Directory structure:
└── cysharp-messagepipe/
    ├── README.md
    ├── Directory.Build.props
    ├── docker-compose.yml
    ├── LICENSE
    ├── MessagePipe.sln
    ├── MessagePipe.sln.startup.json
    ├── NuGet.config
    ├── opensource.snk
    ├── .dockerignore
    ├── .editorconfig
    ├── docs/
    │   └── performance_graph.xlsx
    ├── sandbox/
    │   ├── InterprocessServer/
    │   │   ├── InterprocessServer.csproj
    │   │   └── Program.cs
    │   ├── MessagePipe.AnalyzerTestApp/
    │   │   ├── MessagePipe.AnalyzerTestApp.csproj
    │   │   └── Program.cs
    │   └── MessagePipe.Sandbox.ConsoleApp/
    │       ├── ChangedValueFilter.cs
    │       ├── MessagePipe.Sandbox.ConsoleApp.csproj
    │       ├── NapedPipeTest.cs
    │       ├── Program.cs
    │       ├── TcpTest.cs
    │       └── Properties/
    │           └── launchSettings.json
    ├── src/
    │   ├── MessagePipe/
    │   │   ├── _InternalVisibleTo.cs
    │   │   ├── AsyncMessageBroker.cs
    │   │   ├── AsyncMessageBroker_Key.cs
    │   │   ├── AsyncRequestHandler.cs
    │   │   ├── AttributeFilterProvider.cs
    │   │   ├── DisposableBag.cs
    │   │   ├── Disposables.cs
    │   │   ├── Disposables.tt
    │   │   ├── DistributedSubscriberExtensions.cs
    │   │   ├── EventFactory.cs
    │   │   ├── FilterAttachedAsyncMessageHandlerFactory.cs
    │   │   ├── FilterAttachedAsyncRequestHandlerFactory.cs
    │   │   ├── FilterAttachedMessageHandlerFactory.cs
    │   │   ├── FilterAttachedRequestHandlerFactory.cs
    │   │   ├── GlobalMessagePipe.cs
    │   │   ├── IDistributedPubSub.cs
    │   │   ├── IgnoreAutoRegistration.cs
    │   │   ├── InMemoryDistributedPubSub.cs
    │   │   ├── IPublisherSubscriber.cs
    │   │   ├── IRequestHandler.cs
    │   │   ├── MessageBroker.cs
    │   │   ├── MessageBroker_Key.cs
    │   │   ├── MessagePipe.csproj
    │   │   ├── MessagePipeDiagnosticsInfo.cs
    │   │   ├── MessagePipeFilter.cs
    │   │   ├── MessagePipeOptions.cs
    │   │   ├── PredicateFilter.cs
    │   │   ├── RequestHandler.cs
    │   │   ├── ServiceCollectionExtensions.cs
    │   │   ├── SubscriberExtensions.AsAsyncEnumerable.cs
    │   │   ├── SubscriberExtensions.AsObservable.cs
    │   │   ├── SubscriberExtensions.cs
    │   │   ├── SubscriberExtensions.FirstAsync.cs
    │   │   └── Internal/
    │   │       ├── ArrayUtil.cs
    │   │       ├── AsyncHandlerWhenAll.AwaiterNode.cs
    │   │       ├── AsyncHandlerWhenAll.cs
    │   │       ├── AsyncRequestHandlerWhenAll.Awaiter.cs
    │   │       ├── AsyncRequestHandlerWhenAll.cs
    │   │       ├── FastQueue.cs
    │   │       ├── FilterDefinition.cs
    │   │       ├── FreeList.cs
    │   │       ├── PoolStack.cs
    │   │       ├── Preserve.cs
    │   │       ├── TaskExtensions.cs
    │   │       ├── TypeCollector.cs
    │   │       └── TypeExtensions.cs
    │   ├── MessagePipe.Analyzer/
    │   │   ├── MessagePipe.Analyzer.csproj
    │   │   ├── MessagePipeAnalyzer.cs
    │   │   └── Properties/
    │   │       └── launchSettings.json
    │   ├── MessagePipe.Interprocess/
    │   │   ├── MessageBuilder.cs
    │   │   ├── MessagePipe.Interprocess.csproj
    │   │   ├── MessagePipeInterprocessOptions.cs
    │   │   ├── NamedPipeDistributedPublisherSubscribercs.cs
    │   │   ├── NamedPipeRemoteRequestHandler.cs
    │   │   ├── ServiceCollectionInterprocessExtensions.cs
    │   │   ├── TcpDistributedPublisherSubscriber.cs
    │   │   ├── TcpRemoteRequestHandler.cs
    │   │   ├── UdpDistributedPublisherSubscriber.cs
    │   │   ├── Internal/
    │   │   │   ├── ArrayPoolBufferWriter.cs
    │   │   │   ├── AsyncDisposableBridge.cs
    │   │   │   ├── Preserve.cs
    │   │   │   └── TransformHandler.cs
    │   │   └── Workers/
    │   │       ├── NamedPipeWorker.cs
    │   │       ├── SocketTcpClient.cs
    │   │       ├── SocketUdpClient.cs
    │   │       ├── TcpWorker.cs
    │   │       └── UdpWorker.cs
    │   ├── MessagePipe.Nats/
    │   │   ├── MessagePipe.Nats.csproj
    │   │   ├── MessagePipeNatsOptions.cs
    │   │   ├── NatsConnectionFactory.cs
    │   │   ├── NatsPublisher.cs
    │   │   ├── NatsSubscriber.cs
    │   │   └── ServiceCollectionNatsExtensions.cs
    │   ├── MessagePipe.Redis/
    │   │   ├── MessagePackRedisSerializer.cs
    │   │   ├── MessagePipe.Redis.csproj
    │   │   ├── MessagePipeRedisOptions.cs
    │   │   ├── RedisPubSub.cs
    │   │   ├── ServiceCollectionRedisExtensions.cs
    │   │   └── SingleConnectionMultiplexerFactory.cs
    │   └── MessagePipe.Unity/
    │       ├── Assets/
    │       │   ├── Editor.meta
    │       │   ├── InitTestScene637547097397462845.unity
    │       │   ├── InitTestScene637547097397462845.unity.meta
    │       │   ├── Plugins.meta
    │       │   ├── Scenes.meta
    │       │   ├── Scripts.meta
    │       │   ├── Tests.meta
    │       │   ├── Editor/
    │       │   │   ├── PackageExporter.cs
    │       │   │   └── PackageExporter.cs.meta
    │       │   ├── Plugins/
    │       │   │   ├── MessagePipe.Interprocess.meta
    │       │   │   ├── MessagePipe.meta
    │       │   │   ├── MessagePipe.VContainer.meta
    │       │   │   ├── MessagePipe.Zenject.meta
    │       │   │   ├── System.Buffers.dll.meta
    │       │   │   ├── System.Memory.dll.meta
    │       │   │   ├── System.Runtime.CompilerServices.Unsafe.dll.meta
    │       │   │   ├── System.Threading.Tasks.Extensions.dll.meta
    │       │   │   ├── Zenject.meta
    │       │   │   ├── MessagePipe/
    │       │   │   │   ├── Editor.meta
    │       │   │   │   ├── package.json
    │       │   │   │   ├── package.json.meta
    │       │   │   │   ├── Runtime.meta
    │       │   │   │   ├── Editor/
    │       │   │   │   │   ├── DiagnosticsHelper.cs
    │       │   │   │   │   ├── DiagnosticsHelper.cs.meta
    │       │   │   │   │   ├── MessagePipe.Editor.asmdef
    │       │   │   │   │   ├── MessagePipe.Editor.asmdef.meta
    │       │   │   │   │   ├── MessagePipeDiagnosticsInfoTreeView.cs
    │       │   │   │   │   ├── MessagePipeDiagnosticsInfoTreeView.cs.meta
    │       │   │   │   │   ├── MessagePipeDiagnosticsInfoWindow.cs
    │       │   │   │   │   ├── MessagePipeDiagnosticsInfoWindow.cs.meta
    │       │   │   │   │   ├── SplitterGUILayout.cs
    │       │   │   │   │   └── SplitterGUILayout.cs.meta
    │       │   │   │   └── Runtime/
    │       │   │   │       ├── AsyncMessageBroker.cs
    │       │   │   │       ├── AsyncMessageBroker.cs.meta
    │       │   │   │       ├── AsyncMessageBroker_Key.cs
    │       │   │   │       ├── AsyncMessageBroker_Key.cs.meta
    │       │   │   │       ├── AsyncRequestHandler.cs
    │       │   │   │       ├── AsyncRequestHandler.cs.meta
    │       │   │   │       ├── AttributeFilterProvider.cs
    │       │   │   │       ├── AttributeFilterProvider.cs.meta
    │       │   │   │       ├── DisposableBag.cs
    │       │   │   │       ├── DisposableBag.cs.meta
    │       │   │   │       ├── Disposables.cs
    │       │   │   │       ├── Disposables.cs.meta
    │       │   │   │       ├── DistributedSubscriberExtensions.cs
    │       │   │   │       ├── DistributedSubscriberExtensions.cs.meta
    │       │   │   │       ├── EventFactory.cs
    │       │   │   │       ├── EventFactory.cs.meta
    │       │   │   │       ├── FilterAttachedAsyncMessageHandlerFactory.cs
    │       │   │   │       ├── FilterAttachedAsyncMessageHandlerFactory.cs.meta
    │       │   │   │       ├── FilterAttachedAsyncRequestHandlerFactory.cs
    │       │   │   │       ├── FilterAttachedAsyncRequestHandlerFactory.cs.meta
    │       │   │   │       ├── FilterAttachedMessageHandlerFactory.cs
    │       │   │   │       ├── FilterAttachedMessageHandlerFactory.cs.meta
    │       │   │   │       ├── FilterAttachedRequestHandlerFactory.cs
    │       │   │   │       ├── FilterAttachedRequestHandlerFactory.cs.meta
    │       │   │   │       ├── GlobalMessagePipe.cs
    │       │   │   │       ├── GlobalMessagePipe.cs.meta
    │       │   │   │       ├── IDistributedPubSub.cs
    │       │   │   │       ├── IDistributedPubSub.cs.meta
    │       │   │   │       ├── IgnoreAutoRegistration.cs
    │       │   │   │       ├── IgnoreAutoRegistration.cs.meta
    │       │   │   │       ├── InMemoryDistributedPubSub.cs
    │       │   │   │       ├── InMemoryDistributedPubSub.cs.meta
    │       │   │   │       ├── Internal.meta
    │       │   │   │       ├── IPublisherSubscriber.cs
    │       │   │   │       ├── IPublisherSubscriber.cs.meta
    │       │   │   │       ├── IRequestHandler.cs
    │       │   │   │       ├── IRequestHandler.cs.meta
    │       │   │   │       ├── MessageBroker.cs
    │       │   │   │       ├── MessageBroker.cs.meta
    │       │   │   │       ├── MessageBroker_Key.cs
    │       │   │   │       ├── MessageBroker_Key.cs.meta
    │       │   │   │       ├── MessagePipe.asmdef
    │       │   │   │       ├── MessagePipe.asmdef.meta
    │       │   │   │       ├── MessagePipeDiagnosticsInfo.cs
    │       │   │   │       ├── MessagePipeDiagnosticsInfo.cs.meta
    │       │   │   │       ├── MessagePipeFilter.cs
    │       │   │   │       ├── MessagePipeFilter.cs.meta
    │       │   │   │       ├── MessagePipeOptions.cs
    │       │   │   │       ├── MessagePipeOptions.cs.meta
    │       │   │   │       ├── PredicateFilter.cs
    │       │   │   │       ├── PredicateFilter.cs.meta
    │       │   │   │       ├── RequestHandler.cs
    │       │   │   │       ├── RequestHandler.cs.meta
    │       │   │   │       ├── ServiceCollectionExtensions.cs
    │       │   │   │       ├── ServiceCollectionExtensions.cs.meta
    │       │   │   │       ├── SubscriberExtensions.AsAsyncEnumerable.cs
    │       │   │   │       ├── SubscriberExtensions.AsAsyncEnumerable.cs.meta
    │       │   │   │       ├── SubscriberExtensions.AsObservable.cs
    │       │   │   │       ├── SubscriberExtensions.AsObservable.cs.meta
    │       │   │   │       ├── SubscriberExtensions.cs
    │       │   │   │       ├── SubscriberExtensions.cs.meta
    │       │   │   │       ├── SubscriberExtensions.FirstAsync.cs
    │       │   │   │       ├── SubscriberExtensions.FirstAsync.cs.meta
    │       │   │   │       ├── Unity.meta
    │       │   │   │       ├── Internal/
    │       │   │   │       │   ├── ArrayUtil.cs
    │       │   │   │       │   ├── ArrayUtil.cs.meta
    │       │   │   │       │   ├── AsyncHandlerWhenAll.AwaiterNode.cs
    │       │   │   │       │   ├── AsyncHandlerWhenAll.AwaiterNode.cs.meta
    │       │   │   │       │   ├── AsyncHandlerWhenAll.cs
    │       │   │   │       │   ├── AsyncHandlerWhenAll.cs.meta
    │       │   │   │       │   ├── AsyncRequestHandlerWhenAll.Awaiter.cs
    │       │   │   │       │   ├── AsyncRequestHandlerWhenAll.Awaiter.cs.meta
    │       │   │   │       │   ├── AsyncRequestHandlerWhenAll.cs
    │       │   │   │       │   ├── AsyncRequestHandlerWhenAll.cs.meta
    │       │   │   │       │   ├── FastQueue.cs
    │       │   │   │       │   ├── FastQueue.cs.meta
    │       │   │   │       │   ├── FilterDefinition.cs
    │       │   │   │       │   ├── FilterDefinition.cs.meta
    │       │   │   │       │   ├── FreeList.cs
    │       │   │   │       │   ├── FreeList.cs.meta
    │       │   │   │       │   ├── PoolStack.cs
    │       │   │   │       │   ├── PoolStack.cs.meta
    │       │   │   │       │   ├── Preserve.cs
    │       │   │   │       │   ├── Preserve.cs.meta
    │       │   │   │       │   ├── TaskExtensions.cs
    │       │   │   │       │   ├── TaskExtensions.cs.meta
    │       │   │   │       │   ├── TypeCollector.cs
    │       │   │   │       │   ├── TypeCollector.cs.meta
    │       │   │   │       │   ├── TypeExtensions.cs
    │       │   │   │       │   └── TypeExtensions.cs.meta
    │       │   │   │       └── Unity/
    │       │   │   │           ├── BuiltinContainerBuilder.cs
    │       │   │   │           ├── BuiltinContainerBuilder.cs.meta
    │       │   │   │           ├── DependencyInjectionShims.cs
    │       │   │   │           ├── DependencyInjectionShims.cs.meta
    │       │   │   │           ├── InternalVisibleTo.cs
    │       │   │   │           ├── InternalVisibleTo.cs.meta
    │       │   │   │           ├── TaskShims.cs
    │       │   │   │           └── TaskShims.cs.meta
    │       │   │   ├── MessagePipe.Interprocess/
    │       │   │   │   ├── package.json
    │       │   │   │   ├── package.json.meta
    │       │   │   │   ├── Runtime.meta
    │       │   │   │   └── Runtime/
    │       │   │   │       ├── Internal.meta
    │       │   │   │       ├── MessageBuilder.cs
    │       │   │   │       ├── MessageBuilder.cs.meta
    │       │   │   │       ├── MessagePipe.Interprocess.asmdef
    │       │   │   │       ├── MessagePipe.Interprocess.asmdef.meta
    │       │   │   │       ├── MessagePipeInterprocessOptions.cs
    │       │   │   │       ├── MessagePipeInterprocessOptions.cs.meta
    │       │   │   │       ├── NamedPipeDistributedPublisherSubscribercs.cs
    │       │   │   │       ├── NamedPipeDistributedPublisherSubscribercs.cs.meta
    │       │   │   │       ├── NamedPipeRemoteRequestHandler.cs
    │       │   │   │       ├── NamedPipeRemoteRequestHandler.cs.meta
    │       │   │   │       ├── ServiceCollectionInterprocessExtensions.cs
    │       │   │   │       ├── ServiceCollectionInterprocessExtensions.cs.meta
    │       │   │   │       ├── TcpDistributedPublisherSubscriber.cs
    │       │   │   │       ├── TcpDistributedPublisherSubscriber.cs.meta
    │       │   │   │       ├── TcpRemoteRequestHandler.cs
    │       │   │   │       ├── TcpRemoteRequestHandler.cs.meta
    │       │   │   │       ├── UdpDistributedPublisherSubscriber.cs
    │       │   │   │       ├── UdpDistributedPublisherSubscriber.cs.meta
    │       │   │   │       ├── Unity.meta
    │       │   │   │       ├── Workers.meta
    │       │   │   │       ├── Internal/
    │       │   │   │       │   ├── ArrayPoolBufferWriter.cs
    │       │   │   │       │   ├── ArrayPoolBufferWriter.cs.meta
    │       │   │   │       │   ├── AsyncDisposableBridge.cs
    │       │   │   │       │   ├── AsyncDisposableBridge.cs.meta
    │       │   │   │       │   ├── Preserve.cs
    │       │   │   │       │   ├── Preserve.cs.meta
    │       │   │   │       │   ├── TransformHandler.cs
    │       │   │   │       │   └── TransformHandler.cs.meta
    │       │   │   │       ├── Unity/
    │       │   │   │       │   ├── TaskShims.cs
    │       │   │   │       │   └── TaskShims.cs.meta
    │       │   │   │       └── Workers/
    │       │   │   │           ├── NamedPipeWorker.cs
    │       │   │   │           ├── NamedPipeWorker.cs.meta
    │       │   │   │           ├── SocketTcpClient.cs
    │       │   │   │           ├── SocketTcpClient.cs.meta
    │       │   │   │           ├── SocketUdpClient.cs
    │       │   │   │           ├── SocketUdpClient.cs.meta
    │       │   │   │           ├── TcpWorker.cs
    │       │   │   │           ├── TcpWorker.cs.meta
    │       │   │   │           ├── UdpWorker.cs
    │       │   │   │           └── UdpWorker.cs.meta
    │       │   │   ├── MessagePipe.VContainer/
    │       │   │   │   ├── package.json
    │       │   │   │   ├── package.json.meta
    │       │   │   │   ├── Runtime.meta
    │       │   │   │   └── Runtime/
    │       │   │   │       ├── ContainerBuilderExtensions.cs
    │       │   │   │       ├── ContainerBuilderExtensions.cs.meta
    │       │   │   │       ├── MessagePipe.VContainer.asmdef
    │       │   │   │       ├── MessagePipe.VContainer.asmdef.meta
    │       │   │   │       ├── TypeProxy.cs
    │       │   │   │       └── TypeProxy.cs.meta
    │       │   │   ├── MessagePipe.Zenject/
    │       │   │   │   ├── package.json
    │       │   │   │   ├── package.json.meta
    │       │   │   │   ├── Runtime.meta
    │       │   │   │   └── Runtime/
    │       │   │   │       ├── DiContainerExtensions.cs
    │       │   │   │       ├── DiContainerExtensions.cs.meta
    │       │   │   │       ├── MessagePipe.Zenject.asmdef
    │       │   │   │       ├── MessagePipe.Zenject.asmdef.meta
    │       │   │   │       ├── TypeProxy.cs
    │       │   │   │       └── TypeProxy.cs.meta
    │       │   │   └── Zenject/
    │       │   │       ├── ReadMe.url
    │       │   │       ├── ReadMe.url.meta
    │       │   │       ├── LICENSE.txt
    │       │   │       ├── LICENSE.txt.meta
    │       │   │       ├── package.json
    │       │   │       ├── package.json.meta
    │       │   │       ├── Source.meta
    │       │   │       ├── Version.txt
    │       │   │       ├── Version.txt.meta
    │       │   │       ├── zenject.asmdef
    │       │   │       ├── zenject.asmdef.meta
    │       │   │       └── Source/
    │       │   │           ├── Binding.meta
    │       │   │           ├── Editor.meta
    │       │   │           ├── Factories.meta
    │       │   │           ├── Injection.meta
    │       │   │           ├── Install.meta
    │       │   │           ├── Internal.meta
    │       │   │           ├── Main.meta
    │       │   │           ├── Providers.meta
    │       │   │           ├── Runtime.meta
    │       │   │           ├── Usage.meta
    │       │   │           ├── Util.meta
    │       │   │           ├── Validation.meta
    │       │   │           ├── Zenject.csproj
    │       │   │           ├── Zenject.csproj.meta
    │       │   │           ├── Binding/
    │       │   │           │   ├── Binders.meta
    │       │   │           │   ├── BindInfo.meta
    │       │   │           │   ├── BindingUtil.cs
    │       │   │           │   ├── BindingUtil.cs.meta
    │       │   │           │   ├── Finalizers.meta
    │       │   │           │   ├── Binders/
    │       │   │           │   │   ├── ArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── ArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── ConcreteBinders.meta
    │       │   │           │   │   ├── ConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── ConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── ConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── ConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── Conventions.meta
    │       │   │           │   │   ├── CopyNonLazyBinder.cs
    │       │   │           │   │   ├── CopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── Factory.meta
    │       │   │           │   │   ├── FromBinders.meta
    │       │   │           │   │   ├── GameObject.meta
    │       │   │           │   │   ├── IdBinder.cs
    │       │   │           │   │   ├── IdBinder.cs.meta
    │       │   │           │   │   ├── IdScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── IdScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── IfNotBoundBinder.cs
    │       │   │           │   │   ├── IfNotBoundBinder.cs.meta
    │       │   │           │   │   ├── InstantiateCallbackConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── InstantiateCallbackConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── NonLazyBinder.cs
    │       │   │           │   │   ├── NonLazyBinder.cs.meta
    │       │   │           │   │   ├── ScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── ScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── SubContainerBinder.cs
    │       │   │           │   │   ├── SubContainerBinder.cs.meta
    │       │   │           │   │   ├── WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │   ├── WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │   ├── ConcreteBinders/
    │       │   │           │   │   │   ├── ConcreteBinderGeneric.cs
    │       │   │           │   │   │   ├── ConcreteBinderGeneric.cs.meta
    │       │   │           │   │   │   ├── ConcreteBinderNonGeneric.cs
    │       │   │           │   │   │   ├── ConcreteBinderNonGeneric.cs.meta
    │       │   │           │   │   │   ├── ConcreteIdBinderGeneric.cs
    │       │   │           │   │   │   ├── ConcreteIdBinderGeneric.cs.meta
    │       │   │           │   │   │   ├── ConcreteIdBinderNonGeneric.cs
    │       │   │           │   │   │   └── ConcreteIdBinderNonGeneric.cs.meta
    │       │   │           │   │   ├── Conventions/
    │       │   │           │   │   │   ├── ConventionAssemblySelectionBinder.cs
    │       │   │           │   │   │   ├── ConventionAssemblySelectionBinder.cs.meta
    │       │   │           │   │   │   ├── ConventionBindInfo.cs
    │       │   │           │   │   │   ├── ConventionBindInfo.cs.meta
    │       │   │           │   │   │   ├── ConventionFilterTypesBinder.cs
    │       │   │           │   │   │   ├── ConventionFilterTypesBinder.cs.meta
    │       │   │           │   │   │   ├── ConventionSelectTypesBinder.cs
    │       │   │           │   │   │   └── ConventionSelectTypesBinder.cs.meta
    │       │   │           │   │   ├── Factory/
    │       │   │           │   │   │   ├── FactoryArgumentsToChoiceBinder.meta
    │       │   │           │   │   │   ├── FactoryFromBinder.meta
    │       │   │           │   │   │   ├── FactoryFromBinderBase.cs
    │       │   │           │   │   │   ├── FactoryFromBinderBase.cs.meta
    │       │   │           │   │   │   ├── FactoryToChoiceBinder.meta
    │       │   │           │   │   │   ├── FactoryToChoiceIdBinder.meta
    │       │   │           │   │   │   ├── PlaceholderFactoryBindingFinalizer.cs
    │       │   │           │   │   │   ├── PlaceholderFactoryBindingFinalizer.cs.meta
    │       │   │           │   │   │   ├── Pooling.meta
    │       │   │           │   │   │   ├── FactoryArgumentsToChoiceBinder/
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder0.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder0.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder1.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder1.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder10.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder10.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder2.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder2.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder3.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder3.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder4.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder4.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder5.cs
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder5.cs.meta
    │       │   │           │   │   │   │   ├── FactoryArgumentsToChoiceBinder6.cs
    │       │   │           │   │   │   │   └── FactoryArgumentsToChoiceBinder6.cs.meta
    │       │   │           │   │   │   ├── FactoryFromBinder/
    │       │   │           │   │   │   │   ├── FactoryFromBinder0.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder0.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder1.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder1.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder10.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder10.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder2.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder2.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder3.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder3.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder4.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder4.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder5.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder5.cs.meta
    │       │   │           │   │   │   │   ├── FactoryFromBinder6.cs
    │       │   │           │   │   │   │   ├── FactoryFromBinder6.cs.meta
    │       │   │           │   │   │   │   ├── SubContainerBinder.meta
    │       │   │           │   │   │   │   ├── Untyped.meta
    │       │   │           │   │   │   │   ├── SubContainerBinder/
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder0.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder0.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder1.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder1.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder10.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder10.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder2.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder2.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder3.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder3.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder4.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder4.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder5.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder5.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder6.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinder6.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinderBase.cs
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinderBase.cs.meta
    │       │   │           │   │   │   │   │   ├── FactorySubContainerBinderWithParams.cs
    │       │   │           │   │   │   │   │   └── FactorySubContainerBinderWithParams.cs.meta
    │       │   │           │   │   │   │   └── Untyped/
    │       │   │           │   │   │   │       ├── FactoryFromBinderUntyped.cs
    │       │   │           │   │   │   │       └── FactoryFromBinderUntyped.cs.meta
    │       │   │           │   │   │   ├── FactoryToChoiceBinder/
    │       │   │           │   │   │   │   ├── DecoratorToChoiceFromBinder.cs
    │       │   │           │   │   │   │   ├── DecoratorToChoiceFromBinder.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder0.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder0.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder1.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder1.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder10.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder10.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder2.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder2.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder3.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder3.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder4.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder4.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder5.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder5.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceBinder6.cs
    │       │   │           │   │   │   │   └── FactoryToChoiceBinder6.cs.meta
    │       │   │           │   │   │   ├── FactoryToChoiceIdBinder/
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder0.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder0.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder1.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder1.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder10.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder10.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder2.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder2.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder3.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder3.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder4.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder4.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder5.cs
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder5.cs.meta
    │       │   │           │   │   │   │   ├── FactoryToChoiceIdBinder6.cs
    │       │   │           │   │   │   │   └── FactoryToChoiceIdBinder6.cs.meta
    │       │   │           │   │   │   └── Pooling/
    │       │   │           │   │   │       ├── MemoryPoolBindingFinalizer.cs
    │       │   │           │   │   │       ├── MemoryPoolBindingFinalizer.cs.meta
    │       │   │           │   │   │       ├── MemoryPoolExpandBinder.cs
    │       │   │           │   │   │       ├── MemoryPoolExpandBinder.cs.meta
    │       │   │           │   │   │       ├── MemoryPoolInitialSizeBinder.cs
    │       │   │           │   │   │       └── MemoryPoolInitialSizeBinder.cs.meta
    │       │   │           │   │   ├── FromBinders/
    │       │   │           │   │   │   ├── FromBinder.cs
    │       │   │           │   │   │   ├── FromBinder.cs.meta
    │       │   │           │   │   │   ├── FromBinderGeneric.cs
    │       │   │           │   │   │   ├── FromBinderGeneric.cs.meta
    │       │   │           │   │   │   ├── FromBinderNonGeneric.cs
    │       │   │           │   │   │   └── FromBinderNonGeneric.cs.meta
    │       │   │           │   │   └── GameObject/
    │       │   │           │   │       ├── NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │       ├── NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   │       ├── TransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs
    │       │   │           │   │       └── TransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
    │       │   │           │   ├── BindInfo/
    │       │   │           │   │   ├── BindInfo.cs
    │       │   │           │   │   ├── BindInfo.cs.meta
    │       │   │           │   │   ├── BindStatement.cs
    │       │   │           │   │   ├── BindStatement.cs.meta
    │       │   │           │   │   ├── FactoryBindInfo.cs
    │       │   │           │   │   ├── FactoryBindInfo.cs.meta
    │       │   │           │   │   ├── GameObjectCreationParameters.cs
    │       │   │           │   │   ├── GameObjectCreationParameters.cs.meta
    │       │   │           │   │   ├── MemoryPoolBindInfo.cs
    │       │   │           │   │   └── MemoryPoolBindInfo.cs.meta
    │       │   │           │   └── Finalizers/
    │       │   │           │       ├── IBindingFinalizer.cs
    │       │   │           │       ├── IBindingFinalizer.cs.meta
    │       │   │           │       ├── NullBindingFinalizer.cs
    │       │   │           │       ├── NullBindingFinalizer.cs.meta
    │       │   │           │       ├── PrefabBindingFinalizer.cs
    │       │   │           │       ├── PrefabBindingFinalizer.cs.meta
    │       │   │           │       ├── PrefabResourceBindingFinalizer.cs
    │       │   │           │       ├── PrefabResourceBindingFinalizer.cs.meta
    │       │   │           │       ├── ProviderBindingFinalizer.cs
    │       │   │           │       ├── ProviderBindingFinalizer.cs.meta
    │       │   │           │       ├── ScopableBindingFinalizer.cs
    │       │   │           │       ├── ScopableBindingFinalizer.cs.meta
    │       │   │           │       ├── SingleProviderBindingFinalizer.cs
    │       │   │           │       ├── SingleProviderBindingFinalizer.cs.meta
    │       │   │           │       ├── SubContainerBindingFinalizer.cs
    │       │   │           │       ├── SubContainerBindingFinalizer.cs.meta
    │       │   │           │       ├── SubContainerPrefabBindingFinalizer.cs
    │       │   │           │       └── SubContainerPrefabBindingFinalizer.cs.meta
    │       │   │           ├── Editor/
    │       │   │           │   ├── Editors.meta
    │       │   │           │   ├── EditorStaticInstaller.cs
    │       │   │           │   ├── EditorStaticInstaller.cs.meta
    │       │   │           │   ├── EditorWindow.meta
    │       │   │           │   ├── ObjectGraphVisualizer.cs
    │       │   │           │   ├── ObjectGraphVisualizer.cs.meta
    │       │   │           │   ├── SceneParentLoading.meta
    │       │   │           │   ├── UnityInspectorListEditor.cs
    │       │   │           │   ├── UnityInspectorListEditor.cs.meta
    │       │   │           │   ├── Zenject-Editor.asmdef
    │       │   │           │   ├── Zenject-Editor.asmdef.meta
    │       │   │           │   ├── ZenMenuItems.cs
    │       │   │           │   ├── ZenMenuItems.cs.meta
    │       │   │           │   ├── ZenUnityEditorUtil.cs
    │       │   │           │   ├── ZenUnityEditorUtil.cs.meta
    │       │   │           │   ├── Editors/
    │       │   │           │   │   ├── ContextEditor.cs
    │       │   │           │   │   ├── ContextEditor.cs.meta
    │       │   │           │   │   ├── GameObjectContextEditor.cs
    │       │   │           │   │   ├── GameObjectContextEditor.cs.meta
    │       │   │           │   │   ├── ProjectContextEditor.cs
    │       │   │           │   │   ├── ProjectContextEditor.cs.meta
    │       │   │           │   │   ├── RunnableContextEditor.cs
    │       │   │           │   │   ├── RunnableContextEditor.cs.meta
    │       │   │           │   │   ├── SceneContextEditor.cs
    │       │   │           │   │   ├── SceneContextEditor.cs.meta
    │       │   │           │   │   ├── SceneDecoratorContextEditor.cs
    │       │   │           │   │   └── SceneDecoratorContextEditor.cs.meta
    │       │   │           │   ├── EditorWindow/
    │       │   │           │   │   ├── ZenjectEditorWindow.cs
    │       │   │           │   │   └── ZenjectEditorWindow.cs.meta
    │       │   │           │   └── SceneParentLoading/
    │       │   │           │       ├── DefaultSceneContractConfig.cs
    │       │   │           │       ├── DefaultSceneContractConfig.cs.meta
    │       │   │           │       ├── SceneParentAutomaticLoader.cs
    │       │   │           │       └── SceneParentAutomaticLoader.cs.meta
    │       │   │           ├── Factories/
    │       │   │           │   ├── FactoryProviderWrapper.cs
    │       │   │           │   ├── FactoryProviderWrapper.cs.meta
    │       │   │           │   ├── IFactory.cs
    │       │   │           │   ├── IFactory.cs.meta
    │       │   │           │   ├── KeyedFactory.cs
    │       │   │           │   ├── KeyedFactory.cs.meta
    │       │   │           │   ├── PlaceholderFactory.cs
    │       │   │           │   ├── PlaceholderFactory.cs.meta
    │       │   │           │   ├── PlaceholderFactoryBase.cs
    │       │   │           │   ├── PlaceholderFactoryBase.cs.meta
    │       │   │           │   ├── Pooling.meta
    │       │   │           │   ├── PrefabFactory.cs
    │       │   │           │   ├── PrefabFactory.cs.meta
    │       │   │           │   ├── PrefabResourceFactory.cs
    │       │   │           │   ├── PrefabResourceFactory.cs.meta
    │       │   │           │   └── Pooling/
    │       │   │           │       ├── IMemoryPool.cs
    │       │   │           │       ├── IMemoryPool.cs.meta
    │       │   │           │       ├── MemoryPool.cs
    │       │   │           │       ├── MemoryPool.cs.meta
    │       │   │           │       ├── MemoryPoolBase.cs
    │       │   │           │       ├── MemoryPoolBase.cs.meta
    │       │   │           │       ├── MonoMemoryPool.cs
    │       │   │           │       ├── MonoMemoryPool.cs.meta
    │       │   │           │       ├── MonoPoolableMemoryPool.cs
    │       │   │           │       ├── MonoPoolableMemoryPool.cs.meta
    │       │   │           │       ├── PoolableMemoryPool.cs
    │       │   │           │       ├── PoolableMemoryPool.cs.meta
    │       │   │           │       ├── PoolFactory.cs
    │       │   │           │       ├── PoolFactory.cs.meta
    │       │   │           │       ├── Static.meta
    │       │   │           │       ├── Util.meta
    │       │   │           │       ├── Static/
    │       │   │           │       │   ├── PoolableStaticMemoryPool.cs
    │       │   │           │       │   ├── PoolableStaticMemoryPool.cs.meta
    │       │   │           │       │   ├── StaticMemoryPool.cs
    │       │   │           │       │   └── StaticMemoryPool.cs.meta
    │       │   │           │       └── Util/
    │       │   │           │           ├── ArrayPool.cs
    │       │   │           │           ├── ArrayPool.cs.meta
    │       │   │           │           ├── DictionaryPool.cs
    │       │   │           │           ├── DictionaryPool.cs.meta
    │       │   │           │           ├── HashSetPool.cs
    │       │   │           │           ├── HashSetPool.cs.meta
    │       │   │           │           ├── ListPool.cs
    │       │   │           │           ├── ListPool.cs.meta
    │       │   │           │           ├── PoolCleanupChecker.cs
    │       │   │           │           ├── PoolCleanupChecker.cs.meta
    │       │   │           │           ├── StaticMemoryPoolRegistry.cs
    │       │   │           │           └── StaticMemoryPoolRegistry.cs.meta
    │       │   │           ├── Injection/
    │       │   │           │   ├── InjectContext.cs
    │       │   │           │   ├── InjectContext.cs.meta
    │       │   │           │   ├── InjectUtil.cs
    │       │   │           │   ├── InjectUtil.cs.meta
    │       │   │           │   ├── LazyInject.cs
    │       │   │           │   └── LazyInject.cs.meta
    │       │   │           ├── Install/
    │       │   │           │   ├── Contexts.meta
    │       │   │           │   ├── IInstaller.cs
    │       │   │           │   ├── IInstaller.cs.meta
    │       │   │           │   ├── Installer.cs
    │       │   │           │   ├── Installer.cs.meta
    │       │   │           │   ├── InstallerBase.cs
    │       │   │           │   ├── InstallerBase.cs.meta
    │       │   │           │   ├── MonoInstaller.cs
    │       │   │           │   ├── MonoInstaller.cs.meta
    │       │   │           │   ├── MonoInstallerBase.cs
    │       │   │           │   ├── MonoInstallerBase.cs.meta
    │       │   │           │   ├── ScriptableObjectInstaller.cs
    │       │   │           │   ├── ScriptableObjectInstaller.cs.meta
    │       │   │           │   ├── ScriptableObjectInstallerBase.cs
    │       │   │           │   ├── ScriptableObjectInstallerBase.cs.meta
    │       │   │           │   ├── ZenjectBinding.cs
    │       │   │           │   ├── ZenjectBinding.cs.meta
    │       │   │           │   ├── ZenjectManagersInstaller.cs
    │       │   │           │   ├── ZenjectManagersInstaller.cs.meta
    │       │   │           │   └── Contexts/
    │       │   │           │       ├── Context.cs
    │       │   │           │       ├── Context.cs.meta
    │       │   │           │       ├── GameObjectContext.cs
    │       │   │           │       ├── GameObjectContext.cs.meta
    │       │   │           │       ├── ProjectContext.cs
    │       │   │           │       ├── ProjectContext.cs.meta
    │       │   │           │       ├── RunnableContext.cs
    │       │   │           │       ├── RunnableContext.cs.meta
    │       │   │           │       ├── SceneContext.cs
    │       │   │           │       ├── SceneContext.cs.meta
    │       │   │           │       ├── SceneDecoratorContext.cs
    │       │   │           │       ├── SceneDecoratorContext.cs.meta
    │       │   │           │       ├── StaticContext.cs
    │       │   │           │       └── StaticContext.cs.meta
    │       │   │           ├── Internal/
    │       │   │           │   ├── Assert.cs
    │       │   │           │   ├── Assert.cs.meta
    │       │   │           │   ├── Func.cs
    │       │   │           │   ├── Func.cs.meta
    │       │   │           │   ├── LinqExtensions.cs
    │       │   │           │   ├── LinqExtensions.cs.meta
    │       │   │           │   ├── Log.cs
    │       │   │           │   ├── Log.cs.meta
    │       │   │           │   ├── MiscExtensions.cs
    │       │   │           │   ├── MiscExtensions.cs.meta
    │       │   │           │   ├── PreserveAttribute.cs
    │       │   │           │   ├── PreserveAttribute.cs.meta
    │       │   │           │   ├── TypeExtensions.cs
    │       │   │           │   ├── TypeExtensions.cs.meta
    │       │   │           │   ├── TypeStringFormatter.cs
    │       │   │           │   ├── TypeStringFormatter.cs.meta
    │       │   │           │   ├── ValuePair.cs
    │       │   │           │   └── ValuePair.cs.meta
    │       │   │           ├── Main/
    │       │   │           │   ├── BindingId.cs
    │       │   │           │   ├── BindingId.cs.meta
    │       │   │           │   ├── DiContainer.cs.meta
    │       │   │           │   ├── IInstantiator.cs
    │       │   │           │   ├── IInstantiator.cs.meta
    │       │   │           │   ├── LazyInstanceInjector.cs
    │       │   │           │   ├── LazyInstanceInjector.cs.meta
    │       │   │           │   ├── LookupId.cs
    │       │   │           │   ├── LookupId.cs.meta
    │       │   │           │   ├── SingletonMarkRegistry.cs
    │       │   │           │   ├── SingletonMarkRegistry.cs.meta
    │       │   │           │   ├── ZenjectSettings.cs
    │       │   │           │   └── ZenjectSettings.cs.meta
    │       │   │           ├── Providers/
    │       │   │           │   ├── CachedOpenTypeProvider.cs
    │       │   │           │   ├── CachedOpenTypeProvider.cs.meta
    │       │   │           │   ├── CachedProvider.cs
    │       │   │           │   ├── CachedProvider.cs.meta
    │       │   │           │   ├── ComponentProviders.meta
    │       │   │           │   ├── Decorator.meta
    │       │   │           │   ├── GameObjectProviders.meta
    │       │   │           │   ├── GetterProvider.cs
    │       │   │           │   ├── GetterProvider.cs.meta
    │       │   │           │   ├── IFactoryProvider.cs
    │       │   │           │   ├── IFactoryProvider.cs.meta
    │       │   │           │   ├── InstanceProvider.cs
    │       │   │           │   ├── InstanceProvider.cs.meta
    │       │   │           │   ├── IProvider.cs
    │       │   │           │   ├── IProvider.cs.meta
    │       │   │           │   ├── IProviderExtensions.cs
    │       │   │           │   ├── IProviderExtensions.cs.meta
    │       │   │           │   ├── MethodMultipleProviderUntyped.cs
    │       │   │           │   ├── MethodMultipleProviderUntyped.cs.meta
    │       │   │           │   ├── MethodProvider.cs
    │       │   │           │   ├── MethodProvider.cs.meta
    │       │   │           │   ├── MethodProviderMultiple.cs
    │       │   │           │   ├── MethodProviderMultiple.cs.meta
    │       │   │           │   ├── MethodProviderSimple.cs
    │       │   │           │   ├── MethodProviderSimple.cs.meta
    │       │   │           │   ├── MethodProviderUntyped.cs
    │       │   │           │   ├── MethodProviderUntyped.cs.meta
    │       │   │           │   ├── MethodProviderWithContainer.cs
    │       │   │           │   ├── MethodProviderWithContainer.cs.meta
    │       │   │           │   ├── PoolableMemoryPoolProvider.cs
    │       │   │           │   ├── PoolableMemoryPoolProvider.cs.meta
    │       │   │           │   ├── PrefabCreators.meta
    │       │   │           │   ├── PrefabProviders.meta
    │       │   │           │   ├── ProviderUtil.cs
    │       │   │           │   ├── ProviderUtil.cs.meta
    │       │   │           │   ├── ResolveProvider.cs
    │       │   │           │   ├── ResolveProvider.cs.meta
    │       │   │           │   ├── ResourceProvider.cs
    │       │   │           │   ├── ResourceProvider.cs.meta
    │       │   │           │   ├── ScriptableObjectInstanceProvider.cs
    │       │   │           │   ├── ScriptableObjectInstanceProvider.cs.meta
    │       │   │           │   ├── ScriptableObjectResourceProvider.cs
    │       │   │           │   ├── ScriptableObjectResourceProvider.cs.meta
    │       │   │           │   ├── SubContainerCreators.meta
    │       │   │           │   ├── SubContainerDependencyProvider.cs
    │       │   │           │   ├── SubContainerDependencyProvider.cs.meta
    │       │   │           │   ├── TransientProvider.cs
    │       │   │           │   ├── TransientProvider.cs.meta
    │       │   │           │   ├── ComponentProviders/
    │       │   │           │   │   ├── AddToGameObjectComponentProviders.meta
    │       │   │           │   │   ├── GetFromGameObjectComponentProvider.cs
    │       │   │           │   │   ├── GetFromGameObjectComponentProvider.cs.meta
    │       │   │           │   │   ├── GetFromGameObjectGetterComponentProvider.cs
    │       │   │           │   │   ├── GetFromGameObjectGetterComponentProvider.cs.meta
    │       │   │           │   │   ├── GetFromPrefabComponentProvider.cs
    │       │   │           │   │   ├── GetFromPrefabComponentProvider.cs.meta
    │       │   │           │   │   ├── InstantiateOnPrefabComponentProvider.cs
    │       │   │           │   │   ├── InstantiateOnPrefabComponentProvider.cs.meta
    │       │   │           │   │   └── AddToGameObjectComponentProviders/
    │       │   │           │   │       ├── AddToCurrentGameObjectComponentProvider.cs
    │       │   │           │   │       ├── AddToCurrentGameObjectComponentProvider.cs.meta
    │       │   │           │   │       ├── AddToExistingGameObjectComponentProvider.cs
    │       │   │           │   │       ├── AddToExistingGameObjectComponentProvider.cs.meta
    │       │   │           │   │       ├── AddToGameObjectComponentProviderBase.cs
    │       │   │           │   │       ├── AddToGameObjectComponentProviderBase.cs.meta
    │       │   │           │   │       ├── AddToNewGameObjectComponentProvider.cs
    │       │   │           │   │       └── AddToNewGameObjectComponentProvider.cs.meta
    │       │   │           │   ├── Decorator/
    │       │   │           │   │   ├── DecoratorProvider.cs
    │       │   │           │   │   └── DecoratorProvider.cs.meta
    │       │   │           │   ├── GameObjectProviders/
    │       │   │           │   │   ├── EmptyGameObjectProvider.cs
    │       │   │           │   │   ├── EmptyGameObjectProvider.cs.meta
    │       │   │           │   │   ├── PrefabGameObjectProvider.cs
    │       │   │           │   │   └── PrefabGameObjectProvider.cs.meta
    │       │   │           │   ├── PrefabCreators/
    │       │   │           │   │   ├── IPrefabInstantiator.cs
    │       │   │           │   │   ├── IPrefabInstantiator.cs.meta
    │       │   │           │   │   ├── PrefabInstantiator.cs
    │       │   │           │   │   ├── PrefabInstantiator.cs.meta
    │       │   │           │   │   ├── PrefabInstantiatorCached.cs
    │       │   │           │   │   └── PrefabInstantiatorCached.cs.meta
    │       │   │           │   ├── PrefabProviders/
    │       │   │           │   │   ├── IPrefabProvider.cs
    │       │   │           │   │   ├── IPrefabProvider.cs.meta
    │       │   │           │   │   ├── PrefabProvider.cs
    │       │   │           │   │   ├── PrefabProvider.cs.meta
    │       │   │           │   │   ├── PrefabProviderCustom.cs
    │       │   │           │   │   ├── PrefabProviderCustom.cs.meta
    │       │   │           │   │   ├── PrefabProviderResource.cs
    │       │   │           │   │   └── PrefabProviderResource.cs.meta
    │       │   │           │   └── SubContainerCreators/
    │       │   │           │       ├── ISubContainerCreator.cs
    │       │   │           │       ├── ISubContainerCreator.cs.meta
    │       │   │           │       ├── SubContainerCreatorBindInfo.cs
    │       │   │           │       ├── SubContainerCreatorBindInfo.cs.meta
    │       │   │           │       ├── SubContainerCreatorByInstaller.cs
    │       │   │           │       ├── SubContainerCreatorByInstaller.cs.meta
    │       │   │           │       ├── SubContainerCreatorByInstance.cs
    │       │   │           │       ├── SubContainerCreatorByInstance.cs.meta
    │       │   │           │       ├── SubContainerCreatorByInstanceGetter.cs
    │       │   │           │       ├── SubContainerCreatorByInstanceGetter.cs.meta
    │       │   │           │       ├── SubContainerCreatorByMethod.cs
    │       │   │           │       ├── SubContainerCreatorByMethod.cs.meta
    │       │   │           │       ├── SubContainerCreatorByNewGameObjectDynamicContext.cs
    │       │   │           │       ├── SubContainerCreatorByNewGameObjectDynamicContext.cs.meta
    │       │   │           │       ├── SubContainerCreatorByNewPrefab.cs
    │       │   │           │       ├── SubContainerCreatorByNewPrefab.cs.meta
    │       │   │           │       ├── SubContainerCreatorByNewPrefabDynamicContext.cs
    │       │   │           │       ├── SubContainerCreatorByNewPrefabDynamicContext.cs.meta
    │       │   │           │       ├── SubContainerCreatorByNewPrefabWithParams.cs
    │       │   │           │       ├── SubContainerCreatorByNewPrefabWithParams.cs.meta
    │       │   │           │       ├── SubContainerCreatorCached.cs
    │       │   │           │       ├── SubContainerCreatorCached.cs.meta
    │       │   │           │       ├── SubContainerCreatorDynamicContext.cs
    │       │   │           │       ├── SubContainerCreatorDynamicContext.cs.meta
    │       │   │           │       ├── SubContainerCreatorUtil.cs
    │       │   │           │       └── SubContainerCreatorUtil.cs.meta
    │       │   │           ├── Runtime/
    │       │   │           │   ├── DisposableManager.cs
    │       │   │           │   ├── DisposableManager.cs.meta
    │       │   │           │   ├── GuiRenderableManager.cs
    │       │   │           │   ├── GuiRenderableManager.cs.meta
    │       │   │           │   ├── GuiRenderer.cs
    │       │   │           │   ├── GuiRenderer.cs.meta
    │       │   │           │   ├── InitializableManager.cs
    │       │   │           │   ├── InitializableManager.cs.meta
    │       │   │           │   ├── Kernels.meta
    │       │   │           │   ├── PoolableManager.cs
    │       │   │           │   ├── PoolableManager.cs.meta
    │       │   │           │   ├── SceneContextRegistry.cs
    │       │   │           │   ├── SceneContextRegistry.cs.meta
    │       │   │           │   ├── SceneContextRegistryAdderAndRemover.cs
    │       │   │           │   ├── SceneContextRegistryAdderAndRemover.cs.meta
    │       │   │           │   ├── TaskUpdater.cs
    │       │   │           │   ├── TaskUpdater.cs.meta
    │       │   │           │   ├── TickableManager.cs
    │       │   │           │   ├── TickableManager.cs.meta
    │       │   │           │   └── Kernels/
    │       │   │           │       ├── DecoratableMonoKernel.cs
    │       │   │           │       ├── DecoratableMonoKernel.cs.meta
    │       │   │           │       ├── DefaultGameObjectKernel.cs
    │       │   │           │       ├── DefaultGameObjectKernel.cs.meta
    │       │   │           │       ├── Kernel.cs
    │       │   │           │       ├── Kernel.cs.meta
    │       │   │           │       ├── MonoKernel.cs
    │       │   │           │       ├── MonoKernel.cs.meta
    │       │   │           │       ├── ProjectKernel.cs
    │       │   │           │       ├── ProjectKernel.cs.meta
    │       │   │           │       ├── SceneKernel.cs
    │       │   │           │       └── SceneKernel.cs.meta
    │       │   │           ├── Usage/
    │       │   │           │   ├── link.xml
    │       │   │           │   ├── link.xml.meta
    │       │   │           │   └── Zenject-usage.dll.meta
    │       │   │           ├── Util/
    │       │   │           │   ├── ActionInstaller.cs
    │       │   │           │   ├── ActionInstaller.cs.meta
    │       │   │           │   ├── CheatSheet.cs
    │       │   │           │   ├── CheatSheet.cs.meta
    │       │   │           │   ├── DefaultGameObjectParentInstaller.cs
    │       │   │           │   ├── DefaultGameObjectParentInstaller.cs.meta
    │       │   │           │   ├── DisposeBlock.cs
    │       │   │           │   ├── DisposeBlock.cs.meta
    │       │   │           │   ├── ExecutionOrderInstaller.cs
    │       │   │           │   ├── ExecutionOrderInstaller.cs.meta
    │       │   │           │   ├── ProfileBlock.cs
    │       │   │           │   ├── ProfileBlock.cs.meta
    │       │   │           │   ├── ProfileTimers.cs
    │       │   │           │   ├── ProfileTimers.cs.meta
    │       │   │           │   ├── ReflectionInfoTypeInfoConverter.cs
    │       │   │           │   ├── ReflectionInfoTypeInfoConverter.cs.meta
    │       │   │           │   ├── ReflectionTypeInfo.cs
    │       │   │           │   ├── ReflectionTypeInfo.cs.meta
    │       │   │           │   ├── ReflectionUtil.cs
    │       │   │           │   ├── ReflectionUtil.cs.meta
    │       │   │           │   ├── TypeAnalyzer.cs
    │       │   │           │   ├── TypeAnalyzer.cs.meta
    │       │   │           │   ├── UnityUtil.cs
    │       │   │           │   ├── UnityUtil.cs.meta
    │       │   │           │   ├── ValidationUtil.cs
    │       │   │           │   ├── ValidationUtil.cs.meta
    │       │   │           │   ├── ZenAutoInjecter.cs
    │       │   │           │   ├── ZenAutoInjecter.cs.meta
    │       │   │           │   ├── ZenjectException.cs
    │       │   │           │   ├── ZenjectException.cs.meta
    │       │   │           │   ├── ZenjectSceneLoader.cs
    │       │   │           │   ├── ZenjectSceneLoader.cs.meta
    │       │   │           │   ├── ZenPools.cs
    │       │   │           │   ├── ZenPools.cs.meta
    │       │   │           │   ├── ZenReflectionTypeAnalyzer.cs
    │       │   │           │   ├── ZenReflectionTypeAnalyzer.cs.meta
    │       │   │           │   ├── ZenUtilInternal.cs
    │       │   │           │   └── ZenUtilInternal.cs.meta
    │       │   │           └── Validation/
    │       │   │               ├── IValidatable.cs
    │       │   │               ├── IValidatable.cs.meta
    │       │   │               ├── ValidationMarker.cs
    │       │   │               └── ValidationMarker.cs.meta
    │       │   ├── Scenes/
    │       │   │   ├── NewBehaviourScript.cs
    │       │   │   ├── NewBehaviourScript.cs.meta
    │       │   │   ├── SampleScene.unity
    │       │   │   └── SampleScene.unity.meta
    │       │   ├── Scripts/
    │       │   │   ├── GameLifetimeScope.cs
    │       │   │   ├── GameLifetimeScope.cs.meta
    │       │   │   ├── MessagePack.meta
    │       │   │   └── MessagePack/
    │       │   │       ├── Annotations.meta
    │       │   │       ├── BitOperations.cs
    │       │   │       ├── BitOperations.cs.meta
    │       │   │       ├── BufferWriter.cs
    │       │   │       ├── BufferWriter.cs.meta
    │       │   │       ├── ExtensionHeader.cs
    │       │   │       ├── ExtensionHeader.cs.meta
    │       │   │       ├── ExtensionResult.cs
    │       │   │       ├── ExtensionResult.cs.meta
    │       │   │       ├── Formatters.meta
    │       │   │       ├── HashCode.cs
    │       │   │       ├── HashCode.cs.meta
    │       │   │       ├── IFormatterResolver.cs
    │       │   │       ├── IFormatterResolver.cs.meta
    │       │   │       ├── Internal.meta
    │       │   │       ├── LZ4.meta
    │       │   │       ├── MessagePack.asmdef
    │       │   │       ├── MessagePack.asmdef.meta
    │       │   │       ├── MessagePackCode.cs
    │       │   │       ├── MessagePackCode.cs.meta
    │       │   │       ├── MessagePackCompression.cs
    │       │   │       ├── MessagePackCompression.cs.meta
    │       │   │       ├── MessagePackReader.cs
    │       │   │       ├── MessagePackReader.cs.meta
    │       │   │       ├── MessagePackSecurity.cs
    │       │   │       ├── MessagePackSecurity.cs.meta
    │       │   │       ├── MessagePackSerializationException.cs
    │       │   │       ├── MessagePackSerializationException.cs.meta
    │       │   │       ├── MessagePackSerializer.cs
    │       │   │       ├── MessagePackSerializer.cs.meta
    │       │   │       ├── MessagePackSerializer.Json.cs
    │       │   │       ├── MessagePackSerializer.Json.cs.meta
    │       │   │       ├── MessagePackSerializer.NonGeneric.cs
    │       │   │       ├── MessagePackSerializer.NonGeneric.cs.meta
    │       │   │       ├── MessagePackSerializerOptions.cs
    │       │   │       ├── MessagePackSerializerOptions.cs.meta
    │       │   │       ├── MessagePackStreamReader.cs
    │       │   │       ├── MessagePackStreamReader.cs.meta
    │       │   │       ├── MessagePackWriter.cs.meta
    │       │   │       ├── MonoProtection.cs
    │       │   │       ├── MonoProtection.cs.meta
    │       │   │       ├── Nil.cs
    │       │   │       ├── Nil.cs.meta
    │       │   │       ├── package.json
    │       │   │       ├── package.json.meta
    │       │   │       ├── Resolvers.meta
    │       │   │       ├── SafeBitConverter.cs
    │       │   │       ├── SafeBitConverter.cs.meta
    │       │   │       ├── SequencePool.cs
    │       │   │       ├── SequencePool.cs.meta
    │       │   │       ├── SequenceReader.cs
    │       │   │       ├── SequenceReader.cs.meta
    │       │   │       ├── SequenceReaderExtensions.cs
    │       │   │       ├── SequenceReaderExtensions.cs.meta
    │       │   │       ├── StreamPolyfillExtensions.cs
    │       │   │       ├── StreamPolyfillExtensions.cs.meta
    │       │   │       ├── StringEncoding.cs
    │       │   │       ├── StringEncoding.cs.meta
    │       │   │       ├── T4.meta
    │       │   │       ├── ThisLibraryExtensionTypeCodes.cs
    │       │   │       ├── ThisLibraryExtensionTypeCodes.cs.meta
    │       │   │       ├── Unity.meta
    │       │   │       ├── Utilities.cs
    │       │   │       ├── Utilities.cs.meta
    │       │   │       ├── Annotations/
    │       │   │       │   ├── Attributes.cs
    │       │   │       │   ├── Attributes.cs.meta
    │       │   │       │   ├── IMessagePackSerializationCallbackReceiver.cs
    │       │   │       │   ├── IMessagePackSerializationCallbackReceiver.cs.meta
    │       │   │       │   ├── MessagePack.Annotations.asmdef
    │       │   │       │   └── MessagePack.Annotations.asmdef.meta
    │       │   │       ├── Formatters/
    │       │   │       │   ├── CollectionFormatter.cs
    │       │   │       │   ├── CollectionFormatter.cs.meta
    │       │   │       │   ├── CollectionHelpers`2.cs
    │       │   │       │   ├── CollectionHelpers`2.cs.meta
    │       │   │       │   ├── DateTimeFormatters.cs
    │       │   │       │   ├── DateTimeFormatters.cs.meta
    │       │   │       │   ├── DictionaryFormatter.cs
    │       │   │       │   ├── DictionaryFormatter.cs.meta
    │       │   │       │   ├── DynamicObjectTypeFallbackFormatter.cs
    │       │   │       │   ├── DynamicObjectTypeFallbackFormatter.cs.meta
    │       │   │       │   ├── EnumAsStringFormatter`1.cs
    │       │   │       │   ├── EnumAsStringFormatter`1.cs.meta
    │       │   │       │   ├── ExpandoObjectFormatter.cs
    │       │   │       │   ├── ExpandoObjectFormatter.cs.meta
    │       │   │       │   ├── GenericEnumFormatter`1.cs
    │       │   │       │   ├── GenericEnumFormatter`1.cs.meta
    │       │   │       │   ├── IgnoreFormatter`1.cs
    │       │   │       │   ├── IgnoreFormatter`1.cs.meta
    │       │   │       │   ├── IMessagePackFormatter`1.cs
    │       │   │       │   ├── IMessagePackFormatter`1.cs.meta
    │       │   │       │   ├── MultiDimensionalArrayFormatter.cs
    │       │   │       │   ├── MultiDimensionalArrayFormatter.cs.meta
    │       │   │       │   ├── NilFormatter.cs
    │       │   │       │   ├── NilFormatter.cs.meta
    │       │   │       │   ├── NullableFormatter.cs
    │       │   │       │   ├── NullableFormatter.cs.meta
    │       │   │       │   ├── PrimitiveObjectFormatter.cs
    │       │   │       │   ├── PrimitiveObjectFormatter.cs.meta
    │       │   │       │   ├── StandardClassLibraryFormatter.cs
    │       │   │       │   ├── StandardClassLibraryFormatter.cs.meta
    │       │   │       │   ├── TypelessFormatter.cs
    │       │   │       │   ├── TypelessFormatter.cs.meta
    │       │   │       │   ├── UnsafeBinaryFormatters.cs
    │       │   │       │   └── UnsafeBinaryFormatters.cs.meta
    │       │   │       ├── Internal/
    │       │   │       │   ├── AsymmetricKeyHashTable.cs
    │       │   │       │   ├── AsymmetricKeyHashTable.cs.meta
    │       │   │       │   ├── AutomataDictionary.cs
    │       │   │       │   ├── AutomataDictionary.cs.meta
    │       │   │       │   ├── ByteArrayStringHashTable.cs
    │       │   │       │   ├── ByteArrayStringHashTable.cs.meta
    │       │   │       │   ├── CodeGenHelpers.cs
    │       │   │       │   ├── CodeGenHelpers.cs.meta
    │       │   │       │   ├── DateTimeConstants.cs
    │       │   │       │   ├── DateTimeConstants.cs.meta
    │       │   │       │   ├── DynamicAssembly.cs
    │       │   │       │   ├── DynamicAssembly.cs.meta
    │       │   │       │   ├── ExpressionUtility.cs
    │       │   │       │   ├── ExpressionUtility.cs.meta
    │       │   │       │   ├── FarmHash.cs
    │       │   │       │   ├── FarmHash.cs.meta
    │       │   │       │   ├── GuidBits.cs
    │       │   │       │   ├── GuidBits.cs.meta
    │       │   │       │   ├── ILGeneratorExtensions.cs
    │       │   │       │   ├── ILGeneratorExtensions.cs.meta
    │       │   │       │   ├── ReflectionExtensions.cs
    │       │   │       │   ├── ReflectionExtensions.cs.meta
    │       │   │       │   ├── RuntimeTypeHandleEqualityComparer.cs
    │       │   │       │   ├── RuntimeTypeHandleEqualityComparer.cs.meta
    │       │   │       │   ├── Sequence`1.cs
    │       │   │       │   ├── Sequence`1.cs.meta
    │       │   │       │   ├── ThreadsafeTypeKeyHashTable.cs
    │       │   │       │   ├── ThreadsafeTypeKeyHashTable.cs.meta
    │       │   │       │   ├── TinyJsonReader.cs
    │       │   │       │   ├── TinyJsonReader.cs.meta
    │       │   │       │   ├── UnsafeMemory.Low.cs
    │       │   │       │   └── UnsafeMemory.Low.cs.meta
    │       │   │       ├── LZ4/
    │       │   │       │   ├── LZ4Codec.cs
    │       │   │       │   ├── LZ4Codec.cs.meta
    │       │   │       │   ├── LZ4Codec.Helper.cs
    │       │   │       │   ├── LZ4Codec.Helper.cs.meta
    │       │   │       │   ├── LZ4Codec.Safe.cs
    │       │   │       │   ├── LZ4Codec.Safe.cs.meta
    │       │   │       │   ├── LZ4Codec.Safe32.Dirty.cs
    │       │   │       │   ├── LZ4Codec.Safe32.Dirty.cs.meta
    │       │   │       │   ├── LZ4Codec.Safe64.Dirty.cs
    │       │   │       │   ├── LZ4Codec.Safe64.Dirty.cs.meta
    │       │   │       │   ├── LZ4Codec.Unsafe.cs
    │       │   │       │   ├── LZ4Codec.Unsafe.cs.meta
    │       │   │       │   ├── LZ4Codec.Unsafe32.Dirty.cs
    │       │   │       │   ├── LZ4Codec.Unsafe32.Dirty.cs.meta
    │       │   │       │   ├── LZ4Codec.Unsafe64.Dirty.cs
    │       │   │       │   └── LZ4Codec.Unsafe64.Dirty.cs.meta
    │       │   │       ├── Resolvers/
    │       │   │       │   ├── AttributeFormatterResolver.cs
    │       │   │       │   ├── AttributeFormatterResolver.cs.meta
    │       │   │       │   ├── BuiltinResolver.cs
    │       │   │       │   ├── BuiltinResolver.cs.meta
    │       │   │       │   ├── CachingFormatterResolver.cs
    │       │   │       │   ├── CachingFormatterResolver.cs.meta
    │       │   │       │   ├── CompositeResolver.cs
    │       │   │       │   ├── CompositeResolver.cs.meta
    │       │   │       │   ├── ContractlessReflectionObjectResolver.cs
    │       │   │       │   ├── ContractlessReflectionObjectResolver.cs.meta
    │       │   │       │   ├── DynamicEnumAsStringResolver.cs
    │       │   │       │   ├── DynamicEnumAsStringResolver.cs.meta
    │       │   │       │   ├── DynamicEnumResolver.cs
    │       │   │       │   ├── DynamicEnumResolver.cs.meta
    │       │   │       │   ├── DynamicGenericResolver.cs
    │       │   │       │   ├── DynamicGenericResolver.cs.meta
    │       │   │       │   ├── DynamicObjectResolver.cs.meta
    │       │   │       │   ├── DynamicUnionResolver.cs
    │       │   │       │   ├── DynamicUnionResolver.cs.meta
    │       │   │       │   ├── ExpandoObjectResolver.cs
    │       │   │       │   ├── ExpandoObjectResolver.cs.meta
    │       │   │       │   ├── NativeDateTimeResolver.cs
    │       │   │       │   ├── NativeDateTimeResolver.cs.meta
    │       │   │       │   ├── NativeDecimalResolver.cs
    │       │   │       │   ├── NativeDecimalResolver.cs.meta
    │       │   │       │   ├── NativeGuidResolver.cs
    │       │   │       │   ├── NativeGuidResolver.cs.meta
    │       │   │       │   ├── PrimitiveObjectResolver.cs
    │       │   │       │   ├── PrimitiveObjectResolver.cs.meta
    │       │   │       │   ├── StandardResolver.cs
    │       │   │       │   ├── StandardResolver.cs.meta
    │       │   │       │   ├── StaticCompositeResolver.cs
    │       │   │       │   ├── StaticCompositeResolver.cs.meta
    │       │   │       │   ├── TypelessContractlessStandardResolver.cs
    │       │   │       │   ├── TypelessContractlessStandardResolver.cs.meta
    │       │   │       │   ├── TypelessObjectResolver.cs
    │       │   │       │   └── TypelessObjectResolver.cs.meta
    │       │   │       ├── T4/
    │       │   │       │   ├── ForceSizePrimitiveFormatter.cs
    │       │   │       │   ├── ForceSizePrimitiveFormatter.cs.meta
    │       │   │       │   ├── MessagePackReader.Integers.cs
    │       │   │       │   ├── MessagePackReader.Integers.cs.meta
    │       │   │       │   ├── PrimitiveFormatter.cs
    │       │   │       │   ├── PrimitiveFormatter.cs.meta
    │       │   │       │   ├── TupleFormatter.cs
    │       │   │       │   ├── TupleFormatter.cs.meta
    │       │   │       │   ├── UnsafeMemory.cs
    │       │   │       │   ├── UnsafeMemory.cs.meta
    │       │   │       │   ├── ValueTupleFormatter.cs
    │       │   │       │   └── ValueTupleFormatter.cs.meta
    │       │   │       └── Unity/
    │       │   │           ├── Extension.meta
    │       │   │           ├── Formatters.cs
    │       │   │           ├── Formatters.cs.meta
    │       │   │           ├── MessagePackWindow.cs
    │       │   │           ├── MessagePackWindow.cs.meta
    │       │   │           ├── UnityResolver.cs
    │       │   │           ├── UnityResolver.cs.meta
    │       │   │           └── Extension/
    │       │   │               ├── UnityBlitResolver.cs
    │       │   │               ├── UnityBlitResolver.cs.meta
    │       │   │               ├── UnsafeBlitFormatter.cs
    │       │   │               └── UnsafeBlitFormatter.cs.meta
    │       │   └── Tests/
    │       │       ├── BuiltinTest.cs
    │       │       ├── BuiltinTest.cs.meta
    │       │       ├── InterprocessTest.cs
    │       │       ├── InterprocessTest.cs.meta
    │       │       ├── TestHelper.cs
    │       │       ├── TestHelper.cs.meta
    │       │       ├── Tests.asmdef
    │       │       ├── Tests.asmdef.meta
    │       │       ├── TestType.cs
    │       │       ├── TestType.cs.meta
    │       │       ├── VContainerTest.cs
    │       │       ├── VContainerTest.cs.meta
    │       │       ├── ZenjectTest.cs
    │       │       └── ZenjectTest.cs.meta
    │       ├── Packages/
    │       │   ├── manifest.json
    │       │   └── packages-lock.json
    │       └── ProjectSettings/
    │           ├── AudioManager.asset
    │           ├── ClusterInputManager.asset
    │           ├── CsprojModifierSettings.json
    │           ├── DynamicsManager.asset
    │           ├── EditorBuildSettings.asset
    │           ├── EditorSettings.asset
    │           ├── GraphicsSettings.asset
    │           ├── InputManager.asset
    │           ├── MemorySettings.asset
    │           ├── NavMeshAreas.asset
    │           ├── NetworkManager.asset
    │           ├── PackageManagerSettings.asset
    │           ├── Physics2DSettings.asset
    │           ├── PresetManager.asset
    │           ├── ProjectSettings.asset
    │           ├── ProjectVersion.txt
    │           ├── QualitySettings.asset
    │           ├── SceneTemplateSettings.json
    │           ├── TagManager.asset
    │           ├── TimeManager.asset
    │           ├── UnityConnectSettings.asset
    │           ├── VersionControlSettings.asset
    │           ├── VFXManager.asset
    │           └── XRSettings.asset
    ├── tests/
    │   ├── MessagePipe.Analyzer.Tests/
    │   │   ├── AnalyzerTest.cs
    │   │   └── MessagePipe.Analyzer.Tests.csproj
    │   ├── MessagePipe.Benchmark/
    │   │   ├── BenchmarkDotNetRun.cs
    │   │   ├── MessagePipe.Benchmark.csproj
    │   │   ├── Program.cs
    │   │   └── PublishOps.cs
    │   ├── MessagePipe.Interprocess.Benchmark/
    │   │   ├── MessagePipe.Interprocess.Benchmark.csproj
    │   │   ├── MyAsyncRequestHandler.cs
    │   │   ├── Program.cs
    │   │   ├── TcpBenchmark.cs
    │   │   └── TcpParallelBenchmark.cs
    │   ├── MessagePipe.Interprocess.Tests/
    │   │   ├── _TestHelper.cs
    │   │   ├── MessagePipe.Interprocess.Tests.csproj
    │   │   ├── NamedPipeTest.cs
    │   │   ├── TcpTest.cs
    │   │   └── UdpTest.cs
    │   ├── MessagePipe.Nats.Tests/
    │   │   ├── ReadMe.md
    │   │   ├── MessagePipe.Nats.Tests.csproj
    │   │   └── NatsPubSub.cs
    │   ├── MessagePipe.Redis.Tests/
    │   │   ├── ReadMe.md
    │   │   ├── _TestHelper.cs
    │   │   ├── ConnectionMultiplexerFactoryTest.cs
    │   │   ├── MessagePipe.Redis.Tests.csproj
    │   │   └── RedisPubSubKeyedASync.cs
    │   └── MessagePipe.Tests/
    │       ├── _TestHelper.cs
    │       ├── ArrayUtilTest.cs
    │       ├── AsAsyncEnumerableTest.cs
    │       ├── BufferedTest.cs
    │       ├── DisaposableBagTest.cs
    │       ├── EventFactoryTest.cs
    │       ├── FirstAsyncTest.cs
    │       ├── FreeListTest.cs
    │       ├── GlobalMixFilterTest.cs
    │       ├── InMemoryDistributedTest.cs
    │       ├── MessagePipe.Tests.csproj
    │       ├── MultiRequestHandlerTest.cs
    │       ├── PubSubKeyedASync.cs
    │       ├── PubSubKeyedSync.cs
    │       ├── PubSubKeylessASsync.cs
    │       ├── PubSubKeylessSync.cs
    │       ├── RequestAllHandlerAsyncFilterTest.cs
    │       ├── RequestAllHandlerAsyncTest.cs
    │       ├── RequestAllHandlerFilterTest.cs
    │       ├── RequestAllHandlerTest.cs
    │       ├── RequestHandlerAsyncFilterTest.cs
    │       ├── RequestHandlerAsyncTest.cs
    │       ├── RequestHandlerFilterTest.cs
    │       ├── RequestHandlerTest.cs
    │       └── WhenAllTest.cs
    ├── tools/
    │   └── PostBuildUtility/
    │       ├── PostBuildUtility.csproj
    │       └── Program.cs
    └── .github/
        ├── dependabot.yaml
        └── workflows/
            ├── build-debug.yaml
            ├── build-release.yaml
            ├── prevent-github-change.yaml
            └── stale.yaml

================================================
FILE: README.md
================================================
# MessagePipe
[![GitHub Actions](https://github.com/Cysharp/MessagePipe/workflows/Build-Debug/badge.svg)](https://github.com/Cysharp/MessagePipe/actions) [![Releases](https://img.shields.io/github/release/Cysharp/MessagePipe.svg)](https://github.com/Cysharp/MessagePipe/releases)

MessagePipe is a high-performance in-memory/distributed messaging pipeline for .NET and Unity. It supports all cases of Pub/Sub usage, mediator pattern for CQRS, EventAggregator of Prism(V-VM decoupling), IPC(Interprocess Communication)-RPC, etc.

* Dependency-injection first
* Filter pipeline
* better event
* sync/async
* keyed/keyless
* buffered/bufferless
* singleton/scoped
* broadcast/response(+many)
* in-memory/interprocess/distributed

MessagePipe is faster than standard C# event and 78 times faster than Prism's EventAggregator.

![](https://user-images.githubusercontent.com/46207/115984507-5d36da80-a5e2-11eb-9942-66602906f499.png)

Of course, memory allocation per publish operation is less(zero).

![](https://user-images.githubusercontent.com/46207/115814615-62542800-a430-11eb-9041-1f31c1ac8464.png)

Also providing roslyn-analyzer to prevent subscription leak.

![](https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png)

Getting Started
---
For .NET, use NuGet. For Unity, please read [Unity](#unity) section.

> PM> Install-Package [MessagePipe](https://www.nuget.org/packages/MessagePipe)

MessagePipe is built on top of a `Microsoft.Extensions.DependencyInjection`(for Unity, `VContainer` or `Zenject` or `Builtin Tiny DI`) so set up via `ConfigureServices` in [.NET Generic Host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host). Generic Host is widely used in .NET such as ASP.NET Core, [MagicOnion](https://github.com/Cysharp/MagicOnion/), [ConsoleAppFramework](https://github.com/Cysharp/ConsoleAppFramework/), MAUI, WPF(with external support), etc so easy to setup.

```csharp
using MessagePipe;
using Microsoft.Extensions.DependencyInjection;

Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe(); // AddMessagePipe(options => { }) for configure options
    })
```

Get the `IPublisher<T>` for publisher, Get the `ISubscribe<T>` for subscriber, like a `Logger<T>`. `T` can be any type, primitive(int, string, etc...), struct, class, enum, etc.

```csharp
using MessagePipe;

public struct MyEvent { }

public class SceneA
{
    readonly IPublisher<MyEvent> publisher;
    
    public SceneA(IPublisher<MyEvent> publisher)
    {
        this.publisher = publisher;
    }

    void Send()
    {
        this.publisher.Publish(new MyEvent());
    }
}

public class SceneB
{
    readonly ISubscriber<MyEvent> subscriber;
    readonly IDisposable disposable;

    public SceneB(ISubscriber<MyEvent> subscriber)
    {
        var bag = DisposableBag.CreateBuilder(); // composite disposable for manage subscription
        
        subscriber.Subscribe(x => Console.WriteLine("here")).AddTo(bag);

        disposable = bag.Build();
    }

    void Close()
    {
        disposable.Dispose(); // unsubscribe event, all subscription **must** Dispose when completed
    }
}
```

It is similar to event, but decoupled by type as key. The return value of Subscribe is `IDisposable`, which makes it easier to unsubscribe than event. You can release many subscriptions at once by `DisposableBag`(`CompositeDisposable`). See the [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section for more details.

The publisher/subscriber(internally we called MessageBroker) is managed by DI, it is possible to have different broker for each scope. Also, all subscriptions are unsubscribed when the scope is disposed, which prevents subscription leaks.

> Default is singleton, you can configure `MessagePipeOptions.InstanceLifetime` to `Singleton` or `Scoped`.

`IPublisher<T>/ISubscriber<T>` is keyless(type only) however MessagePipe has similar interface `IPublisher<TKey, TMessage>/ISubscriber<TKey, TMessage>` that is keyed(topic) interface.

For example, our real usecase, There is an application that connects Unity and [MagicOnion](https://github.com/Cysharp/MagicOnion/) (a real-time communication framework like SignalR) and delivers it via a browser by Blazor. At that time, we needed something to connect Blazor's page (Browser lifecycle) and MagicOnion's Hub (Connection lifecycle) to transmit data. We also need to distribute the connections by their IDs.

`Browser <-> Blazor <- [MessagePipe] -> MagicOnion <-> Unity`

We solved this with the following code.

```csharp
// MagicOnion(similar as SignalR, realtime event framework for .NET and Unity)
public class UnityConnectionHub : StreamingHubBase<IUnityConnectionHub, IUnityConnectionHubReceiver>, IUnityConnectionHub
{
    readonly IPublisher<Guid, UnitEventData> eventPublisher;
    readonly IPublisher<Guid, ConnectionClose> closePublisher;
    Guid id;

    public UnityConnectionHub(IPublisher<Guid, UnitEventData> eventPublisher, IPublisher<Guid, ConnectionClose> closePublisher)
    {
        this.eventPublisher = eventPublisher;
        this.closePublisher = closePublisher;
    }

    override async ValueTask OnConnected()
    {
        this.id = Guid.Parse(Context.Headers["id"]);
    }

    override async ValueTask OnDisconnected()
    {
        this.closePublisher.Publish(id, new ConnectionClose()); // publish to browser(Blazor)
    }

    // called from Client(Unity)
    public Task<UnityEventData> SendEventAsync(UnityEventData data)
    {
        this.eventPublisher.Publish(id, data); // publish to browser(Blazor)
    }
}

// Blazor
public partial class BlazorPage : ComponentBase, IDisposable
{
    [Parameter]
    public Guid ID { get; set; }

    [Inject]
    ISubscriber<Guid, UnitEventData> UnityEventSubscriber { get; set; }

    [Inject]
    ISubscriber<Guid, ConnectionClose> ConnectionCloseSubscriber { get; set; }

    IDisposable subscription;

    protected override void OnInitialized()
    {
        // receive event from MagicOnion(that is from Unity)
        var d1 = UnityEventSubscriber.Subscribe(ID, x =>
        {
            // do anything...
        });

        var d2 = ConnectionCloseSubscriber.Subscribe(ID, _ =>
        {
            // show disconnected thing to view...
            subscription?.Dispose(); // and unsubscribe events.
        });

        subscription = DisposableBag.Create(d1, d2); // combine disposable.
    }
    
    public void Dispose()
    {
        // unsubscribe event when browser is closed.
        subscription?.Dispose();
    }
}
```

> The main difference of Reactive Extensions' Subject is has no `OnCompleted`. OnCompleted may or may not be used, making it very difficult to determine the intent to the observer(subscriber). Also, we usually subscribe to multiple events from the same (different event type)publisher, and it is difficult to handle duplicate OnCompleted in that case. For this reason, MessagePipe only provides a simple Publish(OnNext). If you want to convey completion, please receive a separate event and perform dedicated processing there.

> In other words, this is the equivalent of [Relay in RxSwift](https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Subjects.md).

In addition to standard Pub/Sub, MessagePipe supports async handlers, mediator patterns with handlers that accept return values, and filters for pre-and-post execution customization.

This image is a visualization of the connection between all those interfaces.

![image](https://user-images.githubusercontent.com/46207/122254092-bf87c980-cf07-11eb-8bdd-039c87309db6.png)

You may be confused by the number of interfaces, but many functions can be written with a similar, unified API.

Publish/Subscribe
---
Publish/Subscribe interface has keyed(topic) and keyless, sync and async interface.

```csharp
// keyless-sync
public interface IPublisher<TMessage>
{
    void Publish(TMessage message);
}

public interface ISubscriber<TMessage>
{
    IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
}

// keyless-async
public interface IAsyncPublisher<TMessage>
{
    // async interface's publish is fire-and-forget
    void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
    ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
    ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
}

public interface IAsyncSubscriber<TMessage>
{
    IDisposable Subscribe(IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
}

// keyed-sync
public interface IPublisher<TKey, TMessage>
    where TKey : notnull
{
    void Publish(TKey key, TMessage message);
}

public interface ISubscriber<TKey, TMessage>
    where TKey : notnull
{
    IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
}

// keyed-async
public interface IAsyncPublisher<TKey, TMessage>
    where TKey : notnull
{
    void Publish(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
    ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
}

public interface IAsyncSubscriber<TKey, TMessage>
    where TKey : notnull
{
    IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
}
```

All are available in the form of `IPublisher/Subscribe<T>` in the DI. async handler can await all subscribers completed by `await PublishAsync`. Asynchronous methods can work sequentially or in parallel, depending on `AsyncPublishStrategy` (defaults is `Parallel`, can be changed by `MessagePipeOptions` or by specifying at publish time). If you don't need to wait, you can call `void Publish` to act as fire-and-forget.

The before and after of execution can be changed by passing a custom filter. See the [Filter](#filter) section for details.

If an error occurs, it will be propagated to the caller and subsequent subscribers will be stopped. This behavior can be changed by writing a filter to ignore errors.

ISingleton***, IScoped***
---
I(Async)Publisher(Subscriber)'s lifetime belongs to `MessagePipeOptions.InstanceLifetime`. However if declare with `ISingletonPublisher<TMessage>`/`ISingletonSubscriber<TKey, TMessage>`, `ISingletonAsyncPublisher<TMessage>`/`ISingletonAsyncSubscriber<TKey, TMessage>` then used singleton lifetime. Also `IScopedPublisher<TMessage>`/`IScopedSubscriber<TKey, TMessage>`, `IScopedAsyncPublisher<TMessage>`/`IScopedAsyncSubscriber<TKey, TMessage>` uses scoped lifetime.

Buffered
---
`IBufferedPublisher<TMessage>/IBufferedSubscriber<TMessage>` pair is similar as `BehaviorSubject` or Reactive Extensions(More equal is RxSwift's `BehaviorRelay`). It returns latest value on `Subscribe`.

```csharp
var p = provider.GetRequiredService<IBufferedPublisher<int>>();
var s = provider.GetRequiredService<IBufferedSubscriber<int>>();

p.Publish(999);

var d1 = s.Subscribe(x => Console.WriteLine(x)); // 999
p.Publish(1000); // 1000

var d2 = s.Subscribe(x => Console.WriteLine(x)); // 1000
p.Publish(9999); // 9999, 9999

DisposableBag.Create(d1, d2).Dispose();
```

> If `TMessage` is class and does not have latest value(null), does not send value on Subscribe.

> Keyed buffered publisher/subscriber does not exist because difficult to avoid memory leak of (unused)key and keep latest value.

EventFactory
---
Using `EventFactory`, you can create generic `IPublisher/ISubscriber`, `IAsyncPublisher/IAsyncSubscriber`, `IBufferedPublisher/IBufferedSubscriber`, `IBufferedAsyncPublisher/IBufferedAsyncSubscriber` like C# events, with a Subscriber tied to each instance, not grouped by type.

MessagePipe has better properties than a normal C# event

* Using Subscribe/Dispose instead of `+=`, `-=` , easy to management subscription
* Both sync and async support
* Both bufferless and buffered support
* Enable unsubscribe all subscription from publisher.dispose
* Attaches invocation pipeline behaviour by Filter
* To monitor subscription leak by `MessagePipeDiagnosticsInfo`
* TO prevent subscription leak by `MessagePipe.Analyzer`

```csharp
public class BetterEvent : IDisposable
{
    // using MessagePipe instead of C# event/Rx.Subject
    // store Publisher to private field(declare IDisposablePublisher/IDisposableAsyncPublisher)
    IDisposablePublisher<int> tickPublisher;

    // Subscriber is used from outside so public property
    public ISubscriber<int> OnTick { get; }

    public BetterEvent(EventFactory eventFactory)
    {
        // CreateEvent can deconstruct by tuple and set together
        (tickPublisher, OnTick) = eventFactory.CreateEvent<int>();

        // also create async event(IAsyncSubscriber) by `CreateAsyncEvent`
        // eventFactory.CreateAsyncEvent
    }

    int count;
    void Tick()
    {
        tickPublisher.Publish(count++);
    }

    public void Dispose()
    {
        // You can unsubscribe all from Publisher.
        tickPublisher.Dispose();
    }
}
```

If you want to create event outside of DI, see [Global Provider](#global-provider) section.

```csharp
IDisposablePublisher<int> tickPublisher;
public ISubscriber<int> OnTick { get; }

ctor()
{
    (tickPublisher, OnTick) = GlobalMessagePipe.CreateEvent<int>();
}
```

Request/Response/All
---
Similar as [MediatR](https://github.com/jbogard/MediatR), implement support of mediator pattern.

```csharp
public interface IRequestHandler<in TRequest, out TResponse>
{
    TResponse Invoke(TRequest request);
}

public interface IAsyncRequestHandler<in TRequest, TResponse>
{
    ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);
}
```

For example, declare handler for Ping type.

```csharp
public readonly struct Ping { }
public readonly struct Pong { }

public class PingPongHandler : IRequestHandler<Ping, Pong>
{
    public Pong Invoke(Ping request)
    {
        Console.WriteLine("Ping called.");
        return new Pong();
    }
}
```

You can get handler like this.

```csharp
class FooController
{
    IRequestHandler<Ping, Pong> requestHandler;

    // automatically instantiate PingPongHandler.
    public FooController(IRequestHandler<Ping, Pong> requestHandler)
    {
        this.requestHandler = requestHandler;
    }

    public void Run()
    {
        var pong = this.requestHandler.Invoke(new Ping());
        Console.WriteLine("PONG");
    }
}
```

For more complex implementation patterns, [this Microsoft documentation](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-application-layer-implementation-web-api#implement-the-command-process-pipeline-with-a-mediator-pattern-mediatr) is applicable.

Declare many request handlers, you can use `IRequestAllHandler`, `IAsyncRequestAllHandler` instead of single handler.

```csharp
public interface IRequestAllHandler<in TRequest, out TResponse>
{
    TResponse[] InvokeAll(TRequest request);
    IEnumerable<TResponse> InvokeAllLazy(TRequest request);
}

public interface IAsyncRequestAllHandler<in TRequest, TResponse>
{
    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);
    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
    IAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken = default);
}
```

```csharp
public class PingPongHandler1 : IRequestHandler<Ping, Pong>
{
    public Pong Invoke(Ping request)
    {
        Console.WriteLine("Ping1 called.");
        return new Pong();
    }
}

public class PingPongHandler2 : IRequestHandler<Ping, Pong>
{
    public Pong Invoke(Ping request)
    {
        Console.WriteLine("Ping1 called.");
        return new Pong();
    }
}

class BarController
{
    IRequestAllHandler<Ping, Pong> requestAllHandler;

    public FooController(IRequestAllHandler<Ping, Pong> requestAllHandler)
    {
        this.requestAllHandler = requestAllHandler;
    }

    public void Run()
    {
        var pongs = this.requestAllHandler.InvokeAll(new Ping());
        Console.WriteLine("PONG COUNT:" + pongs.Length);
    }
}
```

Subscribe Extensions
---
`ISubscriber`(`IAsyncSubscriber`) interface requires `IMessageHandler<T>` to handle message.

```csharp
public interface ISubscriber<TMessage>
{
    IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
}
```

However, the extension method allows you to write `Action<T>` directly.

```csharp
public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
public static IObservable<TMessage> AsObservable<TMessage>(this ISubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)
public static IAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)
public static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
public static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
```

Also, the `Func<TMessage, bool>` overload can filter messages by predicate (internally implemented with PredicateFilter, where Order is int.MinValue and is always checked first).

`AsObservable` can convert message pipeline to `IObservable<T>`, it can handle by Reactive Extensions(in Unity, you can use `UniRx`). `AsObservable` exists in sync subscriber(keyless, keyed, buffered).

`AsAsyncEnumerable` can convert message pipeline to `IAsyncEnumerable<T>`, it can handle by async LINQ and async foreach. `AsAsyncEnumerable` exists in async subscriber(keyless, keyed, buffered).

`FirstAsync` gets the first value of message. It is similar as `AsObservable().FirstAsync()`, `AsObservable().Where().FirstAsync()`. If uses `CancellationTokenSource(TimeSpan)` then similar as `AsObservable().Timeout().FirstAsync()`. Argument of `CancellationToken` is required to avoid task leak. 

```csharp
// for Unity, use cts.CancelAfterSlim(TIimeSpan) instead.
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));
var value = await subscriber.FirstAsync(cts.Token);
```

`FirstAsync` exists in both sync and async subscriber(keyless, keyed, buffered).

Filter
---
Filter system can hook before and after method invocation. It is implemented with the Middleware pattern, which allows you to write synchronous and asynchronous code with similar syntax. MessagePipe provides different filter types - sync (`MessageHandlerFilter<T>`), async (`AsyncMessageHandlerFilter<T>`), request (`RequestHandlerFilter<TReq, TRes>`) and async request (`AsyncRequestHandlerFilter<TReq, TRes>`). To implement other concerete filters the above filter types can be extended.

Filters can be specified in three places - global(by `MessagePipeOptions.AddGlobalFilter`), per handler type, and per subscription. These filters are sorted according to the Order specified in each of them, and are generated when subscribing.

Since the filter is generated on a per subscription basis, the filter can have a state.

```csharp
public class ChangedValueFilter<T> : MessageHandlerFilter<T>
{
    T lastValue;

    public override void Handle(T message, Action<T> next)
    {
        if (EqualityComparer<T>.Default.Equals(message, lastValue))
        {
            return;
        }

        lastValue = message;
        next(message);
    }
}

// uses(per subscribe)
subscribe.Subscribe(x => Console.WriteLine(x), new ChangedValueFilter<int>(){ Order = 100 });

// add per handler type(use generics filter, write open generics)
[MessageHandlerFilter(typeof(ChangedValueFilter<>), 100)]
public class WriteLineHandler<T> : IMessageHandler<T>
{
    public void Handle(T message) => Console.WriteLine(message);
}

// add per global
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe(options =>
        {
            options.AddGlobalMessageHandlerFilter(typeof(ChangedValueFilter<>), 100);
        });
    });
```

use the filter by attribute, you can use these attributes: `[MessageHandlerFilter(type, order)]`, `[AsyncMessageHandlerFilter(type, order)]`, `[RequestHandlerFilter(type, order)]`, `[AsyncRequestHandlerFilter(type, order)]`.

These are idea showcase of filter.

```csharp
public class PredicateFilter<T> : MessageHandlerFilter<T>
{
    private readonly Func<T, bool> predicate;

    public PredicateFilter(Func<T, bool> predicate)
    {
        this.predicate = predicate;
    }

    public override void Handle(T message, Action<T> next)
    {
        if (predicate(message))
        {
            next(message);
        }
    }
}
```

```csharp
public class LockFilter<T> : MessageHandlerFilter<T>
{
    readonly object gate = new object();

    public override void Handle(T message, Action<T> next)
    {
        lock (gate)
        {
            next(message);
        }
    }
}
```

```csharp
public class IgnoreErrorFilter<T> : MessageHandlerFilter<T>
{
    readonly ILogger<IgnoreErrorFilter<T>> logger;

    public IgnoreErrorFilter(ILogger<IgnoreErrorFilter<T>> logger)
    {
        this.logger = logger;
    }

    public override void Handle(T message, Action<T> next)
    {
        try
        {
            next(message);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, ""); // error logged, but do not propagate
        }
    }
}
```

```csharp
public class DispatcherFilter<T> : MessageHandlerFilter<T>
{
    readonly Dispatcher dispatcher;

    public DispatcherFilter(Dispatcher dispatcher)
    {
        this.dispatcher = dispatcher;
    }

    public override void Handle(T message, Action<T> next)
    {
        dispatcher.BeginInvoke(() =>
        {
            next(message);
        });
    }
}
```

```csharp
public class DelayRequestFilter : AsyncRequestHandlerFilter<int, int>
{
    public override async ValueTask<int> InvokeAsync(int request, CancellationToken cancellationToken, Func<int, CancellationToken, ValueTask<int>> next)
    {
        await Task.Delay(TimeSpan.FromSeconds(request));
        var response = await next(request, cancellationToken);
        return response;
    }
}
```

Managing Subscription and Diagnostics
---
Subscribe returns `IDisposable`; when call `Dispose` then unsubscribe. A better reason than event is that it is easy to Unsubscribe. To manage multiple IDisposable, you can use `CompositeDisposable` in Rx(UniRx) or `DisposableBag` included in MessagePipe.

```csharp
IDisposable disposable;

void OnInitialize(ISubscriber<int> subscriber)
{
    var d1 = subscriber.Subscribe(_ => { });
    var d2 = subscriber.Subscribe(_ => { });
    var d3 = subscriber.Subscribe(_ => { });

    // static DisposableBag: DisposableBag.Create(1~7(optimized) or N);
    disposable = DisposableBag.Create(d1, d2, d3);
}

void Close()
{
    // dispose all subscription
    disposable?.Dispose();
}
```

```csharp
IDisposable disposable;

void OnInitialize(ISubscriber<int> subscriber)
{
    // use builder pattern, you can use subscription.AddTo(bag)
    var bag = DisposableBag.CreateBuilder();

    subscriber.Subscribe(_ => { }).AddTo(bag);
    subscriber.Subscribe(_ => { }).AddTo(bag);
    subscriber.Subscribe(_ => { }).AddTo(bag);

    disposable = bag.Build(); // create final composite IDisposable
}

void Close()
{
    // dispose all subscription
    disposable?.Dispose();
}
```

```csharp
IDisposable disposable;

void OnInitialize(ISubscriber<int> subscriber)
{
    var bag = DisposableBag.CreateBuilder();

    // calling once(or x count), you can use DisposableBag.CreateSingleAssignment to hold subscription reference.
    var d = DisposableBag.CreateSingleAssignment();
    
    // you can invoke Dispose in handler action.
    // assign disposable, you can use `SetTo` and `AddTo` bag.
    // or you can use d.Disposable = subscriber.Subscribe();
    subscriber.Subscribe(_ => { d.Dispose(); }).SetTo(d).AddTo(bag);

    disposable = bag.Build();
}

void Close()
{
    disposable?.Dispose();
}
```

The returned `IDisposable` value **must** be handled. If it is ignored, it will leak. However Weak reference, which is widely used in WPF, is an anti-pattern. All subscriptions should be managed explicitly.

You can monitor subscription count by `MessagePipeDiagnosticsInfo`. It can get from service provider(or DI).

```csharp
public sealed class MessagePipeDiagnosticsInfo
{
    /// <summary>Get current subscribed count.</summary>
    public int SubscribeCount { get; }

    /// <summary>
    /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, list all stacktrace on subscribe.
    /// </summary>
    public StackTraceInfo[] GetCapturedStackTraces(bool ascending = true);

    /// <summary>
    /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, groped by caller of subscribe.
    /// </summary>
    public ILookup<string, StackTraceInfo> GetGroupedByCaller(bool ascending = true)
}
```

If you monitor SubscribeCount, you can check leak of subscription.

```csharp
public class MonitorTimer : IDisposable
{
    CancellationTokenSource cts = new CancellationTokenSource();

    public MonitorTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)
    {
        RunTimer(diagnosticsInfo);
    }

    async void RunTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)
    {
        while (!cts.IsCancellationRequested)
        {
            // show SubscribeCount
            Console.WriteLine("SubscribeCount:" + diagnosticsInfo.SubscribeCount);
            await Task.Delay(TimeSpan.FromSeconds(5), cts.Token);
        }
    }

    public void Dispose()
    {
        cts.Cancel();
    }
}
```

Also, by enabling MessagePipeOptions.EnableCaptureStackTrace (disabled by default), the location of the subscribed location can be displayed, making it easier to find the location of the leak if it exists.

Check the Count of GroupedByCaller, and if any of them show abnormal values, then the stack trace is where it occurs, and you probably ignore Subscription.

for Unity, `Window ->  MessagePipe Diagnostics` window is useful for monitoring subscritpion. It visualizes `MessagePipeDianogsticsInfo`.

![image](https://user-images.githubusercontent.com/46207/116953319-e2e41580-acc7-11eb-88c9-a4704bf3e3c9.png)

To Enable use of the MessagePipeDiagnostics window, require to set up `GlobalMessagePipe`.

```csharp
// VContainer
public class MessagePipeDemo : VContainer.Unity.IStartable
{
    public MessagePipeDemo(IObjectResolver resolver)
    {
        // require this line.
        GlobalMessagePipe.SetProvider(resolver.AsServiceProvider());
    }
}

// Zenject
void Configure(DiContainer container)
{
    GlobalMessagePipe.SetProvider(container.AsServiceProvider());
}

// builtin
var prodiver = builder.BuildServiceProvider();
GlobalMessagePipe.SetProvider(provider);
```

Analyzer
---
In previous section, we anounce `The returned IDisposable value **must** be handled`. To prevent subscription leak, we provide roslyn analyzer.

> PM> Install-Package [MessagePipe.Analyzer](https://www.nuget.org/packages/MessagePipe.Analyzer)

![](https://user-images.githubusercontent.com/46207/117535259-da753d00-b02f-11eb-9818-0ab5ef3049b1.png)

This will raise an error for unhandled `Subscribe`.

This analyzer can use after Unity 2020.2(see: [Roslyn analyzers and ruleset files](https://docs.unity3d.com/2020.2/Documentation/Manual/roslyn-analyzers.html) document). `MessagePipe.Analyzer.dll` exists in [releases page](https://github.com/Cysharp/MessagePipe/releases/).

![](https://user-images.githubusercontent.com/46207/117535248-d5b08900-b02f-11eb-8add-33101a71033a.png)

Currently Unity's analyzer support is incomplete. We are complementing analyzer support with editor extension, please check the [Cysharp/CsprojModifier](https://github.com/Cysharp/CsprojModifier).

![](https://github.com/Cysharp/CsprojModifier/raw/master/docs/images/Screen-01.png)

IDistributedPubSub / MessagePipe.Redis
---
For the distributed(networked) Pub/Sub, you can use `IDistributedPublisher<TKey, TMessage>`, `IDistributedSubscriber<TKey, TMessage>` instead of `IAsyncPublisher`.

```csharp
public interface IDistributedPublisher<TKey, TMessage>
{
    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);
}

public interface IDistributedSubscriber<TKey, TMessage>
{
    // and also without filter overload.
    public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
    public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
}
```

`IAsyncPublisher` means in-memory Pub/Sub. Since processing over the network is fundamentally different, you need to use a different interface to avoid confusion.

Redis is available as a standard network provider.

> PM> Install-Package [MessagePipe.Redis](https://www.nuget.org/packages/MessagePipe.Redis)

use `AddMessagePipeRedis` to enable redis provider.

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe()
            .AddRedis(IConnectionMultiplexer | IConnectionMultiplexerFactory, configure);
    })
```

`IConnectionMultiplexer` overload, you can pass [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis)'s `ConnectionMultiplexer` directly. Implement own `IConnectionMultiplexerFactory` to allow for per-key distribution and use from connection pools.

`MessagePipeRedisOptions`, you can configure serialization.

```csharp
public sealed class MessagePipeRedisOptions
{
    public IRedisSerializer RedisSerializer { get; set; }
}

public interface IRedisSerializer
{
    byte[] Serialize<T>(T value);
    T Deserialize<T>(byte[] value);
}
```

In default uses [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp)'s `ContractlessStandardResolver`. You can change to use other `MessagePackSerializerOptions` by `new MessagePackRedisSerializer(options)` or implement own serializer wrapper.

MessagePipe has in-memory IDistributedPublisher/Subscriber for local test usage.

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        var config = ctx.Configuration.Get<MyConfig>();

        var builder = services.AddMessagePipe();
        if (config.IsLocal)
        {
            // use in-memory IDistributedPublisher/Subscriber in local.
            builder.AddInMemoryDistributedMessageBroker();   
        }
        else
        {
            // use Redis IDistributedPublisher/Subscriber
            builder.AddRedis();
        }
    });
```

InterprocessPubSub, IRemoteAsyncRequest / MessagePipe.Interprocess
---
For the interprocess(NamedPipe/UDP/TCP) Pub/Sub(IPC), you can use `IDistributedPublisher<TKey, TMessage>`, `IDistributedSubscriber<TKey, TMessage>` similar as `MessagePipe.Redis`.

> PM> Install-Package MessagePipe.Interprocess

MessagePipe.Interprocess is also exsits on Unity(except NamedPipe).

use `AddUdpInterprocess`, `AddTcpInterprocess`, `AddNamedPipeInterprocess`, `AddUdpInterprocessUds`, `AddTcpInterprocessUds` to enable interprocess provider(Uds is Unix domain socket, most performant option).

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe()
            .AddUdpInterprocess("127.0.0.1", 3215, configure); // setup host and port.
            // .AddTcpInterprocess("127.0.0.1", 3215, configure);
            // .AddNamedPipeInterprocess("messagepipe-namedpipe", configure);
            // .AddUdpInterprocessUds("domainSocketPath")
            // .AddTcpInterprocessUds("domainSocketPath")
    })
```

```csharp
public async P(IDistributedPublisher<string, int> publisher)
{
    // publish value to remote process.
    await publisher.PublishAsync("foobar", 100);
}

public async S(IDistributedSubscriber<string, int> subscriber)
{
    // subscribe remote-message with "foobar" key.
    await subscriber.SubscribeAsync("foobar", x =>
    {
        Console.WriteLine(x);
    });
}
```

when injected `IDistributedPublisher`, process will be `server`, start to listen client. when injected `IDistributedSubscriber`, process will be `client`, start to connect to server. when DI scope is closed, server/client connection is closed.

Udp is connectionless protocol so does not require server is started before client connect. However protocol limitation, does not send over 64K message. We're recommend to use this if message is not large.

Namedpipe is 1:1 connection, can not connect multiple subscribers.

Tcp has no such restrictions and is the most flexible of all the options.

In default uses [MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp)'s `ContractlessStandardResolver` for message serialization. You can change to use other `MessagePackSerializerOptions` by MessagePipeInterprocessOptions.MessagePackSerializerOptions.

```csharp
builder.AddUdpInterprocess("127.0.0.1", 3215, options =>
{
    // You can configure other options, `InstanceLifetime` and `UnhandledErrorHandler`.
    options.MessagePackSerializerOptions = StandardResolver.Options;
});
```

For IPC-RPC, you can use `IRemoteRequestHandler<in TRequest, TResponse>` that invoke remote `IAsyncRequestHandler<TRequest, TResponse>`. using `TcpInterprocess` or `NamedPipeInterprocess` enabled it.

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe()
            .AddTcpInterprocess("127.0.0.1", 3215, x =>
            {
                x.HostAsServer = true; // if remote process as server, set true(otherwise false(default)).
            });
    });
```

```csharp
// example: server handler
public class MyAsyncHandler : IAsyncRequestHandler<int, string>
{
    public async ValueTask<string> InvokeAsync(int request, CancellationToken cancellationToken = default)
    {
        await Task.Delay(1);
        if (request == -1)
        {
            throw new Exception("NO -1");
        }
        else
        {
            return "ECHO:" + request.ToString();
        }
    }
}
```

```csharp
// client
async void A(IRemoteRequestHandler<int, string> remoteHandler)
{
    var v = await remoteHandler.InvokeAsync(9999);
    Console.WriteLine(v); // ECHO:9999
}
```

For Unity, requires to import MessagePack-CSharp package and needs slightly different configuration.

```csharp
// example of VContainer
var builder = new ContainerBuilder();
var options = builder.RegisterMessagePipe(configure);

var messagePipeBuilder = builder.ToMessagePipeBuilder(); // require to convert ServiceCollection to enable Intereprocess

var interprocessOptions = messagePipeBuilder.AddTcpInterprocess();

// register manually.
// IDistributedPublisher/Subscriber
messagePipeBuilder.RegisterTcpInterprocessMessageBroker<int, int>(interprocessOptions);
// RemoteHandler
builder.RegisterAsyncRequestHandler<int, string, MyAsyncHandler>(options); // for server
messagePipeBuilder.RegisterTcpRemoteRequestHandler<int, string>(interprocessOptions); // for client
```

MessagePipeOptions
---
You can configure MessagePipe behaviour by `MessagePipeOptions` in `AddMessagePipe(Action<MMessagePipeOptions> configure)`.

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        // var config = ctx.Configuration.Get<MyConfig>(); // optional: get settings from configuration(use it for options configure)

        services.AddMessagePipe(options =>
        {
            options.InstanceLifetime = InstanceLifetime.Scoped;
#if DEBUG
            // EnableCaptureStackTrace slows performance, so recommended to use only in DEBUG and in profiling, disable it.
            options.EnableCaptureStackTrace = true;
#endif
        });
    })
```

Option has these properties(and method).

```csharp
public sealed class MessagePipeOptions
{
    AsyncPublishStrategy DefaultAsyncPublishStrategy; // default is Parallel
    HandlingSubscribeDisposedPolicy HandlingSubscribeDisposedPolic; // default is Ignore
    InstanceLifetime InstanceLifetime; // default is Singleton
    InstanceLifetime RequestHandlerLifetime; // default is Scoped
    bool EnableAutoRegistration;  // default is true
    bool EnableCaptureStackTrace; // default is false

    void SetAutoRegistrationSearchAssemblies(params Assembly[] assemblies);
    void SetAutoRegistrationSearchTypes(params Type[] types);
    void AddGlobal***Filter<T>();
}

public enum AsyncPublishStrategy
{
    Parallel, Sequential
}

public enum InstanceLifetime
{
    Singleton, Scoped, Transient
}

public enum HandlingSubscribeDisposedPolicy
{
    Ignore, Throw
}
```

### DefaultAsyncPublishStrategy

`IAsyncPublisher` has `PublishAsync` method. If AsyncPublishStrategy.Sequential, await each subscribers. If Parallel, uses WhenAll.

```csharp
public interface IAsyncPublisher<TMessage>
{
    // using Default AsyncPublishStrategy
    ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default);
    ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
    // snip others...
}

public interface IAsyncPublisher<TKey, TMessage>
    where TKey : notnull
{
    // using Default AsyncPublishStrategy
    ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);
    ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
    // snip others...
}

public interface IAsyncRequestAllHandler<in TRequest, TResponse>
{
    // using Default AsyncPublishStrategy
    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);
    ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
    // snip others...
}
```

`MessagePipeOptions.DefaultAsyncPublishStrategy`'s default is `Parallel`.

### HandlingSubscribeDisposedPolicy

When `ISubscriber.Subscribe` after MessageBroker(publisher/subscriber manager) is disposed(for example, scope is disposed), choose `Ignore`(returns empty `IDisposable`) or `Throw` exception. Default is `Ignore`.

### InstanceLifetime

Configure MessageBroker(publisher/subscriber manager)'s lifetime of DI cotainer. You can choose `Singleton` or `Scoped`. Default is `Singleton`. When choose `Scoped`, each messagebrokers manage different subscribers and when scope is disposed, unsubscribe all managing subscribers.

### RequestHandlerLifetime

Configure IRequestHandler/IAsyncRequestHandler's lifetime of DI container. You can choose `Singleton` or `Scoped` or `Transient`. Default is `Scoped`.

### EnableAutoRegistration/SetAutoRegistrationSearchAssemblies/SetAutoRegistrationSearchTypes

Register `IRequestHandler`, `IAsyncHandler` and filters to DI container automatically on startup. Default is `true` and default search target is CurrentDomain's all assemblies and types. However, this sometimes fails to detect the assembly being stripped. In that case, you can enable the search by explicitly adding it to `SetAutoRegistrationSearchAssemblies` or `SetAutoRegistrationSearchTypes`.

`[IgnoreAutoRegistration]` attribute allows to disable auto registration which attribute attached.

### EnableCaptureStackTrace

See the details [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section, if `true` then capture stacktrace on Subscribe. It is useful for debugging but performance will be degraded. Default is `false` and recommended to enable only debug.

### AddGlobal***Filter

Add global filter, for example logging filter will be useful.

```csharp
public class LoggingFilter<T> : MessageHandlerFilter<T>
{
    readonly ILogger<LoggingFilter<T>> logger;

    public LoggingFilter(ILogger<LoggingFilter<T>> logger)
    {
        this.logger = logger;
    }

    public override void Handle(T message, Action<T> next)
    {
        try
        {
            logger.LogDebug("before invoke.");
            next(message);
            logger.LogDebug("invoke completed.");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "error");
        }
    }
}
```

To enable all types, use open generics.

```csharp
Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, services) =>
    {
        services.AddMessagePipe(options =>
        {
            // use typeof(Filter<>, order);
            options.AddGlobalMessageHandlerFilter(typeof(LoggingFilter<>), -10000);
        });
    });
```

Global provider
---
If you want to get publisher/subscriber/handler from globally scope, get `IServiceProvider` before run and set to static helper called `GlobalMessagePipe`.

```csharp
var host = Host.CreateDefaultBuilder()
    .ConfigureServices((ctx, x) =>
    {
        x.AddMessagePipe();
    })
    .Build(); // build host before run.

GlobalMessagePipe.SetProvider(host.Services); // set service provider

await host.RunAsync(); // run framework.
```

`GlobalMessagePipe` has these static method(`GetPublisher<T>`, `GetSubscriber<T>`, `CreateEvent<T>`, etc...) so you can get globally.

![image](https://user-images.githubusercontent.com/46207/116521078-7c00de00-a90e-11eb-85c0-2c62c140c51d.png)

Integration with other DI library
---
All(popular) DI libraries has `Microsoft.Extensions.DependencyInjection` bridge so configure by MS.E.DI and use bridge if you want.

Compare with Channels
---
[System.Threading.Channels](https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels)(for Unity, `UniTask.Channels`) uses Queue internal, the producer is not affected by the performance of the consumer, and the consumer can control the flow rate(back pressure). This is a different use than MessagePipe's Pub/Sub.

Unity
---
You need to install Core library and choose [VContainer](https://github.com/hadashiA/VContainer/) or [Zenject](https://github.com/modesttree/Zenject) or `BuiltinContainerBuilder` for runtime. You can install via UPM git URL package or asset package(MessagePipe.*.unitypackage) available in [MessagePipe/releases](https://github.com/Cysharp/MessagePipe/releases) page.

* Core `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe`
* VContainer `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer`
* Zenject `https://github.com/Cysharp/MessagePipe.git?path=src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject`

Andalso, requires [UniTask](https://github.com/Cysharp/UniTask) to install, all `ValueTask` declaration in .NET is replaced to `UniTask`.

> [!NOTE]
> Unity version does not have open generics support(for IL2CPP) and does not support auto registration. Therefore, all required types need to be manually registered.

VContainer's installation sample.

```csharp
public class GameLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        // RegisterMessagePipe returns options.
        var options = builder.RegisterMessagePipe(/* configure option */);
        
        // Setup GlobalMessagePipe to enable diagnostics window and global function
        builder.RegisterBuildCallback(c => GlobalMessagePipe.SetProvider(c.AsServiceProvider()));

        // RegisterMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.
        builder.RegisterMessageBroker<int>(options);

        // also exists RegisterMessageBroker<TKey, TMessage>, RegisterRequestHandler, RegisterAsyncRequestHandler

        // RegisterMessageHandlerFilter: Register for filter, also exists RegisterAsyncMessageHandlerFilter, Register(Async)RequestHandlerFilter
        builder.RegisterMessageHandlerFilter<MyFilter<int>>();

        builder.RegisterEntryPoint<MessagePipeDemo>(Lifetime.Singleton);
    }
}

public class MessagePipeDemo : VContainer.Unity.IStartable
{
    readonly IPublisher<int> publisher;
    readonly ISubscriber<int> subscriber;

    public MessagePipeDemo(IPublisher<int> publisher, ISubscriber<int> subscriber)
    {
        this.publisher = publisher;
        this.subscriber = subscriber;
    }

    public void Start()
    {
        var d = DisposableBag.CreateBuilder();
        subscriber.Subscribe(x => Debug.Log("S1:" + x)).AddTo(d);
        subscriber.Subscribe(x => Debug.Log("S2:" + x)).AddTo(d);

        publisher.Publish(10);
        publisher.Publish(20);
        publisher.Publish(30);

        var disposable = d.Build();
        disposable.Dispose();
    }
}
```

> [!TIP]
> If you are using Unity 2022.1 or later and VContainer 1.14.0 or later, you do not need `RegsiterMessageBroker<>`. 
> A set of types including `ISubscriber<>`, `IPublisher<>` or its asynchronous version will be resolved automatically.
> Note that `IRequesthandler<>` and `IRequestAllHanlder<>` still require manual registration.


Unity version does not have open generics support(for IL2CPP) and does not support auto registration. Therefore, all required types need to be manually registered.


Zenject's installation sample.

```csharp
void Configure(DiContainer builder)
{
    // BindMessagePipe returns options.
    var options = builder.BindMessagePipe(/* configure option */);
    
    // BindMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.
    builder.BindMessageBroker<int>(options);

    // also exists BindMessageBroker<TKey, TMessage>, BindRequestHandler, BindAsyncRequestHandler

    // BindMessageHandlerFilter: Bind for filter, also exists BindAsyncMessageHandlerFilter, Bind(Async)RequestHandlerFilter
    builder.BindMessageHandlerFilter<MyFilter<int>>();

    // set global to enable diagnostics window and global function
    GlobalMessagePipe.SetProvider(builder.AsServiceProvider());
}
```

> Zenject version is not supported `InstanceScope.Singleton` for Zenject's limitation. The default is `Scoped`, which cannot be changed.

`BuiltinContainerBuilder` is builtin minimum DI library for MessagePipe, it no needs other DI library to use MessagePipe. Here is installation sample.

```csharp
var builder = new BuiltinContainerBuilder();

builder.AddMessagePipe(/* configure option */);

// AddMessageBroker: Register for IPublisher<T>/ISubscriber<T>, includes async and buffered.
builder.AddMessageBroker<int>(options);

// also exists AddMessageBroker<TKey, TMessage>, AddRequestHandler, AddAsyncRequestHandler

// AddMessageHandlerFilter: Register for filter, also exists RegisterAsyncMessageHandlerFilter, Register(Async)RequestHandlerFilter
builder.AddMessageHandlerFilter<MyFilter<int>>();

// create provider and set to Global(to enable diagnostics window and global fucntion)
var provider = builder.BuildServiceProvider();
GlobalMessagePipe.SetProvider(provider);

// --- to use MessagePipe, you can use from GlobalMessagePipe.
var p = GlobalMessagePipe.GetPublisher<int>();
var s = GlobalMessagePipe.GetSubscriber<int>();

var d = s.Subscribe(x => Debug.Log(x));

p.Publish(10);
p.Publish(20);
p.Publish(30);

d.Dispose();
```

> BuiltinContainerBuilder does not supports scope(always `InstanceScope.Singleton`), `IRequestAllHandler/IAsyncRequestAllHandler`, and many DI functionally, so we recommend to use by `GlobalMessagePipe` when use BuiltinContainerBuilder.

Adding global filter, you can not use open generics filter so recommended to create these helper method.

```csharp
// Register IPublisher<T>/ISubscriber<T> and global filter.
static void RegisterMessageBroker<T>(IContainerBuilder builder, MessagePipeOptions options)
{
    builder.RegisterMessageBroker<T>(options);

    // setup for global filters.
    options.AddGlobalMessageHandlerFilter<MyMessageHandlerFilter<T>>();
}

// Register IRequestHandler<TReq, TRes>/IRequestAllHandler<TReq, TRes> and global filter.
static void RegisterRequest<TRequest, TResponse, THandler>(IContainerBuilder builder, MessagePipeOptions options)
    where THandler : IRequestHandler
{
    builder.RegisterRequestHandler<TRequest, TResponse, THandler>(options);
    
    // setup for global filters.
    options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter<TRequest, TResponse>>();
}
```

Also you can use `GlobalMessagePipe` and `MessagePipe Diagnostics` window. see: [Global provider](#global-provider) and [Managing Subscription and Diagnostics](#managing-subscription-and-diagnostics) section.

License
---
This library is licensed under the MIT License.



================================================
FILE: Directory.Build.props
================================================
<Project>
  <PropertyGroup>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>

    <!-- NuGet Packaging -->
    <IsPackable>false</IsPackable>
    <PackageVersion>$(Version)</PackageVersion>
    <Company>Cysharp</Company>
    <Authors>Cysharp</Authors>
    <Copyright>© Cysharp, Inc.</Copyright>
    <PackageProjectUrl>https://github.com/Cysharp/MessagePipe</PackageProjectUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageIcon>Icon.png</PackageIcon>
    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)opensource.snk</AssemblyOriginatorKeyFile>

  </PropertyGroup>

  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)Icon.png" Pack="true" PackagePath="\" />
    <None Include="$(MSBuildThisFileDirectory)README.md" Pack="true" PackagePath="\" />
    <EmbeddedResource Include="$(MSBuildThisFileDirectory)LICENSE" />
  </ItemGroup>
</Project>



================================================
FILE: docker-compose.yml
================================================
version: "3.4"

services:
  redis:
    image: "redis:6.2.1"
    ports:
      - "6379:6379"
  nats:
    image: nats
    ports:
      - 4222:4222



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2021 Cysharp, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: MessagePipe.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32002.185
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe", "src\MessagePipe\MessagePipe.csproj", "{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{381F6F79-110B-4CE4-9A49-583046D8C164}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "sandbox", "sandbox", "{9813BFC3-7860-4697-A3AF-118BDF710BD0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Sandbox.ConsoleApp", "sandbox\MessagePipe.Sandbox.ConsoleApp\MessagePipe.Sandbox.ConsoleApp.csproj", "{BEFA1E77-266B-4F35-8892-935729D4A07F}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{36546FD6-866F-4809-AFCE-87F7F4201361}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Tests", "tests\MessagePipe.Tests\MessagePipe.Tests.csproj", "{BC6D3323-B70E-49A1-9360-0E09D8C2851B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Redis", "src\MessagePipe.Redis\MessagePipe.Redis.csproj", "{F8F7655B-50D0-4487-93BD-66F3BD7FB736}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Benchmark", "tests\MessagePipe.Benchmark\MessagePipe.Benchmark.csproj", "{1DD3A001-BB03-4192-892C-92B298E79E68}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tools", "tools", "{7946AB0F-638C-4D40-BB01-1EC790B0E921}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "PostBuildUtility", "tools\PostBuildUtility\PostBuildUtility.csproj", "{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Redis.Tests", "tests\MessagePipe.Redis.Tests\MessagePipe.Redis.Tests.csproj", "{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "_items", "_items", "{33ADB827-BA73-4B6A-AA57-13C74AB9183D}"
	ProjectSection(SolutionItems) = preProject
		.dockerignore = .dockerignore
		.gitignore = .gitignore
		docker-compose.yml = docker-compose.yml
		README.md = README.md
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = ".github", ".github", "{71072B57-914A-4CA8-915A-64E832DA6E1F}"
	ProjectSection(SolutionItems) = preProject
		.github\workflows\build-debug.yml = .github\workflows\build-debug.yml
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Analyzer", "src\MessagePipe.Analyzer\MessagePipe.Analyzer.csproj", "{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.AnalyzerTestApp", "sandbox\MessagePipe.AnalyzerTestApp\MessagePipe.AnalyzerTestApp.csproj", "{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Analyzer.Tests", "tests\MessagePipe.Analyzer.Tests\MessagePipe.Analyzer.Tests.csproj", "{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Interprocess", "src\MessagePipe.Interprocess\MessagePipe.Interprocess.csproj", "{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Interprocess.Tests", "tests\MessagePipe.Interprocess.Tests\MessagePipe.Interprocess.Tests.csproj", "{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "InterprocessServer", "sandbox\InterprocessServer\InterprocessServer.csproj", "{0E645BF9-3464-4856-A624-FEFCF0050220}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Interprocess.Benchmark", "tests\MessagePipe.Interprocess.Benchmark\MessagePipe.Interprocess.Benchmark.csproj", "{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessagePipe.Nats", "src\MessagePipe.Nats\MessagePipe.Nats.csproj", "{80D9A03B-CDF0-4D52-BF07-2C198707E65C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MessagePipe.Nats.Tests", "tests\MessagePipe.Nats.Tests\MessagePipe.Nats.Tests.csproj", "{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
		WinBenchmark|Any CPU = WinBenchmark|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.Release|Any CPU.Build.0 = Release|Any CPU
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.Release|Any CPU.Build.0 = Release|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{BEFA1E77-266B-4F35-8892-935729D4A07F}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.Release|Any CPU.Build.0 = Release|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.Release|Any CPU.Build.0 = Release|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.Release|Any CPU.Build.0 = Release|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{1DD3A001-BB03-4192-892C-92B298E79E68}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.Release|Any CPU.Build.0 = Release|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.WinBenchmark|Any CPU.ActiveCfg = WinBenchmark|Any CPU
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F}.WinBenchmark|Any CPU.Build.0 = WinBenchmark|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.Release|Any CPU.Build.0 = Release|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.Release|Any CPU.Build.0 = Release|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.Release|Any CPU.Build.0 = Release|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.Release|Any CPU.Build.0 = Release|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.Release|Any CPU.Build.0 = Release|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.Release|Any CPU.Build.0 = Release|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.Release|Any CPU.Build.0 = Release|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{0E645BF9-3464-4856-A624-FEFCF0050220}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.Release|Any CPU.Build.0 = Release|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.Release|Any CPU.Build.0 = Release|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.Release|Any CPU.Build.0 = Release|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{D94EF9D4-3CC2-4420-8D0B-25957E7C5309} = {381F6F79-110B-4CE4-9A49-583046D8C164}
		{BEFA1E77-266B-4F35-8892-935729D4A07F} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}
		{BC6D3323-B70E-49A1-9360-0E09D8C2851B} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{F8F7655B-50D0-4487-93BD-66F3BD7FB736} = {381F6F79-110B-4CE4-9A49-583046D8C164}
		{1DD3A001-BB03-4192-892C-92B298E79E68} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{7C720CA5-C5F6-4B23-B4DD-4E98FF22111F} = {7946AB0F-638C-4D40-BB01-1EC790B0E921}
		{0C4DDD4B-8DCE-48EB-B309-39132313C3AB} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{71072B57-914A-4CA8-915A-64E832DA6E1F} = {33ADB827-BA73-4B6A-AA57-13C74AB9183D}
		{CB2E0099-5D84-4E14-9699-3AF5B9237DF4} = {381F6F79-110B-4CE4-9A49-583046D8C164}
		{3F0CF7FC-D764-40C0-BA3A-0302DB2F205F} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}
		{64A0C890-301B-49D9-95C8-8CAFB53DCFDC} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{10E626FF-DE92-4784-A9EB-F5A6BE26D1D3} = {381F6F79-110B-4CE4-9A49-583046D8C164}
		{3B2C3908-E9EB-43F3-9340-3CF5EFBA2F09} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{0E645BF9-3464-4856-A624-FEFCF0050220} = {9813BFC3-7860-4697-A3AF-118BDF710BD0}
		{AF421C72-0DDA-4568-BD7E-B3CE90B3B31C} = {36546FD6-866F-4809-AFCE-87F7F4201361}
		{80D9A03B-CDF0-4D52-BF07-2C198707E65C} = {381F6F79-110B-4CE4-9A49-583046D8C164}
		{8BE1C4C7-9584-4F87-9773-6E7A3B3C71E2} = {36546FD6-866F-4809-AFCE-87F7F4201361}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {138B7AA8-E4C0-46A3-A48B-0D373CAC365D}
	EndGlobalSection
EndGlobal



================================================
FILE: MessagePipe.sln.startup.json
================================================
/*
    This is a configuration file for the SwitchStartupProject Visual Studio Extension
    See https://heptapod.host/thirteen/switchstartupproject/blob/branch/current/Configuration.md
*/
{
    /*  Configuration File Version  */
    "Version": 3,

    /*  Create an item in the dropdown list for each project in the solution?  */
    "ListAllProjects": true

    /*
        Dictionary of named configurations with one or multiple startup projects
        and optional parameters like command line arguments and working directory.
        Example:

        "MultiProjectConfigurations": {
          "A + B (Ext)": {
            "Projects": {
              "MyProjectA": {},
              "MyProjectB": {
                "CommandLineArguments": "1234",
                "WorkingDirectory": "%USERPROFILE%\\test",
                "StartExternalProgram": "c:\\myprogram.exe"
              }
            }
          },
          "A + B": {
            "Projects": {
              "MyProjectA": {},
              "MyProjectB": {
                "CommandLineArguments": "",
                "WorkingDirectory": "",
                "StartProject": true
              }
            }
          },
          "D (Debug x86)": {
            "Projects": {
              "MyProjectD": {}
            },
            "SolutionConfiguration": "Debug",
            "SolutionPlatform": "x86",
          },
          "D (Release x64)": {
            "Projects": {
              "MyProjectD": {}
            },
            "SolutionConfiguration": "Release",
            "SolutionPlatform": "x64",
          }
        }
    */
    //"MultiProjectConfigurations": {
    //    "Interprocess": {
    //        "Projects": {
    //            ["InterprocessServer": {
    //                "CommandLineArguments": "SERVER"
    //            },
    //            "InterprocessServer": {
    //                "CommandLineArguments": "CLIENT"
    //            }
    //        }
    //    }
    //}
}



================================================
FILE: NuGet.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
    <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
  </packageSources>
  <disabledPackageSources>
    <clear />
  </disabledPackageSources>
</configuration>



================================================
FILE: opensource.snk
================================================
[Binary file]


================================================
FILE: .dockerignore
================================================
**/.classpath
**/.dockerignore
**/.env
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/.vscode
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/azds.yaml
**/bin
**/charts
**/docker-compose*
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
LICENSE
README.md


================================================
FILE: .editorconfig
================================================
﻿# top-most EditorConfig file
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

# Visual Studio Spell checker configs (https://learn.microsoft.com/en-us/visualstudio/ide/text-spell-checker?view=vs-2022#how-to-customize-the-spell-checker)
spelling_exclusion_path  = ./exclusion.dic

[*.cs]
indent_size = 4
charset = utf-8-bom
end_of_line = unset

# Solution files
[*.{sln,slnx}]
end_of_line = unset

# MSBuild project files
[*.{csproj,props,targets}]
end_of_line = unset

# Xml config files
[*.{ruleset,config,nuspec,resx,runsettings,DotSettings}]
end_of_line = unset

[*{_AssemblyInfo.cs,.notsupported.cs}]
generated_code = true

# C# code style settings
[*.{cs}]
dotnet_diagnostic.IDE0044.severity = none # IDE0044: Make field readonly

# https://stackoverflow.com/questions/79195382/how-to-disable-fading-unused-methods-in-visual-studio-2022-17-12-0
dotnet_diagnostic.IDE0051.severity = none # IDE0051: Remove unused private member
dotnet_diagnostic.IDE0130.severity = none # IDE0130: Namespace does not match folder structure



================================================
FILE: docs/performance_graph.xlsx
================================================
[Binary file]


================================================
FILE: sandbox/InterprocessServer/InterprocessServer.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="ConsoleAppFramework" Version="4.0.6" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\MessagePipe.Interprocess\MessagePipe.Interprocess.csproj" />
    <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: sandbox/InterprocessServer/Program.cs
================================================
﻿using ConsoleAppFramework;
using MessagePack;
using MessagePack.Formatters;
using MessagePack.Resolvers;
using MessagePipe;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace InterprocessServer
{
    class Program : ConsoleAppBase
    {
        static void Main(string[] args)
        {
            //var buffer = new byte[] { 147, 1, 172, 83, 121, 115, 116, 101, 109, 46, 73, 110, 116, 51, 50, 173, 83, 121, 115, 116, 101, 109, 46, 83, 116, 114, 105, 110, 103 };
            //var bbbuffer = new byte[] { 147, 1, 172, 83, 121, 115, 116, 101, 109, 46, 73, 110, 116, 51, 50, 173, 83, 121, 115, 116, 101, 109, 46, 83, 116, 114, 105, 110, 103 }.AsMemory();
            //var tako = MessagePackSerializer.Deserialize<RequestHeader>(bbbuffer, ContractlessStandardResolver.Options);






            //var isServer = args[0] == "SERVER";
            // var isServer = true;
            // Console.WriteLine(args[0]);

            Host.CreateDefaultBuilder()
                .ConfigureServices(x =>
                {
                    x.AddMessagePipe()
                        .AddNamedPipeInterprocess("messagepipe-pipe");
                })
                .RunConsoleAppFrameworkAsync<Program>(args);
        }

        public async Task RunA(IDistributedPublisher<string, int> publisher)
        {
            await publisher.PublishAsync("foo", 100);
        }

        public async Task RunB(IDistributedSubscriber<string, int> subscriber)
        {
            await subscriber.SubscribeAsync("foo", x =>
            {
                Console.WriteLine(x);
            });
        }



        public async Task RunClient(IRemoteRequestHandler<int, string> handler)
        {
            var v = await handler.InvokeAsync(100);
            Console.WriteLine(v); // "ECHO:100"
        }


    }


    public class MyAsyncHandler : IAsyncRequestHandler<int, string>
    {
        public async ValueTask<string> InvokeAsync(int request, CancellationToken cancellationToken = default)
        {
            await Task.Delay(1);
            return "ECHO:" + request.ToString();
        }
    }

    //[Preserve]
    [MessagePackFormatter(typeof(Formatter))]
    internal class RequestHeader
    {
        public int MessageId { get; }
        public string RequestType { get; }
        public string ResponseType { get; }

        public RequestHeader(int messageId, string requestType, string responseType)
        {
            MessageId = messageId;
            RequestType = requestType;
            ResponseType = responseType;
        }

        //[Preserve]
        public class Formatter : IMessagePackFormatter<RequestHeader>
        {
            public RequestHeader Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                // debugging...
                var x = reader.ReadArrayHeader();
                Console.WriteLine(x);
                if (x != 3) throw new MessagePack.MessagePackSerializationException("Array length is invalid. Length:" + x);
                var id = reader.ReadInt32();

                var req = reader.ReadString();
                var res = reader.ReadString();
                return new RequestHeader(id, req, res);
            }

            public void Serialize(ref MessagePackWriter writer, RequestHeader value, MessagePackSerializerOptions options)
            {
                writer.WriteArrayHeader(3);
                writer.Write(value.MessageId);
                writer.Write(value.RequestType);
                writer.Write(value.ResponseType);
            }
        }
    }
}



================================================
FILE: sandbox/MessagePipe.AnalyzerTestApp/MessagePipe.AnalyzerTestApp.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="System.Reactive" Version="5.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe.Analyzer\MessagePipe.Analyzer.csproj">
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
            <OutputItemType>Analyzer</OutputItemType>
        </ProjectReference>
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/MessagePipe.AnalyzerTestApp/Program.cs
================================================
﻿#pragma warning disable CS1998
#pragma warning disable MPA001 // for check MessagePipe.Analyzer, remove this line.

using System;
using System.Linq;
using System.Reactive.Linq;

namespace MessagePipe.AnalyzerTestApp
{

    class Program
    {
        static void Main()
        {
            Observable.Range(1, 10).Subscribe(_ => Console.WriteLine("OK Rx"));
        }

        static IDisposable Ret(ISubscriber<int> subscriber)
        {
            return subscriber.Subscribe(_ => Console.WriteLine("OK RETURN"));
        }

        static IDisposable Ret(ISubscriber<int, int> subscriber)
        {
            return subscriber.Subscribe(0, _ => Console.WriteLine("OK RETURN"));
        }

        static IDisposable Ret(IAsyncSubscriber<int> subscriber)
        {
            return subscriber.Subscribe(async (_, _) => Console.WriteLine("OK RETURN"));
        }

        static IDisposable Ret(IAsyncSubscriber<int, int> subscriber)
        {
            return subscriber.Subscribe(0, async (_, _) => Console.WriteLine("OK RETURN"));
        }

        static IDisposable Ret(IBufferedSubscriber<int> subscriber)
        {
            return subscriber.Subscribe(_ => Console.WriteLine("OK RETURN"));
        }

        class MyClass
        {
            public MyClass(IDisposable d)
            {

            }
        }

        static void Subscriber(ISubscriber<int> subscriber)
        {
            subscriber.Subscribe(_ => Console.WriteLine("NG NOT HANDLED"));

            var d = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN"));

            IDisposable d1;
            d1 = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN2"));

            _ = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN3"));

            DisposableBag.Create(subscriber.Subscribe(_ => Console.WriteLine("OK METHOD ARG1")));

            var bag = DisposableBag.CreateBuilder();
            subscriber.Subscribe(_ => Console.WriteLine("OK METHOD CHAIN")).AddTo(bag);

            Enumerable.Range(1, 10).Select(_ => subscriber.Subscribe(_ => Console.WriteLine("OK IN LAMBDA")));

            new MyClass(subscriber.Subscribe(_ => Console.WriteLine("OK CTOR")));

            using (subscriber.Subscribe(_ => Console.WriteLine("OK USING")))
            {
            }

            using (subscriber.Subscribe(_ => Console.WriteLine("OK USING2")))
            {
            }

            using var u = subscriber.Subscribe(_ => Console.WriteLine("OK USING 3"));
        }

        static void Subscriber2(ISubscriber<string, int> subscriber)
        {
            subscriber.Subscribe("a", _ => Console.WriteLine("NG NOT HANDLED"));

            var d = subscriber.Subscribe("a", _ => Console.WriteLine("OK ASSIGN"));

            IDisposable d1;
            d1 = subscriber.Subscribe("a", _ => Console.WriteLine("OK ASSIGN2"));

            _ = subscriber.Subscribe("a", _ => Console.WriteLine("OK ASSIGN3"));

            DisposableBag.Create(subscriber.Subscribe("a", _ => Console.WriteLine("OK METHOD ARG1")));

            var bag = DisposableBag.CreateBuilder();
            subscriber.Subscribe("a", _ => Console.WriteLine("OK METHOD CHAIN")).AddTo(bag);

            Enumerable.Range(1, 10).Select(_ => subscriber.Subscribe("a", _ => Console.WriteLine("OK IN LAMBDA")));

            new MyClass(subscriber.Subscribe("a", _ => Console.WriteLine("OK CTOR")));

            using (subscriber.Subscribe("a", _ => Console.WriteLine("OK USING")))
            {
            }

            using (subscriber.Subscribe("a", _ => Console.WriteLine("OK USING2")))
            {
            }

            using var u = subscriber.Subscribe("a", _ => Console.WriteLine("OK USING 3"));
        }

        static void AsyncSubscriber(IAsyncSubscriber<int> subscriber)
        {
            subscriber.Subscribe(async (_, _) => Console.WriteLine("NG NOT HANDLED"));

            var d = subscriber.Subscribe(async (_, _) => Console.WriteLine("OK ASSIGN"));

            IDisposable d1;
            d1 = subscriber.Subscribe(async (_, _) => Console.WriteLine("OK ASSIGN2"));

            _ = subscriber.Subscribe(async (_, _) => Console.WriteLine("OK ASSIGN3"));

            DisposableBag.Create(subscriber.Subscribe(async (_, _) => Console.WriteLine("OK METHOD ARG1")));

            var bag = DisposableBag.CreateBuilder();
            subscriber.Subscribe(async (_, _) => Console.WriteLine("OK METHOD CHAIN")).AddTo(bag);

            Enumerable.Range(1, 10).Select(_ => subscriber.Subscribe(async (_, _) => Console.WriteLine("OK IN LAMBDA")));

            new MyClass(subscriber.Subscribe(async (_, _) => Console.WriteLine("OK CTOR")));

            using (subscriber.Subscribe(async (_, _) => Console.WriteLine("OK USING")))
            {
            }

            using (subscriber.Subscribe(async (_, _) => Console.WriteLine("OK USING2")))
            {
            }

            using var u = subscriber.Subscribe(async (_, _) => Console.WriteLine("OK USING 3"));
        }

        static void AsyncSubscriber2(IAsyncSubscriber<string, int> subscriber)
        {
            subscriber.Subscribe("a", async (_, _) => Console.WriteLine("NG NOT HANDLED"));

            var d = subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK ASSIGN"));

            IDisposable d1;
            d1 = subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK ASSIGN2"));

            _ = subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK ASSIGN3"));

            DisposableBag.Create(subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK METHOD ARG1")));

            var bag = DisposableBag.CreateBuilder();
            subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK METHOD CHAIN")).AddTo(bag);

            Enumerable.Range(1, 10).Select(async (_, _) => subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK IN LAMBDA")));

            new MyClass(subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK CTOR")));

            using (subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK USING")))
            {
            }

            using (subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK USING2")))
            {
            }

            using var u = subscriber.Subscribe("a", async (_, _) => Console.WriteLine("OK USING 3"));
        }

        static void BufferedSubscriber(IBufferedSubscriber<int> subscriber)
        {
            subscriber.Subscribe(_ => Console.WriteLine("NG NOT HANDLED"));

            var d = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN"));

            IDisposable d1;
            d1 = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN2"));

            _ = subscriber.Subscribe(_ => Console.WriteLine("OK ASSIGN3"));

            DisposableBag.Create(subscriber.Subscribe(_ => Console.WriteLine("OK METHOD ARG1")));

            var bag = DisposableBag.CreateBuilder();
            subscriber.Subscribe(_ => Console.WriteLine("OK METHOD CHAIN")).AddTo(bag);

            Enumerable.Range(1, 10).Select(_ => subscriber.Subscribe(_ => Console.WriteLine("OK IN LAMBDA")));

            new MyClass(subscriber.Subscribe(_ => Console.WriteLine("OK CTOR")));

            using (subscriber.Subscribe(_ => Console.WriteLine("OK USING")))
            {
            }

            using (subscriber.Subscribe(_ => Console.WriteLine("OK USING2")))
            {
            }

            using var u = subscriber.Subscribe(_ => Console.WriteLine("OK USING 3"));
        }
    }
}



================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/ChangedValueFilter.cs
================================================
﻿#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Sandbox.ConsoleApp
{
    public class ChangedValueFilter<TMessage> : MessageHandlerFilter<TMessage>
    {
        TMessage lastValue;

        public override void Handle(TMessage message, Action<TMessage> next)
        {
            if (EqualityComparer<TMessage>.Default.Equals(message, lastValue))
            {
                return;
            }

            lastValue = message;
            next(message);
        }
    }


    public class LockFilter<T> : MessageHandlerFilter<T>
    {
        readonly object gate = new object();

        public override void Handle(T message, Action<T> next)
        {
            lock (gate)
            {
                next(message);
            }
        }
    }

    public class IgnoreErrorFilter<T> : MessageHandlerFilter<T>
    {
        readonly ILogger<IgnoreErrorFilter<T>> logger;

        public IgnoreErrorFilter(ILogger<IgnoreErrorFilter<T>> logger)
        {
            this.logger = logger;
        }

        public override void Handle(T message, Action<T> next)
        {
            try
            {
                next(message);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, ""); // error logged, but do not propagate
            }
        }
    }



    public class DelayFilter<T> : AsyncMessageHandlerFilter<T>
    {
        readonly TimeSpan delaySpan;

        public DelayFilter(TimeSpan delaySpan)
        {
            this.delaySpan = delaySpan;
        }

        public override async ValueTask HandleAsync(T message, CancellationToken cancellationToken, Func<T, CancellationToken, ValueTask> next)
        {
            await Task.Delay(delaySpan, cancellationToken);
            await next(message, cancellationToken);
        }
    }
}


================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/MessagePipe.Sandbox.ConsoleApp.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
        <SignAssembly>true</SignAssembly>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="ConsoleAppFramework" Version="4.0.6" />
        <PackageReference Include="StackExchange.Redis" Version="2.5.61" />
        <PackageReference Include="ZLogger" Version="1.6.1" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
        <!--<ProjectReference Include="..\..\src\MessagePipe.Analyzer\MessagePipe.Analyzer\MessagePipe.Analyzer.csproj"
                          PrivateAssets="all"
                          ReferenceOutputAssembly="false"
                          OutputItemType="Analyzer" />-->
    </ItemGroup>

</Project>



================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/NapedPipeTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO.Pipes;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace MessagePipe.Sandbox.ConsoleApp
{
    public class NapedPipeTest
    {
        public async static Task Main()
        {
            string host = "127.0.0.1";
            int port = 1245;
            var ip = new IPEndPoint(IPAddress.Parse(host), port);

            var server = new NamedPipeServerStream("foo", PipeDirection.InOut, 1);
            var client = new NamedPipeClientStream(".", "foo", PipeDirection.InOut);

            await client.ConnectAsync();
            await server.WaitForConnectionAsync();
            
            var buffer = new byte[1024];
            var r = server.ReadAsync(buffer);
            client.Dispose(); // disconnected

            Console.WriteLine("WAIT FOREVER?");
            var i = await r;

            Console.WriteLine("OK?" + i); // 0 is ok
            await server.ReadAsync(buffer);
            Console.WriteLine("WAIT");

            server.Dispose();

            

            var newServer = new NamedPipeServerStream("foo", PipeDirection.InOut, 1);
            var newClient = new NamedPipeClientStream(".", "foo", PipeDirection.InOut);

            await newClient.ConnectAsync();
            await newServer.WaitForConnectionAsync();



        }

        static async Task ServerLoop(Socket server, TaskCompletionSource tcs)
        {
            var remote = await server.AcceptAsync();
            remote.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
            remote.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.TcpKeepAliveTime, 4);

            // await tcs.Task;    

            var buffer = new byte[1024];
            try
            {
                var get = await remote.ReceiveAsync(buffer, SocketFlags.None); // 0 is disconnect?
            }
            catch
            {
                Console.WriteLine("EX");
            }



        }
    }
}



================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/Program.cs
================================================
﻿#pragma warning disable CS8603 // Possible null reference return.
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

using ConsoleAppFramework;
using MessagePipe.Sandbox.ConsoleApp;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZLogger;

namespace MessagePipe
{
    public class MyOption
    {
        public int MyProperty { get; set; }
    }

    [IgnoreAutoRegistration]
    public class MyGenericsHandler<TR2> : IRequestHandler<string, TR2>
    {
        public TR2 Invoke(string request)
        {
            Console.WriteLine("everything default!");
            return default(TR2);
        }
    }
    //[IgnoreAutoRegistration]
    public class MyMyGenericsHandler<TR1, TR2> : IRequestHandler<TR1, TR2>
    {
        public TR2 Invoke(TR1 request)
        {
            Console.WriteLine("everything default!");
            return default(TR2);
        }
    }

    [IgnoreAutoRegistration]
    public class MyGenericsHandler2 : IRequestHandler<int, int>
    {
        public int Invoke(int request)
        {
            Console.WriteLine("everything default 2!");
            return default(int);
        }
    }

    class Program : ConsoleAppBase
    {
        static async Task Main3(string[] args)
        {
            var c = new ServiceCollection();
            var p = c.BuildServiceProvider();
            var p2 = p.GetRequiredService<IServiceProvider>();


            var host = Host.CreateDefaultBuilder()
                    .ConfigureServices((_, x) =>
                    {

                        x.AddMessagePipe();
                    })
                    .Build(); // build host before run.

            GlobalMessagePipe.SetProvider(host.Services); // set service provider

            await host.RunAsync(); // run framework.



            args = new[] { "moremore" };

            await Host.CreateDefaultBuilder()
                .ConfigureServices((_, x) =>
                {


                    x.AddMessagePipe(options =>
                    {
                        options.InstanceLifetime = InstanceLifetime.Singleton;
                        options.EnableCaptureStackTrace = true;

                        options.AddGlobalMessageHandlerFilter(typeof(MyFilter<>));
                        //options.AddGlobalMessageHandlerFilter<MyFilter<MyMessage>>();
                    });


                    //var interfaceType = typeof(IRequestHandlerCore<,>);
                    //var objectType = typeof(MyGenericsHandler<,>);
                    //x.Add(interfaceType, objectType, InstanceLifetime.Singleton);

                    //x.AddRequestHandler(typeof(MyMyGenericsHandler<,> ));
                    //x.AddRequestHandler(typeof(MyGenericsHandler<>));


                })
                .ConfigureLogging(x =>
                {
                    x.ClearProviders();
                    x.SetMinimumLevel(LogLevel.Information);
                    x.AddZLoggerConsole();
                })
                .RunConsoleAppFrameworkAsync<Program>(args);
        }

        IPublisher<string, MyMessage> publisher;
        ISubscriber<string, MyMessage> subscriber;
        IPublisher<MyMessage> keylessP;
        ISubscriber<MyMessage> keylessS;
        IAsyncPublisher<MyMessage> asyncKeylessP;
        IAsyncSubscriber<MyMessage> asyncKeylessS;


        IRequestHandler<Ping, Pong> pingponghandler;
        IRequestAllHandler<Ping, Pong> pingallhandler;
        // PingHandler pingpingHandler;


        IPublisher<int> intPublisher;
        ISubscriber<int> intSubscriber;

        IServiceScopeFactory scopeF;
        MessagePipeDiagnosticsInfo diagnosticsInfo;

        IServiceProvider provider;

        public Program(
            IPublisher<string, MyMessage> publisher,
            ISubscriber<string, MyMessage> subscriber,
            IPublisher<MyMessage> keyless1,
            ISubscriber<MyMessage> keyless2,

            IAsyncPublisher<MyMessage> asyncKeylessP,
            IAsyncSubscriber<MyMessage> asyncKeylessS,

            IRequestHandler<Ping, Pong> pingponghandler,
            //PingHandler pingpingHandler,
            IRequestAllHandler<Ping, Pong> pingallhandler,

            IPublisher<int> intP,
            ISubscriber<int> intS,
            IServiceScopeFactory scopeF,
            MessagePipeDiagnosticsInfo diagnosticsInfo,

            IServiceProvider provider


            )
        {
            this.provider = provider;
            this.scopeF = scopeF;
            this.publisher = publisher;
            this.subscriber = subscriber;
            this.keylessP = keyless1;
            this.keylessS = keyless2;
            this.asyncKeylessP = asyncKeylessP;
            this.asyncKeylessS = asyncKeylessS;
            this.pingponghandler = pingponghandler;
            //this.pingpingHandler = pingpingHandler;
            this.pingallhandler = pingallhandler;
            this.intPublisher = intP;
            this.intSubscriber = intS;
            this.diagnosticsInfo = diagnosticsInfo;

            var r1 = provider.GetRequiredService<IRequestHandler<string, int>>();
            r1.Invoke("foo");
        }

        [Command("keyed")]
        public void Keyed()
        {
            this.subscriber.Subscribe("foo", x =>
            {
                Console.WriteLine("A:" + x.MyProperty);
            });

            this.subscriber.Subscribe("foo", new MyFirst());

            var d = this.subscriber.Subscribe("foo", x =>
             {
                 Console.WriteLine("B:" + x.MyProperty);
             });

            publisher.Publish("foo", new MyMessage() { MyProperty = "tako" });
            publisher.Publish("foo", new MyMessage() { MyProperty = "yaki" });

            d.Dispose();

            publisher.Publish("foo", new MyMessage() { MyProperty = "kamo" });
        }

        [Command("keyless")]
        public void Keyless()
        {
            this.keylessS.Subscribe(x =>
            {
                Console.WriteLine("A:" + x.MyProperty);
            });

            var d = this.keylessS.Subscribe(x =>
            {
                Console.WriteLine("B:" + x.MyProperty);
            });


            keylessP.Publish(new MyMessage() { MyProperty = "tako" });
            keylessP.Publish(new MyMessage() { MyProperty = "yaki" });


            keylessS.AsObservable();


            d.Dispose();

            keylessP.Publish(new MyMessage() { MyProperty = "kamo" });
        }

        [Command("asynckeyless")]
        public async Task AsyncKeyless()
        {
            this.asyncKeylessS.Subscribe(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(2), ct);
                Console.WriteLine("A:" + x.MyProperty);
            });

            var d = this.asyncKeylessS.Subscribe(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(1), ct);
                Console.WriteLine("B:" + x.MyProperty);
            });

            await asyncKeylessP.PublishAsync(new MyMessage() { MyProperty = "tako" });
            await asyncKeylessP.PublishAsync(new MyMessage() { MyProperty = "yaki" });

            Console.WriteLine("here?");

            d.Dispose();

            await asyncKeylessP.PublishAsync(new MyMessage() { MyProperty = "kamo" });
        }

        [Command("ping")]
        public void Ping()
        {
            Console.WriteLine("ping");
            var pong = pingponghandler.Invoke(new Ping());
            Console.WriteLine("pong");
        }

        [Command("pingmany")]
        public void PingMany()
        {
            Console.WriteLine("ping");
            var pong = pingallhandler.InvokeAll(new Ping());
            foreach (var item in pong)
            {
                Console.WriteLine("pong");
            }
        }

        event Action myEventAction;

        [Command("myevent")]
        public void MyEvent()
        {
            myEventAction += () => Console.WriteLine("ev one");
            myEventAction += () => Console.WriteLine("ev two");
            myEventAction();

            myEventAction += () =>
            {
                Console.WriteLine("eve three and exception");
                throw new Exception("???");
            };

            myEventAction += () => Console.WriteLine("ev four");
            myEventAction();
        }

        [Command("mydelegate")]
        public void MyDelegate()
        {
            var d1 = new FooMore().GetDelegate();
            var d2 = new BarMore().GetDelegate();
        }

        [Command("filter")]
        public void Filter()
        {
            this.keylessS.Subscribe(new MyFirst());

            keylessP.Publish(new MyMessage() { MyProperty = "tako" });
            keylessP.Publish(new MyMessage() { MyProperty = "yaki" });
        }

        [Command("predicate")]
        public void Pred()
        {
            var d = DisposableBag.CreateBuilder();
            this.keylessS.Subscribe(x =>
            {
                Console.WriteLine("FilteredA:" + x.MyProperty);
            }, x => x.MyProperty == "foo" || x.MyProperty == "hoge")
                .AddTo(d);


            this.keylessS.Subscribe(x =>
            {
                Console.WriteLine("FilteredB:" + x.MyProperty);
            }, x => x.MyProperty == "foo" || x.MyProperty == "hage").AddTo(d);

            this.keylessP.Publish(new MyMessage { MyProperty = "nano" });
            this.keylessP.Publish(new MyMessage { MyProperty = "foo" });
            this.keylessP.Publish(new MyMessage { MyProperty = "hage" });
            this.keylessP.Publish(new MyMessage { MyProperty = "hoge" });

            this.intSubscriber.Subscribe(x => Console.WriteLine(x), x => x < 10).AddTo(d);
            this.intPublisher.Publish(999);
            this.intPublisher.Publish(5);

            d.Build().Dispose();
            d.Clear();
            Console.WriteLine("----");

            intSubscriber.Subscribe(x =>
            {
                Console.WriteLine("int one:" + x);
            }, new ChangedValueFilter<int>());

            intPublisher.Publish(100);
            intPublisher.Publish(200);
            intPublisher.Publish(200);
            intPublisher.Publish(299);


        }

        [Command("checkscope")]
        public void CheckScope()
        {

            var scope = scopeF.CreateScope();

            var scope2 = scopeF.CreateScope();

            var p = scope.ServiceProvider.GetRequiredService<IPublisher<long>>();
            var s = scope.ServiceProvider.GetRequiredService<ISubscriber<long>>();

            var p2 = scope2.ServiceProvider.GetRequiredService<IPublisher<long>>();
            var s2 = scope2.ServiceProvider.GetRequiredService<ISubscriber<long>>();

            var d = s.Subscribe(x => Console.WriteLine("foo:" + x));
            var d2 = s2.Subscribe(x => Console.WriteLine("bar:" + x));



            p.Publish(100);
            p.Publish(200);
            p.Publish(300);
            p2.Publish(999);


            scope.Dispose();

            p.Publish(129);
            s.Subscribe(_ => Console.WriteLine("s2???"));

            p2.Publish(1999);
        }

        [Command("moremore")]
        public void CheckMoreAndMore()
        {
            var req = provider.GetRequiredService<IRequestHandler<int, int>>();
            var all = provider.GetRequiredService<IRequestAllHandler<int, int>>();


            req.Invoke(100);


            intPublisher.Publish(10);
        }
    }



    public class PingHandler : IRequestHandler<Ping, Pong>
    {
        public Pong Invoke(Ping request)
        {
            Console.WriteLine("1 ping");
            return new Pong();
        }
    }

    public class PingHandler2 : IRequestHandler<Ping, Pong>
    {
        public Pong Invoke(Ping request)
        {
            Console.WriteLine("2 ping");
            return new Pong();
        }
    }


    public class MyClass
    {

    }


    public class MyFilter<T> : MessageHandlerFilter<T>
    {
        public override void Handle(T message, Action<T> next)
        {
            Console.WriteLine("before:" + Order);
            next(message);
            Console.WriteLine("after:" + Order);
        }
    }

    [MessageHandlerFilter(typeof(MyFilter<MyMessage>), Order = 30)]
    [MessageHandlerFilter(typeof(MyFilter<MyMessage>), Order = -99)]
    [MessageHandlerFilter(typeof(MyFilter<MyMessage>), Order = 1000)]
    public class MyFirst : IMessageHandler<MyMessage>
    {
        public void Handle(MyMessage message)
        {
            Console.WriteLine("YEAHHHH:" + message.MyProperty);
        }
    }


    public class Ping
    {
    }

    public class Pong
    {
    }

    public class FooMore
    {
        public int Tako;
        public int Nano;

        public Action GetDelegate() => Ahokkusu;

        public void Ahokkusu()
        {
            Console.WriteLine("nano");
        }
    }

    public struct BarMore
    {
        public int Tako;
        public int Nano;

        public Action GetDelegate() => Ahokkusu;

        public void Ahokkusu()
        {
            Console.WriteLine("nano");
        }
    }

    public class MyMessage
    {
        public string MyProperty { get; set; }
    }

    // .UseDistributedAsyncPublisher();


    // DistributedAsyncPublisher




    public class KeyedMessageBrokerCore<TKey, TValue>
    {

    }



    public class FirstHandler : IRequestHandler<int, int>
    {
        public int Invoke(int request)
        {
            Console.WriteLine("Called First!");
            return request;
        }
    }

    public class SecondHandler : IRequestHandler<int, int>
    {
        public int Invoke(int request)
        {
            Console.WriteLine("Called Second!");
            return request;
        }
    }

    public class ThirdHandler : IRequestHandler<int, int>
    {
        public int Invoke(int request)
        {
            Console.WriteLine("Called Third!");
            return request;
        }
    }



    public class MonitorTimer : IDisposable
    {
        CancellationTokenSource cts = new CancellationTokenSource();

        public MonitorTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)
        {
            RunTimer(diagnosticsInfo);
        }

        async void RunTimer(MessagePipeDiagnosticsInfo diagnosticsInfo)
        {
            while (!cts.IsCancellationRequested)
            {
                // show SubscribeCount
                Console.WriteLine(diagnosticsInfo.SubscribeCount);
                await Task.Delay(TimeSpan.FromSeconds(5), cts.Token);
            }
        }

        public void Dispose()
        {
            cts.Cancel();
        }
    }


    [MessageHandlerFilter(typeof(ChangedValueFilter<>))]
    public class WriteLineHandler<T> : IMessageHandler<T>
    {
        public void Handle(T message) => Console.WriteLine(message);
    }


    public class DelayRequestFilter : AsyncRequestHandlerFilter<int, int>
    {
        public override async ValueTask<int> InvokeAsync(int request, CancellationToken cancellationToken, Func<int, CancellationToken, ValueTask<int>> next)
        {
            await Task.Delay(TimeSpan.FromSeconds(request));
            var response = await next(request, cancellationToken);
            return response;
        }
    }

    public class Command1
    {
    }

    public class Response1
    {
    }

    public class Command2
    {
    }

    public class Response2
    {
    }


    public class MultiHandler :
        IAsyncRequestHandler<Command1, Response1>,
        IAsyncRequestHandler<Command2, Response2>
    {
        public ValueTask<Response1> InvokeAsync(Command1 request, CancellationToken cancellationToken = default)
        {
            return default;
        }

        public ValueTask<Response2> InvokeAsync(Command2 request, CancellationToken cancellationToken = default)
        {
            return default;
        }
    }


}



================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/TcpTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace MessagePipe.Sandbox.ConsoleApp
{
    public class TcpTest
    {
        public async static Task Main2()
        {
            string host = "127.0.0.1";
            int port = 1245;
            var ip = new IPEndPoint(IPAddress.Parse(host), port);

            var server = new Socket(ip.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            server.ReceiveTimeout = 1000;
            server.NoDelay = true;

            server.Bind(ip);
            server.Listen(10);

            var tcs = new TaskCompletionSource();
            _ = ServerLoop(server, tcs);

            var client = new Socket(ip.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            client.Connect(ip);



            Console.ReadLine();

            Console.WriteLine("DISCONNECT");
            //client.Disconnect(false);



            /*
            Console.WriteLine("START SEND");

            var byte1 = Encoding.UTF8.GetBytes("foo");
            var byte2 = Encoding.UTF8.GetBytes("bar");
            client.Send(byte1, byte1.Length, SocketFlags.None);
            client.Send(byte2, byte2.Length, SocketFlags.None);



            tcs.TrySetResult();
            */

            Console.ReadLine();
            await Task.Yield();
        }

        static async Task ServerLoop(Socket server, TaskCompletionSource tcs)
        {
            var remote = await server.AcceptAsync();
            remote.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
            remote.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.TcpKeepAliveTime, 4);

            // await tcs.Task;    

            var buffer = new byte[1024];
            try
            {
                var get = await remote.ReceiveAsync(buffer, SocketFlags.None); // 0 is disconnect?
            }
            catch
            {
                Console.WriteLine("EX");
            }



        }
    }
}



================================================
FILE: sandbox/MessagePipe.Sandbox.ConsoleApp/Properties/launchSettings.json
================================================
{
  "profiles": {
    "MessagePipe.Sandbox.ConsoleApp": {
      "commandName": "Project"
    },
    "ping": {
      "commandName": "Project",
      "commandLineArgs": "ping"
    },
    "pingmany": {
      "commandName": "Project",
      "commandLineArgs": "pingmany"
    }
  }
}


================================================
FILE: src/MessagePipe/_InternalVisibleTo.cs
================================================
﻿using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("MessagePipe.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]
[assembly: InternalsVisibleTo("MessagePipe.Sandbox.ConsoleApp, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]


================================================
FILE: src/MessagePipe/AsyncMessageBroker.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public class AsyncMessageBroker<TMessage> : IAsyncPublisher<TMessage>, IAsyncSubscriber<TMessage>
    {
        readonly AsyncMessageBrokerCore<TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public AsyncMessageBroker(AsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public IDisposable Subscribe(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateAsyncMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class AsyncMessageBrokerCore<TMessage> : IDisposable, IHandlerHolderMarker
    {
        FreeList<IAsyncMessageHandler<TMessage>> handlers;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate = new object();
        bool isDisposed;

        [Preserve]
        public AsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlers = new FreeList<IAsyncMessageHandler<TMessage>>();
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.diagnotics = diagnotics;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            var array = handlers.GetValues();
            for (int i = 0; i < array.Length; i++)
            {
                array[i]?.HandleAsync(message, cancellationToken).Forget();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return PublishAsync(message, defaultAsyncPublishStrategy, cancellationToken);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            var array = handlers.GetValues();
            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                foreach (var item in array)
                {
                    if (item != null)
                    {
                        await item.HandleAsync(message, cancellationToken);
                    }
                }
            }
            else
            {
                await new AsyncHandlerWhenAll<TMessage>(array, message, cancellationToken);
            }
        }

        public IDisposable Subscribe(IAsyncMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(AsyncMessageBrokerCore<TMessage>));

                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(this, subscriptionKey);
                diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                // Dispose is called when scope is finished.
                if (!isDisposed && handlers.TryDispose(out var count))
                {
                    isDisposed = true;
                    diagnotics.RemoveTargetDiagnostics(this, count);
                }
            }
        }

        sealed class Subscription : IDisposable
        {
            bool isDisposed;
            readonly AsyncMessageBrokerCore<TMessage> core;
            readonly int subscriptionKey;

            public Subscription(AsyncMessageBrokerCore<TMessage> core, int subscriptionKey)
            {
                this.core = core;
                this.subscriptionKey = subscriptionKey;
            }

            public void Dispose()
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    lock (core.gate)
                    {
                        core.handlers.Remove(subscriptionKey, true);
                        core.diagnotics.DecrementSubscribe(core, this);
                    }
                }
            }
        }
    }

    [Preserve]
    public sealed class BufferedAsyncMessageBroker<TMessage> : IBufferedAsyncPublisher<TMessage>, IBufferedAsyncSubscriber<TMessage>
    {
        readonly BufferedAsyncMessageBrokerCore<TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public BufferedAsyncMessageBroker(BufferedAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public ValueTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            return SubscribeAsync(handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken)
        {
            handler = handlerFactory.CreateAsyncMessageHandler(handler, filters);
            return core.SubscribeAsync(handler, cancellationToken);
        }
    }

    [Preserve]
    public sealed class BufferedAsyncMessageBrokerCore<TMessage>
    {
        static readonly bool IsValueType = typeof(TMessage).IsValueType;

        readonly AsyncMessageBrokerCore<TMessage> core;
        TMessage? lastMessage;

        [Preserve]
        public BufferedAsyncMessageBrokerCore(AsyncMessageBrokerCore<TMessage> core)
        {
            this.core = core;
            this.lastMessage = default;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            lastMessage = message;
            core.Publish(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            lastMessage = message;
            return core.PublishAsync(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            lastMessage = message;
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public async ValueTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            if (IsValueType || lastMessage != null)
            {
                await handler.HandleAsync(lastMessage!, cancellationToken);
            }
            return core.Subscribe(handler);
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonAsyncMessageBroker<TMessage> : AsyncMessageBroker<TMessage>, ISingletonAsyncPublisher<TMessage>, ISingletonAsyncSubscriber<TMessage>
    {
        [Preserve]
        public SingletonAsyncMessageBroker(SingletonAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBroker<TMessage> : AsyncMessageBroker<TMessage>, IScopedAsyncPublisher<TMessage>, IScopedAsyncSubscriber<TMessage>
    {
        [Preserve]
        public ScopedAsyncMessageBroker(ScopedAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonAsyncMessageBrokerCore<TMessage> : AsyncMessageBrokerCore<TMessage>
    {
        [Preserve]
        public SingletonAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBrokerCore<TMessage> : AsyncMessageBrokerCore<TMessage>
    {
        [Preserve]
        public ScopedAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe/AsyncMessageBroker_Key.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public class AsyncMessageBroker<TKey, TMessage> : IAsyncPublisher<TKey, TMessage>, IAsyncSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        readonly AsyncMessageBrokerCore<TKey, TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public AsyncMessageBroker(AsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(key, message, cancellationToken);
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(key, message, cancellationToken);
        }

        public ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(key, message, publishStrategy, cancellationToken);
        }

        public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(key, handlerFactory.CreateAsyncMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class AsyncMessageBrokerCore<TKey, TMessage> : IDisposable
        where TKey : notnull
    {
        readonly Dictionary<TKey, HandlerHolder> handlerGroup;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate;
        bool isDisposed;

        [Preserve]
        public AsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlerGroup = new Dictionary<TKey, HandlerHolder>();
            this.diagnotics = diagnotics;
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.gate = new object();
        }

        public void Publish(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            IAsyncMessageHandler<TMessage>?[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            for (int i = 0; i < handlers.Length; i++)
            {
                handlers[i]?.HandleAsync(message, cancellationToken).Forget();
            }
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            return PublishAsync(key, message, defaultAsyncPublishStrategy, cancellationToken);
        }

        public async ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            IAsyncMessageHandler<TMessage>?[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                foreach (var item in handlers)
                {
                    if (item != null)
                    {
                        await item.HandleAsync(message, cancellationToken);
                    }
                }
            }
            else
            {
                await new AsyncHandlerWhenAll<TMessage>(handlers, message, cancellationToken);
            }
        }

        public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(AsyncMessageBrokerCore<TKey, TMessage>));

                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    handlerGroup[key] = holder = new HandlerHolder(this);
                }

                return holder.Subscribe(key, handler);
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    foreach (var handlers in handlerGroup.Values)
                    {
                        handlers.Dispose();
                    }
                }
            }
        }

        // similar as Keyless-MessageBrokerCore but require to remove when key is empty on Dispose
        sealed class HandlerHolder : IDisposable, IHandlerHolderMarker
        {
            readonly FreeList<IAsyncMessageHandler<TMessage>> handlers;
            readonly AsyncMessageBrokerCore<TKey, TMessage> core;

            public HandlerHolder(AsyncMessageBrokerCore<TKey, TMessage> core)
            {
                this.handlers = new FreeList<IAsyncMessageHandler<TMessage>>();
                this.core = core;
            }

            public IAsyncMessageHandler<TMessage>?[] GetHandlers() => handlers.GetValues();

            public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler)
            {
                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(key, subscriptionKey, this);
                core.diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }

            public void Dispose()
            {
                lock (core.gate)
                {
                    if (handlers.TryDispose(out var count))
                    {
                        core.diagnotics.RemoveTargetDiagnostics(this, count);
                    }
                }
            }

            sealed class Subscription : IDisposable
            {
                bool isDisposed;
                readonly TKey key;
                readonly int subscriptionKey;
                readonly HandlerHolder holder;

                public Subscription(TKey key, int subscriptionKey, HandlerHolder holder)
                {
                    this.key = key;
                    this.subscriptionKey = subscriptionKey;
                    this.holder = holder;
                }

                public void Dispose()
                {
                    if (!isDisposed)
                    {
                        isDisposed = true;
                        lock (holder.core.gate)
                        {
                            if (!holder.core.isDisposed)
                            {
                                holder.handlers.Remove(subscriptionKey, false);
                                holder.core.diagnotics.DecrementSubscribe(holder, this);
                                if (holder.handlers.GetCount() == 0)
                                {
                                    holder.core.handlerGroup.Remove(key);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonAsyncMessageBroker<TKey, TMessage> : AsyncMessageBroker<TKey, TMessage>, ISingletonAsyncPublisher<TKey, TMessage>, ISingletonAsyncSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        public SingletonAsyncMessageBroker(SingletonAsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonAsyncMessageBrokerCore<TKey, TMessage> : AsyncMessageBrokerCore<TKey, TMessage>
        where TKey : notnull
    {
        public SingletonAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBroker<TKey, TMessage> : AsyncMessageBroker<TKey, TMessage>, IScopedAsyncPublisher<TKey, TMessage>, IScopedAsyncSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        public ScopedAsyncMessageBroker(ScopedAsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBrokerCore<TKey, TMessage> : AsyncMessageBrokerCore<TKey, TMessage>
        where TKey : notnull
    {
        public ScopedAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe/AsyncRequestHandler.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // async

    [Preserve]
    public sealed class AsyncRequestHandler<TRequest, TResponse> : IAsyncRequestHandler<TRequest, TResponse>
    {
        readonly IAsyncRequestHandlerCore<TRequest, TResponse> handler;

        [Preserve]
        public AsyncRequestHandler(IAsyncRequestHandlerCore<TRequest, TResponse> handler, FilterAttachedAsyncRequestHandlerFactory handlerFactory)
        {
            this.handler = handlerFactory.CreateAsyncRequestHandler<TRequest, TResponse>(handler);
        }

        public ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return handler.InvokeAsync(request, cancellationToken);
        }
    }

    [Preserve]
    public sealed class AsyncRequestAllHandler<TRequest, TResponse> : IAsyncRequestAllHandler<TRequest, TResponse>
    {
        readonly IAsyncRequestHandlerCore<TRequest, TResponse>[] handlers;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;

        [Preserve]
        public AsyncRequestAllHandler(IEnumerable<IAsyncRequestHandlerCore<TRequest, TResponse>> handlers, FilterAttachedAsyncRequestHandlerFactory handlerFactory, MessagePipeOptions options)
        {
            var collection = (handlers as ICollection<IAsyncRequestHandlerCore<TRequest, TResponse>>) ?? handlers.ToArray();

            var array = new IAsyncRequestHandlerCore<TRequest, TResponse>[collection.Count];
            var i = 0;
            foreach (var item in collection)
            {
                array[i++] = handlerFactory.CreateAsyncRequestHandler(item);
            }

            this.handlers = array;
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
        }

        public ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken)
        {
            return InvokeAllAsync(request, defaultAsyncPublishStrategy, cancellationToken);
        }

        public async ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                var responses = new TResponse[handlers.Length];
                for (int i = 0; i < handlers.Length; i++)
                {
                    responses[i] = await handlers[i].InvokeAsync(request, cancellationToken);
                }
                return responses;
            }
            else
            {
                return await new AsyncRequestHandlerWhenAll<TRequest, TResponse>(handlers, request, cancellationToken);
            }
        }

#if UNITY_2018_3_OR_NEWER

        public Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken)
        {

           return Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.Create<TResponse>(async (writer, token) =>
           {
               for (int i = 0; i < handlers.Length; i++)
               {
                   await writer.YieldAsync(await handlers[i].InvokeAsync(request, cancellationToken));
               }
           });
        }
#else

        public async IAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, [EnumeratorCancellation] CancellationToken cancellationToken)
        {
            for (int i = 0; i < handlers.Length; i++)
            {
                yield return await handlers[i].InvokeAsync(request, cancellationToken);
            }
        }

#endif
    }
}


================================================
FILE: src/MessagePipe/AttributeFilterProvider.cs
================================================
﻿#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using MessagePipe.Internal;

namespace MessagePipe
{
    // not intended to use directly, use FilterAttachedMessageHandlerFactory.

    [Preserve]
    public sealed class AttributeFilterProvider<TAttribute>
        where TAttribute : IMessagePipeFilterAttribute
    {
        // cache attribute defines.
        readonly ConcurrentDictionary<Type, AttributeFilterDefinition[]> cache = new ConcurrentDictionary<Type, AttributeFilterDefinition[]>();

        [Preserve]
        public AttributeFilterProvider()
        {

        }

        public (int, IEnumerable<IMessagePipeFilter>) GetAttributeFilters(Type handlerType, IServiceProvider provider)
        {
            if (cache.TryGetValue(handlerType, out var value))
            {
                if (value.Length == 0) return (0, Array.Empty<IMessagePipeFilter>());
                return (value.Length, CreateFilters(value, provider));
            }

            // require to get all filter for alidate.
            var filterAttributes = handlerType.GetCustomAttributes(typeof(IMessagePipeFilterAttribute), true).OfType<TAttribute>().ToArray();
            if (filterAttributes.Length == 0)
            {
                cache[handlerType] = Array.Empty<AttributeFilterDefinition>();
                return (0, Array.Empty<IMessagePipeFilter>());
            }
            else
            {
                var array = filterAttributes.Cast<TAttribute>().Select(x => new AttributeFilterDefinition(x.Type, x.Order)).ToArray();
                var filterDefinitions = cache.GetOrAdd(handlerType, array);
                return (filterDefinitions.Length, CreateFilters(filterDefinitions, provider));
            }
        }

        static IEnumerable<IMessagePipeFilter> CreateFilters(AttributeFilterDefinition[] filterDefinitions, IServiceProvider provider)
        {
            foreach (var filterDefinition in filterDefinitions)
            {
                var f = (IMessagePipeFilter)provider.GetRequiredService(filterDefinition.FilterType);
                f.Order = filterDefinition.Order;
                yield return f;
            }
        }
    }
}


================================================
FILE: src/MessagePipe/DisposableBag.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Threading;

namespace MessagePipe
{
    public static partial class DisposableBag
    {
        public static IDisposable Create(params IDisposable[] disposables)
        {
            return new NthDisposable(disposables);
        }

        sealed class NthDisposable : IDisposable
        {
            bool disposed;
            readonly IDisposable[] disposables;

            public NthDisposable(IDisposable[] disposables)
            {
                this.disposables = disposables;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    foreach (var item in disposables)
                    {
                        item.Dispose();
                    }
                }
            }
        }

        public static SingleAssignmentDisposable CreateSingleAssignment()
        {
            return new SingleAssignmentDisposable();
        }

        public static CancellationTokenDisposable CreateCancellation()
        {
            return new CancellationTokenDisposable();
        }

        public static DisposableBagBuilder CreateBuilder()
        {
            return new DisposableBagBuilder();
        }

        public static DisposableBagBuilder CreateBuilder(int initialCapacity)
        {
            return new DisposableBagBuilder(initialCapacity);
        }

        public static IDisposable Empty => EmptyDisposable.Instance;

        public static void AddTo(this IDisposable disposable, DisposableBagBuilder disposableBag)
        {
            disposableBag.Add(disposable);
        }

        public static SingleAssignmentDisposable SetTo(this IDisposable disposable, SingleAssignmentDisposable singleAssignmentDisposable)
        {
            singleAssignmentDisposable.Disposable = disposable;
            return singleAssignmentDisposable;
        }
    }

    internal class EmptyDisposable : IDisposable
    {
        internal static readonly IDisposable Instance = new EmptyDisposable();

        EmptyDisposable()
        {
        }

        public void Dispose()
        {
        }
    }

    public partial class DisposableBagBuilder
    {
        readonly List<IDisposable> disposables;

        internal DisposableBagBuilder()
        {
            disposables = new List<IDisposable>();
        }

        internal DisposableBagBuilder(int initialCapacity)
        {
            disposables = new List<IDisposable>(initialCapacity);
        }

        public void Add(IDisposable disposable)
        {
            disposables.Add(disposable);
        }

        public void Clear()
        {
            foreach (var item in disposables)
            {
                item.Dispose();
            }
            disposables.Clear();
        }

        //public IDisposable Build() in Disposables.tt(Disposables.cs)
    }

    public sealed class SingleAssignmentDisposable : IDisposable
    {
        IDisposable? inner;
        bool isDisposed;
        readonly object gate = new object();

        public IDisposable Disposable
        {
            set
            {
                lock (gate)
                {
                    if (isDisposed)
                    {
                        // already disposed, dispose immediately
                        value.Dispose();
                        return;
                    }
                    else
                    {
                        if (inner == null)
                        {
                            // set new Disposable once.
                            inner = value;
                            return;
                        }
                        else
                        {
                            // set twice is invalid.
                            throw new InvalidOperationException("Set IDisposable twice is invalid.");
                        }
                    }
                }
            }
        }

        public void Dispose()
        {
            if (isDisposed) return;
            lock (gate)
            {
                isDisposed = true;
                if (inner != null)
                {
                    inner.Dispose();
                    inner = null;
                }
            }
        }
    }

    public sealed class CancellationTokenDisposable : IDisposable
    {
        CancellationTokenSource cancellationTokenSource;
        public CancellationToken Token => cancellationTokenSource.Token;

        public CancellationTokenDisposable()
        {
            this.cancellationTokenSource = new CancellationTokenSource();
        }

        public void Dispose()
        {
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
        }
    }
}



================================================
FILE: src/MessagePipe/Disposables.cs
================================================
﻿// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Disposables.tt. DO NOT CHANGE IT.
// </auto-generated>
using System;

namespace MessagePipe
{
    public static partial class DisposableBag
    {
        public static IDisposable Create(IDisposable disposable1)
        {
            return new Disposable1(disposable1);
        }

        sealed class Disposable1 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            
            public Disposable1(IDisposable disposable1)
            {
                this.disposable1 = disposable1;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2)
        {
            return new Disposable2(disposable1, disposable2);
        }

        sealed class Disposable2 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            
            public Disposable2(IDisposable disposable1, IDisposable disposable2)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
        {
            return new Disposable3(disposable1, disposable2, disposable3);
        }

        sealed class Disposable3 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            
            public Disposable3(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4)
        {
            return new Disposable4(disposable1, disposable2, disposable3, disposable4);
        }

        sealed class Disposable4 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            
            public Disposable4(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5)
        {
            return new Disposable5(disposable1, disposable2, disposable3, disposable4, disposable5);
        }

        sealed class Disposable5 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            
            public Disposable5(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6)
        {
            return new Disposable6(disposable1, disposable2, disposable3, disposable4, disposable5, disposable6);
        }

        sealed class Disposable6 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            readonly IDisposable disposable6;
            
            public Disposable6(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
                this.disposable6 = disposable6;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                    disposable6.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6, IDisposable disposable7)
        {
            return new Disposable7(disposable1, disposable2, disposable3, disposable4, disposable5, disposable6, disposable7);
        }

        sealed class Disposable7 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            readonly IDisposable disposable6;
            readonly IDisposable disposable7;
            
            public Disposable7(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6, IDisposable disposable7)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
                this.disposable6 = disposable6;
                this.disposable7 = disposable7;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                    disposable6.Dispose();
                    disposable7.Dispose();
                }
            }
        }

    }

    public partial class DisposableBagBuilder
    {
        public IDisposable Build()
        {
            switch (disposables.Count)
            {
                case 0:
                    return DisposableBag.Empty;
                case 1:
                    return DisposableBag.Create(disposables[0]);
                case 2:
                    return DisposableBag.Create(disposables[0], disposables[1]);
                case 3:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2]);
                case 4:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3]);
                case 5:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4]);
                case 6:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4], disposables[5]);
                case 7:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4], disposables[5], disposables[6]);
                default:
                    return DisposableBag.Create(disposables.ToArray());
            }
        }
    }
}


================================================
FILE: src/MessagePipe/Disposables.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Disposables.tt. DO NOT CHANGE IT.
// </auto-generated>
using System;

namespace MessagePipe
{
    public static partial class DisposableBag
    {
<# for(var i = 1; i <= 7; i++) { #>
        public static IDisposable Create(<#= string.Join(", ", Enumerable.Range(1, i).Select(x => "IDisposable disposable" + x)) #>)
        {
            return new Disposable<#= i #>(<#= string.Join(", ", Enumerable.Range(1, i).Select(x => "disposable" + x)) #>);
        }

        sealed class Disposable<#= i #> : IDisposable
        {
            bool disposed;
<# for(var j = 1; j <= i; j++) { #>
            readonly IDisposable disposable<#= j #>;
<# } #>
            
            public Disposable<#= i #>(<#= string.Join(", ", Enumerable.Range(1, i).Select(x => "IDisposable disposable" + x)) #>)
            {
<# for(var j = 1; j <= i; j++) { #>
                this.disposable<#= j #> = disposable<#= j #>;
<# } #>
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
<# for(var j = 1; j <= i; j++) { #>
                    disposable<#= j #>.Dispose();
<# } #>
                }
            }
        }

<# } #>
    }

    public partial class DisposableBagBuilder
    {
        public IDisposable Build()
        {
            switch (disposables.Count)
            {
                case 0:
                    return DisposableBag.Empty;
<# for(var i = 1; i <= 7; i++) { #>
                case <#= i #>:
                    return DisposableBag.Create(<#= string.Join(", ", Enumerable.Range(0, i).Select(x => "disposables[" + x + "]")) #>);
<# } #>
                default:
                    return DisposableBag.Create(disposables.ToArray());
            }
        }
    }
}


================================================
FILE: src/MessagePipe/DistributedSubscriberExtensions.cs
================================================
﻿using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    public static class DistributedSubscriberExtensions
    {
        // sync handler

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(key, new AnonymousMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, predicate, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : Append(filters, predicateFilter);

            return subscriber.SubscribeAsync(key, new AnonymousMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        // async handler

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, predicate, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : Append(filters, predicateFilter);

            return subscriber.SubscribeAsync(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        static T[] Append<T>(T[] source, T item)
        {
            var dest = new T[source.Length + 1];
            Array.Copy(source, 0, dest, 0, source.Length);
            dest[dest.Length - 1] = item;
            return dest;
        }
    }
}


================================================
FILE: src/MessagePipe/EventFactory.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public sealed class EventFactory
    {
        readonly MessagePipeOptions options;
        readonly MessagePipeDiagnosticsInfo diagnosticsInfo;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public EventFactory(
                MessagePipeOptions options,
                MessagePipeDiagnosticsInfo diagnosticsInfo,
                FilterAttachedMessageHandlerFactory handlerFactory,
                FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.diagnosticsInfo = diagnosticsInfo;
            this.handlerFactory = handlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;
        }

        public (IDisposablePublisher<T>, ISubscriber<T>) CreateEvent<T>()
        {
            var core = new MessageBrokerCore<T>(diagnosticsInfo, options);
            var publisher = new DisposablePublisher<T>(core);
            var subscriber = new MessageBroker<T>(core, handlerFactory);
            return (publisher, subscriber);
        }

        public (IDisposableAsyncPublisher<T>, IAsyncSubscriber<T>) CreateAsyncEvent<T>()
        {
            var core = new AsyncMessageBrokerCore<T>(diagnosticsInfo, options);
            var publisher = new DisposableAsyncPublisher<T>(core);
            var subscriber = new AsyncMessageBroker<T>(core, asyncHandlerFactory);
            return (publisher, subscriber);
        }

        public (IDisposableBufferedPublisher<T>, IBufferedSubscriber<T>) CreateBufferedEvent<T>(T initialValue)
        {
            var innerCore = new MessageBrokerCore<T>(diagnosticsInfo, options);
            var core = new BufferedMessageBrokerCore<T>(innerCore);
            var broker = new BufferedMessageBroker<T>(core, handlerFactory);
            var publisher = new DisposableBufferedPublisher<T>(broker, innerCore);
            var subscriber = broker;
            publisher.Publish(initialValue);
            return (publisher, subscriber);
        }

        public (IDisposableBufferedAsyncPublisher<T>, IBufferedAsyncSubscriber<T>) CreateBufferedAsyncEvent<T>(T initialValue)
        {
            var innerCore = new AsyncMessageBrokerCore<T>(diagnosticsInfo, options);
            var core = new BufferedAsyncMessageBrokerCore<T>(innerCore);
            var broker = new BufferedAsyncMessageBroker<T>(core, asyncHandlerFactory);
            var publisher = new DisposableBufferedAsyncPublisher<T>(broker, innerCore);
            var subscriber = broker;
            publisher.Publish(initialValue, CancellationToken.None); // set initial value is completely sync.
            return (publisher, subscriber);
        }
    }

    public interface IDisposablePublisher<TMessage> : IPublisher<TMessage>, IDisposable
    {
    }

    public interface IDisposableBufferedPublisher<TMessage> : IBufferedPublisher<TMessage>, IDisposable
    {
    }

    internal class DisposablePublisher<TMessage> : IDisposablePublisher<TMessage>
    {
        readonly MessageBrokerCore<TMessage> core;

        public DisposablePublisher(MessageBrokerCore<TMessage> core)
        {
            this.core = core;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public void Dispose()
        {
            core.Dispose();
        }
    }

    internal class DisposableBufferedPublisher<TMessage> : IDisposableBufferedPublisher<TMessage>
    {
        readonly BufferedMessageBroker<TMessage> broker;
        readonly IDisposable disposable;

        public DisposableBufferedPublisher(BufferedMessageBroker<TMessage> broker, IDisposable disposable)
        {
            this.broker = broker;
            this.disposable = disposable;
        }

        public void Publish(TMessage message)
        {
            broker.Publish(message);
        }

        public void Dispose()
        {
            disposable.Dispose();
        }
    }

    public interface IDisposableAsyncPublisher<TMessage> : IAsyncPublisher<TMessage>, IDisposable
    {
    }

    public interface IDisposableBufferedAsyncPublisher<TMessage> : IBufferedAsyncPublisher<TMessage>, IDisposable
    {
    }

    internal sealed class DisposableAsyncPublisher<TMessage> : IDisposableAsyncPublisher<TMessage>
    {
        readonly AsyncMessageBrokerCore<TMessage> core;

        public DisposableAsyncPublisher(AsyncMessageBrokerCore<TMessage> core)
        {
            this.core = core;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public void Dispose()
        {
            core.Dispose();
        }
    }

    internal sealed class DisposableBufferedAsyncPublisher<TMessage> : IDisposableBufferedAsyncPublisher<TMessage>
    {
        readonly BufferedAsyncMessageBroker<TMessage> broker;
        readonly IDisposable disposable;

        public DisposableBufferedAsyncPublisher(BufferedAsyncMessageBroker<TMessage> broker, IDisposable disposable)
        {
            this.broker = broker;
            this.disposable = disposable;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            broker.Publish(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return broker.PublishAsync(message, cancellationToken);
        }

        public ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return broker.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public void Dispose()
        {
            disposable.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe/FilterAttachedAsyncMessageHandlerFactory.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // Async

    [Preserve]
    public sealed class FilterAttachedAsyncMessageHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<AsyncMessageHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedAsyncMessageHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<AsyncMessageHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IAsyncMessageHandler<TMessage> CreateAsyncMessageHandler<TMessage>(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var (globalLength, globalFilters) = options.GetGlobalAsyncMessageHandlerFilters(provider, typeof(TMessage));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (filters.Length != 0 || globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedAsyncMessageHandler<TMessage>(handler, globalFilters.Concat(handlerFilters).Concat(filters).Cast<AsyncMessageHandlerFilter<TMessage>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedAsyncMessageHandler<T> : IAsyncMessageHandler<T>
    {
        Func<T, CancellationToken, ValueTask> handler;

        public FilterAttachedAsyncMessageHandler(IAsyncMessageHandler<T> body, IEnumerable<AsyncMessageHandlerFilter<T>> filters)
        {
            Func<T, CancellationToken, ValueTask> next = body.HandleAsync;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new AsyncMessageHandlerFilterRunner<T>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public ValueTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            return handler.Invoke(message, cancellationToken);
        }
    }

    internal sealed class AsyncMessageHandlerFilterRunner<T>
    {
        readonly AsyncMessageHandlerFilter<T> filter;
        readonly Func<T, CancellationToken, ValueTask> next;

        public AsyncMessageHandlerFilterRunner(AsyncMessageHandlerFilter<T> filter, Func<T, CancellationToken, ValueTask> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<T, CancellationToken, ValueTask> GetDelegate() => HandleAsync;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        ValueTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            return filter.HandleAsync(message, cancellationToken, next);
        }
    }
}


================================================
FILE: src/MessagePipe/FilterAttachedAsyncRequestHandlerFactory.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // Async

    [Preserve]
    public sealed class FilterAttachedAsyncRequestHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<AsyncRequestHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedAsyncRequestHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<AsyncRequestHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IAsyncRequestHandlerCore<TRequest, TResponse> CreateAsyncRequestHandler<TRequest, TResponse>(IAsyncRequestHandlerCore<TRequest, TResponse> handler)
        {
            var (globalLength, globalFilters) = options.GetGlobalAsyncRequestHandlerFilters(provider, typeof(TRequest), typeof(TResponse));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedAsyncRequestHandler<TRequest, TResponse>(handler, globalFilters.Concat(handlerFilters).Cast<AsyncRequestHandlerFilter<TRequest, TResponse>>());
            }

            return handler;
        }
    }


    internal sealed class FilterAttachedAsyncRequestHandler<TRequest, TResponse> : IAsyncRequestHandler<TRequest, TResponse>
    {
        Func<TRequest, CancellationToken, ValueTask<TResponse>> handler;

        public FilterAttachedAsyncRequestHandler(IAsyncRequestHandlerCore<TRequest, TResponse> body, IEnumerable<AsyncRequestHandlerFilter<TRequest, TResponse>> filters)
        {
            Func<TRequest, CancellationToken, ValueTask<TResponse>> next = body.InvokeAsync;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new AsyncRequestHandlerFilterRunner<TRequest, TResponse>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken)
        {
            return handler(request, cancellationToken);
        }
    }

    internal sealed class AsyncRequestHandlerFilterRunner<TRequest, TResponse>
    {
        readonly AsyncRequestHandlerFilter<TRequest, TResponse> filter;
        readonly Func<TRequest, CancellationToken, ValueTask<TResponse>> next;

        public AsyncRequestHandlerFilterRunner(AsyncRequestHandlerFilter<TRequest, TResponse> filter, Func<TRequest, CancellationToken, ValueTask<TResponse>> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<TRequest, CancellationToken, ValueTask<TResponse>> GetDelegate() => InvokeAsync;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken)
        {
            return filter.InvokeAsync(request, cancellationToken, next);
        }
    }
}


================================================
FILE: src/MessagePipe/FilterAttachedMessageHandlerFactory.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // Sync

    [Preserve]
    public sealed class FilterAttachedMessageHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<MessageHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedMessageHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<MessageHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IMessageHandler<TMessage> CreateMessageHandler<TMessage>(IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters)
        {
            var (globalLength, globalFilters) = options.GetGlobalMessageHandlerFilters(provider, typeof(TMessage));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (filters.Length != 0 || globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedMessageHandler<TMessage>(handler, globalFilters.Concat(handlerFilters).Concat(filters).Cast<MessageHandlerFilter<TMessage>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedMessageHandler<T> : IMessageHandler<T>
    {
        Action<T> handler;

        public FilterAttachedMessageHandler(IMessageHandler<T> body, IEnumerable<MessageHandlerFilter<T>> filters)
        {
            Action<T> next = body.Handle;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new MessageHandlerFilterRunner<T>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public void Handle(T message)
        {
            handler(message);
        }
    }

    internal sealed class MessageHandlerFilterRunner<T>
    {
        readonly MessageHandlerFilter<T> filter;
        readonly Action<T> next;

        public MessageHandlerFilterRunner(MessageHandlerFilter<T> filter, Action<T> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Action<T> GetDelegate() => Handle;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void Handle(T message)
        {
            filter.Handle(message, next);
        }
    }
}


================================================
FILE: src/MessagePipe/FilterAttachedRequestHandlerFactory.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace MessagePipe
{
    // Sync

    [Preserve]
    public sealed class FilterAttachedRequestHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<RequestHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedRequestHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<RequestHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IRequestHandlerCore<TRequest, TResponse> CreateRequestHandler<TRequest, TResponse>(IRequestHandlerCore<TRequest, TResponse> handler)
        {
            var (globalLength, globalFilters) = options.GetGlobalRequestHandlerFilters(provider, typeof(TRequest), typeof(TResponse));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedRequestHandler<TRequest, TResponse>(handler, globalFilters.Concat(handlerFilters).Cast<RequestHandlerFilter<TRequest, TResponse>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedRequestHandler<TRequest, TResponse> : IRequestHandler<TRequest, TResponse>
    {
        Func<TRequest, TResponse> handler;

        public FilterAttachedRequestHandler(IRequestHandlerCore<TRequest, TResponse> body, IEnumerable<RequestHandlerFilter<TRequest, TResponse>> filters)
        {
            Func<TRequest, TResponse> next = body.Invoke;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new RequestHandlerFilterRunner<TRequest, TResponse>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public TResponse Invoke(TRequest request)
        {
            return handler(request);
        }
    }

    internal sealed class RequestHandlerFilterRunner<TRequest, TResponse>
    {
        readonly RequestHandlerFilter<TRequest, TResponse> filter;
        readonly Func<TRequest, TResponse> next;

        public RequestHandlerFilterRunner(RequestHandlerFilter<TRequest, TResponse> filter, Func<TRequest, TResponse> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<TRequest, TResponse> GetDelegate() => Invoke;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        TResponse Invoke(TRequest request)
        {
            return filter.Invoke(request, next);
        }
    }
}


================================================
FILE: src/MessagePipe/GlobalMessagePipe.cs
================================================
﻿#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
using System;

namespace MessagePipe
{
    public static class GlobalMessagePipe
    {
        static IServiceProvider? provider;
        static EventFactory? eventFactory;
        static MessagePipeDiagnosticsInfo? diagnosticsInfo;

        public static void SetProvider(IServiceProvider provider)
        {
            GlobalMessagePipe.provider = provider;
            GlobalMessagePipe.eventFactory = provider.GetRequiredService<EventFactory>();
            GlobalMessagePipe.diagnosticsInfo = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
        }

        public static bool IsInitialized => provider != null;

        public static MessagePipeDiagnosticsInfo DiagnosticsInfo
        {
            get
            {
                ThrowIfNotInitialized();
                return diagnosticsInfo;
            }
        }

        public static IPublisher<TMessage> GetPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IPublisher<TMessage>>();
        }

        public static ISubscriber<TMessage> GetSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<ISubscriber<TMessage>>();
        }

        public static IAsyncPublisher<TMessage> GetAsyncPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncPublisher<TMessage>>();
        }

        public static IAsyncSubscriber<TMessage> GetAsyncSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncSubscriber<TMessage>>();
        }

        public static IPublisher<TKey, TMessage> GetPublisher<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IPublisher<TKey, TMessage>>();
        }

        public static ISubscriber<TKey, TMessage> GetSubscriber<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<ISubscriber<TKey, TMessage>>();
        }

        public static IAsyncPublisher<TKey, TMessage> GetAsyncPublisher<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncPublisher<TKey, TMessage>>();
        }

        public static IAsyncSubscriber<TKey, TMessage> GetAsyncSubscriber<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncSubscriber<TKey, TMessage>>();
        }

        public static IRequestHandler<TRequest, TResponse> GetRequestHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IRequestHandler<TRequest, TResponse>>();
        }

        public static IAsyncRequestHandler<TRequest, TResponse> GetAsyncRequestHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncRequestHandler<TRequest, TResponse>>();
        }

        public static IRequestAllHandler<TRequest, TResponse> GetRequestAllHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IRequestAllHandler<TRequest, TResponse>>();
        }

        public static IAsyncRequestAllHandler<TRequest, TResponse> GetAsyncRequestAllHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncRequestAllHandler<TRequest, TResponse>>();
        }

        public static IBufferedPublisher<TMessage> GetBufferedPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedPublisher<TMessage>>();
        }

        public static IBufferedSubscriber<TMessage> GetBufferedSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedSubscriber<TMessage>>();
        }

        public static IBufferedAsyncPublisher<TMessage> GetAsyncBufferedPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedAsyncPublisher<TMessage>>();
        }

        public static IBufferedAsyncSubscriber<TMessage> GetAsyncBufferedSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedAsyncSubscriber<TMessage>>();
        }

#if !UNITY_2018_3_OR_NEWER

        public static IDistributedPublisher<TKey, TMessage> GetDistributedPublisher<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IDistributedPublisher<TKey, TMessage>>();
        }

        public static IDistributedSubscriber<TKey, TMessage> GetDistributedSubscriber<TKey, TMessage>()
            where TKey : notnull
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IDistributedSubscriber<TKey, TMessage>>();
        }

#endif

        public static (IDisposablePublisher<T>, ISubscriber<T>) CreateEvent<T>()
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateEvent<T>();
        }

        public static (IDisposableAsyncPublisher<T>, IAsyncSubscriber<T>) CreateAsyncEvent<T>()
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateAsyncEvent<T>();
        }

        public static (IDisposableBufferedPublisher<T>, IBufferedSubscriber<T>) CreateBufferedEvent<T>(T initialValue)
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateBufferedEvent<T>(initialValue);
        }

        public static (IDisposableBufferedAsyncPublisher<T>, IBufferedAsyncSubscriber<T>) CreateBufferedAsyncEvent<T>(T initialValue)
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateBufferedAsyncEvent<T>(initialValue);
        }

        // [MemberNotNull(nameof(provider), nameof(eventFactory), nameof(diagnosticsInfo))]
        static void ThrowIfNotInitialized()
        {
            if (provider == null || eventFactory == null || diagnosticsInfo == null)
            {
                throw new InvalidOperationException("Require to call `SetProvider` before use GlobalMessagePipe.");
            }
        }
    }
}



================================================
FILE: src/MessagePipe/IDistributedPubSub.cs
================================================
﻿using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    public interface IDistributedPublisher<TKey, TMessage>
    {
        ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);
    }

    public interface IDistributedSubscriber<TKey, TMessage>
    {
        ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
        ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
    }
}


================================================
FILE: src/MessagePipe/IgnoreAutoRegistration.cs
================================================
﻿using System;

namespace MessagePipe
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public class IgnoreAutoRegistration : Attribute
    {
    }
}



================================================
FILE: src/MessagePipe/InMemoryDistributedPubSub.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public sealed class InMemoryDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    where TKey : notnull
    {
        readonly IAsyncPublisher<TKey, TMessage> publisher;

        [Preserve]
        public InMemoryDistributedPublisher(IAsyncPublisher<TKey, TMessage> publisher)
        {
            this.publisher = publisher;
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            return publisher.PublishAsync(key, message, cancellationToken);
        }
    }

    [Preserve]
    public sealed class InMemoryDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        readonly IAsyncSubscriber<TKey, TMessage> subscriber;

        [Preserve]
        public InMemoryDistributedSubscriber(IAsyncSubscriber<TKey, TMessage> subscriber)
        {
            this.subscriber = subscriber;
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, new AsyncMessageHandlerBridge<TMessage>(handler));
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, new AsyncMessageHandlerBridge<TMessage>(handler), filters.Select(x => new AsyncMessageHandlerFilterBridge<TMessage>(x)).ToArray());
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, handler);
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {

            var d = subscriber.Subscribe(key, handler, filters);
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    internal sealed class AsyncDisposableBridge : IAsyncDisposable
    {
        readonly IDisposable disposable;

        public AsyncDisposableBridge(IDisposable disposable)
        {
            this.disposable = disposable;
        }

        public ValueTask DisposeAsync()
        {
            disposable.Dispose();
            return default;
        }
    }

    internal sealed class AsyncMessageHandlerBridge<T> : IAsyncMessageHandler<T>
    {
        readonly IMessageHandler<T> handler;

        public AsyncMessageHandlerBridge(IMessageHandler<T> handler)
        {
            this.handler = handler;
        }

        public ValueTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            handler.Handle(message);
            return default;
        }
    }

    internal sealed class AsyncMessageHandlerFilterBridge<T> : AsyncMessageHandlerFilter<T>
    {
        readonly MessageHandlerFilter<T> filter;

        public AsyncMessageHandlerFilterBridge(MessageHandlerFilter<T> filter)
        {
            this.filter = filter;
            this.Order = filter.Order;
        }

        public override ValueTask HandleAsync(T message, CancellationToken cancellationToken, Func<T, CancellationToken, ValueTask> next)
        {
            filter.Handle(message, x => next(x, cancellationToken));
            return default;
        }
    }
}


================================================
FILE: src/MessagePipe/IPublisherSubscriber.cs
================================================
﻿using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // handler

    public interface IMessageHandler<TMessage>
    {
        void Handle(TMessage message);
    }

    public interface IAsyncMessageHandler<TMessage>
    {
        ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken);
    }

    // Keyless

    public interface IPublisher<TMessage>
    {
        void Publish(TMessage message);
    }

    public interface ISubscriber<TMessage>
    {
        IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IAsyncPublisher<TMessage>
    {
        void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IAsyncSubscriber<TMessage>
    {
        IDisposable Subscribe(IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
    }

    public interface ISingletonPublisher<TMessage> : IPublisher<TMessage> { }
    public interface ISingletonSubscriber<TMessage> : ISubscriber<TMessage> { }
    public interface IScopedPublisher<TMessage> : IPublisher<TMessage> { }
    public interface IScopedSubscriber<TMessage> : ISubscriber<TMessage> { }
    public interface ISingletonAsyncPublisher<TMessage> : IAsyncPublisher<TMessage> { }
    public interface ISingletonAsyncSubscriber<TMessage> : IAsyncSubscriber<TMessage> { }
    public interface IScopedAsyncPublisher<TMessage> : IAsyncPublisher<TMessage> { }
    public interface IScopedAsyncSubscriber<TMessage> : IAsyncSubscriber<TMessage> { }

    // Keyed

    public interface IPublisher<TKey, TMessage>
        where TKey : notnull
    {
        void Publish(TKey key, TMessage message);
    }

    public interface ISubscriber<TKey, TMessage>
        where TKey : notnull
    {
        IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IAsyncPublisher<TKey, TMessage>
        where TKey : notnull
    {
        void Publish(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IAsyncSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
    }

    public interface ISingletonPublisher<TKey, TMessage> : IPublisher<TKey, TMessage> where TKey : notnull { }
    public interface ISingletonSubscriber<TKey, TMessage> : ISubscriber<TKey, TMessage> where TKey : notnull { }
    public interface IScopedPublisher<TKey, TMessage> : IPublisher<TKey, TMessage> where TKey : notnull { }
    public interface IScopedSubscriber<TKey, TMessage> : ISubscriber<TKey, TMessage> where TKey : notnull { }
    public interface ISingletonAsyncPublisher<TKey, TMessage> : IAsyncPublisher<TKey, TMessage> where TKey : notnull { }
    public interface ISingletonAsyncSubscriber<TKey, TMessage> : IAsyncSubscriber<TKey, TMessage> where TKey : notnull { }
    public interface IScopedAsyncPublisher<TKey, TMessage> : IAsyncPublisher<TKey, TMessage> where TKey : notnull { }
    public interface IScopedAsyncSubscriber<TKey, TMessage> : IAsyncSubscriber<TKey, TMessage> where TKey : notnull { }

    // buffered keyless

    public interface IBufferedPublisher<TMessage>
    {
        void Publish(TMessage message);
    }

    public interface IBufferedSubscriber<TMessage>
    {
        IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IBufferedAsyncPublisher<TMessage>
    {
        void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        ValueTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IBufferedAsyncSubscriber<TMessage>
    {
        ValueTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        ValueTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
    }

    // NOTE: buffered Keyed is undefined
    // because difficult to avoid (unused)key and keep latest value memory leak.
}


================================================
FILE: src/MessagePipe/IRequestHandler.cs
================================================
﻿using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    // Sync

    public interface IRequestHandler
    {
    }

    public interface IRequestHandlerCore<in TRequest, out TResponse> : IRequestHandler
    {
        TResponse Invoke(TRequest request);
    }

    public interface IRequestHandler<in TRequest, out TResponse> : IRequestHandlerCore<TRequest, TResponse>
    {
    }

    public interface IRequestAllHandler<in TRequest, out TResponse>
    {
        TResponse[] InvokeAll(TRequest request);
        IEnumerable<TResponse> InvokeAllLazy(TRequest request);
    }

    // Async

    public interface IAsyncRequestHandler
    {
    }

    public interface IAsyncRequestHandlerCore<in TRequest, TResponse> : IAsyncRequestHandler
    {
        ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    public interface IAsyncRequestHandler<in TRequest, TResponse> : IAsyncRequestHandlerCore<TRequest, TResponse>
    {
    }

    public interface IAsyncRequestAllHandler<in TRequest, TResponse>
    {
        ValueTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);
        ValueTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
        IAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    // Remote

    public interface IRemoteRequestHandler<in TRequest, TResponse>
    // where TAsyncRequestHandler : IAsyncRequestHandler<TRequest, TResponse>
    {
        ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    public class RemoteRequestException : Exception
    {
        public RemoteRequestException(string message)
            : base(message)
        {
        }
    }

    // almostly internal usage for IRemoteRequestHandler type search
    public static class AsyncRequestHandlerRegistory
    {
        static ConcurrentDictionary<(string, string), Type> types = new ConcurrentDictionary<(string, string), Type>();

        public static void Add(Type handlerType)
        {
            foreach (var interfaceType in handlerType.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore")))
            {
                var genArgs = interfaceType.GetGenericArguments();
                types[(genArgs[0].FullName!, genArgs[1].FullName)!] = handlerType;
            }
        }

        public static void Add(Type requestType, Type responseType, Type handlerType)
        {
            types[(requestType.FullName!, responseType.FullName!)] = handlerType;
        }

        public static Type Get(string requestType, string responseType)
        {
            if (types.TryGetValue((requestType, responseType), out var result))
            {
                return result;
            }
            throw new InvalidOperationException($"IAsyncHandler<{requestType}, {responseType}> is not registered.");
        }
    }
}



================================================
FILE: src/MessagePipe/MessageBroker.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Runtime.CompilerServices;

namespace MessagePipe
{
    [Preserve]
    public class MessageBroker<TMessage> : IPublisher<TMessage>, ISubscriber<TMessage>
    {
        readonly MessageBrokerCore<TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public MessageBroker(MessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class MessageBrokerCore<TMessage> : IDisposable, IHandlerHolderMarker
    {
        readonly FreeList<IMessageHandler<TMessage>> handlers;
        readonly MessagePipeDiagnosticsInfo diagnostics;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate = new object();
        bool isDisposed;

        [Preserve]
        public MessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
        {
            this.handlers = new FreeList<IMessageHandler<TMessage>>();
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.diagnostics = diagnostics;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Publish(TMessage message)
        {
            var array = handlers.GetValues();
            for (int i = 0; i < array.Length; i++)
            {
                array[i]?.Handle(message);
            }
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(MessageBrokerCore<TMessage>));

                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(this, subscriptionKey);
                diagnostics.IncrementSubscribe(this, subscription);
                return subscription;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                // Dispose is called when scope is finished.
                if (!isDisposed && handlers.TryDispose(out var count))
                {
                    isDisposed = true;
                    diagnostics.RemoveTargetDiagnostics(this, count);
                }
            }
        }

        sealed class Subscription : IDisposable
        {
            bool isDisposed;
            readonly MessageBrokerCore<TMessage> core;
            readonly int subscriptionKey;

            public Subscription(MessageBrokerCore<TMessage> core, int subscriptionKey)
            {
                this.core = core;
                this.subscriptionKey = subscriptionKey;
            }

            public void Dispose()
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    lock (core.gate)
                    {
                        if (!core.isDisposed)
                        {
                            core.handlers.Remove(subscriptionKey, true);
                            core.diagnostics.DecrementSubscribe(core, this);
                        }
                    }
                }
            }
        }
    }

    [Preserve]
    public sealed class BufferedMessageBroker<TMessage> : IBufferedPublisher<TMessage>, IBufferedSubscriber<TMessage>
    {
        readonly BufferedMessageBrokerCore<TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public BufferedMessageBroker(BufferedMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public sealed class BufferedMessageBrokerCore<TMessage>
    {
        static readonly bool IsValueType = typeof(TMessage).IsValueType;

        readonly MessageBrokerCore<TMessage> core;
        TMessage? lastMessage;

        [Preserve]
        public BufferedMessageBrokerCore(MessageBrokerCore<TMessage> core)
        {
            this.core = core;
            this.lastMessage = default;
        }

        public void Publish(TMessage message)
        {
            lastMessage = message;
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler)
        {
            if (IsValueType || lastMessage != null)
            {
                handler.Handle(lastMessage!);
            }
            return core.Subscribe(handler);
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonMessageBroker<TMessage> : MessageBroker<TMessage>, ISingletonPublisher<TMessage>, ISingletonSubscriber<TMessage>
    {
        [Preserve]
        public SingletonMessageBroker(SingletonMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBroker<TMessage> : MessageBroker<TMessage>, IScopedPublisher<TMessage>, IScopedSubscriber<TMessage>
    {
        [Preserve]
        public ScopedMessageBroker(ScopedMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonMessageBrokerCore<TMessage> : MessageBrokerCore<TMessage>
    {
        [Preserve]
        public SingletonMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBrokerCore<TMessage> : MessageBrokerCore<TMessage>
    {
        [Preserve]
        public ScopedMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe/MessageBroker_Key.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;

namespace MessagePipe
{
    [Preserve]
    public class MessageBroker<TKey, TMessage> : IPublisher<TKey, TMessage>, ISubscriber<TKey, TMessage>
        where TKey : notnull
    {
        readonly MessageBrokerCore<TKey, TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public MessageBroker(MessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TKey key, TMessage message)
        {
            core.Publish(key, message);
        }

        public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(key, handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class MessageBrokerCore<TKey, TMessage> : IDisposable
    where TKey : notnull
    {
        readonly Dictionary<TKey, HandlerHolder> handlerGroup;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate;
        bool isDisposed;

        [Preserve]
        public MessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlerGroup = new Dictionary<TKey, HandlerHolder>();
            this.diagnotics = diagnotics;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.gate = new object();
        }

        public void Publish(TKey key, TMessage message)
        {
            IMessageHandler<TMessage>?[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            for (int i = 0; i < handlers.Length; i++)
            {
                handlers[i]?.Handle(message);
            }
        }

        public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(MessageBrokerCore<TKey, TMessage>));

                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    handlerGroup[key] = holder = new HandlerHolder(this);
                }

                return holder.Subscribe(key, handler);
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    foreach (var handlers in handlerGroup.Values)
                    {
                        handlers.Dispose();
                    }
                }
            }
        }

        // similar as Keyless-MessageBrokerCore but require to remove when key is empty on Dispose
        sealed class HandlerHolder : IDisposable, IHandlerHolderMarker
        {
            readonly FreeList<IMessageHandler<TMessage>> handlers;
            readonly MessageBrokerCore<TKey, TMessage> core;

            public HandlerHolder(MessageBrokerCore<TKey, TMessage> core)
            {
                this.handlers = new FreeList<IMessageHandler<TMessage>>();
                this.core = core;
            }

            public IMessageHandler<TMessage>?[] GetHandlers() => handlers.GetValues();

            public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler)
            {
                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(key, subscriptionKey, this);
                core.diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }

            public void Dispose()
            {
                lock (core.gate)
                {
                    if (handlers.TryDispose(out var count))
                    {
                        core.diagnotics.RemoveTargetDiagnostics(this, count);
                    }
                }
            }

            sealed class Subscription : IDisposable
            {
                bool isDisposed;
                readonly TKey key;
                readonly int subscriptionKey;
                readonly HandlerHolder holder;

                public Subscription(TKey key, int subscriptionKey, HandlerHolder holder)
                {
                    this.key = key;
                    this.subscriptionKey = subscriptionKey;
                    this.holder = holder;
                }

                public void Dispose()
                {
                    if (!isDisposed)
                    {
                        isDisposed = true;
                        lock (holder.core.gate)
                        {
                            if (!holder.core.isDisposed)
                            {
                                holder.handlers.Remove(subscriptionKey, false);
                                holder.core.diagnotics.DecrementSubscribe(holder, this);
                                if (holder.handlers.GetCount() == 0)
                                {
                                    holder.core.handlerGroup.Remove(key);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonMessageBroker<TKey, TMessage> : MessageBroker<TKey, TMessage>, ISingletonPublisher<TKey, TMessage>, ISingletonSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        public SingletonMessageBroker(SingletonMessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonMessageBrokerCore<TKey, TMessage> : MessageBrokerCore<TKey, TMessage>
        where TKey : notnull
    {
        public SingletonMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBroker<TKey, TMessage> : MessageBroker<TKey, TMessage>, IScopedPublisher<TKey, TMessage>, IScopedSubscriber<TKey, TMessage>
        where TKey : notnull
    {
        public ScopedMessageBroker(ScopedMessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBrokerCore<TKey, TMessage> : MessageBrokerCore<TKey, TMessage>
        where TKey : notnull
    {
        public ScopedMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe/MessagePipe.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net6.0</TargetFrameworks>
    <WarningsAsErrors>true</WarningsAsErrors>
    <Configurations>Debug;Release;WinBenchmark</Configurations>

    <!-- NuGet Packaging -->
    <PackageTags>pubsub;eventaggregator</PackageTags>
    <Description>High performance in-memory/distributed messaging pipeline for .NET and Unity.</Description>
    <SignAssembly>true</SignAssembly>
    <IsPackable>true</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="6.0.0" />
  </ItemGroup>
  <ItemGroup Condition="$(TargetFramework) == 'netstandard2.0'">
    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="6.0.0" />
    <PackageReference Include="System.Threading.Channels" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <None Update="Disposables.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>Disposables.cs</LastGenOutput>
    </None>
    <Compile Update="Disposables.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Disposables.tt</DependentUpon>
    </Compile>
  </ItemGroup>

  <!-- Copy files for Unity -->
  <PropertyGroup>
    <DestinationRoot>$(MSBuildProjectDirectory)\..\MessagePipe.Unity\Assets\Plugins\MessagePipe\Runtime\</DestinationRoot>
  </PropertyGroup>
  <ItemGroup>
    <TargetFiles1 Include="$(MSBuildProjectDirectory)\**\*.cs" Exclude="**\bin\**\*.*;**\obj\**\*.*;_InternalVisibleTo.cs" />
  </ItemGroup>

  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Copy SourceFiles="@(TargetFiles1)" DestinationFiles="$(DestinationRoot)\%(RecursiveDir)%(Filename)%(Extension)" SkipUnchangedFiles="true" />

    <!-- After copy, replace for unity codes -->
    <Exec Command="dotnet run --no-build -c $(ConfigurationName) --project $(MSBuildProjectDirectory)\..\..\tools\PostBuildUtility\PostBuildUtility.csproj -- replace-to-unity $(DestinationRoot)" />
  </Target>
</Project>



================================================
FILE: src/MessagePipe/MessagePipeDiagnosticsInfo.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security;
using System.Threading;

namespace MessagePipe
{
    internal interface IHandlerHolderMarker
    {
    }

    public class StackTraceInfo
    {
        static bool displayFileNames = true;
        static int idSeed = 0;

        public int Id { get; }
        public DateTimeOffset Timestamp { get; }
        public StackTrace StackTrace { get; }
        public string Head { get; }

        internal string formattedStackTrace = default!; // cache field for internal use(Unity Editor, etc...)

        public StackTraceInfo(StackTrace stackTrace)
        {
            Id = Interlocked.Increment(ref idSeed);
            Timestamp = DateTimeOffset.UtcNow;
            StackTrace = stackTrace;
            Head = GetGroupKey(stackTrace);
        }

        internal static string GetGroupKey(StackTrace stackTrace)
        {
            for (int i = 0; i < stackTrace.FrameCount; i++)
            {
                var sf = stackTrace.GetFrame(i);
                if (sf == null) continue;
                var m = sf.GetMethod();
                if (m == null) continue;
                if (m.DeclaringType == null) continue;
                if (m.DeclaringType.Namespace == null || !m.DeclaringType.Namespace.StartsWith("MessagePipe"))
                {
                    if (displayFileNames && sf.GetILOffset() != -1)
                    {
                        string? fileName = null;
                        try
                        {
                            fileName = sf.GetFileName();
                        }
                        catch (NotSupportedException)
                        {
                            displayFileNames = false;
                        }
                        catch (SecurityException)
                        {
                            displayFileNames = false;
                        }

                        if (fileName != null)
                        {
                            return m.DeclaringType.FullName + "." + m.Name + " (at " + Path.GetFileName(fileName) + ":" + sf.GetFileLineNumber() + ")";
                        }
                        else
                        {
                            return m.DeclaringType.FullName + "." + m.Name + " (offset: " + sf.GetILOffset() + ")";
                        }
                    }

                    return m.DeclaringType.FullName + "." + m.Name;
                }
            }

            return "";
        }
    }

    /// <summary>
    /// Diagnostics info of in-memory(ISubscriber/IAsyncSubscriber) subscriptions.
    /// </summary>
    [Preserve]
    public sealed class MessagePipeDiagnosticsInfo
    {
        static readonly ILookup<string, StackTraceInfo> EmptyLookup = Array.Empty<StackTraceInfo>().ToLookup(_ => "", x => x);

        int subscribeCount;
        bool dirty;
        MessagePipeOptions options;

        object gate = new object();
        Dictionary<IHandlerHolderMarker, Dictionary<IDisposable, StackTraceInfo>> capturedStackTraces = new Dictionary<IHandlerHolderMarker, Dictionary<IDisposable, StackTraceInfo>>();

        /// <summary>Get current subscribed count.</summary>
        public int SubscribeCount => subscribeCount;

        internal bool CheckAndResetDirty()
        {
            var d = dirty;
            dirty = false;
            return d;
        }

        internal MessagePipeOptions MessagePipeOptions => options;

        /// <summary>
        /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, list all stacktrace on subscribe.
        /// </summary>
        public StackTraceInfo[] GetCapturedStackTraces(bool ascending = true)
        {
            if (!options.EnableCaptureStackTrace) return Array.Empty<StackTraceInfo>();
            lock (gate)
            {
                var iter = capturedStackTraces.SelectMany(x => x.Value.Values);
                iter = (ascending) ? iter.OrderBy(x => x.Id) : iter.OrderByDescending(x => x.Id);
                return iter.ToArray();
            }
        }

        /// <summary>
        /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, groped by caller of subscribe.
        /// </summary>
        public ILookup<string, StackTraceInfo> GetGroupedByCaller(bool ascending = true)
        {
            if (!options.EnableCaptureStackTrace) return EmptyLookup;
            lock (gate)
            {
                var iter = capturedStackTraces.SelectMany(x => x.Value.Values);
                iter = (ascending) ? iter.OrderBy(x => x.Id) : iter.OrderByDescending(x => x.Id);
                return iter.ToLookup(x => x.Head);
            }
        }

        [Preserve]
        public MessagePipeDiagnosticsInfo(MessagePipeOptions options)
        {
            this.options = options;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void IncrementSubscribe(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            Interlocked.Increment(ref subscribeCount);
            if (options.EnableCaptureStackTrace)
            {
                AddStackTrace(handlerHolder, subscription);
            }
            dirty = true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        void AddStackTrace(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            lock (gate)
            {
                if (!capturedStackTraces.TryGetValue(handlerHolder, out var dict))
                {
                    dict = new Dictionary<IDisposable, StackTraceInfo>();
                    capturedStackTraces[handlerHolder] = dict;
                }

                dict.Add(subscription, new StackTraceInfo(new StackTrace(true)));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void DecrementSubscribe(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            Interlocked.Decrement(ref subscribeCount);
            if (options.EnableCaptureStackTrace)
            {
                RemoveStackTrace(handlerHolder, subscription);
            }
            dirty = true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        void RemoveStackTrace(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            lock (gate)
            {
                if (!capturedStackTraces.TryGetValue(handlerHolder, out var dict))
                {
                    return;
                }

                dict.Remove(subscription);
            }
        }

        internal void RemoveTargetDiagnostics(IHandlerHolderMarker targetHolder, int removeCount)
        {
            Interlocked.Add(ref subscribeCount, -removeCount);
            if (options.EnableCaptureStackTrace)
            {
                lock (gate)
                {
                    capturedStackTraces.Remove(targetHolder);
                }
            }
            dirty = true;
        }
    }
}


================================================
FILE: src/MessagePipe/MessagePipeFilter.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    public interface IMessagePipeFilterAttribute
    {
        Type Type { get; }
        int Order { get; }
    }

    public interface IMessagePipeFilter
    {
        int Order { get; set; }
    }

    // Sync filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class MessageHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public MessageHandlerFilterAttribute(Type type)
        {
            if (!typeof(IMessageHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not MessageHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IMessageHandlerFilter : IMessagePipeFilter
    {
    }

    public abstract class MessageHandlerFilter<TMessage> : IMessageHandlerFilter
    {
        public int Order { get; set; }
        public abstract void Handle(TMessage message, Action<TMessage> next);
    }

    // Async filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class AsyncMessageHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public AsyncMessageHandlerFilterAttribute(Type type)
        {
            if (!typeof(IAsyncMessageHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not AsyncMessageHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IAsyncMessageHandlerFilter : IMessagePipeFilter
    {
    }


    public abstract class AsyncMessageHandlerFilter<TMessage> : IAsyncMessageHandlerFilter
    {
        public int Order { get; set; }
        public abstract ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken, Func<TMessage, CancellationToken, ValueTask> next);
    }

    // Req-Res Filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class RequestHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public RequestHandlerFilterAttribute(Type type)
        {
            if (!typeof(IRequestHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not RequestHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IRequestHandlerFilter : IMessagePipeFilter
    {

    }

    public abstract class RequestHandlerFilter<TRequest, TResponse> : IRequestHandlerFilter
    {
        public int Order { get; set; }
        public abstract TResponse Invoke(TRequest request, Func<TRequest, TResponse> next);
    }

    // async Req-Res

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class AsyncRequestHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public AsyncRequestHandlerFilterAttribute(Type type)
        {
            if (!typeof(IAsyncRequestHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not AsyncRequestHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IAsyncRequestHandlerFilter : IMessagePipeFilter
    {

    }

    public abstract class AsyncRequestHandlerFilter<TRequest, TResponse> : IAsyncRequestHandlerFilter
    {
        public int Order { get; set; }
        public abstract ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken, Func<TRequest, CancellationToken, ValueTask<TResponse>> next);
    }
}


================================================
FILE: src/MessagePipe/MessagePipeOptions.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using MessagePipe.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
namespace MessagePipe
{
    public enum AsyncPublishStrategy
    {
        Parallel, Sequential
    }

    public enum InstanceLifetime
    {
        Singleton, Scoped, Transient
    }

    public enum HandlingSubscribeDisposedPolicy
    {
        Ignore, Throw
    }

    internal static class HandlingSubscribeDisposedPolicyExtensions
    {
        public static IDisposable Handle(this HandlingSubscribeDisposedPolicy policy, string name)
        {
            if (policy == HandlingSubscribeDisposedPolicy.Throw)
            {
                throw new ObjectDisposedException(name);
            }
            return DisposableBag.Empty;
        }
    }

    public sealed class MessagePipeOptions
    {
        /// <summary>AsyncPublisher.PublishAsync's concurrent starategy, default is Parallel.</summary>
        public AsyncPublishStrategy DefaultAsyncPublishStrategy { get; set; }

#if !UNITY_2018_3_OR_NEWER
        public bool EnableAutoRegistration { get; set; }

#endif

        /// <summary>For diagnostics usage, enable MessagePipeDiagnosticsInfo.CapturedStacktraces; default is false.</summary>
        public bool EnableCaptureStackTrace { get; set; }

        /// <summary>Choose how work on subscriber.Subscribe when after disposed, default is Ignore.</summary>
        public HandlingSubscribeDisposedPolicy HandlingSubscribeDisposedPolicy { get; set; }

        /// <summary>Default publisher/subscribe's lifetime scope, default is Singleton.</summary>
        public InstanceLifetime InstanceLifetime { get; set; }

        /// <summary>Default IRequestHandler/IAsyncRequestHandler's lifetime scope, default is Scoped.</summary>
        public InstanceLifetime RequestHandlerLifetime { get; set; }

        public MessagePipeOptions()
        {
            this.DefaultAsyncPublishStrategy = AsyncPublishStrategy.Parallel;
            this.InstanceLifetime = InstanceLifetime.Singleton;
            this.RequestHandlerLifetime = InstanceLifetime.Scoped;
            this.EnableCaptureStackTrace = false;
            this.HandlingSubscribeDisposedPolicy = HandlingSubscribeDisposedPolicy.Ignore;
#if !UNITY_2018_3_OR_NEWER
            this.EnableAutoRegistration = true;
            this.autoregistrationAssemblies = null;
            this.autoregistrationTypes = null;
#endif
        }

#if !UNITY_2018_3_OR_NEWER

        // auto-registration

        internal Assembly[]? autoregistrationAssemblies;
        internal Type[]? autoregistrationTypes;

        public void SetAutoRegistrationSearchAssemblies(params Assembly[] assemblies)
        {
            autoregistrationAssemblies = assemblies;
        }

        public void SetAutoRegistrationSearchTypes(params Type[] types)
        {
            autoregistrationTypes = types;
        }

#endif

        // filters

        internal IEnumerable<Type> GetGlobalFilterTypes()
        {
            foreach (var item in messageHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in asyncMessageHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in requestHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in asyncRequestHandlerFilters)
            {
                yield return item.FilterType;
            }
        }

        // MessageHandlerFilter

        List<FilterDefinition> messageHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalMessageHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IMessageHandlerFilter));
            messageHandlerFilters.Add(new MessageHandlerFilterDefinition(type, order, typeof(MessageHandlerFilter<>)));
        }

#endif

        public void AddGlobalMessageHandlerFilter<T>(int order = 0)
            where T : IMessageHandlerFilter
        {
            messageHandlerFilters.Add(new MessageHandlerFilterDefinition(typeof(T), order, typeof(MessageHandlerFilter<>)));
        }

        internal (int count, IEnumerable<IMessageHandlerFilter>) GetGlobalMessageHandlerFilters(IServiceProvider provider, Type messageType)
        {
            return (messageHandlerFilters.Count, CreateFilters<IMessageHandlerFilter>(messageHandlerFilters, provider, messageType));
        }

        // AsyncMessageHandlerFilter

        List<FilterDefinition> asyncMessageHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalAsyncMessageHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IAsyncMessageHandlerFilter));
            asyncMessageHandlerFilters.Add(new MessageHandlerFilterDefinition(type, order, typeof(AsyncMessageHandlerFilter<>)));
        }

#endif

        public void AddGlobalAsyncMessageHandlerFilter<T>(int order = 0)
            where T : IAsyncMessageHandlerFilter
        {
            asyncMessageHandlerFilters.Add(new MessageHandlerFilterDefinition(typeof(T), order, typeof(AsyncMessageHandlerFilter<>)));
        }

        internal (int count, IEnumerable<IAsyncMessageHandlerFilter>) GetGlobalAsyncMessageHandlerFilters(IServiceProvider provider, Type messageType)
        {
            return (asyncMessageHandlerFilters.Count, CreateFilters<IAsyncMessageHandlerFilter>(asyncMessageHandlerFilters, provider, messageType));
        }

        // RequestHandlerFilter

        List<FilterDefinition> requestHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalRequestHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IRequestHandlerFilter));
            requestHandlerFilters.Add(new RequestHandlerFilterDefinition(type, order, typeof(RequestHandlerFilter<,>)));
        }

#endif

        public void AddGlobalRequestHandlerFilter<T>(int order = 0)
            where T : IRequestHandlerFilter
        {
            requestHandlerFilters.Add(new RequestHandlerFilterDefinition(typeof(T), order, typeof(RequestHandlerFilter<,>)));
        }

        internal (int, IEnumerable<IRequestHandlerFilter>) GetGlobalRequestHandlerFilters(IServiceProvider provider, Type requestType, Type responseType)
        {
            return (requestHandlerFilters.Count, CreateFilters<IRequestHandlerFilter>(requestHandlerFilters, provider, requestType, responseType));
        }

        //  AsyncRequestHandlerFilter

        List<FilterDefinition> asyncRequestHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalAsyncRequestHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IAsyncRequestHandlerFilter));
            asyncRequestHandlerFilters.Add(new RequestHandlerFilterDefinition(type, order, typeof(AsyncRequestHandlerFilter<,>)));
        }

#endif

        public void AddGlobalAsyncRequestHandlerFilter<T>(int order = 0)
            where T : IAsyncRequestHandlerFilter
        {
            asyncRequestHandlerFilters.Add(new RequestHandlerFilterDefinition(typeof(T), order, typeof(AsyncRequestHandlerFilter<,>)));
        }

        internal (int, IEnumerable<IAsyncRequestHandlerFilter>) GetGlobalAsyncRequestHandlerFilters(IServiceProvider provider, Type requestType, Type responseType)
        {
            return (asyncRequestHandlerFilters.Count, CreateFilters<IAsyncRequestHandlerFilter>(asyncRequestHandlerFilters, provider, requestType, responseType));
        }

        static IEnumerable<T> CreateFilters<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type messageType)
            where T : IMessagePipeFilter
        {
            if (filterDefinitions.Count == 0) return Array.Empty<T>();
            return CreateFiltersCore<T>(filterDefinitions, provider, messageType);
        }

        static IEnumerable<T> CreateFiltersCore<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type messageType)
            where T : IMessagePipeFilter
        {
            for (int i = 0; i < filterDefinitions.Count; i++)
            {
                var def = filterDefinitions[i] as MessageHandlerFilterDefinition;
                if (def == null) continue;
                var filterType = def.FilterType;
                if (def.IsOpenGenerics)
                {
                    filterType = filterType.MakeGenericType(messageType);
                }
                else if (def.MessageType != messageType)
                {
                    continue;
                }

                var filter = (T)provider.GetRequiredService(filterType);
                filter.Order = def.Order;
                yield return filter;
            }
        }

        static IEnumerable<T> CreateFilters<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type requestType, Type responseType)
            where T : IMessagePipeFilter
        {
            if (filterDefinitions.Count == 0) return Array.Empty<T>();
            return CreateFiltersCore<T>(filterDefinitions, provider, requestType, responseType);
        }

        static IEnumerable<T> CreateFiltersCore<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type requestType, Type responseType)
            where T : IMessagePipeFilter
        {
            for (int i = 0; i < filterDefinitions.Count; i++)
            {
                var def = filterDefinitions[i] as RequestHandlerFilterDefinition;
                if (def == null) continue;
                var filterType = def.FilterType;
                if (def.IsOpenGenerics)
                {
                    filterType = filterType.MakeGenericType(requestType, responseType);
                }
                else if (!(def.RequestType == requestType && def.ResponseType == responseType))
                {
                    continue;
                }

                var filter = (T)provider.GetRequiredService(filterType);
                filter.Order = def.Order;
                yield return filter;
            }
        }

        void ValidateFilterType(Type type, Type filterType)
        {
            if (!filterType.IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not {filterType.Name}");
            }
        }
    }
}


================================================
FILE: src/MessagePipe/PredicateFilter.cs
================================================
﻿using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    internal sealed class PredicateFilter<T> : MessageHandlerFilter<T>
    {
        readonly Func<T, bool> predicate;

        public PredicateFilter(Func<T, bool> predicate)
        {
            this.predicate = predicate;
            this.Order = int.MinValue; // predicate filter first.
        }

        public override void Handle(T message, Action<T> next)
        {
            if (predicate(message))
            {
                next(message);
            }
        }
    }

    internal sealed class AsyncPredicateFilter<T> : AsyncMessageHandlerFilter<T>
    {
        readonly Func<T, bool> predicate;

        public AsyncPredicateFilter(Func<T, bool> predicate)
        {
            this.predicate = predicate;
            this.Order = int.MinValue; // predicate filter first.
        }

        public override ValueTask HandleAsync(T message, CancellationToken cancellationToken, Func<T, CancellationToken, ValueTask> next)
        {
            if (predicate(message))
            {
                return next(message, cancellationToken);
            }
            return default(ValueTask);
        }
    }
}


================================================
FILE: src/MessagePipe/RequestHandler.cs
================================================
﻿using MessagePipe.Internal;
using System.Collections.Generic;
using System.Linq;

namespace MessagePipe
{
    [Preserve]
    public sealed class RequestHandler<TRequest, TResponse> : IRequestHandler<TRequest, TResponse>
    {
        readonly IRequestHandlerCore<TRequest, TResponse> handler;

        [Preserve]
        public RequestHandler(IRequestHandlerCore<TRequest, TResponse> handler, FilterAttachedRequestHandlerFactory handlerFactory)
        {
            this.handler = handlerFactory.CreateRequestHandler<TRequest, TResponse>(handler);
        }

        public TResponse Invoke(TRequest request)
        {
            return handler.Invoke(request);
        }
    }

    [Preserve]
    public sealed class RequestAllHandler<TRequest, TResponse> : IRequestAllHandler<TRequest, TResponse>
    {
        readonly IRequestHandlerCore<TRequest, TResponse>[] handlers;

        [Preserve]
        public RequestAllHandler(IEnumerable<IRequestHandlerCore<TRequest, TResponse>> handlers, FilterAttachedRequestHandlerFactory handlerFactory)
        {
            var collection = (handlers as ICollection<IRequestHandlerCore<TRequest, TResponse>>) ?? handlers.ToArray();

            var array = new IRequestHandlerCore<TRequest, TResponse>[collection.Count];
            var i = 0;
            foreach (var item in collection)
            {
                array[i++] = handlerFactory.CreateRequestHandler(item);
            }

            this.handlers = array;
        }

        public TResponse[] InvokeAll(TRequest request)
        {
            var responses = new TResponse[handlers.Length];

            for (int i = 0; i < handlers.Length; i++)
            {
                responses[i] = handlers[i].Invoke(request);
            }

            return responses;
        }

        public IEnumerable<TResponse> InvokeAllLazy(TRequest request)
        {
            for (int i = 0; i < handlers.Length; i++)
            {
                yield return handlers[i].Invoke(request);
            }
        }
    }
}


================================================
FILE: src/MessagePipe/ServiceCollectionExtensions.cs
================================================
﻿using MessagePipe;
using MessagePipe.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
#endif
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#if !UNITY_2018_3_OR_NEWER
namespace Microsoft.Extensions.DependencyInjection
#else
namespace MessagePipe
#endif
{
    /// <summary>
    /// An interface for configuring MessagePipe services.
    /// </summary>
    public interface IMessagePipeBuilder
    {
        IServiceCollection Services { get; }
    }

    public class MessagePipeBuilder : IMessagePipeBuilder
    {
        public IServiceCollection Services { get; }

        public MessagePipeBuilder(IServiceCollection services)
        {
            Services = services;
        }
    }

    public static class ServiceCollectionExtensions
    {
        public static IMessagePipeBuilder AddMessagePipe(this IServiceCollection services)
        {
            return AddMessagePipe(services, _ => { });
        }

        public static IMessagePipeBuilder AddMessagePipe(this IServiceCollection services, Action<MessagePipeOptions> configure)
        {
            var options = new MessagePipeOptions();
            configure(options);
            services.AddSingleton(options); // add as singleton instance
            services.AddSingleton(typeof(MessagePipeDiagnosticsInfo));
            services.AddSingleton(typeof(EventFactory));

            // filters.
            // attribute and order is deterministic at compile, so use Singleton lifetime of cache.
            services.AddSingleton(typeof(AttributeFilterProvider<MessageHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<AsyncMessageHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<RequestHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<AsyncRequestHandlerFilterAttribute>));
            services.AddSingleton(typeof(FilterAttachedMessageHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedAsyncMessageHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedRequestHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedAsyncRequestHandlerFactory));
            foreach (var item in options.GetGlobalFilterTypes())
            {
                services.TryAddTransient(item); // filter itself is Transient
            }

#if !UNITY_2018_3_OR_NEWER || (MESSAGEPIPE_OPENGENERICS_SUPPORT && UNITY_2022_1_OR_NEWER)
            // open generics implemntations(.NET Only)

            {
                var lifetime = options.InstanceLifetime; // pubsub lifetime

                // keyless PubSub
                services.Add(typeof(MessageBrokerCore<>), lifetime);
                services.Add(typeof(IPublisher<>), typeof(MessageBroker<>), lifetime);
                services.Add(typeof(ISubscriber<>), typeof(MessageBroker<>), lifetime);
                services.Add(typeof(BufferedMessageBrokerCore<>), lifetime);
                services.Add(typeof(IBufferedPublisher<>), typeof(BufferedMessageBroker<>), lifetime);
                services.Add(typeof(IBufferedSubscriber<>), typeof(BufferedMessageBroker<>), lifetime);

                // keyless-variation
                services.Add(typeof(SingletonMessageBrokerCore<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonPublisher<>), typeof(SingletonMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonSubscriber<>), typeof(SingletonMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedMessageBrokerCore<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedPublisher<>), typeof(ScopedMessageBroker<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedSubscriber<>), typeof(ScopedMessageBroker<>), InstanceLifetime.Scoped);

                // keyless PubSub async
                services.Add(typeof(AsyncMessageBrokerCore<>), lifetime);
                services.Add(typeof(IAsyncPublisher<>), typeof(AsyncMessageBroker<>), lifetime);
                services.Add(typeof(IAsyncSubscriber<>), typeof(AsyncMessageBroker<>), lifetime);
                services.Add(typeof(BufferedAsyncMessageBrokerCore<>), lifetime);
                services.Add(typeof(IBufferedAsyncPublisher<>), typeof(BufferedAsyncMessageBroker<>), lifetime);
                services.Add(typeof(IBufferedAsyncSubscriber<>), typeof(BufferedAsyncMessageBroker<>), lifetime);

                // keyless-async-variation
                services.Add(typeof(SingletonAsyncMessageBrokerCore<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncPublisher<>), typeof(SingletonAsyncMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncSubscriber<>), typeof(SingletonAsyncMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedAsyncMessageBrokerCore<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncPublisher<>), typeof(ScopedAsyncMessageBroker<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncSubscriber<>), typeof(ScopedAsyncMessageBroker<>), InstanceLifetime.Scoped);

                // keyed PubSub
                services.Add(typeof(MessageBrokerCore<,>), lifetime);
                services.Add(typeof(IPublisher<,>), typeof(MessageBroker<,>), lifetime);
                services.Add(typeof(ISubscriber<,>), typeof(MessageBroker<,>), lifetime);

                // keyed-variation
                services.Add(typeof(SingletonMessageBrokerCore<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonPublisher<,>), typeof(SingletonMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonSubscriber<,>), typeof(SingletonMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedMessageBrokerCore<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedPublisher<,>), typeof(ScopedMessageBroker<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedSubscriber<,>), typeof(ScopedMessageBroker<,>), InstanceLifetime.Scoped);

                // keyed PubSub async
                services.Add(typeof(AsyncMessageBrokerCore<,>), lifetime);
                services.Add(typeof(IAsyncPublisher<,>), typeof(AsyncMessageBroker<,>), lifetime);
                services.Add(typeof(IAsyncSubscriber<,>), typeof(AsyncMessageBroker<,>), lifetime);

                // keyed-async-variation
                services.Add(typeof(SingletonAsyncMessageBrokerCore<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncPublisher<,>), typeof(SingletonAsyncMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncSubscriber<,>), typeof(SingletonAsyncMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedAsyncMessageBrokerCore<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncPublisher<,>), typeof(ScopedAsyncMessageBroker<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncSubscriber<,>), typeof(ScopedAsyncMessageBroker<,>), InstanceLifetime.Scoped);
            }

            var lifetime2 = options.RequestHandlerLifetime; // requesthandler lifetime

#endif
#if !UNITY_2018_3_OR_NEWER
            // RequestHandler
            services.Add(typeof(IRequestHandler<,>), typeof(RequestHandler<,>), lifetime2);
            services.Add(typeof(IAsyncRequestHandler<,>), typeof(AsyncRequestHandler<,>), lifetime2);

            // RequestAll
            services.Add(typeof(IRequestAllHandler<,>), typeof(RequestAllHandler<,>), lifetime2);
            services.Add(typeof(IAsyncRequestAllHandler<,>), typeof(AsyncRequestAllHandler<,>), lifetime2);
            
            // auto registration is .NET only.
            if (options.EnableAutoRegistration)
            {
                // auto register filter and requesthandler
                // request handler is option's lifetime, filter is transient
                if (options.autoregistrationAssemblies == null && options.autoregistrationTypes == null)
                {
                    AddRequestHandlerAndFilterFromTypes(services, lifetime2, TypeCollector.CollectFromCurrentDomain());
                }
                else
                {
                    var fromAssemblies = (options.autoregistrationAssemblies != null)
                        ? TypeCollector.CollectFromAssemblies(options.autoregistrationAssemblies)
                        : Enumerable.Empty<Type>();
                    var types = options.autoregistrationTypes ?? Enumerable.Empty<Type>();

                    AddRequestHandlerAndFilterFromTypes(services, lifetime2, fromAssemblies.Concat(types).Distinct());
                }
            }

#endif

            return new MessagePipeBuilder(services);
        }

#if !UNITY_2018_3_OR_NEWER

        public static IMessagePipeBuilder AddMessageHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IMessageHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddAsyncMessageHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IAsyncMessageHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddRequestHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IRequestHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddAsyncRequestHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IAsyncRequestHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddRequestHandler(this IMessagePipeBuilder builder, Type type)
        {
            return AddRequestHandlerCore(builder, type, typeof(IRequestHandlerCore<,>));
        }

        public static IMessagePipeBuilder AddRequestHandler<T>(this IMessagePipeBuilder builder)
            where T : IRequestHandler
        {
            return AddRequestHandler(builder, typeof(T));
        }

        public static IMessagePipeBuilder AddAsyncRequestHandler(this IMessagePipeBuilder builder, Type type)
        {
            return AddRequestHandlerCore(builder, type, typeof(IAsyncRequestHandlerCore<,>));
        }

        public static IMessagePipeBuilder AddAsyncRequestHandler<T>(this IMessagePipeBuilder builder)
            where T : IAsyncRequestHandler
        {
            return AddAsyncRequestHandler(builder, typeof(T));
        }

        static IMessagePipeBuilder AddRequestHandlerCore(IMessagePipeBuilder builder, Type type, Type coreType)
        {
            var options = builder.Services.FirstOrDefault(x => x.ServiceType == typeof(MessagePipeOptions));
            if (options == null)
            {
                throw new ArgumentException($"Not yet added MessagePipeOptions, please call services.AddMessagePipe() before.");
            }
            var isAsync = (coreType == typeof(IAsyncRequestHandlerCore<,>));

            var registered = false;
            foreach (var interfaceType in type.GetInterfaces())
            {
                if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == coreType)
                {
                    var iType = interfaceType;
                    if (type.IsGenericType && !type.IsConstructedGenericType)
                    {
                        if (!interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            throw new ArgumentException("partial open generic type is not supported. Type:" + type.FullName);
                        }

                        iType = interfaceType.GetGenericTypeDefinition();
                    }

                    registered = true;
                    builder.Services.Add(iType, type, ((MessagePipeOptions)options.ImplementationInstance!).RequestHandlerLifetime);
                }
            }

            if (!registered)
            {
                throw new ArgumentException($"{type.FullName} does not implement {coreType.Name.Replace("Core", "")}.");
            }
            else if (isAsync)
            {
                AsyncRequestHandlerRegistory.Add(coreType);
            }

            return builder;
        }

        public static IMessagePipeBuilder AddInMemoryDistributedMessageBroker(this IMessagePipeBuilder builder)
        {
            var options = builder.Services.FirstOrDefault(x => x.ServiceType == typeof(MessagePipeOptions));
            if (options == null)
            {
                throw new ArgumentException($"Not yet added MessagePipeOptions, please call services.AddMessagePipe() before.");
            }

            var lifetime = ((MessagePipeOptions)options.ImplementationInstance!).InstanceLifetime;
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(InMemoryDistributedPublisher<,>), lifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(InMemoryDistributedSubscriber<,>), lifetime);

            return builder;
        }

        internal static void Add(this IServiceCollection services, Type serviceType, InstanceLifetime lifetime)
        {
            var lt = (lifetime == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                   : (lifetime == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                   : ServiceLifetime.Transient;
            services.Add(new ServiceDescriptor(serviceType, serviceType, lt));
        }

        internal static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime lifetime)
        {
            var lt = (lifetime == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                   : (lifetime == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                   : ServiceLifetime.Transient;
            services.Add(new ServiceDescriptor(serviceType, implementationType, lt));
        }

        static void AddRequestHandlerAndFilterFromTypes(IServiceCollection services, InstanceLifetime requestHandlerLifetime, IEnumerable<Type> targetTypes)
        {
            foreach (var objectType in targetTypes)
            {
                if (objectType.IsInterface || objectType.IsAbstract) continue;
                if (objectType.GetCustomAttributes(typeof(IgnoreAutoRegistration), false).Length != 0) continue;

                foreach (var interfaceType in objectType.GetInterfaces())
                {
                    if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == typeof(IRequestHandlerCore<,>))
                    {
                        if (!objectType.IsGenericType || objectType.IsConstructedGenericType)
                        {
                            services.Add(interfaceType, objectType, requestHandlerLifetime);
                        }
                        else if (interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            services.Add(typeof(IRequestHandlerCore<,>), objectType, requestHandlerLifetime);
                        }
                        continue;
                    }

                    if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == typeof(IAsyncRequestHandlerCore<,>))
                    {
                        if (!objectType.IsGenericType || objectType.IsConstructedGenericType)
                        {
                            services.Add(interfaceType, objectType, requestHandlerLifetime);
                        }
                        else if (interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            services.Add(typeof(IAsyncRequestHandlerCore<,>), objectType, requestHandlerLifetime);
                        }

                        AsyncRequestHandlerRegistory.Add(objectType);
                        continue;
                    }
                }

                foreach (var baseType in objectType.GetBaseTypes())
                {
                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(MessageHandlerFilter<>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(AsyncMessageHandlerFilter<>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(RequestHandlerFilter<,>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(AsyncRequestHandlerFilter<,>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }
                }

            NEXT_TYPE:
                continue;
            }
        }
#endif
    }
}


================================================
FILE: src/MessagePipe/SubscriberExtensions.AsAsyncEnumerable.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
#if !UNITY_2018_3_OR_NEWER
using System.Threading.Channels;
#endif

namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static IAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new AsyncEnumerableAsyncSubscriber<TMessage>(subscriber, filters);
        }

        public static IAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new BufferedAsyncEnumerableAsyncSubscriber<TMessage>(subscriber, filters);
        }

        public static IAsyncEnumerable<TMessage> AsAsyncEnumerable<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, params AsyncMessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return new AsyncEnumerableAsyncSubscriber<TKey, TMessage>(key, subscriber, filters);
        }
    }

    internal class AsyncEnumerableAsyncSubscriber<TMessage> : IAsyncEnumerable<TMessage>
    {
        readonly IAsyncSubscriber<TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public AsyncEnumerableAsyncSubscriber(IAsyncSubscriber<TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            disposable.Disposable = subscriber.Subscribe(e, filters);
            return e;
        }
    }

    internal class BufferedAsyncEnumerableAsyncSubscriber<TMessage> : IAsyncEnumerable<TMessage>
    {
        readonly IBufferedAsyncSubscriber<TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public BufferedAsyncEnumerableAsyncSubscriber(IBufferedAsyncSubscriber<TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            var task = subscriber.SubscribeAsync(e, filters);
            SetDisposableAsync(task, disposable);
            return e;
        }

        async void SetDisposableAsync(ValueTask<IDisposable> task, SingleAssignmentDisposable d)
        {
            d.Disposable = await task;
        }
    }

    internal class AsyncEnumerableAsyncSubscriber<TKey, TMessage> : IAsyncEnumerable<TMessage>
        where TKey : notnull
    {
        readonly TKey key;
        readonly IAsyncSubscriber<TKey, TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public AsyncEnumerableAsyncSubscriber(TKey key, IAsyncSubscriber<TKey, TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.key = key;
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            disposable.Disposable = subscriber.Subscribe(key, e, filters);
            return e;
        }
    }

    internal class AsyncMessageHandlerEnumerator<TMessage> : IAsyncEnumerator<TMessage>, IAsyncMessageHandler<TMessage>
    {
        Channel<TMessage> channel;
        CancellationToken cancellationToken;
        SingleAssignmentDisposable singleAssignmentDisposable;

        public AsyncMessageHandlerEnumerator(SingleAssignmentDisposable singleAssignmentDisposable, CancellationToken cancellationToken)
        {
            this.singleAssignmentDisposable = singleAssignmentDisposable;
            this.cancellationToken = cancellationToken;
#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<TMessage>(new UnboundedChannelOptions()
            {
                SingleWriter = true,
                SingleReader = true,
                AllowSynchronousContinuations = true
            });
#else
                this.channel = Channel.CreateSingleConsumerUnbounded<TMessage>();
#endif
        }

        TMessage IAsyncEnumerator<TMessage>.Current
        {
            get
            {
                if (channel.Reader.TryRead(out var msg))
                {
                    return msg;
                }
                throw new InvalidOperationException("Message is not buffered in Channel.");
            }
        }

        ValueTask<bool> IAsyncEnumerator<TMessage>.MoveNextAsync()
        {
            return channel.Reader.WaitToReadAsync(cancellationToken);
        }

        ValueTask IAsyncMessageHandler<TMessage>.HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            channel.Writer.TryWrite(message);
            return default;
        }

        ValueTask IAsyncDisposable.DisposeAsync()
        {
            singleAssignmentDisposable.Dispose(); // unsubscribe message.
            return default;
        }
    }
}


================================================
FILE: src/MessagePipe/SubscriberExtensions.AsObservable.cs
================================================
﻿using System;


namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static IObservable<TMessage> AsObservable<TMessage>(this ISubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ObservableSubscriber<TMessage>(subscriber, filters);
        }

        public static IObservable<TMessage> AsObservable<TMessage>(this IBufferedSubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ObservableBufferedSubscriber<TMessage>(subscriber, filters);
        }

        public static IObservable<TMessage> AsObservable<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, params MessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return new ObservableSubscriber<TKey, TMessage>(key, subscriber, filters);
        }
    }

    internal sealed class ObservableSubscriber<TKey, TMessage> : IObservable<TMessage>
        where TKey : notnull
    {
        readonly TKey key;
        readonly ISubscriber<TKey, TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableSubscriber(TKey key, ISubscriber<TKey, TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.key = key;
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(key, new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObservableSubscriber<TMessage> : IObservable<TMessage>
    {
        readonly ISubscriber<TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableSubscriber(ISubscriber<TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObservableBufferedSubscriber<TMessage> : IObservable<TMessage>
    {
        readonly IBufferedSubscriber<TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableBufferedSubscriber(IBufferedSubscriber<TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObserverMessageHandler<TMessage> : IMessageHandler<TMessage>
    {
        readonly IObserver<TMessage> observer;

        public ObserverMessageHandler(IObserver<TMessage> observer)
        {
            this.observer = observer;
        }

        public void Handle(TMessage message)
        {
            observer.OnNext(message);
        }
    }
}


================================================
FILE: src/MessagePipe/SubscriberExtensions.cs
================================================
﻿using MessagePipe.Internal;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        // pubsub-keyless-sync

        public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IBufferedSubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IBufferedSubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        // pubsub-keyless-async

        public static IDisposable Subscribe<TMessage>(this IAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static ValueTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static ValueTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, handler, predicate, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static ValueTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.SubscribeAsync(new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        // pubsub-key-sync

        public static IDisposable Subscribe<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return subscriber.Subscribe(key, new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(key, new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        // pubsub-key-async

        public static IDisposable Subscribe<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return subscriber.Subscribe(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, ValueTask> handler, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }
    }

    internal sealed class AnonymousMessageHandler<TMessage> : IMessageHandler<TMessage>
    {
        readonly Action<TMessage> handler;

        public AnonymousMessageHandler(Action<TMessage> handler)
        {
            this.handler = handler;
        }

        public void Handle(TMessage message)
        {
            handler.Invoke(message);
        }
    }

    internal sealed class AnonymousAsyncMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>
    {
        readonly Func<TMessage, CancellationToken, ValueTask> handler;

        public AnonymousAsyncMessageHandler(Func<TMessage, CancellationToken, ValueTask> handler)
        {
            this.handler = handler;
        }

        public ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            return handler.Invoke(message, cancellationToken);
        }
    }
}


================================================
FILE: src/MessagePipe/SubscriberExtensions.FirstAsync.cs
================================================
﻿using System;
using MessagePipe.Internal;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;

namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ValueTask<TMessage>(new FirstAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new ValueTask<TMessage>(new FirstAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }
        public static ValueTask<TMessage> FirstAsync<TMessage>(this IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ValueTask<TMessage>(new FirstAsyncBufferedMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TMessage>(this IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new ValueTask<TMessage>(new FirstAsyncBufferedMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TMessage>(this IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new ValueTask<TMessage>(new FirstAsyncAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TMessage>(this IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new ValueTask<TMessage>(new FirstAsyncAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static async ValueTask<TMessage> FirstAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return await new ValueTask<TMessage>(await FirstAsyncAsyncBufferedMessageHandler<TMessage>.CreateAsync(subscriber, cancellationToken, filters), 0);
        }

        public static async ValueTask<TMessage> FirstAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return await new ValueTask<TMessage>(await FirstAsyncAsyncBufferedMessageHandler<TMessage>.CreateAsync(subscriber, cancellationToken, filters), 0);
        }
        public static ValueTask<TMessage> FirstAsync<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return new ValueTask<TMessage>(new FirstAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new ValueTask<TMessage>(new FirstAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            return new ValueTask<TMessage>(new FirstAsyncAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static ValueTask<TMessage> FirstAsync<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
            where TKey : notnull
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new ValueTask<TMessage>(new FirstAsyncAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }
    }

    internal sealed class FirstAsyncMessageHandler<TKey, TMessage> : IMessageHandler<TMessage>, IValueTaskSource<TMessage>
        where TKey : notnull
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public FirstAsyncMessageHandler(ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.SetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(key, this, filters);
            }
            catch (Exception ex)
            {
                this.core.SetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncMessageHandler<TKey, TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.SetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }
    internal sealed class FirstAsyncMessageHandler<TMessage> : IMessageHandler<TMessage>, IValueTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public FirstAsyncMessageHandler(ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.SetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.SetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncMessageHandler<TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.SetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncBufferedMessageHandler<TMessage> : IMessageHandler<TMessage>, IValueTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public FirstAsyncBufferedMessageHandler(IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.SetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.SetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncBufferedMessageHandler<TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.SetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncMessageHandler<TKey, TMessage> : IAsyncMessageHandler<TMessage>, IValueTaskSource<TMessage>
        where TKey : notnull
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public FirstAsyncAsyncMessageHandler(IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.SetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(key, this, filters);
            }
            catch (Exception ex)
            {
                this.core.SetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncAsyncMessageHandler<TKey, TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.SetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.SetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>, IValueTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public FirstAsyncAsyncMessageHandler(IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.SetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.SetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncAsyncMessageHandler<TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.SetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.SetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncBufferedMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>, IValueTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable? subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        ManualResetValueTaskSourceCore<TMessage> core;

        static readonly Action<object?> cancelCallback = Cancel;

        public static async ValueTask<FirstAsyncAsyncBufferedMessageHandler<TMessage>> CreateAsync(IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var self = new FirstAsyncAsyncBufferedMessageHandler<TMessage>();
            if (cancellationToken.IsCancellationRequested)
            {
                self.core.SetException(new OperationCanceledException(cancellationToken));
                return self;
            }

            try
            {
                self.subscription = await subscriber.SubscribeAsync(self, filters).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                self.core.SetException(ex);
                return self;
            }

            if (self.handleCalled != 0)
            {
                self.subscription?.Dispose();
                return self;
            }

            if (cancellationToken.CanBeCanceled)
            {
                self.cancellationToken = cancellationToken;
                self.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, self, false);
            }
            return self;
        }

        static void Cancel(object? state)
        {
            var self = (FirstAsyncAsyncBufferedMessageHandler<TMessage>)state!;
            self.subscription?.Dispose();
            self.core.SetException(new OperationCanceledException(self.cancellationToken));
        }

        public ValueTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.SetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.SetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        public ValueTaskSourceStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object?> continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)
        {
            core.OnCompleted(continuation, state, token, flags);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }
}


================================================
FILE: src/MessagePipe/Internal/ArrayUtil.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MessagePipe.Internal
{
    internal static class ArrayUtil
    {
        public static T[] ImmutableAdd<T>(T[] source, T item)
        {
            var dest = new T[source.Length + 1];
            Array.Copy(source, 0, dest, 0, source.Length);
            dest[dest.Length - 1] = item;
            return dest;
        }

        public static T[] ImmutableRemove<T, TState>(T[] source, Func<T, TState, bool> match, TState state)
        {
            if (source.Length == 0) return source;

            int index = -1;
            for (int i = 0; i < source.Length; i++)
            {
                if (match(source[i], state))
                {
                    index = i;
                    break;
                }
            }

            if (index == -1)
            {
                return source;
            }

            if (source.Length == 1)
            {
                return Array.Empty<T>();
            }

            var dest = new T[source.Length - 1];

            if (index == 0)
            {
                // copy [1, last]
                Array.Copy(source, 1, dest, 0, dest.Length);
            }
            else if (index == source.Length - 1)
            {
                // copy [0, last-1]
                Array.Copy(source, 0, dest, 0, dest.Length);
            }
            else
            {
                // copy [0, index -1], [index+1-last]
                Array.Copy(source, 0, dest, 0, index);
                Array.Copy(source, index + 1, dest, index, source.Length - index - 1);
            }

            return dest;
        }

        public static IEnumerable<T> Concat<T>(T[] source1, T[] source2)
        {
            if (source1.Length != 0)
            {
                foreach (var item in source1)
                {
                    yield return item;
                }
            }

            if (source2.Length != 0)
            {
                foreach (var item in source2)
                {
                    yield return item;
                }
            }
        }

        public static IEnumerable<T> Concat<T>(T[] source1, T[] source2, T[] source3)
        {
            if (source1.Length != 0)
            {
                foreach (var item in source1)
                {
                    yield return item;
                }
            }

            if (source2.Length != 0)
            {
                foreach (var item in source2)
                {
                    yield return item;
                }
            }

            if (source3.Length != 0)
            {
                foreach (var item in source3)
                {
                    yield return item;
                }
            }
        }
    }
}


================================================
FILE: src/MessagePipe/Internal/AsyncHandlerWhenAll.AwaiterNode.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;

namespace MessagePipe.Internal
{
    internal partial class AsyncHandlerWhenAll<T>
    {
        internal class AwaiterNode : IPoolStackNode<AwaiterNode>
        {
            AwaiterNode? nextNode;
            public ref AwaiterNode? NextNode => ref nextNode;

            AsyncHandlerWhenAll<T> parent = default!;
            ValueTaskAwaiter awaiter;

            readonly Action continuation;

            static PoolStack<AwaiterNode> pool;

            public AwaiterNode()
            {
                this.continuation = OnCompleted;
            }

            public static void RegisterUnsafeOnCompleted(AsyncHandlerWhenAll<T> parent, ValueTaskAwaiter awaiter)
            {
                if (!pool.TryPop(out var result))
                {
                    result = new AwaiterNode();
                }
                result!.parent = parent;
                result.awaiter = awaiter;

                result.awaiter.UnsafeOnCompleted(result.continuation);
            }

            void OnCompleted()
            {
                var p = this.parent;
                var a = this.awaiter;
                this.parent = null!;
                this.awaiter = default;

                pool.TryPush(this);

                try
                {
                    a.GetResult();
                }
                catch (Exception ex)
                {
                    p.exception = ExceptionDispatchInfo.Capture(ex);
                    p.TryInvokeContinuation();
                    return;
                }

                p.IncrementSuccessfully();
            }
        }
    }
}



================================================
FILE: src/MessagePipe/Internal/AsyncHandlerWhenAll.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Internal
{
    internal static class ContinuationSentinel
    {
        public static readonly Action AvailableContinuation = () => { };
        public static readonly Action CompletedContinuation = () => { };
    }

    internal partial class AsyncHandlerWhenAll<T> : ICriticalNotifyCompletion
    {
        readonly int taskCount = 0;

        int completedCount = 0;
        ExceptionDispatchInfo? exception;
        Action continuation = ContinuationSentinel.AvailableContinuation;

        public AsyncHandlerWhenAll(IAsyncMessageHandler<T>?[] handlers, T message, CancellationToken cancellationtoken)
        {
            taskCount = handlers.Length;

            foreach (var item in handlers)
            {
                if (item == null)
                {
                    IncrementSuccessfully();
                }
                else
                {
                    try
                    {
                        var awaiter = item.HandleAsync(message, cancellationtoken).GetAwaiter();
                        if (awaiter.IsCompleted)
                        {
                            awaiter.GetResult();
                            goto SUCCESSFULLY;
                        }
                        else
                        {
                            AwaiterNode.RegisterUnsafeOnCompleted(this, awaiter);
                            continue;
                        }
                    }
                    catch (Exception ex)
                    {
                        exception = ExceptionDispatchInfo.Capture(ex);
                        TryInvokeContinuation();
                        return;
                    }

                SUCCESSFULLY:
                    IncrementSuccessfully();
                }
            }
        }

        void IncrementSuccessfully()
        {
            if (Interlocked.Increment(ref completedCount) == taskCount)
            {
                TryInvokeContinuation();
            }
        }

        void TryInvokeContinuation()
        {
            var c = Interlocked.Exchange(ref continuation, ContinuationSentinel.CompletedContinuation); // register completed.
            if (c != ContinuationSentinel.AvailableContinuation && c != ContinuationSentinel.CompletedContinuation)
            {
                c();
            }
        }

        // Awaiter

        public AsyncHandlerWhenAll<T> GetAwaiter()
        {
            return this;
        }

        public bool IsCompleted => exception != null || completedCount == taskCount;

        public void GetResult()
        {
            if (exception != null)
            {
                exception.Throw();
            }
            // Complete, OK.
        }

        public void OnCompleted(Action continuation)
        {
            UnsafeOnCompleted(continuation);
        }

        public void UnsafeOnCompleted(Action continuation)
        {
            var c = Interlocked.CompareExchange(ref this.continuation, continuation, ContinuationSentinel.AvailableContinuation);
            if (c == ContinuationSentinel.CompletedContinuation) // registered TryInvokeContinuation first.
            {
                continuation();
                return;
            }
        }
    }
}



================================================
FILE: src/MessagePipe/Internal/AsyncRequestHandlerWhenAll.Awaiter.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;

namespace MessagePipe.Internal
{
    internal partial class AsyncRequestHandlerWhenAll<TRequest, TResponse>
    {
        internal class AwaiterNode : IPoolStackNode<AwaiterNode>
        {
            AwaiterNode? nextNode;
            public ref AwaiterNode? NextNode => ref nextNode;

            AsyncRequestHandlerWhenAll<TRequest, TResponse> parent = default!;
            ValueTaskAwaiter<TResponse> awaiter;
            int index = -1;

            readonly Action continuation;

            static PoolStack<AwaiterNode> pool;

            public AwaiterNode()
            {
                this.continuation = OnCompleted;
            }

            public static void RegisterUnsafeOnCompleted(AsyncRequestHandlerWhenAll<TRequest, TResponse> parent, ValueTaskAwaiter<TResponse> awaiter, int index)
            {
                if (!pool.TryPop(out var result))
                {
                    result = new AwaiterNode();
                }
                result!.parent = parent;
                result.awaiter = awaiter;
                result.index = index;

                result.awaiter.UnsafeOnCompleted(result.continuation);
            }

            void OnCompleted()
            {
                var p = this.parent;
                var a = this.awaiter;
                var i = this.index;
                this.parent = null!;
                this.awaiter = default;
                this.index = -1;

                pool.TryPush(this);

                try
                {
                    p.result[i] = a.GetResult();
                }
                catch (Exception ex)
                {
                    p.exception = ExceptionDispatchInfo.Capture(ex);
                    p.TryInvokeContinuation();
                    return;
                }

                p.IncrementSuccessfully();
            }
        }
    }
}



================================================
FILE: src/MessagePipe/Internal/AsyncRequestHandlerWhenAll.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Threading;

namespace MessagePipe.Internal
{
    internal partial class AsyncRequestHandlerWhenAll<TRequest, TResponse> : ICriticalNotifyCompletion
    {
        int completedCount;
        ExceptionDispatchInfo? exception;
        Action continuation = ContinuationSentinel.AvailableContinuation;

        readonly TResponse[] result;

        public AsyncRequestHandlerWhenAll(IAsyncRequestHandlerCore<TRequest, TResponse>[] handlers, TRequest request, CancellationToken cancellationtoken)
        {
            result = new TResponse[handlers.Length];

            for (int i = 0; i < handlers.Length; i++)
            {
                try
                {
                    var awaiter = handlers[i].InvokeAsync(request, cancellationtoken).GetAwaiter();
                    if (awaiter.IsCompleted)
                    {
                        result[i] = awaiter.GetResult();
                    }
                    else
                    {
                        AwaiterNode.RegisterUnsafeOnCompleted(this, awaiter, i);
                        continue;
                    }
                }
                catch (Exception ex)
                {
                    exception = ExceptionDispatchInfo.Capture(ex);
                    TryInvokeContinuation();
                    return;
                }

                IncrementSuccessfully();
            }
        }

        void IncrementSuccessfully()
        {
            if (Interlocked.Increment(ref completedCount) == result.Length)
            {
                TryInvokeContinuation();
            }
        }

        void TryInvokeContinuation()
        {
            var c = Interlocked.Exchange(ref continuation, ContinuationSentinel.CompletedContinuation); // register completed.
            if (c != ContinuationSentinel.AvailableContinuation && c != ContinuationSentinel.CompletedContinuation)
            {
                c();
            }
        }

        // Awaiter

        public AsyncRequestHandlerWhenAll<TRequest, TResponse> GetAwaiter()
        {
            return this;
        }

        public bool IsCompleted => exception != null || completedCount == result.Length;

        public TResponse[] GetResult()
        {
            if (exception != null)
            {
                exception.Throw();
            }
            // Complete, OK.
            return result;
        }

        public void OnCompleted(Action continuation)
        {
            UnsafeOnCompleted(continuation);
        }

        public void UnsafeOnCompleted(Action continuation)
        {
            var c = Interlocked.CompareExchange(ref this.continuation, continuation, ContinuationSentinel.AvailableContinuation);
            if (c == ContinuationSentinel.CompletedContinuation) // registered TryInvokeContinuation first.
            {
                continuation();
            }
        }
    }
}



================================================
FILE: src/MessagePipe/Internal/FastQueue.cs
================================================
﻿#pragma warning disable CS8618

using System;
using System.Runtime.CompilerServices;

namespace MessagePipe.Internal
{
    // fixed size queue.
    internal class FastQueue<T>
    {
        T[] array;
        int head;
        int tail;
        int size;

        public FastQueue(int capacity)
        {
            if (capacity < 0) throw new ArgumentOutOfRangeException("capacity");
            array = new T[capacity];
            head = tail = size = 0;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return size; }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Enqueue(T item)
        {
            if (size == array.Length)
            {
                ThrowForFullQueue();
            }

            array[tail] = item;
            MoveNext(ref tail);
            size++;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T Dequeue()
        {
            if (size == 0) ThrowForEmptyQueue();

            int head = this.head;
            T[] array = this.array;
            T removed = array[head];
            array[head] = default!;
            MoveNext(ref this.head);
            size--;
            return removed;
        }

        public void EnsureNewCapacity(int capacity)
        {
            T[] newarray = new T[capacity];
            if (size > 0)
            {
                if (head < tail)
                {
                    Array.Copy(array, head, newarray, 0, size);
                }
                else
                {
                    Array.Copy(array, head, newarray, 0, array.Length - head);
                    Array.Copy(array, 0, newarray, array.Length - head, tail);
                }
            }

            array = newarray;
            head = 0;
            tail = (size == capacity) ? 0 : size;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void MoveNext(ref int index)
        {
            int tmp = index + 1;
            if (tmp == array.Length)
            {
                tmp = 0;
            }
            index = tmp;
        }

        void ThrowForEmptyQueue()
        {
            throw new InvalidOperationException("Queue is empty.");
        }

        void ThrowForFullQueue()
        {
            throw new InvalidOperationException("Queue is full.");
        }
    }
}


================================================
FILE: src/MessagePipe/Internal/FilterDefinition.cs
================================================
﻿using System;
using System.Linq;

namespace MessagePipe.Internal
{
    internal abstract class FilterDefinition
    {
        public Type FilterType { get; }
        public int Order { get; }

        public FilterDefinition(Type filterType, int order)
        {
            this.FilterType = filterType;
            this.Order = order;
        }
    }

    internal sealed class AttributeFilterDefinition : FilterDefinition
    {
        public AttributeFilterDefinition(Type filterType, int order)
            : base(filterType, order)
        {
        }
    }

    internal sealed class MessageHandlerFilterDefinition : FilterDefinition
    {
        public Type? MessageType { get; }
        public bool IsOpenGenerics { get; }

        public MessageHandlerFilterDefinition(Type filterType, int order, Type interfaceGenericDefinition)
            : base(filterType, order)
        {
            if (filterType.IsGenericType && !filterType.IsConstructedGenericType)
            {
                this.IsOpenGenerics = true;
                this.MessageType = null;
            }
            else
            {
                this.IsOpenGenerics = false;
                var interfaceType = filterType.GetBaseTypes().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceGenericDefinition);

                var genArgs = interfaceType.GetGenericArguments();
                this.MessageType = genArgs[0];
            }
        }
    }

    internal sealed class RequestHandlerFilterDefinition : FilterDefinition
    {
        public Type? RequestType { get; }
        public Type? ResponseType { get; }
        public bool IsOpenGenerics { get; }

        public RequestHandlerFilterDefinition(Type filterType, int order, Type interfaceGenericDefinition)
            : base(filterType, order)
        {
            if (filterType.IsGenericType && !filterType.IsConstructedGenericType)
            {
                this.IsOpenGenerics = true;
                this.RequestType = null;
                this.ResponseType = null;
            }
            else
            {
                this.IsOpenGenerics = false;
                var interfaceType = filterType.GetBaseTypes().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceGenericDefinition);

                var genArgs = interfaceType.GetGenericArguments();
                this.RequestType = genArgs[0];
                this.ResponseType = genArgs[1];
            }
        }
    }
}


================================================
FILE: src/MessagePipe/Internal/FreeList.cs
================================================
﻿#pragma warning disable CS8618

using System;
using System.Collections.Generic;
using System.Threading;

namespace MessagePipe.Internal
{
    internal sealed class FreeList<T> : IDisposable
        where T : class
    {
        const int InitialCapacity = 4;
        const int MinShrinkStart = 8;

        T?[] values;
        int count;
        FastQueue<int> freeIndex;
        bool isDisposed;
        readonly object gate = new object();

        public FreeList()
        {
            Initialize();
        }

        public T?[] GetValues() => values; // no lock, safe for iterate

        public int GetCount()
        {
            lock (gate)
            {
                return count;
            }
        }

        public int Add(T value)
        {
            lock (gate)
            {
                if (isDisposed) throw new ObjectDisposedException(nameof(FreeList<T>));

                if (freeIndex.Count != 0)
                {
                    var index = freeIndex.Dequeue();
                    values[index] = value;
                    count++;
                    return index;
                }
                else
                {
                    // resize
                    var newValues = new T[values.Length * 2];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    freeIndex.EnsureNewCapacity(newValues.Length);
                    for (int i = values.Length; i < newValues.Length; i++)
                    {
                        freeIndex.Enqueue(i);
                    }

                    var index = freeIndex.Dequeue();
                    newValues[values.Length] = value;
                    count++;
                    Volatile.Write(ref values, newValues);
                    return index;
                }
            }
        }

        public void Remove(int index, bool shrinkWhenEmpty)
        {
            lock (gate)
            {
                if (isDisposed) return; // do nothing

                ref var v = ref values[index];
                if (v == null) throw new KeyNotFoundException($"key index {index} is not found.");

                v = null;
                freeIndex.Enqueue(index);
                count--;

                if (shrinkWhenEmpty && count == 0 && values.Length > MinShrinkStart)
                {
                    Initialize(); // re-init.
                }
            }
        }

        /// <summary>
        /// Dispose and get cleared count.
        /// </summary>
        public bool TryDispose(out int clearedCount)
        {
            lock (gate)
            {
                if (isDisposed)
                {
                    clearedCount = 0;
                    return false;
                }

                clearedCount = count;
                Dispose();
                return true;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (isDisposed) return;
                isDisposed = true;

                freeIndex = null!;
                values = Array.Empty<T?>();
                count = 0;
            }
        }

        // [MemberNotNull(nameof(freeIndex), nameof(values))]
        void Initialize()
        {
            freeIndex = new FastQueue<int>(InitialCapacity);
            for (int i = 0; i < InitialCapacity; i++)
            {
                freeIndex.Enqueue(i);
            }
            count = 0;

            var v = new T?[InitialCapacity];
            Volatile.Write(ref values, v);
        }
    }
}


================================================
FILE: src/MessagePipe/Internal/PoolStack.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace MessagePipe.Internal
{
    internal interface IPoolStackNode<T>
        where T : class
    {
        ref T? NextNode { get; }
    }

    // mutable struct, don't mark readonly.
    [StructLayout(LayoutKind.Auto)]
    internal struct PoolStack<T>
        where T : class, IPoolStackNode<T>
    {
        int gate;
        int size;
        T? root;

        public int Size => size;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryPop(out T? result)
        {
            if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
            {
                var v = root;
                if (!(v is null))
                {
                    ref var nextNode = ref v.NextNode;
                    root = nextNode;
                    nextNode = null;
                    size--;
                    result = v;
                    Volatile.Write(ref gate, 0);
                    return true;
                }

                Volatile.Write(ref gate, 0);
            }
            result = default!;
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryPush(T item)
        {
            if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
            {
                item.NextNode = root;
                root = item;
                size++;
                Volatile.Write(ref gate, 0);
                return true;
            }
            return false;
        }
    }
}



================================================
FILE: src/MessagePipe/Internal/Preserve.cs
================================================
﻿namespace MessagePipe.Internal
{
    // Preserve for Unity IL2CPP

    internal class PreserveAttribute : System.Attribute
    {
    }
}



================================================
FILE: src/MessagePipe/Internal/TaskExtensions.cs
================================================
﻿using System.Threading.Tasks;

namespace MessagePipe.Internal
{
    internal static class TaskExtensions
    {
#if !UNITY_2018_3_OR_NEWER

        internal static async void Forget(this ValueTask task)
        {
            await task;
        }

#endif
    }
}


================================================
FILE: src/MessagePipe/Internal/TypeCollector.cs
================================================
﻿#if !UNITY_2018_3_OR_NEWER

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace MessagePipe.Internal
{
    internal static class TypeCollector
    {
        public static IEnumerable<Type> CollectFromCurrentDomain()
        {
            var wellKnownIgnoreAssemblies = new[]
            {
                "netstandard",
                "System.*",
                "Microsoft.Win32.*",
                "Microsoft.Extensions.*",
                "Microsoft.AspNetCore",
                "Microsoft.AspNetCore.*",
                "Grpc.*",
                "MessagePack",
                "MessagePack.*",
                "MagicOnion.Server",
                "MagicOnion.Server.*",
                "MagicOnion.Client",
                "MagicOnion.Client.*",
                "MagicOnion.Abstractions",
                "MagicOnion.Shared",
            };

            var assemblies = AppDomain.CurrentDomain.GetAssemblies()
                .Where(x => x.GetName().Name != "MessagePipe" && x.GetName().Name != "MessagePipe.Redis")
                .Where(x =>
                {
                    return !wellKnownIgnoreAssemblies.Any(y =>
                    {
                        if (y.EndsWith("*"))
                        {
                            return x.GetName().Name!.StartsWith(y.Substring(0, y.Length - 1));
                        }
                        else
                        {
                            return x.GetName().Name == y;
                        }
                    });
                });

            return CollectFromAssemblies(assemblies);
        }

        public static IEnumerable<Type> CollectFromAssemblies(IEnumerable<Assembly> searchAssemblies)
        {
            var types = searchAssemblies
                .Where(x => x.GetName().Name != "MessagePipe" && x.GetName().Name != "MessagePipe.Redis")
                .SelectMany(x =>
                {
                    try
                    {
                        return x.GetTypes();
                    }
                    catch (ReflectionTypeLoadException ex)
                    {
                        return ex.Types.Where(t => t != null);
                    }
                })
                .Where(x => x != null);

            return types!;
        }

        
    }
}

#endif


================================================
FILE: src/MessagePipe/Internal/TypeExtensions.cs
================================================
﻿using System;
using System.Collections.Generic;

namespace MessagePipe.Internal
{
    internal static class TypeExtensions
    {
        public static IEnumerable<Type> GetBaseTypes(this Type? t)
        {
            if (t == null) yield break;
            t = t.BaseType;
            while (t != null)
            {
                yield return t;
                t = t.BaseType;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Analyzer/MessagePipe.Analyzer.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>library</OutputType>
    <TargetFramework>netstandard2.0</TargetFramework>
    <IsRoslynComponent>true</IsRoslynComponent>
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);PackBuildOutputs</TargetsForTfmSpecificContentInPackage>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <IncludeSymbols>false</IncludeSymbols>
    <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>
    <DevelopmentDependency>true</DevelopmentDependency>

    <!-- NuGet Packaging -->
    <PackageTags>analyzer;</PackageTags>
    <Description>Analyzers of MessagePipe to prevent subscription leak.</Description>
    <SignAssembly>true</SignAssembly>
    <IsPackable>true</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.3">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.1.0" />
  </ItemGroup>

  <Target Name="PackBuildOutputs" DependsOnTargets="SatelliteDllsProjectOutputGroup;DebugSymbolsProjectOutputGroup">
    <ItemGroup>
      <TfmSpecificPackageFile Include="$(TargetDir)\*.dll" PackagePath="analyzers\dotnet\cs" />
      <TfmSpecificPackageFile Include="@(SatelliteDllsProjectOutputGroupOutput->'%(FinalOutputPath)')" PackagePath="analyzers\dotnet\cs\%(SatelliteDllsProjectOutputGroupOutput.Culture)\" />
    </ItemGroup>
  </Target>
</Project>



================================================
FILE: src/MessagePipe.Analyzer/MessagePipeAnalyzer.cs
================================================
﻿#pragma warning disable RS2008

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Linq;

namespace MessagePipe.Analyzer
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public class MessagePipeAnalyzer : DiagnosticAnalyzer
    {
        private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(
            id: "MPA001",
            title: "MessagePipeAnalyzer001: Don't ignore subscription",
            messageFormat: "Don't ignore subscription(IDisposable of Subscribe)",
            category: "Usage",
            defaultSeverity: DiagnosticSeverity.Error,
            isEnabledByDefault: true,
            description: "Checks handle Subscribe result(IDisposable).");

        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

        public override void Initialize(AnalysisContext context)
        {
            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
            context.EnableConcurrentExecution();

            context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);
        }

        private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
        {
            var types = new[]
            {
                "MessagePipe.ISubscriber`1",
                "MessagePipe.ISubscriber`2",
                "MessagePipe.IAsyncSubscriber`1",
                "MessagePipe.IAsyncSubscriber`2",
                "MessagePipe.IBufferedSubscriber`1",
                "MessagePipe.IBufferedAsyncSubscriber`1",
            };
            var messagePipeSymbols = types.Select(x => context.SemanticModel.Compilation.GetTypeByMetadataName(x)).Where(x => x != null).ToArray();

            var invocationExpressions = context.Node
                .DescendantNodes()
                .OfType<InvocationExpressionSyntax>();

            foreach (var expr in invocationExpressions)
            {
                var memberAccess = (expr.Expression as MemberAccessExpressionSyntax);
                if (memberAccess == null) continue;
                if (memberAccess.Name.Identifier.ValueText != "Subscribe") continue;

                var callerType = context.SemanticModel.GetTypeInfo(memberAccess.Expression).Type;
                if (callerType == null) continue;
                var originalType = callerType.OriginalDefinition;
                if (originalType == null) continue;

                if (!IsMessagePipeSymbol(messagePipeSymbols!, originalType)) continue;

                if (ValidateInvocation(expr)) continue;

                // Report Warning
                var diagnostic = Diagnostic.Create(Rule, expr.GetLocation());
                context.ReportDiagnostic(diagnostic);
            }
        }

        static bool ValidateInvocation(InvocationExpressionSyntax expr)
        {
            bool allAncestorsIsParenthes = true;
            foreach (var x in expr.Ancestors())
            {
                // scope is in lambda, method
                if (x.IsKind(SyntaxKind.SimpleLambdaExpression) || x.IsKind(SyntaxKind.ParenthesizedLambdaExpression) || x.IsKind(SyntaxKind.ArrowExpressionClause))
                {
                    // () => M()
                    if (allAncestorsIsParenthes) return true;
                    break;
                }
                if (x.IsKind(SyntaxKind.MethodDeclaration)) break;
                if (x.IsKind(SyntaxKind.PropertyDeclaration)) break;
                if (x.IsKind(SyntaxKind.ConstructorDeclaration)) break;

                // x = M()
                if (x.IsKind(SyntaxKind.SimpleAssignmentExpression)) return true;
                // var x = M()
                if (x.IsKind(SyntaxKind.VariableDeclarator)) return true;
                // return M()
                if (x.IsKind(SyntaxKind.ReturnStatement)) return true;
                // from x in M()
                if (x.IsKind(SyntaxKind.FromClause)) return true;
                // (bool) ? M() : M()
                if (x.IsKind(SyntaxKind.ConditionalExpression)) return true;
                // M(M())
                if (x.IsKind(SyntaxKind.InvocationExpression)) return true;
                // new C(M())
                if (x.IsKind(SyntaxKind.ObjectCreationExpression)) return true;
                // using(M())
                if (x.IsKind(SyntaxKind.UsingStatement)) return true;

                // (((((M()))))
                if (!x.IsKind(SyntaxKind.ParenthesizedExpression))
                {
                    allAncestorsIsParenthes = false;
                }
            }

            return false;
        }

        static bool IsMessagePipeSymbol(INamedTypeSymbol[] messagePipeSymbols, ITypeSymbol typeSymbol)
        {
            foreach (var item in messagePipeSymbols)
            {
                if (item.Equals(typeSymbol, SymbolEqualityComparer.Default)) return true;
            }

            return false;
        }
    }
}



================================================
FILE: src/MessagePipe.Analyzer/Properties/launchSettings.json
================================================
{
  "profiles": {
    "MessagePipe.Analyzer": {
      "commandName": "DebugRoslynComponent",
      "targetProject": "..\\..\\sandbox\\MessagePipe.AnalyzerTestApp\\MessagePipe.AnalyzerTestApp.csproj"
    }
  }
}


================================================
FILE: src/MessagePipe.Interprocess/MessageBuilder.cs
================================================
﻿using MessagePack;
using MessagePack.Formatters;
using MessagePipe.Interprocess.Internal;
using System;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace MessagePipe.Interprocess
{
    public interface IInterprocessKey : IEquatable<IInterprocessKey>
    {
        ReadOnlyMemory<byte> KeyMemory { get; }
    }

    public interface IInterprocessValue
    {
        ReadOnlyMemory<byte> ValueMemory { get; }
    }

    internal sealed class InterprocessMessage : IInterprocessKey, IInterprocessValue
    {
        readonly byte[] buffer;
        readonly int keyIndex;
        readonly int keyOffset;
        readonly int hashCode;

        public MessageType MessageType { get; }

        public InterprocessMessage(MessageType messageType, byte[] buffer, int keyIndex, int keyOffset)
        {
            this.MessageType = messageType;
            this.buffer = buffer;
            this.keyIndex = keyIndex;
            this.keyOffset = keyOffset;
            this.hashCode = CalcHashCode();
        }

        public ReadOnlyMemory<byte> KeyMemory => buffer.AsMemory(keyIndex, keyOffset - keyIndex);
        public ReadOnlyMemory<byte> ValueMemory => buffer.AsMemory(keyOffset, buffer.Length - keyOffset);

        public bool Equals(IInterprocessKey? other)
        {
            if (other == null) return false;
            return KeyMemory.Span.SequenceEqual(other.KeyMemory.Span);
        }

        public override int GetHashCode()
        {
            return hashCode;
        }

        int CalcHashCode()
        {
            // FNV1A32
            var obj = buffer;
            uint hash = 2166136261;
            for (int i = keyIndex; i < keyOffset; i++)
            {
                hash = unchecked((obj[i] ^ hash) * 16777619);
            }

            return unchecked((int)hash);
        }
    }

    internal enum MessageType : byte
    {
        PubSub = 1,
        RemoteRequest = 2,
        RemoteResponse = 3,
        RemoteError = 4,
    }

    internal static class MessageBuilder
    {
        // Message Frame-----
        // Length: int32(4), without self(MsgPack Body Only)
        // Body(PubSub): MessagePack Array[3](Type(byte), key, message)
        // Body(Reques): MessagePack Array[3](Type(byte), RequestHeader, request)
        // Body(Respon): MessagePack Array[3](Type(byte), messageId:int, response)
        // Body(RError): MessagePack Array[3](Type(byte), messageId:int, error:string)

        public static IInterprocessKey CreateKey<TKey>(TKey key, MessagePackSerializerOptions options)
        {
            var bytes = MessagePackSerializer.Serialize(key, options);
            return new InterprocessMessage(MessageType.PubSub, bytes, 0, bytes.Length);
        }

        public static byte[] BuildPubSubMessage<TKey, TMessaege>(TKey key, TMessaege message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.PubSub);
                MessagePackSerializer.Serialize(ref writer, key, options);
                MessagePackSerializer.Serialize(ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteRequestMessage<TRequest>(Type requestType, Type responseType, int messageId, TRequest message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteRequest);
                MessagePackSerializer.Serialize(ref writer, new RequestHeader(messageId, requestType.FullName!, responseType.FullName!), options);
                MessagePackSerializer.Serialize(ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteResponseMessage(int messageId, Type responseType, object message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteResponse);
                MessagePackSerializer.Serialize(ref writer, messageId, options);
                MessagePackSerializer.Serialize(responseType, ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteResponseError(int messageId, string exception, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteError);
                MessagePackSerializer.Serialize(ref writer, messageId, options);
                MessagePackSerializer.Serialize(ref writer, exception, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static int FetchMessageLength(ReadOnlySpan<byte> xs)
        {
            return Unsafe.ReadUnaligned<int>(ref Unsafe.AsRef(xs[0]));
        }

        public static InterprocessMessage ReadPubSubMessage(byte[] buffer)
        {
            var reader = new MessagePackReader(buffer);
            if (reader.ReadArrayHeader() != 3)
            {
                throw new InvalidOperationException("Invalid messagepack buffer.");
            }

            var b = reader.ReadByte();
            var msgType = (MessageType)b;

            var keyIndex = (int)reader.Consumed;
            reader.Skip();
            var keyOffset = (int)reader.Consumed;
            reader.Skip();

            return new InterprocessMessage(msgType, buffer, keyIndex, keyOffset);
        }
    }

    // (messageId:int, (reqType,resType):(string,string))

    [Preserve]
    [MessagePackFormatter(typeof(Formatter))]
    internal class RequestHeader
    {
        public int MessageId { get; }
        public string RequestType { get; }
        public string ResponseType { get; }

        public RequestHeader(int messageId, string requestType, string responseType)
        {
            MessageId = messageId;
            RequestType = requestType;
            ResponseType = responseType;
        }

        [Preserve]
        public class Formatter : IMessagePackFormatter<RequestHeader>
        {
            public RequestHeader Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                // debugging...
                var x = reader.ReadArrayHeader();
                if (x != 3) throw new MessagePack.MessagePackSerializationException("Array length is invalid. Length:" + x);
                var id = reader.ReadInt32();

                var req = reader.ReadString();
                var res = reader.ReadString();
                return new RequestHeader(id, req, res);
            }

            public void Serialize(ref MessagePackWriter writer, RequestHeader value, MessagePackSerializerOptions options)
            {
                writer.WriteArrayHeader(3);
                writer.Write(value.MessageId);
                writer.Write(value.RequestType);
                writer.Write(value.ResponseType);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Interprocess/MessagePipe.Interprocess.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net6.0</TargetFrameworks>
    <WarningsAsErrors>true</WarningsAsErrors>
    <Configurations>Debug;Release;</Configurations>

    <!-- NuGet Packaging -->
    <PackageTags>pubsub;eventaggregator</PackageTags>
    <Description>Interprocess extensions for MessagePipe.</Description>
    <SignAssembly>true</SignAssembly>
    <IsPackable>true</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MessagePack" Version="3.1.4" />
    <PackageReference Include="System.IO.Pipelines" Version="6.0.3" />
    <ProjectReference Include="..\MessagePipe\MessagePipe.csproj" />
  </ItemGroup>

  <ItemGroup Condition="$(TargetFramework) == 'netstandard2.0'">
    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="6.0.0" />
    <PackageReference Include="System.Threading.Channels" Version="6.0.0" />
  </ItemGroup>

  <!-- Copy files for Unity -->
  <PropertyGroup>
    <DestinationRoot>$(MSBuildProjectDirectory)\..\MessagePipe.Unity\Assets\Plugins\MessagePipe.Interprocess\Runtime\</DestinationRoot>
  </PropertyGroup>
  <ItemGroup>
    <TargetFiles1 Include="$(MSBuildProjectDirectory)\**\*.cs" Exclude="**\bin\**\*.*;**\obj\**\*.*;_InternalVisibleTo.cs" />
  </ItemGroup>

  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Copy SourceFiles="@(TargetFiles1)" DestinationFiles="$(DestinationRoot)\%(RecursiveDir)%(Filename)%(Extension)" SkipUnchangedFiles="true" />

    <!-- After copy, replace for unity codes -->
    <Exec Command="dotnet run --no-build -c $(ConfigurationName) --project $(MSBuildProjectDirectory)\..\..\tools\PostBuildUtility\PostBuildUtility.csproj -- replace-to-unity $(DestinationRoot)" />
  </Target>

</Project>



================================================
FILE: src/MessagePipe.Interprocess/MessagePipeInterprocessOptions.cs
================================================
﻿using MessagePack;
using MessagePack.Resolvers;
using System;

namespace MessagePipe.Interprocess
{
    public abstract class MessagePipeInterprocessOptions
    {
        public MessagePackSerializerOptions MessagePackSerializerOptions { get; set; }
        public InstanceLifetime InstanceLifetime { get; set; }
        public Action<string, Exception> UnhandledErrorHandler { get; set; }

        public MessagePipeInterprocessOptions()
        {
            this.MessagePackSerializerOptions = ContractlessStandardResolver.Options;
            this.InstanceLifetime = InstanceLifetime.Scoped;
#if !UNITY_2018_3_OR_NEWER
            this.UnhandledErrorHandler = (msg, x) => Console.WriteLine(msg + x);
#else
            this.UnhandledErrorHandler = (msg, x) => UnityEngine.Debug.Log(msg + x);
#endif
        }
    }

    public sealed class MessagePipeInterprocessUdpOptions : MessagePipeInterprocessOptions
    {
        public string Host { get; }
        public int Port { get; }

        public MessagePipeInterprocessUdpOptions(string host, int port)
            : base()
        {
            this.Host = host;
            this.Port = port;
        }
    }

    public sealed class MessagePipeInterprocessNamedPipeOptions : MessagePipeInterprocessOptions
    {
        public string PipeName { get; }
        public string ServerName { get; set; }
        public bool? HostAsServer { get; set; }

        public MessagePipeInterprocessNamedPipeOptions(string pipeName)
            : base()
        {
            this.PipeName = pipeName;
            this.ServerName = ".";
            this.HostAsServer = null;
        }
    }

    public sealed class MessagePipeInterprocessTcpOptions : MessagePipeInterprocessOptions
    {
        public string Host { get; }
        public int Port { get; }
        public bool? HostAsServer { get; set; }

        public MessagePipeInterprocessTcpOptions(string host, int port)
            : base()
        {
            this.Host = host;
            this.Port = port;
            this.HostAsServer = null;
        }
    }
#if NET5_0_OR_GREATER
    public sealed class MessagePipeInterprocessUdpUdsOptions : MessagePipeInterprocessOptions
    {
        public string SocketPath { get; set; }

        public MessagePipeInterprocessUdpUdsOptions(string socketPath)
            : base()
        {
            this.SocketPath = socketPath;
        }

    }
    public sealed class MessagePipeInterprocessTcpUdsOptions : MessagePipeInterprocessOptions
    {
        public string SocketPath { get; set; }
        public int? SendBufferSize { get; set; }
        public int? ReceiveBufferSize { get; set; }
        public bool? HostAsServer { get; set; }
        public MessagePipeInterprocessTcpUdsOptions(string socketPath): this(socketPath, null, null)
        {
        }
        public MessagePipeInterprocessTcpUdsOptions(string socketPath, int? sendBufferSize, int? recvBufferSize)
        {
            this.SocketPath = socketPath;
            HostAsServer = null;
            this.SendBufferSize = sendBufferSize;
            this.ReceiveBufferSize = recvBufferSize;
        }
    }
#endif
}


================================================
FILE: src/MessagePipe.Interprocess/NamedPipeDistributedPublisherSubscribercs.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class NamedPipeDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly NamedPipeWorker worker;

        [Preserve]
        public NamedPipeDistributedPublisher(NamedPipeWorker worker)
        {
            this.worker = worker;
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class NamedPipeDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from worker.
        readonly MessagePipeInterprocessNamedPipeOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public NamedPipeDistributedSubscriber(NamedPipeWorker worker, MessagePipeInterprocessNamedPipeOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        ValueTask<IAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }


}



================================================
FILE: src/MessagePipe.Interprocess/NamedPipeRemoteRequestHandler.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class NamedPipeRemoteRequestHandler<TRequest, TResponse> : IRemoteRequestHandler<TRequest, TResponse>
    {
        readonly NamedPipeWorker worker;

        [Preserve]
        public NamedPipeRemoteRequestHandler(NamedPipeWorker worker)
        {
            this.worker = worker;
        }

        public async ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return await worker.RequestAsync<TRequest, TResponse>(request, cancellationToken);
        }
    }
}



================================================
FILE: src/MessagePipe.Interprocess/ServiceCollectionInterprocessExtensions.cs
================================================
﻿using System;
using MessagePipe;
using MessagePipe.Interprocess;
using MessagePipe.Interprocess.Workers;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif

#if !UNITY_2018_3_OR_NEWER
using ReturnType = Microsoft.Extensions.DependencyInjection.IMessagePipeBuilder;
namespace Microsoft.Extensions.DependencyInjection
#else
using ReturnType = MessagePipe.Interprocess.MessagePipeInterprocessOptions;
namespace MessagePipe
#endif
{
    public static class ServiceCollectionInterprocessExtensions
    {
        public static ReturnType AddUdpInterprocess(this IMessagePipeBuilder builder, string host, int port)
        {
            return AddUdpInterprocess(builder, host, port, _ => { });
        }

        public static ReturnType AddUdpInterprocess(this IMessagePipeBuilder builder, string host, int port, Action<MessagePipeInterprocessUdpOptions> configure)
        {
            var options = new MessagePipeInterprocessUdpOptions(host, port);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(UdpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(UdpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(UdpDistributedSubscriber<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }

        public static ReturnType AddTcpInterprocess(this IMessagePipeBuilder builder, string host, int port)
        {
            return AddTcpInterprocess(builder, host, port, _ => { });
        }

        public static ReturnType AddTcpInterprocess(this IMessagePipeBuilder builder, string host, int port, Action<MessagePipeInterprocessTcpOptions> configure)
        {
            var options = new MessagePipeInterprocessTcpOptions(host, port);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(TcpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(TcpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(TcpDistributedSubscriber<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(TcpRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif

        }

#if !UNITY_2018_3_OR_NEWER

        // NamedPipe in Unity is slightly buggy so disable.

        public static ReturnType AddNamedPipeInterprocess(this IMessagePipeBuilder builder, string pipeName)
        {
            return AddNamedPipeInterprocess(builder, pipeName, _ => { });
        }

        public static ReturnType AddNamedPipeInterprocess(this IMessagePipeBuilder builder, string pipeName, Action<MessagePipeInterprocessNamedPipeOptions> configure)
        {
            var options = new MessagePipeInterprocessNamedPipeOptions(pipeName);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(NamedPipeWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(NamedPipeDistributedPublisher<,>), InstanceLifetime.Singleton);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(NamedPipeDistributedSubscriber<,>), InstanceLifetime.Singleton);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(NamedPipeRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }

#endif

        static void Add(this IServiceCollection services, Type serviceType, InstanceLifetime scope)
        {
            services.Add(serviceType, serviceType, scope);
        }

#if !UNITY_2018_3_OR_NEWER

        static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime scope)
        {
            var lifetime = (scope == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                : (scope == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                : ServiceLifetime.Transient;

            var descriptor = new ServiceDescriptor(serviceType, implementationType, lifetime);
            services.Add(descriptor);
        }

#endif

#if UNITY_2018_3_OR_NEWER

        static void AddAsyncMessageBroker<TKey,TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            builder.Services.Add(typeof(AsyncMessageBrokerCore<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IAsyncPublisher<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IAsyncSubscriber<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), options.InstanceLifetime);
        }

        public static IMessagePipeBuilder RegisterUpdInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            AddAsyncMessageBroker<TKey, TMessage>(builder, options);
            builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(UdpDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(UdpDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

            return builder;
        }

        public static IMessagePipeBuilder RegisterTcpInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            AddAsyncMessageBroker<TKey, TMessage>(builder, options);
            builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(TcpDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(TcpDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

            return builder;
        }

        //public static IMessagePipeBuilder RegisterNamedPipeInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        //{
        //    AddAsyncMessageBroker<TKey, TMessage>(builder, options);
        //    builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(NamedPipeDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
        //    builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(NamedPipeDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

        //    return builder;
        //}

        public static IMessagePipeBuilder RegisterTcpRemoteRequestHandler<TRequest, TResponse>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            builder.Services.Add(typeof(IRemoteRequestHandler<TRequest, TResponse>), typeof(TcpRemoteRequestHandler<TRequest, TResponse>), options.InstanceLifetime);

            return builder;
        }

        //public static IMessagePipeBuilder RegisterNamedPipeRemoteRequestHandler<TRequest, TResponse>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        //{
        //    builder.Services.Add(typeof(IRemoteRequestHandler<TRequest, TResponse>), typeof(NamedPipeRemoteRequestHandler<TRequest, TResponse>), options.InstanceLifetime);

        //    return builder;
        //}

#endif
#if NET5_0_OR_GREATER
        public static ReturnType AddUdpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath)
        {
            return AddUdpInterprocessUds(builder, domainSocketPath, _ => { });
        }
        public static ReturnType AddUdpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath, Action<MessagePipeInterprocessUdpUdsOptions> configure)
        {
            var options = new MessagePipeInterprocessUdpUdsOptions(domainSocketPath);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(UdpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(UdpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(UdpDistributedSubscriber<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }
        public static ReturnType AddTcpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath)
        {
            return AddTcpInterprocessUds(builder, domainSocketPath, _ => { });
        }

        public static ReturnType AddTcpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath, Action<MessagePipeInterprocessTcpUdsOptions> configure)
        {
            var options = new MessagePipeInterprocessTcpUdsOptions(domainSocketPath);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(TcpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(TcpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(TcpDistributedSubscriber<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(TcpRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif

        }
#endif // NET5_0_OR_GREATER
    }
}


================================================
FILE: src/MessagePipe.Interprocess/TcpDistributedPublisherSubscriber.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class TcpDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly TcpWorker worker;

        [Preserve]
        public TcpDistributedPublisher(TcpWorker worker)
        {
            this.worker = worker;
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class TcpDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from UdpWorker.
        readonly MessagePipeInterprocessOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public TcpDistributedSubscriber(TcpWorker worker, MessagePipeInterprocessTcpOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public TcpDistributedSubscriber(TcpWorker worker, MessagePipeInterprocessTcpUdsOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#endif
        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        ValueTask<IAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    
}



================================================
FILE: src/MessagePipe.Interprocess/TcpRemoteRequestHandler.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class TcpRemoteRequestHandler<TRequest, TResponse> : IRemoteRequestHandler<TRequest, TResponse>
    {
        readonly TcpWorker worker;

        [Preserve]
        public TcpRemoteRequestHandler(TcpWorker worker)
        {
            this.worker = worker;
        }

        public async ValueTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return await worker.RequestAsync<TRequest, TResponse>(request, cancellationToken);
        }
    }
}



================================================
FILE: src/MessagePipe.Interprocess/UdpDistributedPublisherSubscriber.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class UdpDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly UdpWorker worker;

        [Preserve]
        public UdpDistributedPublisher(UdpWorker worker)
        {
            this.worker = worker;
        }

        public ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class UdpDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from UdpWorker.
        readonly MessagePipeInterprocessOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public UdpDistributedSubscriber(UdpWorker worker, MessagePipeInterprocessUdpOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public UdpDistributedSubscriber(UdpWorker worker, MessagePipeInterprocessUdpUdsOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#endif
        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        ValueTask<IAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new ValueTask<IAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    
}



================================================
FILE: src/MessagePipe.Interprocess/Internal/ArrayPoolBufferWriter.cs
================================================
﻿using System;
using System.Buffers;

namespace MessagePipe.Interprocess.Internal
{
    internal class ArrayPoolBufferWriter : IBufferWriter<byte>, IDisposable
    {
        byte[] buffer;
        int index;

        const int MinBufferSize = 256;

        public int WrittenCount => index;
        public int Capacity => buffer.Length;
        public int FreeCapacity => buffer.Length - index;

        public ReadOnlySpan<byte> WrittenSpan => buffer.AsSpan(0, index);

        public ArrayPoolBufferWriter()
        {
            buffer = Array.Empty<byte>();
        }

        public void Advance(int count)
        {
            index += count;
        }

        public Memory<byte> GetMemory(int sizeHint = 0)
        {
            EnsureCapacity(sizeHint);
            return buffer.AsMemory(index);
        }

        public Span<byte> GetSpan(int sizeHint = 0)
        {
            EnsureCapacity(sizeHint);
            return buffer.AsSpan(index);
        }

        void EnsureCapacity(int sizeHint)
        {
            if (sizeHint == 0)
            {
                sizeHint = 1;
            }

            if (sizeHint > FreeCapacity)
            {
                var newBuffer = ArrayPool<byte>.Shared.Rent(Math.Max(index + sizeHint, MinBufferSize));
                if (buffer.Length != 0)
                {
                    Array.Copy(buffer, 0, newBuffer, 0, index);
                    ArrayPool<byte>.Shared.Return(buffer);
                }
                buffer = newBuffer;
            }
        }

        public void Dispose()
        {
            if (buffer.Length != 0)
            {
                ArrayPool<byte>.Shared.Return(buffer);
                buffer = Array.Empty<byte>();
            }
        }
    }

}



================================================
FILE: src/MessagePipe.Interprocess/Internal/AsyncDisposableBridge.cs
================================================
﻿using System;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess.Internal
{
    internal sealed class AsyncDisposableBridge : IAsyncDisposable
    {
        readonly IDisposable disposable;

        public AsyncDisposableBridge(IDisposable disposable)
        {
            this.disposable = disposable;
        }

        public ValueTask DisposeAsync()
        {
            disposable.Dispose();
            return default;
        }
    }

    
}



================================================
FILE: src/MessagePipe.Interprocess/Internal/Preserve.cs
================================================
﻿namespace MessagePipe.Interprocess.Internal
{
    // Preserve for Unity IL2CPP

    internal class PreserveAttribute : System.Attribute
    {
    }
}



================================================
FILE: src/MessagePipe.Interprocess/Internal/TransformHandler.cs
================================================
﻿using MessagePack;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess.Internal
{
    internal sealed class TransformSyncMessageHandler<TMessage> : IAsyncMessageHandler<IInterprocessValue>
    {
        readonly IMessageHandler<TMessage> handler;
        readonly MessagePackSerializerOptions options;

        public TransformSyncMessageHandler(IMessageHandler<TMessage> handler, MessagePackSerializerOptions options)
        {
            this.handler = handler;
            this.options = options;
        }

        public ValueTask HandleAsync(IInterprocessValue message, CancellationToken cancellationToken)
        {
            var msg = MessagePackSerializer.Deserialize<TMessage>(message.ValueMemory, options);
            handler.Handle(msg);
            return default;
        }
    }

    internal sealed class TransformAsyncMessageHandler<TMessage> : IAsyncMessageHandler<IInterprocessValue>
    {
        readonly IAsyncMessageHandler<TMessage> handler;
        readonly MessagePackSerializerOptions options;

        public TransformAsyncMessageHandler(IAsyncMessageHandler<TMessage> handler, MessagePackSerializerOptions options)
        {
            this.handler = handler;
            this.options = options;
        }

        public ValueTask HandleAsync(IInterprocessValue message, CancellationToken cancellationToken)
        {
            var msg = MessagePackSerializer.Deserialize<TMessage>(message.ValueMemory, options);
            return handler.HandleAsync(msg, cancellationToken);
        }
    }

}



================================================
FILE: src/MessagePipe.Interprocess/Workers/NamedPipeWorker.cs
================================================
﻿using MessagePack;
using MessagePipe.Interprocess.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using System.Threading.Channels;
#endif
using System;
using System.Collections.Concurrent;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class NamedPipeWorker : IDisposable
    {
        readonly string pipeName;
        readonly IServiceProvider provider;
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessNamedPipeOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<NamedPipeServerStream> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<NamedPipeClientStream> client;

        // request-response
        int messageId = 0;
        ConcurrentDictionary<int, TaskCompletionSource<IInterprocessValue>> responseCompletions = new ConcurrentDictionary<int, TaskCompletionSource<IInterprocessValue>>();

        // create from DI
        [Preserve]
        public NamedPipeWorker(IServiceProvider provider, MessagePipeInterprocessNamedPipeOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.pipeName = options.PipeName;
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = CreateLazyServerStream();

            this.client = new Lazy<NamedPipeClientStream>(() =>
            {
                return new NamedPipeClientStream(options.ServerName, options.PipeName, PipeDirection.InOut, PipeOptions.Asynchronous);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }

        Lazy<NamedPipeServerStream> CreateLazyServerStream()
        {
            return new Lazy<NamedPipeServerStream>(() => new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.Asynchronous));
        }

        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        public async ValueTask<TResponse> RequestAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var mid = Interlocked.Increment(ref messageId);
            var tcs = new TaskCompletionSource<IInterprocessValue>();
            responseCompletions[mid] = tcs;
            var buffer = MessageBuilder.BuildRemoteRequestMessage(typeof(TRequest), typeof(TResponse), mid, request, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
            var memoryValue = await tcs.Task.ConfigureAwait(false);
            return MessagePackSerializer.Deserialize<TResponse>(memoryValue.ValueMemory, options.MessagePackSerializerOptions);
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                RunReceiveLoop(server.Value, x =>
                {
#if !UNITY_2018_3_OR_NEWER
                    return server.Value.WaitForConnectionAsync(x);
#else
                    return System.Threading.Tasks.Task.Run(()=> server.Value.WaitForConnection(), x);
#endif
                });
            }
        }

        // Send packet to udp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var pipeStream = client.Value;

            try
            {
#if !UNITY_2018_3_OR_NEWER
                await pipeStream.ConnectAsync(Timeout.Infinite, token).ConfigureAwait(false);
#else
                await System.Threading.Tasks.Task.Run(() => pipeStream.Connect(), token);
#endif
            }
            catch (IOException)
            {
                return; // connection closed.
            }
            RunReceiveLoop(pipeStream, null); // client connected, setup receive loop

            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await pipeStream.WriteAsync(item, 0, item.Length, token).ConfigureAwait(false);
                    }
                    catch (IOException)
                    {
                        return; // connection closed.
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        // Receive from udp socket and push value to subscribers.
        async void RunReceiveLoop(Stream pipeStream, Func<CancellationToken, Task>? waitForConnection)
        {
        RECONNECT:
            var token = cancellationTokenSource.Token;
            if (waitForConnection != null)
            {
                try
                {
                    await waitForConnection(token).ConfigureAwait(false);
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
            }
            var buffer = new byte[65536];
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value = Array.Empty<byte>();
                try
                {
                    var readLen = await pipeStream.ReadAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                    if (readLen == 0)
                    {
                        if (waitForConnection != null)
                        {
                            server.Value.Dispose();
                            server = CreateLazyServerStream();
                            pipeStream = server.Value;
                            goto RECONNECT; // end of stream(disconnect, wait reconnect)
                        }
                    }

                    var messageLen = MessageBuilder.FetchMessageLength(buffer);
                    if (readLen == (messageLen + 4))
                    {
                        value = buffer.AsMemory(4, messageLen); // skip length header
                    }
                    else
                    {
                        // read more
                        if (buffer.Length < (messageLen + 4))
                        {
                            Array.Resize(ref buffer, messageLen + 4);
                        }
                        var remain = messageLen - (readLen - 4);
                        await ReadFullyAsync(buffer, pipeStream, readLen, remain, token).ConfigureAwait(false);
                        value = buffer.AsMemory(4, messageLen);
                    }
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }

                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray()); // can avoid copy?
                    switch (message.MessageType)
                    {
                        case MessageType.PubSub:
                            publisher.Publish(message, message, CancellationToken.None);
                            break;
                        case MessageType.RemoteRequest:
                            {
                                // NOTE: should use without reflection(Expression.Compile)
                                var header = Deserialize<RequestHeader>(message.KeyMemory, options.MessagePackSerializerOptions);
                                var (mid, reqTypeName, resTypeName) = (header.MessageId, header.RequestType, header.ResponseType);
                                byte[] resultBytes;
                                try
                                {
                                    var t = AsyncRequestHandlerRegistory.Get(reqTypeName, resTypeName);
                                    var interfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandler"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var coreInterfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var service = provider.GetRequiredService(interfaceType); // IAsyncRequestHandler<TRequest,TResponse>
                                    var genericArgs = interfaceType.GetGenericArguments(); // [TRequest, TResponse]
                                    var request = MessagePackSerializer.Deserialize(genericArgs[0], message.ValueMemory, options.MessagePackSerializerOptions);
                                    var responseTask = coreInterfaceType.GetMethod("InvokeAsync")!.Invoke(service, new[] { request, CancellationToken.None });
                                    var task = typeof(ValueTask<>).MakeGenericType(genericArgs[1]).GetMethod("AsTask")!.Invoke(responseTask, null);
                                    await ((System.Threading.Tasks.Task)task!); // Task<T> -> Task
                                    var result = task.GetType().GetProperty("Result")!.GetValue(task);
                                    resultBytes = MessageBuilder.BuildRemoteResponseMessage(mid, genericArgs[1], result!, options.MessagePackSerializerOptions);
                                }
                                catch (Exception ex)
                                {
                                    // NOTE: ok to send stacktrace?
                                    resultBytes = MessageBuilder.BuildRemoteResponseError(mid, ex.ToString(), options.MessagePackSerializerOptions);
                                }

                                await pipeStream.WriteAsync(resultBytes, 0, resultBytes.Length).ConfigureAwait(false);
                            }
                            break;
                        case MessageType.RemoteResponse:
                        case MessageType.RemoteError:
                            {
                                var mid = Deserialize<int>(message.KeyMemory, options.MessagePackSerializerOptions);
                                if (responseCompletions.TryRemove(mid, out var tcs))
                                {
                                    if (message.MessageType == MessageType.RemoteResponse)
                                    {
                                        tcs.TrySetResult(message); // synchronous completion, use memory buffer immediately.
                                    }
                                    else
                                    {
                                        var errorMsg = MessagePackSerializer.Deserialize<string>(message.ValueMemory, options.MessagePackSerializerOptions);
                                        tcs.TrySetException(new RemoteRequestException(errorMsg));
                                    }
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) continue;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        // omajinai.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options)
        {
            if (buffer.IsEmpty && MemoryMarshal.TryGetArray(buffer, out var segment))
            {
                buffer = segment;
            }
            return MessagePackSerializer.Deserialize<T>(buffer, options);
        }

        static async ValueTask ReadFullyAsync(byte[] buffer, Stream stream, int index, int remain, CancellationToken token)
        {
            while (remain > 0)
            {
                var len = await stream.ReadAsync(buffer, index, remain, token).ConfigureAwait(false);
                index += len;
                remain -= len;
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }

            foreach (var item in responseCompletions)
            {
                try
                {
                    item.Value.TrySetCanceled();
                }
                catch { }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Interprocess/Workers/SocketTcpClient.cs
================================================
﻿using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess.Workers
{
    // TODO:TCP STREAM AND READ

    internal sealed class SocketTcpServer : IDisposable
    {
        const int MaxConnections = 0x7fffffff;

        readonly Socket socket;

        SocketTcpServer(AddressFamily addressFamily, ProtocolType protocolType, int? sendBufferSize, int? recvBufferSize)
        {
            socket = new Socket(addressFamily, SocketType.Stream, protocolType);
            if(sendBufferSize.HasValue)
            {
                socket.SendBufferSize = sendBufferSize.Value;
            }
            if(recvBufferSize.HasValue)
            {
                socket.ReceiveBufferSize = recvBufferSize.Value;
            }
        }

        public static SocketTcpServer Listen(string host, int port)
        {
            var ip = new IPEndPoint(IPAddress.Parse(host), port);
            var server = new SocketTcpServer(ip.AddressFamily, ProtocolType.Tcp, null, null);

            server.socket.Bind(ip);
            server.socket.Listen(MaxConnections);
            return server;
        }

#if NET5_0_OR_GREATER
        /// <summary>
        /// create TCP unix domain socket server and listen
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <param name="recvBufferSize">socket's receive buffer size</param>
        /// <param name="sendBufferSize">socket's send buffer size</param>
        /// <exception cref="SocketException">unix domain socket not supported or socket already exists</exception>
        /// <returns>TCP unix domain socket server</returns>
        public static SocketTcpServer ListenUds(string domainSocketPath, int? sendBufferSize = null, int? recvBufferSize = null)
        {
            var server = new SocketTcpServer(AddressFamily.Unix, ProtocolType.IP, sendBufferSize, recvBufferSize);
            server.socket.Bind(new UnixDomainSocketEndPoint(domainSocketPath));
            server.socket.Listen(MaxConnections);
            return server;
        }
#endif

        public async void StartAcceptLoopAsync(Action<SocketTcpClient> onAccept, CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                Socket remote = default!;
                try
                {
                    remote = await socket.AcceptAsync();
                }
                catch // (ObjectDisposedException)
                {
                    return;
                }
                onAccept(new SocketTcpClient(remote));
            }
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }

    internal sealed class SocketTcpClient : IDisposable
    {
        readonly Socket socket;

        SocketTcpClient(AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Stream, protocolType);
        }

        internal SocketTcpClient(Socket socket)
        {
            this.socket = socket;
        }

        public static SocketTcpClient Connect(string host, int port)
        {
            var ip = new IPEndPoint(IPAddress.Parse(host), port);
            var client = new SocketTcpClient(ip.AddressFamily, ProtocolType.Tcp);
            client.socket.Connect(ip);
            return client;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create TCP unix domain socket client and connect to server
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <exception cref="SocketException">unix domain socket not supported or server does not listen</exception>
        /// <returns>TCP socket client.</returns>
        public static SocketTcpClient ConnectUds(string domainSocketPath)
        {
            var client = new SocketTcpClient(AddressFamily.Unix, ProtocolType.IP);
            client.socket.Connect(new UnixDomainSocketEndPoint(domainSocketPath));
            return client;
        }
#endif

        public async ValueTask<int> ReceiveAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
#if NET5_0_OR_GREATER
            var xs = new ArraySegment<byte>(buffer, offset, count);
            var i = await socket.ReceiveAsync(xs, SocketFlags.None, cancellationToken).ConfigureAwait(false);
            return i;
#else
            var tcs = new TaskCompletionSource<int>();

            socket.BeginReceive(buffer, offset, count, SocketFlags.None, x =>
            {
                int i;
                try
                {
                    i = socket.EndReceive(x);
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(ex);
                    return;
                }
                tcs.TrySetResult(i);
            }, null);

            return await tcs.Task;
#endif
        }

        public ValueTask<int> SendAsync(byte[] buffer, CancellationToken cancellationToken = default)
        {
#if NET5_0_OR_GREATER
            return socket.SendAsync(buffer, SocketFlags.None, cancellationToken);
#else
            var tcs = new TaskCompletionSource<int>();
            socket.BeginSend(buffer, 0, buffer.Length, SocketFlags.None, x =>
             {
                 int i;
                 try
                 {
                     i = socket.EndSend(x);
                 }
                 catch (Exception ex)
                 {
                     tcs.TrySetException(ex);
                     return;
                 }
                 tcs.TrySetResult(i);
             }, null);

#if !UNITY_2018_3_OR_NEWER
            return new ValueTask<int>(tcs.Task);
#else
            return tcs.Task;
#endif
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe.Interprocess/Workers/SocketUdpClient.cs
================================================
﻿using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Interprocess.Workers
{
    internal sealed class SocketUdpServer : IDisposable
    {
        const int MinBuffer = 4096;

        readonly Socket socket;
        readonly byte[] buffer;

        SocketUdpServer(int bufferSize, AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Dgram, protocolType);
            socket.ReceiveBufferSize = bufferSize;
            buffer = new byte[Math.Max(bufferSize, MinBuffer)];
        }
        public static SocketUdpServer Bind(int port, int bufferSize)
        {
            var server = new SocketUdpServer(bufferSize, AddressFamily.InterNetwork, ProtocolType.Udp);
            server.socket.Bind(new IPEndPoint(IPAddress.Any, port));
            return server;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create UDP socket and bind for listen.
        /// </summary>
        /// <param name="domainSocketPath">path to socket</param>
        /// <param name="bufferSize">socket buffer size</param>
        /// <exception cref="SocketException">unix domain socket not supported or socket already exists even if it is not bound</exception>
        /// <returns>UDP server with bound socket</returns>
        public static SocketUdpServer BindUds(string domainSocketPath, int bufferSize)
        {
            var server = new SocketUdpServer(bufferSize, AddressFamily.Unix, ProtocolType.IP);
            server.socket.Bind(new UnixDomainSocketEndPoint(domainSocketPath));
            return server;
        }
#endif

        public async ValueTask<ReadOnlyMemory<byte>> ReceiveAsync(CancellationToken cancellationToken)
        {
#if NET5_0_OR_GREATER
            var i = await socket.ReceiveAsync(buffer, SocketFlags.None, cancellationToken).ConfigureAwait(false);
            return buffer.AsMemory(0, i);
#else
            var tcs = new TaskCompletionSource<ReadOnlyMemory<byte>>();

            socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, x =>
            {
                int i;
                try
                {
                    i = socket.EndReceive(x);
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(ex);
                    return;
                }
                var r = buffer.AsMemory(0, i);
                tcs.TrySetResult(r);
            }, null);

            return await tcs.Task;
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }

    internal sealed class SocketUdpClient : IDisposable
    {
        const int MinBuffer = 4096;

        readonly Socket socket;
        readonly byte[] buffer;

        SocketUdpClient(int bufferSize, AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Dgram, protocolType);
            socket.SendBufferSize = bufferSize;
            buffer = new byte[Math.Max(bufferSize, MinBuffer)];
        }

        public static SocketUdpClient Connect(string host, int port, int bufferSize)
        {
            var ipaddr = IPAddress.Parse(host);
            var client = new SocketUdpClient(bufferSize, ipaddr.AddressFamily, ProtocolType.Udp);
            client.socket.Connect(new IPEndPoint(ipaddr, port));
            return client;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create UDP unix domain socket client and connect to server
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <param name="bufferSize"></param>
        /// <exception cref="SocketException">unix domain socket not supported or server does not exist</exception>
        /// <returns>UDP unix domain socket client</returns>
        public static SocketUdpClient ConnectUds(string domainSocketPath, int bufferSize)
        {
            var client = new SocketUdpClient(bufferSize, AddressFamily.Unix, ProtocolType.IP);
            client.socket.Connect(new UnixDomainSocketEndPoint(domainSocketPath));
            return client;
        }
#endif

        public ValueTask<int> SendAsync(byte[] buffer, CancellationToken cancellationToken = default)
        {
#if NET5_0_OR_GREATER
            return socket.SendAsync(buffer, SocketFlags.None, cancellationToken);
#else
            var tcs = new TaskCompletionSource<int>();
            socket.BeginSend(buffer, 0, buffer.Length, SocketFlags.None, x =>
             {
                 int i;
                 try
                 {
                     i = socket.EndSend(x);
                 }
                 catch (Exception ex)
                 {
                     tcs.TrySetException(ex);
                     return;
                 }
                 tcs.TrySetResult(i);
             }, null);
#if !UNITY_2018_3_OR_NEWER
            return new ValueTask<int>(tcs.Task);
#else
            return tcs.Task;
#endif
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe.Interprocess/Workers/TcpWorker.cs
================================================
﻿using MessagePack;
using MessagePipe.Interprocess.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using System.Threading.Channels;
#endif
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class TcpWorker : IDisposable
    {
        readonly IServiceProvider provider;
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<SocketTcpServer> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<SocketTcpClient> client;

        // request-response
        int messageId = 0;
        ConcurrentDictionary<int, TaskCompletionSource<IInterprocessValue>> responseCompletions = new ConcurrentDictionary<int, TaskCompletionSource<IInterprocessValue>>();

        // create from DI
        [Preserve]
        public TcpWorker(IServiceProvider provider, MessagePipeInterprocessTcpOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketTcpServer>(() =>
            {
                return SocketTcpServer.Listen(options.Host, options.Port);
            });

            this.client = new Lazy<SocketTcpClient>(() =>
            {
                return SocketTcpClient.Connect(options.Host, options.Port);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public TcpWorker(IServiceProvider provider, MessagePipeInterprocessTcpUdsOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketTcpServer>(() =>
            {
                return SocketTcpServer.ListenUds(options.SocketPath);
            });

            this.client = new Lazy<SocketTcpClient>(() =>
            {
                return SocketTcpClient.ConnectUds(options.SocketPath);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }
#endif
        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        public async ValueTask<TResponse> RequestAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var mid = Interlocked.Increment(ref messageId);
            var tcs = new TaskCompletionSource<IInterprocessValue>();
            responseCompletions[mid] = tcs;
            var buffer = MessageBuilder.BuildRemoteRequestMessage(typeof(TRequest), typeof(TResponse), mid, request, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
            var memoryValue = await tcs.Task.ConfigureAwait(false);
            return MessagePackSerializer.Deserialize<TResponse>(memoryValue.ValueMemory, options.MessagePackSerializerOptions);
        }

        // Send packet to tcp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var tcpClient = client.Value;
            RunReceiveLoop(tcpClient); // also setup receive loop

            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await tcpClient.SendAsync(item, token).ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                var s = server.Value; // init
                s.StartAcceptLoopAsync(RunReceiveLoop, cancellationTokenSource.Token);
            }
        }

        // Receive from tcp socket and push value to subscribers.
        async void RunReceiveLoop(SocketTcpClient client)
        {
            var token = cancellationTokenSource.Token;
            var buffer = new byte[65536];
            ReadOnlyMemory<byte> readBuffer = Array.Empty<byte>();
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value = Array.Empty<byte>();
                try
                {
                    if (readBuffer.Length == 0)
                    {
                        var readLen = await client.ReceiveAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                        if (readLen == 0) return; // end of stream(disconnect)
                        readBuffer = buffer.AsMemory(0, readLen);
                    }
                    else if (readBuffer.Length < 4) // rare case
                    {
                        var readLen = await client.ReceiveAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                        if (readLen == 0) return;
                        var newBuffer = new byte[readBuffer.Length + readLen];
                        readBuffer.CopyTo(newBuffer);
                        buffer.AsSpan(readLen).CopyTo(newBuffer.AsSpan(readBuffer.Length));
                        readBuffer = newBuffer;
                    }

                    var messageLen = MessageBuilder.FetchMessageLength(readBuffer.Span);
                    if (readBuffer.Length == (messageLen + 4)) // just size
                    {
                        value = readBuffer.Slice(4, messageLen); // skip length header
                        readBuffer = Array.Empty<byte>();
                        goto PARSE_MESSAGE;
                    }
                    else if (readBuffer.Length > (messageLen + 4)) // over size
                    {
                        value = readBuffer.Slice(4, messageLen);
                        readBuffer = readBuffer.Slice(messageLen + 4);
                        goto PARSE_MESSAGE;
                    }
                    else // needs to read more
                    {
                        var readLen = readBuffer.Length;
                        if (readLen < (messageLen + 4))
                        {
                            if (readBuffer.Length != buffer.Length)
                            {
                                var newBuffer = new byte[buffer.Length];
                                readBuffer.CopyTo(newBuffer);
                                buffer = newBuffer;
                            }

                            if (buffer.Length < messageLen + 4)
                            {
                                Array.Resize(ref buffer, messageLen + 4);
                            }
                        }
                        var remain = messageLen - (readLen - 4);
                        await ReadFullyAsync(buffer, client, readLen, remain, token).ConfigureAwait(false);
                        value = buffer.AsMemory(4, messageLen);
                        readBuffer = Array.Empty<byte>();
                        goto PARSE_MESSAGE;
                    }
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }
            PARSE_MESSAGE:
                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray()); // can avoid copy?
                    switch (message.MessageType)
                    {
                        case MessageType.PubSub:
                            publisher.Publish(message, message, CancellationToken.None);
                            break;
                        case MessageType.RemoteRequest:
                            {
                                // NOTE: should use without reflection(Expression.Compile)
                                var header = Deserialize<RequestHeader>(message.KeyMemory, options.MessagePackSerializerOptions);
                                var (mid, reqTypeName, resTypeName) = (header.MessageId, header.RequestType, header.ResponseType);
                                byte[] resultBytes;
                                try
                                {
                                    var t = AsyncRequestHandlerRegistory.Get(reqTypeName, resTypeName);
                                    var interfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandler"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var coreInterfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var service = provider.GetRequiredService(interfaceType); // IAsyncRequestHandler<TRequest,TResponse>
                                    var genericArgs = interfaceType.GetGenericArguments(); // [TRequest, TResponse]
                                    // Unity IL2CPP does not work(can not invoke nongenerics MessagePackSerializer)
                                    var request = MessagePackSerializer.Deserialize(genericArgs[0], message.ValueMemory, options.MessagePackSerializerOptions);
                                    var responseTask = coreInterfaceType.GetMethod("InvokeAsync")!.Invoke(service, new[] { request, CancellationToken.None });
#if !UNITY_2018_3_OR_NEWER
                                    var task = typeof(ValueTask<>).MakeGenericType(genericArgs[1]).GetMethod("AsTask")!.Invoke(responseTask, null);
#else
                                    var asTask = typeof(UniTaskExtensions).GetMethods().First(x => x.IsGenericMethod && x.Name == "AsTask")
                                        .MakeGenericMethod(genericArgs[1]);
                                    var task = asTask.Invoke(null, new[] { responseTask });
#endif
                                    await ((System.Threading.Tasks.Task)task!); // Task<T> -> Task
                                    var result = task.GetType().GetProperty("Result")!.GetValue(task);
                                    resultBytes = MessageBuilder.BuildRemoteResponseMessage(mid, genericArgs[1], result!, options.MessagePackSerializerOptions);
                                }
                                catch (Exception ex)
                                {
                                    // NOTE: ok to send stacktrace?
                                    resultBytes = MessageBuilder.BuildRemoteResponseError(mid, ex.ToString(), options.MessagePackSerializerOptions);
                                }

                                await client.SendAsync(resultBytes).ConfigureAwait(false);
                            }
                            break;
                        case MessageType.RemoteResponse:
                        case MessageType.RemoteError:
                            {
                                var mid = Deserialize<int>(message.KeyMemory, options.MessagePackSerializerOptions);
                                if (responseCompletions.TryRemove(mid, out var tcs))
                                {
                                    if (message.MessageType == MessageType.RemoteResponse)
                                    {
                                        tcs.TrySetResult(message); // synchronous completion, use memory buffer immediately.
                                    }
                                    else
                                    {
                                        var errorMsg = MessagePackSerializer.Deserialize<string>(message.ValueMemory, options.MessagePackSerializerOptions);
                                        tcs.TrySetException(new RemoteRequestException(errorMsg));
                                    }
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) continue;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        // omajinai.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options)
        {
            if (buffer.IsEmpty && MemoryMarshal.TryGetArray(buffer, out var segment))
            {
                buffer = segment;
            }
            return MessagePackSerializer.Deserialize<T>(buffer, options);
        }

        static async ValueTask ReadFullyAsync(byte[] buffer, SocketTcpClient client, int index, int remain, CancellationToken token)
        {
            while (remain > 0)
            {
                var len = await client.ReceiveAsync(buffer, index, remain, token).ConfigureAwait(false);
                index += len;
                remain -= len;
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Interprocess/Workers/UdpWorker.cs
================================================
﻿using MessagePipe.Interprocess.Internal;
using System;
using System.Threading;
#if !UNITY_2018_3_OR_NEWER
using System.Threading.Channels;
#else
using Cysharp.Threading.Tasks;
#endif

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class UdpWorker : IDisposable
    {
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<SocketUdpServer> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<SocketUdpClient> client;

        // create from DI
        [Preserve]
        public UdpWorker(MessagePipeInterprocessUdpOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketUdpServer>(() =>
            {
                return SocketUdpServer.Bind(options.Port, 0x10000);
            });

            this.client = new Lazy<SocketUdpClient>(() =>
            {
                return SocketUdpClient.Connect(options.Host, options.Port, 0x10000);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public UdpWorker(MessagePipeInterprocessUdpUdsOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketUdpServer>(() =>
            {
                return SocketUdpServer.BindUds(options.SocketPath, 0x10000);
            });

            this.client = new Lazy<SocketUdpClient>(() =>
            {
                return SocketUdpClient.ConnectUds(options.SocketPath, 0x10000);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif
        }
#endif
        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        // Send packet to udp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var udpClient = client.Value;
            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await udpClient.SendAsync(item, token).ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                _ = server.Value; // init
                RunReceiveLoop();
            }
        }

        // Receive from udp socket and push value to subscribers.
        async void RunReceiveLoop()
        {
            var token = cancellationTokenSource.Token;
            var udpServer = server.Value;
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value;
                try
                {
                    value = await udpServer.ReceiveAsync(token).ConfigureAwait(false);
                    if (value.Length == 0) return; // invalid data?
                    var len = MessageBuilder.FetchMessageLength(value.Span);
                    if (len != value.Length - 4)
                    {
                        throw new InvalidOperationException("Receive invalid message size.");
                    }
                    value = value.Slice(4);
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }

                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray());
                    publisher.Publish(message, message, CancellationToken.None);
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Nats/MessagePipe.Nats.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <!-- NuGet Packaging -->
    <PackageTags>pubsub;eventaggregator</PackageTags>
    <Description>Nats IDistributedPublisher/Subscriber provider for MessagePipe.</Description>
    <SignAssembly>true</SignAssembly>
    <IsPackable>true</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <None Include="Icon.png" Pack="true" PackagePath="/" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="AlterNats" Version="1.0.0" />
    <PackageReference Include="MessagePack" Version="3.1.4" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MessagePipe\MessagePipe.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: src/MessagePipe.Nats/MessagePipeNatsOptions.cs
================================================
﻿namespace MessagePipe.Nats;

public sealed class MessagePipeNatsOptions
{
    public NatsConnectionFactory NatsConnectionFactory { get; }

    public MessagePipeNatsOptions(NatsConnectionFactory connectionFactory)
    {
        NatsConnectionFactory = connectionFactory;
    }
}


================================================
FILE: src/MessagePipe.Nats/NatsConnectionFactory.cs
================================================
﻿using AlterNats;

namespace MessagePipe.Nats;

public class NatsConnectionFactory
{
    readonly NatsOptions options;
    NatsConnection? connection;

    public NatsConnectionFactory() : this(NatsOptions.Default) { }

    public NatsConnectionFactory(NatsOptions options)
    {
        this.options = options;
    }

    public async ValueTask<NatsConnection> GetConnectionAsync()
    {
        connection ??= new NatsConnection(options);

        if (connection.ConnectionState == NatsConnectionState.Closed)
        {
            await connection.ConnectAsync();
        }

        return connection;
    }
}


================================================
FILE: src/MessagePipe.Nats/NatsPublisher.cs
================================================
﻿using AlterNats;

namespace MessagePipe.Nats;

public sealed class NatsPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
{
    readonly NatsConnectionFactory connectionFactory;

    public NatsPublisher(
        NatsConnectionFactory connectionFactory)
    {
        this.connectionFactory = connectionFactory;
    }

    public async ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = new CancellationToken())
    {
        var natsKey = GetNatsKey(key);

        if (natsKey == null) throw new ArgumentNullException(nameof(key));

        var connection = await connectionFactory.GetConnectionAsync();
        await connection.PublishAsync(natsKey.Value, message);
    }

    NatsKey? GetNatsKey(TKey key)
    {
        switch (key)
        {
            case NatsKey natsKey:
                return natsKey;
            case string s:
                return new NatsKey(s);
            default:
                var k = key?.ToString();
                return k != null ? new NatsKey(k) : null;
        }
    }
}


================================================
FILE: src/MessagePipe.Nats/NatsSubscriber.cs
================================================
﻿using AlterNats;

namespace MessagePipe.Nats;

public sealed class NatsSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
{
    readonly NatsConnectionFactory connectionFactory;
    readonly FilterAttachedMessageHandlerFactory messageHandlerFactory;
    readonly FilterAttachedAsyncMessageHandlerFactory asyncMessageHandlerFactory;

    public NatsSubscriber(
        NatsConnectionFactory connectionFactory,
        FilterAttachedMessageHandlerFactory messageHandlerFactory,
        FilterAttachedAsyncMessageHandlerFactory asyncMessageHandlerFactory)
    {
        this.connectionFactory = connectionFactory;
        this.messageHandlerFactory = messageHandlerFactory;
        this.asyncMessageHandlerFactory = asyncMessageHandlerFactory;
    }

    public ValueTask<IAsyncDisposable> SubscribeAsync(
        TKey key,
        IMessageHandler<TMessage> handler,
        CancellationToken cancellationToken = new())
    {
        return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
    }

    public async ValueTask<IAsyncDisposable> SubscribeAsync(
        TKey key,
        IMessageHandler<TMessage> handler,
        MessageHandlerFilter<TMessage>[] filters,
        CancellationToken cancellationToken = new())
    {
        var subject = GetSubjectString(key);

        if (subject == null) throw new ArgumentException(nameof(key));

        handler = messageHandlerFactory.CreateMessageHandler(handler, filters); // with filter

        var connection = await connectionFactory.GetConnectionAsync();

        var s = await connection.SubscribeAsync<TMessage>(subject, data =>
        {
            handler.Handle(data);
        });

        return new Subscription(s);
    }

    public ValueTask<IAsyncDisposable> SubscribeAsync(
        TKey key,
        IAsyncMessageHandler<TMessage> handler,
        CancellationToken cancellationToken = new())
    {
        return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
    }

    public async ValueTask<IAsyncDisposable> SubscribeAsync(
        TKey key,
        IAsyncMessageHandler<TMessage> handler,
        AsyncMessageHandlerFilter<TMessage>[] filters,
        CancellationToken cancellationToken = new())
    {
        var subject = GetSubjectString(key);

        if (subject == null) throw new ArgumentException(nameof(key));

        handler = asyncMessageHandlerFactory.CreateAsyncMessageHandler(handler, filters); // with filter

        var connection = await connectionFactory.GetConnectionAsync();

        var s = await connection.SubscribeAsync<TMessage>(subject, async data =>
        {
            await handler.HandleAsync(data, CancellationToken.None).ConfigureAwait(false);
        });

        return new Subscription(s);
    }

    sealed class Subscription : IAsyncDisposable
    {
        readonly IDisposable disposable;

        public Subscription(IDisposable disposable)
        {
            this.disposable = disposable;
        }

        public ValueTask DisposeAsync()
        {
            disposable.Dispose();

            return ValueTask.CompletedTask;
        }
    }

    string? GetSubjectString(TKey key)
    {
        switch (key)
        {
            case NatsKey natsKey:
                return natsKey.Key;
            case string s:
                return s;
            default:
                return key?.ToString();
        }
    }
}


================================================
FILE: src/MessagePipe.Nats/ServiceCollectionNatsExtensions.cs
================================================
﻿
using MessagePipe;
using MessagePipe.Nats;

namespace Microsoft.Extensions.DependencyInjection;

public static class ServiceCollectionNatsExtensions
{
    public static IMessagePipeBuilder AddNats(this IMessagePipeBuilder builder, NatsConnectionFactory connectionFactory)
    {
        return AddNats(builder, connectionFactory, _ => { });
    }

    public static IMessagePipeBuilder AddNats(this IMessagePipeBuilder builder, NatsConnectionFactory connectionFactory, Action<MessagePipeNatsOptions> configure)
    {
        var options = new MessagePipeNatsOptions(connectionFactory);
        configure(options);
        builder.Services.AddSingleton(options);
        builder.Services.AddSingleton(options.NatsConnectionFactory);

        builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(NatsPublisher<,>), InstanceLifetime.Singleton);
        builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(NatsSubscriber<,>), InstanceLifetime.Singleton);

        return builder;
    }

    static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime scope)
    {
        var lifetime = (scope == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
            : (scope == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
            : ServiceLifetime.Transient;
        services.Add(new ServiceDescriptor(serviceType, implementationType, lifetime));
    }
}


================================================
FILE: src/MessagePipe.Redis/MessagePackRedisSerializer.cs
================================================
﻿using MessagePack;
using MessagePack.Resolvers;

namespace MessagePipe.Redis
{
    public sealed class MessagePackRedisSerializer : IRedisSerializer
    {
        readonly MessagePackSerializerOptions options;

        public MessagePackRedisSerializer()
        {
            options = ContractlessStandardResolver.Options;
        }

        public MessagePackRedisSerializer(MessagePackSerializerOptions options)
        {
            this.options = options;
        }

        public byte[] Serialize<T>(T value)
        {
            if (value is byte[] xs) return xs;
            return MessagePackSerializer.Serialize<T>(value, options);
        }

        public T Deserialize<T>(byte[] value)
        {
            return MessagePackSerializer.Deserialize<T>(value, options);
        }
    }
}


================================================
FILE: src/MessagePipe.Redis/MessagePipe.Redis.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net6.0</TargetFrameworks>
    <Configurations>Debug;Release;WinBenchmark</Configurations>

    <!-- NuGet Packaging -->
    <PackageTags>pubsub;eventaggregator</PackageTags>
    <Description>Redis IDistributedPublisher/Subscriber provider for MessagePipe.</Description>
    <SignAssembly>true</SignAssembly>
    <IsPackable>true</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <None Include="Icon.png" Pack="true" PackagePath="/" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="MessagePack" Version="3.1.4" />
    <PackageReference Include="StackExchange.Redis" Version="2.5.61" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MessagePipe\MessagePipe.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: src/MessagePipe.Redis/MessagePipeRedisOptions.cs
================================================
﻿using StackExchange.Redis;

namespace MessagePipe.Redis
{
    public interface IRedisSerializer
    {
        byte[] Serialize<T>(T value);
        T Deserialize<T>(byte[] value);
    }

    public interface IConnectionMultiplexerFactory
    {
        public IConnectionMultiplexer GetConnectionMultiplexer<TKey>(TKey key);
    }

    public sealed class MessagePipeRedisOptions
    {
        public IRedisSerializer RedisSerializer { get; set; }

        public MessagePipeRedisOptions()
        {
            this.RedisSerializer = new MessagePackRedisSerializer();
        }
    }
}


================================================
FILE: src/MessagePipe.Redis/RedisPubSub.cs
================================================
﻿using StackExchange.Redis;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePipe.Redis
{
    public sealed class RedisPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly IRedisSerializer serializer;
        readonly IConnectionMultiplexerFactory connectionFactory;

        public RedisPublisher(IConnectionMultiplexerFactory connectionFactory, IRedisSerializer serializer)
        {
            this.connectionFactory = connectionFactory;
            this.serializer = serializer;
        }

        public async ValueTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            var channel = CreateChannel(key);
            var value = serializer.Serialize(message);

            // Redis.PublishAsync has no cancellationToken overload.
            await connectionFactory.GetConnectionMultiplexer(key).GetSubscriber().PublishAsync(channel, value).ConfigureAwait(false);
        }

        RedisChannel CreateChannel(TKey key)
        {
            switch (key)
            {
                case string s:
                    return new RedisChannel(s, RedisChannel.PatternMode.Auto); // use Auto.
                case byte[] v:
                    return new RedisChannel(v, RedisChannel.PatternMode.Auto);
                default:
                    return new RedisChannel(serializer.Serialize(key), RedisChannel.PatternMode.Literal);
            }
        }
    }

    public sealed class RedisSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        IRedisSerializer serializer;
        readonly IConnectionMultiplexerFactory connectionFactory;
        readonly FilterAttachedMessageHandlerFactory messageHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncMessageHandlerFactory;

        public RedisSubscriber(IConnectionMultiplexerFactory connectionFactory, IRedisSerializer serializer, FilterAttachedMessageHandlerFactory messageHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncMessageHandlerFactory)
        {
            this.connectionFactory = connectionFactory;
            this.serializer = serializer;
            this.messageHandlerFactory = messageHandlerFactory;
            this.asyncMessageHandlerFactory = asyncMessageHandlerFactory;
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public async ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken)
        {
            handler = messageHandlerFactory.CreateMessageHandler(handler, filters); // with filter

            var channel = CreateChannel(key);

            var mq = await connectionFactory.GetConnectionMultiplexer(key).GetSubscriber().SubscribeAsync(channel).ConfigureAwait(false);
            mq.OnMessage(message =>
            {
                var v = serializer.Deserialize<TMessage>((byte[])message.Message);
                handler.Handle(v);
            });

            return new Subscription(mq);
        }

        public ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public async ValueTask<IAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken)
        {
            handler = asyncMessageHandlerFactory.CreateAsyncMessageHandler(handler, filters); // with filter

            var channel = CreateChannel(key);

            var mq = await connectionFactory.GetConnectionMultiplexer(key).GetSubscriber().SubscribeAsync(channel).ConfigureAwait(false);
            mq.OnMessage(async message =>
            {
                var v = serializer.Deserialize<TMessage>((byte[])message.Message);
                await handler.HandleAsync(v, CancellationToken.None).ConfigureAwait(false);
            });

            return new Subscription(mq);
        }

        RedisChannel CreateChannel(TKey key)
        {
            switch (key)
            {
                case string s:
                    return new RedisChannel(s, RedisChannel.PatternMode.Auto); // use Auto.
                case byte[] v:
                    return new RedisChannel(v, RedisChannel.PatternMode.Auto);
                default:
                    return new RedisChannel(serializer.Serialize(key), RedisChannel.PatternMode.Literal);
            }
        }

        sealed class Subscription : IAsyncDisposable
        {
            readonly ChannelMessageQueue mq;

            public Subscription(ChannelMessageQueue mq)
            {
                this.mq = mq;
            }

            public async ValueTask DisposeAsync()
            {
                await mq.UnsubscribeAsync();
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Redis/ServiceCollectionRedisExtensions.cs
================================================
﻿using MessagePipe;
using MessagePipe.Redis;
using StackExchange.Redis;
using System;
using System.Collections.Generic;
using System.Text;

namespace Microsoft.Extensions.DependencyInjection
{
    public static class ServiceCollectionRedisExtensions
    {
        public static IMessagePipeBuilder AddRedis(this IMessagePipeBuilder builder, IConnectionMultiplexer connectionMultiplexer)
        {
            return AddRedis(builder, new SingleConnectionMultiplexerFactory(connectionMultiplexer), _ => { });
        }

        public static IMessagePipeBuilder AddRedis(this IMessagePipeBuilder builder, IConnectionMultiplexerFactory connectionMultiplexerFactory)
        {
            return AddRedis(builder, connectionMultiplexerFactory, _ => { });
        }

        public static IMessagePipeBuilder AddRedis<T>(this IMessagePipeBuilder builder)
            where T : class, IConnectionMultiplexerFactory
        {
            return AddRedis<T>(builder, _ => { });
        }

        public static IMessagePipeBuilder AddRedis<T>(this IMessagePipeBuilder builder, Action<MessagePipeRedisOptions> configure)
            where T : class, IConnectionMultiplexerFactory
        {
            return AddRedis(builder, ServiceDescriptor.Singleton<IConnectionMultiplexerFactory, T>(), configure);
        }

        public static IMessagePipeBuilder AddRedis(this IMessagePipeBuilder builder, IConnectionMultiplexer connectionMultiplexer, Action<MessagePipeRedisOptions> configure)
        {
            return AddRedis(builder, new SingleConnectionMultiplexerFactory(connectionMultiplexer), configure);
        }

        public static IMessagePipeBuilder AddRedis(this IMessagePipeBuilder builder, IConnectionMultiplexerFactory connectionMultiplexerFactory, Action<MessagePipeRedisOptions> configure)
        {
            return AddRedis(builder, ServiceDescriptor.Singleton(connectionMultiplexerFactory), configure);
        }

        static IMessagePipeBuilder AddRedis(IMessagePipeBuilder builder, ServiceDescriptor connectionMultiplexerServiceDesc, Action<MessagePipeRedisOptions> configure)
        {
            var options = new MessagePipeRedisOptions();
            configure(options);
            builder.Services.AddSingleton(options); // add as singleton instance
            builder.Services.Add(connectionMultiplexerServiceDesc);
            builder.Services.AddSingleton<IRedisSerializer>(options.RedisSerializer);

            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(RedisPublisher<,>), InstanceLifetime.Singleton);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(RedisSubscriber<,>), InstanceLifetime.Singleton);

            return builder;
        }

        static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime scope)
        {
            var lifetime = (scope == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                : (scope == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                : ServiceLifetime.Transient;
            services.Add(new ServiceDescriptor(serviceType, implementationType, lifetime));
        }
    }
}



================================================
FILE: src/MessagePipe.Redis/SingleConnectionMultiplexerFactory.cs
================================================
﻿using StackExchange.Redis;

namespace MessagePipe.Redis
{
    internal sealed class SingleConnectionMultiplexerFactory : IConnectionMultiplexerFactory
    {
        readonly IConnectionMultiplexer connectionMultiplexer;

        public SingleConnectionMultiplexerFactory(IConnectionMultiplexer connectionMultiplexer)
        {
            this.connectionMultiplexer = connectionMultiplexer;
        }

        public IConnectionMultiplexer GetConnectionMultiplexer<TKey>(TKey key)
        {
            return connectionMultiplexer;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Editor.meta
================================================
fileFormatVersion: 2
guid: aa25edf82eacad640944402a9a9c43e8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/InitTestScene637547097397462845.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!114 &439950893
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: f3e1b3cbf3fac6a459b1a602167ad311, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!114 &840896148
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: d44e6804bc58be84ea71a619b468f150, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!114 &1296256394
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 68f09f0f82599b5448579854e622a4c1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!1 &1980682887
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1980682890}
  - component: {fileID: 1980682889}
  - component: {fileID: 1980682888}
  m_Layer: 0
  m_Name: Code-based tests runner
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &1980682888
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1980682887}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3cf5cb9e1ef590c48b1f919f2a7bd895, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!114 &1980682889
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1980682887}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 102e512f651ee834f951a2516c1ea3b8, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_AssembliesWithTests:
  - RuntimeUnitTestToolkit
  - Tests
  - UnityEngine.TestRunner
  testStartedEvent:
    m_PersistentCalls:
      m_Calls:
      - m_Target: {fileID: 1980682888}
        m_TargetAssemblyTypeName: UnityEngine.TestTools.TestRunner.Callbacks.PlayModeRunnerCallback,
          UnityEngine.TestRunner
        m_MethodName: TestStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 840896148}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.TestRunnerCallback,
          UnityEditor.TestRunner
        m_MethodName: TestStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 439950893}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.Api.CallbacksDelegatorListener,
          UnityEditor.TestRunner
        m_MethodName: TestStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 1296256394}
        m_TargetAssemblyTypeName: UnityEngine.TestRunner.Utils.TestRunCallbackListener,
          UnityEngine.TestRunner
        m_MethodName: TestStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
  testFinishedEvent:
    m_PersistentCalls:
      m_Calls:
      - m_Target: {fileID: 1980682888}
        m_TargetAssemblyTypeName: UnityEngine.TestTools.TestRunner.Callbacks.PlayModeRunnerCallback,
          UnityEngine.TestRunner
        m_MethodName: TestFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 840896148}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.TestRunnerCallback,
          UnityEditor.TestRunner
        m_MethodName: TestFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 439950893}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.Api.CallbacksDelegatorListener,
          UnityEditor.TestRunner
        m_MethodName: TestFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 1296256394}
        m_TargetAssemblyTypeName: UnityEngine.TestRunner.Utils.TestRunCallbackListener,
          UnityEngine.TestRunner
        m_MethodName: TestFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
  runStartedEvent:
    m_PersistentCalls:
      m_Calls:
      - m_Target: {fileID: 1980682888}
        m_TargetAssemblyTypeName: UnityEngine.TestTools.TestRunner.Callbacks.PlayModeRunnerCallback,
          UnityEngine.TestRunner
        m_MethodName: RunStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 840896148}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.TestRunnerCallback,
          UnityEditor.TestRunner
        m_MethodName: RunStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 439950893}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.Api.CallbacksDelegatorListener,
          UnityEditor.TestRunner
        m_MethodName: RunStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 1296256394}
        m_TargetAssemblyTypeName: UnityEngine.TestRunner.Utils.TestRunCallbackListener,
          UnityEngine.TestRunner
        m_MethodName: RunStarted
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
  runFinishedEvent:
    m_PersistentCalls:
      m_Calls:
      - m_Target: {fileID: 1980682888}
        m_TargetAssemblyTypeName: UnityEngine.TestTools.TestRunner.Callbacks.PlayModeRunnerCallback,
          UnityEngine.TestRunner
        m_MethodName: RunFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 840896148}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.TestRunnerCallback,
          UnityEditor.TestRunner
        m_MethodName: RunFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 439950893}
        m_TargetAssemblyTypeName: UnityEditor.TestTools.TestRunner.Api.CallbacksDelegatorListener,
          UnityEditor.TestRunner
        m_MethodName: RunFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
      - m_Target: {fileID: 1296256394}
        m_TargetAssemblyTypeName: UnityEngine.TestRunner.Utils.TestRunCallbackListener,
          UnityEngine.TestRunner
        m_MethodName: RunFinished
        m_Mode: 0
        m_Arguments:
          m_ObjectArgument: {fileID: 0}
          m_ObjectArgumentAssemblyTypeName: 
          m_IntArgument: 0
          m_FloatArgument: 0
          m_StringArgument: 
          m_BoolArgument: 0
        m_CallState: 2
  settings:
    filters:
    - assemblyNames: []
      groupNames: []
      categoryNames: []
      testNames: []
      synchronousOnly: 0
    sceneBased: 0
    originalScene: 
    bootstrapScene: Assets/InitTestScene637547097397462845.unity
--- !u!4 &1980682890
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1980682887}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}



================================================
FILE: src/MessagePipe.Unity/Assets/InitTestScene637547097397462845.unity.meta
================================================
fileFormatVersion: 2
guid: 20f2916dc3c05014e8a70a8a7eb5a314
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins.meta
================================================
fileFormatVersion: 2
guid: cd1b737b914de1d4bb683956adec068b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scenes.meta
================================================
fileFormatVersion: 2
guid: 8eb00c9ac877fb24dafbd37b07d6705e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts.meta
================================================
fileFormatVersion: 2
guid: f451de971cb3f754abe9a42160b96d46
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests.meta
================================================
fileFormatVersion: 2
guid: f32e3ea5afbf6ac4198ddec0af8d49a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Editor/PackageExporter.cs
================================================
﻿#if UNITY_EDITOR

using System;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

public static class PackageExporter
{
    [MenuItem("Tools/Export Unitypackage")]
    public static void Export()
    {
        var roots = new[] { "Plugins/MessagePipe", "Plugins/MessagePipe.VContainer", "Plugins/MessagePipe.Zenject", "Plugins/MessagePipe.Interprocess" };

        foreach (var root in roots)
        {
            var version = GetVersion(root);
            var fn = root.Split('/').Last();

            var fileName = string.IsNullOrEmpty(version) ? $"{fn}.unitypackage" : $"{fn}.{version}.unitypackage";
            var exportPath = "./" + fileName;

            var path = Path.Combine(Application.dataPath, root);
            var assets = Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories)
                .Where(x => Path.GetExtension(x) == ".cs" || Path.GetExtension(x) == ".asmdef" || Path.GetExtension(x) == ".json" || Path.GetExtension(x) == ".meta")
                .Select(x => "Assets" + x.Replace(Application.dataPath, "").Replace(@"\", "/"))
                .ToArray();

            UnityEngine.Debug.Log("Export below files" + Environment.NewLine + string.Join(Environment.NewLine, assets));

            AssetDatabase.ExportPackage(
                assets,
                exportPath,
                ExportPackageOptions.Default);

            UnityEngine.Debug.Log("Export complete: " + Path.GetFullPath(exportPath));
        }
    }

    static string GetVersion(string root)
    {
        var version = Environment.GetEnvironmentVariable("UNITY_PACKAGE_VERSION");
        var versionJson = Path.Combine(Application.dataPath, root, "package.json");

        if (File.Exists(versionJson))
        {
            var v = JsonUtility.FromJson<Version>(File.ReadAllText(versionJson));

            if (!string.IsNullOrEmpty(version))
            {
                if (v.version != version)
                {
                    var msg = $"package.json and env version are mismatched. UNITY_PACKAGE_VERSION:{version}, package.json:{v.version}";

                    if (Application.isBatchMode)
                    {
                        Console.WriteLine(msg);
                        Application.Quit(1);
                    }

                    throw new Exception("package.json and env version are mismatched.");
                }
            }

            version = v.version;
        }

        return version;
    }

    public class Version
    {
        public string version;
    }
}

#endif


================================================
FILE: src/MessagePipe.Unity/Assets/Editor/PackageExporter.cs.meta
================================================
fileFormatVersion: 2
guid: 34885e00b06e4c847b8e2958ebb2d26b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess.meta
================================================
fileFormatVersion: 2
guid: d0c51f37d170e034f946f5da62a4f8e1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.meta
================================================
fileFormatVersion: 2
guid: f712d78263274134c8498b41c55605e2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer.meta
================================================
fileFormatVersion: 2
guid: db681da2e7852764182cc952d6246695
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject.meta
================================================
fileFormatVersion: 2
guid: ef9f739bcb1497144b332a4724ffa4d6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/System.Buffers.dll.meta
================================================
fileFormatVersion: 2
guid: 80babde185fa5f5f58e1c7c451054bf5
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/System.Memory.dll.meta
================================================
fileFormatVersion: 2
guid: 00334fc99a0c324ce9667086377aec59
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/System.Runtime.CompilerServices.Unsafe.dll.meta
================================================
fileFormatVersion: 2
guid: 9faef98abc153627f8af30123e43611c
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/System.Threading.Tasks.Extensions.dll.meta
================================================
fileFormatVersion: 2
guid: a16c98699003c0ef58a75e0c61ff420b
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject.meta
================================================
fileFormatVersion: 2
guid: af4a638e5db9d8649a981064d9f7a50c
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor.meta
================================================
fileFormatVersion: 2
guid: 88252c2ba4ae5154d8da30b27304e8dc
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/package.json
================================================
{
    "name": "com.cysharp.messagepipe",
    "displayName": "MessagePipe",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.8.1",
    "unity": "2018.4",
    "description": "High performance messaging pipeline.",
    "keywords": [ "pubsub", "event", "Scripting", "DI" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/package.json.meta
================================================
fileFormatVersion: 2
guid: 9a9f4bdf8524db740a6d7803b36704d5
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime.meta
================================================
fileFormatVersion: 2
guid: 17409b10561aad44f86d6c9e0ad09c93
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/DiagnosticsHelper.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using Cysharp.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using UnityEngine;

namespace MessagePipe.Editor
{
    internal static class DiagnosticsExtensions
    {
        static bool displayFilenames = true;

        static readonly Regex typeBeautifyRegex = new Regex("`.+$", RegexOptions.Compiled);

        static readonly Dictionary<Type, string> builtInTypeNames = new Dictionary<Type, string>
        {
            { typeof(void), "void" },
            { typeof(bool), "bool" },
            { typeof(byte), "byte" },
            { typeof(char), "char" },
            { typeof(decimal), "decimal" },
            { typeof(double), "double" },
            { typeof(float), "float" },
            { typeof(int), "int" },
            { typeof(long), "long" },
            { typeof(object), "object" },
            { typeof(sbyte), "sbyte" },
            { typeof(short), "short" },
            { typeof(string), "string" },
            { typeof(uint), "uint" },
            { typeof(ulong), "ulong" },
            { typeof(ushort), "ushort" },
            { typeof(Task), "Task" },
            { typeof(UniTask), "UniTask" },
            { typeof(UniTaskVoid), "UniTaskVoid" }
        };

        public static string CleanupAsyncStackTrace(this StackTrace stackTrace)
        {
            if (stackTrace == null) return "";

            var sb = new StringBuilder();
            for (int i = 0; i < stackTrace.FrameCount; i++)
            {
                var sf = stackTrace.GetFrame(i);

                var mb = sf.GetMethod();

                if (IgnoreLine(mb)) continue;
                if (IsAsync(mb))
                {
                    sb.Append("async ");
                    TryResolveStateMachineMethod(ref mb, out var decType);
                }

                // return type
                if (mb is MethodInfo mi)
                {
                    sb.Append(BeautifyType(mi.ReturnType, false));
                    sb.Append(" ");
                }

                // method name
                sb.Append(BeautifyType(mb.DeclaringType, false));
                if (!mb.IsConstructor)
                {
                    sb.Append(".");
                }
                sb.Append(mb.Name);
                if (mb.IsGenericMethod)
                {
                    sb.Append("<");
                    foreach (var item in mb.GetGenericArguments())
                    {
                        sb.Append(BeautifyType(item, true));
                    }
                    sb.Append(">");
                }

                // parameter
                sb.Append("(");
                sb.Append(string.Join(", ", mb.GetParameters().Select(p => BeautifyType(p.ParameterType, true) + " " + p.Name)));
                sb.Append(")");

                // file name
                if (displayFilenames && (sf.GetILOffset() != -1))
                {
                    String fileName = null;

                    try
                    {
                        fileName = sf.GetFileName();
                    }
                    catch (NotSupportedException)
                    {
                        displayFilenames = false;
                    }
                    catch (SecurityException)
                    {
                        displayFilenames = false;
                    }

                    if (fileName != null)
                    {
                        sb.Append(' ');
                        sb.AppendFormat(CultureInfo.InvariantCulture, "(at {0})", AppendHyperLink(fileName, sf.GetFileLineNumber().ToString()));
                    }
                }

                sb.AppendLine();
            }
            return sb.ToString();
        }


        static bool IsAsync(MethodBase methodInfo)
        {
            var declareType = methodInfo.DeclaringType;
            return typeof(IAsyncStateMachine).IsAssignableFrom(declareType);
        }

        // code from Ben.Demystifier/EnhancedStackTrace.Frame.cs
        static bool TryResolveStateMachineMethod(ref MethodBase method, out Type declaringType)
        {
            declaringType = method.DeclaringType;

            var parentType = declaringType.DeclaringType;
            if (parentType == null)
            {
                return false;
            }

            var methods = parentType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            if (methods == null)
            {
                return false;
            }

            foreach (var candidateMethod in methods)
            {
                var attributes = candidateMethod.GetCustomAttributes<StateMachineAttribute>();
                if (attributes == null)
                {
                    continue;
                }

                foreach (var asma in attributes)
                {
                    if (asma.StateMachineType == declaringType)
                    {
                        method = candidateMethod;
                        declaringType = candidateMethod.DeclaringType;
                        // Mark the iterator as changed; so it gets the + annotation of the original method
                        // async statemachines resolve directly to their builder methods so aren't marked as changed
                        return asma is IteratorStateMachineAttribute;
                    }
                }
            }

            return false;
        }

        static string BeautifyType(Type t, bool shortName)
        {
            if (builtInTypeNames.TryGetValue(t, out var builtin))
            {
                return builtin;
            }
            if (t.IsGenericParameter) return t.Name;
            if (t.IsArray) return BeautifyType(t.GetElementType(), shortName) + "[]";
            if (t.FullName?.StartsWith("System.ValueTuple") ?? false)
            {
                return "(" + string.Join(", ", t.GetGenericArguments().Select(x => BeautifyType(x, true))) + ")";
            }
            if (!t.IsGenericType) return shortName ? t.Name : t.FullName.Replace("Cysharp.Threading.Tasks.Triggers.", "").Replace("Cysharp.Threading.Tasks.Internal.", "").Replace("Cysharp.Threading.Tasks.", "") ?? t.Name;

            var innerFormat = string.Join(", ", t.GetGenericArguments().Select(x => BeautifyType(x, true)));

            var genericType = t.GetGenericTypeDefinition().FullName;
            if (genericType == "System.Threading.Tasks.Task`1")
            {
                genericType = "Task";
            }

            return typeBeautifyRegex.Replace(genericType, "").Replace("Cysharp.Threading.Tasks.Triggers.", "").Replace("Cysharp.Threading.Tasks.Internal.", "").Replace("Cysharp.Threading.Tasks.", "") + "<" + innerFormat + ">";
        }

        static bool IgnoreLine(MethodBase methodInfo)
        {
            var declareType = methodInfo.DeclaringType.FullName;
            if (declareType == "System.Threading.ExecutionContext")
            {
                return true;
            }
            else if (declareType.StartsWith("System.Runtime.CompilerServices"))
            {
                return true;
            }
            else if (declareType.StartsWith("Cysharp.Threading.Tasks.CompilerServices"))
            {
                return true;
            }
            else if (declareType == "System.Threading.Tasks.AwaitTaskContinuation")
            {
                return true;
            }
            else if (declareType.StartsWith("System.Threading.Tasks.Task"))
            {
                return true;
            }
            else if (declareType.StartsWith("Cysharp.Threading.Tasks.UniTaskCompletionSourceCore"))
            {
                return true;
            }
            else if (declareType.StartsWith("Cysharp.Threading.Tasks.AwaiterActions"))
            {
                return true;
            }
            else if (declareType.StartsWith("MessagePipe"))
            {
                return true;
            }

            return false;
        }

        static string AppendHyperLink(string path, string line)
        {
            var fi = new FileInfo(path);
            if (fi.Directory == null)
            {
                return fi.Name;
            }
            else
            {
                var fname = fi.FullName.Replace(Path.DirectorySeparatorChar, '/').Replace(Application.dataPath, "");
                if (Path.GetPathRoot(fname).Contains(":"))
                {
                    return fname + ":" + line; // without link outside of project dir
                }

                string withAssetsPath = null;
                if (fname.StartsWith("/"))
                {
                    withAssetsPath = "Assets" + fname;
                }
                else
                {
                    withAssetsPath = "Assets/" + fname;
                }
                return "<a href=\"" + withAssetsPath + "\" line=\"" + line + "\">" + withAssetsPath + ":" + line + "</a>";
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/DiagnosticsHelper.cs.meta
================================================
fileFormatVersion: 2
guid: 303a48117c1cf3f4f95d89cbc665c54c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipe.Editor.asmdef
================================================
{
    "name": "MessagePipe.Editor",
    "references": [
        "MessagePipe",
        "UniTask"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": false,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipe.Editor.asmdef.meta
================================================
fileFormatVersion: 2
guid: f87f2db4f7bec46409857b7e7a6938ff
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipeDiagnosticsInfoTreeView.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System;
using UnityEditor.IMGUI.Controls;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace MessagePipe.Editor
{
    public class MessagePipeDiagnosticsInfoTreeViewItem : TreeViewItem
    {
        static Regex removeHref = new Regex("<a href.+>(.+)</a>", RegexOptions.Compiled);

        public int Count { get; set; }
        public string Head { get; set; }
        public TimeSpan Elapsed { get; set; }
        public IEnumerable<StackTraceInfo> StackTraces { get; set; }

        public MessagePipeDiagnosticsInfoTreeViewItem(int id) : base(id)
        {

        }
    }

    public class MessagePipeDiagnosticsInfoTreeView : TreeView
    {
        const string sortedColumnIndexStateKey = "MessagePipeDiagnosticsInfoTreeView_sortedColumnIndex";

        public IReadOnlyList<TreeViewItem> CurrentBindingItems;
        Dictionary<string, int> usedTrackIds = new Dictionary<string, int>();
        int trackId = -10000; // 0~ is used in StackTraceInfo

        public MessagePipeDiagnosticsInfoTreeView()
            : this(new TreeViewState(), new MultiColumnHeader(new MultiColumnHeaderState(new[]
            {
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Position")},
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Elapsed"), width = 5 },
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Count"), width = 5},
            })))
        {
        }

        MessagePipeDiagnosticsInfoTreeView(TreeViewState state, MultiColumnHeader header)
            : base(state, header)
        {
            rowHeight = 20;
            showAlternatingRowBackgrounds = true;
            showBorder = true;
            header.sortingChanged += Header_sortingChanged;

            header.ResizeToFit();
            Reload();

            header.sortedColumnIndex = SessionState.GetInt(sortedColumnIndexStateKey, 1);
        }

        public void ReloadAndSort()
        {
            var currentSelected = this.state.selectedIDs;
            Reload();
            Header_sortingChanged(this.multiColumnHeader);
            this.state.selectedIDs = currentSelected;
        }

        private void Header_sortingChanged(MultiColumnHeader multiColumnHeader)
        {
            SessionState.SetInt(sortedColumnIndexStateKey, multiColumnHeader.sortedColumnIndex);
            var index = multiColumnHeader.sortedColumnIndex;
            var ascending = multiColumnHeader.IsSortedAscending(multiColumnHeader.sortedColumnIndex);

            var items = rootItem.children.Cast<MessagePipeDiagnosticsInfoTreeViewItem>();

            IOrderedEnumerable<MessagePipeDiagnosticsInfoTreeViewItem> orderedEnumerable;
            switch (index)
            {
                case 0:
                    orderedEnumerable = ascending ? items.OrderBy(item => item.Head) : items.OrderByDescending(item => item.Head);
                    break;
                case 1:
                    orderedEnumerable = ascending ? items.OrderBy(item => item.Elapsed) : items.OrderByDescending(item => item.Elapsed);
                    break;
                case 2:
                    orderedEnumerable = ascending ? items.OrderBy(item => item.Count) : items.OrderByDescending(item => item.Count);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(index), index, null);
            }

            CurrentBindingItems = rootItem.children = orderedEnumerable.Cast<TreeViewItem>().ToList();
            BuildRows(rootItem);
        }

        protected override TreeViewItem BuildRoot()
        {
            var root = new TreeViewItem { depth = -1 };

            var children = new List<TreeViewItem>();

            if (MessagePipeDiagnosticsInfoWindow.diagnosticsInfo != null)
            {
                var now = DateTimeOffset.UtcNow;
                if (MessagePipeDiagnosticsInfoWindow.EnableCollapse)
                {
                    var grouped = MessagePipeDiagnosticsInfoWindow.diagnosticsInfo.GetGroupedByCaller(false);
                    foreach (var item in grouped)
                    {
                        if (!usedTrackIds.TryGetValue(item.Key, out var id))
                        {
                            id = trackId++;
                            usedTrackIds[item.Key] = id;
                        }

                        var viewItem = new MessagePipeDiagnosticsInfoTreeViewItem(id)
                        {
                            Count = item.Count(),
                            Head = item.Key,
                            Elapsed = now - item.Last().Timestamp,
                            StackTraces = item
                        };
                        children.Add(viewItem);
                    }
                }
                else
                {
                    foreach (var item in MessagePipeDiagnosticsInfoWindow.diagnosticsInfo.GetCapturedStackTraces())
                    {
                        var viewItem = new MessagePipeDiagnosticsInfoTreeViewItem(item.Id)
                        {
                            Count = 1,
                            Head = item.Head,
                            Elapsed = now - item.Timestamp,
                            StackTraces = new[] { item }
                        };
                        children.Add(viewItem);
                    }
                }
            }

            CurrentBindingItems = children;
            root.children = CurrentBindingItems as List<TreeViewItem>;
            return root;
        }

        protected override bool CanMultiSelect(TreeViewItem item)
        {
            return false;
        }

        protected override void RowGUI(RowGUIArgs args)
        {
            var item = args.item as MessagePipeDiagnosticsInfoTreeViewItem;

            for (var visibleColumnIndex = 0; visibleColumnIndex < args.GetNumVisibleColumns(); visibleColumnIndex++)
            {
                var rect = args.GetCellRect(visibleColumnIndex);
                var columnIndex = args.GetColumn(visibleColumnIndex);

                var labelStyle = args.selected ? EditorStyles.whiteLabel : EditorStyles.label;
                labelStyle.alignment = TextAnchor.MiddleLeft;
                switch (columnIndex)
                {
                    case 0:
                        EditorGUI.LabelField(rect, item.Head, labelStyle);
                        break;
                    case 1:
                        EditorGUI.LabelField(rect, item.Elapsed.TotalSeconds.ToString(@"00.00"), labelStyle);
                        break;
                    case 2:
                        EditorGUI.LabelField(rect, item.Count.ToString(), labelStyle);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(columnIndex), columnIndex, null);
                }
            }
        }
    }

}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipeDiagnosticsInfoTreeView.cs.meta
================================================
fileFormatVersion: 2
guid: d5cee7ab0cc85bc4cbb6b0a2f68a4fff
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipeDiagnosticsInfoWindow.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace MessagePipe.Editor
{
    public class MessagePipeDiagnosticsInfoWindow : EditorWindow
    {
        static readonly string Splitter = "---" + Environment.NewLine;

        static int interval;

        static MessagePipeDiagnosticsInfoWindow window;

        internal static MessagePipeDiagnosticsInfo diagnosticsInfo;


        [MenuItem("Window/MessagePipe Diagnostics")]
        public static void OpenWindow()
        {
            if (window != null)
            {
                window.Close();
            }

            // will called OnEnable(singleton instance will be set).
            GetWindow<MessagePipeDiagnosticsInfoWindow>("MessagePipe Diagnostics").Show();
        }

        static readonly GUILayoutOption[] EmptyLayoutOption = new GUILayoutOption[0];

        MessagePipeDiagnosticsInfoTreeView treeView;
        object splitterState;

        void OnEnable()
        {
            window = this; // set singleton.
            splitterState = SplitterGUILayout.CreateSplitterState(new float[] { 75f, 25f }, new int[] { 32, 32 }, null);
            treeView = new MessagePipeDiagnosticsInfoTreeView();
            EnableAutoReload = EditorPrefs.GetBool("MessagePipeDiagnosticsInfoWindow.EnableAutoReload", false);
        }

        void OnGUI()
        {
            // Head
            RenderHeadPanel();

            // Splittable
            SplitterGUILayout.BeginVerticalSplit(this.splitterState, EmptyLayoutOption);
            {
                // Column Tabble
                RenderTable();

                // StackTrace details
                RenderDetailsPanel();
            }
            SplitterGUILayout.EndVerticalSplit();
        }

        #region HeadPanel

        static bool EnableAutoReload { get; set; }
        static bool EnableCaptureStackTrace { get; set; }
        internal static bool EnableCollapse { get; set; } = true;
        static readonly GUIContent EnableAutoReloadHeadContent = EditorGUIUtility.TrTextContent("Enable AutoReload", "Reload view automatically.", (Texture)null);
        static readonly GUIContent EnableCaptureStackTraceHeadContent = EditorGUIUtility.TrTextContent("Enable CaptureStackTrace", "CaptureStackTrace on Subscribe.", (Texture)null);
        static readonly GUIContent EnableCollapseHeadContent = EditorGUIUtility.TrTextContent("Collapse", "Collapse StackTraces.", (Texture)null);
        static readonly GUIContent ReloadHeadContent = EditorGUIUtility.TrTextContent("Reload", "Reload View.", (Texture)null);

        // [Enable CaptureStackTrace] | [Enable AutoReload] | .... | Reload
        void RenderHeadPanel()
        {
            EditorGUILayout.BeginVertical(EmptyLayoutOption);
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar, EmptyLayoutOption);

            // lazy initialize...
            if (diagnosticsInfo == null)
            {
                if (GlobalMessagePipe.IsInitialized)
                {
                    diagnosticsInfo = GlobalMessagePipe.DiagnosticsInfo;
                    EnableCaptureStackTrace = diagnosticsInfo.MessagePipeOptions.EnableCaptureStackTrace;
                }
            }

            if (GUILayout.Toggle(EnableCaptureStackTrace, EnableCaptureStackTraceHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != EnableCaptureStackTrace)
            {
                if (CheckInitialized())
                {
                    diagnosticsInfo.MessagePipeOptions.EnableCaptureStackTrace = EnableCaptureStackTrace = !EnableCaptureStackTrace;
                }
            }

            if (GUILayout.Toggle(EnableCollapse, EnableCollapseHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != EnableCollapse)
            {
                if (CheckInitialized())
                {
                    EnableCollapse = !EnableCollapse;
                    treeView.ReloadAndSort();
                    Repaint();
                }
            }

            if (GUILayout.Toggle(EnableAutoReload, EnableAutoReloadHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != EnableAutoReload)
            {
                if (CheckInitialized())
                {
                    EnableAutoReload = !EnableAutoReload;
                    EditorPrefs.SetBool("MessagePipeDiagnosticsInfoWindow.EnableAutoReload", EnableAutoReload);
                }
            }

            GUILayout.FlexibleSpace();

            if (GUILayout.Button(ReloadHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption))
            {
                if (CheckInitialized())
                {
                    treeView.ReloadAndSort();
                    Repaint();
                }
            }

            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
        }

        bool CheckInitialized()
        {
            if (diagnosticsInfo == null)
            {
                Debug.LogError("MessagePackDiagnosticsInfo is not set. Should call GlobalMessagePipe.SetProvider on startup.");
                return false;
            }
            return true;
        }

        #endregion

        #region TableColumn

        Vector2 tableScroll;
        GUIStyle tableListStyle;

        void RenderTable()
        {
            if (tableListStyle == null)
            {
                tableListStyle = new GUIStyle("CN Box");
                tableListStyle.margin.top = 0;
                tableListStyle.padding.left = 3;
            }

            EditorGUILayout.BeginVertical(tableListStyle, EmptyLayoutOption);

            this.tableScroll = EditorGUILayout.BeginScrollView(this.tableScroll, new GUILayoutOption[]
            {
                GUILayout.ExpandWidth(true),
                GUILayout.MaxWidth(2000f)
            });
            var controlRect = EditorGUILayout.GetControlRect(new GUILayoutOption[]
            {
                GUILayout.ExpandHeight(true),
                GUILayout.ExpandWidth(true)
            });


            treeView?.OnGUI(controlRect);

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void Update()
        {
            if (diagnosticsInfo != null && EnableAutoReload)
            {
                if (interval++ % 120 == 0)
                {
                    if (diagnosticsInfo.CheckAndResetDirty())
                    {
                        treeView.ReloadAndSort();
                        Repaint();
                    }
                }
            }
        }

        #endregion

        #region Details

        static GUIStyle detailsStyle;
        Vector2 detailsScroll;

        void RenderDetailsPanel()
        {
            if (detailsStyle == null)
            {
                detailsStyle = new GUIStyle("CN Message");
                detailsStyle.wordWrap = false;
                detailsStyle.stretchHeight = true;
                detailsStyle.margin.right = 15;
            }

            string message = "";
            var selected = treeView.state.selectedIDs;
            if (selected.Count > 0)
            {
                var first = selected[0];
                var item = treeView.CurrentBindingItems.FirstOrDefault(x => x.id == first) as MessagePipeDiagnosticsInfoTreeViewItem;
                if (item != null)
                {
                    var now = DateTimeOffset.UtcNow;
                    message = string.Join(Splitter, item.StackTraces
                        .Select(x =>
                            "Subscribe at " + x.Timestamp.ToLocalTime().ToString("HH:mm:ss.ff") // + ", Elapsed: " + (now - x.Timestamp).TotalSeconds.ToString("00.00")
                            + Environment.NewLine
                            + (x.formattedStackTrace ?? (x.formattedStackTrace = x.StackTrace.CleanupAsyncStackTrace()))));
                }
            }

            detailsScroll = EditorGUILayout.BeginScrollView(this.detailsScroll, EmptyLayoutOption);
            var vector = detailsStyle.CalcSize(new GUIContent(message));
            EditorGUILayout.SelectableLabel(message, detailsStyle, new GUILayoutOption[]
            {
                GUILayout.ExpandHeight(true),
                GUILayout.ExpandWidth(true),
                GUILayout.MinWidth(vector.x),
                GUILayout.MinHeight(vector.y)
            });
            EditorGUILayout.EndScrollView();
        }

        #endregion
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/MessagePipeDiagnosticsInfoWindow.cs.meta
================================================
fileFormatVersion: 2
guid: 42968f1c1e4200549b214c533eca73ea
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/SplitterGUILayout.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MessagePipe.Editor
{
    // reflection call of UnityEditor.SplitterGUILayout
    internal static class SplitterGUILayout
    {
        static BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;

        static Lazy<Type> splitterStateType = new Lazy<Type>(() =>
        {
            var type = typeof(EditorWindow).Assembly.GetTypes().First(x => x.FullName == "UnityEditor.SplitterState");
            return type;
        });

        static Lazy<ConstructorInfo> splitterStateCtor = new Lazy<ConstructorInfo>(() =>
        {
            var type = splitterStateType.Value;
            return type.GetConstructor(flags, null, new Type[] { typeof(float[]), typeof(int[]), typeof(int[]) }, null);
        });

        static Lazy<Type> splitterGUILayoutType = new Lazy<Type>(() =>
        {
            var type = typeof(EditorWindow).Assembly.GetTypes().First(x => x.FullName == "UnityEditor.SplitterGUILayout");
            return type;
        });

        static Lazy<MethodInfo> beginVerticalSplit = new Lazy<MethodInfo>(() =>
        {
            var type = splitterGUILayoutType.Value;
            return type.GetMethod("BeginVerticalSplit", flags, null, new Type[] { splitterStateType.Value, typeof(GUILayoutOption[]) }, null);
        });

        static Lazy<MethodInfo> endVerticalSplit = new Lazy<MethodInfo>(() =>
        {
            var type = splitterGUILayoutType.Value;
            return type.GetMethod("EndVerticalSplit", flags, null, Type.EmptyTypes, null);
        });

        public static object CreateSplitterState(float[] relativeSizes, int[] minSizes, int[] maxSizes)
        {
            return splitterStateCtor.Value.Invoke(new object[] { relativeSizes, minSizes, maxSizes });
        }

        public static void BeginVerticalSplit(object splitterState, params GUILayoutOption[] options)
        {
            beginVerticalSplit.Value.Invoke(null, new object[] { splitterState, options });
        }

        public static void EndVerticalSplit()
        {
            endVerticalSplit.Value.Invoke(null, Type.EmptyTypes);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Editor/SplitterGUILayout.cs.meta
================================================
fileFormatVersion: 2
guid: 14cc21ce00a64784eab22336b747c4f8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncMessageBroker.cs
================================================
using MessagePipe.Internal;
using System;
using System.Runtime.CompilerServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public class AsyncMessageBroker<TMessage> : IAsyncPublisher<TMessage>, IAsyncSubscriber<TMessage>
    {
        readonly AsyncMessageBrokerCore<TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public AsyncMessageBroker(AsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public IDisposable Subscribe(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateAsyncMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class AsyncMessageBrokerCore<TMessage> : IDisposable, IHandlerHolderMarker
    {
        FreeList<IAsyncMessageHandler<TMessage>> handlers;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate = new object();
        bool isDisposed;

        [Preserve]
        public AsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlers = new FreeList<IAsyncMessageHandler<TMessage>>();
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.diagnotics = diagnotics;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            var array = handlers.GetValues();
            for (int i = 0; i < array.Length; i++)
            {
                array[i]?.HandleAsync(message, cancellationToken).Forget();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return PublishAsync(message, defaultAsyncPublishStrategy, cancellationToken);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            var array = handlers.GetValues();
            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                foreach (var item in array)
                {
                    if (item != null)
                    {
                        await item.HandleAsync(message, cancellationToken);
                    }
                }
            }
            else
            {
                await new AsyncHandlerWhenAll<TMessage>(array, message, cancellationToken);
            }
        }

        public IDisposable Subscribe(IAsyncMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(AsyncMessageBrokerCore<TMessage>));

                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(this, subscriptionKey);
                diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                // Dispose is called when scope is finished.
                if (!isDisposed && handlers.TryDispose(out var count))
                {
                    isDisposed = true;
                    diagnotics.RemoveTargetDiagnostics(this, count);
                }
            }
        }

        sealed class Subscription : IDisposable
        {
            bool isDisposed;
            readonly AsyncMessageBrokerCore<TMessage> core;
            readonly int subscriptionKey;

            public Subscription(AsyncMessageBrokerCore<TMessage> core, int subscriptionKey)
            {
                this.core = core;
                this.subscriptionKey = subscriptionKey;
            }

            public void Dispose()
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    lock (core.gate)
                    {
                        core.handlers.Remove(subscriptionKey, true);
                        core.diagnotics.DecrementSubscribe(core, this);
                    }
                }
            }
        }
    }

    [Preserve]
    public sealed class BufferedAsyncMessageBroker<TMessage> : IBufferedAsyncPublisher<TMessage>, IBufferedAsyncSubscriber<TMessage>
    {
        readonly BufferedAsyncMessageBrokerCore<TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public BufferedAsyncMessageBroker(BufferedAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public UniTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            return SubscribeAsync(handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken)
        {
            handler = handlerFactory.CreateAsyncMessageHandler(handler, filters);
            return core.SubscribeAsync(handler, cancellationToken);
        }
    }

    [Preserve]
    public sealed class BufferedAsyncMessageBrokerCore<TMessage>
    {
        static readonly bool IsValueType = typeof(TMessage).IsValueType;

        readonly AsyncMessageBrokerCore<TMessage> core;
        TMessage lastMessage;

        [Preserve]
        public BufferedAsyncMessageBrokerCore(AsyncMessageBrokerCore<TMessage> core)
        {
            this.core = core;
            this.lastMessage = default;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            lastMessage = message;
            core.Publish(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            lastMessage = message;
            return core.PublishAsync(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            lastMessage = message;
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public async UniTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken)
        {
            if (IsValueType || lastMessage != null)
            {
                await handler.HandleAsync(lastMessage, cancellationToken);
            }
            return core.Subscribe(handler);
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonAsyncMessageBroker<TMessage> : AsyncMessageBroker<TMessage>, ISingletonAsyncPublisher<TMessage>, ISingletonAsyncSubscriber<TMessage>
    {
        [Preserve]
        public SingletonAsyncMessageBroker(SingletonAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBroker<TMessage> : AsyncMessageBroker<TMessage>, IScopedAsyncPublisher<TMessage>, IScopedAsyncSubscriber<TMessage>
    {
        [Preserve]
        public ScopedAsyncMessageBroker(ScopedAsyncMessageBrokerCore<TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonAsyncMessageBrokerCore<TMessage> : AsyncMessageBrokerCore<TMessage>
    {
        [Preserve]
        public SingletonAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBrokerCore<TMessage> : AsyncMessageBrokerCore<TMessage>
    {
        [Preserve]
        public ScopedAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncMessageBroker.cs.meta
================================================
fileFormatVersion: 2
guid: 9ff4242954a14784998cdc6a4dce02f7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncMessageBroker_Key.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public class AsyncMessageBroker<TKey, TMessage> : IAsyncPublisher<TKey, TMessage>, IAsyncSubscriber<TKey, TMessage>
        
    {
        readonly AsyncMessageBrokerCore<TKey, TMessage> core;
        readonly FilterAttachedAsyncMessageHandlerFactory handlerFactory;

        [Preserve]
        public AsyncMessageBroker(AsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(key, message, cancellationToken);
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(key, message, cancellationToken);
        }

        public UniTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(key, message, publishStrategy, cancellationToken);
        }

        public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(key, handlerFactory.CreateAsyncMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class AsyncMessageBrokerCore<TKey, TMessage> : IDisposable
        
    {
        readonly Dictionary<TKey, HandlerHolder> handlerGroup;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate;
        bool isDisposed;

        [Preserve]
        public AsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlerGroup = new Dictionary<TKey, HandlerHolder>();
            this.diagnotics = diagnotics;
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.gate = new object();
        }

        public void Publish(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            IAsyncMessageHandler<TMessage>[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            for (int i = 0; i < handlers.Length; i++)
            {
                handlers[i]?.HandleAsync(message, cancellationToken).Forget();
            }
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken)
        {
            return PublishAsync(key, message, defaultAsyncPublishStrategy, cancellationToken);
        }

        public async UniTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            IAsyncMessageHandler<TMessage>[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                foreach (var item in handlers)
                {
                    if (item != null)
                    {
                        await item.HandleAsync(message, cancellationToken);
                    }
                }
            }
            else
            {
                await new AsyncHandlerWhenAll<TMessage>(handlers, message, cancellationToken);
            }
        }

        public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(AsyncMessageBrokerCore<TKey, TMessage>));

                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    handlerGroup[key] = holder = new HandlerHolder(this);
                }

                return holder.Subscribe(key, handler);
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    foreach (var handlers in handlerGroup.Values)
                    {
                        handlers.Dispose();
                    }
                }
            }
        }

        // similar as Keyless-MessageBrokerCore but require to remove when key is empty on Dispose
        sealed class HandlerHolder : IDisposable, IHandlerHolderMarker
        {
            readonly FreeList<IAsyncMessageHandler<TMessage>> handlers;
            readonly AsyncMessageBrokerCore<TKey, TMessage> core;

            public HandlerHolder(AsyncMessageBrokerCore<TKey, TMessage> core)
            {
                this.handlers = new FreeList<IAsyncMessageHandler<TMessage>>();
                this.core = core;
            }

            public IAsyncMessageHandler<TMessage>[] GetHandlers() => handlers.GetValues();

            public IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> handler)
            {
                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(key, subscriptionKey, this);
                core.diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }

            public void Dispose()
            {
                lock (core.gate)
                {
                    if (handlers.TryDispose(out var count))
                    {
                        core.diagnotics.RemoveTargetDiagnostics(this, count);
                    }
                }
            }

            sealed class Subscription : IDisposable
            {
                bool isDisposed;
                readonly TKey key;
                readonly int subscriptionKey;
                readonly HandlerHolder holder;

                public Subscription(TKey key, int subscriptionKey, HandlerHolder holder)
                {
                    this.key = key;
                    this.subscriptionKey = subscriptionKey;
                    this.holder = holder;
                }

                public void Dispose()
                {
                    if (!isDisposed)
                    {
                        isDisposed = true;
                        lock (holder.core.gate)
                        {
                            if (!holder.core.isDisposed)
                            {
                                holder.handlers.Remove(subscriptionKey, false);
                                holder.core.diagnotics.DecrementSubscribe(holder, this);
                                if (holder.handlers.GetCount() == 0)
                                {
                                    holder.core.handlerGroup.Remove(key);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonAsyncMessageBroker<TKey, TMessage> : AsyncMessageBroker<TKey, TMessage>, ISingletonAsyncPublisher<TKey, TMessage>, ISingletonAsyncSubscriber<TKey, TMessage>
        
    {
        public SingletonAsyncMessageBroker(SingletonAsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonAsyncMessageBrokerCore<TKey, TMessage> : AsyncMessageBrokerCore<TKey, TMessage>
        
    {
        public SingletonAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBroker<TKey, TMessage> : AsyncMessageBroker<TKey, TMessage>, IScopedAsyncPublisher<TKey, TMessage>, IScopedAsyncSubscriber<TKey, TMessage>
        
    {
        public ScopedAsyncMessageBroker(ScopedAsyncMessageBrokerCore<TKey, TMessage> core, FilterAttachedAsyncMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedAsyncMessageBrokerCore<TKey, TMessage> : AsyncMessageBrokerCore<TKey, TMessage>
        
    {
        public ScopedAsyncMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncMessageBroker_Key.cs.meta
================================================
fileFormatVersion: 2
guid: 4b5f3339b1e89654eb1d48f159d13519
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncRequestHandler.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // async

    [Preserve]
    public sealed class AsyncRequestHandler<TRequest, TResponse> : IAsyncRequestHandler<TRequest, TResponse>
    {
        readonly IAsyncRequestHandlerCore<TRequest, TResponse> handler;

        [Preserve]
        public AsyncRequestHandler(IAsyncRequestHandlerCore<TRequest, TResponse> handler, FilterAttachedAsyncRequestHandlerFactory handlerFactory)
        {
            this.handler = handlerFactory.CreateAsyncRequestHandler<TRequest, TResponse>(handler);
        }

        public UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return handler.InvokeAsync(request, cancellationToken);
        }
    }

    [Preserve]
    public sealed class AsyncRequestAllHandler<TRequest, TResponse> : IAsyncRequestAllHandler<TRequest, TResponse>
    {
        readonly IAsyncRequestHandlerCore<TRequest, TResponse>[] handlers;
        readonly AsyncPublishStrategy defaultAsyncPublishStrategy;

        [Preserve]
        public AsyncRequestAllHandler(IEnumerable<IAsyncRequestHandlerCore<TRequest, TResponse>> handlers, FilterAttachedAsyncRequestHandlerFactory handlerFactory, MessagePipeOptions options)
        {
            var collection = (handlers as ICollection<IAsyncRequestHandlerCore<TRequest, TResponse>>) ?? handlers.ToArray();

            var array = new IAsyncRequestHandlerCore<TRequest, TResponse>[collection.Count];
            var i = 0;
            foreach (var item in collection)
            {
                array[i++] = handlerFactory.CreateAsyncRequestHandler(item);
            }

            this.handlers = array;
            this.defaultAsyncPublishStrategy = options.DefaultAsyncPublishStrategy;
        }

        public UniTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken)
        {
            return InvokeAllAsync(request, defaultAsyncPublishStrategy, cancellationToken);
        }

        public async UniTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            if (publishStrategy == AsyncPublishStrategy.Sequential)
            {
                var responses = new TResponse[handlers.Length];
                for (int i = 0; i < handlers.Length; i++)
                {
                    responses[i] = await handlers[i].InvokeAsync(request, cancellationToken);
                }
                return responses;
            }
            else
            {
                return await new AsyncRequestHandlerWhenAll<TRequest, TResponse>(handlers, request, cancellationToken);
            }
        }

#if UNITY_2018_3_OR_NEWER

        public Cysharp.Threading.Tasks.IUniTaskAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken)
        {

           return Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.Create<TResponse>(async (writer, token) =>
           {
               for (int i = 0; i < handlers.Length; i++)
               {
                   await writer.YieldAsync(await handlers[i].InvokeAsync(request, cancellationToken));
               }
           });
        }
#else

        public async IUniTaskAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request,  CancellationToken cancellationToken)
        {
            for (int i = 0; i < handlers.Length; i++)
            {
                yield return await handlers[i].InvokeAsync(request, cancellationToken);
            }
        }

#endif
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AsyncRequestHandler.cs.meta
================================================
fileFormatVersion: 2
guid: 20d7c39308d94fe46804d57186aa9c80
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AttributeFilterProvider.cs
================================================
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using MessagePipe.Internal;

namespace MessagePipe
{
    // not intended to use directly, use FilterAttachedMessageHandlerFactory.

    [Preserve]
    public sealed class AttributeFilterProvider<TAttribute>
        where TAttribute : IMessagePipeFilterAttribute
    {
        // cache attribute defines.
        readonly ConcurrentDictionary<Type, AttributeFilterDefinition[]> cache = new ConcurrentDictionary<Type, AttributeFilterDefinition[]>();

        [Preserve]
        public AttributeFilterProvider()
        {

        }

        public (int, IEnumerable<IMessagePipeFilter>) GetAttributeFilters(Type handlerType, IServiceProvider provider)
        {
            if (cache.TryGetValue(handlerType, out var value))
            {
                if (value.Length == 0) return (0, Array.Empty<IMessagePipeFilter>());
                return (value.Length, CreateFilters(value, provider));
            }

            // require to get all filter for alidate.
            var filterAttributes = handlerType.GetCustomAttributes(typeof(IMessagePipeFilterAttribute), true).OfType<TAttribute>().ToArray();
            if (filterAttributes.Length == 0)
            {
                cache[handlerType] = Array.Empty<AttributeFilterDefinition>();
                return (0, Array.Empty<IMessagePipeFilter>());
            }
            else
            {
                var array = filterAttributes.Cast<TAttribute>().Select(x => new AttributeFilterDefinition(x.Type, x.Order)).ToArray();
                var filterDefinitions = cache.GetOrAdd(handlerType, array);
                return (filterDefinitions.Length, CreateFilters(filterDefinitions, provider));
            }
        }

        static IEnumerable<IMessagePipeFilter> CreateFilters(AttributeFilterDefinition[] filterDefinitions, IServiceProvider provider)
        {
            foreach (var filterDefinition in filterDefinitions)
            {
                var f = (IMessagePipeFilter)provider.GetRequiredService(filterDefinition.FilterType);
                f.Order = filterDefinition.Order;
                yield return f;
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/AttributeFilterProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 83a485c21bc2f0e4fa984cc1976cd9bb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/DisposableBag.cs
================================================
using System;
using System.Collections.Generic;
using System.Threading;

namespace MessagePipe
{
    public static partial class DisposableBag
    {
        public static IDisposable Create(params IDisposable[] disposables)
        {
            return new NthDisposable(disposables);
        }

        sealed class NthDisposable : IDisposable
        {
            bool disposed;
            readonly IDisposable[] disposables;

            public NthDisposable(IDisposable[] disposables)
            {
                this.disposables = disposables;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    foreach (var item in disposables)
                    {
                        item.Dispose();
                    }
                }
            }
        }

        public static SingleAssignmentDisposable CreateSingleAssignment()
        {
            return new SingleAssignmentDisposable();
        }

        public static CancellationTokenDisposable CreateCancellation()
        {
            return new CancellationTokenDisposable();
        }

        public static DisposableBagBuilder CreateBuilder()
        {
            return new DisposableBagBuilder();
        }

        public static DisposableBagBuilder CreateBuilder(int initialCapacity)
        {
            return new DisposableBagBuilder(initialCapacity);
        }

        public static IDisposable Empty => EmptyDisposable.Instance;

        public static void AddTo(this IDisposable disposable, DisposableBagBuilder disposableBag)
        {
            disposableBag.Add(disposable);
        }

        public static SingleAssignmentDisposable SetTo(this IDisposable disposable, SingleAssignmentDisposable singleAssignmentDisposable)
        {
            singleAssignmentDisposable.Disposable = disposable;
            return singleAssignmentDisposable;
        }
    }

    internal class EmptyDisposable : IDisposable
    {
        internal static readonly IDisposable Instance = new EmptyDisposable();

        EmptyDisposable()
        {
        }

        public void Dispose()
        {
        }
    }

    public partial class DisposableBagBuilder
    {
        readonly List<IDisposable> disposables;

        internal DisposableBagBuilder()
        {
            disposables = new List<IDisposable>();
        }

        internal DisposableBagBuilder(int initialCapacity)
        {
            disposables = new List<IDisposable>(initialCapacity);
        }

        public void Add(IDisposable disposable)
        {
            disposables.Add(disposable);
        }

        public void Clear()
        {
            foreach (var item in disposables)
            {
                item.Dispose();
            }
            disposables.Clear();
        }

        //public IDisposable Build() in Disposables.tt(Disposables.cs)
    }

    public sealed class SingleAssignmentDisposable : IDisposable
    {
        IDisposable inner;
        bool isDisposed;
        readonly object gate = new object();

        public IDisposable Disposable
        {
            set
            {
                lock (gate)
                {
                    if (isDisposed)
                    {
                        // already disposed, dispose immediately
                        value.Dispose();
                        return;
                    }
                    else
                    {
                        if (inner == null)
                        {
                            // set new Disposable once.
                            inner = value;
                            return;
                        }
                        else
                        {
                            // set twice is invalid.
                            throw new InvalidOperationException("Set IDisposable twice is invalid.");
                        }
                    }
                }
            }
        }

        public void Dispose()
        {
            if (isDisposed) return;
            lock (gate)
            {
                isDisposed = true;
                if (inner != null)
                {
                    inner.Dispose();
                    inner = null;
                }
            }
        }
    }

    public sealed class CancellationTokenDisposable : IDisposable
    {
        CancellationTokenSource cancellationTokenSource;
        public CancellationToken Token => cancellationTokenSource.Token;

        public CancellationTokenDisposable()
        {
            this.cancellationTokenSource = new CancellationTokenSource();
        }

        public void Dispose()
        {
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/DisposableBag.cs.meta
================================================
fileFormatVersion: 2
guid: 51024c92400082e45b599d6dc44390ea
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Disposables.cs
================================================
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Disposables.tt. DO NOT CHANGE IT.
// </auto-generated>
using System;

namespace MessagePipe
{
    public static partial class DisposableBag
    {
        public static IDisposable Create(IDisposable disposable1)
        {
            return new Disposable1(disposable1);
        }

        sealed class Disposable1 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            
            public Disposable1(IDisposable disposable1)
            {
                this.disposable1 = disposable1;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2)
        {
            return new Disposable2(disposable1, disposable2);
        }

        sealed class Disposable2 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            
            public Disposable2(IDisposable disposable1, IDisposable disposable2)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
        {
            return new Disposable3(disposable1, disposable2, disposable3);
        }

        sealed class Disposable3 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            
            public Disposable3(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4)
        {
            return new Disposable4(disposable1, disposable2, disposable3, disposable4);
        }

        sealed class Disposable4 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            
            public Disposable4(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5)
        {
            return new Disposable5(disposable1, disposable2, disposable3, disposable4, disposable5);
        }

        sealed class Disposable5 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            
            public Disposable5(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6)
        {
            return new Disposable6(disposable1, disposable2, disposable3, disposable4, disposable5, disposable6);
        }

        sealed class Disposable6 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            readonly IDisposable disposable6;
            
            public Disposable6(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
                this.disposable6 = disposable6;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                    disposable6.Dispose();
                }
            }
        }

        public static IDisposable Create(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6, IDisposable disposable7)
        {
            return new Disposable7(disposable1, disposable2, disposable3, disposable4, disposable5, disposable6, disposable7);
        }

        sealed class Disposable7 : IDisposable
        {
            bool disposed;
            readonly IDisposable disposable1;
            readonly IDisposable disposable2;
            readonly IDisposable disposable3;
            readonly IDisposable disposable4;
            readonly IDisposable disposable5;
            readonly IDisposable disposable6;
            readonly IDisposable disposable7;
            
            public Disposable7(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3, IDisposable disposable4, IDisposable disposable5, IDisposable disposable6, IDisposable disposable7)
            {
                this.disposable1 = disposable1;
                this.disposable2 = disposable2;
                this.disposable3 = disposable3;
                this.disposable4 = disposable4;
                this.disposable5 = disposable5;
                this.disposable6 = disposable6;
                this.disposable7 = disposable7;
            }

            public void Dispose()
            {
                if (!disposed)
                {
                    disposed = true;
                    disposable1.Dispose();
                    disposable2.Dispose();
                    disposable3.Dispose();
                    disposable4.Dispose();
                    disposable5.Dispose();
                    disposable6.Dispose();
                    disposable7.Dispose();
                }
            }
        }

    }

    public partial class DisposableBagBuilder
    {
        public IDisposable Build()
        {
            switch (disposables.Count)
            {
                case 0:
                    return DisposableBag.Empty;
                case 1:
                    return DisposableBag.Create(disposables[0]);
                case 2:
                    return DisposableBag.Create(disposables[0], disposables[1]);
                case 3:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2]);
                case 4:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3]);
                case 5:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4]);
                case 6:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4], disposables[5]);
                case 7:
                    return DisposableBag.Create(disposables[0], disposables[1], disposables[2], disposables[3], disposables[4], disposables[5], disposables[6]);
                default:
                    return DisposableBag.Create(disposables.ToArray());
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Disposables.cs.meta
================================================
fileFormatVersion: 2
guid: df1a115654a129c48a7a44f1bac7ca76
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/DistributedSubscriberExtensions.cs
================================================
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    public static class DistributedSubscriberExtensions
    {
        // sync handler

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(key, new AnonymousMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, predicate, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : Append(filters, predicateFilter);

            return subscriber.SubscribeAsync(key, new AnonymousMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        // async handler

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, key, handler, predicate, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IUniTaskAsyncDisposable> SubscribeAsync<TKey, TMessage>(this IDistributedSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : Append(filters, predicateFilter);

            return subscriber.SubscribeAsync(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        static T[] Append<T>(T[] source, T item)
        {
            var dest = new T[source.Length + 1];
            Array.Copy(source, 0, dest, 0, source.Length);
            dest[dest.Length - 1] = item;
            return dest;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/DistributedSubscriberExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 43c3a4761b12f5d439902b352fe13985
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/EventFactory.cs
================================================
using MessagePipe.Internal;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public sealed class EventFactory
    {
        readonly MessagePipeOptions options;
        readonly MessagePipeDiagnosticsInfo diagnosticsInfo;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public EventFactory(
                MessagePipeOptions options,
                MessagePipeDiagnosticsInfo diagnosticsInfo,
                FilterAttachedMessageHandlerFactory handlerFactory,
                FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.diagnosticsInfo = diagnosticsInfo;
            this.handlerFactory = handlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;
        }

        public (IDisposablePublisher<T>, ISubscriber<T>) CreateEvent<T>()
        {
            var core = new MessageBrokerCore<T>(diagnosticsInfo, options);
            var publisher = new DisposablePublisher<T>(core);
            var subscriber = new MessageBroker<T>(core, handlerFactory);
            return (publisher, subscriber);
        }

        public (IDisposableAsyncPublisher<T>, IAsyncSubscriber<T>) CreateAsyncEvent<T>()
        {
            var core = new AsyncMessageBrokerCore<T>(diagnosticsInfo, options);
            var publisher = new DisposableAsyncPublisher<T>(core);
            var subscriber = new AsyncMessageBroker<T>(core, asyncHandlerFactory);
            return (publisher, subscriber);
        }

        public (IDisposableBufferedPublisher<T>, IBufferedSubscriber<T>) CreateBufferedEvent<T>(T initialValue)
        {
            var innerCore = new MessageBrokerCore<T>(diagnosticsInfo, options);
            var core = new BufferedMessageBrokerCore<T>(innerCore);
            var broker = new BufferedMessageBroker<T>(core, handlerFactory);
            var publisher = new DisposableBufferedPublisher<T>(broker, innerCore);
            var subscriber = broker;
            publisher.Publish(initialValue);
            return (publisher, subscriber);
        }

        public (IDisposableBufferedAsyncPublisher<T>, IBufferedAsyncSubscriber<T>) CreateBufferedAsyncEvent<T>(T initialValue)
        {
            var innerCore = new AsyncMessageBrokerCore<T>(diagnosticsInfo, options);
            var core = new BufferedAsyncMessageBrokerCore<T>(innerCore);
            var broker = new BufferedAsyncMessageBroker<T>(core, asyncHandlerFactory);
            var publisher = new DisposableBufferedAsyncPublisher<T>(broker, innerCore);
            var subscriber = broker;
            publisher.Publish(initialValue, CancellationToken.None); // set initial value is completely sync.
            return (publisher, subscriber);
        }
    }

    public interface IDisposablePublisher<TMessage> : IPublisher<TMessage>, IDisposable
    {
    }

    public interface IDisposableBufferedPublisher<TMessage> : IBufferedPublisher<TMessage>, IDisposable
    {
    }

    internal class DisposablePublisher<TMessage> : IDisposablePublisher<TMessage>
    {
        readonly MessageBrokerCore<TMessage> core;

        public DisposablePublisher(MessageBrokerCore<TMessage> core)
        {
            this.core = core;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public void Dispose()
        {
            core.Dispose();
        }
    }

    internal class DisposableBufferedPublisher<TMessage> : IDisposableBufferedPublisher<TMessage>
    {
        readonly BufferedMessageBroker<TMessage> broker;
        readonly IDisposable disposable;

        public DisposableBufferedPublisher(BufferedMessageBroker<TMessage> broker, IDisposable disposable)
        {
            this.broker = broker;
            this.disposable = disposable;
        }

        public void Publish(TMessage message)
        {
            broker.Publish(message);
        }

        public void Dispose()
        {
            disposable.Dispose();
        }
    }

    public interface IDisposableAsyncPublisher<TMessage> : IAsyncPublisher<TMessage>, IDisposable
    {
    }

    public interface IDisposableBufferedAsyncPublisher<TMessage> : IBufferedAsyncPublisher<TMessage>, IDisposable
    {
    }

    internal sealed class DisposableAsyncPublisher<TMessage> : IDisposableAsyncPublisher<TMessage>
    {
        readonly AsyncMessageBrokerCore<TMessage> core;

        public DisposableAsyncPublisher(AsyncMessageBrokerCore<TMessage> core)
        {
            this.core = core;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            core.Publish(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return core.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public void Dispose()
        {
            core.Dispose();
        }
    }

    internal sealed class DisposableBufferedAsyncPublisher<TMessage> : IDisposableBufferedAsyncPublisher<TMessage>
    {
        readonly BufferedAsyncMessageBroker<TMessage> broker;
        readonly IDisposable disposable;

        public DisposableBufferedAsyncPublisher(BufferedAsyncMessageBroker<TMessage> broker, IDisposable disposable)
        {
            this.broker = broker;
            this.disposable = disposable;
        }

        public void Publish(TMessage message, CancellationToken cancellationToken)
        {
            broker.Publish(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, CancellationToken cancellationToken)
        {
            return broker.PublishAsync(message, cancellationToken);
        }

        public UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken)
        {
            return broker.PublishAsync(message, publishStrategy, cancellationToken);
        }

        public void Dispose()
        {
            disposable.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/EventFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 3333784b20e6d204cba340fbeeb690d4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedAsyncMessageHandlerFactory.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // Async

    [Preserve]
    public sealed class FilterAttachedAsyncMessageHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<AsyncMessageHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedAsyncMessageHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<AsyncMessageHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IAsyncMessageHandler<TMessage> CreateAsyncMessageHandler<TMessage>(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var (globalLength, globalFilters) = options.GetGlobalAsyncMessageHandlerFilters(provider, typeof(TMessage));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (filters.Length != 0 || globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedAsyncMessageHandler<TMessage>(handler, globalFilters.Concat(handlerFilters).Concat(filters).Cast<AsyncMessageHandlerFilter<TMessage>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedAsyncMessageHandler<T> : IAsyncMessageHandler<T>
    {
        Func<T, CancellationToken, UniTask> handler;

        public FilterAttachedAsyncMessageHandler(IAsyncMessageHandler<T> body, IEnumerable<AsyncMessageHandlerFilter<T>> filters)
        {
            Func<T, CancellationToken, UniTask> next = body.HandleAsync;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new AsyncMessageHandlerFilterRunner<T>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public UniTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            return handler.Invoke(message, cancellationToken);
        }
    }

    internal sealed class AsyncMessageHandlerFilterRunner<T>
    {
        readonly AsyncMessageHandlerFilter<T> filter;
        readonly Func<T, CancellationToken, UniTask> next;

        public AsyncMessageHandlerFilterRunner(AsyncMessageHandlerFilter<T> filter, Func<T, CancellationToken, UniTask> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<T, CancellationToken, UniTask> GetDelegate() => HandleAsync;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        UniTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            return filter.HandleAsync(message, cancellationToken, next);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedAsyncMessageHandlerFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 9fb3e88151da09b429954485734415ad
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedAsyncRequestHandlerFactory.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // Async

    [Preserve]
    public sealed class FilterAttachedAsyncRequestHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<AsyncRequestHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedAsyncRequestHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<AsyncRequestHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IAsyncRequestHandlerCore<TRequest, TResponse> CreateAsyncRequestHandler<TRequest, TResponse>(IAsyncRequestHandlerCore<TRequest, TResponse> handler)
        {
            var (globalLength, globalFilters) = options.GetGlobalAsyncRequestHandlerFilters(provider, typeof(TRequest), typeof(TResponse));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedAsyncRequestHandler<TRequest, TResponse>(handler, globalFilters.Concat(handlerFilters).Cast<AsyncRequestHandlerFilter<TRequest, TResponse>>());
            }

            return handler;
        }
    }


    internal sealed class FilterAttachedAsyncRequestHandler<TRequest, TResponse> : IAsyncRequestHandler<TRequest, TResponse>
    {
        Func<TRequest, CancellationToken, UniTask<TResponse>> handler;

        public FilterAttachedAsyncRequestHandler(IAsyncRequestHandlerCore<TRequest, TResponse> body, IEnumerable<AsyncRequestHandlerFilter<TRequest, TResponse>> filters)
        {
            Func<TRequest, CancellationToken, UniTask<TResponse>> next = body.InvokeAsync;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new AsyncRequestHandlerFilterRunner<TRequest, TResponse>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken)
        {
            return handler(request, cancellationToken);
        }
    }

    internal sealed class AsyncRequestHandlerFilterRunner<TRequest, TResponse>
    {
        readonly AsyncRequestHandlerFilter<TRequest, TResponse> filter;
        readonly Func<TRequest, CancellationToken, UniTask<TResponse>> next;

        public AsyncRequestHandlerFilterRunner(AsyncRequestHandlerFilter<TRequest, TResponse> filter, Func<TRequest, CancellationToken, UniTask<TResponse>> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<TRequest, CancellationToken, UniTask<TResponse>> GetDelegate() => InvokeAsync;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken)
        {
            return filter.InvokeAsync(request, cancellationToken, next);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedAsyncRequestHandlerFactory.cs.meta
================================================
fileFormatVersion: 2
guid: f5da70d21e4dd394eb29dcf2da76388a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedMessageHandlerFactory.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // Sync

    [Preserve]
    public sealed class FilterAttachedMessageHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<MessageHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedMessageHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<MessageHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IMessageHandler<TMessage> CreateMessageHandler<TMessage>(IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters)
        {
            var (globalLength, globalFilters) = options.GetGlobalMessageHandlerFilters(provider, typeof(TMessage));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (filters.Length != 0 || globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedMessageHandler<TMessage>(handler, globalFilters.Concat(handlerFilters).Concat(filters).Cast<MessageHandlerFilter<TMessage>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedMessageHandler<T> : IMessageHandler<T>
    {
        Action<T> handler;

        public FilterAttachedMessageHandler(IMessageHandler<T> body, IEnumerable<MessageHandlerFilter<T>> filters)
        {
            Action<T> next = body.Handle;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new MessageHandlerFilterRunner<T>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public void Handle(T message)
        {
            handler(message);
        }
    }

    internal sealed class MessageHandlerFilterRunner<T>
    {
        readonly MessageHandlerFilter<T> filter;
        readonly Action<T> next;

        public MessageHandlerFilterRunner(MessageHandlerFilter<T> filter, Action<T> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Action<T> GetDelegate() => Handle;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void Handle(T message)
        {
            filter.Handle(message, next);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedMessageHandlerFactory.cs.meta
================================================
fileFormatVersion: 2
guid: d356abab610b5bc498c0df71e6c2e642
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedRequestHandlerFactory.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace MessagePipe
{
    // Sync

    [Preserve]
    public sealed class FilterAttachedRequestHandlerFactory
    {
        readonly MessagePipeOptions options;
        readonly AttributeFilterProvider<RequestHandlerFilterAttribute> filterProvider;
        readonly IServiceProvider provider;

        [Preserve]
        public FilterAttachedRequestHandlerFactory(MessagePipeOptions options, AttributeFilterProvider<RequestHandlerFilterAttribute> filterProvider, IServiceProvider provider)
        {
            this.options = options;
            this.filterProvider = filterProvider;
            this.provider = provider;
        }

        public IRequestHandlerCore<TRequest, TResponse> CreateRequestHandler<TRequest, TResponse>(IRequestHandlerCore<TRequest, TResponse> handler)
        {
            var (globalLength, globalFilters) = options.GetGlobalRequestHandlerFilters(provider, typeof(TRequest), typeof(TResponse));
            var (handlerLength, handlerFilters) = filterProvider.GetAttributeFilters(handler.GetType(), provider);

            if (globalLength != 0 || handlerLength != 0)
            {
                handler = new FilterAttachedRequestHandler<TRequest, TResponse>(handler, globalFilters.Concat(handlerFilters).Cast<RequestHandlerFilter<TRequest, TResponse>>());
            }

            return handler;
        }
    }

    internal sealed class FilterAttachedRequestHandler<TRequest, TResponse> : IRequestHandler<TRequest, TResponse>
    {
        Func<TRequest, TResponse> handler;

        public FilterAttachedRequestHandler(IRequestHandlerCore<TRequest, TResponse> body, IEnumerable<RequestHandlerFilter<TRequest, TResponse>> filters)
        {
            Func<TRequest, TResponse> next = body.Invoke;
            foreach (var f in filters.OrderByDescending(x => x.Order))
            {
                next = new RequestHandlerFilterRunner<TRequest, TResponse>(f, next).GetDelegate();
            }

            this.handler = next;
        }

        public TResponse Invoke(TRequest request)
        {
            return handler(request);
        }
    }

    internal sealed class RequestHandlerFilterRunner<TRequest, TResponse>
    {
        readonly RequestHandlerFilter<TRequest, TResponse> filter;
        readonly Func<TRequest, TResponse> next;

        public RequestHandlerFilterRunner(RequestHandlerFilter<TRequest, TResponse> filter, Func<TRequest, TResponse> next)
        {
            this.filter = filter;
            this.next = next;
        }

        public Func<TRequest, TResponse> GetDelegate() => Invoke;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        TResponse Invoke(TRequest request)
        {
            return filter.Invoke(request, next);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/FilterAttachedRequestHandlerFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 68b83bed45164ac4c8ad723ec1ecfec3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/GlobalMessagePipe.cs
================================================
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
using System;

namespace MessagePipe
{
    public static class GlobalMessagePipe
    {
        static IServiceProvider provider;
        static EventFactory eventFactory;
        static MessagePipeDiagnosticsInfo diagnosticsInfo;

        public static void SetProvider(IServiceProvider provider)
        {
            GlobalMessagePipe.provider = provider;
            GlobalMessagePipe.eventFactory = provider.GetRequiredService<EventFactory>();
            GlobalMessagePipe.diagnosticsInfo = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
        }

        public static bool IsInitialized => provider != null;

        public static MessagePipeDiagnosticsInfo DiagnosticsInfo
        {
            get
            {
                ThrowIfNotInitialized();
                return diagnosticsInfo;
            }
        }

        public static IPublisher<TMessage> GetPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IPublisher<TMessage>>();
        }

        public static ISubscriber<TMessage> GetSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<ISubscriber<TMessage>>();
        }

        public static IAsyncPublisher<TMessage> GetAsyncPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncPublisher<TMessage>>();
        }

        public static IAsyncSubscriber<TMessage> GetAsyncSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncSubscriber<TMessage>>();
        }

        public static IPublisher<TKey, TMessage> GetPublisher<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IPublisher<TKey, TMessage>>();
        }

        public static ISubscriber<TKey, TMessage> GetSubscriber<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<ISubscriber<TKey, TMessage>>();
        }

        public static IAsyncPublisher<TKey, TMessage> GetAsyncPublisher<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncPublisher<TKey, TMessage>>();
        }

        public static IAsyncSubscriber<TKey, TMessage> GetAsyncSubscriber<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncSubscriber<TKey, TMessage>>();
        }

        public static IRequestHandler<TRequest, TResponse> GetRequestHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IRequestHandler<TRequest, TResponse>>();
        }

        public static IAsyncRequestHandler<TRequest, TResponse> GetAsyncRequestHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncRequestHandler<TRequest, TResponse>>();
        }

        public static IRequestAllHandler<TRequest, TResponse> GetRequestAllHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IRequestAllHandler<TRequest, TResponse>>();
        }

        public static IAsyncRequestAllHandler<TRequest, TResponse> GetAsyncRequestAllHandler<TRequest, TResponse>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IAsyncRequestAllHandler<TRequest, TResponse>>();
        }

        public static IBufferedPublisher<TMessage> GetBufferedPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedPublisher<TMessage>>();
        }

        public static IBufferedSubscriber<TMessage> GetBufferedSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedSubscriber<TMessage>>();
        }

        public static IBufferedAsyncPublisher<TMessage> GetAsyncBufferedPublisher<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedAsyncPublisher<TMessage>>();
        }

        public static IBufferedAsyncSubscriber<TMessage> GetAsyncBufferedSubscriber<TMessage>()
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IBufferedAsyncSubscriber<TMessage>>();
        }

#if !UNITY_2018_3_OR_NEWER

        public static IDistributedPublisher<TKey, TMessage> GetDistributedPublisher<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IDistributedPublisher<TKey, TMessage>>();
        }

        public static IDistributedSubscriber<TKey, TMessage> GetDistributedSubscriber<TKey, TMessage>()
            
        {
            ThrowIfNotInitialized();
            return provider.GetRequiredService<IDistributedSubscriber<TKey, TMessage>>();
        }

#endif

        public static (IDisposablePublisher<T>, ISubscriber<T>) CreateEvent<T>()
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateEvent<T>();
        }

        public static (IDisposableAsyncPublisher<T>, IAsyncSubscriber<T>) CreateAsyncEvent<T>()
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateAsyncEvent<T>();
        }

        public static (IDisposableBufferedPublisher<T>, IBufferedSubscriber<T>) CreateBufferedEvent<T>(T initialValue)
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateBufferedEvent<T>(initialValue);
        }

        public static (IDisposableBufferedAsyncPublisher<T>, IBufferedAsyncSubscriber<T>) CreateBufferedAsyncEvent<T>(T initialValue)
        {
            ThrowIfNotInitialized();
            return eventFactory.CreateBufferedAsyncEvent<T>(initialValue);
        }

        // [MemberNotNull(nameof(provider), nameof(eventFactory), nameof(diagnosticsInfo))]
        static void ThrowIfNotInitialized()
        {
            if (provider == null || eventFactory == null || diagnosticsInfo == null)
            {
                throw new InvalidOperationException("Require to call `SetProvider` before use GlobalMessagePipe.");
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/GlobalMessagePipe.cs.meta
================================================
fileFormatVersion: 2
guid: 899560cc44305ba49a9a52a5d3bd9006
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IDistributedPubSub.cs
================================================
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    public interface IDistributedPublisher<TKey, TMessage>
    {
        UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default);
    }

    public interface IDistributedSubscriber<TKey, TMessage>
    {
        UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
        UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IDistributedPubSub.cs.meta
================================================
fileFormatVersion: 2
guid: 615b2188717516a40933e367cbee86fe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IgnoreAutoRegistration.cs
================================================
using System;

namespace MessagePipe
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public class IgnoreAutoRegistration : Attribute
    {
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IgnoreAutoRegistration.cs.meta
================================================
fileFormatVersion: 2
guid: 88e7192171cabe24bae4f8013fa2e1d5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/InMemoryDistributedPubSub.cs
================================================
using MessagePipe.Internal;
using System;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    [Preserve]
    public sealed class InMemoryDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    
    {
        readonly IAsyncPublisher<TKey, TMessage> publisher;

        [Preserve]
        public InMemoryDistributedPublisher(IAsyncPublisher<TKey, TMessage> publisher)
        {
            this.publisher = publisher;
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            return publisher.PublishAsync(key, message, cancellationToken);
        }
    }

    [Preserve]
    public sealed class InMemoryDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
        
    {
        readonly IAsyncSubscriber<TKey, TMessage> subscriber;

        [Preserve]
        public InMemoryDistributedSubscriber(IAsyncSubscriber<TKey, TMessage> subscriber)
        {
            this.subscriber = subscriber;
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, new AsyncMessageHandlerBridge<TMessage>(handler));
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, new AsyncMessageHandlerBridge<TMessage>(handler), filters.Select(x => new AsyncMessageHandlerFilterBridge<TMessage>(x)).ToArray());
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            var d = subscriber.Subscribe(key, handler);
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {

            var d = subscriber.Subscribe(key, handler, filters);
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    internal sealed class AsyncDisposableBridge : IUniTaskAsyncDisposable
    {
        readonly IDisposable disposable;

        public AsyncDisposableBridge(IDisposable disposable)
        {
            this.disposable = disposable;
        }

        public UniTask DisposeAsync()
        {
            disposable.Dispose();
            return default;
        }
    }

    internal sealed class AsyncMessageHandlerBridge<T> : IAsyncMessageHandler<T>
    {
        readonly IMessageHandler<T> handler;

        public AsyncMessageHandlerBridge(IMessageHandler<T> handler)
        {
            this.handler = handler;
        }

        public UniTask HandleAsync(T message, CancellationToken cancellationToken)
        {
            handler.Handle(message);
            return default;
        }
    }

    internal sealed class AsyncMessageHandlerFilterBridge<T> : AsyncMessageHandlerFilter<T>
    {
        readonly MessageHandlerFilter<T> filter;

        public AsyncMessageHandlerFilterBridge(MessageHandlerFilter<T> filter)
        {
            this.filter = filter;
            this.Order = filter.Order;
        }

        public override UniTask HandleAsync(T message, CancellationToken cancellationToken, Func<T, CancellationToken, UniTask> next)
        {
            filter.Handle(message, x => next(x, cancellationToken));
            return default;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/InMemoryDistributedPubSub.cs.meta
================================================
fileFormatVersion: 2
guid: de4f5b0be149901449e59ffb8bd852b9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal.meta
================================================
fileFormatVersion: 2
guid: b6d3bd36f92c48a4ca1a6b5bd1ec08a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IPublisherSubscriber.cs
================================================
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // handler

    public interface IMessageHandler<TMessage>
    {
        void Handle(TMessage message);
    }

    public interface IAsyncMessageHandler<TMessage>
    {
        UniTask HandleAsync(TMessage message, CancellationToken cancellationToken);
    }

    // Keyless

    public interface IPublisher<TMessage>
    {
        void Publish(TMessage message);
    }

    public interface ISubscriber<TMessage>
    {
        IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IAsyncPublisher<TMessage>
    {
        void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IAsyncSubscriber<TMessage>
    {
        IDisposable Subscribe(IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
    }

    public interface ISingletonPublisher<TMessage> : IPublisher<TMessage> { }
    public interface ISingletonSubscriber<TMessage> : ISubscriber<TMessage> { }
    public interface IScopedPublisher<TMessage> : IPublisher<TMessage> { }
    public interface IScopedSubscriber<TMessage> : ISubscriber<TMessage> { }
    public interface ISingletonAsyncPublisher<TMessage> : IAsyncPublisher<TMessage> { }
    public interface ISingletonAsyncSubscriber<TMessage> : IAsyncSubscriber<TMessage> { }
    public interface IScopedAsyncPublisher<TMessage> : IAsyncPublisher<TMessage> { }
    public interface IScopedAsyncSubscriber<TMessage> : IAsyncSubscriber<TMessage> { }

    // Keyed

    public interface IPublisher<TKey, TMessage>
        
    {
        void Publish(TKey key, TMessage message);
    }

    public interface ISubscriber<TKey, TMessage>
        
    {
        IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IAsyncPublisher<TKey, TMessage>
        
    {
        void Publish(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TKey key, TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IAsyncSubscriber<TKey, TMessage>
        
    {
        IDisposable Subscribe(TKey key, IAsyncMessageHandler<TMessage> asyncHandler, params AsyncMessageHandlerFilter<TMessage>[] filters);
    }

    public interface ISingletonPublisher<TKey, TMessage> : IPublisher<TKey, TMessage>  { }
    public interface ISingletonSubscriber<TKey, TMessage> : ISubscriber<TKey, TMessage>  { }
    public interface IScopedPublisher<TKey, TMessage> : IPublisher<TKey, TMessage>  { }
    public interface IScopedSubscriber<TKey, TMessage> : ISubscriber<TKey, TMessage>  { }
    public interface ISingletonAsyncPublisher<TKey, TMessage> : IAsyncPublisher<TKey, TMessage>  { }
    public interface ISingletonAsyncSubscriber<TKey, TMessage> : IAsyncSubscriber<TKey, TMessage>  { }
    public interface IScopedAsyncPublisher<TKey, TMessage> : IAsyncPublisher<TKey, TMessage>  { }
    public interface IScopedAsyncSubscriber<TKey, TMessage> : IAsyncSubscriber<TKey, TMessage>  { }

    // buffered keyless

    public interface IBufferedPublisher<TMessage>
    {
        void Publish(TMessage message);
    }

    public interface IBufferedSubscriber<TMessage>
    {
        IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters);
    }

    public interface IBufferedAsyncPublisher<TMessage>
    {
        void Publish(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken));
        UniTask PublishAsync(TMessage message, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default(CancellationToken));
    }

    public interface IBufferedAsyncSubscriber<TMessage>
    {
        UniTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default);
        UniTask<IDisposable> SubscribeAsync(IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default);
    }

    // NOTE: buffered Keyed is undefined
    // because difficult to avoid (unused)key and keep latest value memory leak.
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IPublisherSubscriber.cs.meta
================================================
fileFormatVersion: 2
guid: 536e6aa88d3ff4e4ca0656e7c958692d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IRequestHandler.cs
================================================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    // Sync

    public interface IRequestHandler
    {
    }

    public interface IRequestHandlerCore<in TRequest, out TResponse> : IRequestHandler
    {
        TResponse Invoke(TRequest request);
    }

    public interface IRequestHandler<in TRequest, out TResponse> : IRequestHandlerCore<TRequest, TResponse>
    {
    }

    public interface IRequestAllHandler<in TRequest, out TResponse>
    {
        TResponse[] InvokeAll(TRequest request);
        IEnumerable<TResponse> InvokeAllLazy(TRequest request);
    }

    // Async

    public interface IAsyncRequestHandler
    {
    }

    public interface IAsyncRequestHandlerCore<in TRequest, TResponse> : IAsyncRequestHandler
    {
        UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    public interface IAsyncRequestHandler<in TRequest, TResponse> : IAsyncRequestHandlerCore<TRequest, TResponse>
    {
    }

    public interface IAsyncRequestAllHandler<in TRequest, TResponse>
    {
        UniTask<TResponse[]> InvokeAllAsync(TRequest request, CancellationToken cancellationToken = default);
        UniTask<TResponse[]> InvokeAllAsync(TRequest request, AsyncPublishStrategy publishStrategy, CancellationToken cancellationToken = default);
        IUniTaskAsyncEnumerable<TResponse> InvokeAllLazyAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    // Remote

    public interface IRemoteRequestHandler<in TRequest, TResponse>
    // where TAsyncRequestHandler : IAsyncRequestHandler<TRequest, TResponse>
    {
        UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default);
    }

    public class RemoteRequestException : Exception
    {
        public RemoteRequestException(string message)
            : base(message)
        {
        }
    }

    // almostly internal usage for IRemoteRequestHandler type search
    public static class AsyncRequestHandlerRegistory
    {
        static ConcurrentDictionary<(string, string), Type> types = new ConcurrentDictionary<(string, string), Type>();

        public static void Add(Type handlerType)
        {
            foreach (var interfaceType in handlerType.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore")))
            {
                var genArgs = interfaceType.GetGenericArguments();
                types[(genArgs[0].FullName, genArgs[1].FullName)] = handlerType;
            }
        }

        public static void Add(Type requestType, Type responseType, Type handlerType)
        {
            types[(requestType.FullName, responseType.FullName)] = handlerType;
        }

        public static Type Get(string requestType, string responseType)
        {
            if (types.TryGetValue((requestType, responseType), out var result))
            {
                return result;
            }
            throw new InvalidOperationException($"IAsyncHandler<{requestType}, {responseType}> is not registered.");
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/IRequestHandler.cs.meta
================================================
fileFormatVersion: 2
guid: a57abb29732cf1f46911962a087f3773
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessageBroker.cs
================================================
using MessagePipe.Internal;
using System;
using System.Runtime.CompilerServices;

namespace MessagePipe
{
    [Preserve]
    public class MessageBroker<TMessage> : IPublisher<TMessage>, ISubscriber<TMessage>
    {
        readonly MessageBrokerCore<TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public MessageBroker(MessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class MessageBrokerCore<TMessage> : IDisposable, IHandlerHolderMarker
    {
        readonly FreeList<IMessageHandler<TMessage>> handlers;
        readonly MessagePipeDiagnosticsInfo diagnostics;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate = new object();
        bool isDisposed;

        [Preserve]
        public MessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
        {
            this.handlers = new FreeList<IMessageHandler<TMessage>>();
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.diagnostics = diagnostics;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Publish(TMessage message)
        {
            var array = handlers.GetValues();
            for (int i = 0; i < array.Length; i++)
            {
                array[i]?.Handle(message);
            }
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(MessageBrokerCore<TMessage>));

                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(this, subscriptionKey);
                diagnostics.IncrementSubscribe(this, subscription);
                return subscription;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                // Dispose is called when scope is finished.
                if (!isDisposed && handlers.TryDispose(out var count))
                {
                    isDisposed = true;
                    diagnostics.RemoveTargetDiagnostics(this, count);
                }
            }
        }

        sealed class Subscription : IDisposable
        {
            bool isDisposed;
            readonly MessageBrokerCore<TMessage> core;
            readonly int subscriptionKey;

            public Subscription(MessageBrokerCore<TMessage> core, int subscriptionKey)
            {
                this.core = core;
                this.subscriptionKey = subscriptionKey;
            }

            public void Dispose()
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    lock (core.gate)
                    {
                        if (!core.isDisposed)
                        {
                            core.handlers.Remove(subscriptionKey, true);
                            core.diagnostics.DecrementSubscribe(core, this);
                        }
                    }
                }
            }
        }
    }

    [Preserve]
    public sealed class BufferedMessageBroker<TMessage> : IBufferedPublisher<TMessage>, IBufferedSubscriber<TMessage>
    {
        readonly BufferedMessageBrokerCore<TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public BufferedMessageBroker(BufferedMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TMessage message)
        {
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public sealed class BufferedMessageBrokerCore<TMessage>
    {
        static readonly bool IsValueType = typeof(TMessage).IsValueType;

        readonly MessageBrokerCore<TMessage> core;
        TMessage lastMessage;

        [Preserve]
        public BufferedMessageBrokerCore(MessageBrokerCore<TMessage> core)
        {
            this.core = core;
            this.lastMessage = default;
        }

        public void Publish(TMessage message)
        {
            lastMessage = message;
            core.Publish(message);
        }

        public IDisposable Subscribe(IMessageHandler<TMessage> handler)
        {
            if (IsValueType || lastMessage != null)
            {
                handler.Handle(lastMessage);
            }
            return core.Subscribe(handler);
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonMessageBroker<TMessage> : MessageBroker<TMessage>, ISingletonPublisher<TMessage>, ISingletonSubscriber<TMessage>
    {
        [Preserve]
        public SingletonMessageBroker(SingletonMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBroker<TMessage> : MessageBroker<TMessage>, IScopedPublisher<TMessage>, IScopedSubscriber<TMessage>
    {
        [Preserve]
        public ScopedMessageBroker(ScopedMessageBrokerCore<TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonMessageBrokerCore<TMessage> : MessageBrokerCore<TMessage>
    {
        [Preserve]
        public SingletonMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBrokerCore<TMessage> : MessageBrokerCore<TMessage>
    {
        [Preserve]
        public ScopedMessageBrokerCore(MessagePipeDiagnosticsInfo diagnostics, MessagePipeOptions options)
            : base(diagnostics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessageBroker.cs.meta
================================================
fileFormatVersion: 2
guid: 2e2f4d89d2e58ce4d84730fa5b28d39a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessageBroker_Key.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;

namespace MessagePipe
{
    [Preserve]
    public class MessageBroker<TKey, TMessage> : IPublisher<TKey, TMessage>, ISubscriber<TKey, TMessage>
        
    {
        readonly MessageBrokerCore<TKey, TMessage> core;
        readonly FilterAttachedMessageHandlerFactory handlerFactory;

        [Preserve]
        public MessageBroker(MessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
        {
            this.core = core;
            this.handlerFactory = handlerFactory;
        }

        public void Publish(TKey key, TMessage message)
        {
            core.Publish(key, message);
        }

        public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return core.Subscribe(key, handlerFactory.CreateMessageHandler(handler, filters));
        }
    }

    [Preserve]
    public class MessageBrokerCore<TKey, TMessage> : IDisposable
    
    {
        readonly Dictionary<TKey, HandlerHolder> handlerGroup;
        readonly MessagePipeDiagnosticsInfo diagnotics;
        readonly HandlingSubscribeDisposedPolicy handlingSubscribeDisposedPolicy;
        readonly object gate;
        bool isDisposed;

        [Preserve]
        public MessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
        {
            this.handlerGroup = new Dictionary<TKey, HandlerHolder>();
            this.diagnotics = diagnotics;
            this.handlingSubscribeDisposedPolicy = options.HandlingSubscribeDisposedPolicy;
            this.gate = new object();
        }

        public void Publish(TKey key, TMessage message)
        {
            IMessageHandler<TMessage>[] handlers;
            lock (gate)
            {
                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    return;
                }
                handlers = holder.GetHandlers();
            }

            for (int i = 0; i < handlers.Length; i++)
            {
                handlers[i]?.Handle(message);
            }
        }

        public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler)
        {
            lock (gate)
            {
                if (isDisposed) return handlingSubscribeDisposedPolicy.Handle(nameof(MessageBrokerCore<TKey, TMessage>));

                if (!handlerGroup.TryGetValue(key, out var holder))
                {
                    handlerGroup[key] = holder = new HandlerHolder(this);
                }

                return holder.Subscribe(key, handler);
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (!isDisposed)
                {
                    isDisposed = true;
                    foreach (var handlers in handlerGroup.Values)
                    {
                        handlers.Dispose();
                    }
                }
            }
        }

        // similar as Keyless-MessageBrokerCore but require to remove when key is empty on Dispose
        sealed class HandlerHolder : IDisposable, IHandlerHolderMarker
        {
            readonly FreeList<IMessageHandler<TMessage>> handlers;
            readonly MessageBrokerCore<TKey, TMessage> core;

            public HandlerHolder(MessageBrokerCore<TKey, TMessage> core)
            {
                this.handlers = new FreeList<IMessageHandler<TMessage>>();
                this.core = core;
            }

            public IMessageHandler<TMessage>[] GetHandlers() => handlers.GetValues();

            public IDisposable Subscribe(TKey key, IMessageHandler<TMessage> handler)
            {
                var subscriptionKey = handlers.Add(handler);
                var subscription = new Subscription(key, subscriptionKey, this);
                core.diagnotics.IncrementSubscribe(this, subscription);
                return subscription;
            }

            public void Dispose()
            {
                lock (core.gate)
                {
                    if (handlers.TryDispose(out var count))
                    {
                        core.diagnotics.RemoveTargetDiagnostics(this, count);
                    }
                }
            }

            sealed class Subscription : IDisposable
            {
                bool isDisposed;
                readonly TKey key;
                readonly int subscriptionKey;
                readonly HandlerHolder holder;

                public Subscription(TKey key, int subscriptionKey, HandlerHolder holder)
                {
                    this.key = key;
                    this.subscriptionKey = subscriptionKey;
                    this.holder = holder;
                }

                public void Dispose()
                {
                    if (!isDisposed)
                    {
                        isDisposed = true;
                        lock (holder.core.gate)
                        {
                            if (!holder.core.isDisposed)
                            {
                                holder.handlers.Remove(subscriptionKey, false);
                                holder.core.diagnotics.DecrementSubscribe(holder, this);
                                if (holder.handlers.GetCount() == 0)
                                {
                                    holder.core.handlerGroup.Remove(key);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Singleton, Scoped variation

    [Preserve]
    public class SingletonMessageBroker<TKey, TMessage> : MessageBroker<TKey, TMessage>, ISingletonPublisher<TKey, TMessage>, ISingletonSubscriber<TKey, TMessage>
        
    {
        public SingletonMessageBroker(SingletonMessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class SingletonMessageBrokerCore<TKey, TMessage> : MessageBrokerCore<TKey, TMessage>
        
    {
        public SingletonMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBroker<TKey, TMessage> : MessageBroker<TKey, TMessage>, IScopedPublisher<TKey, TMessage>, IScopedSubscriber<TKey, TMessage>
        
    {
        public ScopedMessageBroker(ScopedMessageBrokerCore<TKey, TMessage> core, FilterAttachedMessageHandlerFactory handlerFactory)
            : base(core, handlerFactory)
        {
        }
    }

    [Preserve]
    public class ScopedMessageBrokerCore<TKey, TMessage> : MessageBrokerCore<TKey, TMessage>
        
    {
        public ScopedMessageBrokerCore(MessagePipeDiagnosticsInfo diagnotics, MessagePipeOptions options)
            : base(diagnotics, options)
        {
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessageBroker_Key.cs.meta
================================================
fileFormatVersion: 2
guid: 85274606129d1db439c9cbf391440890
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipe.asmdef
================================================
{
    "name": "MessagePipe",
    "references": [
        "UniTask",
        "UniTask.Linq"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "jp.hadashikick.vcontainer",
            "expression": "1.14.0",
            "define": "MESSAGEPIPE_OPENGENERICS_SUPPORT"
        }
    ],
    "noEngineReferences": true
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipe.asmdef.meta
================================================
fileFormatVersion: 2
guid: 08b38f39e2d9e594389b7a4cf4c2c338
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeDiagnosticsInfo.cs
================================================
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security;
using System.Threading;

namespace MessagePipe
{
    internal interface IHandlerHolderMarker
    {
    }

    public class StackTraceInfo
    {
        static bool displayFileNames = true;
        static int idSeed = 0;

        public int Id { get; }
        public DateTimeOffset Timestamp { get; }
        public StackTrace StackTrace { get; }
        public string Head { get; }

        internal string formattedStackTrace = default; // cache field for internal use(Unity Editor, etc...)

        public StackTraceInfo(StackTrace stackTrace)
        {
            Id = Interlocked.Increment(ref idSeed);
            Timestamp = DateTimeOffset.UtcNow;
            StackTrace = stackTrace;
            Head = GetGroupKey(stackTrace);
        }

        internal static string GetGroupKey(StackTrace stackTrace)
        {
            for (int i = 0; i < stackTrace.FrameCount; i++)
            {
                var sf = stackTrace.GetFrame(i);
                if (sf == null) continue;
                var m = sf.GetMethod();
                if (m == null) continue;
                if (m.DeclaringType == null) continue;
                if (m.DeclaringType.Namespace == null || !m.DeclaringType.Namespace.StartsWith("MessagePipe"))
                {
                    if (displayFileNames && sf.GetILOffset() != -1)
                    {
                        string fileName = null;
                        try
                        {
                            fileName = sf.GetFileName();
                        }
                        catch (NotSupportedException)
                        {
                            displayFileNames = false;
                        }
                        catch (SecurityException)
                        {
                            displayFileNames = false;
                        }

                        if (fileName != null)
                        {
                            return m.DeclaringType.FullName + "." + m.Name + " (at " + Path.GetFileName(fileName) + ":" + sf.GetFileLineNumber() + ")";
                        }
                        else
                        {
                            return m.DeclaringType.FullName + "." + m.Name + " (offset: " + sf.GetILOffset() + ")";
                        }
                    }

                    return m.DeclaringType.FullName + "." + m.Name;
                }
            }

            return "";
        }
    }

    /// <summary>
    /// Diagnostics info of in-memory(ISubscriber/IAsyncSubscriber) subscriptions.
    /// </summary>
    [Preserve]
    public sealed class MessagePipeDiagnosticsInfo
    {
        static readonly ILookup<string, StackTraceInfo> EmptyLookup = Array.Empty<StackTraceInfo>().ToLookup(_ => "", x => x);

        int subscribeCount;
        bool dirty;
        MessagePipeOptions options;

        object gate = new object();
        Dictionary<IHandlerHolderMarker, Dictionary<IDisposable, StackTraceInfo>> capturedStackTraces = new Dictionary<IHandlerHolderMarker, Dictionary<IDisposable, StackTraceInfo>>();

        /// <summary>Get current subscribed count.</summary>
        public int SubscribeCount => subscribeCount;

        internal bool CheckAndResetDirty()
        {
            var d = dirty;
            dirty = false;
            return d;
        }

        internal MessagePipeOptions MessagePipeOptions => options;

        /// <summary>
        /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, list all stacktrace on subscribe.
        /// </summary>
        public StackTraceInfo[] GetCapturedStackTraces(bool ascending = true)
        {
            if (!options.EnableCaptureStackTrace) return Array.Empty<StackTraceInfo>();
            lock (gate)
            {
                var iter = capturedStackTraces.SelectMany(x => x.Value.Values);
                iter = (ascending) ? iter.OrderBy(x => x.Id) : iter.OrderByDescending(x => x.Id);
                return iter.ToArray();
            }
        }

        /// <summary>
        /// When MessagePipeOptions.EnableCaptureStackTrace is enabled, groped by caller of subscribe.
        /// </summary>
        public ILookup<string, StackTraceInfo> GetGroupedByCaller(bool ascending = true)
        {
            if (!options.EnableCaptureStackTrace) return EmptyLookup;
            lock (gate)
            {
                var iter = capturedStackTraces.SelectMany(x => x.Value.Values);
                iter = (ascending) ? iter.OrderBy(x => x.Id) : iter.OrderByDescending(x => x.Id);
                return iter.ToLookup(x => x.Head);
            }
        }

        [Preserve]
        public MessagePipeDiagnosticsInfo(MessagePipeOptions options)
        {
            this.options = options;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void IncrementSubscribe(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            Interlocked.Increment(ref subscribeCount);
            if (options.EnableCaptureStackTrace)
            {
                AddStackTrace(handlerHolder, subscription);
            }
            dirty = true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        void AddStackTrace(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            lock (gate)
            {
                if (!capturedStackTraces.TryGetValue(handlerHolder, out var dict))
                {
                    dict = new Dictionary<IDisposable, StackTraceInfo>();
                    capturedStackTraces[handlerHolder] = dict;
                }

                dict.Add(subscription, new StackTraceInfo(new StackTrace(true)));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void DecrementSubscribe(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            Interlocked.Decrement(ref subscribeCount);
            if (options.EnableCaptureStackTrace)
            {
                RemoveStackTrace(handlerHolder, subscription);
            }
            dirty = true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        void RemoveStackTrace(IHandlerHolderMarker handlerHolder, IDisposable subscription)
        {
            lock (gate)
            {
                if (!capturedStackTraces.TryGetValue(handlerHolder, out var dict))
                {
                    return;
                }

                dict.Remove(subscription);
            }
        }

        internal void RemoveTargetDiagnostics(IHandlerHolderMarker targetHolder, int removeCount)
        {
            Interlocked.Add(ref subscribeCount, -removeCount);
            if (options.EnableCaptureStackTrace)
            {
                lock (gate)
                {
                    capturedStackTraces.Remove(targetHolder);
                }
            }
            dirty = true;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeDiagnosticsInfo.cs.meta
================================================
fileFormatVersion: 2
guid: 31a8e66be7b5f3e48a325afe580b9956
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeFilter.cs
================================================
using MessagePipe.Internal;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    public interface IMessagePipeFilterAttribute
    {
        Type Type { get; }
        int Order { get; }
    }

    public interface IMessagePipeFilter
    {
        int Order { get; set; }
    }

    // Sync filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class MessageHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public MessageHandlerFilterAttribute(Type type)
        {
            if (!typeof(IMessageHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not MessageHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IMessageHandlerFilter : IMessagePipeFilter
    {
    }

    public abstract class MessageHandlerFilter<TMessage> : IMessageHandlerFilter
    {
        public int Order { get; set; }
        public abstract void Handle(TMessage message, Action<TMessage> next);
    }

    // Async filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class AsyncMessageHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public AsyncMessageHandlerFilterAttribute(Type type)
        {
            if (!typeof(IAsyncMessageHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not AsyncMessageHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IAsyncMessageHandlerFilter : IMessagePipeFilter
    {
    }


    public abstract class AsyncMessageHandlerFilter<TMessage> : IAsyncMessageHandlerFilter
    {
        public int Order { get; set; }
        public abstract UniTask HandleAsync(TMessage message, CancellationToken cancellationToken, Func<TMessage, CancellationToken, UniTask> next);
    }

    // Req-Res Filter

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class RequestHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public RequestHandlerFilterAttribute(Type type)
        {
            if (!typeof(IRequestHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not RequestHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IRequestHandlerFilter : IMessagePipeFilter
    {

    }

    public abstract class RequestHandlerFilter<TRequest, TResponse> : IRequestHandlerFilter
    {
        public int Order { get; set; }
        public abstract TResponse Invoke(TRequest request, Func<TRequest, TResponse> next);
    }

    // async Req-Res

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [Preserve]
    public class AsyncRequestHandlerFilterAttribute : Attribute, IMessagePipeFilterAttribute
    {
        public Type Type { get; }
        public int Order { get; set; }

        [Preserve]
        public AsyncRequestHandlerFilterAttribute(Type type)
        {
            if (!typeof(IAsyncRequestHandlerFilter).IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not AsyncRequestHandlerFilter.");
            }
            this.Type = type;
        }
    }

    public interface IAsyncRequestHandlerFilter : IMessagePipeFilter
    {

    }

    public abstract class AsyncRequestHandlerFilter<TRequest, TResponse> : IAsyncRequestHandlerFilter
    {
        public int Order { get; set; }
        public abstract UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken, Func<TRequest, CancellationToken, UniTask<TResponse>> next);
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeFilter.cs.meta
================================================
fileFormatVersion: 2
guid: 966d1ba6951125747bde8ebc0f1f8d2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeOptions.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using MessagePipe.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif
namespace MessagePipe
{
    public enum AsyncPublishStrategy
    {
        Parallel, Sequential
    }

    public enum InstanceLifetime
    {
        Singleton, Scoped, Transient
    }

    public enum HandlingSubscribeDisposedPolicy
    {
        Ignore, Throw
    }

    internal static class HandlingSubscribeDisposedPolicyExtensions
    {
        public static IDisposable Handle(this HandlingSubscribeDisposedPolicy policy, string name)
        {
            if (policy == HandlingSubscribeDisposedPolicy.Throw)
            {
                throw new ObjectDisposedException(name);
            }
            return DisposableBag.Empty;
        }
    }

    public sealed class MessagePipeOptions
    {
        /// <summary>AsyncPublisher.PublishAsync's concurrent starategy, default is Parallel.</summary>
        public AsyncPublishStrategy DefaultAsyncPublishStrategy { get; set; }

#if !UNITY_2018_3_OR_NEWER
        public bool EnableAutoRegistration { get; set; }

#endif

        /// <summary>For diagnostics usage, enable MessagePipeDiagnosticsInfo.CapturedStacktraces; default is false.</summary>
        public bool EnableCaptureStackTrace { get; set; }

        /// <summary>Choose how work on subscriber.Subscribe when after disposed, default is Ignore.</summary>
        public HandlingSubscribeDisposedPolicy HandlingSubscribeDisposedPolicy { get; set; }

        /// <summary>Default publisher/subscribe's lifetime scope, default is Singleton.</summary>
        public InstanceLifetime InstanceLifetime { get; set; }

        /// <summary>Default IRequestHandler/IAsyncRequestHandler's lifetime scope, default is Scoped.</summary>
        public InstanceLifetime RequestHandlerLifetime { get; set; }

        public MessagePipeOptions()
        {
            this.DefaultAsyncPublishStrategy = AsyncPublishStrategy.Parallel;
            this.InstanceLifetime = InstanceLifetime.Singleton;
            this.RequestHandlerLifetime = InstanceLifetime.Scoped;
            this.EnableCaptureStackTrace = false;
            this.HandlingSubscribeDisposedPolicy = HandlingSubscribeDisposedPolicy.Ignore;
#if !UNITY_2018_3_OR_NEWER
            this.EnableAutoRegistration = true;
            this.autoregistrationAssemblies = null;
            this.autoregistrationTypes = null;
#endif
        }

#if !UNITY_2018_3_OR_NEWER

        // auto-registration

        internal Assembly[] autoregistrationAssemblies;
        internal Type[] autoregistrationTypes;

        public void SetAutoRegistrationSearchAssemblies(params Assembly[] assemblies)
        {
            autoregistrationAssemblies = assemblies;
        }

        public void SetAutoRegistrationSearchTypes(params Type[] types)
        {
            autoregistrationTypes = types;
        }

#endif

        // filters

        internal IEnumerable<Type> GetGlobalFilterTypes()
        {
            foreach (var item in messageHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in asyncMessageHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in requestHandlerFilters)
            {
                yield return item.FilterType;
            }

            foreach (var item in asyncRequestHandlerFilters)
            {
                yield return item.FilterType;
            }
        }

        // MessageHandlerFilter

        List<FilterDefinition> messageHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalMessageHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IMessageHandlerFilter));
            messageHandlerFilters.Add(new MessageHandlerFilterDefinition(type, order, typeof(MessageHandlerFilter<>)));
        }

#endif

        public void AddGlobalMessageHandlerFilter<T>(int order = 0)
            where T : IMessageHandlerFilter
        {
            messageHandlerFilters.Add(new MessageHandlerFilterDefinition(typeof(T), order, typeof(MessageHandlerFilter<>)));
        }

        internal (int count, IEnumerable<IMessageHandlerFilter>) GetGlobalMessageHandlerFilters(IServiceProvider provider, Type messageType)
        {
            return (messageHandlerFilters.Count, CreateFilters<IMessageHandlerFilter>(messageHandlerFilters, provider, messageType));
        }

        // AsyncMessageHandlerFilter

        List<FilterDefinition> asyncMessageHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalAsyncMessageHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IAsyncMessageHandlerFilter));
            asyncMessageHandlerFilters.Add(new MessageHandlerFilterDefinition(type, order, typeof(AsyncMessageHandlerFilter<>)));
        }

#endif

        public void AddGlobalAsyncMessageHandlerFilter<T>(int order = 0)
            where T : IAsyncMessageHandlerFilter
        {
            asyncMessageHandlerFilters.Add(new MessageHandlerFilterDefinition(typeof(T), order, typeof(AsyncMessageHandlerFilter<>)));
        }

        internal (int count, IEnumerable<IAsyncMessageHandlerFilter>) GetGlobalAsyncMessageHandlerFilters(IServiceProvider provider, Type messageType)
        {
            return (asyncMessageHandlerFilters.Count, CreateFilters<IAsyncMessageHandlerFilter>(asyncMessageHandlerFilters, provider, messageType));
        }

        // RequestHandlerFilter

        List<FilterDefinition> requestHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalRequestHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IRequestHandlerFilter));
            requestHandlerFilters.Add(new RequestHandlerFilterDefinition(type, order, typeof(RequestHandlerFilter<,>)));
        }

#endif

        public void AddGlobalRequestHandlerFilter<T>(int order = 0)
            where T : IRequestHandlerFilter
        {
            requestHandlerFilters.Add(new RequestHandlerFilterDefinition(typeof(T), order, typeof(RequestHandlerFilter<,>)));
        }

        internal (int, IEnumerable<IRequestHandlerFilter>) GetGlobalRequestHandlerFilters(IServiceProvider provider, Type requestType, Type responseType)
        {
            return (requestHandlerFilters.Count, CreateFilters<IRequestHandlerFilter>(requestHandlerFilters, provider, requestType, responseType));
        }

        //  AsyncRequestHandlerFilter

        List<FilterDefinition> asyncRequestHandlerFilters = new List<FilterDefinition>();

#if !UNITY_2018_3_OR_NEWER

        /// <summary>
        /// If register open generics(typeof(MyFilter&lt;&gt;)) to register all message types.
        /// </summary>
        public void AddGlobalAsyncRequestHandlerFilter(Type type, int order = 0)
        {
            ValidateFilterType(type, typeof(IAsyncRequestHandlerFilter));
            asyncRequestHandlerFilters.Add(new RequestHandlerFilterDefinition(type, order, typeof(AsyncRequestHandlerFilter<,>)));
        }

#endif

        public void AddGlobalAsyncRequestHandlerFilter<T>(int order = 0)
            where T : IAsyncRequestHandlerFilter
        {
            asyncRequestHandlerFilters.Add(new RequestHandlerFilterDefinition(typeof(T), order, typeof(AsyncRequestHandlerFilter<,>)));
        }

        internal (int, IEnumerable<IAsyncRequestHandlerFilter>) GetGlobalAsyncRequestHandlerFilters(IServiceProvider provider, Type requestType, Type responseType)
        {
            return (asyncRequestHandlerFilters.Count, CreateFilters<IAsyncRequestHandlerFilter>(asyncRequestHandlerFilters, provider, requestType, responseType));
        }

        static IEnumerable<T> CreateFilters<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type messageType)
            where T : IMessagePipeFilter
        {
            if (filterDefinitions.Count == 0) return Array.Empty<T>();
            return CreateFiltersCore<T>(filterDefinitions, provider, messageType);
        }

        static IEnumerable<T> CreateFiltersCore<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type messageType)
            where T : IMessagePipeFilter
        {
            for (int i = 0; i < filterDefinitions.Count; i++)
            {
                var def = filterDefinitions[i] as MessageHandlerFilterDefinition;
                if (def == null) continue;
                var filterType = def.FilterType;
                if (def.IsOpenGenerics)
                {
                    filterType = filterType.MakeGenericType(messageType);
                }
                else if (def.MessageType != messageType)
                {
                    continue;
                }

                var filter = (T)provider.GetRequiredService(filterType);
                filter.Order = def.Order;
                yield return filter;
            }
        }

        static IEnumerable<T> CreateFilters<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type requestType, Type responseType)
            where T : IMessagePipeFilter
        {
            if (filterDefinitions.Count == 0) return Array.Empty<T>();
            return CreateFiltersCore<T>(filterDefinitions, provider, requestType, responseType);
        }

        static IEnumerable<T> CreateFiltersCore<T>(List<FilterDefinition> filterDefinitions, IServiceProvider provider, Type requestType, Type responseType)
            where T : IMessagePipeFilter
        {
            for (int i = 0; i < filterDefinitions.Count; i++)
            {
                var def = filterDefinitions[i] as RequestHandlerFilterDefinition;
                if (def == null) continue;
                var filterType = def.FilterType;
                if (def.IsOpenGenerics)
                {
                    filterType = filterType.MakeGenericType(requestType, responseType);
                }
                else if (!(def.RequestType == requestType && def.ResponseType == responseType))
                {
                    continue;
                }

                var filter = (T)provider.GetRequiredService(filterType);
                filter.Order = def.Order;
                yield return filter;
            }
        }

        void ValidateFilterType(Type type, Type filterType)
        {
            if (!filterType.IsAssignableFrom(type))
            {
                throw new ArgumentException($"{type.FullName} is not {filterType.Name}");
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/MessagePipeOptions.cs.meta
================================================
fileFormatVersion: 2
guid: 4941c4967c104e24fa0f99858dcc904c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/PredicateFilter.cs
================================================
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    internal sealed class PredicateFilter<T> : MessageHandlerFilter<T>
    {
        readonly Func<T, bool> predicate;

        public PredicateFilter(Func<T, bool> predicate)
        {
            this.predicate = predicate;
            this.Order = int.MinValue; // predicate filter first.
        }

        public override void Handle(T message, Action<T> next)
        {
            if (predicate(message))
            {
                next(message);
            }
        }
    }

    internal sealed class AsyncPredicateFilter<T> : AsyncMessageHandlerFilter<T>
    {
        readonly Func<T, bool> predicate;

        public AsyncPredicateFilter(Func<T, bool> predicate)
        {
            this.predicate = predicate;
            this.Order = int.MinValue; // predicate filter first.
        }

        public override UniTask HandleAsync(T message, CancellationToken cancellationToken, Func<T, CancellationToken, UniTask> next)
        {
            if (predicate(message))
            {
                return next(message, cancellationToken);
            }
            return default(UniTask);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/PredicateFilter.cs.meta
================================================
fileFormatVersion: 2
guid: db2ec1225e28c194d9701f9af19887c4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/RequestHandler.cs
================================================
using MessagePipe.Internal;
using System.Collections.Generic;
using System.Linq;

namespace MessagePipe
{
    [Preserve]
    public sealed class RequestHandler<TRequest, TResponse> : IRequestHandler<TRequest, TResponse>
    {
        readonly IRequestHandlerCore<TRequest, TResponse> handler;

        [Preserve]
        public RequestHandler(IRequestHandlerCore<TRequest, TResponse> handler, FilterAttachedRequestHandlerFactory handlerFactory)
        {
            this.handler = handlerFactory.CreateRequestHandler<TRequest, TResponse>(handler);
        }

        public TResponse Invoke(TRequest request)
        {
            return handler.Invoke(request);
        }
    }

    [Preserve]
    public sealed class RequestAllHandler<TRequest, TResponse> : IRequestAllHandler<TRequest, TResponse>
    {
        readonly IRequestHandlerCore<TRequest, TResponse>[] handlers;

        [Preserve]
        public RequestAllHandler(IEnumerable<IRequestHandlerCore<TRequest, TResponse>> handlers, FilterAttachedRequestHandlerFactory handlerFactory)
        {
            var collection = (handlers as ICollection<IRequestHandlerCore<TRequest, TResponse>>) ?? handlers.ToArray();

            var array = new IRequestHandlerCore<TRequest, TResponse>[collection.Count];
            var i = 0;
            foreach (var item in collection)
            {
                array[i++] = handlerFactory.CreateRequestHandler(item);
            }

            this.handlers = array;
        }

        public TResponse[] InvokeAll(TRequest request)
        {
            var responses = new TResponse[handlers.Length];

            for (int i = 0; i < handlers.Length; i++)
            {
                responses[i] = handlers[i].Invoke(request);
            }

            return responses;
        }

        public IEnumerable<TResponse> InvokeAllLazy(TRequest request)
        {
            for (int i = 0; i < handlers.Length; i++)
            {
                yield return handlers[i].Invoke(request);
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/RequestHandler.cs.meta
================================================
fileFormatVersion: 2
guid: 404063e67b7fdd54ca1801cf6aa9e633
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/ServiceCollectionExtensions.cs
================================================
using MessagePipe;
using MessagePipe.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
#endif
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#if !UNITY_2018_3_OR_NEWER
namespace Microsoft.Extensions.DependencyInjection
#else
namespace MessagePipe
#endif
{
    /// <summary>
    /// An interface for configuring MessagePipe services.
    /// </summary>
    public interface IMessagePipeBuilder
    {
        IServiceCollection Services { get; }
    }

    public class MessagePipeBuilder : IMessagePipeBuilder
    {
        public IServiceCollection Services { get; }

        public MessagePipeBuilder(IServiceCollection services)
        {
            Services = services;
        }
    }

    public static class ServiceCollectionExtensions
    {
        public static IMessagePipeBuilder AddMessagePipe(this IServiceCollection services)
        {
            return AddMessagePipe(services, _ => { });
        }

        public static IMessagePipeBuilder AddMessagePipe(this IServiceCollection services, Action<MessagePipeOptions> configure)
        {
            var options = new MessagePipeOptions();
            configure(options);
            services.AddSingleton(options); // add as singleton instance
            services.AddSingleton(typeof(MessagePipeDiagnosticsInfo));
            services.AddSingleton(typeof(EventFactory));

            // filters.
            // attribute and order is deterministic at compile, so use Singleton lifetime of cache.
            services.AddSingleton(typeof(AttributeFilterProvider<MessageHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<AsyncMessageHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<RequestHandlerFilterAttribute>));
            services.AddSingleton(typeof(AttributeFilterProvider<AsyncRequestHandlerFilterAttribute>));
            services.AddSingleton(typeof(FilterAttachedMessageHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedAsyncMessageHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedRequestHandlerFactory));
            services.AddSingleton(typeof(FilterAttachedAsyncRequestHandlerFactory));
            foreach (var item in options.GetGlobalFilterTypes())
            {
                services.TryAddTransient(item); // filter itself is Transient
            }

#if !UNITY_2018_3_OR_NEWER || (MESSAGEPIPE_OPENGENERICS_SUPPORT && UNITY_2022_1_OR_NEWER)
            // open generics implemntations(.NET Only)

            {
                var lifetime = options.InstanceLifetime; // pubsub lifetime

                // keyless PubSub
                services.Add(typeof(MessageBrokerCore<>), lifetime);
                services.Add(typeof(IPublisher<>), typeof(MessageBroker<>), lifetime);
                services.Add(typeof(ISubscriber<>), typeof(MessageBroker<>), lifetime);
                services.Add(typeof(BufferedMessageBrokerCore<>), lifetime);
                services.Add(typeof(IBufferedPublisher<>), typeof(BufferedMessageBroker<>), lifetime);
                services.Add(typeof(IBufferedSubscriber<>), typeof(BufferedMessageBroker<>), lifetime);

                // keyless-variation
                services.Add(typeof(SingletonMessageBrokerCore<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonPublisher<>), typeof(SingletonMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonSubscriber<>), typeof(SingletonMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedMessageBrokerCore<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedPublisher<>), typeof(ScopedMessageBroker<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedSubscriber<>), typeof(ScopedMessageBroker<>), InstanceLifetime.Scoped);

                // keyless PubSub async
                services.Add(typeof(AsyncMessageBrokerCore<>), lifetime);
                services.Add(typeof(IAsyncPublisher<>), typeof(AsyncMessageBroker<>), lifetime);
                services.Add(typeof(IAsyncSubscriber<>), typeof(AsyncMessageBroker<>), lifetime);
                services.Add(typeof(BufferedAsyncMessageBrokerCore<>), lifetime);
                services.Add(typeof(IBufferedAsyncPublisher<>), typeof(BufferedAsyncMessageBroker<>), lifetime);
                services.Add(typeof(IBufferedAsyncSubscriber<>), typeof(BufferedAsyncMessageBroker<>), lifetime);

                // keyless-async-variation
                services.Add(typeof(SingletonAsyncMessageBrokerCore<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncPublisher<>), typeof(SingletonAsyncMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncSubscriber<>), typeof(SingletonAsyncMessageBroker<>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedAsyncMessageBrokerCore<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncPublisher<>), typeof(ScopedAsyncMessageBroker<>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncSubscriber<>), typeof(ScopedAsyncMessageBroker<>), InstanceLifetime.Scoped);

                // keyed PubSub
                services.Add(typeof(MessageBrokerCore<,>), lifetime);
                services.Add(typeof(IPublisher<,>), typeof(MessageBroker<,>), lifetime);
                services.Add(typeof(ISubscriber<,>), typeof(MessageBroker<,>), lifetime);

                // keyed-variation
                services.Add(typeof(SingletonMessageBrokerCore<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonPublisher<,>), typeof(SingletonMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonSubscriber<,>), typeof(SingletonMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedMessageBrokerCore<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedPublisher<,>), typeof(ScopedMessageBroker<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedSubscriber<,>), typeof(ScopedMessageBroker<,>), InstanceLifetime.Scoped);

                // keyed PubSub async
                services.Add(typeof(AsyncMessageBrokerCore<,>), lifetime);
                services.Add(typeof(IAsyncPublisher<,>), typeof(AsyncMessageBroker<,>), lifetime);
                services.Add(typeof(IAsyncSubscriber<,>), typeof(AsyncMessageBroker<,>), lifetime);

                // keyed-async-variation
                services.Add(typeof(SingletonAsyncMessageBrokerCore<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncPublisher<,>), typeof(SingletonAsyncMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ISingletonAsyncSubscriber<,>), typeof(SingletonAsyncMessageBroker<,>), InstanceLifetime.Singleton);
                services.Add(typeof(ScopedAsyncMessageBrokerCore<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncPublisher<,>), typeof(ScopedAsyncMessageBroker<,>), InstanceLifetime.Scoped);
                services.Add(typeof(IScopedAsyncSubscriber<,>), typeof(ScopedAsyncMessageBroker<,>), InstanceLifetime.Scoped);
            }

            var lifetime2 = options.RequestHandlerLifetime; // requesthandler lifetime

#endif
#if !UNITY_2018_3_OR_NEWER
            // RequestHandler
            services.Add(typeof(IRequestHandler<,>), typeof(RequestHandler<,>), lifetime2);
            services.Add(typeof(IAsyncRequestHandler<,>), typeof(AsyncRequestHandler<,>), lifetime2);

            // RequestAll
            services.Add(typeof(IRequestAllHandler<,>), typeof(RequestAllHandler<,>), lifetime2);
            services.Add(typeof(IAsyncRequestAllHandler<,>), typeof(AsyncRequestAllHandler<,>), lifetime2);
            
            // auto registration is .NET only.
            if (options.EnableAutoRegistration)
            {
                // auto register filter and requesthandler
                // request handler is option's lifetime, filter is transient
                if (options.autoregistrationAssemblies == null && options.autoregistrationTypes == null)
                {
                    AddRequestHandlerAndFilterFromTypes(services, lifetime2, TypeCollector.CollectFromCurrentDomain());
                }
                else
                {
                    var fromAssemblies = (options.autoregistrationAssemblies != null)
                        ? TypeCollector.CollectFromAssemblies(options.autoregistrationAssemblies)
                        : Enumerable.Empty<Type>();
                    var types = options.autoregistrationTypes ?? Enumerable.Empty<Type>();

                    AddRequestHandlerAndFilterFromTypes(services, lifetime2, fromAssemblies.Concat(types).Distinct());
                }
            }

#endif

            return new MessagePipeBuilder(services);
        }

#if !UNITY_2018_3_OR_NEWER

        public static IMessagePipeBuilder AddMessageHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IMessageHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddAsyncMessageHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IAsyncMessageHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddRequestHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IRequestHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddAsyncRequestHandlerFilter<T>(this IMessagePipeBuilder builder)
            where T : class, IAsyncRequestHandlerFilter
        {
            builder.Services.TryAddTransient<T>();
            return builder;
        }

        public static IMessagePipeBuilder AddRequestHandler(this IMessagePipeBuilder builder, Type type)
        {
            return AddRequestHandlerCore(builder, type, typeof(IRequestHandlerCore<,>));
        }

        public static IMessagePipeBuilder AddRequestHandler<T>(this IMessagePipeBuilder builder)
            where T : IRequestHandler
        {
            return AddRequestHandler(builder, typeof(T));
        }

        public static IMessagePipeBuilder AddAsyncRequestHandler(this IMessagePipeBuilder builder, Type type)
        {
            return AddRequestHandlerCore(builder, type, typeof(IAsyncRequestHandlerCore<,>));
        }

        public static IMessagePipeBuilder AddAsyncRequestHandler<T>(this IMessagePipeBuilder builder)
            where T : IAsyncRequestHandler
        {
            return AddAsyncRequestHandler(builder, typeof(T));
        }

        static IMessagePipeBuilder AddRequestHandlerCore(IMessagePipeBuilder builder, Type type, Type coreType)
        {
            var options = builder.Services.FirstOrDefault(x => x.ServiceType == typeof(MessagePipeOptions));
            if (options == null)
            {
                throw new ArgumentException($"Not yet added MessagePipeOptions, please call services.AddMessagePipe() before.");
            }
            var isAsync = (coreType == typeof(IAsyncRequestHandlerCore<,>));

            var registered = false;
            foreach (var interfaceType in type.GetInterfaces())
            {
                if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == coreType)
                {
                    var iType = interfaceType;
                    if (type.IsGenericType && !type.IsConstructedGenericType)
                    {
                        if (!interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            throw new ArgumentException("partial open generic type is not supported. Type:" + type.FullName);
                        }

                        iType = interfaceType.GetGenericTypeDefinition();
                    }

                    registered = true;
                    builder.Services.Add(iType, type, ((MessagePipeOptions)options.ImplementationInstance!).RequestHandlerLifetime);
                }
            }

            if (!registered)
            {
                throw new ArgumentException($"{type.FullName} does not implement {coreType.Name.Replace("Core", "")}.");
            }
            else if (isAsync)
            {
                AsyncRequestHandlerRegistory.Add(coreType);
            }

            return builder;
        }

        public static IMessagePipeBuilder AddInMemoryDistributedMessageBroker(this IMessagePipeBuilder builder)
        {
            var options = builder.Services.FirstOrDefault(x => x.ServiceType == typeof(MessagePipeOptions));
            if (options == null)
            {
                throw new ArgumentException($"Not yet added MessagePipeOptions, please call services.AddMessagePipe() before.");
            }

            var lifetime = ((MessagePipeOptions)options.ImplementationInstance!).InstanceLifetime;
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(InMemoryDistributedPublisher<,>), lifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(InMemoryDistributedSubscriber<,>), lifetime);

            return builder;
        }

        internal static void Add(this IServiceCollection services, Type serviceType, InstanceLifetime lifetime)
        {
            var lt = (lifetime == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                   : (lifetime == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                   : ServiceLifetime.Transient;
            services.Add(new ServiceDescriptor(serviceType, serviceType, lt));
        }

        internal static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime lifetime)
        {
            var lt = (lifetime == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                   : (lifetime == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                   : ServiceLifetime.Transient;
            services.Add(new ServiceDescriptor(serviceType, implementationType, lt));
        }

        static void AddRequestHandlerAndFilterFromTypes(IServiceCollection services, InstanceLifetime requestHandlerLifetime, IEnumerable<Type> targetTypes)
        {
            foreach (var objectType in targetTypes)
            {
                if (objectType.IsInterface || objectType.IsAbstract) continue;
                if (objectType.GetCustomAttributes(typeof(IgnoreAutoRegistration), false).Length != 0) continue;

                foreach (var interfaceType in objectType.GetInterfaces())
                {
                    if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == typeof(IRequestHandlerCore<,>))
                    {
                        if (!objectType.IsGenericType || objectType.IsConstructedGenericType)
                        {
                            services.Add(interfaceType, objectType, requestHandlerLifetime);
                        }
                        else if (interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            services.Add(typeof(IRequestHandlerCore<,>), objectType, requestHandlerLifetime);
                        }
                        continue;
                    }

                    if (interfaceType.IsGenericType && interfaceType.GetGenericTypeDefinition() == typeof(IAsyncRequestHandlerCore<,>))
                    {
                        if (!objectType.IsGenericType || objectType.IsConstructedGenericType)
                        {
                            services.Add(interfaceType, objectType, requestHandlerLifetime);
                        }
                        else if (interfaceType.GetGenericArguments().All(x => x.IsGenericParameter))
                        {
                            services.Add(typeof(IAsyncRequestHandlerCore<,>), objectType, requestHandlerLifetime);
                        }

                        AsyncRequestHandlerRegistory.Add(objectType);
                        continue;
                    }
                }

                foreach (var baseType in objectType.GetBaseTypes())
                {
                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(MessageHandlerFilter<>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(AsyncMessageHandlerFilter<>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(RequestHandlerFilter<,>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }

                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == typeof(AsyncRequestHandlerFilter<,>))
                    {
                        services.TryAddTransient(objectType);
                        goto NEXT_TYPE;
                    }
                }

            NEXT_TYPE:
                continue;
            }
        }
#endif
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/ServiceCollectionExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 6517efc3f0b91a54cb1b53c9ab318ccd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.AsAsyncEnumerable.cs
================================================
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
#if !UNITY_2018_3_OR_NEWER
using System.Threading.Channels;
#endif

namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static IUniTaskAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new AsyncEnumerableAsyncSubscriber<TMessage>(subscriber, filters);
        }

        public static IUniTaskAsyncEnumerable<TMessage> AsAsyncEnumerable<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new BufferedAsyncEnumerableAsyncSubscriber<TMessage>(subscriber, filters);
        }

        public static IUniTaskAsyncEnumerable<TMessage> AsAsyncEnumerable<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, params AsyncMessageHandlerFilter<TMessage>[] filters)
            
        {
            return new AsyncEnumerableAsyncSubscriber<TKey, TMessage>(key, subscriber, filters);
        }
    }

    internal class AsyncEnumerableAsyncSubscriber<TMessage> : IUniTaskAsyncEnumerable<TMessage>
    {
        readonly IAsyncSubscriber<TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public AsyncEnumerableAsyncSubscriber(IAsyncSubscriber<TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IUniTaskAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            disposable.Disposable = subscriber.Subscribe(e, filters);
            return e;
        }
    }

    internal class BufferedAsyncEnumerableAsyncSubscriber<TMessage> : IUniTaskAsyncEnumerable<TMessage>
    {
        readonly IBufferedAsyncSubscriber<TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public BufferedAsyncEnumerableAsyncSubscriber(IBufferedAsyncSubscriber<TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IUniTaskAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            var task = subscriber.SubscribeAsync(e, filters);
            SetDisposableAsync(task, disposable);
            return e;
        }

        async void SetDisposableAsync(UniTask<IDisposable> task, SingleAssignmentDisposable d)
        {
            d.Disposable = await task;
        }
    }

    internal class AsyncEnumerableAsyncSubscriber<TKey, TMessage> : IUniTaskAsyncEnumerable<TMessage>
        
    {
        readonly TKey key;
        readonly IAsyncSubscriber<TKey, TMessage> subscriber;
        readonly AsyncMessageHandlerFilter<TMessage>[] filters;

        public AsyncEnumerableAsyncSubscriber(TKey key, IAsyncSubscriber<TKey, TMessage> subscriber, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            this.key = key;
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IUniTaskAsyncEnumerator<TMessage> GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            var disposable = DisposableBag.CreateSingleAssignment();
            var e = new AsyncMessageHandlerEnumerator<TMessage>(disposable, cancellationToken);
            disposable.Disposable = subscriber.Subscribe(key, e, filters);
            return e;
        }
    }

    internal class AsyncMessageHandlerEnumerator<TMessage> : IUniTaskAsyncEnumerator<TMessage>, IAsyncMessageHandler<TMessage>
    {
        Channel<TMessage> channel;
        CancellationToken cancellationToken;
        SingleAssignmentDisposable singleAssignmentDisposable;

        public AsyncMessageHandlerEnumerator(SingleAssignmentDisposable singleAssignmentDisposable, CancellationToken cancellationToken)
        {
            this.singleAssignmentDisposable = singleAssignmentDisposable;
            this.cancellationToken = cancellationToken;
#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<TMessage>(new UnboundedChannelOptions()
            {
                SingleWriter = true,
                SingleReader = true,
                AllowSynchronousContinuations = true
            });
#else
                this.channel = Channel.CreateSingleConsumerUnbounded<TMessage>();
#endif
        }

        TMessage IUniTaskAsyncEnumerator<TMessage>.Current
        {
            get
            {
                if (channel.Reader.TryRead(out var msg))
                {
                    return msg;
                }
                throw new InvalidOperationException("Message is not buffered in Channel.");
            }
        }

        UniTask<bool> IUniTaskAsyncEnumerator<TMessage>.MoveNextAsync()
        {
            return channel.Reader.WaitToReadAsync(cancellationToken);
        }

        UniTask IAsyncMessageHandler<TMessage>.HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            channel.Writer.TryWrite(message);
            return default;
        }

        UniTask IUniTaskAsyncDisposable.DisposeAsync()
        {
            singleAssignmentDisposable.Dispose(); // unsubscribe message.
            return default;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.AsAsyncEnumerable.cs.meta
================================================
fileFormatVersion: 2
guid: 1f1690006c32a3d419ac194f2e583f11
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.AsObservable.cs
================================================
using System;


namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static IObservable<TMessage> AsObservable<TMessage>(this ISubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ObservableSubscriber<TMessage>(subscriber, filters);
        }

        public static IObservable<TMessage> AsObservable<TMessage>(this IBufferedSubscriber<TMessage> subscriber, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new ObservableBufferedSubscriber<TMessage>(subscriber, filters);
        }

        public static IObservable<TMessage> AsObservable<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, params MessageHandlerFilter<TMessage>[] filters)
            
        {
            return new ObservableSubscriber<TKey, TMessage>(key, subscriber, filters);
        }
    }

    internal sealed class ObservableSubscriber<TKey, TMessage> : IObservable<TMessage>
        
    {
        readonly TKey key;
        readonly ISubscriber<TKey, TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableSubscriber(TKey key, ISubscriber<TKey, TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.key = key;
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(key, new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObservableSubscriber<TMessage> : IObservable<TMessage>
    {
        readonly ISubscriber<TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableSubscriber(ISubscriber<TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObservableBufferedSubscriber<TMessage> : IObservable<TMessage>
    {
        readonly IBufferedSubscriber<TMessage> subscriber;
        readonly MessageHandlerFilter<TMessage>[] filters;

        public ObservableBufferedSubscriber(IBufferedSubscriber<TMessage> subscriber, MessageHandlerFilter<TMessage>[] filters)
        {
            this.subscriber = subscriber;
            this.filters = filters;
        }

        public IDisposable Subscribe(IObserver<TMessage> observer)
        {
            return subscriber.Subscribe(new ObserverMessageHandler<TMessage>(observer), filters);
        }
    }

    internal sealed class ObserverMessageHandler<TMessage> : IMessageHandler<TMessage>
    {
        readonly IObserver<TMessage> observer;

        public ObserverMessageHandler(IObserver<TMessage> observer)
        {
            this.observer = observer;
        }

        public void Handle(TMessage message)
        {
            observer.OnNext(message);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.AsObservable.cs.meta
================================================
fileFormatVersion: 2
guid: 57264acd3fea83247bacc12b86ec0a8c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.cs
================================================
using MessagePipe.Internal;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        // pubsub-keyless-sync

        public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this ISubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IBufferedSubscriber<TMessage> subscriber, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IBufferedSubscriber<TMessage> subscriber, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        // pubsub-keyless-async

        public static IDisposable Subscribe<TMessage>(this IAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return subscriber.Subscribe(new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TMessage>(this IAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static UniTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            return subscriber.SubscribeAsync(new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        public static UniTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(subscriber, handler, predicate, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public static UniTask<IDisposable> SubscribeAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.SubscribeAsync(new AnonymousAsyncMessageHandler<TMessage>(handler), filters, cancellationToken);
        }

        // pubsub-key-sync

        public static IDisposable Subscribe<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, params MessageHandlerFilter<TMessage>[] filters)
            
        {
            return subscriber.Subscribe(key, new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, Action<TMessage> handler, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
            
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(key, new AnonymousMessageHandler<TMessage>(handler), filters);
        }

        // pubsub-key-async

        public static IDisposable Subscribe<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, params AsyncMessageHandlerFilter<TMessage>[] filters)
            
        {
            return subscriber.Subscribe(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }

        public static IDisposable Subscribe<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, Func<TMessage, CancellationToken, UniTask> handler, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
            
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return subscriber.Subscribe(key, new AnonymousAsyncMessageHandler<TMessage>(handler), filters);
        }
    }

    internal sealed class AnonymousMessageHandler<TMessage> : IMessageHandler<TMessage>
    {
        readonly Action<TMessage> handler;

        public AnonymousMessageHandler(Action<TMessage> handler)
        {
            this.handler = handler;
        }

        public void Handle(TMessage message)
        {
            handler.Invoke(message);
        }
    }

    internal sealed class AnonymousAsyncMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>
    {
        readonly Func<TMessage, CancellationToken, UniTask> handler;

        public AnonymousAsyncMessageHandler(Func<TMessage, CancellationToken, UniTask> handler)
        {
            this.handler = handler;
        }

        public UniTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            return handler.Invoke(message, cancellationToken);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: ed3c72e122a9d5548b926e103edcd17a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.FirstAsync.cs
================================================
using System;
using MessagePipe.Internal;
using System.Threading;
using Cysharp.Threading.Tasks;


namespace MessagePipe
{
    public static partial class SubscriberExtensions
    {
        public static UniTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new UniTask<TMessage>(new FirstAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TMessage>(this ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new UniTask<TMessage>(new FirstAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }
        public static UniTask<TMessage> FirstAsync<TMessage>(this IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
        {
            return new UniTask<TMessage>(new FirstAsyncBufferedMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TMessage>(this IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new UniTask<TMessage>(new FirstAsyncBufferedMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TMessage>(this IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return new UniTask<TMessage>(new FirstAsyncAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TMessage>(this IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new UniTask<TMessage>(new FirstAsyncAsyncMessageHandler<TMessage>(subscriber, cancellationToken, filters), 0);
        }

        public static async UniTask<TMessage> FirstAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            return await new UniTask<TMessage>(await FirstAsyncAsyncBufferedMessageHandler<TMessage>.CreateAsync(subscriber, cancellationToken, filters), 0);
        }

        public static async UniTask<TMessage> FirstAsync<TMessage>(this IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return await new UniTask<TMessage>(await FirstAsyncAsyncBufferedMessageHandler<TMessage>.CreateAsync(subscriber, cancellationToken, filters), 0);
        }
        public static UniTask<TMessage> FirstAsync<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, params MessageHandlerFilter<TMessage>[] filters)
            
        {
            return new UniTask<TMessage>(new FirstAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TKey, TMessage>(this ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params MessageHandlerFilter<TMessage>[] filters)
            
        {
            var predicateFilter = new PredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new UniTask<TMessage>(new FirstAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, params AsyncMessageHandlerFilter<TMessage>[] filters)
            
        {
            return new UniTask<TMessage>(new FirstAsyncAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }

        public static UniTask<TMessage> FirstAsync<TKey, TMessage>(this IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, Func<TMessage, bool> predicate, params AsyncMessageHandlerFilter<TMessage>[] filters)
            
        {
            var predicateFilter = new AsyncPredicateFilter<TMessage>(predicate);
            filters = (filters.Length == 0)
                ? new[] { predicateFilter }
                : ArrayUtil.ImmutableAdd(filters, predicateFilter);

            return new UniTask<TMessage>(new FirstAsyncAsyncMessageHandler<TKey, TMessage>(subscriber, key, cancellationToken, filters), 0);
        }
    }

    internal sealed class FirstAsyncMessageHandler<TKey, TMessage> : IMessageHandler<TMessage>, IUniTaskSource<TMessage>
        
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public FirstAsyncMessageHandler(ISubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.TrySetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(key, this, filters);
            }
            catch (Exception ex)
            {
                this.core.TrySetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncMessageHandler<TKey, TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.TrySetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }
    internal sealed class FirstAsyncMessageHandler<TMessage> : IMessageHandler<TMessage>, IUniTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public FirstAsyncMessageHandler(ISubscriber<TMessage> subscriber, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.TrySetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.TrySetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncMessageHandler<TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.TrySetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncBufferedMessageHandler<TMessage> : IMessageHandler<TMessage>, IUniTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public FirstAsyncBufferedMessageHandler(IBufferedSubscriber<TMessage> subscriber, CancellationToken cancellationToken, MessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.TrySetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.TrySetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncBufferedMessageHandler<TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public void Handle(TMessage message)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    core.TrySetResult(message);
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncMessageHandler<TKey, TMessage> : IAsyncMessageHandler<TMessage>, IUniTaskSource<TMessage>
        
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public FirstAsyncAsyncMessageHandler(IAsyncSubscriber<TKey, TMessage> subscriber, TKey key, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.TrySetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(key, this, filters);
            }
            catch (Exception ex)
            {
                this.core.TrySetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncAsyncMessageHandler<TKey, TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public UniTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.TrySetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.TrySetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>, IUniTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public FirstAsyncAsyncMessageHandler(IAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                this.core.TrySetException(new OperationCanceledException(cancellationToken));
                return;
            }

            try
            {
                this.subscription = subscriber.Subscribe(this, filters);
            }
            catch (Exception ex)
            {
                this.core.TrySetException(ex);
                return;
            }

            if (handleCalled != 0)
            {
                this.subscription?.Dispose();
                return;
            }

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationToken = cancellationToken;
                this.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, this, false);
            }
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncAsyncMessageHandler<TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public UniTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.TrySetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.TrySetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }

    internal sealed class FirstAsyncAsyncBufferedMessageHandler<TMessage> : IAsyncMessageHandler<TMessage>, IUniTaskSource<TMessage>
    {
        int handleCalled = 0;
        IDisposable subscription;
        CancellationToken cancellationToken;
        CancellationTokenRegistration cancellationTokenRegistration;
        UniTaskCompletionSourceCore<TMessage> core;

        static readonly Action<object> cancelCallback = Cancel;

        public static async UniTask<FirstAsyncAsyncBufferedMessageHandler<TMessage>> CreateAsync(IBufferedAsyncSubscriber<TMessage> subscriber, CancellationToken cancellationToken, AsyncMessageHandlerFilter<TMessage>[] filters)
        {
            var self = new FirstAsyncAsyncBufferedMessageHandler<TMessage>();
            if (cancellationToken.IsCancellationRequested)
            {
                self.core.TrySetException(new OperationCanceledException(cancellationToken));
                return self;
            }

            try
            {
                self.subscription = await subscriber.SubscribeAsync(self, filters).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                self.core.TrySetException(ex);
                return self;
            }

            if (self.handleCalled != 0)
            {
                self.subscription?.Dispose();
                return self;
            }

            if (cancellationToken.CanBeCanceled)
            {
                self.cancellationToken = cancellationToken;
                self.cancellationTokenRegistration = cancellationToken.Register(cancelCallback, self, false);
            }
            return self;
        }

        static void Cancel(object state)
        {
            var self = (FirstAsyncAsyncBufferedMessageHandler<TMessage>)state;
            self.subscription?.Dispose();
            self.core.TrySetException(new OperationCanceledException(self.cancellationToken));
        }

        public UniTask HandleAsync(TMessage message, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref handleCalled) == 1)
            {
                try
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        core.TrySetException(new OperationCanceledException(cancellationToken));
                    }
                    else
                    {
                        core.TrySetResult(message);
                    }
                }
                finally
                {
                    subscription?.Dispose();
                    cancellationTokenRegistration.Dispose();
                }
            }
            return default;
        }

        void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }

        public TMessage GetResult(short token)
        {
            return core.GetResult(token);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/SubscriberExtensions.FirstAsync.cs.meta
================================================
fileFormatVersion: 2
guid: 62041e06f03db384c86357d47a829902
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity.meta
================================================
fileFormatVersion: 2
guid: 2ad1b59197920034ea740de5425525c3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/ArrayUtil.cs
================================================
using System;
using System.Collections.Generic;
using System.Text;

namespace MessagePipe.Internal
{
    internal static class ArrayUtil
    {
        public static T[] ImmutableAdd<T>(T[] source, T item)
        {
            var dest = new T[source.Length + 1];
            Array.Copy(source, 0, dest, 0, source.Length);
            dest[dest.Length - 1] = item;
            return dest;
        }

        public static T[] ImmutableRemove<T, TState>(T[] source, Func<T, TState, bool> match, TState state)
        {
            if (source.Length == 0) return source;

            int index = -1;
            for (int i = 0; i < source.Length; i++)
            {
                if (match(source[i], state))
                {
                    index = i;
                    break;
                }
            }

            if (index == -1)
            {
                return source;
            }

            if (source.Length == 1)
            {
                return Array.Empty<T>();
            }

            var dest = new T[source.Length - 1];

            if (index == 0)
            {
                // copy [1, last]
                Array.Copy(source, 1, dest, 0, dest.Length);
            }
            else if (index == source.Length - 1)
            {
                // copy [0, last-1]
                Array.Copy(source, 0, dest, 0, dest.Length);
            }
            else
            {
                // copy [0, index -1], [index+1-last]
                Array.Copy(source, 0, dest, 0, index);
                Array.Copy(source, index + 1, dest, index, source.Length - index - 1);
            }

            return dest;
        }

        public static IEnumerable<T> Concat<T>(T[] source1, T[] source2)
        {
            if (source1.Length != 0)
            {
                foreach (var item in source1)
                {
                    yield return item;
                }
            }

            if (source2.Length != 0)
            {
                foreach (var item in source2)
                {
                    yield return item;
                }
            }
        }

        public static IEnumerable<T> Concat<T>(T[] source1, T[] source2, T[] source3)
        {
            if (source1.Length != 0)
            {
                foreach (var item in source1)
                {
                    yield return item;
                }
            }

            if (source2.Length != 0)
            {
                foreach (var item in source2)
                {
                    yield return item;
                }
            }

            if (source3.Length != 0)
            {
                foreach (var item in source3)
                {
                    yield return item;
                }
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/ArrayUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 6e420b3a76e513743af51fc4136e6b22
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncHandlerWhenAll.AwaiterNode.cs
================================================
using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;

namespace MessagePipe.Internal
{
    internal partial class AsyncHandlerWhenAll<T>
    {
        internal class AwaiterNode : IPoolStackNode<AwaiterNode>
        {
            AwaiterNode nextNode;
            public ref AwaiterNode NextNode => ref nextNode;

            AsyncHandlerWhenAll<T> parent = default;
            Cysharp.Threading.Tasks.UniTask.Awaiter awaiter;

            readonly Action continuation;

            static PoolStack<AwaiterNode> pool;

            public AwaiterNode()
            {
                this.continuation = OnCompleted;
            }

            public static void RegisterUnsafeOnCompleted(AsyncHandlerWhenAll<T> parent, Cysharp.Threading.Tasks.UniTask.Awaiter awaiter)
            {
                if (!pool.TryPop(out var result))
                {
                    result = new AwaiterNode();
                }
                result.parent = parent;
                result.awaiter = awaiter;

                result.awaiter.UnsafeOnCompleted(result.continuation);
            }

            void OnCompleted()
            {
                var p = this.parent;
                var a = this.awaiter;
                this.parent = null;
                this.awaiter = default;

                pool.TryPush(this);

                try
                {
                    a.GetResult();
                }
                catch (Exception ex)
                {
                    p.exception = ExceptionDispatchInfo.Capture(ex);
                    p.TryInvokeContinuation();
                    return;
                }

                p.IncrementSuccessfully();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncHandlerWhenAll.AwaiterNode.cs.meta
================================================
fileFormatVersion: 2
guid: 249b60be372ce534c82164c6c32c5774
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncHandlerWhenAll.cs
================================================
using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Internal
{
    internal static class ContinuationSentinel
    {
        public static readonly Action AvailableContinuation = () => { };
        public static readonly Action CompletedContinuation = () => { };
    }

    internal partial class AsyncHandlerWhenAll<T> : ICriticalNotifyCompletion
    {
        readonly int taskCount = 0;

        int completedCount = 0;
        ExceptionDispatchInfo exception;
        Action continuation = ContinuationSentinel.AvailableContinuation;

        public AsyncHandlerWhenAll(IAsyncMessageHandler<T>[] handlers, T message, CancellationToken cancellationtoken)
        {
            taskCount = handlers.Length;

            foreach (var item in handlers)
            {
                if (item == null)
                {
                    IncrementSuccessfully();
                }
                else
                {
                    try
                    {
                        var awaiter = item.HandleAsync(message, cancellationtoken).GetAwaiter();
                        if (awaiter.IsCompleted)
                        {
                            awaiter.GetResult();
                            goto SUCCESSFULLY;
                        }
                        else
                        {
                            AwaiterNode.RegisterUnsafeOnCompleted(this, awaiter);
                            continue;
                        }
                    }
                    catch (Exception ex)
                    {
                        exception = ExceptionDispatchInfo.Capture(ex);
                        TryInvokeContinuation();
                        return;
                    }

                SUCCESSFULLY:
                    IncrementSuccessfully();
                }
            }
        }

        void IncrementSuccessfully()
        {
            if (Interlocked.Increment(ref completedCount) == taskCount)
            {
                TryInvokeContinuation();
            }
        }

        void TryInvokeContinuation()
        {
            var c = Interlocked.Exchange(ref continuation, ContinuationSentinel.CompletedContinuation); // register completed.
            if (c != ContinuationSentinel.AvailableContinuation && c != ContinuationSentinel.CompletedContinuation)
            {
                c();
            }
        }

        // Awaiter

        public AsyncHandlerWhenAll<T> GetAwaiter()
        {
            return this;
        }

        public bool IsCompleted => exception != null || completedCount == taskCount;

        public void GetResult()
        {
            if (exception != null)
            {
                exception.Throw();
            }
            // Complete, OK.
        }

        public void OnCompleted(Action continuation)
        {
            UnsafeOnCompleted(continuation);
        }

        public void UnsafeOnCompleted(Action continuation)
        {
            var c = Interlocked.CompareExchange(ref this.continuation, continuation, ContinuationSentinel.AvailableContinuation);
            if (c == ContinuationSentinel.CompletedContinuation) // registered TryInvokeContinuation first.
            {
                continuation();
                return;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncHandlerWhenAll.cs.meta
================================================
fileFormatVersion: 2
guid: 639972fd7f1f93949855d5f0e9e7e837
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncRequestHandlerWhenAll.Awaiter.cs
================================================
using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;

namespace MessagePipe.Internal
{
    internal partial class AsyncRequestHandlerWhenAll<TRequest, TResponse>
    {
        internal class AwaiterNode : IPoolStackNode<AwaiterNode>
        {
            AwaiterNode nextNode;
            public ref AwaiterNode NextNode => ref nextNode;

            AsyncRequestHandlerWhenAll<TRequest, TResponse> parent = default;
            Cysharp.Threading.Tasks.UniTask<TResponse>.Awaiter awaiter;
            int index = -1;

            readonly Action continuation;

            static PoolStack<AwaiterNode> pool;

            public AwaiterNode()
            {
                this.continuation = OnCompleted;
            }

            public static void RegisterUnsafeOnCompleted(AsyncRequestHandlerWhenAll<TRequest, TResponse> parent, Cysharp.Threading.Tasks.UniTask<TResponse>.Awaiter awaiter, int index)
            {
                if (!pool.TryPop(out var result))
                {
                    result = new AwaiterNode();
                }
                result.parent = parent;
                result.awaiter = awaiter;
                result.index = index;

                result.awaiter.UnsafeOnCompleted(result.continuation);
            }

            void OnCompleted()
            {
                var p = this.parent;
                var a = this.awaiter;
                var i = this.index;
                this.parent = null;
                this.awaiter = default;
                this.index = -1;

                pool.TryPush(this);

                try
                {
                    p.result[i] = a.GetResult();
                }
                catch (Exception ex)
                {
                    p.exception = ExceptionDispatchInfo.Capture(ex);
                    p.TryInvokeContinuation();
                    return;
                }

                p.IncrementSuccessfully();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncRequestHandlerWhenAll.Awaiter.cs.meta
================================================
fileFormatVersion: 2
guid: 82dc1eeff19391c49935e5c28d824d0c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncRequestHandlerWhenAll.cs
================================================
using System;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Threading;

namespace MessagePipe.Internal
{
    internal partial class AsyncRequestHandlerWhenAll<TRequest, TResponse> : ICriticalNotifyCompletion
    {
        int completedCount;
        ExceptionDispatchInfo exception;
        Action continuation = ContinuationSentinel.AvailableContinuation;

        readonly TResponse[] result;

        public AsyncRequestHandlerWhenAll(IAsyncRequestHandlerCore<TRequest, TResponse>[] handlers, TRequest request, CancellationToken cancellationtoken)
        {
            result = new TResponse[handlers.Length];

            for (int i = 0; i < handlers.Length; i++)
            {
                try
                {
                    var awaiter = handlers[i].InvokeAsync(request, cancellationtoken).GetAwaiter();
                    if (awaiter.IsCompleted)
                    {
                        result[i] = awaiter.GetResult();
                    }
                    else
                    {
                        AwaiterNode.RegisterUnsafeOnCompleted(this, awaiter, i);
                        continue;
                    }
                }
                catch (Exception ex)
                {
                    exception = ExceptionDispatchInfo.Capture(ex);
                    TryInvokeContinuation();
                    return;
                }

                IncrementSuccessfully();
            }
        }

        void IncrementSuccessfully()
        {
            if (Interlocked.Increment(ref completedCount) == result.Length)
            {
                TryInvokeContinuation();
            }
        }

        void TryInvokeContinuation()
        {
            var c = Interlocked.Exchange(ref continuation, ContinuationSentinel.CompletedContinuation); // register completed.
            if (c != ContinuationSentinel.AvailableContinuation && c != ContinuationSentinel.CompletedContinuation)
            {
                c();
            }
        }

        // Awaiter

        public AsyncRequestHandlerWhenAll<TRequest, TResponse> GetAwaiter()
        {
            return this;
        }

        public bool IsCompleted => exception != null || completedCount == result.Length;

        public TResponse[] GetResult()
        {
            if (exception != null)
            {
                exception.Throw();
            }
            // Complete, OK.
            return result;
        }

        public void OnCompleted(Action continuation)
        {
            UnsafeOnCompleted(continuation);
        }

        public void UnsafeOnCompleted(Action continuation)
        {
            var c = Interlocked.CompareExchange(ref this.continuation, continuation, ContinuationSentinel.AvailableContinuation);
            if (c == ContinuationSentinel.CompletedContinuation) // registered TryInvokeContinuation first.
            {
                continuation();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/AsyncRequestHandlerWhenAll.cs.meta
================================================
fileFormatVersion: 2
guid: 3a9b19107a17d5f4daf1c73f9fb78808
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FastQueue.cs
================================================
#pragma warning disable CS8618

using System;
using System.Runtime.CompilerServices;

namespace MessagePipe.Internal
{
    // fixed size queue.
    internal class FastQueue<T>
    {
        T[] array;
        int head;
        int tail;
        int size;

        public FastQueue(int capacity)
        {
            if (capacity < 0) throw new ArgumentOutOfRangeException("capacity");
            array = new T[capacity];
            head = tail = size = 0;
        }

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return size; }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Enqueue(T item)
        {
            if (size == array.Length)
            {
                ThrowForFullQueue();
            }

            array[tail] = item;
            MoveNext(ref tail);
            size++;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T Dequeue()
        {
            if (size == 0) ThrowForEmptyQueue();

            int head = this.head;
            T[] array = this.array;
            T removed = array[head];
            array[head] = default;
            MoveNext(ref this.head);
            size--;
            return removed;
        }

        public void EnsureNewCapacity(int capacity)
        {
            T[] newarray = new T[capacity];
            if (size > 0)
            {
                if (head < tail)
                {
                    Array.Copy(array, head, newarray, 0, size);
                }
                else
                {
                    Array.Copy(array, head, newarray, 0, array.Length - head);
                    Array.Copy(array, 0, newarray, array.Length - head, tail);
                }
            }

            array = newarray;
            head = 0;
            tail = (size == capacity) ? 0 : size;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void MoveNext(ref int index)
        {
            int tmp = index + 1;
            if (tmp == array.Length)
            {
                tmp = 0;
            }
            index = tmp;
        }

        void ThrowForEmptyQueue()
        {
            throw new InvalidOperationException("Queue is empty.");
        }

        void ThrowForFullQueue()
        {
            throw new InvalidOperationException("Queue is full.");
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FastQueue.cs.meta
================================================
fileFormatVersion: 2
guid: 6b6f67d2fd2e5f743a13bdab4c5a97b7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FilterDefinition.cs
================================================
using System;
using System.Linq;

namespace MessagePipe.Internal
{
    internal abstract class FilterDefinition
    {
        public Type FilterType { get; }
        public int Order { get; }

        public FilterDefinition(Type filterType, int order)
        {
            this.FilterType = filterType;
            this.Order = order;
        }
    }

    internal sealed class AttributeFilterDefinition : FilterDefinition
    {
        public AttributeFilterDefinition(Type filterType, int order)
            : base(filterType, order)
        {
        }
    }

    internal sealed class MessageHandlerFilterDefinition : FilterDefinition
    {
        public Type MessageType { get; }
        public bool IsOpenGenerics { get; }

        public MessageHandlerFilterDefinition(Type filterType, int order, Type interfaceGenericDefinition)
            : base(filterType, order)
        {
            if (filterType.IsGenericType && !filterType.IsConstructedGenericType)
            {
                this.IsOpenGenerics = true;
                this.MessageType = null;
            }
            else
            {
                this.IsOpenGenerics = false;
                var interfaceType = filterType.GetBaseTypes().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceGenericDefinition);

                var genArgs = interfaceType.GetGenericArguments();
                this.MessageType = genArgs[0];
            }
        }
    }

    internal sealed class RequestHandlerFilterDefinition : FilterDefinition
    {
        public Type RequestType { get; }
        public Type ResponseType { get; }
        public bool IsOpenGenerics { get; }

        public RequestHandlerFilterDefinition(Type filterType, int order, Type interfaceGenericDefinition)
            : base(filterType, order)
        {
            if (filterType.IsGenericType && !filterType.IsConstructedGenericType)
            {
                this.IsOpenGenerics = true;
                this.RequestType = null;
                this.ResponseType = null;
            }
            else
            {
                this.IsOpenGenerics = false;
                var interfaceType = filterType.GetBaseTypes().First(x => x.IsGenericType && x.GetGenericTypeDefinition() == interfaceGenericDefinition);

                var genArgs = interfaceType.GetGenericArguments();
                this.RequestType = genArgs[0];
                this.ResponseType = genArgs[1];
            }
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FilterDefinition.cs.meta
================================================
fileFormatVersion: 2
guid: a38379cd17a92584d85857f0fb79905c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FreeList.cs
================================================
#pragma warning disable CS8618

using System;
using System.Collections.Generic;
using System.Threading;

namespace MessagePipe.Internal
{
    internal sealed class FreeList<T> : IDisposable
        where T : class
    {
        const int InitialCapacity = 4;
        const int MinShrinkStart = 8;

        T[] values;
        int count;
        FastQueue<int> freeIndex;
        bool isDisposed;
        readonly object gate = new object();

        public FreeList()
        {
            Initialize();
        }

        public T[] GetValues() => values; // no lock, safe for iterate

        public int GetCount()
        {
            lock (gate)
            {
                return count;
            }
        }

        public int Add(T value)
        {
            lock (gate)
            {
                if (isDisposed) throw new ObjectDisposedException(nameof(FreeList<T>));

                if (freeIndex.Count != 0)
                {
                    var index = freeIndex.Dequeue();
                    values[index] = value;
                    count++;
                    return index;
                }
                else
                {
                    // resize
                    var newValues = new T[values.Length * 2];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    freeIndex.EnsureNewCapacity(newValues.Length);
                    for (int i = values.Length; i < newValues.Length; i++)
                    {
                        freeIndex.Enqueue(i);
                    }

                    var index = freeIndex.Dequeue();
                    newValues[values.Length] = value;
                    count++;
                    Volatile.Write(ref values, newValues);
                    return index;
                }
            }
        }

        public void Remove(int index, bool shrinkWhenEmpty)
        {
            lock (gate)
            {
                if (isDisposed) return; // do nothing

                ref var v = ref values[index];
                if (v == null) throw new KeyNotFoundException($"key index {index} is not found.");

                v = null;
                freeIndex.Enqueue(index);
                count--;

                if (shrinkWhenEmpty && count == 0 && values.Length > MinShrinkStart)
                {
                    Initialize(); // re-init.
                }
            }
        }

        /// <summary>
        /// Dispose and get cleared count.
        /// </summary>
        public bool TryDispose(out int clearedCount)
        {
            lock (gate)
            {
                if (isDisposed)
                {
                    clearedCount = 0;
                    return false;
                }

                clearedCount = count;
                Dispose();
                return true;
            }
        }

        public void Dispose()
        {
            lock (gate)
            {
                if (isDisposed) return;
                isDisposed = true;

                freeIndex = null;
                values = Array.Empty<T>();
                count = 0;
            }
        }

        // [MemberNotNull(nameof(freeIndex), nameof(values))]
        void Initialize()
        {
            freeIndex = new FastQueue<int>(InitialCapacity);
            for (int i = 0; i < InitialCapacity; i++)
            {
                freeIndex.Enqueue(i);
            }
            count = 0;

            var v = new T[InitialCapacity];
            Volatile.Write(ref values, v);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/FreeList.cs.meta
================================================
fileFormatVersion: 2
guid: 8c04dd0220323ea4f9e1b2ed7ad91e73
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/PoolStack.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace MessagePipe.Internal
{
    internal interface IPoolStackNode<T>
        where T : class
    {
        ref T NextNode { get; }
    }

    // mutable struct, don't mark readonly.
    [StructLayout(LayoutKind.Auto)]
    internal struct PoolStack<T>
        where T : class, IPoolStackNode<T>
    {
        int gate;
        int size;
        T root;

        public int Size => size;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryPop(out T result)
        {
            if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
            {
                var v = root;
                if (!(v is null))
                {
                    ref var nextNode = ref v.NextNode;
                    root = nextNode;
                    nextNode = null;
                    size--;
                    result = v;
                    Volatile.Write(ref gate, 0);
                    return true;
                }

                Volatile.Write(ref gate, 0);
            }
            result = default;
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryPush(T item)
        {
            if (Interlocked.CompareExchange(ref gate, 1, 0) == 0)
            {
                item.NextNode = root;
                root = item;
                size++;
                Volatile.Write(ref gate, 0);
                return true;
            }
            return false;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/PoolStack.cs.meta
================================================
fileFormatVersion: 2
guid: 0d9907cbd191bdd4aaaad806a875becb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/Preserve.cs
================================================
namespace MessagePipe.Internal
{
    // Preserve for Unity IL2CPP

    internal class PreserveAttribute : System.Attribute
    {
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/Preserve.cs.meta
================================================
fileFormatVersion: 2
guid: 1cd40406f42a03147a83846ab0d84a9b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TaskExtensions.cs
================================================
using Cysharp.Threading.Tasks;

namespace MessagePipe.Internal
{
    internal static class TaskExtensions
    {
#if !UNITY_2018_3_OR_NEWER

        internal static async void Forget(this UniTask task)
        {
            await task;
        }

#endif
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TaskExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 9ec017bb6553adf48be54ab4a05be055
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TypeCollector.cs
================================================
#if !UNITY_2018_3_OR_NEWER

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace MessagePipe.Internal
{
    internal static class TypeCollector
    {
        public static IEnumerable<Type> CollectFromCurrentDomain()
        {
            var wellKnownIgnoreAssemblies = new[]
            {
                "netstandard",
                "System.*",
                "Microsoft.Win32.*",
                "Microsoft.Extensions.*",
                "Microsoft.AspNetCore",
                "Microsoft.AspNetCore.*",
                "Grpc.*",
                "MessagePack",
                "MessagePack.*",
                "MagicOnion.Server",
                "MagicOnion.Server.*",
                "MagicOnion.Client",
                "MagicOnion.Client.*",
                "MagicOnion.Abstractions",
                "MagicOnion.Shared",
            };

            var assemblies = AppDomain.CurrentDomain.GetAssemblies()
                .Where(x => x.GetName().Name != "MessagePipe" && x.GetName().Name != "MessagePipe.Redis")
                .Where(x =>
                {
                    return !wellKnownIgnoreAssemblies.Any(y =>
                    {
                        if (y.EndsWith("*"))
                        {
                            return x.GetName().Name!.StartsWith(y.Substring(0, y.Length - 1));
                        }
                        else
                        {
                            return x.GetName().Name == y;
                        }
                    });
                });

            return CollectFromAssemblies(assemblies);
        }

        public static IEnumerable<Type> CollectFromAssemblies(IEnumerable<Assembly> searchAssemblies)
        {
            var types = searchAssemblies
                .Where(x => x.GetName().Name != "MessagePipe" && x.GetName().Name != "MessagePipe.Redis")
                .SelectMany(x =>
                {
                    try
                    {
                        return x.GetTypes();
                    }
                    catch (ReflectionTypeLoadException ex)
                    {
                        return ex.Types.Where(t => t != null);
                    }
                })
                .Where(x => x != null);

            return types!;
        }

        
    }
}

#endif


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TypeCollector.cs.meta
================================================
fileFormatVersion: 2
guid: 76a2d6cd54166cb46b88b5596bc76ca3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TypeExtensions.cs
================================================
using System;
using System.Collections.Generic;

namespace MessagePipe.Internal
{
    internal static class TypeExtensions
    {
        public static IEnumerable<Type> GetBaseTypes(this Type t)
        {
            if (t == null) yield break;
            t = t.BaseType;
            while (t != null)
            {
                yield return t;
                t = t.BaseType;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Internal/TypeExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: aceffa59feb54604b842f080e91a3825
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/BuiltinContainerBuilder.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace MessagePipe
{
    public partial class BuiltinContainerBuilder
    {
        public BuiltinContainerBuilder()
        {
        }

        public BuiltinContainerBuilder AddMessagePipe()
        {
            return AddMessagePipe(_ => { });
        }

        public BuiltinContainerBuilder AddMessagePipe(Action<MessagePipeOptions> configure)
        {
            ServiceCollectionExtensions.AddMessagePipe(this, configure);
            return this;
        }

        public IServiceProvider BuildServiceProvider()
        {
            return new BuiltinContainerBuilderServiceProvider(this);
        }

        /// <summary>Register IPublisher[TMessage] and ISubscriber[TMessage](includes Async/Buffered) to container builder.</summary>
        public BuiltinContainerBuilder AddMessageBroker<TMessage>()
        {
            var services = this;

            // keyless PubSub
            services.AddSingleton(typeof(MessageBrokerCore<TMessage>));
            services.AddSingleton(typeof(IPublisher<TMessage>), typeof(MessageBroker<TMessage>));
            services.AddSingleton(typeof(ISubscriber<TMessage>), typeof(MessageBroker<TMessage>));

            // keyless PubSub async
            services.AddSingleton(typeof(AsyncMessageBrokerCore<TMessage>));
            services.AddSingleton(typeof(IAsyncPublisher<TMessage>), typeof(AsyncMessageBroker<TMessage>));
            services.AddSingleton(typeof(IAsyncSubscriber<TMessage>), typeof(AsyncMessageBroker<TMessage>));

            // keyless buffered PubSub
            services.AddSingleton(typeof(BufferedMessageBrokerCore<TMessage>));
            services.AddSingleton(typeof(IBufferedPublisher<TMessage>), typeof(BufferedMessageBroker<TMessage>));
            services.AddSingleton(typeof(IBufferedSubscriber<TMessage>), typeof(BufferedMessageBroker<TMessage>));

            // keyless buffered PubSub async
            services.AddSingleton(typeof(BufferedAsyncMessageBrokerCore<TMessage>));
            services.AddSingleton(typeof(IBufferedAsyncPublisher<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>));
            services.AddSingleton(typeof(IBufferedAsyncSubscriber<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>));

            return this;
        }

        /// <summary>Register IPublisher[TKey, TMessage] and ISubscriber[TKey, TMessage](includes Async) to container builder.</summary>
        public BuiltinContainerBuilder AddMessageBroker<TKey, TMessage>()
        {
            var services = this;

            // keyed PubSub
            services.AddSingleton(typeof(MessageBrokerCore<TKey, TMessage>));
            services.AddSingleton(typeof(IPublisher<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>));
            services.AddSingleton(typeof(ISubscriber<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>));

            // keyed PubSub async
            services.AddSingleton(typeof(AsyncMessageBrokerCore<TKey, TMessage>));
            services.AddSingleton(typeof(IAsyncPublisher<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>));
            services.AddSingleton(typeof(IAsyncSubscriber<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>));

            return this;
        }

        /// <summary>Register IRequestHandler[TRequest, TResponse] to container builder.</summary>
        public BuiltinContainerBuilder AddRequestHandler<TRequest, TResponse, THandler>()
            where THandler : IRequestHandler
        {
            var services = this;

            services.AddSingleton(typeof(IRequestHandlerCore<TRequest, TResponse>), typeof(THandler));
            services.AddSingleton(typeof(IRequestHandler<TRequest, TResponse>), typeof(RequestHandler<TRequest, TResponse>));

            return this;
        }

        /// <summary>Register IAsyncRequestHandler[TRequest, TResponse] to container builder.</summary>
        public BuiltinContainerBuilder AddAsyncRequestHandler<TRequest, TResponse, THandler>()
            where THandler : IAsyncRequestHandler
        {
            var services = this;

            services.AddSingleton(typeof(IAsyncRequestHandlerCore<TRequest, TResponse>), typeof(THandler));
            services.AddSingleton(typeof(IAsyncRequestHandler<TRequest, TResponse>), typeof(AsyncRequestHandler<TRequest, TResponse>));

            AsyncRequestHandlerRegistory.Add(typeof(TRequest), typeof(TResponse), typeof(THandler));

            return this;
        }

        public BuiltinContainerBuilder AddMessageHandlerFilter<T>()
            where T : class, IMessageHandlerFilter
        {
            this.TryAddTransient(typeof(T));
            return this;
        }

        public BuiltinContainerBuilder AddAsyncMessageHandlerFilter<T>()
            where T : class, IAsyncMessageHandlerFilter
        {
            this.TryAddTransient(typeof(T));
            return this;
        }

        public BuiltinContainerBuilder AddRequestHandlerFilter<T>()
            where T : class, IRequestHandlerFilter
        {
            this.TryAddTransient(typeof(T));
            return this;
        }

        public BuiltinContainerBuilder AddAsyncRequestHandlerFilter<T>()
            where T : class, IAsyncRequestHandlerFilter
        {
            this.TryAddTransient(typeof(T));
            return this;
        }
    }

    // DI Container builder.
    public partial class BuiltinContainerBuilder : IServiceCollection
    {
        internal readonly Dictionary<Type, object> singletonInstances = new Dictionary<Type, object>();
        internal readonly List<(Type serviceType, Type implementationType)> singleton = new List<(Type serviceType, Type implementationType)>();
        internal readonly List<(Type serviceType, Type implementationType)> transient = new List<(Type serviceType, Type implementationType)>();

        public void AddSingleton<T>(T instance)
        {
            singletonInstances[typeof(T)] = instance;
        }

        public void AddSingleton(Type type)
        {
            singleton.Add((type, type));
        }

        public void AddTransient(Type type)
        {
            transient.Add((type, type));
        }

        public void TryAddTransient(Type type)
        {
            foreach (var item in transient)
            {
                if (item.serviceType == type)
                {
                    return;
                }
            }

            transient.Add((type, type));
        }

        public void AddSingleton(Type serviceType, Type implementationType)
        {
            singleton.Add((serviceType, implementationType));
        }


        public void Add(Type serviceType, InstanceLifetime lifetime)
        {
            Add(serviceType, serviceType, lifetime);
        }

        public void Add(Type serviceType, Type implementationType, InstanceLifetime lifetime)
        {
            if (lifetime == InstanceLifetime.Scoped || lifetime == InstanceLifetime.Singleton)
            {
                singleton.Add((serviceType, implementationType));
            }
            else // Transient
            {
                transient.Add((serviceType, implementationType));
            }
        }
    }

    class BuiltinContainerBuilderServiceProvider : IServiceProvider
    {
        readonly Dictionary<Type, Lazy<object>> singletonInstances;
        readonly Dictionary<Type, ServiceProviderType> transientTypes;

        public BuiltinContainerBuilderServiceProvider(BuiltinContainerBuilder builder)
        {
            this.singletonInstances = new Dictionary<Type, Lazy<object>>(builder.singletonInstances.Count + builder.singleton.Count);
            this.transientTypes = new Dictionary<Type, ServiceProviderType>(builder.transient.Count);

            foreach (var item in builder.singletonInstances)
            {
                this.singletonInstances[item.Key] = new Lazy<object>(() => item.Value);
            }

            foreach (var item in builder.singleton)
            {
                var implType = item.implementationType;
                this.singletonInstances[item.serviceType] = new Lazy<object>(() => new ServiceProviderType(implType).Instantiate(this, 0)); // memo: require to lazy with parameter(pass depth).
            }

            foreach (var item in builder.transient)
            {
                this.transientTypes[item.serviceType] = new ServiceProviderType(item.implementationType);
            }
        }

        public object GetService(Type serviceType)
        {
            return GetService(serviceType, 0);
        }

        public object GetService(Type serviceType, int depth)
        {
            if (serviceType == typeof(IServiceProvider))
            {
                return this; // resolve self
            }

            if (singletonInstances.TryGetValue(serviceType, out var value))
            {
                return value.Value; // return Lazy<T>.Value
            }

            if (transientTypes.TryGetValue(serviceType, out var providerType))
            {
                return providerType.Instantiate(this, depth);
            }

            return null;
        }
    }

    class ServiceProviderType
    {
        readonly Type type;
        readonly ConstructorInfo ctor;
        readonly ParameterInfo[] parameters;

        public ServiceProviderType(Type type)
        {
            var info = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance)
                .Select(x => new { ctor = x, parameters = x.GetParameters() })
                .OrderByDescending(x => x.parameters.Length) // MaxBy
                .FirstOrDefault();

            if (!type.IsValueType && info == null)
            {
                throw new InvalidOperationException("ConsturoctorInfo is not found, is stripped? Type:" + type.FullName);
            }

            this.type = type;
            this.ctor = info?.ctor;
            this.parameters = info?.parameters;
        }

        public object Instantiate(BuiltinContainerBuilderServiceProvider provider, int depth)
        {
            if (ctor == null)
            {
                return Activator.CreateInstance(type);
            }

            if (parameters.Length == 0)
            {
                return ctor.Invoke(Array.Empty<object>());
            }
            if (depth > 15)
            {
                throw new InvalidOperationException("Parameter too recursively: " + type.FullName);
            }

            var p = new object[parameters.Length];
            for (int i = 0; i < p.Length; i++)
            {
                p[i] = provider.GetService(parameters[i].ParameterType, depth + 1);
            }

            return ctor.Invoke(p);
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/BuiltinContainerBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: 2fdf7a1af83b5a84485609f895d5044d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/DependencyInjectionShims.cs
================================================
using System;

namespace MessagePipe
{
    public static class DependencyInjectionShims
    {
        public static T GetRequiredService<T>(this IServiceProvider provider)
        {
            var service = provider.GetService(typeof(T));
            if (service == null)
            {
                throw new InvalidOperationException($"{typeof(T).FullName} is not registered.");
            }
            return (T)service;
        }

        public static object GetRequiredService(this IServiceProvider provider, Type type)
        {
            var service = provider.GetService(type);
            if (service == null)
            {
                throw new InvalidOperationException($"{type.FullName} is not registered.");
            }
            return service;
        }
    }

    public interface IServiceCollection
    {
        void Add(Type serviceType, InstanceLifetime lifetime);
        void Add(Type serviceType, Type implementationType, InstanceLifetime lifetime);
        void AddSingleton<T>(T instance);
        void AddSingleton(Type type);
        void AddTransient(Type type);
        void TryAddTransient(Type type);
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/DependencyInjectionShims.cs.meta
================================================
fileFormatVersion: 2
guid: 5b51cc4576b29b645992d453cdb4125e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/InternalVisibleTo.cs
================================================
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("MessagePipe.Editor")]



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/InternalVisibleTo.cs.meta
================================================
fileFormatVersion: 2
guid: f3d6bb660d4c1f54e8548af97a83ec8e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/TaskShims.cs
================================================
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    internal static class TaskShims
    {
        internal static UniTask ConfigureAwait(this UniTask task, bool _)
        {
            return task;
        }

        internal static UniTask<T> ConfigureAwait<T>(this UniTask<T> task, bool _)
        {
            return task;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe/Runtime/Unity/TaskShims.cs.meta
================================================
fileFormatVersion: 2
guid: 366096f581024d441a388b50e7e90fd0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/package.json
================================================
{
    "name": "com.cysharp.messagepipe.interprocess",
    "displayName": "MessagePipe.Interprocess",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.8.1",
    "unity": "2018.4",
    "description": "MessagePipe Interprocess Extension.",
    "keywords": [ "pubsub", "event", "Scripting", "DI" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/package.json.meta
================================================
fileFormatVersion: 2
guid: 44d0c2be8b734d84c8e7d744f3125b6b
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime.meta
================================================
fileFormatVersion: 2
guid: a6d0b7d9aa69f914abbebd85362c4446
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal.meta
================================================
fileFormatVersion: 2
guid: 1f570ccc9bfd1704fa9bf6f25a6bb091
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessageBuilder.cs
================================================
using MessagePack;
using MessagePack.Formatters;
using MessagePipe.Interprocess.Internal;
using System;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace MessagePipe.Interprocess
{
    public interface IInterprocessKey : IEquatable<IInterprocessKey>
    {
        ReadOnlyMemory<byte> KeyMemory { get; }
    }

    public interface IInterprocessValue
    {
        ReadOnlyMemory<byte> ValueMemory { get; }
    }

    internal sealed class InterprocessMessage : IInterprocessKey, IInterprocessValue
    {
        readonly byte[] buffer;
        readonly int keyIndex;
        readonly int keyOffset;
        readonly int hashCode;

        public MessageType MessageType { get; }

        public InterprocessMessage(MessageType messageType, byte[] buffer, int keyIndex, int keyOffset)
        {
            this.MessageType = messageType;
            this.buffer = buffer;
            this.keyIndex = keyIndex;
            this.keyOffset = keyOffset;
            this.hashCode = CalcHashCode();
        }

        public ReadOnlyMemory<byte> KeyMemory => buffer.AsMemory(keyIndex, keyOffset - keyIndex);
        public ReadOnlyMemory<byte> ValueMemory => buffer.AsMemory(keyOffset, buffer.Length - keyOffset);

        public bool Equals(IInterprocessKey other)
        {
            if (other == null) return false;
            return KeyMemory.Span.SequenceEqual(other.KeyMemory.Span);
        }

        public override int GetHashCode()
        {
            return hashCode;
        }

        int CalcHashCode()
        {
            // FNV1A32
            var obj = buffer;
            uint hash = 2166136261;
            for (int i = keyIndex; i < keyOffset; i++)
            {
                hash = unchecked((obj[i] ^ hash) * 16777619);
            }

            return unchecked((int)hash);
        }
    }

    internal enum MessageType : byte
    {
        PubSub = 1,
        RemoteRequest = 2,
        RemoteResponse = 3,
        RemoteError = 4,
    }

    internal static class MessageBuilder
    {
        // Message Frame-----
        // Length: int32(4), without self(MsgPack Body Only)
        // Body(PubSub): MessagePack Array[3](Type(byte), key, message)
        // Body(Reques): MessagePack Array[3](Type(byte), RequestHeader, request)
        // Body(Respon): MessagePack Array[3](Type(byte), messageId:int, response)
        // Body(RError): MessagePack Array[3](Type(byte), messageId:int, error:string)

        public static IInterprocessKey CreateKey<TKey>(TKey key, MessagePackSerializerOptions options)
        {
            var bytes = MessagePackSerializer.Serialize(key, options);
            return new InterprocessMessage(MessageType.PubSub, bytes, 0, bytes.Length);
        }

        public static byte[] BuildPubSubMessage<TKey, TMessaege>(TKey key, TMessaege message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.PubSub);
                MessagePackSerializer.Serialize(ref writer, key, options);
                MessagePackSerializer.Serialize(ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteRequestMessage<TRequest>(Type requestType, Type responseType, int messageId, TRequest message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteRequest);
                MessagePackSerializer.Serialize(ref writer, new RequestHeader(messageId, requestType.FullName, responseType.FullName), options);
                MessagePackSerializer.Serialize(ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteResponseMessage(int messageId, Type responseType, object message, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteResponse);
                MessagePackSerializer.Serialize(ref writer, messageId, options);
                MessagePackSerializer.Serialize(responseType, ref writer, message, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static byte[] BuildRemoteResponseError(int messageId, string exception, MessagePackSerializerOptions options)
        {
            using (var bufferWriter = new ArrayPoolBufferWriter())
            {
                var writer = new MessagePackWriter(bufferWriter);
                writer.WriteArrayHeader(3);
                writer.Write((byte)MessageType.RemoteError);
                MessagePackSerializer.Serialize(ref writer, messageId, options);
                MessagePackSerializer.Serialize(ref writer, exception, options);
                writer.Flush();

                var finalBuffer = new byte[4 + bufferWriter.WrittenCount];
                Unsafe.WriteUnaligned(ref finalBuffer[0], bufferWriter.WrittenCount);
                bufferWriter.WrittenSpan.CopyTo(finalBuffer.AsSpan(4));
                return finalBuffer;
            }
        }

        public static int FetchMessageLength(ReadOnlySpan<byte> xs)
        {
            return Unsafe.ReadUnaligned<int>(ref Unsafe.AsRef(xs[0]));
        }

        public static InterprocessMessage ReadPubSubMessage(byte[] buffer)
        {
            var reader = new MessagePackReader(buffer);
            if (reader.ReadArrayHeader() != 3)
            {
                throw new InvalidOperationException("Invalid messagepack buffer.");
            }

            var b = reader.ReadByte();
            var msgType = (MessageType)b;

            var keyIndex = (int)reader.Consumed;
            reader.Skip();
            var keyOffset = (int)reader.Consumed;
            reader.Skip();

            return new InterprocessMessage(msgType, buffer, keyIndex, keyOffset);
        }
    }

    // (messageId:int, (reqType,resType):(string,string))

    [Preserve]
    [MessagePackFormatter(typeof(Formatter))]
    internal class RequestHeader
    {
        public int MessageId { get; }
        public string RequestType { get; }
        public string ResponseType { get; }

        public RequestHeader(int messageId, string requestType, string responseType)
        {
            MessageId = messageId;
            RequestType = requestType;
            ResponseType = responseType;
        }

        [Preserve]
        public class Formatter : IMessagePackFormatter<RequestHeader>
        {
            public RequestHeader Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                // debugging...
                var x = reader.ReadArrayHeader();
                if (x != 3) throw new MessagePack.MessagePackSerializationException("Array length is invalid. Length:" + x);
                var id = reader.ReadInt32();

                var req = reader.ReadString();
                var res = reader.ReadString();
                return new RequestHeader(id, req, res);
            }

            public void Serialize(ref MessagePackWriter writer, RequestHeader value, MessagePackSerializerOptions options)
            {
                writer.WriteArrayHeader(3);
                writer.Write(value.MessageId);
                writer.Write(value.RequestType);
                writer.Write(value.ResponseType);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessageBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: 66b9e3cf391722447b364b5a21ee8f7a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessagePipe.Interprocess.asmdef
================================================
{
    "name": "MessagePipe.Interprocess",
    "rootNamespace": "MessagePipe",
    "references": [
        "MessagePipe",
        "MessagePack",
        "MessagePack.Annotations",
        "UniTask"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessagePipe.Interprocess.asmdef.meta
================================================
fileFormatVersion: 2
guid: 19668f8dd6209ac4f84e2a027b6f37b8
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessagePipeInterprocessOptions.cs
================================================
using MessagePack;
using MessagePack.Resolvers;
using System;

namespace MessagePipe.Interprocess
{
    public abstract class MessagePipeInterprocessOptions
    {
        public MessagePackSerializerOptions MessagePackSerializerOptions { get; set; }
        public InstanceLifetime InstanceLifetime { get; set; }
        public Action<string, Exception> UnhandledErrorHandler { get; set; }

        public MessagePipeInterprocessOptions()
        {
            this.MessagePackSerializerOptions = ContractlessStandardResolver.Options;
            this.InstanceLifetime = InstanceLifetime.Scoped;
#if !UNITY_2018_3_OR_NEWER
            this.UnhandledErrorHandler = (msg, x) => Console.WriteLine(msg + x);
#else
            this.UnhandledErrorHandler = (msg, x) => UnityEngine.Debug.Log(msg + x);
#endif
        }
    }

    public sealed class MessagePipeInterprocessUdpOptions : MessagePipeInterprocessOptions
    {
        public string Host { get; }
        public int Port { get; }

        public MessagePipeInterprocessUdpOptions(string host, int port)
            : base()
        {
            this.Host = host;
            this.Port = port;
        }
    }

    public sealed class MessagePipeInterprocessNamedPipeOptions : MessagePipeInterprocessOptions
    {
        public string PipeName { get; }
        public string ServerName { get; set; }
        public bool? HostAsServer { get; set; }

        public MessagePipeInterprocessNamedPipeOptions(string pipeName)
            : base()
        {
            this.PipeName = pipeName;
            this.ServerName = ".";
            this.HostAsServer = null;
        }
    }

    public sealed class MessagePipeInterprocessTcpOptions : MessagePipeInterprocessOptions
    {
        public string Host { get; }
        public int Port { get; }
        public bool? HostAsServer { get; set; }

        public MessagePipeInterprocessTcpOptions(string host, int port)
            : base()
        {
            this.Host = host;
            this.Port = port;
            this.HostAsServer = null;
        }
    }
#if NET5_0_OR_GREATER
    public sealed class MessagePipeInterprocessUdpUdsOptions : MessagePipeInterprocessOptions
    {
        public string SocketPath { get; set; }

        public MessagePipeInterprocessUdpUdsOptions(string socketPath)
            : base()
        {
            this.SocketPath = socketPath;
        }

    }
    public sealed class MessagePipeInterprocessTcpUdsOptions : MessagePipeInterprocessOptions
    {
        public string SocketPath { get; set; }
        public int? SendBufferSize { get; set; }
        public int? ReceiveBufferSize { get; set; }
        public bool? HostAsServer { get; set; }
        public MessagePipeInterprocessTcpUdsOptions(string socketPath): this(socketPath, null, null)
        {
        }
        public MessagePipeInterprocessTcpUdsOptions(string socketPath, int? sendBufferSize, int? recvBufferSize)
        {
            this.SocketPath = socketPath;
            HostAsServer = null;
            this.SendBufferSize = sendBufferSize;
            this.ReceiveBufferSize = recvBufferSize;
        }
    }
#endif
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/MessagePipeInterprocessOptions.cs.meta
================================================
fileFormatVersion: 2
guid: afa6128b287147a4e87573ec8ac2a366
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/NamedPipeDistributedPublisherSubscribercs.cs
================================================
using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class NamedPipeDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly NamedPipeWorker worker;

        [Preserve]
        public NamedPipeDistributedPublisher(NamedPipeWorker worker)
        {
            this.worker = worker;
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class NamedPipeDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from worker.
        readonly MessagePipeInterprocessNamedPipeOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public NamedPipeDistributedSubscriber(NamedPipeWorker worker, MessagePipeInterprocessNamedPipeOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        UniTask<IUniTaskAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }


}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/NamedPipeDistributedPublisherSubscribercs.cs.meta
================================================
fileFormatVersion: 2
guid: 09e48ca16ce40a6438ea9bf420dc606d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/NamedPipeRemoteRequestHandler.cs
================================================
using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class NamedPipeRemoteRequestHandler<TRequest, TResponse> : IRemoteRequestHandler<TRequest, TResponse>
    {
        readonly NamedPipeWorker worker;

        [Preserve]
        public NamedPipeRemoteRequestHandler(NamedPipeWorker worker)
        {
            this.worker = worker;
        }

        public async UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return await worker.RequestAsync<TRequest, TResponse>(request, cancellationToken);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/NamedPipeRemoteRequestHandler.cs.meta
================================================
fileFormatVersion: 2
guid: 31e4b74a27936ef4582f4e3be32e95d7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/ServiceCollectionInterprocessExtensions.cs
================================================
using System;
using MessagePipe;
using MessagePipe.Interprocess;
using MessagePipe.Interprocess.Workers;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
#endif

#if !UNITY_2018_3_OR_NEWER
using ReturnType = Microsoft.Extensions.DependencyInjection.IMessagePipeBuilder;
namespace Microsoft.Extensions.DependencyInjection
#else
using ReturnType = MessagePipe.Interprocess.MessagePipeInterprocessOptions;
namespace MessagePipe
#endif
{
    public static class ServiceCollectionInterprocessExtensions
    {
        public static ReturnType AddUdpInterprocess(this IMessagePipeBuilder builder, string host, int port)
        {
            return AddUdpInterprocess(builder, host, port, _ => { });
        }

        public static ReturnType AddUdpInterprocess(this IMessagePipeBuilder builder, string host, int port, Action<MessagePipeInterprocessUdpOptions> configure)
        {
            var options = new MessagePipeInterprocessUdpOptions(host, port);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(UdpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(UdpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(UdpDistributedSubscriber<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }

        public static ReturnType AddTcpInterprocess(this IMessagePipeBuilder builder, string host, int port)
        {
            return AddTcpInterprocess(builder, host, port, _ => { });
        }

        public static ReturnType AddTcpInterprocess(this IMessagePipeBuilder builder, string host, int port, Action<MessagePipeInterprocessTcpOptions> configure)
        {
            var options = new MessagePipeInterprocessTcpOptions(host, port);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(TcpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(TcpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(TcpDistributedSubscriber<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(TcpRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif

        }

#if !UNITY_2018_3_OR_NEWER

        // NamedPipe in Unity is slightly buggy so disable.

        public static ReturnType AddNamedPipeInterprocess(this IMessagePipeBuilder builder, string pipeName)
        {
            return AddNamedPipeInterprocess(builder, pipeName, _ => { });
        }

        public static ReturnType AddNamedPipeInterprocess(this IMessagePipeBuilder builder, string pipeName, Action<MessagePipeInterprocessNamedPipeOptions> configure)
        {
            var options = new MessagePipeInterprocessNamedPipeOptions(pipeName);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(NamedPipeWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(NamedPipeDistributedPublisher<,>), InstanceLifetime.Singleton);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(NamedPipeDistributedSubscriber<,>), InstanceLifetime.Singleton);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(NamedPipeRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }

#endif

        static void Add(this IServiceCollection services, Type serviceType, InstanceLifetime scope)
        {
            services.Add(serviceType, serviceType, scope);
        }

#if !UNITY_2018_3_OR_NEWER

        static void Add(this IServiceCollection services, Type serviceType, Type implementationType, InstanceLifetime scope)
        {
            var lifetime = (scope == InstanceLifetime.Scoped) ? ServiceLifetime.Scoped
                : (scope == InstanceLifetime.Singleton) ? ServiceLifetime.Singleton
                : ServiceLifetime.Transient;

            var descriptor = new ServiceDescriptor(serviceType, implementationType, lifetime);
            services.Add(descriptor);
        }

#endif

#if UNITY_2018_3_OR_NEWER

        static void AddAsyncMessageBroker<TKey,TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            builder.Services.Add(typeof(AsyncMessageBrokerCore<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IAsyncPublisher<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IAsyncSubscriber<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), options.InstanceLifetime);
        }

        public static IMessagePipeBuilder RegisterUpdInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            AddAsyncMessageBroker<TKey, TMessage>(builder, options);
            builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(UdpDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(UdpDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

            return builder;
        }

        public static IMessagePipeBuilder RegisterTcpInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            AddAsyncMessageBroker<TKey, TMessage>(builder, options);
            builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(TcpDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(TcpDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

            return builder;
        }

        //public static IMessagePipeBuilder RegisterNamedPipeInterprocessMessageBroker<TKey, TMessage>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        //{
        //    AddAsyncMessageBroker<TKey, TMessage>(builder, options);
        //    builder.Services.Add(typeof(IDistributedPublisher<TKey, TMessage>), typeof(NamedPipeDistributedPublisher<TKey, TMessage>), options.InstanceLifetime);
        //    builder.Services.Add(typeof(IDistributedSubscriber<TKey, TMessage>), typeof(NamedPipeDistributedSubscriber<TKey, TMessage>), options.InstanceLifetime);

        //    return builder;
        //}

        public static IMessagePipeBuilder RegisterTcpRemoteRequestHandler<TRequest, TResponse>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        {
            builder.Services.Add(typeof(IRemoteRequestHandler<TRequest, TResponse>), typeof(TcpRemoteRequestHandler<TRequest, TResponse>), options.InstanceLifetime);

            return builder;
        }

        //public static IMessagePipeBuilder RegisterNamedPipeRemoteRequestHandler<TRequest, TResponse>(this IMessagePipeBuilder builder, MessagePipeInterprocessOptions options)
        //{
        //    builder.Services.Add(typeof(IRemoteRequestHandler<TRequest, TResponse>), typeof(NamedPipeRemoteRequestHandler<TRequest, TResponse>), options.InstanceLifetime);

        //    return builder;
        //}

#endif
#if NET5_0_OR_GREATER
        public static ReturnType AddUdpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath)
        {
            return AddUdpInterprocessUds(builder, domainSocketPath, _ => { });
        }
        public static ReturnType AddUdpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath, Action<MessagePipeInterprocessUdpUdsOptions> configure)
        {
            var options = new MessagePipeInterprocessUdpUdsOptions(domainSocketPath);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(UdpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(UdpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(UdpDistributedSubscriber<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif
        }
        public static ReturnType AddTcpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath)
        {
            return AddTcpInterprocessUds(builder, domainSocketPath, _ => { });
        }

        public static ReturnType AddTcpInterprocessUds(this IMessagePipeBuilder builder, string domainSocketPath, Action<MessagePipeInterprocessTcpUdsOptions> configure)
        {
            var options = new MessagePipeInterprocessTcpUdsOptions(domainSocketPath);
            configure(options);

            builder.Services.AddSingleton(options);
            builder.Services.Add(typeof(TcpWorker), options.InstanceLifetime);

#if !UNITY_2018_3_OR_NEWER
            builder.Services.Add(typeof(IDistributedPublisher<,>), typeof(TcpDistributedPublisher<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IDistributedSubscriber<,>), typeof(TcpDistributedSubscriber<,>), options.InstanceLifetime);
            builder.Services.Add(typeof(IRemoteRequestHandler<,>), typeof(TcpRemoteRequestHandler<,>), options.InstanceLifetime);
            return builder;
#else
            AddAsyncMessageBroker<IInterprocessKey, IInterprocessValue>(builder, options);
            return options;
#endif

        }
#endif // NET5_0_OR_GREATER
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/ServiceCollectionInterprocessExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 82628f656de455f4ba677b9808610a34
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/TcpDistributedPublisherSubscriber.cs
================================================
using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class TcpDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly TcpWorker worker;

        [Preserve]
        public TcpDistributedPublisher(TcpWorker worker)
        {
            this.worker = worker;
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class TcpDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from UdpWorker.
        readonly MessagePipeInterprocessOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public TcpDistributedSubscriber(TcpWorker worker, MessagePipeInterprocessTcpOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public TcpDistributedSubscriber(TcpWorker worker, MessagePipeInterprocessTcpUdsOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#endif
        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        UniTask<IUniTaskAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/TcpDistributedPublisherSubscriber.cs.meta
================================================
fileFormatVersion: 2
guid: 156b112bcf8771646a94d21a56e384d5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/TcpRemoteRequestHandler.cs
================================================
using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class TcpRemoteRequestHandler<TRequest, TResponse> : IRemoteRequestHandler<TRequest, TResponse>
    {
        readonly TcpWorker worker;

        [Preserve]
        public TcpRemoteRequestHandler(TcpWorker worker)
        {
            this.worker = worker;
        }

        public async UniTask<TResponse> InvokeAsync(TRequest request, CancellationToken cancellationToken = default)
        {
            return await worker.RequestAsync<TRequest, TResponse>(request, cancellationToken);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/TcpRemoteRequestHandler.cs.meta
================================================
fileFormatVersion: 2
guid: 24bcb5686c4766644839fd2bcae9e73c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/UdpDistributedPublisherSubscriber.cs
================================================
using MessagePipe.Interprocess.Internal;
using MessagePipe.Interprocess.Workers;
using System;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess
{
    [Preserve]
    public sealed class UdpDistributedPublisher<TKey, TMessage> : IDistributedPublisher<TKey, TMessage>
    {
        readonly UdpWorker worker;

        [Preserve]
        public UdpDistributedPublisher(UdpWorker worker)
        {
            this.worker = worker;
        }

        public UniTask PublishAsync(TKey key, TMessage message, CancellationToken cancellationToken = default)
        {
            worker.Publish(key, message);
            return default;
        }
    }

    [Preserve]
    public sealed class UdpDistributedSubscriber<TKey, TMessage> : IDistributedSubscriber<TKey, TMessage>
    {
        // Pubsished from UdpWorker.
        readonly MessagePipeInterprocessOptions options;
        readonly IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore;
        readonly FilterAttachedMessageHandlerFactory syncHandlerFactory;
        readonly FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory;

        [Preserve]
        public UdpDistributedSubscriber(UdpWorker worker, MessagePipeInterprocessUdpOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public UdpDistributedSubscriber(UdpWorker worker, MessagePipeInterprocessUdpUdsOptions options, IAsyncSubscriber<IInterprocessKey, IInterprocessValue> subscriberCore, FilterAttachedMessageHandlerFactory syncHandlerFactory, FilterAttachedAsyncMessageHandlerFactory asyncHandlerFactory)
        {
            this.options = options;
            this.subscriberCore = subscriberCore;
            this.syncHandlerFactory = syncHandlerFactory;
            this.asyncHandlerFactory = asyncHandlerFactory;

            worker.StartReceiver();
        }
#endif
        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<MessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IMessageHandler<TMessage> handler, MessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = syncHandlerFactory.CreateMessageHandler(handler, filters);
            var transform = new TransformSyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, CancellationToken cancellationToken = default)
        {
            return SubscribeAsync(key, handler, Array.Empty<AsyncMessageHandlerFilter<TMessage>>(), cancellationToken);
        }

        public UniTask<IUniTaskAsyncDisposable> SubscribeAsync(TKey key, IAsyncMessageHandler<TMessage> handler, AsyncMessageHandlerFilter<TMessage>[] filters, CancellationToken cancellationToken = default)
        {
            handler = asyncHandlerFactory.CreateAsyncMessageHandler(handler, filters);
            var transform = new TransformAsyncMessageHandler<TMessage>(handler, options.MessagePackSerializerOptions);
            return SubscribeCore(key, transform);
        }

        UniTask<IUniTaskAsyncDisposable> SubscribeCore(TKey key, IAsyncMessageHandler<IInterprocessValue> handler)
        {
            var byteKey = MessageBuilder.CreateKey(key, options.MessagePackSerializerOptions);
            var d = subscriberCore.Subscribe(byteKey, handler);
            return new UniTask<IUniTaskAsyncDisposable>(new AsyncDisposableBridge(d));
        }
    }

    
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/UdpDistributedPublisherSubscriber.cs.meta
================================================
fileFormatVersion: 2
guid: 7fdec3aacfbc91d45918f0eb6888ce45
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Unity.meta
================================================
fileFormatVersion: 2
guid: ff969af7ac862c54ca4e1dee654fba52
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers.meta
================================================
fileFormatVersion: 2
guid: cc5f2a403a631aa41ae09d4fc51eaefb
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/ArrayPoolBufferWriter.cs
================================================
using System;
using System.Buffers;

namespace MessagePipe.Interprocess.Internal
{
    internal class ArrayPoolBufferWriter : IBufferWriter<byte>, IDisposable
    {
        byte[] buffer;
        int index;

        const int MinBufferSize = 256;

        public int WrittenCount => index;
        public int Capacity => buffer.Length;
        public int FreeCapacity => buffer.Length - index;

        public ReadOnlySpan<byte> WrittenSpan => buffer.AsSpan(0, index);

        public ArrayPoolBufferWriter()
        {
            buffer = Array.Empty<byte>();
        }

        public void Advance(int count)
        {
            index += count;
        }

        public Memory<byte> GetMemory(int sizeHint = 0)
        {
            EnsureCapacity(sizeHint);
            return buffer.AsMemory(index);
        }

        public Span<byte> GetSpan(int sizeHint = 0)
        {
            EnsureCapacity(sizeHint);
            return buffer.AsSpan(index);
        }

        void EnsureCapacity(int sizeHint)
        {
            if (sizeHint == 0)
            {
                sizeHint = 1;
            }

            if (sizeHint > FreeCapacity)
            {
                var newBuffer = ArrayPool<byte>.Shared.Rent(Math.Max(index + sizeHint, MinBufferSize));
                if (buffer.Length != 0)
                {
                    Array.Copy(buffer, 0, newBuffer, 0, index);
                    ArrayPool<byte>.Shared.Return(buffer);
                }
                buffer = newBuffer;
            }
        }

        public void Dispose()
        {
            if (buffer.Length != 0)
            {
                ArrayPool<byte>.Shared.Return(buffer);
                buffer = Array.Empty<byte>();
            }
        }
    }

}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/ArrayPoolBufferWriter.cs.meta
================================================
fileFormatVersion: 2
guid: 015167c80d0d4434bb058f6c2c277e65
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/AsyncDisposableBridge.cs
================================================
using System;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess.Internal
{
    internal sealed class AsyncDisposableBridge : IUniTaskAsyncDisposable
    {
        readonly IDisposable disposable;

        public AsyncDisposableBridge(IDisposable disposable)
        {
            this.disposable = disposable;
        }

        public UniTask DisposeAsync()
        {
            disposable.Dispose();
            return default;
        }
    }

    
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/AsyncDisposableBridge.cs.meta
================================================
fileFormatVersion: 2
guid: 129478ec22cc4964db9a92d0c61179c3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/Preserve.cs
================================================
namespace MessagePipe.Interprocess.Internal
{
    // Preserve for Unity IL2CPP

    internal class PreserveAttribute : System.Attribute
    {
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/Preserve.cs.meta
================================================
fileFormatVersion: 2
guid: 6fffbb18339d01b4f848380fd8f5e653
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/TransformHandler.cs
================================================
using MessagePack;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess.Internal
{
    internal sealed class TransformSyncMessageHandler<TMessage> : IAsyncMessageHandler<IInterprocessValue>
    {
        readonly IMessageHandler<TMessage> handler;
        readonly MessagePackSerializerOptions options;

        public TransformSyncMessageHandler(IMessageHandler<TMessage> handler, MessagePackSerializerOptions options)
        {
            this.handler = handler;
            this.options = options;
        }

        public UniTask HandleAsync(IInterprocessValue message, CancellationToken cancellationToken)
        {
            var msg = MessagePackSerializer.Deserialize<TMessage>(message.ValueMemory, options);
            handler.Handle(msg);
            return default;
        }
    }

    internal sealed class TransformAsyncMessageHandler<TMessage> : IAsyncMessageHandler<IInterprocessValue>
    {
        readonly IAsyncMessageHandler<TMessage> handler;
        readonly MessagePackSerializerOptions options;

        public TransformAsyncMessageHandler(IAsyncMessageHandler<TMessage> handler, MessagePackSerializerOptions options)
        {
            this.handler = handler;
            this.options = options;
        }

        public UniTask HandleAsync(IInterprocessValue message, CancellationToken cancellationToken)
        {
            var msg = MessagePackSerializer.Deserialize<TMessage>(message.ValueMemory, options);
            return handler.HandleAsync(msg, cancellationToken);
        }
    }

}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Internal/TransformHandler.cs.meta
================================================
fileFormatVersion: 2
guid: d066eb1cdb176f940bffa0356a4f2468
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Unity/TaskShims.cs
================================================
using Cysharp.Threading.Tasks;

namespace MessagePipe
{
    internal static class TaskShims
    {
        internal static UniTask ConfigureAwait(this UniTask task, bool _)
        {
            return task;
        }

        internal static UniTask<T> ConfigureAwait<T>(this UniTask<T> task, bool _)
        {
            return task;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Unity/TaskShims.cs.meta
================================================
fileFormatVersion: 2
guid: 6ae88a82d42ac994aa2c0f4d9145a790
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/NamedPipeWorker.cs
================================================
using MessagePack;
using MessagePipe.Interprocess.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using System.Threading.Channels;
#endif
using System;
using System.Collections.Concurrent;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class NamedPipeWorker : IDisposable
    {
        readonly string pipeName;
        readonly IServiceProvider provider;
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessNamedPipeOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<NamedPipeServerStream> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<NamedPipeClientStream> client;

        // request-response
        int messageId = 0;
        ConcurrentDictionary<int, UniTaskCompletionSource<IInterprocessValue>> responseCompletions = new ConcurrentDictionary<int, UniTaskCompletionSource<IInterprocessValue>>();

        // create from DI
        [Preserve]
        public NamedPipeWorker(IServiceProvider provider, MessagePipeInterprocessNamedPipeOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.pipeName = options.PipeName;
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = CreateLazyServerStream();

            this.client = new Lazy<NamedPipeClientStream>(() =>
            {
                return new NamedPipeClientStream(options.ServerName, options.PipeName, PipeDirection.InOut, PipeOptions.Asynchronous);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }

        Lazy<NamedPipeServerStream> CreateLazyServerStream()
        {
            return new Lazy<NamedPipeServerStream>(() => new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.Asynchronous));
        }

        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        public async UniTask<TResponse> RequestAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var mid = Interlocked.Increment(ref messageId);
            var tcs = new UniTaskCompletionSource<IInterprocessValue>();
            responseCompletions[mid] = tcs;
            var buffer = MessageBuilder.BuildRemoteRequestMessage(typeof(TRequest), typeof(TResponse), mid, request, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
            var memoryValue = await tcs.Task.ConfigureAwait(false);
            return MessagePackSerializer.Deserialize<TResponse>(memoryValue.ValueMemory, options.MessagePackSerializerOptions);
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                RunReceiveLoop(server.Value, x =>
                {
#if !UNITY_2018_3_OR_NEWER
                    return server.Value.WaitForConnectionAsync(x);
#else
                    return System.Threading.Tasks.Task.Run(()=> server.Value.WaitForConnection(), x);
#endif
                });
            }
        }

        // Send packet to udp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var pipeStream = client.Value;

            try
            {
#if !UNITY_2018_3_OR_NEWER
                await pipeStream.ConnectAsync(Timeout.Infinite, token).ConfigureAwait(false);
#else
                await System.Threading.Tasks.Task.Run(() => pipeStream.Connect(), token);
#endif
            }
            catch (IOException)
            {
                return; // connection closed.
            }
            RunReceiveLoop(pipeStream, null); // client connected, setup receive loop

            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await pipeStream.WriteAsync(item, 0, item.Length, token).ConfigureAwait(false);
                    }
                    catch (IOException)
                    {
                        return; // connection closed.
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        // Receive from udp socket and push value to subscribers.
        async void RunReceiveLoop(Stream pipeStream, Func<CancellationToken, System.Threading.Tasks.Task> waitForConnection)
        {
        RECONNECT:
            var token = cancellationTokenSource.Token;
            if (waitForConnection != null)
            {
                try
                {
                    await waitForConnection(token).ConfigureAwait(false);
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
            }
            var buffer = new byte[65536];
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value = Array.Empty<byte>();
                try
                {
                    var readLen = await pipeStream.ReadAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                    if (readLen == 0)
                    {
                        if (waitForConnection != null)
                        {
                            server.Value.Dispose();
                            server = CreateLazyServerStream();
                            pipeStream = server.Value;
                            goto RECONNECT; // end of stream(disconnect, wait reconnect)
                        }
                    }

                    var messageLen = MessageBuilder.FetchMessageLength(buffer);
                    if (readLen == (messageLen + 4))
                    {
                        value = buffer.AsMemory(4, messageLen); // skip length header
                    }
                    else
                    {
                        // read more
                        if (buffer.Length < (messageLen + 4))
                        {
                            Array.Resize(ref buffer, messageLen + 4);
                        }
                        var remain = messageLen - (readLen - 4);
                        await ReadFullyAsync(buffer, pipeStream, readLen, remain, token).ConfigureAwait(false);
                        value = buffer.AsMemory(4, messageLen);
                    }
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }

                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray()); // can avoid copy?
                    switch (message.MessageType)
                    {
                        case MessageType.PubSub:
                            publisher.Publish(message, message, CancellationToken.None);
                            break;
                        case MessageType.RemoteRequest:
                            {
                                // NOTE: should use without reflection(Expression.Compile)
                                var header = Deserialize<RequestHeader>(message.KeyMemory, options.MessagePackSerializerOptions);
                                var (mid, reqTypeName, resTypeName) = (header.MessageId, header.RequestType, header.ResponseType);
                                byte[] resultBytes;
                                try
                                {
                                    var t = AsyncRequestHandlerRegistory.Get(reqTypeName, resTypeName);
                                    var interfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandler"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var coreInterfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var service = provider.GetRequiredService(interfaceType); // IAsyncRequestHandler<TRequest,TResponse>
                                    var genericArgs = interfaceType.GetGenericArguments(); // [TRequest, TResponse]
                                    var request = MessagePackSerializer.Deserialize(genericArgs[0], message.ValueMemory, options.MessagePackSerializerOptions);
                                    var responseTask = coreInterfaceType.GetMethod("InvokeAsync").Invoke(service, new[] { request, CancellationToken.None });
                                    var task = typeof(UniTask<>).MakeGenericType(genericArgs[1]).GetMethod("AsTask").Invoke(responseTask, null);
                                    await ((System.Threading.Tasks.Task)task); // Task<T> -> Task
                                    var result = task.GetType().GetProperty("Result").GetValue(task);
                                    resultBytes = MessageBuilder.BuildRemoteResponseMessage(mid, genericArgs[1], result, options.MessagePackSerializerOptions);
                                }
                                catch (Exception ex)
                                {
                                    // NOTE: ok to send stacktrace?
                                    resultBytes = MessageBuilder.BuildRemoteResponseError(mid, ex.ToString(), options.MessagePackSerializerOptions);
                                }

                                await pipeStream.WriteAsync(resultBytes, 0, resultBytes.Length).ConfigureAwait(false);
                            }
                            break;
                        case MessageType.RemoteResponse:
                        case MessageType.RemoteError:
                            {
                                var mid = Deserialize<int>(message.KeyMemory, options.MessagePackSerializerOptions);
                                if (responseCompletions.TryRemove(mid, out var tcs))
                                {
                                    if (message.MessageType == MessageType.RemoteResponse)
                                    {
                                        tcs.TrySetResult(message); // synchronous completion, use memory buffer immediately.
                                    }
                                    else
                                    {
                                        var errorMsg = MessagePackSerializer.Deserialize<string>(message.ValueMemory, options.MessagePackSerializerOptions);
                                        tcs.TrySetException(new RemoteRequestException(errorMsg));
                                    }
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (IOException)
                {
                    return; // connection closed.
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) continue;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        // omajinai.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options)
        {
            if (buffer.IsEmpty && MemoryMarshal.TryGetArray(buffer, out var segment))
            {
                buffer = segment;
            }
            return MessagePackSerializer.Deserialize<T>(buffer, options);
        }

        static async UniTask ReadFullyAsync(byte[] buffer, Stream stream, int index, int remain, CancellationToken token)
        {
            while (remain > 0)
            {
                var len = await stream.ReadAsync(buffer, index, remain, token).ConfigureAwait(false);
                index += len;
                remain -= len;
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }

            foreach (var item in responseCompletions)
            {
                try
                {
                    item.Value.TrySetCanceled();
                }
                catch { }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/NamedPipeWorker.cs.meta
================================================
fileFormatVersion: 2
guid: a91348f2db3285b42bae2c137ad29266
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/SocketTcpClient.cs
================================================
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess.Workers
{
    // TODO:TCP STREAM AND READ

    internal sealed class SocketTcpServer : IDisposable
    {
        const int MaxConnections = 0x7fffffff;

        readonly Socket socket;

        SocketTcpServer(AddressFamily addressFamily, ProtocolType protocolType, int? sendBufferSize, int? recvBufferSize)
        {
            socket = new Socket(addressFamily, SocketType.Stream, protocolType);
            if(sendBufferSize.HasValue)
            {
                socket.SendBufferSize = sendBufferSize.Value;
            }
            if(recvBufferSize.HasValue)
            {
                socket.ReceiveBufferSize = recvBufferSize.Value;
            }
        }

        public static SocketTcpServer Listen(string host, int port)
        {
            var ip = new IPEndPoint(IPAddress.Parse(host), port);
            var server = new SocketTcpServer(ip.AddressFamily, ProtocolType.Tcp, null, null);

            server.socket.Bind(ip);
            server.socket.Listen(MaxConnections);
            return server;
        }

#if NET5_0_OR_GREATER
        /// <summary>
        /// create TCP unix domain socket server and listen
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <param name="recvBufferSize">socket's receive buffer size</param>
        /// <param name="sendBufferSize">socket's send buffer size</param>
        /// <exception cref="SocketException">unix domain socket not supported or socket already exists</exception>
        /// <returns>TCP unix domain socket server</returns>
        public static SocketTcpServer ListenUds(string domainSocketPath, int? sendBufferSize = null, int? recvBufferSize = null)
        {
            var server = new SocketTcpServer(AddressFamily.Unix, ProtocolType.IP, sendBufferSize, recvBufferSize);
            server.socket.Bind(new UnixDomainSocketEndPoint(domainSocketPath));
            server.socket.Listen(MaxConnections);
            return server;
        }
#endif

        public async void StartAcceptLoopAsync(Action<SocketTcpClient> onAccept, CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                Socket remote = default;
                try
                {
                    remote = await socket.AcceptAsync();
                }
                catch // (ObjectDisposedException)
                {
                    return;
                }
                onAccept(new SocketTcpClient(remote));
            }
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }

    internal sealed class SocketTcpClient : IDisposable
    {
        readonly Socket socket;

        SocketTcpClient(AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Stream, protocolType);
        }

        internal SocketTcpClient(Socket socket)
        {
            this.socket = socket;
        }

        public static SocketTcpClient Connect(string host, int port)
        {
            var ip = new IPEndPoint(IPAddress.Parse(host), port);
            var client = new SocketTcpClient(ip.AddressFamily, ProtocolType.Tcp);
            client.socket.Connect(ip);
            return client;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create TCP unix domain socket client and connect to server
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <exception cref="SocketException">unix domain socket not supported or server does not listen</exception>
        /// <returns>TCP socket client.</returns>
        public static SocketTcpClient ConnectUds(string domainSocketPath)
        {
            var client = new SocketTcpClient(AddressFamily.Unix, ProtocolType.IP);
            client.socket.Connect(new UnixDomainSocketEndPoint(domainSocketPath));
            return client;
        }
#endif

        public async UniTask<int> ReceiveAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
#if NET5_0_OR_GREATER
            var xs = new ArraySegment<byte>(buffer, offset, count);
            var i = await socket.ReceiveAsync(xs, SocketFlags.None, cancellationToken).ConfigureAwait(false);
            return i;
#else
            var tcs = new UniTaskCompletionSource<int>();

            socket.BeginReceive(buffer, offset, count, SocketFlags.None, x =>
            {
                int i;
                try
                {
                    i = socket.EndReceive(x);
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(ex);
                    return;
                }
                tcs.TrySetResult(i);
            }, null);

            return await tcs.Task;
#endif
        }

        public UniTask<int> SendAsync(byte[] buffer, CancellationToken cancellationToken = default)
        {
#if NET5_0_OR_GREATER
            return socket.SendAsync(buffer, SocketFlags.None, cancellationToken);
#else
            var tcs = new UniTaskCompletionSource<int>();
            socket.BeginSend(buffer, 0, buffer.Length, SocketFlags.None, x =>
             {
                 int i;
                 try
                 {
                     i = socket.EndSend(x);
                 }
                 catch (Exception ex)
                 {
                     tcs.TrySetException(ex);
                     return;
                 }
                 tcs.TrySetResult(i);
             }, null);

#if !UNITY_2018_3_OR_NEWER
            return new UniTask<int>(tcs.Task);
#else
            return tcs.Task;
#endif
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/SocketTcpClient.cs.meta
================================================
fileFormatVersion: 2
guid: a30eff1772d617147809a941cf5ae2c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/SocketUdpClient.cs
================================================
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Cysharp.Threading.Tasks;

namespace MessagePipe.Interprocess.Workers
{
    internal sealed class SocketUdpServer : IDisposable
    {
        const int MinBuffer = 4096;

        readonly Socket socket;
        readonly byte[] buffer;

        SocketUdpServer(int bufferSize, AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Dgram, protocolType);
            socket.ReceiveBufferSize = bufferSize;
            buffer = new byte[Math.Max(bufferSize, MinBuffer)];
        }
        public static SocketUdpServer Bind(int port, int bufferSize)
        {
            var server = new SocketUdpServer(bufferSize, AddressFamily.InterNetwork, ProtocolType.Udp);
            server.socket.Bind(new IPEndPoint(IPAddress.Any, port));
            return server;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create UDP socket and bind for listen.
        /// </summary>
        /// <param name="domainSocketPath">path to socket</param>
        /// <param name="bufferSize">socket buffer size</param>
        /// <exception cref="SocketException">unix domain socket not supported or socket already exists even if it is not bound</exception>
        /// <returns>UDP server with bound socket</returns>
        public static SocketUdpServer BindUds(string domainSocketPath, int bufferSize)
        {
            var server = new SocketUdpServer(bufferSize, AddressFamily.Unix, ProtocolType.IP);
            server.socket.Bind(new UnixDomainSocketEndPoint(domainSocketPath));
            return server;
        }
#endif

        public async UniTask<ReadOnlyMemory<byte>> ReceiveAsync(CancellationToken cancellationToken)
        {
#if NET5_0_OR_GREATER
            var i = await socket.ReceiveAsync(buffer, SocketFlags.None, cancellationToken).ConfigureAwait(false);
            return buffer.AsMemory(0, i);
#else
            var tcs = new UniTaskCompletionSource<ReadOnlyMemory<byte>>();

            socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, x =>
            {
                int i;
                try
                {
                    i = socket.EndReceive(x);
                }
                catch (Exception ex)
                {
                    tcs.TrySetException(ex);
                    return;
                }
                var r = buffer.AsMemory(0, i);
                tcs.TrySetResult(r);
            }, null);

            return await tcs.Task;
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }

    internal sealed class SocketUdpClient : IDisposable
    {
        const int MinBuffer = 4096;

        readonly Socket socket;
        readonly byte[] buffer;

        SocketUdpClient(int bufferSize, AddressFamily addressFamily, ProtocolType protocolType)
        {
            socket = new Socket(addressFamily, SocketType.Dgram, protocolType);
            socket.SendBufferSize = bufferSize;
            buffer = new byte[Math.Max(bufferSize, MinBuffer)];
        }

        public static SocketUdpClient Connect(string host, int port, int bufferSize)
        {
            var ipaddr = IPAddress.Parse(host);
            var client = new SocketUdpClient(bufferSize, ipaddr.AddressFamily, ProtocolType.Udp);
            client.socket.Connect(new IPEndPoint(ipaddr, port));
            return client;
        }
#if NET5_0_OR_GREATER
        /// <summary>
        /// create UDP unix domain socket client and connect to server
        /// </summary>
        /// <param name="domainSocketPath">path to unix domain socket</param>
        /// <param name="bufferSize"></param>
        /// <exception cref="SocketException">unix domain socket not supported or server does not exist</exception>
        /// <returns>UDP unix domain socket client</returns>
        public static SocketUdpClient ConnectUds(string domainSocketPath, int bufferSize)
        {
            var client = new SocketUdpClient(bufferSize, AddressFamily.Unix, ProtocolType.IP);
            client.socket.Connect(new UnixDomainSocketEndPoint(domainSocketPath));
            return client;
        }
#endif

        public UniTask<int> SendAsync(byte[] buffer, CancellationToken cancellationToken = default)
        {
#if NET5_0_OR_GREATER
            return socket.SendAsync(buffer, SocketFlags.None, cancellationToken);
#else
            var tcs = new UniTaskCompletionSource<int>();
            socket.BeginSend(buffer, 0, buffer.Length, SocketFlags.None, x =>
             {
                 int i;
                 try
                 {
                     i = socket.EndSend(x);
                 }
                 catch (Exception ex)
                 {
                     tcs.TrySetException(ex);
                     return;
                 }
                 tcs.TrySetResult(i);
             }, null);
#if !UNITY_2018_3_OR_NEWER
            return new UniTask<int>(tcs.Task);
#else
            return tcs.Task;
#endif
#endif
        }

        public void Dispose()
        {
            socket.Dispose();
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/SocketUdpClient.cs.meta
================================================
fileFormatVersion: 2
guid: 9616308e8ca62ac40be728df4edf96b6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/TcpWorker.cs
================================================
using MessagePack;
using MessagePipe.Interprocess.Internal;
#if !UNITY_2018_3_OR_NEWER
using Microsoft.Extensions.DependencyInjection;
using System.Threading.Channels;
#endif
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class TcpWorker : IDisposable
    {
        readonly IServiceProvider provider;
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<SocketTcpServer> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<SocketTcpClient> client;

        // request-response
        int messageId = 0;
        ConcurrentDictionary<int, UniTaskCompletionSource<IInterprocessValue>> responseCompletions = new ConcurrentDictionary<int, UniTaskCompletionSource<IInterprocessValue>>();

        // create from DI
        [Preserve]
        public TcpWorker(IServiceProvider provider, MessagePipeInterprocessTcpOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketTcpServer>(() =>
            {
                return SocketTcpServer.Listen(options.Host, options.Port);
            });

            this.client = new Lazy<SocketTcpClient>(() =>
            {
                return SocketTcpClient.Connect(options.Host, options.Port);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public TcpWorker(IServiceProvider provider, MessagePipeInterprocessTcpUdsOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.provider = provider;
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketTcpServer>(() =>
            {
                return SocketTcpServer.ListenUds(options.SocketPath);
            });

            this.client = new Lazy<SocketTcpClient>(() =>
            {
                return SocketTcpClient.ConnectUds(options.SocketPath);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif

            if (options.HostAsServer != null && options.HostAsServer.Value)
            {
                StartReceiver();
            }
        }
#endif
        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        public async UniTask<TResponse> RequestAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var mid = Interlocked.Increment(ref messageId);
            var tcs = new UniTaskCompletionSource<IInterprocessValue>();
            responseCompletions[mid] = tcs;
            var buffer = MessageBuilder.BuildRemoteRequestMessage(typeof(TRequest), typeof(TResponse), mid, request, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
            var memoryValue = await tcs.Task.ConfigureAwait(false);
            return MessagePackSerializer.Deserialize<TResponse>(memoryValue.ValueMemory, options.MessagePackSerializerOptions);
        }

        // Send packet to tcp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var tcpClient = client.Value;
            RunReceiveLoop(tcpClient); // also setup receive loop

            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await tcpClient.SendAsync(item, token).ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                var s = server.Value; // init
                s.StartAcceptLoopAsync(RunReceiveLoop, cancellationTokenSource.Token);
            }
        }

        // Receive from tcp socket and push value to subscribers.
        async void RunReceiveLoop(SocketTcpClient client)
        {
            var token = cancellationTokenSource.Token;
            var buffer = new byte[65536];
            ReadOnlyMemory<byte> readBuffer = Array.Empty<byte>();
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value = Array.Empty<byte>();
                try
                {
                    if (readBuffer.Length == 0)
                    {
                        var readLen = await client.ReceiveAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                        if (readLen == 0) return; // end of stream(disconnect)
                        readBuffer = buffer.AsMemory(0, readLen);
                    }
                    else if (readBuffer.Length < 4) // rare case
                    {
                        var readLen = await client.ReceiveAsync(buffer, 0, buffer.Length, token).ConfigureAwait(false);
                        if (readLen == 0) return;
                        var newBuffer = new byte[readBuffer.Length + readLen];
                        readBuffer.CopyTo(newBuffer);
                        buffer.AsSpan(readLen).CopyTo(newBuffer.AsSpan(readBuffer.Length));
                        readBuffer = newBuffer;
                    }

                    var messageLen = MessageBuilder.FetchMessageLength(readBuffer.Span);
                    if (readBuffer.Length == (messageLen + 4)) // just size
                    {
                        value = readBuffer.Slice(4, messageLen); // skip length header
                        readBuffer = Array.Empty<byte>();
                        goto PARSE_MESSAGE;
                    }
                    else if (readBuffer.Length > (messageLen + 4)) // over size
                    {
                        value = readBuffer.Slice(4, messageLen);
                        readBuffer = readBuffer.Slice(messageLen + 4);
                        goto PARSE_MESSAGE;
                    }
                    else // needs to read more
                    {
                        var readLen = readBuffer.Length;
                        if (readLen < (messageLen + 4))
                        {
                            if (readBuffer.Length != buffer.Length)
                            {
                                var newBuffer = new byte[buffer.Length];
                                readBuffer.CopyTo(newBuffer);
                                buffer = newBuffer;
                            }

                            if (buffer.Length < messageLen + 4)
                            {
                                Array.Resize(ref buffer, messageLen + 4);
                            }
                        }
                        var remain = messageLen - (readLen - 4);
                        await ReadFullyAsync(buffer, client, readLen, remain, token).ConfigureAwait(false);
                        value = buffer.AsMemory(4, messageLen);
                        readBuffer = Array.Empty<byte>();
                        goto PARSE_MESSAGE;
                    }
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }
            PARSE_MESSAGE:
                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray()); // can avoid copy?
                    switch (message.MessageType)
                    {
                        case MessageType.PubSub:
                            publisher.Publish(message, message, CancellationToken.None);
                            break;
                        case MessageType.RemoteRequest:
                            {
                                // NOTE: should use without reflection(Expression.Compile)
                                var header = Deserialize<RequestHeader>(message.KeyMemory, options.MessagePackSerializerOptions);
                                var (mid, reqTypeName, resTypeName) = (header.MessageId, header.RequestType, header.ResponseType);
                                byte[] resultBytes;
                                try
                                {
                                    var t = AsyncRequestHandlerRegistory.Get(reqTypeName, resTypeName);
                                    var interfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandler"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var coreInterfaceType = t.GetInterfaces().Where(x => x.IsGenericType && x.Name.StartsWith("IAsyncRequestHandlerCore"))
                                        .First(x => x.GetGenericArguments().Any(y => y.FullName == header.RequestType));
                                    var service = provider.GetRequiredService(interfaceType); // IAsyncRequestHandler<TRequest,TResponse>
                                    var genericArgs = interfaceType.GetGenericArguments(); // [TRequest, TResponse]
                                    // Unity IL2CPP does not work(can not invoke nongenerics MessagePackSerializer)
                                    var request = MessagePackSerializer.Deserialize(genericArgs[0], message.ValueMemory, options.MessagePackSerializerOptions);
                                    var responseTask = coreInterfaceType.GetMethod("InvokeAsync").Invoke(service, new[] { request, CancellationToken.None });
#if !UNITY_2018_3_OR_NEWER
                                    var task = typeof(UniTask<>).MakeGenericType(genericArgs[1]).GetMethod("AsTask").Invoke(responseTask, null);
#else
                                    var asTask = typeof(UniTaskExtensions).GetMethods().First(x => x.IsGenericMethod && x.Name == "AsTask")
                                        .MakeGenericMethod(genericArgs[1]);
                                    var task = asTask.Invoke(null, new[] { responseTask });
#endif
                                    await ((System.Threading.Tasks.Task)task); // Task<T> -> Task
                                    var result = task.GetType().GetProperty("Result").GetValue(task);
                                    resultBytes = MessageBuilder.BuildRemoteResponseMessage(mid, genericArgs[1], result, options.MessagePackSerializerOptions);
                                }
                                catch (Exception ex)
                                {
                                    // NOTE: ok to send stacktrace?
                                    resultBytes = MessageBuilder.BuildRemoteResponseError(mid, ex.ToString(), options.MessagePackSerializerOptions);
                                }

                                await client.SendAsync(resultBytes).ConfigureAwait(false);
                            }
                            break;
                        case MessageType.RemoteResponse:
                        case MessageType.RemoteError:
                            {
                                var mid = Deserialize<int>(message.KeyMemory, options.MessagePackSerializerOptions);
                                if (responseCompletions.TryRemove(mid, out var tcs))
                                {
                                    if (message.MessageType == MessageType.RemoteResponse)
                                    {
                                        tcs.TrySetResult(message); // synchronous completion, use memory buffer immediately.
                                    }
                                    else
                                    {
                                        var errorMsg = MessagePackSerializer.Deserialize<string>(message.ValueMemory, options.MessagePackSerializerOptions);
                                        tcs.TrySetException(new RemoteRequestException(errorMsg));
                                    }
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) continue;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        // omajinai.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options)
        {
            if (buffer.IsEmpty && MemoryMarshal.TryGetArray(buffer, out var segment))
            {
                buffer = segment;
            }
            return MessagePackSerializer.Deserialize<T>(buffer, options);
        }

        static async UniTask ReadFullyAsync(byte[] buffer, SocketTcpClient client, int index, int remain, CancellationToken token)
        {
            while (remain > 0)
            {
                var len = await client.ReceiveAsync(buffer, index, remain, token).ConfigureAwait(false);
                index += len;
                remain -= len;
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/TcpWorker.cs.meta
================================================
fileFormatVersion: 2
guid: e637fd355b5ec5c49840d43bb56e2c31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/UdpWorker.cs
================================================
using MessagePipe.Interprocess.Internal;
using System;
using System.Threading;
#if !UNITY_2018_3_OR_NEWER
using System.Threading.Channels;
#else
using Cysharp.Threading.Tasks;
#endif

namespace MessagePipe.Interprocess.Workers
{
    [Preserve]
    public sealed class UdpWorker : IDisposable
    {
        readonly CancellationTokenSource cancellationTokenSource;
        readonly IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher;
        readonly MessagePipeInterprocessOptions options;

        // Channel is used from publisher for thread safety of write packet
        int initializedServer = 0;
        Lazy<SocketUdpServer> server;
        Channel<byte[]> channel;

        int initializedClient = 0;
        Lazy<SocketUdpClient> client;

        // create from DI
        [Preserve]
        public UdpWorker(MessagePipeInterprocessUdpOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketUdpServer>(() =>
            {
                return SocketUdpServer.Bind(options.Port, 0x10000);
            });

            this.client = new Lazy<SocketUdpClient>(() =>
            {
                return SocketUdpClient.Connect(options.Host, options.Port, 0x10000);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif
        }
#if NET5_0_OR_GREATER
        [Preserve]
        public UdpWorker(MessagePipeInterprocessUdpUdsOptions options, IAsyncPublisher<IInterprocessKey, IInterprocessValue> publisher)
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            this.options = options;
            this.publisher = publisher;

            this.server = new Lazy<SocketUdpServer>(() =>
            {
                return SocketUdpServer.BindUds(options.SocketPath, 0x10000);
            });

            this.client = new Lazy<SocketUdpClient>(() =>
            {
                return SocketUdpClient.ConnectUds(options.SocketPath, 0x10000);
            });

#if !UNITY_2018_3_OR_NEWER
            this.channel = Channel.CreateUnbounded<byte[]>(new UnboundedChannelOptions()
            {
                SingleReader = true,
                SingleWriter = false,
                AllowSynchronousContinuations = true
            });
#else
            this.channel = Channel.CreateSingleConsumerUnbounded<byte[]>();
#endif
        }
#endif
        public void Publish<TKey, TMessage>(TKey key, TMessage message)
        {
            if (Interlocked.Increment(ref initializedClient) == 1) // first incr, channel not yet started
            {
                _ = client.Value; // init
                RunPublishLoop();
            }

            var buffer = MessageBuilder.BuildPubSubMessage(key, message, options.MessagePackSerializerOptions);
            channel.Writer.TryWrite(buffer);
        }

        // Send packet to udp socket from publisher
        async void RunPublishLoop()
        {
            var reader = channel.Reader;
            var token = cancellationTokenSource.Token;
            var udpClient = client.Value;
            while (await reader.WaitToReadAsync(token).ConfigureAwait(false))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        await udpClient.SendAsync(item, token).ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException) return;
                        if (token.IsCancellationRequested) return;

                        // network error, terminate.
                        options.UnhandledErrorHandler("network error, publish loop will terminate." + Environment.NewLine, ex);
                        return;
                    }
                }
            }
        }

        public void StartReceiver()
        {
            if (Interlocked.Increment(ref initializedServer) == 1) // first incr, channel not yet started
            {
                _ = server.Value; // init
                RunReceiveLoop();
            }
        }

        // Receive from udp socket and push value to subscribers.
        async void RunReceiveLoop()
        {
            var token = cancellationTokenSource.Token;
            var udpServer = server.Value;
            while (!token.IsCancellationRequested)
            {
                ReadOnlyMemory<byte> value;
                try
                {
                    value = await udpServer.ReceiveAsync(token).ConfigureAwait(false);
                    if (value.Length == 0) return; // invalid data?
                    var len = MessageBuilder.FetchMessageLength(value.Span);
                    if (len != value.Length - 4)
                    {
                        throw new InvalidOperationException("Receive invalid message size.");
                    }
                    value = value.Slice(4);
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;

                    // network error, terminate.
                    options.UnhandledErrorHandler("network error, receive loop will terminate." + Environment.NewLine, ex);
                    return;
                }

                try
                {
                    var message = MessageBuilder.ReadPubSubMessage(value.ToArray());
                    publisher.Publish(message, message, CancellationToken.None);
                }
                catch (Exception ex)
                {
                    if (ex is OperationCanceledException) return;
                    if (token.IsCancellationRequested) return;
                    options.UnhandledErrorHandler("", ex);
                }
            }
        }

        public void Dispose()
        {
            channel.Writer.TryComplete();

            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();

            if (server.IsValueCreated)
            {
                server.Value.Dispose();
            }

            if (client.IsValueCreated)
            {
                client.Value.Dispose();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/Runtime/Workers/UdpWorker.cs.meta
================================================
fileFormatVersion: 2
guid: 7390505aba224e34fbbc43eeeabe05a0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/package.json
================================================
{
    "name": "com.cysharp.messagepipe.vcontainer",
    "displayName": "MessagePipe.VContainer",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.8.1",
    "unity": "2018.4",
    "description": "MessagePipe Runtime support for VContainer.",
    "keywords": [ "pubsub", "event", "Scripting", "DI" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/package.json.meta
================================================
fileFormatVersion: 2
guid: 16aae42d17b85f946bd162c0092ead72
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime.meta
================================================
fileFormatVersion: 2
guid: b59663ecd1008f54889bccf8b7ee3233
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/ContainerBuilderExtensions.cs
================================================
﻿using System;
using VContainer;
using MessagePipe.VContainer;

namespace MessagePipe
{
    public static class ContainerBuilderExtensions
    {
        // original is ServiceCollectionExtensions, trimed openegenerics register.

        public static MessagePipeOptions RegisterMessagePipe(this IContainerBuilder builder)
        {
            return RegisterMessagePipe(builder, _ => { });
        }

        public static MessagePipeOptions RegisterMessagePipe(this IContainerBuilder builder, Action<MessagePipeOptions> configure)
        {
            MessagePipeOptions options = null;
            var proxy = new ContainerBuilderProxy(builder);
            proxy.AddMessagePipe(x =>
            {
                configure(x);
                options = x;
            });

            builder.Register<IServiceProvider, ObjectResolverProxy>(Lifetime.Scoped);

            return options;
        }

        /// <summary>Register IPublisher[TMessage] and ISubscriber[TMessage](includes Async/Buffered) to container builder.</summary>
        public static IContainerBuilder RegisterMessageBroker<TMessage>(this IContainerBuilder builder, MessagePipeOptions options)
        {
            var lifetime = GetLifetime(options.InstanceLifetime);
            var services = new ContainerBuilderProxy(builder);

            // keyless PubSub
            services.Add(typeof(MessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IPublisher<TMessage>), typeof(MessageBroker<TMessage>), lifetime);
            services.Add(typeof(ISubscriber<TMessage>), typeof(MessageBroker<TMessage>), lifetime);

            // keyless PubSub async
            services.Add(typeof(AsyncMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IAsyncPublisher<TMessage>), typeof(AsyncMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IAsyncSubscriber<TMessage>), typeof(AsyncMessageBroker<TMessage>), lifetime);

            // keyless buffered PubSub
            services.Add(typeof(BufferedMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IBufferedPublisher<TMessage>), typeof(BufferedMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IBufferedSubscriber<TMessage>), typeof(BufferedMessageBroker<TMessage>), lifetime);

            // keyless buffered PubSub async
            services.Add(typeof(BufferedAsyncMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IBufferedAsyncPublisher<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IBufferedAsyncSubscriber<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>), lifetime);

            return builder;
        }

        /// <summary>Register IPublisher[TKey, TMessage] and ISubscriber[TKey, TMessage](includes Async) to container builder.</summary>
        public static IContainerBuilder RegisterMessageBroker<TKey, TMessage>(this IContainerBuilder builder, MessagePipeOptions options)
        {
            var lifetime = GetLifetime(options.InstanceLifetime);
            var services = new ContainerBuilderProxy(builder);

            // keyed PubSub
            services.Add(typeof(MessageBrokerCore<TKey, TMessage>), lifetime);
            services.Add(typeof(IPublisher<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>), lifetime);
            services.Add(typeof(ISubscriber<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>), lifetime);

            // keyed PubSub async
            services.Add(typeof(AsyncMessageBrokerCore<TKey, TMessage>), lifetime);
            services.Add(typeof(IAsyncPublisher<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), lifetime);
            services.Add(typeof(IAsyncSubscriber<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), lifetime);

            return builder;
        }

        /// <summary>Register IRequestHandler[TRequest, TResponse](includes All) to container builder.</summary>
        public static IContainerBuilder RegisterRequestHandler<TRequest, TResponse, THandler>(this IContainerBuilder builder, MessagePipeOptions options)
            where THandler : IRequestHandler
        {
            var lifetime = GetLifetime(options.RequestHandlerLifetime);
            var services = new ContainerBuilderProxy(builder);

            services.Add(typeof(IRequestHandlerCore<TRequest, TResponse>), typeof(THandler), lifetime);
            if (!builder.Exists(typeof(IRequestHandler<TRequest, TResponse>), true))
            {
                services.Add(typeof(IRequestHandler<TRequest, TResponse>), typeof(RequestHandler<TRequest, TResponse>), lifetime);
                services.Add(typeof(IRequestAllHandler<TRequest, TResponse>), typeof(RequestAllHandler<TRequest, TResponse>), lifetime);
            }

            return builder;
        }

        /// <summary>Register IAsyncRequestHandler[TRequest, TResponse](includes All) to container builder.</summary>
        public static IContainerBuilder RegisterAsyncRequestHandler<TRequest, TResponse, THandler>(this IContainerBuilder builder, MessagePipeOptions options)
            where THandler : IAsyncRequestHandler
        {
            var lifetime = GetLifetime(options.RequestHandlerLifetime);
            var services = new ContainerBuilderProxy(builder);

            services.Add(typeof(IAsyncRequestHandlerCore<TRequest, TResponse>), typeof(THandler), lifetime);
            if (!builder.Exists(typeof(IAsyncRequestHandler<TRequest, TResponse>), true))
            {
                services.Add(typeof(IAsyncRequestHandler<TRequest, TResponse>), typeof(AsyncRequestHandler<TRequest, TResponse>), lifetime);
                services.Add(typeof(IAsyncRequestAllHandler<TRequest, TResponse>), typeof(AsyncRequestAllHandler<TRequest, TResponse>), lifetime);
            }

            AsyncRequestHandlerRegistory.Add(typeof(TRequest), typeof(TResponse), typeof(THandler));
            return builder;
        }

        public static IContainerBuilder RegisterMessageHandlerFilter<T>(this IContainerBuilder builder)
            where T : class, IMessageHandlerFilter
        {
            if (!builder.Exists(typeof(T), true))
            {
                builder.Register<T>(Lifetime.Transient);
            }
            return builder;
        }

        public static IContainerBuilder RegisterAsyncMessageHandlerFilter<T>(this IContainerBuilder builder)
            where T : class, IAsyncMessageHandlerFilter
        {
            if (!builder.Exists(typeof(T), true))
            {
                builder.Register<T>(Lifetime.Transient);
            }
            return builder;
        }

        public static IContainerBuilder RegisterRequestHandlerFilter<T>(this IContainerBuilder builder)
            where T : class, IRequestHandlerFilter
        {
            if (!builder.Exists(typeof(T), true))
            {
                builder.Register<T>(Lifetime.Transient);
            }
            return builder;
        }

        public static IContainerBuilder RegisterAsyncRequestHandlerFilter<T>(this IContainerBuilder builder)
            where T : class, IAsyncRequestHandlerFilter
        {
            if (!builder.Exists(typeof(T), true))
            {
                builder.Register<T>(Lifetime.Transient);
            }

            return builder;
        }

        public static IServiceCollection AsServiceCollection(this IContainerBuilder builder)
        {
            return new ContainerBuilderProxy(builder);
        }

        public static IMessagePipeBuilder ToMessagePipeBuilder(this IContainerBuilder builder)
        {
            return new MessagePipeBuilder(builder.AsServiceCollection());
        }

        static Lifetime GetLifetime(InstanceLifetime lifetime)
        {
            return (lifetime == InstanceLifetime.Scoped) ? Lifetime.Scoped
                : (lifetime == InstanceLifetime.Singleton) ? Lifetime.Singleton
                : Lifetime.Transient;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/ContainerBuilderExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: c8b1b505a5083524f987a59b06841900
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/MessagePipe.VContainer.asmdef
================================================
 {
    "name": "MessagePipe.VContainer",
    "rootNamespace": "MessagePipe",
    "references": [
        "VContainer",
        "MessagePipe"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
           {
            "name": "com.cysharp.messagepipe.interprocess",
            "expression": "",
            "define": "MESSAGEPIPE_INTERPROCESS_SUPPORT"
        }
    ],
    "noEngineReferences": true
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/MessagePipe.VContainer.asmdef.meta
================================================
fileFormatVersion: 2
guid: 4f682e06dbb3e624faedad9cc27106cc
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/TypeProxy.cs
================================================
﻿using MessagePipe.VContainer;
using System;
using VContainer;

namespace MessagePipe.VContainer
{
    internal class ContainerBuilderProxy : IServiceCollection
    {
        readonly IContainerBuilder builder;

        public ContainerBuilderProxy(IContainerBuilder builder)
        {
            this.builder = builder;
        }

        public void AddTransient(Type type)
        {
            builder.Register(type, Lifetime.Transient);
        }

        public void TryAddTransient(Type type)
        {
            if (!builder.Exists(type, true))
            {
                builder.Register(type, Lifetime.Transient);
            }
        }

        public void AddSingleton<T>(T instance)
        {
            builder.RegisterInstance<T>(instance);
        }

        public void AddSingleton(Type type)
        {
            builder.Register(type, Lifetime.Singleton);
        }

        public void Add(Type type, Lifetime lifetime)
        {
            builder.Register(type, lifetime);
        }

        public void Add(Type serviceType, Type implementationType, Lifetime lifetime)
        {
            builder.Register(implementationType, lifetime).As(serviceType);
        }

        public void Add(Type serviceType, InstanceLifetime lifetime)
        {
            var l = (lifetime == InstanceLifetime.Singleton) ? Lifetime.Singleton
                : (lifetime == InstanceLifetime.Scoped) ? Lifetime.Scoped
                : Lifetime.Transient;
            
            builder.Register(serviceType, l);
        }

        public void Add(Type serviceType, Type implementationType, InstanceLifetime lifetime)
        {
            var l = (lifetime == InstanceLifetime.Singleton) ? Lifetime.Singleton
                  : (lifetime == InstanceLifetime.Scoped) ? Lifetime.Scoped
                  : Lifetime.Transient;

            builder.Register(implementationType, l).As(serviceType);
        }
    }

    [Preserve]
    public sealed class ObjectResolverProxy : IServiceProvider
    {
        IObjectResolver resolver;

        [Preserve]
        public ObjectResolverProxy(IObjectResolver resolver)
        {
            this.resolver = resolver;
        }

        public object GetService(Type serviceType)
        {
            return resolver.Resolve(serviceType);
        }
    }
}

namespace MessagePipe
{
    public static class ObjectResolverExtensions
    {
        public static IServiceProvider AsServiceProvider(this IObjectResolver resolver)
        {
            return new ObjectResolverProxy(resolver);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/Runtime/TypeProxy.cs.meta
================================================
fileFormatVersion: 2
guid: 241eea8f2b79e4d4cb3d40f6c76ed4a5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/package.json
================================================
{
    "name": "com.cysharp.messagepipe.zenject",
    "displayName": "MessagePipe.Zenject",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.8.1",
    "unity": "2018.4",
    "description": "MessagePipe Runtime support for Zenject.",
    "keywords": [ "pubsub", "event", "Scripting", "DI" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/package.json.meta
================================================
fileFormatVersion: 2
guid: 47ceacdcdba6cf748af45f07147cc3ab
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime.meta
================================================
fileFormatVersion: 2
guid: 13239d66a4123e24882db50c8bfd483f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/DiContainerExtensions.cs
================================================
using System;
using Zenject;
using MessagePipe.Zenject;

namespace MessagePipe
{
    public static partial class DiContainerExtensions
    {
        // original is ServiceCollectionExtensions, trimed openegenerics register.

        public static MessagePipeOptions BindMessagePipe(this DiContainer builder)
        {
            return BindMessagePipe(builder, _ => { });
        }

        public static MessagePipeOptions BindMessagePipe(this DiContainer builder, Action<MessagePipeOptions> configure)
        {
            MessagePipeOptions options = null;
            var proxy = new DiContainerProxy(builder);
            proxy.AddMessagePipe(x =>
            {
                configure(x);
                options = x;

                // Zenject 6 does not allow regsiter multiple singleton, it causes annoying error.
                // https://github.com/modesttree/Zenject#upgrade-guide-for-zenject-6
                // so force use Scoped.
                options.InstanceLifetime = (options.InstanceLifetime == InstanceLifetime.Singleton)
                    ? InstanceLifetime.Scoped
                    : options.InstanceLifetime;
                options.RequestHandlerLifetime = (options.RequestHandlerLifetime == InstanceLifetime.Singleton)
                    ? InstanceLifetime.Scoped
                    : options.RequestHandlerLifetime;
            });

            builder.Bind<IServiceProvider>().To<DiContainerProviderProxy>().AsCached();

            return options;
        }

        /// <summary>Register IPublisher[TMessage] and ISubscriber[TMessage](includes Async/Buffered) to container builder.</summary>
        public static DiContainer BindMessageBroker<TMessage>(this DiContainer builder, MessagePipeOptions options)
        {
            var lifetime = options.InstanceLifetime;
            var services = new DiContainerProxy(builder);

            // keyless PubSub
            services.Add(typeof(MessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IPublisher<TMessage>), typeof(MessageBroker<TMessage>), lifetime);
            services.Add(typeof(ISubscriber<TMessage>), typeof(MessageBroker<TMessage>), lifetime);

            // keyless PubSub async
            services.Add(typeof(AsyncMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IAsyncPublisher<TMessage>), typeof(AsyncMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IAsyncSubscriber<TMessage>), typeof(AsyncMessageBroker<TMessage>), lifetime);

            // keyless buffered PubSub
            services.Add(typeof(BufferedMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IBufferedPublisher<TMessage>), typeof(BufferedMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IBufferedSubscriber<TMessage>), typeof(BufferedMessageBroker<TMessage>), lifetime);

            // keyless buffered PubSub async
            services.Add(typeof(BufferedAsyncMessageBrokerCore<TMessage>), lifetime);
            services.Add(typeof(IBufferedAsyncPublisher<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>), lifetime);
            services.Add(typeof(IBufferedAsyncSubscriber<TMessage>), typeof(BufferedAsyncMessageBroker<TMessage>), lifetime);

            return builder;
        }

        /// <summary>Register IPublisher[TKey, TMessage] and ISubscriber[TKey, TMessage](includes Async) to container builder.</summary>
        public static DiContainer BindMessageBroker<TKey, TMessage>(this DiContainer builder, MessagePipeOptions options)
        {
            var lifetime = options.InstanceLifetime;
            var services = new DiContainerProxy(builder);

            // keyed PubSub
            services.Add(typeof(MessageBrokerCore<TKey, TMessage>), lifetime);
            services.Add(typeof(IPublisher<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>), lifetime);
            services.Add(typeof(ISubscriber<TKey, TMessage>), typeof(MessageBroker<TKey, TMessage>), lifetime);

            // keyed PubSub async
            services.Add(typeof(AsyncMessageBrokerCore<TKey, TMessage>), lifetime);
            services.Add(typeof(IAsyncPublisher<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), lifetime);
            services.Add(typeof(IAsyncSubscriber<TKey, TMessage>), typeof(AsyncMessageBroker<TKey, TMessage>), lifetime);

            return builder;
        }

        /// <summary>Register IRequestHandler[TRequest, TResponse](includes All) to container builder.</summary>
        public static DiContainer BindRequestHandler<TRequest, TResponse, THandler>(this DiContainer builder, MessagePipeOptions options)
            where THandler : IRequestHandler
        {
            var lifetime = options.RequestHandlerLifetime;
            var services = new DiContainerProxy(builder);

            services.Add(typeof(IRequestHandlerCore<TRequest, TResponse>), typeof(THandler), lifetime);
            if (!builder.HasBinding<IRequestHandler<TRequest, TResponse>>())
            {
                services.Add(typeof(IRequestHandler<TRequest, TResponse>), typeof(RequestHandler<TRequest, TResponse>), lifetime);
                services.Add(typeof(IRequestAllHandler<TRequest, TResponse>), typeof(RequestAllHandler<TRequest, TResponse>), lifetime);
            }
            return builder;
        }

        /// <summary>Register IAsyncRequestHandler[TRequest, TResponse](includes All) to container builder.</summary>
        public static DiContainer BindAsyncRequestHandler<TRequest, TResponse, THandler>(this DiContainer builder, MessagePipeOptions options)
            where THandler : IAsyncRequestHandler
        {
            var lifetime = options.RequestHandlerLifetime;
            var services = new DiContainerProxy(builder);

            services.Add(typeof(IAsyncRequestHandlerCore<TRequest, TResponse>), typeof(THandler), lifetime);
            if (!builder.HasBinding<IAsyncRequestHandler<TRequest, TResponse>>())
            {
                services.Add(typeof(IAsyncRequestHandler<TRequest, TResponse>), typeof(AsyncRequestHandler<TRequest, TResponse>), lifetime);
                services.Add(typeof(IAsyncRequestAllHandler<TRequest, TResponse>), typeof(AsyncRequestAllHandler<TRequest, TResponse>), lifetime);
            }

            AsyncRequestHandlerRegistory.Add(typeof(TRequest), typeof(TResponse), typeof(THandler));
            return builder;
        }

        public static DiContainer BindMessageHandlerFilter<T>(this DiContainer builder)
            where T : class, IMessageHandlerFilter
        {
            if (!builder.HasBinding<T>())
            {
                builder.Bind<T>().AsTransient();
            }
            return builder;
        }

        public static DiContainer BindAsyncMessageHandlerFilter<T>(this DiContainer builder)
            where T : class, IAsyncMessageHandlerFilter
        {
            if (!builder.HasBinding<T>())
            {
                builder.Bind<T>().AsTransient();
            }
            return builder;
        }

        public static DiContainer BindRequestHandlerFilter<T>(this DiContainer builder)
            where T : class, IRequestHandlerFilter
        {
            if (!builder.HasBinding<T>())
            {
                builder.Bind<T>().AsTransient();
            }
            return builder;
        }

        public static DiContainer BindAsyncRequestHandlerFilter<T>(this DiContainer builder)
            where T : class, IAsyncRequestHandlerFilter
        {
            if (!builder.HasBinding<T>())
            {
                builder.Bind<T>().AsTransient();
            }
            return builder;
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/DiContainerExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: dcf52f579fdee4c498aa8bc9cd7cbd72
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/MessagePipe.Zenject.asmdef
================================================
{
    "name": "MessagePipe.Zenject",
    "rootNamespace": "",
    "references": [
        "MessagePipe",
        "Zenject"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": true
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/MessagePipe.Zenject.asmdef.meta
================================================
fileFormatVersion: 2
guid: b061a8094acaa444a90087c499c32e6e
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/TypeProxy.cs
================================================
﻿using MessagePipe.Zenject;
using System;
using Zenject;
using Zenject.Internal;

namespace MessagePipe.Zenject
{
    internal struct DiContainerProxy : IServiceCollection
    {
        readonly DiContainer builder;

        public DiContainerProxy(DiContainer builder)
        {
            this.builder = builder;
        }

        public void AddTransient(Type type)
        {
            builder.Bind(type).AsTransient();
        }

        public void TryAddTransient(Type type)
        {
            if (!builder.HasBinding(type))
            {
                builder.Bind(type).AsTransient();
            }
        }

        public void AddSingleton<T>(T instance)
        {
            builder.BindInstance(instance).AsSingle();
        }

        public void AddSingleton(Type type)
        {
            builder.Bind(type).AsSingle();
        }

        public void Add(Type type, InstanceLifetime lifetime)
        {
            var binder = builder.Bind(type);
            SetScope(binder, lifetime);
        }

        public void Add(Type serviceType, Type implementationType, InstanceLifetime lifetime)
        {
            var binder = builder.Bind(serviceType).To(implementationType);
            SetScope(binder, lifetime);
        }

        private void SetScope(ScopeConcreteIdArgConditionCopyNonLazyBinder binder, InstanceLifetime lifetime)
        {
            if (lifetime == InstanceLifetime.Transient)
            {
                binder.AsTransient();
            }
            else
            {
                binder.AsCached();
            }
        }
    }

    [Preserve]
    public sealed class DiContainerProviderProxy : IServiceProvider
    {
        DiContainer container;

        [Preserve]
        public DiContainerProviderProxy(DiContainer container)
        {
            this.container = container;
        }

        public object GetService(Type serviceType)
        {
            return container.Resolve(serviceType);
        }
    }
}

namespace MessagePipe
{
    public static partial class DiContainerExtensions
    {
        public static IServiceProvider AsServiceProvider(this DiContainer container)
        {
            return new DiContainerProviderProxy(container);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/Runtime/TypeProxy.cs.meta
================================================
fileFormatVersion: 2
guid: ec86b2e104a27c94c945a5db8d6e3da0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/ReadMe.url
================================================
[InternetShortcut]
URL=https://github.com/svermeulen/Extenject



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/ReadMe.url.meta
================================================
fileFormatVersion: 2
guid: 937aea47cf7f0864cb39571ca85e205d
timeCreated: 1529238438
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/LICENSE.txt
================================================
The MIT License (MIT)

Copyright (c) 2010-2015 Modest Tree Media  http://www.modesttree.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://github.com/svermeulen/Extenject/blob/master/License.md



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/LICENSE.txt.meta
================================================
fileFormatVersion: 2
guid: 75406829aaca6154491302d85b26270a
timeCreated: 1427860624
licenseType: Free
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/package.json
================================================
  
{
	"name": "com.mathijsbakker.extenject",
	"displayName": "Extenject",
	"version": "9.2.0",
	"description": "Dependency Injection Framework for Unity3D",
	"unity": "2019.3" 
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/package.json.meta
================================================
fileFormatVersion: 2
guid: b5ee7f1788474bd44a48b0a201461151
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source.meta
================================================
fileFormatVersion: 2
guid: 9180a9720c42cb94f9b30a7c0c938d90
folderAsset: yes
timeCreated: 1452188407
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Version.txt
================================================
9.2.0



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Version.txt.meta
================================================
fileFormatVersion: 2
guid: 4917e73af158b1e4782b175c0568afcf
timeCreated: 1452175972
licenseType: Pro
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/zenject.asmdef
================================================
﻿{
	"name": "Zenject"
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/zenject.asmdef.meta
================================================
fileFormatVersion: 2
guid: 0d8beb7f090555447a6cf5ce9e54dbb4
timeCreated: 1531030458
licenseType: Free
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding.meta
================================================
fileFormatVersion: 2
guid: e92094ea8d3ee634f858163622b6abbb
folderAsset: yes
timeCreated: 1459463884
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor.meta
================================================
fileFormatVersion: 2
guid: 70a96473817a0384580ace78f202a622
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories.meta
================================================
fileFormatVersion: 2
guid: 2750a8b0a1173074e9387536c12de4f7
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection.meta
================================================
fileFormatVersion: 2
guid: e36c66e30e287cf48b9bb264d4924562
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install.meta
================================================
fileFormatVersion: 2
guid: 6a15b3ef3a9656b4f85216520ae9b180
folderAsset: yes
timeCreated: 1459463884
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal.meta
================================================
fileFormatVersion: 2
guid: dd4fbc001f8bada428bbe3af6b6b21e8
folderAsset: yes
timeCreated: 1452188408
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main.meta
================================================
fileFormatVersion: 2
guid: b5f870edd43b85f4dae7b77cc0d75b46
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers.meta
================================================
fileFormatVersion: 2
guid: bd5ba0ff0ad7f874f8938a3266c21d4f
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime.meta
================================================
fileFormatVersion: 2
guid: fb9242e26ea385743abb8476b18d1e9f
folderAsset: yes
timeCreated: 1459463884
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Usage.meta
================================================
fileFormatVersion: 2
guid: a5896143fdd47624ebc6ddd933f1ed1b
folderAsset: yes
timeCreated: 1427464099
licenseType: Free
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util.meta
================================================
fileFormatVersion: 2
guid: 3f550a9d7385fce4e9bc4a0e5fa52daf
folderAsset: yes
DefaultImporter:
  userData: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Validation.meta
================================================
fileFormatVersion: 2
guid: 577ec212adf31e04bbd46b24f633f1e3
folderAsset: yes
timeCreated: 1459463884
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Zenject.csproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{46F25A62-2E29-48CB-95F3-BDBCB0976DDC}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Zenject</RootNamespace>
    <AssemblyName>Zenject</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <IntermediateOutputPath>..\..\..\..\..\..\NonUnityBuild\Temp\Debug\</IntermediateOutputPath>
    <BaseIntermediateOutputPath>..\..\..\..\..\..\NonUnityBuild\Temp\Debug\</BaseIntermediateOutputPath>
    <OutputPath>..\..\..\..\..\NonUnityBuild\Bin\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NOT_UNITY3D;ZEN_MULTITHREADING</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <IntermediateOutputPath>..\..\..\..\..\..\NonUnityBuild\Temp\Release\</IntermediateOutputPath>
    <BaseIntermediateOutputPath>..\..\..\..\..\..\NonUnityBuild\Temp\Release\</BaseIntermediateOutputPath>
    <OutputPath>..\..\..\..\..\NonUnityBuild\Bin\Release\</OutputPath>
    <DefineConstants>TRACE;NOT_UNITY3D;ZEN_MULTITHREADING;ZEN_INTERNAL_NO_POOLS</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Binding\Binders\ArgConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\ConcreteIdArgConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\ConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\CopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder0.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder1.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder10.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder2.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder3.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder4.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder5.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryArgumentsToChoiceBinder\FactoryArgumentsToChoiceBinder6.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder10.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder6.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder10.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder6.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\Untyped\FactoryFromBinderUntyped.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\DecoratorToChoiceFromBinder.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder10.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder6.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder0.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder1.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder10.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder2.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder3.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder4.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder5.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceIdBinder\FactoryToChoiceIdBinder6.cs" />
    <Compile Include="Binding\Binders\Factory\PlaceholderFactoryBindingFinalizer.cs" />
    <Compile Include="Binding\Binders\Factory\Pooling\MemoryPoolBindingFinalizer.cs" />
    <Compile Include="Binding\Binders\Factory\Pooling\MemoryPoolExpandBinder.cs" />
    <Compile Include="Binding\Binders\Factory\Pooling\MemoryPoolInitialSizeBinder.cs" />
    <Compile Include="Binding\Binders\IdBinder.cs" />
    <Compile Include="Binding\Binders\IdScopeConcreteIdArgConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\IfNotBoundBinder.cs" />
    <Compile Include="Binding\Binders\InstantiateCallbackConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\ScopeConcreteIdArgConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\Binders\WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder.cs" />
    <Compile Include="Binding\BindInfo\BindStatement.cs" />
    <Compile Include="Binding\BindInfo\FactoryBindInfo.cs" />
    <Compile Include="Binding\BindInfo\GameObjectCreationParameters.cs" />
    <Compile Include="Binding\BindInfo\MemoryPoolBindInfo.cs" />
    <Compile Include="Binding\Finalizers\NullBindingFinalizer.cs" />
    <Compile Include="Binding\Finalizers\SubContainerBindingFinalizer.cs" />
    <Compile Include="Factories\FactoryProviderWrapper.cs" />
    <Compile Include="Factories\PlaceholderFactory.cs" />
    <Compile Include="Factories\PlaceholderFactoryBase.cs" />
    <Compile Include="Factories\Pooling\IMemoryPool.cs" />
    <Compile Include="Factories\Pooling\MemoryPool.cs" />
    <Compile Include="Factories\Pooling\MemoryPoolBase.cs" />
    <Compile Include="Factories\Pooling\PoolableMemoryPool.cs" />
    <Compile Include="Factories\Pooling\PoolFactory.cs" />
    <Compile Include="Factories\Pooling\Static\PoolableStaticMemoryPool.cs" />
    <Compile Include="Factories\Pooling\Static\StaticMemoryPool.cs" />
    <Compile Include="Factories\Pooling\Util\ArrayPool.cs" />
    <Compile Include="Factories\Pooling\Util\DictionaryPool.cs" />
    <Compile Include="Factories\Pooling\Util\HashSetPool.cs" />
    <Compile Include="Factories\Pooling\Util\ListPool.cs" />
    <Compile Include="Factories\Pooling\Util\PoolCleanupChecker.cs" />
    <Compile Include="Factories\Pooling\Util\StaticMemoryPoolRegistry.cs" />
    <Compile Include="Injection\LazyInject.cs" />
    <Compile Include="Install\Contexts\StaticContext.cs" />
    <Compile Include="Install\InstallerBase.cs" />
    <Compile Include="Install\MonoInstallerBase.cs" />
    <Compile Include="Install\ScriptableObjectInstallerBase.cs" />
    <Compile Include="Install\ZenjectManagersInstaller.cs" />
    <Compile Include="Internal\Assert.cs" />
    <Compile Include="Internal\Func.cs" />
    <Compile Include="Internal\LinqExtensions.cs" />
    <Compile Include="Internal\Log.cs" />
    <Compile Include="Internal\MiscExtensions.cs" />
    <Compile Include="Internal\PreserveAttribute.cs" />
    <Compile Include="Internal\TypeExtensions.cs" />
    <Compile Include="Binding\Binders\ConcreteBinders\ConcreteIdBinderGeneric.cs" />
    <Compile Include="Binding\Binders\ConcreteBinders\ConcreteIdBinderNonGeneric.cs" />
    <Compile Include="Binding\Binders\Conventions\ConventionAssemblySelectionBinder.cs" />
    <Compile Include="Binding\Binders\Conventions\ConventionBindInfo.cs" />
    <Compile Include="Binding\Binders\Conventions\ConventionFilterTypesBinder.cs" />
    <Compile Include="Binding\Binders\Conventions\ConventionSelectTypesBinder.cs" />
    <Compile Include="Binding\BindingUtil.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder0.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder1.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder2.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder3.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder4.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\FactoryFromBinder5.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder2.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder3.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder4.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder5.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder0.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder1.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder2.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder3.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder4.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryToChoiceBinder\FactoryToChoiceBinder5.cs" />
    <Compile Include="Binding\Binders\ConcreteBinders\ConcreteBinderGeneric.cs" />
    <Compile Include="Binding\Binders\ConcreteBinders\ConcreteBinderNonGeneric.cs" />
    <Compile Include="Binding\Binders\FromBinders\FromBinder.cs" />
    <Compile Include="Injection\InjectUtil.cs" />
    <Compile Include="Internal\TypeStringFormatter.cs" />
    <Compile Include="Internal\ValuePair.cs" />
    <Compile Include="Main\LazyInstanceInjector.cs" />
    <Compile Include="Main\LookupId.cs" />
    <Compile Include="Main\SingletonMarkRegistry.cs" />
    <Compile Include="Main\ZenjectSettings.cs" />
    <Compile Include="Providers\CachedOpenTypeProvider.cs" />
    <Compile Include="Providers\Decorator\DecoratorProvider.cs" />
    <Compile Include="Providers\IFactoryProvider.cs" />
    <Compile Include="Providers\MethodMultipleProviderUntyped.cs" />
    <Compile Include="Providers\MethodProviderMultiple.cs" />
    <Compile Include="Providers\MethodProviderUntyped.cs" />
    <Compile Include="Providers\PoolableMemoryPoolProvider.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorBindInfo.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorByInstance.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorByInstanceGetter.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorUtil.cs" />
    <Compile Include="Runtime\GuiRenderableManager.cs" />
    <Compile Include="Runtime\Kernels\Kernel.cs" />
    <Compile Include="Runtime\PoolableManager.cs" />
    <Compile Include="Util\ActionInstaller.cs" />
    <Compile Include="Util\DisposeBlock.cs" />
    <Compile Include="Util\ProfileBlock.cs" />
    <Compile Include="Util\ReflectionInfoTypeInfoConverter.cs" />
    <Compile Include="Util\ReflectionTypeInfo.cs" />
    <Compile Include="Util\ReflectionUtil.cs" />
    <Compile Include="Util\ZenPools.cs" />
    <Compile Include="Util\ZenReflectionTypeAnalyzer.cs" />
    <Compile Include="Validation\IValidatable.cs" />
    <Compile Include="Factories\KeyedFactory.cs" />
    <Compile Include="Util\TypeAnalyzer.cs" />
    <Compile Include="Main\IInstantiator.cs" />
    <Compile Include="Main\BindingId.cs" />
    <Compile Include="Install\IInstaller.cs" />
    <Compile Include="Install\Installer.cs" />
    <Compile Include="Install\MonoInstaller.cs" />
    <Compile Include="Runtime\DisposableManager.cs" />
    <Compile Include="Runtime\InitializableManager.cs" />
    <Compile Include="Injection\InjectContext.cs" />
    <Compile Include="Runtime\TaskUpdater.cs" />
    <Compile Include="Runtime\TickableManager.cs" />
    <Compile Include="Providers\GetterProvider.cs" />
    <Compile Include="Providers\InstanceProvider.cs" />
    <Compile Include="Providers\MethodProvider.cs" />
    <Compile Include="Util\UnityUtil.cs" />
    <Compile Include="Main\DiContainer.cs" />
    <Compile Include="Factories\PrefabFactory.cs" />
    <Compile Include="Util\ExecutionOrderInstaller.cs" />
    <Compile Include="Util\ZenUtilInternal.cs" />
    <Compile Include="Install\ZenjectBinding.cs" />
    <Compile Include="Providers\ProviderUtil.cs" />
    <Compile Include="Providers\IProvider.cs" />
    <Compile Include="Providers\ResolveProvider.cs" />
    <Compile Include="Providers\ResourceProvider.cs" />
    <Compile Include="Providers\TransientProvider.cs" />
    <Compile Include="Util\ZenjectException.cs" />
    <Compile Include="Providers\MethodProviderSimple.cs" />
    <Compile Include="Providers\MethodProviderWithContainer.cs" />
    <Compile Include="Providers\SubContainerDependencyProvider.cs" />
    <Compile Include="Providers\IProviderExtensions.cs" />
    <Compile Include="Providers\SubContainerCreators\ISubContainerCreator.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorByMethod.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorByInstaller.cs" />
    <Compile Include="Providers\SubContainerCreators\SubContainerCreatorCached.cs" />
    <Compile Include="Providers\CachedProvider.cs" />
    <Compile Include="Factories\IFactory.cs" />
    <Compile Include="Binding\BindInfo\BindInfo.cs" />
    <Compile Include="Binding\Binders\FromBinders\FromBinderGeneric.cs" />
    <Compile Include="Binding\Binders\FromBinders\FromBinderNonGeneric.cs" />
    <Compile Include="Binding\Finalizers\ScopableBindingFinalizer.cs" />
    <Compile Include="Binding\Finalizers\ProviderBindingFinalizer.cs" />
    <Compile Include="Binding\Finalizers\IBindingFinalizer.cs" />
    <Compile Include="Binding\Finalizers\SingleProviderBindingFinalizer.cs" />
    <Compile Include="Binding\Binders\SubContainerBinder.cs" />
    <Compile Include="Binding\Finalizers\PrefabBindingFinalizer.cs" />
    <Compile Include="Binding\Finalizers\PrefabResourceBindingFinalizer.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinderBase.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder0.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinderBase.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinderWithParams.cs" />
    <Compile Include="Binding\Binders\Factory\FactoryFromBinder\SubContainerBinder\FactorySubContainerBinder1.cs" />
    <Compile Include="Install\ScriptableObjectInstaller.cs" />
    <Compile Include="Util\ZenjectSceneLoader.cs" />
    <Compile Include="Util\ValidationUtil.cs" />
    <Compile Include="Validation\ValidationMarker.cs" />
    <Compile Include="Binding\Binders\NonLazyBinder.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\..\AssemblyBuild\Zenject-usage\Zenject-usage.csproj">
      <Project>{e22b1cbf-7e4d-48bd-953b-2b730bd9ff13}</Project>
      <Name>Zenject-usage</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Zenject.csproj.meta
================================================
fileFormatVersion: 2
guid: 8645273165cb7f54290d6eaa1e10ab37
timeCreated: 1461878212
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders.meta
================================================
fileFormatVersion: 2
guid: 3e0d343c02f9d0a488a62abffae00ceb
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo.meta
================================================
fileFormatVersion: 2
guid: a78a183f887b72e45b2ec6d77fb514d8
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindingUtil.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using ModestTree;
using Zenject.Internal;
using System.Linq;
using TypeExtensions = ModestTree.TypeExtensions;

#if !NOT_UNITY3D
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

#endif

namespace Zenject
{
    internal static class BindingUtil
    {
#if !NOT_UNITY3D

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsValidPrefab(UnityEngine.Object prefab)
        {
            Assert.That(!ZenUtilInternal.IsNull(prefab), "Received null prefab during bind command");

#if UNITY_EDITOR
            // Unfortunately we can't do this check because asset bundles return PrefabType.None here
            // as discussed here: https://github.com/svermeulen/Zenject/issues/269#issuecomment-323419408
            //Assert.That(PrefabUtility.GetPrefabType(prefab) == PrefabType.Prefab,
                //"Expected prefab but found game object with name '{0}' during bind command", prefab.name);
#endif
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsValidGameObject(GameObject gameObject)
        {
            Assert.That(!ZenUtilInternal.IsNull(gameObject), "Received null game object during bind command");

#if UNITY_EDITOR
            // Unfortunately we can't do this check because asset bundles return PrefabType.None here
            // as discussed here: https://github.com/svermeulen/Zenject/issues/269#issuecomment-323419408
            //Assert.That(PrefabUtility.GetPrefabType(gameObject) != PrefabType.Prefab,
                //"Expected game object but found prefab instead with name '{0}' during bind command", gameObject.name);
#endif
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotComponent(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsNotComponent(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotComponent<T>()
        {
            AssertIsNotComponent(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotComponent(Type type)
        {
            Assert.That(!type.DerivesFrom(typeof(Component)),
                "Invalid type given during bind command.  Expected type '{0}' to NOT derive from UnityEngine.Component", type);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertDerivesFromUnityObject(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertDerivesFromUnityObject(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertDerivesFromUnityObject<T>()
        {
            AssertDerivesFromUnityObject(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertDerivesFromUnityObject(Type type)
        {
            Assert.That(type.DerivesFrom<UnityEngine.Object>(),
                "Invalid type given during bind command.  Expected type '{0}' to derive from UnityEngine.Object", type);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertTypesAreNotComponents(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsNotComponent(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsValidResourcePath(string resourcePath)
        {
            Assert.That(!string.IsNullOrEmpty(resourcePath), "Null or empty resource path provided");

            // We'd like to validate the path here but unfortunately there doesn't appear to be
            // a way to do this besides loading it
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrScriptableObject(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsInterfaceOrScriptableObject(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrScriptableObject<T>()
        {
            AssertIsInterfaceOrScriptableObject(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrScriptableObject(Type type)
        {
            Assert.That(type.DerivesFrom(typeof(ScriptableObject)) || type.IsInterface(),
                "Invalid type given during bind command.  Expected type '{0}' to either derive from UnityEngine.ScriptableObject or be an interface", type);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrComponent(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsInterfaceOrComponent(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrComponent<T>()
        {
            AssertIsInterfaceOrComponent(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsInterfaceOrComponent(Type type)
        {
            Assert.That(type.DerivesFrom(typeof(Component)) || type.IsInterface(),
                "Invalid type given during bind command.  Expected type '{0}' to either derive from UnityEngine.Component or be an interface", type);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsComponent(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsComponent(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsComponent<T>()
        {
            AssertIsComponent(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsComponent(Type type)
        {
            Assert.That(type.DerivesFrom(typeof(Component)),
                "Invalid type given during bind command.  Expected type '{0}' to derive from UnityEngine.Component", type);
        }
#else
        public static void AssertTypesAreNotComponents(IEnumerable<Type> types)
        {
        }

        public static void AssertIsNotComponent(Type type)
        {
        }

        public static void AssertIsNotComponent<T>()
        {
        }

        public static void AssertIsNotComponent(IEnumerable<Type> types)
        {
        }
#endif

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertTypesAreNotAbstract(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsNotAbstract(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotAbstract(IEnumerable<Type> types)
        {
            foreach (var type in types)
            {
                AssertIsNotAbstract(type);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotAbstract<T>()
        {
            AssertIsNotAbstract(typeof(T));
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsNotAbstract(Type type)
        {
            Assert.That(!type.IsAbstract(),
                "Invalid type given during bind command.  Expected type '{0}' to not be abstract.", type);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsDerivedFromType(Type concreteType, Type parentType)
        {
#if !(UNITY_WSA && ENABLE_DOTNET)
            // TODO: Is it possible to do this on WSA?

            Assert.That(parentType.IsOpenGenericType() == concreteType.IsOpenGenericType(),
                "Invalid type given during bind command.  Expected type '{0}' and type '{1}' to both either be open generic types or not open generic types", parentType, concreteType);

            if (parentType.IsOpenGenericType())
            {
                Assert.That(concreteType.IsOpenGenericType());
                Assert.That(TypeExtensions.IsAssignableToGenericType(concreteType, parentType),
                    "Invalid type given during bind command.  Expected open generic type '{0}' to derive from open generic type '{1}'", concreteType, parentType);
            }
            else
#endif
            {
                Assert.That(concreteType.DerivesFromOrEqual(parentType),
                    "Invalid type given during bind command.  Expected type '{0}' to derive from type '{1}'", concreteType, parentType);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertConcreteTypeListIsNotEmpty(IEnumerable<Type> concreteTypes)
        {
            Assert.That(concreteTypes.Count() >= 1,
                "Must supply at least one concrete type to the current binding");
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsDerivedFromTypes(
            IEnumerable<Type> concreteTypes, IEnumerable<Type> parentTypes, InvalidBindResponses invalidBindResponse)
        {
            if (invalidBindResponse == InvalidBindResponses.Assert)
            {
                AssertIsDerivedFromTypes(concreteTypes, parentTypes);
            }
            else
            {
                Assert.IsEqual(invalidBindResponse, InvalidBindResponses.Skip);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsDerivedFromTypes(IEnumerable<Type> concreteTypes, IEnumerable<Type> parentTypes)
        {
            foreach (var concreteType in concreteTypes)
            {
                AssertIsDerivedFromTypes(concreteType, parentTypes);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertIsDerivedFromTypes(Type concreteType, IEnumerable<Type> parentTypes)
        {
            foreach (var parentType in parentTypes)
            {
                AssertIsDerivedFromType(concreteType, parentType);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertInstanceDerivesFromOrEqual(object instance, IEnumerable<Type> parentTypes)
        {
            if (!ZenUtilInternal.IsNull(instance))
            {
                foreach (var baseType in parentTypes)
                {
                    AssertInstanceDerivesFromOrEqual(instance, baseType);
                }
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void AssertInstanceDerivesFromOrEqual(object instance, Type baseType)
        {
            if (!ZenUtilInternal.IsNull(instance))
            {
                Assert.That(instance.GetType().DerivesFromOrEqual(baseType),
                    "Invalid type given during bind command.  Expected type '{0}' to derive from type '{1}'", instance.GetType(), baseType);
            }
        }

        public static IProvider CreateCachedProvider(IProvider creator)
        {
            if (creator.TypeVariesBasedOnMemberType)
            {
                return new CachedOpenTypeProvider(creator);
            }

            return new CachedProvider(creator);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindingUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 3d9014e328d4ff04682edfaaa5bdad36
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers.meta
================================================
fileFormatVersion: 2
guid: 95ed99f2cba5359419d007822a4c0c31
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ArgConditionCopyNonLazyBinder.cs
================================================
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ArgConditionCopyNonLazyBinder : InstantiateCallbackConditionCopyNonLazyBinder
    {
        public ArgConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<T>(T param)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<TParam1, TParam2>(TParam1 param1, TParam2 param2)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param1));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param2));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<TParam1, TParam2, TParam3>(
            TParam1 param1, TParam2 param2, TParam3 param3)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param1));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param2));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param3));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<TParam1, TParam2, TParam3, TParam4>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param1));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param2));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param3));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param4));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<TParam1, TParam2, TParam3, TParam4, TParam5>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param1));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param2));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param3));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param4));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param5));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6)
        {
            BindInfo.Arguments.Clear();
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param1));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param2));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param3));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param4));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param5));
            BindInfo.Arguments.Add(InjectUtil.CreateTypePair(param6));
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArguments(object[] args)
        {
            BindInfo.Arguments.Clear();

            for (int i = 0; i < args.Length; i++)
            {
                var arg = args[i];

                Assert.IsNotNull(arg,
                    "Cannot include null values when creating a zenject argument list because zenject has no way of deducing the type from a null value.  If you want to allow null, use the Explicit form.");

                BindInfo.Arguments.Add(
                    new TypeValuePair(arg.GetType(), arg));
            }
            return this;
        }

        public InstantiateCallbackConditionCopyNonLazyBinder WithArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            BindInfo.Arguments.Clear();

            foreach (var arg in extraArgs)
            {
                BindInfo.Arguments.Add(arg);
            }
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: d0eff25a90fc7a4479dbb9a1f74dddc2
timeCreated: 1483833202
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders.meta
================================================
fileFormatVersion: 2
guid: b3b29de51c8625443984cbd926505d00
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class ConcreteIdArgConditionCopyNonLazyBinder : ArgConditionCopyNonLazyBinder
    {
        public ConcreteIdArgConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public ArgConditionCopyNonLazyBinder WithConcreteId(object id)
        {
            BindInfo.ConcreteIdentifier = id;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 5803a20c252d8ae4498e79e8b3bb09e0
timeCreated: 1523257672
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConditionCopyNonLazyBinder.cs
================================================
using System;
using System.Linq;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConditionCopyNonLazyBinder : CopyNonLazyBinder
    {
        public ConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public CopyNonLazyBinder When(BindingCondition condition)
        {
            BindInfo.Condition = condition;
            return this;
        }

        public CopyNonLazyBinder WhenInjectedIntoInstance(object instance)
        {
            return When(r => ReferenceEquals(r.ObjectInstance, instance));
        }

        public CopyNonLazyBinder WhenInjectedInto(params Type[] targets)
        {
            return When(r => targets.Where(x => r.ObjectType != null && r.ObjectType.DerivesFromOrEqual(x)).Any());
        }

        public CopyNonLazyBinder WhenInjectedInto<T>()
        {
            return When(r => r.ObjectType != null && r.ObjectType.DerivesFromOrEqual(typeof(T)));
        }

        public CopyNonLazyBinder WhenNotInjectedInto<T>()
        {
            return When(r => r.ObjectType == null || !r.ObjectType.DerivesFromOrEqual(typeof(T)));
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: a638543bf618ed94fb418f48d9ea9329
timeCreated: 1483833202
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions.meta
================================================
fileFormatVersion: 2
guid: cecd58a5468ced54aabe6cc4d2eed9a8
folderAsset: yes
timeCreated: 1462127452
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/CopyNonLazyBinder.cs
================================================
using System.Collections.Generic;

namespace Zenject
{
    [NoReflectionBaking]
    public class CopyNonLazyBinder : NonLazyBinder
    {
        List<BindInfo> _secondaryBindInfos;

        public CopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        // This is used in cases where you have multiple bindings that depend on each other so should
        // be inherited together (eg. FromIFactory)
        internal void AddSecondaryCopyBindInfo(BindInfo bindInfo)
        {
            if (_secondaryBindInfos == null)
            {
                _secondaryBindInfos = new List<BindInfo>();
            }
            _secondaryBindInfos.Add(bindInfo);
        }

        public NonLazyBinder CopyIntoAllSubContainers()
        {
            SetInheritanceMethod(BindingInheritanceMethods.CopyIntoAll);
            return this;
        }

        // Only copy the binding into children and not grandchildren
        public NonLazyBinder CopyIntoDirectSubContainers()
        {
            SetInheritanceMethod(BindingInheritanceMethods.CopyDirectOnly);
            return this;
        }

        // Do not apply the binding on the current container
        public NonLazyBinder MoveIntoAllSubContainers()
        {
            SetInheritanceMethod(BindingInheritanceMethods.MoveIntoAll);
            return this;
        }

        // Do not apply the binding on the current container
        public NonLazyBinder MoveIntoDirectSubContainers()
        {
            SetInheritanceMethod(BindingInheritanceMethods.MoveDirectOnly);
            return this;
        }

        void SetInheritanceMethod(BindingInheritanceMethods method)
        {
            BindInfo.BindingInheritanceMethod = method;

            if (_secondaryBindInfos != null)
            {
                foreach (var secondaryBindInfo in _secondaryBindInfos)
                {
                    secondaryBindInfo.BindingInheritanceMethod = method;
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/CopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 6cf2e5d7a11cf6c418960ff59949b5fa
timeCreated: 1483833202
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder(
            SubContainerCreatorBindInfo subContainerBindInfo, BindInfo bindInfo)
            : base(bindInfo)
        {
            SubContainerCreatorBindInfo = subContainerBindInfo;
        }

        protected SubContainerCreatorBindInfo SubContainerCreatorBindInfo
        {
            get; private set;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder WithDefaultGameObjectParent(string defaultParentName)
        {
            SubContainerCreatorBindInfo.DefaultParentName = defaultParentName;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: f6b4e164706b85c408cd7e8f28266747
timeCreated: 1535254660
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory.meta
================================================
fileFormatVersion: 2
guid: 580f48a64cf849041937c7ad570aaf89
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders.meta
================================================
fileFormatVersion: 2
guid: b62c8a25fc0c5d34680c100f745a80e1
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/GameObject.meta
================================================
fileFormatVersion: 2
guid: 6a5ff7e3b16416245acfcd6be217a53f
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IdBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class IdBinder
    {
        BindInfo _bindInfo;

        public IdBinder(BindInfo bindInfo)
        {
            _bindInfo = bindInfo;
        }

        public void WithId(object identifier)
        {
            _bindInfo.Identifier = identifier;
        }
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IdBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 371e1c0b9a8ff664f993cbe2a547eeae
timeCreated: 1484790451
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IdScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class IdScopeConcreteIdArgConditionCopyNonLazyBinder : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public IdScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IdScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: ba3894c2363faea4480796349be1c939
timeCreated: 1535254660
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IfNotBoundBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class IfNotBoundBinder
    {
        public IfNotBoundBinder(BindInfo bindInfo)
        {
            BindInfo = bindInfo;
        }

        // Do not use this
        public BindInfo BindInfo
        {
            get;
            private set;
        }

        public void IfNotBound()
        {
            BindInfo.OnlyBindIfNotBound = true;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/IfNotBoundBinder.cs.meta
================================================
fileFormatVersion: 2
guid: b9f24b7d14dcf8441a1c2b4166a5ec9c
timeCreated: 1519465920
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/InstantiateCallbackConditionCopyNonLazyBinder.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class InstantiateCallbackConditionCopyNonLazyBinder : ConditionCopyNonLazyBinder
    {
        public InstantiateCallbackConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public ConditionCopyNonLazyBinder OnInstantiated(
            Action<InjectContext, object> callback)
        {
            BindInfo.InstantiatedCallback = callback;
            return this;
        }

        public ConditionCopyNonLazyBinder OnInstantiated<T>(
            Action<InjectContext, T> callback)
        {
            // Can't do this here because of factory bindings
            //Assert.That(BindInfo.ContractTypes.All(x => x.DerivesFromOrEqual<T>()));

            BindInfo.InstantiatedCallback = (ctx, obj) =>
            {
                Assert.That(obj == null || obj is T,
                    "Invalid generic argument to OnInstantiated! {0} must be type {1}", obj.GetType(), typeof(T));

                callback(ctx, (T)obj);
            };
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/InstantiateCallbackConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 0711425cf187dd94ea21d8ed6f38d981
timeCreated: 1535263051
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/NonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class NonLazyBinder : IfNotBoundBinder
    {
        public NonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public IfNotBoundBinder NonLazy()
        {
            BindInfo.NonLazy = true;
            return this;
        }

        public IfNotBoundBinder Lazy()
        {
            BindInfo.NonLazy = false;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/NonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 58c27840cbeb2fa4695b09d536809bb2
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class ScopeConcreteIdArgConditionCopyNonLazyBinder : ConcreteIdArgConditionCopyNonLazyBinder
    {
        public ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public ConcreteIdArgConditionCopyNonLazyBinder AsCached()
        {
            BindInfo.Scope = ScopeTypes.Singleton;
            return this;
        }

        public ConcreteIdArgConditionCopyNonLazyBinder AsSingle()
        {
            BindInfo.Scope = ScopeTypes.Singleton;
            BindInfo.MarkAsUniqueSingleton = true;
            return this;
        }

        // Note that this is the default so it's not necessary to call this
        public ConcreteIdArgConditionCopyNonLazyBinder AsTransient()
        {
            BindInfo.Scope = ScopeTypes.Transient;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 5a71e3efc6d683d4cbc3b881bc4e2772
timeCreated: 1523257672
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/SubContainerBinder.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerBinder
    {
        readonly BindInfo _bindInfo;
        readonly BindStatement _bindStatement;
        readonly object _subIdentifier;
        readonly bool _resolveAll;

        public SubContainerBinder(
            BindInfo bindInfo,
            BindStatement bindStatement,
            object subIdentifier, bool resolveAll)
        {
            _bindInfo = bindInfo;
            _bindStatement = bindStatement;
            _subIdentifier = subIdentifier;
            _resolveAll = resolveAll;

            // Reset in case the user ends the binding here
            bindStatement.SetFinalizer(null);
        }

        protected IBindingFinalizer SubFinalizer
        {
            set { _bindStatement.SetFinalizer(value); }
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByInstance(DiContainer subContainer)
        {
            SubFinalizer = new SubContainerBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (_) => new SubContainerCreatorByInstance(subContainer));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByInstanceGetter(
            Func<InjectContext, DiContainer> subContainerGetter)
        {
            SubFinalizer = new SubContainerBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (_) => new SubContainerCreatorByInstanceGetter(subContainerGetter));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo);
        }

        public
#if NOT_UNITY3D
            WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder
#else
            WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
#endif
            ByInstaller<TInstaller>()
            where TInstaller : InstallerBase
        {
            return ByInstaller(typeof(TInstaller));
        }

        public
#if NOT_UNITY3D
            WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder
#else
            WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
#endif
            ByInstaller(Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var subContainerBindInfo = new SubContainerCreatorBindInfo();

            SubFinalizer = new SubContainerBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByInstaller(container, subContainerBindInfo, installerType));

            return new
#if NOT_UNITY3D
                WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder
#else
                WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
#endif
                (subContainerBindInfo, _bindInfo);
        }

        public
#if NOT_UNITY3D
            WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder
#else
            WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
#endif
            ByMethod(Action<DiContainer> installerMethod)
        {
            var subContainerBindInfo = new SubContainerCreatorBindInfo();

            SubFinalizer = new SubContainerBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByMethod(container, subContainerBindInfo, installerMethod));

            return new
#if NOT_UNITY3D
                WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder
#else
                WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
#endif
                (subContainerBindInfo, _bindInfo);
        }

#if !NOT_UNITY3D

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
            Action<DiContainer> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewGameObjectMethod(
                    container, gameObjectInfo, installerMethod));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Action<DiContainer> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabMethod(
                    container,
                    new PrefabProviderCustom(prefabGetter),
                    gameObjectInfo, installerMethod));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab, Action<DiContainer> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabMethod(
                    container,
                    new PrefabProvider(prefab),
                    gameObjectInfo, installerMethod));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectInstaller<TInstaller>()
            where TInstaller : InstallerBase
        {
            return ByNewGameObjectInstaller(typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectInstaller(Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewGameObjectInstaller(
                    container, gameObjectInfo, installerType, _bindInfo.Arguments));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller<TInstaller>(
            Func<InjectContext, UnityEngine.Object> prefabGetter)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabInstaller(prefabGetter, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabInstaller(
                    container,
                    new PrefabProviderCustom(prefabGetter),
                    gameObjectInfo, installerType, _bindInfo.Arguments));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller<TInstaller>(
            UnityEngine.Object prefab)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabInstaller(prefab, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller(
            UnityEngine.Object prefab, Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabInstaller(
                    container,
                    new PrefabProvider(prefab),
                    gameObjectInfo, installerType, _bindInfo.Arguments));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }


        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath, Action<DiContainer> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabMethod(
                    container,
                    new PrefabProviderResource(resourcePath),
                    gameObjectInfo, installerMethod));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceInstaller<TInstaller>(
            string resourcePath)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabResourceInstaller(resourcePath, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceInstaller(
            string resourcePath, Type installerType)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefabInstaller(
                    container,
                    new PrefabProviderResource(resourcePath),
                    gameObjectInfo, installerType, _bindInfo.Arguments));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        [System.Obsolete("ByNewPrefab has been renamed to ByNewContextPrefab to avoid confusion with ByNewPrefabInstaller and ByNewPrefabMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefab(UnityEngine.Object prefab)
        {
            return ByNewContextPrefab(prefab);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefab(UnityEngine.Object prefab)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefab(
                    container, new PrefabProvider(prefab), gameObjectInfo));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }

        [System.Obsolete("ByNewPrefabResource has been renamed to ByNewContextPrefabResource to avoid confusion with ByNewPrefabResourceInstaller and ByNewPrefabResourceMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResource(string resourcePath)
        {
            return ByNewContextPrefabResource(resourcePath);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefabResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            SubFinalizer = new SubContainerPrefabBindingFinalizer(
                _bindInfo, _subIdentifier, _resolveAll,
                (container) => new SubContainerCreatorByNewPrefab(
                    container, new PrefabProviderResource(resourcePath), gameObjectInfo));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(_bindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/SubContainerBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 4d1fcd1593b05194a82073206057613e
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder : DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder(
            SubContainerCreatorBindInfo subContainerBindInfo, BindInfo bindInfo)
            : base(subContainerBindInfo, bindInfo)
        {
        }

        public DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder WithKernel()
        {
            SubContainerCreatorBindInfo.CreateKernel = true;
            return this;
        }

        // This would be used in cases where you want to control the execution order for the
        // subcontainer
        public DefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder WithKernel<TKernel>()
            where TKernel : Kernel
        {
            SubContainerCreatorBindInfo.CreateKernel = true;
            SubContainerCreatorBindInfo.KernelType = typeof(TKernel);
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/WithKernelDefaultParentScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 4690c1b02bdf3d34998b8a505c85b1b2
timeCreated: 1535254659
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        SubContainerCreatorBindInfo _subContainerBindInfo;

        public WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder(
            SubContainerCreatorBindInfo subContainerBindInfo, BindInfo bindInfo)
            : base(bindInfo)
        {
            _subContainerBindInfo = subContainerBindInfo;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder WithKernel()
        {
            _subContainerBindInfo.CreateKernel = true;
            return this;
        }

        // This would be used in cases where you want to control the execution order for the
        // subcontainer
        public ScopeConcreteIdArgConditionCopyNonLazyBinder WithKernel<TKernel>()
            where TKernel : Kernel
        {
            _subContainerBindInfo.CreateKernel = true;
            _subContainerBindInfo.KernelType = typeof(TKernel);
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/WithKernelScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 6447473513963f742b7ab3c02ec633a8
timeCreated: 1535254659
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteBinderGeneric.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConcreteBinderGeneric<TContract> : FromBinderGeneric<TContract>
    {
        public ConcreteBinderGeneric(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
            ToSelf();
        }

        // Note that this is the default, so not necessary to call
        public FromBinderGeneric<TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo, (container, type) => new TransientProvider(
                    type, container, BindInfo.Arguments,
                    BindInfo.ContextInfo, BindInfo.ConcreteIdentifier,
                    BindInfo.InstantiatedCallback));

            return this;
        }

        public FromBinderGeneric<TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FromBinderGeneric<TConcrete>(
                BindContainer, BindInfo, BindStatement);
        }

        public FromBinderNonGeneric To(params Type[] concreteTypes)
        {
            return To((IEnumerable<Type>)concreteTypes);
        }

        public FromBinderNonGeneric To(IEnumerable<Type> concreteTypes)
        {
            BindingUtil.AssertIsDerivedFromTypes(
                concreteTypes, BindInfo.ContractTypes, BindInfo.InvalidBindResponse);

            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.AddRange(concreteTypes);

            return new FromBinderNonGeneric(
                BindContainer, BindInfo, BindStatement);
        }

#if !(UNITY_WSA && ENABLE_DOTNET)
        public FromBinderNonGeneric To(
            Action<ConventionSelectTypesBinder> generator)
        {
            var bindInfo = new ConventionBindInfo();

            // Automatically filter by the given contract types
            bindInfo.AddTypeFilter(
                concreteType => BindInfo.ContractTypes.All(contractType => concreteType.DerivesFromOrEqual(contractType)));

            generator(new ConventionSelectTypesBinder(bindInfo));
            return To(bindInfo.ResolveTypes());
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteBinderGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: 62ec581e8d820a74797d1dabf19d85c3
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteBinderNonGeneric.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConcreteBinderNonGeneric : FromBinderNonGeneric
    {
        public ConcreteBinderNonGeneric(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
            ToSelf();
        }

        // Note that this is the default, so not necessary to call
        public FromBinderNonGeneric ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo, (container, type) => new TransientProvider(
                    type, container, BindInfo.Arguments, BindInfo.ContextInfo, BindInfo.ConcreteIdentifier,
                    BindInfo.InstantiatedCallback));

            return this;
        }

        public FromBinderNonGeneric To<TConcrete>()
        {
            return To(typeof(TConcrete));
        }

        public FromBinderNonGeneric To(params Type[] concreteTypes)
        {
            return To((IEnumerable<Type>)concreteTypes);
        }

        public FromBinderNonGeneric To(IEnumerable<Type> concreteTypes)
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.AddRange(concreteTypes);

            if (BindInfo.ToTypes.Count > 1 && BindInfo.ContractTypes.Count > 1)
            {
                // Be more lenient in this case to behave similar to convention based bindings
                BindInfo.InvalidBindResponse = InvalidBindResponses.Skip;
            }
            else
            {
                BindingUtil.AssertIsDerivedFromTypes(concreteTypes, BindInfo.ContractTypes, BindInfo.InvalidBindResponse);
            }

            return this;
        }

#if !(UNITY_WSA && ENABLE_DOTNET)
        public FromBinderNonGeneric To(
            Action<ConventionSelectTypesBinder> generator)
        {
            var bindInfo = new ConventionBindInfo();

            // This is nice because it allows us to do things like Bind(all interfaces).To(specific types)
            // instead of having to do Bind(all interfaces).To(specific types that inherit from one of these interfaces)
            BindInfo.InvalidBindResponse = InvalidBindResponses.Skip;

            generator(new ConventionSelectTypesBinder(bindInfo));

            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.AddRange(bindInfo.ResolveTypes());

            return this;
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteBinderNonGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: b04935d23b1499e42a242d63a3fe248b
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteIdBinderGeneric.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class ConcreteIdBinderGeneric<TContract> : ConcreteBinderGeneric<TContract>
    {
        public ConcreteIdBinderGeneric(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
        }

        public ConcreteBinderGeneric<TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteIdBinderGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: 358cdf402ef00ff40ac81f3bbe7018f0
timeCreated: 1463318690
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteIdBinderNonGeneric.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class ConcreteIdBinderNonGeneric : ConcreteBinderNonGeneric
    {
        public ConcreteIdBinderNonGeneric(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
        }

        public ConcreteBinderNonGeneric WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/ConcreteBinders/ConcreteIdBinderNonGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: 1251d518904c9574897614d756f76756
timeCreated: 1463318690
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionAssemblySelectionBinder.cs
================================================
#if !(UNITY_WSA && ENABLE_DOTNET)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConventionAssemblySelectionBinder
    {
        public ConventionAssemblySelectionBinder(ConventionBindInfo bindInfo)
        {
            BindInfo = bindInfo;
        }

        protected ConventionBindInfo BindInfo
        {
            get;
            private set;
        }

        public void FromAllAssemblies()
        {
            // Do nothing
            // This is the default
        }

        public void FromAssemblyContaining<T>()
        {
            FromAssembliesContaining(typeof(T));
        }

        public void FromAssembliesContaining(params Type[] types)
        {
            FromAssembliesContaining((IEnumerable<Type>)types);
        }

        public void FromAssembliesContaining(IEnumerable<Type> types)
        {
            FromAssemblies(types.Select(t => t.Assembly).Distinct());
        }

        public void FromThisAssembly()
        {
            FromAssemblies(Assembly.GetCallingAssembly());
        }

        public void FromAssembly(Assembly assembly)
        {
            FromAssemblies(assembly);
        }

        public void FromAssemblies(params Assembly[] assemblies)
        {
            FromAssemblies((IEnumerable<Assembly>)assemblies);
        }

        public void FromAssemblies(IEnumerable<Assembly> assemblies)
        {
            BindInfo.AddAssemblyFilter(assembly => assemblies.Contains(assembly));
        }

        public void FromAssembliesWhere(Func<Assembly, bool> predicate)
        {
            BindInfo.AddAssemblyFilter(predicate);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionAssemblySelectionBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 5229c122d45b5634ebd4b9bccee749ac
timeCreated: 1462127487
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionBindInfo.cs
================================================
#if !(UNITY_WSA && ENABLE_DOTNET)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConventionBindInfo
    {
        readonly List<Func<Type, bool>> _typeFilters = new List<Func<Type, bool>>();
        readonly List<Func<Assembly, bool>> _assemblyFilters = new List<Func<Assembly, bool>>();

#if ZEN_MULTITHREADING
        readonly object _locker = new object();
#endif
        static Dictionary<Assembly, Type[]> _assemblyTypeCache = new Dictionary<Assembly, Type[]>();

        public void AddAssemblyFilter(Func<Assembly, bool> predicate)
        {
            _assemblyFilters.Add(predicate);
        }

        public void AddTypeFilter(Func<Type, bool> predicate)
        {
            _typeFilters.Add(predicate);
        }

        IEnumerable<Assembly> GetAllAssemblies()
        {
            // This seems fast enough that it's not worth caching
            // We also want to allow dynamically loading assemblies
            return AppDomain.CurrentDomain.GetAssemblies();
        }

        bool ShouldIncludeAssembly(Assembly assembly)
        {
            return _assemblyFilters.All(predicate => predicate(assembly));
        }

        bool ShouldIncludeType(Type type)
        {
            return _typeFilters.All(predicate => predicate(type));
        }

        Type[] GetTypes(Assembly assembly)
        {
            Type[] types;

#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                // This is much faster than calling assembly.GetTypes() every time
                if (!_assemblyTypeCache.TryGetValue(assembly, out types))
                {
                    types = assembly.GetTypes();
                    _assemblyTypeCache[assembly] = types;
                }
            }

            return types;
        }

        public List<Type> ResolveTypes()
        {
            return GetAllAssemblies()
                .Where(ShouldIncludeAssembly)
                .SelectMany(assembly => GetTypes(assembly))
                .Where(ShouldIncludeType).ToList();
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionBindInfo.cs.meta
================================================
fileFormatVersion: 2
guid: f1e908965ce63ab40b271724cb5490aa
timeCreated: 1462127523
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionFilterTypesBinder.cs
================================================
#if !(UNITY_WSA && ENABLE_DOTNET)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ConventionFilterTypesBinder : ConventionAssemblySelectionBinder
    {
        public ConventionFilterTypesBinder(ConventionBindInfo bindInfo)
            : base(bindInfo)
        {
        }

        public ConventionFilterTypesBinder DerivingFromOrEqual<T>()
        {
            return DerivingFromOrEqual(typeof(T));
        }

        public ConventionFilterTypesBinder DerivingFromOrEqual(Type parentType)
        {
            BindInfo.AddTypeFilter(type => type.DerivesFromOrEqual(parentType));
            return this;
        }

        public ConventionFilterTypesBinder DerivingFrom<T>()
        {
            return DerivingFrom(typeof(T));
        }

        public ConventionFilterTypesBinder DerivingFrom(Type parentType)
        {
            BindInfo.AddTypeFilter(type => type.DerivesFrom(parentType));
            return this;
        }

        public ConventionFilterTypesBinder WithAttribute<T>()
            where T : Attribute
        {
            return WithAttribute(typeof(T));
        }

        public ConventionFilterTypesBinder WithAttribute(Type attribute)
        {
            Assert.That(attribute.DerivesFrom<Attribute>());
            BindInfo.AddTypeFilter(t => t.HasAttribute(attribute));
            return this;
        }

        public ConventionFilterTypesBinder WithoutAttribute<T>()
            where T : Attribute
        {
            return WithoutAttribute(typeof(T));
        }

        public ConventionFilterTypesBinder WithoutAttribute(Type attribute)
        {
            Assert.That(attribute.DerivesFrom<Attribute>());
            BindInfo.AddTypeFilter(t => !t.HasAttribute(attribute));
            return this;
        }

        public ConventionFilterTypesBinder WithAttributeWhere<T>(Func<T, bool> predicate)
            where T : Attribute
        {
            BindInfo.AddTypeFilter(t => t.HasAttribute<T>() && t.AllAttributes<T>().All(predicate));
            return this;
        }

        public ConventionFilterTypesBinder Where(Func<Type, bool> predicate)
        {
            BindInfo.AddTypeFilter(predicate);
            return this;
        }

        public ConventionFilterTypesBinder InNamespace(string ns)
        {
            return InNamespaces(ns);
        }

        public ConventionFilterTypesBinder InNamespaces(params string[] namespaces)
        {
            return InNamespaces((IEnumerable<string>)namespaces);
        }

        public ConventionFilterTypesBinder InNamespaces(IEnumerable<string> namespaces)
        {
            BindInfo.AddTypeFilter(t => namespaces.Any(n => IsInNamespace(t, n)));
            return this;
        }

        public ConventionFilterTypesBinder WithSuffix(string suffix)
        {
            BindInfo.AddTypeFilter(t => t.Name.EndsWith(suffix));
            return this;
        }

        public ConventionFilterTypesBinder WithPrefix(string prefix)
        {
            BindInfo.AddTypeFilter(t => t.Name.StartsWith(prefix));
            return this;
        }

        public ConventionFilterTypesBinder MatchingRegex(string pattern)
        {
            return MatchingRegex(pattern, RegexOptions.None);
        }

        public ConventionFilterTypesBinder MatchingRegex(string pattern, RegexOptions options)
        {
            return MatchingRegex(new Regex(pattern, options));
        }

        public ConventionFilterTypesBinder MatchingRegex(Regex regex)
        {
            BindInfo.AddTypeFilter(t => regex.IsMatch(t.Name));
            return this;
        }

        static bool IsInNamespace(Type type, string requiredNs)
        {
            var actualNs = type.Namespace ?? "";

            if (requiredNs.Length > actualNs.Length)
            {
                return false;
            }

            return actualNs.StartsWith(requiredNs)
                && (actualNs.Length == requiredNs.Length || actualNs[requiredNs.Length] == '.');
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionFilterTypesBinder.cs.meta
================================================
fileFormatVersion: 2
guid: fc3e9c89606ca52458403153ad0d9b3e
timeCreated: 1462127525
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionSelectTypesBinder.cs
================================================
#if !(UNITY_WSA && ENABLE_DOTNET)

namespace Zenject
{
    [NoReflectionBaking]
    public class ConventionSelectTypesBinder
    {
        readonly ConventionBindInfo _bindInfo;

        public ConventionSelectTypesBinder(ConventionBindInfo bindInfo)
        {
            _bindInfo = bindInfo;
        }

        ConventionFilterTypesBinder CreateNextBinder()
        {
            return new ConventionFilterTypesBinder(_bindInfo);
        }

        public ConventionFilterTypesBinder AllTypes()
        {
            // Do nothing (this is the default)
            return CreateNextBinder();
        }

        public ConventionFilterTypesBinder AllClasses()
        {
            _bindInfo.AddTypeFilter(t => t.IsClass);
            return CreateNextBinder();
        }

        public ConventionFilterTypesBinder AllNonAbstractClasses()
        {
            _bindInfo.AddTypeFilter(t => t.IsClass && !t.IsAbstract);
            return CreateNextBinder();
        }

        public ConventionFilterTypesBinder AllAbstractClasses()
        {
            _bindInfo.AddTypeFilter(t => t.IsClass && t.IsAbstract);
            return CreateNextBinder();
        }

        public ConventionFilterTypesBinder AllInterfaces()
        {
            _bindInfo.AddTypeFilter(t => t.IsInterface);
            return CreateNextBinder();
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Conventions/ConventionSelectTypesBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 05d17b3e7f09bc44f8be86e01642ee8d
timeCreated: 1462127469
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder.meta
================================================
fileFormatVersion: 2
guid: 3fd0e848e31df144fbbeab59a2c137e2
folderAsset: yes
timeCreated: 1528637818
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder.meta
================================================
fileFormatVersion: 2
guid: aa754ab1fdfa8714fb6eddd17108e5c6
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinderBase.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinderBase : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public FactoryFromBinderBase(
            DiContainer bindContainer, Type contractType, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindInfo)
        {
            FactoryBindInfo = factoryBindInfo;
            BindContainer = bindContainer;
            ContractType = contractType;
            factoryBindInfo.ProviderFunc =
                (container) => new TransientProvider(
                    ContractType, container, BindInfo.Arguments, BindInfo.ContextInfo, BindInfo.ConcreteIdentifier,
                    BindInfo.InstantiatedCallback);
        }

        // Don't use this
        internal DiContainer BindContainer
        {
            get; private set;
        }

        protected FactoryBindInfo FactoryBindInfo
        {
            get; private set;
        }

        // Don't use this
        internal Func<DiContainer, IProvider> ProviderFunc
        {
            get { return FactoryBindInfo.ProviderFunc; }
            set { FactoryBindInfo.ProviderFunc = value; }
        }

        protected Type ContractType
        {
            get; private set;
        }

        public IEnumerable<Type> AllParentTypes
        {
            get
            {
                yield return ContractType;

                foreach (var type in BindInfo.ToTypes)
                {
                    yield return type;
                }
            }
        }

        // Note that this isn't necessary to call since it's the default
        public ConditionCopyNonLazyBinder FromNew()
        {
            BindingUtil.AssertIsNotComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            return this;
        }

        public ConditionCopyNonLazyBinder FromResolve()
        {
            return FromResolve(null);
        }

        public ConditionCopyNonLazyBinder FromInstance(object instance)
        {
            BindingUtil.AssertInstanceDerivesFromOrEqual(instance, AllParentTypes);

            ProviderFunc =
                (container) => new InstanceProvider(ContractType, instance, container, null);

            return this;
        }

        public ConditionCopyNonLazyBinder FromResolve(object subIdentifier)
        {
            ProviderFunc =
                (container) => new ResolveProvider(
                    ContractType, container,
                    subIdentifier, false, InjectSources.Any, false);

            return this;
        }

        // Don't use this
        internal ConcreteBinderGeneric<T> CreateIFactoryBinder<T>(out Guid factoryId)
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            factoryId = Guid.NewGuid();

            // Very important here that we use NoFlush otherwise the main binding will be finalized early
            return BindContainer.BindNoFlush<T>().WithId(factoryId);
        }

#if !NOT_UNITY3D

        public ConditionCopyNonLazyBinder FromComponentOn(GameObject gameObject)
        {
            BindingUtil.AssertIsValidGameObject(gameObject);
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            ProviderFunc =
                (container) => new GetFromGameObjectComponentProvider(
                    ContractType, gameObject, true);

            return this;
        }

        public ConditionCopyNonLazyBinder FromComponentOn(Func<InjectContext, GameObject> gameObjectGetter)
        {
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            ProviderFunc =
                (container) => new GetFromGameObjectGetterComponentProvider(
                    ContractType, gameObjectGetter, true);

            return this;
        }

        public ConditionCopyNonLazyBinder FromComponentOnRoot()
        {
            return FromComponentOn(
                ctx => BindContainer.Resolve<Context>().gameObject);
        }

        public ConditionCopyNonLazyBinder FromNewComponentOn(GameObject gameObject)
        {
            BindingUtil.AssertIsValidGameObject(gameObject);
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            ProviderFunc =
                (container) => new AddToExistingGameObjectComponentProvider(
                    gameObject, container, ContractType,
                    new List<TypeValuePair>(), BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback);

            return this;
        }

        public ConditionCopyNonLazyBinder FromNewComponentOn(
            Func<InjectContext, GameObject> gameObjectGetter)
        {
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            ProviderFunc =
                (container) => new AddToExistingGameObjectComponentProviderGetter(
                    gameObjectGetter, container, ContractType,
                    new List<TypeValuePair>(), BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback);

            return this;
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewGameObject()
        {
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new AddToNewGameObjectComponentProvider(
                    container, ContractType,
                    new List<TypeValuePair>(), gameObjectInfo, BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefab(UnityEngine.Object prefab)
        {
            BindingUtil.AssertIsValidPrefab(prefab);
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new InstantiateOnPrefabComponentProvider(
                    ContractType,
                    new PrefabInstantiator(
                        container, gameObjectInfo,
                        ContractType, new [] { ContractType }, new List<TypeValuePair>(),
                        new PrefabProvider(prefab), BindInfo.InstantiatedCallback));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefab(UnityEngine.Object prefab)
        {
            BindingUtil.AssertIsValidPrefab(prefab);
            BindingUtil.AssertIsInterfaceOrComponent(ContractType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new GetFromPrefabComponentProvider(
                    ContractType,
                    new PrefabInstantiator(
                        container, gameObjectInfo,
                        ContractType, new [] { ContractType }, new List<TypeValuePair>(),
                        new PrefabProvider(prefab),
                        BindInfo.InstantiatedCallback), true);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefabResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrComponent(ContractType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new GetFromPrefabComponentProvider(
                    ContractType,
                    new PrefabInstantiator(
                        container, gameObjectInfo,
                        ContractType, new [] { ContractType }, new List<TypeValuePair>(),
                        new PrefabProviderResource(resourcePath), BindInfo.InstantiatedCallback), true);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefabResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsComponent(ContractType);
            BindingUtil.AssertIsNotAbstract(ContractType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new InstantiateOnPrefabComponentProvider(
                    ContractType,
                    new PrefabInstantiator(
                        container, gameObjectInfo,
                        ContractType, new [] { ContractType }, new List<TypeValuePair>(),
                        new PrefabProviderResource(resourcePath),
                        BindInfo.InstantiatedCallback));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public ConditionCopyNonLazyBinder FromNewScriptableObjectResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrScriptableObject(ContractType);

            ProviderFunc =
                (container) => new ScriptableObjectResourceProvider(
                    resourcePath, ContractType, container, new List<TypeValuePair>(),
                    true, null, BindInfo.InstantiatedCallback);

            return this;
        }

        public ConditionCopyNonLazyBinder FromScriptableObjectResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrScriptableObject(ContractType);

            ProviderFunc =
                (container) => new ScriptableObjectResourceProvider(
                    resourcePath, ContractType, container, new List<TypeValuePair>(),
                    false, null, BindInfo.InstantiatedCallback);

            return this;
        }

        public ConditionCopyNonLazyBinder FromResource(string resourcePath)
        {
            BindingUtil.AssertDerivesFromUnityObject(ContractType);

            ProviderFunc =
                (container) => new ResourceProvider(resourcePath, ContractType, true);

            return this;
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinderBase.cs.meta
================================================
fileFormatVersion: 2
guid: 1cdc9466c4b6c7f4f81675e8f546672f
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder.meta
================================================
fileFormatVersion: 2
guid: e1f8d57baff273344a3f10da1e51b772
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder.meta
================================================
fileFormatVersion: 2
guid: ad3cf76cc0b1c154e868ae8b570a78b8
folderAsset: yes
timeCreated: 1484511595
licenseType: Free
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/PlaceholderFactoryBindingFinalizer.cs
================================================
using System.Linq;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class PlaceholderFactoryBindingFinalizer<TContract> : ProviderBindingFinalizer
    {
        readonly FactoryBindInfo _factoryBindInfo;

        public PlaceholderFactoryBindingFinalizer(
            BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindInfo)
        {
            // Note that it doesn't derive from PlaceholderFactory<TContract>
            // when used with To<>, so we can only check IPlaceholderFactory
            Assert.That(factoryBindInfo.FactoryType.DerivesFrom<IPlaceholderFactory>());

            _factoryBindInfo = factoryBindInfo;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            var provider = _factoryBindInfo.ProviderFunc(container);

            var transientProvider = new TransientProvider(
                _factoryBindInfo.FactoryType,
                container,
                _factoryBindInfo.Arguments.Concat(
                    InjectUtil.CreateArgListExplicit(
                        provider,
                        new InjectContext(container, typeof(TContract)))).ToList(),
                BindInfo.ContextInfo, BindInfo.ConcreteIdentifier, null);

            IProvider mainProvider;

            if (BindInfo.Scope == ScopeTypes.Unset || BindInfo.Scope == ScopeTypes.Singleton)
            {
                mainProvider = BindingUtil.CreateCachedProvider(transientProvider);
            }
            else
            {
                Assert.IsEqual(BindInfo.Scope, ScopeTypes.Transient);
                mainProvider = transientProvider;
            }

            RegisterProviderForAllContracts(container, mainProvider);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/PlaceholderFactoryBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: 2a3880a3063c56747b32995b66a8a1ca
timeCreated: 1486691381
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling.meta
================================================
fileFormatVersion: 2
guid: a019116e68c18f342995df14d6fbcf87
folderAsset: yes
timeCreated: 1484511595
licenseType: Free
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder0.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TContract> : FactoryToChoiceBinder<TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments<TParam1, TParam2>(TParam1 param1, TParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments<TParam1, TParam2, TParam3>(
            TParam1 param1, TParam2 param2, TParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments<TParam1, TParam2, TParam3, TParam4>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments<TParam1, TParam2, TParam3, TParam4, TParam5>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder0.cs.meta
================================================
fileFormatVersion: 2
guid: ca3197650e9628a45b99e79b8dea27d9
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder1.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TContract> : FactoryToChoiceBinder<TParam1, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder1.cs.meta
================================================
fileFormatVersion: 2
guid: a37e124df695f644e87579f08ea443f7
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder10.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder10.cs.meta
================================================
fileFormatVersion: 2
guid: 614bb4e31afa5154487c94e128e9461a
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder2.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder2.cs.meta
================================================
fileFormatVersion: 2
guid: 3b450191ad6422c4f841a99cdf3d108a
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder3.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder3.cs.meta
================================================
fileFormatVersion: 2
guid: 667d9c959f8ba004f86c8202d637f9ce
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder4.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder4.cs.meta
================================================
fileFormatVersion: 2
guid: ce44f168dd48e1442b43a43c925abc47
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder5.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder5.cs.meta
================================================
fileFormatVersion: 2
guid: f3c4d5776729d2d4abae523dd6dce595
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder6.cs
================================================
using System.Collections.Generic;
using System.Linq;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> : FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
    {
        public FactoryArgumentsToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // We use generics instead of params object[] so that we preserve type info
        // So that you can for example pass in a variable that is null and the type info will
        // still be used to map null on to the correct field
        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<T>(T param)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2>(TFactoryParam1 param1, TFactoryParam2 param2)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments<TFactoryParam1, TFactoryParam2, TFactoryParam3, TFactoryParam4, TFactoryParam5, TFactoryParam6>(
            TFactoryParam1 param1, TFactoryParam2 param2, TFactoryParam3 param3, TFactoryParam4 param4, TFactoryParam5 param5, TFactoryParam6 param6)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgListExplicit(param1, param2, param3, param4, param5, param6);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArguments(object[] args)
        {
            FactoryBindInfo.Arguments = InjectUtil.CreateArgList(args);
            return this;
        }

        public FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithFactoryArgumentsExplicit(IEnumerable<TypeValuePair> extraArgs)
        {
            FactoryBindInfo.Arguments = extraArgs.ToList();
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryArgumentsToChoiceBinder/FactoryArgumentsToChoiceBinder6.cs.meta
================================================
fileFormatVersion: 2
guid: 22836272211e07a459544765e2e7c098
timeCreated: 1528637818
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder0.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TContract> : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromResolveGetter<TObj>(Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj>(null, method);
        }

        public ConditionCopyNonLazyBinder FromResolveGetter<TObj>(
            object subIdentifier, Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj>(subIdentifier, method, InjectSources.Any);
        }

        public ConditionCopyNonLazyBinder FromResolveGetter<TObj>(
            object subIdentifier, Func<TObj, TContract> method, InjectSources source)
        {
            FactoryBindInfo.ProviderFunc =
                (container) => new GetterProvider<TObj, TContract>(subIdentifier, method, container, source, false);

            return this;
        }

        public ConditionCopyNonLazyBinder FromMethod(Func<DiContainer, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ArgConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }

#if !NOT_UNITY3D

        public ConditionCopyNonLazyBinder FromComponentInHierarchy(
            bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(ContractType);

            return FromMethod(_ =>
                {
                    var res = BindContainer.Resolve<Context>().GetRootGameObjects()
                        .Select(x => x.GetComponentInChildren<TContract>(includeInactive))
                        .Where(x => x != null).FirstOrDefault();

                    Assert.IsNotNull(res,
                        "Could not find component '{0}' through FromComponentInHierarchy factory binding", typeof(TContract));

                    return res;
                });
        }
#endif
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder0Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TContract, TMemoryPool>(
            this FactoryFromBinder<TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<IMemoryPool>
            where TMemoryPool : MemoryPool<IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>().WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TContract>(
            this FactoryFromBinder<TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TContract>(
            this FactoryFromBinder<TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TContract, PoolableMemoryPool<IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TContract>(
            this FactoryFromBinder<TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TContract>(
            this FactoryFromBinder<TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TContract, MonoPoolableMemoryPool<IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TContract, TMemoryPool>(
            this FactoryFromBinder<TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<IMemoryPool>
            where TMemoryPool : MemoryPool<IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromIFactory<TContract>(
            this FactoryFromBinder<TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder0.cs.meta
================================================
fileFormatVersion: 2
guid: fd0f7feaafd2cc44da895162de285da7
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder1.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TContract> : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(Func<DiContainer, TParam1, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder1Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TContract>(
            this FactoryFromBinder<TParam1, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TContract>(
            this FactoryFromBinder<TParam1, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TContract>(
            this FactoryFromBinder<TParam1, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TContract, PoolableMemoryPool<TParam1, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TContract>(
            this FactoryFromBinder<TParam1, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TContract>(
            this FactoryFromBinder<TParam1, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TContract, MonoPoolableMemoryPool<TParam1, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>().WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder1.cs.meta
================================================
fileFormatVersion: 2
guid: 57ab0b3d05763f14fb530d07a5acd481
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder10.cs
================================================
using System;

#if !NOT_UNITY3D

#endif

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
        : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
                Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> method)
        {
            ProviderFunc =
                container => new MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
        {
            return FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public ArgConditionCopyNonLazyBinder FromIFactory(
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                CreateIFactoryBinder<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>>(out factoryId));

            ProviderFunc =
                container => { return new IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(BindInfo);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder10.cs.meta
================================================
fileFormatVersion: 2
guid: d835e30b6131d754e892d6f397e9921a
timeCreated: 1507270780
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder2.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TContract> : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(Func<DiContainer, TParam1, TParam2, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TParam2, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TParam2, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder2Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TParam2, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TParam2, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TParam2, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TContract, PoolableMemoryPool<TParam1, TParam2, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TParam2, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TContract, MonoPoolableMemoryPool<TParam1, TParam2, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>()
                .WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TParam2, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder2.cs.meta
================================================
fileFormatVersion: 2
guid: a36f88760754c1c498ab3270dfb88b72
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder3.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TParam3, TContract> : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(Func<DiContainer, TParam1, TParam2, TParam3, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TParam2, TParam3, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TParam3, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TParam3, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder3Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TParam2, TParam3, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TParam3, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TParam2, TParam3, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TParam2, TParam3, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract, PoolableMemoryPool<TParam1, TParam2, TParam3, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract, MonoPoolableMemoryPool<TParam1, TParam2, TParam3, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>()
                .WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder3.cs.meta
================================================
fileFormatVersion: 2
guid: 4eb3a4d5d01c55748b43f48a1da3c7b6
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder4.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TParam3, TParam4, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder4Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TParam2, TParam3, TParam4, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TParam3, TParam4, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TParam2, TParam3, TParam4, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract, PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract, MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>()
                .WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder4.cs.meta
================================================
fileFormatVersion: 2
guid: e67ee9caa78de914a9c727a607c3d8c0
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder5.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
        : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder5Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool, TContract>
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>()
                .WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder5.cs.meta
================================================
fileFormatVersion: 2
guid: 901200be3b8d1cc40876aa50a03103b8
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder6.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using UnityEngine;
#endif
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
        : FactoryFromBinderBase
    {
        public FactoryFromBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, typeof(TContract), bindInfo, factoryBindInfo)
        {
        }

        public ConditionCopyNonLazyBinder FromMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> method)
        {
            ProviderFunc =
                (container) => new MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(method);

            return this;
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ConditionCopyNonLazyBinder FromFactory<TSubFactory>()
            where TSubFactory : IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
        {
            return this.FromIFactory(x => x.To<TSubFactory>().AsCached());
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> FromSubContainerResolve(object subIdentifier)
        {
            return new FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
                BindContainer, BindInfo, FactoryBindInfo, subIdentifier);
        }
    }

    // These methods have to be extension methods for the UWP build (with .NET backend) to work correctly
    // When these are instance methods it takes a really long time then fails with StackOverflowException
    public static class FactoryFromBinder6Extensions
    {
        public static ArgConditionCopyNonLazyBinder FromIFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder,
            Action<ConcreteBinderGeneric<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>>> factoryBindGenerator)
        {
            Guid factoryId;
            factoryBindGenerator(
                fromBinder.CreateIFactoryBinder<IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>>(out factoryId));

            fromBinder.ProviderFunc =
                (container) => { return new IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(container, factoryId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool, TContract>>(poolBindGenerator);
        }

#if !NOT_UNITY3D
        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
        {
            return fromBinder.FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromMonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool, TContract>>(poolBindGenerator);
        }
#endif

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool, TContract>
        {
            return fromBinder.FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, TMemoryPool>(x => {});
        }

        public static ArgConditionCopyNonLazyBinder FromPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, TMemoryPool>(
            this FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> fromBinder,
            Action<MemoryPoolInitialSizeMaxSizeBinder<TContract>> poolBindGenerator)
            // Unfortunately we have to pass the same contract in again to satisfy the generic
            // constraints below
            where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
            where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool, TContract>
        {
            Assert.IsEqual(typeof(TContract), typeof(TContract));

            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var poolId = Guid.NewGuid();

            // Important to use NoFlush otherwise the binding will be finalized early
            var binder = fromBinder.BindContainer.BindMemoryPoolCustomInterfaceNoFlush<TContract, TMemoryPool, TMemoryPool>()
                .WithId(poolId);

            // Always make it non lazy by default in case the user sets an InitialSize
            binder.NonLazy();

            poolBindGenerator(binder);

            fromBinder.ProviderFunc =
                (container) => { return new PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, TMemoryPool>(container, poolId); };

            return new ArgConditionCopyNonLazyBinder(fromBinder.BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/FactoryFromBinder6.cs.meta
================================================
fileFormatVersion: 2
guid: b79f4e548e208b1418f013d2fdb0e076
timeCreated: 1528529860
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder.meta
================================================
fileFormatVersion: 2
guid: 17d1fc460074cfc419ffecab2a7e97e8
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/Untyped.meta
================================================
fileFormatVersion: 2
guid: 97d57d9da80f7414a8fed9f2a04621b8
folderAsset: yes
timeCreated: 1512304190
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder0.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TContract>
        : FactorySubContainerBinderBase<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(Action<DiContainer> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(Action<DiContainer> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Action<DiContainer> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab, Action<DiContainer> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath, Action<DiContainer> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        [System.Obsolete("ByNewPrefab has been renamed to ByNewContextPrefab to avoid confusion with ByNewPrefabInstaller and ByNewPrefabMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefab(UnityEngine.Object prefab)
        {
            return ByNewContextPrefab(prefab);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefab(UnityEngine.Object prefab)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefab(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        [System.Obsolete("ByNewPrefabResource has been renamed to ByNewContextPrefabResource to avoid confusion with ByNewPrefabResourceInstaller and ByNewPrefabResourceMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResource(string resourcePath)
        {
            return ByNewContextPrefabResource(resourcePath);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefabResource(string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefab(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder0.cs.meta
================================================
fileFormatVersion: 2
guid: 3c12d5eb6ac4cc8449986d020ef27e4f
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder1.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(Action<DiContainer, TParam1> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
            Action<DiContainer, TParam1> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Action<DiContainer, TParam1> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab, Action<DiContainer, TParam1> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath, Action<DiContainer, TParam1> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder1.cs.meta
================================================
fileFormatVersion: 2
guid: b119fe818c4bae143ab8f9a4f2a1b0fd
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder10.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10>( container,
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10>( container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10>( container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10>( container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder10.cs.meta
================================================
fileFormatVersion: 2
guid: 3b6136acd174dfc4d9b9d3f2b9e110e4
timeCreated: 1507270779
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder2.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(Action<DiContainer, TParam1, TParam2> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc = 
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
            Action<DiContainer, TParam1, TParam2> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Action<DiContainer, TParam1, TParam2> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab, Action<DiContainer, TParam1, TParam2> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath, Action<DiContainer, TParam1, TParam2> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder2.cs.meta
================================================
fileFormatVersion: 2
guid: 5f32bdc495dbe204caab18bace045515
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder3.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TParam3, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2, TParam3>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
            Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab, Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath, Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder3.cs.meta
================================================
fileFormatVersion: 2
guid: fdb97e2862ca0a24e8f87c081ea05727
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder4.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder4.cs.meta
================================================
fileFormatVersion: 2
guid: b0f061434819b334289a066ab685ab37
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder5.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder5.cs.meta
================================================
fileFormatVersion: 2
guid: e562a021e16d4a2418f6c47de105c64e
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder6.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
        : FactorySubContainerBinderWithParams<TContract>
    {
        public FactorySubContainerBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
        {
            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
                        container, subcontainerBindInfo, installerMethod), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectMethod(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
                        container, gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            Func<InjectContext, UnityEngine.Object> prefabGetter,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
        {
            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabMethod(
            UnityEngine.Object prefab,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceMethod(
            string resourcePath,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerMethod), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinder6.cs.meta
================================================
fileFormatVersion: 2
guid: 6bc525cf91bd29644ab941902ab4a8d2
timeCreated: 1528529860
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinderBase.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinderBase<TContract>
    {
        public FactorySubContainerBinderBase(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
        {
            FactoryBindInfo = factoryBindInfo;
            SubIdentifier = subIdentifier;
            BindInfo = bindInfo;
            BindContainer = bindContainer;

            // Reset so we get errors if we end here
            factoryBindInfo.ProviderFunc = null;
        }

        protected DiContainer BindContainer
        {
            get; private set;
        }

        protected FactoryBindInfo FactoryBindInfo
        {
            get; private set;
        }

        protected Func<DiContainer, IProvider> ProviderFunc
        {
            get { return FactoryBindInfo.ProviderFunc; }
            set { FactoryBindInfo.ProviderFunc = value; }
        }

        protected BindInfo BindInfo
        {
            get;
            private set;
        }

        protected object SubIdentifier
        {
            get;
            private set;
        }

        protected Type ContractType
        {
            get { return typeof(TContract); }
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByInstaller<TInstaller>()
            where TInstaller : InstallerBase
        {
            return ByInstaller(typeof(TInstaller));
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder ByInstaller(Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var subcontainerBindInfo = new SubContainerCreatorBindInfo();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByInstaller(
                        container, subcontainerBindInfo, installerType, BindInfo.Arguments), false);

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

#if !NOT_UNITY3D
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectInstaller<TInstaller>()
            where TInstaller : InstallerBase
        {
            return ByNewGameObjectInstaller(typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewGameObjectInstaller(Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewGameObjectInstaller(
                        container, gameObjectInfo, installerType, BindInfo.Arguments), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller<TInstaller>(
            Func<InjectContext, UnityEngine.Object> prefabGetter)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabInstaller(prefabGetter, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller(
            Func<InjectContext, UnityEngine.Object> prefabGetter, Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabInstaller(
                        container,
                        new PrefabProviderCustom(prefabGetter),
                        gameObjectInfo, installerType, BindInfo.Arguments), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller<TInstaller>(
            UnityEngine.Object prefab)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabInstaller(prefab, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabInstaller(
            UnityEngine.Object prefab, Type installerType)
        {
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabInstaller(
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo, installerType, BindInfo.Arguments), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceInstaller<TInstaller>(
            string resourcePath)
            where TInstaller : InstallerBase
        {
            return ByNewPrefabResourceInstaller(resourcePath, typeof(TInstaller));
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResourceInstaller(
            string resourcePath, Type installerType)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc =
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabInstaller(
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo, installerType, BindInfo.Arguments), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinderBase.cs.meta
================================================
fileFormatVersion: 2
guid: 387c12fd770c48e49bcefe4c0723d511
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinderWithParams.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactorySubContainerBinderWithParams<TContract> : FactorySubContainerBinderBase<TContract>
    {
        public FactorySubContainerBinderWithParams(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, object subIdentifier)
            : base(bindContainer, bindInfo, factoryBindInfo, subIdentifier)
        {
        }

#if !NOT_UNITY3D

        [System.Obsolete("ByNewPrefab has been renamed to ByNewContextPrefab to avoid confusion with ByNewPrefabInstaller and ByNewPrefabMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefab(Type installerType, UnityEngine.Object prefab)
        {
            return ByNewContextPrefab(installerType, prefab);
        }

        [System.Obsolete("ByNewPrefab has been renamed to ByNewContextPrefab to avoid confusion with ByNewPrefabInstaller and ByNewPrefabMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefab<TInstaller>(UnityEngine.Object prefab)
            where TInstaller : IInstaller
        {
            return ByNewContextPrefab<TInstaller>(prefab);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefab<TInstaller>(UnityEngine.Object prefab)
            where TInstaller : IInstaller
        {
            return ByNewContextPrefab(typeof(TInstaller), prefab);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefab(Type installerType, UnityEngine.Object prefab)
        {
            BindingUtil.AssertIsValidPrefab(prefab);

            Assert.That(installerType.DerivesFrom<MonoInstaller>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'MonoInstaller'", installerType);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc = 
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabWithParams(
                        installerType,
                        container,
                        new PrefabProvider(prefab),
                        gameObjectInfo), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        [System.Obsolete("ByNewPrefabResource has been renamed to ByNewContextPrefabResource to avoid confusion with ByNewPrefabResourceInstaller and ByNewPrefabResourceMethod")]
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResource<TInstaller>(string resourcePath)
            where TInstaller : IInstaller
        {
            return ByNewContextPrefabResource<TInstaller>(resourcePath);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewPrefabResource(
            Type installerType, string resourcePath)
        {
            return ByNewContextPrefabResource(installerType, resourcePath);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefabResource<TInstaller>(string resourcePath)
            where TInstaller : IInstaller
        {
            return ByNewContextPrefabResource(typeof(TInstaller), resourcePath);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder ByNewContextPrefabResource(
            Type installerType, string resourcePath)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);

            var gameObjectInfo = new GameObjectCreationParameters();

            ProviderFunc = 
                (container) => new SubContainerDependencyProvider(
                    ContractType, SubIdentifier,
                    new SubContainerCreatorByNewPrefabWithParams(
                        installerType,
                        container,
                        new PrefabProviderResource(resourcePath),
                        gameObjectInfo), false);

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/SubContainerBinder/FactorySubContainerBinderWithParams.cs.meta
================================================
fileFormatVersion: 2
guid: a002e9dce4e8af54d948529d6beda84b
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/Untyped/FactoryFromBinderUntyped.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryFromBinderUntyped : FactoryFromBinderBase
    {
        public FactoryFromBinderUntyped(
            DiContainer bindContainer, Type contractType, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, contractType, bindInfo, factoryBindInfo)
        {
        }

        // TODO - add similar methods found in FactoryFromBinder<>
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryFromBinder/Untyped/FactoryFromBinderUntyped.cs.meta
================================================
fileFormatVersion: 2
guid: ed1989ebc010d0746ab301cc5747f5c8
timeCreated: 1512304191
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/DecoratorToChoiceFromBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class DecoratorToChoiceFromBinder<TContract>
    {
        DiContainer _bindContainer;
        BindInfo _bindInfo;
        FactoryBindInfo _factoryBindInfo;

        public DecoratorToChoiceFromBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
        {
            _bindContainer = bindContainer;
            _bindInfo = bindInfo;
            _factoryBindInfo = factoryBindInfo;
        }

        public FactoryFromBinder<TContract, TConcrete> With<TConcrete>()
            where TConcrete : TContract
        {
            _bindInfo.ToChoice = ToChoices.Concrete;
            _bindInfo.ToTypes.Clear();
            _bindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TContract, TConcrete>(
                _bindContainer, _bindInfo, _factoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/DecoratorToChoiceFromBinder.cs.meta
================================================
fileFormatVersion: 2
guid: e70f91cb77703ce42ae6ad721b89d35c
timeCreated: 1528372067
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder0.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TContract> : FactoryFromBinder<TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinderUntyped To(Type concreteType)
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(concreteType);

            return new FactoryFromBinderUntyped(
                BindContainer, concreteType, BindInfo, FactoryBindInfo);
        }

        public FactoryFromBinder<TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder0.cs.meta
================================================
fileFormatVersion: 2
guid: 98bc5c26f28a00544afe116adee67cc2
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder1.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TContract> : FactoryFromBinder<TParam1, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder1.cs.meta
================================================
fileFormatVersion: 2
guid: 388c17c735861d145903203b31cb190d
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder10.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
        : FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder10.cs.meta
================================================
fileFormatVersion: 2
guid: 4cdcd151f6d139642b7a2a6968c6ebd8
timeCreated: 1507270779
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder2.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TContract> : FactoryFromBinder<TParam1, TParam2, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder2.cs.meta
================================================
fileFormatVersion: 2
guid: 59c18bddf62adaf46b1de0564bf02388
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder3.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TParam3, TContract> : FactoryFromBinder<TParam1, TParam2, TParam3, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TParam3, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TParam3, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TParam3, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder3.cs.meta
================================================
fileFormatVersion: 2
guid: a71cc77bd306cca459126294c63080b1
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder4.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> : FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder4.cs.meta
================================================
fileFormatVersion: 2
guid: fee2c810a2ee8d2489a6a29177b48d82
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder5.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
        : FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder5.cs.meta
================================================
fileFormatVersion: 2
guid: dc472af8f2bc5bf498b8e85704193aac
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder6.cs
================================================
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
        : FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
    {
        public FactoryToChoiceBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        // Note that this is the default, so not necessary to call
        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> ToSelf()
        {
            Assert.IsEqual(BindInfo.ToChoice, ToChoices.Self);
            return this;
        }

        public FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TConcrete> To<TConcrete>()
            where TConcrete : TContract
        {
            BindInfo.ToChoice = ToChoices.Concrete;
            BindInfo.ToTypes.Clear();
            BindInfo.ToTypes.Add(typeof(TConcrete));

            return new FactoryFromBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TConcrete>(BindContainer, BindInfo, FactoryBindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceBinder/FactoryToChoiceBinder6.cs.meta
================================================
fileFormatVersion: 2
guid: 4c738f3e9159a7e4f8450de246530f96
timeCreated: 1528529860
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder0.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TContract> : FactoryArgumentsToChoiceBinder<TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer container, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(container, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder0.cs.meta
================================================
fileFormatVersion: 2
guid: dca817e151a0eac4480344dcf838b949
timeCreated: 1484511596
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder1.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TContract> : FactoryArgumentsToChoiceBinder<TParam1, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder1.cs.meta
================================================
fileFormatVersion: 2
guid: a005e8d2a91ae2647927c047c663d046
timeCreated: 1484511596
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder10.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
        : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder10.cs.meta
================================================
fileFormatVersion: 2
guid: 3e0b2700788fac54698446fcfad2b705
timeCreated: 1507270779
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder2.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TContract> : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder2.cs.meta
================================================
fileFormatVersion: 2
guid: c109e2a5fd72a004e83beae958fa888a
timeCreated: 1484511596
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder3.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TParam3, TContract> : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder3.cs.meta
================================================
fileFormatVersion: 2
guid: be02341a689ce654ab7160ce4eb5ed0e
timeCreated: 1484511596
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder4.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TParam3, TParam4, TContract> : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder4.cs.meta
================================================
fileFormatVersion: 2
guid: e65744c901e080744aada3988bfdf11c
timeCreated: 1484511596
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder5.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
        : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder5.cs.meta
================================================
fileFormatVersion: 2
guid: 20b01a4cfa147764a9e52134e2a32bb4
timeCreated: 1484511595
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder6.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryToChoiceIdBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
        : FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>
    {
        public FactoryToChoiceIdBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
        }

        public FactoryArgumentsToChoiceBinder<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/FactoryToChoiceIdBinder/FactoryToChoiceIdBinder6.cs.meta
================================================
fileFormatVersion: 2
guid: b60ae0cff4748ec43b6cb040b0f3a728
timeCreated: 1528529860
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolBindingFinalizer.cs
================================================
using System.Linq;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MemoryPoolBindingFinalizer<TContract> : ProviderBindingFinalizer
    {
        readonly MemoryPoolBindInfo _poolBindInfo;
        readonly FactoryBindInfo _factoryBindInfo;

        public MemoryPoolBindingFinalizer(
            BindInfo bindInfo, FactoryBindInfo factoryBindInfo, MemoryPoolBindInfo poolBindInfo)
            : base(bindInfo)
        {
            // Note that it doesn't derive from MemoryPool<TContract>
            // when used with To<>, so we can only check IMemoryPoolBase
            Assert.That(factoryBindInfo.FactoryType.DerivesFrom<IMemoryPool>());

            _factoryBindInfo = factoryBindInfo;
            _poolBindInfo = poolBindInfo;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            var factory = new FactoryProviderWrapper<TContract>(
                _factoryBindInfo.ProviderFunc(container), new InjectContext(container, typeof(TContract)));

            var settings = new MemoryPoolSettings(
                _poolBindInfo.InitialSize, _poolBindInfo.MaxSize, _poolBindInfo.ExpandMethod);

            var transientProvider = new TransientProvider(
                _factoryBindInfo.FactoryType,
                container,
                _factoryBindInfo.Arguments.Concat(
                    InjectUtil.CreateArgListExplicit(factory, settings)).ToList(),
                BindInfo.ContextInfo, BindInfo.ConcreteIdentifier, null);

            IProvider mainProvider;

            if (BindInfo.Scope == ScopeTypes.Unset || BindInfo.Scope == ScopeTypes.Singleton)
            {
                mainProvider = BindingUtil.CreateCachedProvider(transientProvider);
            }
            else
            {
                Assert.IsEqual(BindInfo.Scope, ScopeTypes.Transient);
                mainProvider = transientProvider;
            }

            RegisterProviderForAllContracts(container, mainProvider);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: 41eb30ac64078db4090dd136ccaf1fbe
timeCreated: 1485699960
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolExpandBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class MemoryPoolExpandBinder<TContract> : FactoryArgumentsToChoiceBinder<TContract>
    {
        public MemoryPoolExpandBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, MemoryPoolBindInfo poolBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo)
        {
            MemoryPoolBindInfo = poolBindInfo;

            ExpandByOneAtATime();
        }

        protected MemoryPoolBindInfo MemoryPoolBindInfo
        {
            get; private set;
        }

        public FactoryArgumentsToChoiceBinder<TContract> ExpandByOneAtATime()
        {
            MemoryPoolBindInfo.ExpandMethod = PoolExpandMethods.OneAtATime;
            return this;
        }

        public FactoryArgumentsToChoiceBinder<TContract> ExpandByDoubling()
        {
            MemoryPoolBindInfo.ExpandMethod = PoolExpandMethods.Double;
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolExpandBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 95b7c7be81364a740b952460f5a07bbf
timeCreated: 1485699961
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolInitialSizeBinder.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class MemoryPoolMaxSizeBinder<TContract> : MemoryPoolExpandBinder<TContract>
    {
        public MemoryPoolMaxSizeBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, MemoryPoolBindInfo poolBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo, poolBindInfo)
        {
        }

        public MemoryPoolExpandBinder<TContract> WithMaxSize(int size)
        {
            MemoryPoolBindInfo.MaxSize = size;
            return this;
        }
    }

    [NoReflectionBaking]
    public class MemoryPoolInitialSizeMaxSizeBinder<TContract> : MemoryPoolMaxSizeBinder<TContract>
    {
        public MemoryPoolInitialSizeMaxSizeBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, MemoryPoolBindInfo poolBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo, poolBindInfo)
        {
        }

        public MemoryPoolMaxSizeBinder<TContract> WithInitialSize(int size)
        {
            MemoryPoolBindInfo.InitialSize = size;
            return this;
        }

        public FactoryArgumentsToChoiceBinder<TContract> WithFixedSize(int size)
        {
            MemoryPoolBindInfo.InitialSize = size;
            MemoryPoolBindInfo.MaxSize = size;
            MemoryPoolBindInfo.ExpandMethod = PoolExpandMethods.Disabled;
            return this;
        }
    }

    [NoReflectionBaking]
    public class MemoryPoolIdInitialSizeMaxSizeBinder<TContract> : MemoryPoolInitialSizeMaxSizeBinder<TContract>
    {
        public MemoryPoolIdInitialSizeMaxSizeBinder(
            DiContainer bindContainer, BindInfo bindInfo, FactoryBindInfo factoryBindInfo, MemoryPoolBindInfo poolBindInfo)
            : base(bindContainer, bindInfo, factoryBindInfo, poolBindInfo)
        {
        }

        public MemoryPoolInitialSizeMaxSizeBinder<TContract> WithId(object identifier)
        {
            BindInfo.Identifier = identifier;
            return this;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/Factory/Pooling/MemoryPoolInitialSizeBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 80ff9e6d501d30d4a82639f4ae453712
timeCreated: 1485699961
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinder.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;
using System.Linq;

#if !NOT_UNITY3D
using UnityEngine;
#endif

using Zenject.Internal;

namespace Zenject
{
    public abstract class FromBinder : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public FromBinder(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindInfo)
        {
            BindStatement = bindStatement;
            BindContainer = bindContainer;
        }

        protected DiContainer BindContainer
        {
            get; private set;
        }

        protected BindStatement BindStatement
        {
            get;
            private set;
        }

        protected IBindingFinalizer SubFinalizer
        {
            set { BindStatement.SetFinalizer(value); }
        }

        protected IEnumerable<Type> AllParentTypes
        {
            get { return BindInfo.ContractTypes.Concat(BindInfo.ToTypes); }
        }

        protected IEnumerable<Type> ConcreteTypes
        {
            get
            {
                if (BindInfo.ToChoice == ToChoices.Self)
                {
                    return BindInfo.ContractTypes;
                }

                Assert.IsNotEmpty(BindInfo.ToTypes);
                return BindInfo.ToTypes;
            }
        }

        // This is the default if nothing else is called
        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNew()
        {
            BindingUtil.AssertTypesAreNotComponents(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolve()
        {
            return FromResolve(null);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolve(object subIdentifier)
        {
            return FromResolve(subIdentifier, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolve(object subIdentifier, InjectSources source)
        {
            return FromResolveInternal(subIdentifier, false, source);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAll()
        {
            return FromResolveAll(null);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAll(object subIdentifier)
        {
            return FromResolveAll(subIdentifier, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAll(object subIdentifier, InjectSources source)
        {
            return FromResolveInternal(subIdentifier, true, source);
        }

        ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveInternal(object subIdentifier, bool matchAll, InjectSources source)
        {
            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new ResolveProvider(
                    type, container, subIdentifier, false, source, matchAll));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public SubContainerBinder FromSubContainerResolveAll()
        {
            return FromSubContainerResolveAll(null);
        }

        public SubContainerBinder FromSubContainerResolveAll(object subIdentifier)
        {
            return FromSubContainerResolveInternal(subIdentifier, true);
        }

        public SubContainerBinder FromSubContainerResolve()
        {
            return FromSubContainerResolve(null);
        }

        public SubContainerBinder FromSubContainerResolve(object subIdentifier)
        {
            return FromSubContainerResolveInternal(subIdentifier, false);
        }

        SubContainerBinder FromSubContainerResolveInternal(
            object subIdentifier, bool resolveAll)
        {
            // It's unlikely they will want to create the whole subcontainer with each binding
            // (aka transient) which is the default so require that they specify it
            BindInfo.RequireExplicitScope = true;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            return new SubContainerBinder(
                BindInfo, BindStatement, subIdentifier, resolveAll);
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromIFactoryBase<TContract>(
            Action<ConcreteBinderGeneric<IFactory<TContract>>> factoryBindGenerator)
        {
            // Use a random ID so that our provider is the only one that can find it and so it doesn't
            // conflict with anything else
            var factoryId = Guid.NewGuid();

            // Important to use NoFlush here otherwise the main binding will finalize early
            var subBinder = BindContainer.BindNoFlush<IFactory<TContract>>()
                .WithId(factoryId);

            factoryBindGenerator(subBinder);

            // This is kind of like a look up method like FromMethod so don't enforce specifying scope
            // The internal binding will require an explicit scope so should be obvious enough
            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new IFactoryProvider<TContract>(container, factoryId));

            var binder = new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
            // Needed for example if the user uses MoveIntoDirectSubContainers
            binder.AddSecondaryCopyBindInfo(subBinder.BindInfo);
            return binder;
        }

#if !NOT_UNITY3D

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsOn(GameObject gameObject)
        {
            BindingUtil.AssertIsValidGameObject(gameObject);
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new GetFromGameObjectComponentProvider(
                    type, gameObject, false));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentOn(GameObject gameObject)
        {
            BindingUtil.AssertIsValidGameObject(gameObject);
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new GetFromGameObjectComponentProvider(
                    type, gameObject, true));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsOn(Func<InjectContext, GameObject> gameObjectGetter)
        {
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new GetFromGameObjectGetterComponentProvider(
                    type, gameObjectGetter, false));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentOn(Func<InjectContext, GameObject> gameObjectGetter)
        {
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new GetFromGameObjectGetterComponentProvider(
                    type, gameObjectGetter, true));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsOnRoot()
        {
            return FromComponentsOn(
                ctx => ctx.Container.Resolve<Context>().gameObject);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentOnRoot()
        {
            return FromComponentOn(
                ctx => ctx.Container.Resolve<Context>().gameObject);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOn(GameObject gameObject)
        {
            BindingUtil.AssertIsValidGameObject(gameObject);
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new AddToExistingGameObjectComponentProvider(
                    gameObject, container, type, BindInfo.Arguments, BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOn(Func<InjectContext, GameObject> gameObjectGetter)
        {
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new AddToExistingGameObjectComponentProviderGetter(
                    gameObjectGetter, container, type, BindInfo.Arguments, BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentSibling()
        {
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new SingleProviderBindingFinalizer(
                BindInfo, (container, type) => new AddToCurrentGameObjectComponentProvider(
                    container, type, BindInfo.Arguments, BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnRoot()
        {
            return FromNewComponentOn(
                ctx => ctx.Container.Resolve<Context>().gameObject);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewGameObject()
        {
            return FromNewComponentOnNewGameObject(new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewGameObject(
            GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new AddToNewGameObjectComponentProvider(
                    container,
                    type,
                    BindInfo.Arguments,
                    gameObjectInfo, BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefabResource(string resourcePath)
        {
            return FromNewComponentOnNewPrefabResource(resourcePath, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefabResource(
            string resourcePath, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabResourceBindingFinalizer(
                BindInfo, gameObjectInfo, resourcePath,
                (contractType, instantiator) => new InstantiateOnPrefabComponentProvider(contractType, instantiator));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefab(UnityEngine.Object prefab)
        {
            return FromNewComponentOnNewPrefab(prefab, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromNewComponentOnNewPrefab(
            UnityEngine.Object prefab, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidPrefab(prefab);
            BindingUtil.AssertIsComponent(ConcreteTypes);
            BindingUtil.AssertTypesAreNotAbstract(ConcreteTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabBindingFinalizer(
                BindInfo, gameObjectInfo, prefab,
                (contractType, instantiator) =>
                    new InstantiateOnPrefabComponentProvider(contractType, instantiator));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefab(UnityEngine.Object prefab)
        {
            return FromComponentInNewPrefab(
                prefab, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefab(
            UnityEngine.Object prefab, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidPrefab(prefab);
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabBindingFinalizer(
                BindInfo, gameObjectInfo, prefab,
                (contractType, instantiator) => new GetFromPrefabComponentProvider(contractType, instantiator, true));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInNewPrefab(UnityEngine.Object prefab)
        {
            return FromComponentsInNewPrefab(
                prefab, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInNewPrefab(
            UnityEngine.Object prefab, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidPrefab(prefab);
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabBindingFinalizer(
                BindInfo, gameObjectInfo, prefab,
                (contractType, instantiator) => new GetFromPrefabComponentProvider(contractType, instantiator, false));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefabResource(string resourcePath)
        {
            return FromComponentInNewPrefabResource(resourcePath, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInNewPrefabResource(
            string resourcePath, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabResourceBindingFinalizer(
                BindInfo, gameObjectInfo, resourcePath,
                (contractType, instantiator) => new GetFromPrefabComponentProvider(contractType, instantiator, true));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInNewPrefabResource(string resourcePath)
        {
            return FromComponentsInNewPrefabResource(resourcePath, new GameObjectCreationParameters());
        }

        internal NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInNewPrefabResource(
            string resourcePath, GameObjectCreationParameters gameObjectInfo)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new PrefabResourceBindingFinalizer(
                BindInfo, gameObjectInfo, resourcePath,
                (contractType, instantiator) => new GetFromPrefabComponentProvider(contractType, instantiator, false));

            return new NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo, gameObjectInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewScriptableObject(ScriptableObject resource)
        {
            return FromScriptableObjectInternal(resource, true);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromScriptableObject(ScriptableObject resource)
        {
            return FromScriptableObjectInternal(resource, false);
        }

        ScopeConcreteIdArgConditionCopyNonLazyBinder FromScriptableObjectInternal(
            ScriptableObject resource, bool createNew)
        {
            BindingUtil.AssertIsInterfaceOrScriptableObject(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new ScriptableObjectInstanceProvider(
                    resource, type, container, BindInfo.Arguments, createNew,
                    BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromNewScriptableObjectResource(string resourcePath)
        {
            return FromScriptableObjectResourceInternal(resourcePath, true);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromScriptableObjectResource(string resourcePath)
        {
            return FromScriptableObjectResourceInternal(resourcePath, false);
        }

        ScopeConcreteIdArgConditionCopyNonLazyBinder FromScriptableObjectResourceInternal(
            string resourcePath, bool createNew)
        {
            BindingUtil.AssertIsValidResourcePath(resourcePath);
            BindingUtil.AssertIsInterfaceOrScriptableObject(AllParentTypes);

            BindInfo.RequireExplicitScope = true;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new ScriptableObjectResourceProvider(
                    resourcePath, type, container, BindInfo.Arguments, createNew,
                    BindInfo.ConcreteIdentifier, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResource(string resourcePath)
        {
            BindingUtil.AssertDerivesFromUnityObject(ConcreteTypes);

            BindInfo.RequireExplicitScope = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (_, type) => new ResourceProvider(resourcePath, type, true));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResources(string resourcePath)
        {
            BindingUtil.AssertDerivesFromUnityObject(ConcreteTypes);

            BindInfo.RequireExplicitScope = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (_, type) => new ResourceProvider(resourcePath, type, false));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInChildren(
            bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentInChildren to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        var match = monoBehaviour.GetComponentInChildren(concreteType, includeInactive);

                        if (match == null)
                        {
                            Assert.That(ctx.Optional,
                                "Could not find any component with type '{0}' through FromComponentInChildren binding", concreteType);
                            return Enumerable.Empty<object>();
                        }

                        return new object[] { match };
                    },
                    container));

            return this;
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInChildrenBase(
            bool excludeSelf, Func<Component, bool> predicate, bool includeInactive)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentsInChildren to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        var res = monoBehaviour.GetComponentsInChildren(concreteType, includeInactive)
                            .Where(x => !ReferenceEquals(x, ctx.ObjectInstance));

                        if (excludeSelf)
                        {
                            res = res.Where(x => x.gameObject != monoBehaviour.gameObject);
                        }

                        if (predicate != null)
                        {
                            res = res.Where(predicate);
                        }

                        return res.Cast<object>();
                    },
                    container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInParents(
            bool excludeSelf = false, bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentSibling to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        var matches = monoBehaviour.GetComponentsInParent(concreteType, includeInactive)
                            .Where(x => !ReferenceEquals(x, ctx.ObjectInstance));

                        if (excludeSelf)
                        {
                            matches = matches.Where(x => x.gameObject != monoBehaviour.gameObject);
                        }

                        var match = matches.FirstOrDefault();

                        if (match == null)
                        {
                            Assert.That(ctx.Optional,
                                "Could not find any component with type '{0}' through FromComponentInParents binding", concreteType);

                            return Enumerable.Empty<object>();
                        }

                        return new object[] { match };
                    },
                    container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInParents(
            bool excludeSelf = false, bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentSibling to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        var res = monoBehaviour.GetComponentsInParent(concreteType, includeInactive)
                            .Where(x => !ReferenceEquals(x, ctx.ObjectInstance));

                        if (excludeSelf)
                        {
                            res = res.Where(x => x.gameObject != monoBehaviour.gameObject);
                        }

                        return res.Cast<object>();
                    },
                    container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentSibling()
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentSibling to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        var match = monoBehaviour.GetComponent(concreteType);

                        if (match == null)
                        {
                            Assert.That(ctx.Optional,
                                "Could not find any component with type '{0}' through FromComponentSibling binding", concreteType);
                            return Enumerable.Empty<object>();
                        }

                        return new object[] { match };
                    },
                    container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsSibling()
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = false;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        Assert.That(ctx.ObjectType.DerivesFromOrEqual<MonoBehaviour>(),
                            "Cannot use FromComponentSibling to inject data into non monobehaviours!");

                        Assert.IsNotNull(ctx.ObjectInstance);

                        var monoBehaviour = (MonoBehaviour)ctx.ObjectInstance;

                        return monoBehaviour.GetComponents(concreteType)
                            .Where(x => !ReferenceEquals(x, monoBehaviour)).Cast<object>();
                    },
                    container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentInHierarchy(
            bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            // Since this is a pretty heavy operation, let's require an explicit scope
            // Most of the time they should use AsCached or AsSingle
            BindInfo.RequireExplicitScope = true;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        var match = container.Resolve<Context>().GetRootGameObjects()
                            .Select(x => x.GetComponentInChildren(concreteType, includeInactive))
                            .Where(x => x != null && !ReferenceEquals(x, ctx.ObjectInstance)).FirstOrDefault();

                        if (match == null)
                        {
                            Assert.That(ctx.Optional,
                                "Could not find any component with type '{0}' through FromComponentInHierarchy binding", concreteType);
                            return Enumerable.Empty<object>();
                        }

                        return new object[] { match };
                    },
                    container));

            return this;
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInHierarchyBase(
            Func<Component, bool> predicate = null, bool includeInactive = true)
        {
            BindingUtil.AssertIsInterfaceOrComponent(AllParentTypes);

            BindInfo.RequireExplicitScope = true;

            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;

            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, concreteType) => new MethodMultipleProviderUntyped(ctx =>
                    {
                        var res = container.Resolve<Context>().GetRootGameObjects()
                            .SelectMany(x => x.GetComponentsInChildren(concreteType, includeInactive))
                            .Where(x => !ReferenceEquals(x, ctx.ObjectInstance));

                        if (predicate != null)
                        {
                            res = res.Where(predicate);
                        }

                        return res.Cast<object>();
                    },
                    container));

            return this;
        }
#endif

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodUntyped(Func<InjectContext, object> method)
        {
            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new MethodProviderUntyped(method, container));

            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodMultipleUntyped(Func<InjectContext, IEnumerable<object>> method)
        {
            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new MethodMultipleProviderUntyped(method, container));

            return this;
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodBase<TConcrete>(Func<InjectContext, TConcrete> method)
        {
            BindingUtil.AssertIsDerivedFromTypes(typeof(TConcrete), AllParentTypes);

            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new MethodProvider<TConcrete>(method, container));

            return this;
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodMultipleBase<TConcrete>(Func<InjectContext, IEnumerable<TConcrete>> method)
        {
            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new MethodProviderMultiple<TConcrete>(method, container));

            return this;
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetterBase<TObj, TResult>(
            object identifier, Func<TObj, TResult> method, InjectSources source, bool matchMultiple)
        {
            BindingUtil.AssertIsDerivedFromTypes(typeof(TResult), AllParentTypes);

            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new GetterProvider<TObj, TResult>(identifier, method, container, source, matchMultiple));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }

        protected ScopeConcreteIdArgConditionCopyNonLazyBinder FromInstanceBase(object instance)
        {
            BindingUtil.AssertInstanceDerivesFromOrEqual(instance, AllParentTypes);

            BindInfo.RequireExplicitScope = false;
            // Don't know how it's created so can't assume here that it violates AsSingle
            BindInfo.MarkAsCreationBinding = false;
            SubFinalizer = new ScopableBindingFinalizer(
                BindInfo,
                (container, type) => new InstanceProvider(type, instance, container, BindInfo.InstantiatedCallback));

            return new ScopeConcreteIdArgConditionCopyNonLazyBinder(BindInfo);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 1bfe8c7cab3320b4a818fbb97098fb11
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinderGeneric.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;
using System.Linq;

#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    [NoReflectionBaking]
    public class FromBinderGeneric<TContract> : FromBinder
    {
        public FromBinderGeneric(
            DiContainer bindContainer,
            BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
            BindingUtil.AssertIsDerivedFromTypes(typeof(TContract), BindInfo.ContractTypes);
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromFactory<TFactory>()
            where TFactory : IFactory<TContract>
        {
            return FromIFactory(x => x.To<TFactory>().AsCached());
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromIFactory(
            Action<ConcreteBinderGeneric<IFactory<TContract>>> factoryBindGenerator)
        {
            return FromIFactoryBase<TContract>(factoryBindGenerator);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethod(Func<TContract> method)
        {
            return FromMethodBase<TContract>(ctx => method());
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethod(Func<InjectContext, TContract> method)
        {
            return FromMethodBase<TContract>(method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodMultiple(Func<InjectContext, IEnumerable<TContract>> method)
        {
            BindingUtil.AssertIsDerivedFromTypes(typeof(TContract), AllParentTypes);
            return FromMethodMultipleBase<TContract>(method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj>(Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj>(null, method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj>(object identifier, Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj>(identifier, method, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj>(object identifier, Func<TObj, TContract> method, InjectSources source)
        {
            return FromResolveGetterBase<TObj, TContract>(identifier, method, source, false);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj>(Func<TObj, TContract> method)
        {
            return FromResolveAllGetter<TObj>(null, method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj>(object identifier, Func<TObj, TContract> method)
        {
            return FromResolveAllGetter<TObj>(identifier, method, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj>(object identifier, Func<TObj, TContract> method, InjectSources source)
        {
            return FromResolveGetterBase<TObj, TContract>(identifier, method, source, true);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromInstance(TContract instance)
        {
            return FromInstanceBase(instance);
        }

#if !NOT_UNITY3D

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInChildren(
            Func<TContract, bool> predicate, bool includeInactive = true)
        {
            return FromComponentsInChildren(false, predicate, includeInactive);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInChildren(
            bool excludeSelf = false, Func<TContract, bool> predicate = null, bool includeInactive = true)
        {
            Func<Component, bool> subPredicate;

            if (predicate != null)
            {
                subPredicate = component => predicate((TContract)(object)component);
            }
            else
            {
                subPredicate = null;
            }

            return FromComponentsInChildrenBase(
                excludeSelf, subPredicate, includeInactive);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInHierarchy(
            Func<TContract, bool> predicate = null, bool includeInactive = true)
        {
            Func<Component, bool> subPredicate;

            if (predicate != null)
            {
                subPredicate = component => predicate((TContract)(object)component);
            }
            else
            {
                subPredicate = null;
            }

            return FromComponentsInHierarchyBase(subPredicate, includeInactive);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinderGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: 97eaa55248b4c824a887df4db7cf888d
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinderNonGeneric.cs
================================================
using System;
using System.Collections.Generic;

#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    [NoReflectionBaking]
    public class FromBinderNonGeneric : FromBinder
    {
        public FromBinderNonGeneric(
            DiContainer bindContainer, BindInfo bindInfo,
            BindStatement bindStatement)
            : base(bindContainer, bindInfo, bindStatement)
        {
        }

        // Shortcut for FromIFactory and also for backwards compatibility
        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromFactory<TConcrete, TFactory>()
            where TFactory : IFactory<TConcrete>
        {
            return FromIFactory<TConcrete>(x => x.To<TFactory>().AsCached());
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromIFactory<TContract>(
            Action<ConcreteBinderGeneric<IFactory<TContract>>> factoryBindGenerator)
        {
            return FromIFactoryBase<TContract>(factoryBindGenerator);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethod<TConcrete>(Func<InjectContext, TConcrete> method)
        {
            return FromMethodBase<TConcrete>(method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromMethodMultiple<TConcrete>(Func<InjectContext, IEnumerable<TConcrete>> method)
        {
            BindingUtil.AssertIsDerivedFromTypes(typeof(TConcrete), AllParentTypes);
            return FromMethodMultipleBase<TConcrete>(method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj, TContract>(Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj, TContract>(null, method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj, TContract>(object identifier, Func<TObj, TContract> method)
        {
            return FromResolveGetter<TObj, TContract>(identifier, method, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveGetter<TObj, TContract>(object identifier, Func<TObj, TContract> method, InjectSources source)
        {
            return FromResolveGetterBase<TObj, TContract>(identifier, method, source, false);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj, TContract>(Func<TObj, TContract> method)
        {
            return FromResolveAllGetter<TObj, TContract>(null, method);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj, TContract>(object identifier, Func<TObj, TContract> method)
        {
            return FromResolveAllGetter<TObj, TContract>(identifier, method, InjectSources.Any);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromResolveAllGetter<TObj, TContract>(object identifier, Func<TObj, TContract> method, InjectSources source)
        {
            return FromResolveGetterBase<TObj, TContract>(identifier, method, source, true);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromInstance(object instance)
        {
            return FromInstanceBase(instance);
        }

#if !NOT_UNITY3D

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInChildren(
            Func<Component, bool> predicate, bool includeInactive = true)
        {
            return FromComponentsInChildren(false, predicate, includeInactive);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInChildren(
            bool excludeSelf = false, Func<Component, bool> predicate = null, bool includeInactive = true)
        {
            return FromComponentsInChildrenBase(excludeSelf, predicate, includeInactive);
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder FromComponentsInHierarchy(
            Func<Component, bool> predicate = null, bool includeInactive = true)
        {
            return FromComponentsInHierarchyBase(predicate, includeInactive);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/FromBinders/FromBinderNonGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: e54c591a4175efc4688be675528600c1
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/GameObject/NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
#if !NOT_UNITY3D

namespace Zenject
{
    [NoReflectionBaking]
    public class NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder : TransformScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder(
            BindInfo bindInfo,
            GameObjectCreationParameters gameObjectInfo)
            : base(bindInfo, gameObjectInfo)
        {
        }

        public TransformScopeConcreteIdArgConditionCopyNonLazyBinder WithGameObjectName(string gameObjectName)
        {
            GameObjectInfo.Name = gameObjectName;
            return this;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/GameObject/NameTransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: 74c9bb72aa7484d49a39760d2246f1a3
timeCreated: 1523257673
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/GameObject/TransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs
================================================
#if !NOT_UNITY3D

using System;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class TransformScopeConcreteIdArgConditionCopyNonLazyBinder : ScopeConcreteIdArgConditionCopyNonLazyBinder
    {
        public TransformScopeConcreteIdArgConditionCopyNonLazyBinder(
            BindInfo bindInfo,
            GameObjectCreationParameters gameObjectInfo)
            : base(bindInfo)
        {
            GameObjectInfo = gameObjectInfo;
        }

        protected GameObjectCreationParameters GameObjectInfo
        {
            get;
            private set;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder UnderTransform(Transform parent)
        {
            GameObjectInfo.ParentTransform = parent;
            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder UnderTransform(Func<InjectContext, Transform> parentGetter)
        {
            GameObjectInfo.ParentTransformGetter = parentGetter;
            return this;
        }

        public ScopeConcreteIdArgConditionCopyNonLazyBinder UnderTransformGroup(string transformGroupname)
        {
            GameObjectInfo.GroupName = transformGroupname;
            return this;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Binders/GameObject/TransformScopeConcreteIdArgConditionCopyNonLazyBinder.cs.meta
================================================
fileFormatVersion: 2
guid: d6441d2557329b14b8a80a6d3c490e9b
timeCreated: 1523257674
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/BindInfo.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Zenject.Internal;

namespace Zenject
{
    public enum ScopeTypes
    {
        Unset,
        Transient,
        Singleton
    }

    public enum ToChoices
    {
        Self,
        Concrete
    }

    public enum InvalidBindResponses
    {
        Assert,
        Skip
    }

    public enum BindingInheritanceMethods
    {
        None,
        CopyIntoAll,
        CopyDirectOnly,
        MoveIntoAll,
        MoveDirectOnly
    }

    [NoReflectionBaking]
    public class BindInfo : IDisposable
    {
        public bool MarkAsCreationBinding;
        public bool MarkAsUniqueSingleton;
        public object ConcreteIdentifier;
        public bool SaveProvider;
        public bool OnlyBindIfNotBound;
        public bool RequireExplicitScope;
        public object Identifier;
        public readonly List<Type> ContractTypes;
        public BindingInheritanceMethods BindingInheritanceMethod;
        public InvalidBindResponses InvalidBindResponse;
        public bool NonLazy;
        public BindingCondition Condition;
        public ToChoices ToChoice;
        public string ContextInfo;
        public readonly List<Type> ToTypes; // Only relevant with ToChoices.Concrete
        public ScopeTypes Scope;
        public readonly List<TypeValuePair> Arguments;
        public Action<InjectContext, object> InstantiatedCallback;

        public BindInfo()
        {
            ContractTypes = new List<Type>();
            ToTypes = new List<Type>();
            Arguments = new List<TypeValuePair>();

            Reset();
        }

        public void Dispose()
        {
            ZenPools.DespawnBindInfo(this);
        }

        [Conditional("UNITY_EDITOR")]
        public void SetContextInfo(string contextInfo)
        {
            ContextInfo = contextInfo;
        }

        public void Reset()
        {
            MarkAsCreationBinding = true;
            MarkAsUniqueSingleton = false;
            ConcreteIdentifier = null;
            SaveProvider = false;
            OnlyBindIfNotBound = false;
            RequireExplicitScope = false;
            Identifier = null;
            ContractTypes.Clear();
            BindingInheritanceMethod = BindingInheritanceMethods.None;
            InvalidBindResponse = InvalidBindResponses.Assert;
            NonLazy = false;
            Condition = null;
            ToChoice = ToChoices.Self;
            ContextInfo = null;
            ToTypes.Clear();
            Scope = ScopeTypes.Unset;
            Arguments.Clear();
            InstantiatedCallback = null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/BindInfo.cs.meta
================================================
fileFormatVersion: 2
guid: 647e28e377c50e549b443131ce6163fc
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/BindStatement.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class BindStatement : IDisposable
    {
        readonly List<IDisposable> _disposables;
        IBindingFinalizer _bindingFinalizer;

        public BindStatement()
        {
            _disposables = new List<IDisposable>();
            Reset();
        }

        public BindingInheritanceMethods BindingInheritanceMethod
        {
            get
            {
                AssertHasFinalizer();
                return _bindingFinalizer.BindingInheritanceMethod;
            }
        }

        public bool HasFinalizer
        {
            get { return _bindingFinalizer != null; }
        }

        public void SetFinalizer(IBindingFinalizer bindingFinalizer)
        {
            _bindingFinalizer = bindingFinalizer;
        }

        void AssertHasFinalizer()
        {
            if (_bindingFinalizer == null)
            {
                throw Assert.CreateException(
                    "Unfinished binding!  Some required information was left unspecified.");
            }
        }

        public void AddDisposable(IDisposable disposable)
        {
            _disposables.Add(disposable);
        }

        public BindInfo SpawnBindInfo()
        {
            var bindInfo = ZenPools.SpawnBindInfo();
            AddDisposable(bindInfo);
            return bindInfo;
        }

        public void FinalizeBinding(DiContainer container)
        {
            AssertHasFinalizer();
            _bindingFinalizer.FinalizeBinding(container);
        }

        public void Reset()
        {
            _bindingFinalizer = null;

            for (int i = 0; i < _disposables.Count; i++)
            {
                _disposables[i].Dispose();
            }

            _disposables.Clear();
        }

        public void Dispose()
        {
            ZenPools.DespawnStatement(this);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/BindStatement.cs.meta
================================================
fileFormatVersion: 2
guid: 63a8f1068d150404f820c8cc9057dbc8
timeCreated: 1535868299
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/FactoryBindInfo.cs
================================================
using System;
using System.Collections.Generic;

namespace Zenject
{
    [NoReflectionBaking]
    public class FactoryBindInfo
    {
        public FactoryBindInfo(Type factoryType)
        {
            FactoryType = factoryType;
            Arguments = new List<TypeValuePair>();
        }

        public Type FactoryType
        {
            get; private set;
        }

        public Func<DiContainer, IProvider> ProviderFunc
        {
            get; set;
        }

        public List<TypeValuePair> Arguments
        {
            get;
            set;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/FactoryBindInfo.cs.meta
================================================
fileFormatVersion: 2
guid: e69b2b4566e331e44a9f92e4e309816a
timeCreated: 1484520532
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/GameObjectCreationParameters.cs
================================================
#if !NOT_UNITY3D

using System;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class GameObjectCreationParameters
    {
        public string Name
        {
            get;
            set;
        }

        public string GroupName
        {
            get;
            set;
        }

        public Transform ParentTransform
        {
            get;
            set;
        }

        public Func<InjectContext, Transform> ParentTransformGetter
        {
            get;
            set;
        }

        public Vector3? Position
        {
            get;
            set;
        }

        public Quaternion? Rotation
        {
            get;
            set;
        }

        public static readonly GameObjectCreationParameters Default = new GameObjectCreationParameters();

        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + (Name == null ? 0 : Name.GetHashCode());
                hash = hash * 29 + (GroupName == null ? 0 : GroupName.GetHashCode());
                hash = hash * 29 + (ParentTransform == null ? 0 : ParentTransform.GetHashCode());
                hash = hash * 29 + (ParentTransformGetter == null ? 0 : ParentTransformGetter.GetHashCode());
                hash = hash * 29 + (!Position.HasValue ? 0 : Position.Value.GetHashCode());
                hash = hash * 29 + (!Rotation.HasValue ? 0 : Rotation.Value.GetHashCode());
                return hash;
            }
        }

        public override bool Equals(object other)
        {
            if (other is GameObjectCreationParameters)
            {
                GameObjectCreationParameters otherId = (GameObjectCreationParameters)other;
                return otherId == this;
            }

            return false;
        }

        public bool Equals(GameObjectCreationParameters that)
        {
            return this == that;
        }

        public static bool operator ==(GameObjectCreationParameters left, GameObjectCreationParameters right)
        {
            return Equals(left.Name, right.Name)
                && Equals(left.GroupName, right.GroupName);
        }

        public static bool operator !=(GameObjectCreationParameters left, GameObjectCreationParameters right)
        {
            return !left.Equals(right);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/GameObjectCreationParameters.cs.meta
================================================
fileFormatVersion: 2
guid: 2b708f7f76ea5574e9a39b60cc5a8238
timeCreated: 1477163090
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/MemoryPoolBindInfo.cs
================================================
namespace Zenject
{
    public enum PoolExpandMethods
    {
        OneAtATime,
        Double,
        Disabled
    }

    [NoReflectionBaking]
    public class MemoryPoolBindInfo
    {
        public MemoryPoolBindInfo()
        {
            ExpandMethod = PoolExpandMethods.OneAtATime;
            MaxSize = int.MaxValue;
        }

        public PoolExpandMethods ExpandMethod
        {
            get; set;
        }

        public int InitialSize
        {
            get; set;
        }

        public int MaxSize
        {
            get; set;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/BindInfo/MemoryPoolBindInfo.cs.meta
================================================
fileFormatVersion: 2
guid: 3f8798fbf64bca945a7be04615c08c4f
timeCreated: 1485711462
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/IBindingFinalizer.cs
================================================
namespace Zenject
{
    public interface IBindingFinalizer
    {
        BindingInheritanceMethods BindingInheritanceMethod
        {
            get;
        }

        void FinalizeBinding(DiContainer container);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/IBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: d0c24b30b6678884db62f15947ec943c
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/NullBindingFinalizer.cs
================================================
namespace Zenject
{
    [NoReflectionBaking]
    public class NullBindingFinalizer : IBindingFinalizer
    {
        public BindingInheritanceMethods BindingInheritanceMethod
        {
            get { return BindingInheritanceMethods.None; }
        }

        public void FinalizeBinding(DiContainer container)
        {
            // Do nothing
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/NullBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: 6b41a20eb0faa1041bf6aa0bfcc76064
timeCreated: 1480010956
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/PrefabBindingFinalizer.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabBindingFinalizer : ProviderBindingFinalizer
    {
        readonly GameObjectCreationParameters _gameObjectBindInfo;
        readonly UnityEngine.Object _prefab;
        readonly Func<Type, IPrefabInstantiator, IProvider> _providerFactory;

        public PrefabBindingFinalizer(
            BindInfo bindInfo,
            GameObjectCreationParameters gameObjectBindInfo,
            UnityEngine.Object prefab, Func<Type, IPrefabInstantiator, IProvider> providerFactory)
            : base(bindInfo)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
            _prefab = prefab;
            _providerFactory = providerFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);
                FinalizeBindingSelf(container);
            }
            else
            {
                FinalizeBindingConcrete(container, BindInfo.ToTypes);
            }
        }

        void FinalizeBindingConcrete(DiContainer container, List<Type> concreteTypes)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                            _providerFactory(
                                concreteType,
                                new PrefabInstantiator(
                                    container,
                                    _gameObjectBindInfo,
                                    concreteType,
                                    concreteTypes,
                                    BindInfo.Arguments,
                                    new PrefabProvider(_prefab),
                                    BindInfo.InstantiatedCallback)));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var argumentTarget = concreteTypes.OnlyOrDefault();

                    if (argumentTarget == null)
                    {
                        Assert.That(BindInfo.Arguments.IsEmpty(),
                            "Cannot provide arguments to prefab instantiator when using more than one concrete type");
                    }

                    var prefabCreator = new PrefabInstantiatorCached(
                        new PrefabInstantiator(
                            container,
                            _gameObjectBindInfo,
                            argumentTarget,
                            concreteTypes,
                            BindInfo.Arguments,
                            new PrefabProvider(_prefab),
                            BindInfo.InstantiatedCallback));

                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) => BindingUtil.CreateCachedProvider(
                            _providerFactory(concreteType, prefabCreator)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        void FinalizeBindingSelf(DiContainer container)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            _providerFactory(
                                contractType,
                                new PrefabInstantiator(
                                    container,
                                    _gameObjectBindInfo,
                                    contractType,
                                    BindInfo.ContractTypes,
                                    BindInfo.Arguments,
                                    new PrefabProvider(_prefab),
                                    BindInfo.InstantiatedCallback)));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var argumentTarget = BindInfo.ContractTypes.OnlyOrDefault();

                    if (argumentTarget == null)
                    {
                        Assert.That(BindInfo.Arguments.IsEmpty(),
                            "Cannot provide arguments to prefab instantiator when using more than one concrete type");
                    }

                    var prefabCreator = new PrefabInstantiatorCached(
                        new PrefabInstantiator(
                            container,
                            _gameObjectBindInfo,
                            argumentTarget,
                            BindInfo.ContractTypes,
                            BindInfo.Arguments,
                            new PrefabProvider(_prefab),
                            BindInfo.InstantiatedCallback));

                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            BindingUtil.CreateCachedProvider(
                                _providerFactory(contractType, prefabCreator)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/PrefabBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: 10487121a4674d74884ee65e70762e35
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/PrefabResourceBindingFinalizer.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabResourceBindingFinalizer : ProviderBindingFinalizer
    {
        readonly GameObjectCreationParameters _gameObjectBindInfo;
        readonly string _resourcePath;
        readonly Func<Type, IPrefabInstantiator, IProvider> _providerFactory;

        public PrefabResourceBindingFinalizer(
            BindInfo bindInfo,
            GameObjectCreationParameters gameObjectBindInfo,
            string resourcePath, Func<Type, IPrefabInstantiator, IProvider> providerFactory)
            : base(bindInfo)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
            _resourcePath = resourcePath;
            _providerFactory = providerFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);
                FinalizeBindingSelf(container);
            }
            else
            {
                FinalizeBindingConcrete(container, BindInfo.ToTypes);
            }
        }

        void FinalizeBindingConcrete(DiContainer container, List<Type> concreteTypes)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                            _providerFactory(
                                concreteType,
                                new PrefabInstantiator(
                                    container,
                                    _gameObjectBindInfo,
                                    concreteType,
                                    concreteTypes,
                                    BindInfo.Arguments,
                                    new PrefabProviderResource(_resourcePath),
                                    BindInfo.InstantiatedCallback)));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var argumentTarget = concreteTypes.OnlyOrDefault();

                    if (argumentTarget == null)
                    {
                        Assert.That(BindInfo.Arguments.IsEmpty(),
                            "Cannot provide arguments to prefab instantiator when using more than one concrete type");
                    }

                    var prefabCreator = new PrefabInstantiatorCached(
                        new PrefabInstantiator(
                            container,
                            _gameObjectBindInfo,
                            argumentTarget,
                            concreteTypes,
                            BindInfo.Arguments,
                            new PrefabProviderResource(_resourcePath),
                            BindInfo.InstantiatedCallback));

                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) => BindingUtil.CreateCachedProvider(
                            _providerFactory(concreteType, prefabCreator)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        void FinalizeBindingSelf(DiContainer container)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            _providerFactory(
                                contractType,
                                new PrefabInstantiator(
                                    container,
                                    _gameObjectBindInfo,
                                    contractType,
                                    BindInfo.ContractTypes,
                                    BindInfo.Arguments,
                                    new PrefabProviderResource(_resourcePath),
                                    BindInfo.InstantiatedCallback)));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var argumentTarget = BindInfo.ContractTypes.OnlyOrDefault();

                    if (argumentTarget == null)
                    {
                        Assert.That(BindInfo.Arguments.IsEmpty(),
                            "Cannot provide arguments to prefab instantiator when using more than one concrete type");
                    }

                    var prefabCreator = new PrefabInstantiatorCached(
                        new PrefabInstantiator(
                            container,
                            _gameObjectBindInfo,
                            argumentTarget,
                            BindInfo.ContractTypes,
                            BindInfo.Arguments,
                            new PrefabProviderResource(_resourcePath),
                            BindInfo.InstantiatedCallback));

                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            BindingUtil.CreateCachedProvider(
                                _providerFactory(contractType, prefabCreator)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/PrefabResourceBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: b851ccfb909f66c4587d694f6e37b279
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/ProviderBindingFinalizer.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class ProviderBindingFinalizer : IBindingFinalizer
    {
        public ProviderBindingFinalizer(BindInfo bindInfo)
        {
            BindInfo = bindInfo;
        }

        public BindingInheritanceMethods BindingInheritanceMethod
        {
            get { return BindInfo.BindingInheritanceMethod; }
        }

        protected BindInfo BindInfo
        {
            get;
            private set;
        }

        protected ScopeTypes GetScope()
        {
            if (BindInfo.Scope == ScopeTypes.Unset)
            {
                // If condition is set then it's probably fine to allow the default of transient
                Assert.That(!BindInfo.RequireExplicitScope || BindInfo.Condition != null,
                    "Scope must be set for the previous binding!  Please either specify AsTransient, AsCached, or AsSingle. Last binding: Contract: {0}, Identifier: {1} {2}",
                    BindInfo.ContractTypes.Select(x => x.PrettyName()).Join(", "), BindInfo.Identifier,
                    BindInfo.ContextInfo != null ? "Context: '{0}'".Fmt(BindInfo.ContextInfo) : "");
                return ScopeTypes.Transient;
            }

            return BindInfo.Scope;
        }

        public void FinalizeBinding(DiContainer container)
        {
            if (BindInfo.ContractTypes.Count == 0)
            {
                // We could assert her instead but it is nice when used with things like
                // BindInterfaces() (and there aren't any interfaces) to allow
                // interfaces to be added later
                return;
            }

            try
            {
                OnFinalizeBinding(container);
            }
            catch (Exception e)
            {
                throw Assert.CreateException(
                    e, "Error while finalizing previous binding! Contract: {0}, Identifier: {1} {2}",
                    BindInfo.ContractTypes.Select(x => x.PrettyName()).Join(", "), BindInfo.Identifier,
                    BindInfo.ContextInfo != null ? "Context: '{0}'".Fmt(BindInfo.ContextInfo) : "");
            }
        }

        protected abstract void OnFinalizeBinding(DiContainer container);

        protected void RegisterProvider<TContract>(
            DiContainer container, IProvider provider)
        {
            RegisterProvider(container, typeof(TContract), provider);
        }

        protected void RegisterProvider(
            DiContainer container, Type contractType, IProvider provider)
        {
            if (BindInfo.OnlyBindIfNotBound && container.HasBindingId(contractType, BindInfo.Identifier))
            {
                return;
            }

            container.RegisterProvider(
                new BindingId(contractType, BindInfo.Identifier),
                BindInfo.Condition,
                provider, BindInfo.NonLazy);

            if (contractType.IsValueType() && !(contractType.IsGenericType() && contractType.GetGenericTypeDefinition() == typeof(Nullable<>)))
            {
                var nullableType = typeof(Nullable<>).MakeGenericType(contractType);

                // Also bind to nullable primitives
                // this is useful so that we can have optional primitive dependencies
                container.RegisterProvider(
                    new BindingId(nullableType, BindInfo.Identifier),
                    BindInfo.Condition,
                    provider, BindInfo.NonLazy);
            }
        }

        protected void RegisterProviderPerContract(
            DiContainer container, Func<DiContainer, Type, IProvider> providerFunc)
        {
            foreach (var contractType in BindInfo.ContractTypes)
            {
                var provider = providerFunc(container, contractType);

                if (BindInfo.MarkAsUniqueSingleton)
                {
                    container.SingletonMarkRegistry.MarkSingleton(contractType);
                }
                else if (BindInfo.MarkAsCreationBinding)
                {
                    container.SingletonMarkRegistry.MarkNonSingleton(contractType);
                }

                RegisterProvider(container, contractType, provider);
            }
        }

        protected void RegisterProviderForAllContracts(
            DiContainer container, IProvider provider)
        {
            foreach (var contractType in BindInfo.ContractTypes)
            {
                if (BindInfo.MarkAsUniqueSingleton)
                {
                    container.SingletonMarkRegistry.MarkSingleton(contractType);
                }
                else if (BindInfo.MarkAsCreationBinding)
                {
                    container.SingletonMarkRegistry.MarkNonSingleton(contractType);
                }

                RegisterProvider(container, contractType, provider);
            }
        }

        protected void RegisterProvidersPerContractAndConcreteType(
            DiContainer container,
            List<Type> concreteTypes,
            Func<Type, Type, IProvider> providerFunc)
        {
            Assert.That(!BindInfo.ContractTypes.IsEmpty());
            Assert.That(!concreteTypes.IsEmpty());

            foreach (var contractType in BindInfo.ContractTypes)
            {
                foreach (var concreteType in concreteTypes)
                {
                    if (ValidateBindTypes(concreteType, contractType))
                    {
                        RegisterProvider(container, contractType, providerFunc(contractType, concreteType));
                    }
                }
            }
        }

        // Returns true if the bind should continue, false to skip
        bool ValidateBindTypes(Type concreteType, Type contractType)
        {
            bool isConcreteOpenGenericType = concreteType.IsOpenGenericType();
            bool isContractOpenGenericType = contractType.IsOpenGenericType();
            if (isConcreteOpenGenericType != isContractOpenGenericType)
            {
                return false;
            }

#if !(UNITY_WSA && ENABLE_DOTNET)
            // TODO: Is it possible to do this on WSA?

            if (isContractOpenGenericType)
            {
                Assert.That(isConcreteOpenGenericType);

                if (TypeExtensions.IsAssignableToGenericType(concreteType, contractType))
                {
                    return true;
                }
            }
            else if (concreteType.DerivesFromOrEqual(contractType))
            {
                return true;
            }
#else
            if (concreteType.DerivesFromOrEqual(contractType))
            {
                return true;
            }
#endif

            if (BindInfo.InvalidBindResponse == InvalidBindResponses.Assert)
            {
                throw Assert.CreateException(
                    "Expected type '{0}' to derive from or be equal to '{1}'", concreteType, contractType);
            }

            Assert.IsEqual(BindInfo.InvalidBindResponse, InvalidBindResponses.Skip);
            return false;
        }

        // Note that if multiple contract types are provided per concrete type,
        // it will re-use the same provider for each contract type
        // (each concrete type will have its own provider though)
        protected void RegisterProvidersForAllContractsPerConcreteType(
            DiContainer container,
            List<Type> concreteTypes,
            Func<DiContainer, Type, IProvider> providerFunc)
        {
            Assert.That(!BindInfo.ContractTypes.IsEmpty());
            Assert.That(!concreteTypes.IsEmpty());

            var providerMap = ZenPools.SpawnDictionary<Type, IProvider>();
            try
            {
                foreach (var concreteType in concreteTypes)
                {
                    var provider = providerFunc(container, concreteType);

                    providerMap[concreteType] = provider;

                    if (BindInfo.MarkAsUniqueSingleton)
                    {
                        container.SingletonMarkRegistry.MarkSingleton(concreteType);
                    }
                    else if (BindInfo.MarkAsCreationBinding)
                    {
                        container.SingletonMarkRegistry.MarkNonSingleton(concreteType);
                    }
                }

                foreach (var contractType in BindInfo.ContractTypes)
                {
                    foreach (var concreteType in concreteTypes)
                    {
                        if (ValidateBindTypes(concreteType, contractType))
                        {
                            RegisterProvider(container, contractType, providerMap[concreteType]);
                        }
                    }
                }
            }
            finally
            {
                ZenPools.DespawnDictionary(providerMap);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/ProviderBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: ee5cb643a9ee24c4fa00e62afc9ef599
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/ScopableBindingFinalizer.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ScopableBindingFinalizer : ProviderBindingFinalizer
    {
        readonly Func<DiContainer, Type, IProvider> _providerFactory;

        public ScopableBindingFinalizer(
            BindInfo bindInfo, Func<DiContainer, Type, IProvider> providerFactory)
            : base(bindInfo)
        {
            _providerFactory = providerFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);
                FinalizeBindingSelf(container);
            }
            else
            {
                FinalizeBindingConcrete(container, BindInfo.ToTypes);
            }
        }

        void FinalizeBindingConcrete(DiContainer container, List<Type> concreteTypes)
        {
            if (concreteTypes.Count == 0)
            {
                // This can be common when using convention based bindings
                return;
            }

            var scope = GetScope();
            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container, concreteTypes, _providerFactory);
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                            BindingUtil.CreateCachedProvider(
                                _providerFactory(container, concreteType)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        void FinalizeBindingSelf(DiContainer container)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProviderPerContract(container, _providerFactory);
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            BindingUtil.CreateCachedProvider(
                                _providerFactory(container, contractType)));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/ScopableBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: d2392181aaeca434cb15e2719d7567d6
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SingleProviderBindingFinalizer.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SingleProviderBindingFinalizer : ProviderBindingFinalizer
    {
        readonly Func<DiContainer, Type, IProvider> _providerFactory;

        public SingleProviderBindingFinalizer(
            BindInfo bindInfo, Func<DiContainer, Type, IProvider> providerFactory)
            : base(bindInfo)
        {
            _providerFactory = providerFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);

                RegisterProviderPerContract(container, _providerFactory);
            }
            else
            {
                // Empty sometimes when using convention based bindings
                if (!BindInfo.ToTypes.IsEmpty())
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container, BindInfo.ToTypes, _providerFactory);
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SingleProviderBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: deaa9a3ee9e42a8448bba948495b9225
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SubContainerBindingFinalizer.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerBindingFinalizer : ProviderBindingFinalizer
    {
        readonly object _subIdentifier;
        readonly bool _resolveAll;
        readonly Func<DiContainer, ISubContainerCreator> _creatorFactory;

        public SubContainerBindingFinalizer(
            BindInfo bindInfo, object subIdentifier,
            bool resolveAll, Func<DiContainer, ISubContainerCreator> creatorFactory)
            : base(bindInfo)
        {
            _subIdentifier = subIdentifier;
            _resolveAll = resolveAll;
            _creatorFactory = creatorFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);
                FinalizeBindingSelf(container);
            }
            else
            {
                FinalizeBindingConcrete(container, BindInfo.ToTypes);
            }
        }

        void FinalizeBindingConcrete(DiContainer container, List<Type> concreteTypes)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                            new SubContainerDependencyProvider(
                                concreteType, _subIdentifier, _creatorFactory(container), _resolveAll));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var containerCreator = new SubContainerCreatorCached(_creatorFactory(container));

                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                            new SubContainerDependencyProvider(
                                concreteType, _subIdentifier, containerCreator, _resolveAll));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        void FinalizeBindingSelf(DiContainer container)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProviderPerContract(
                        container,
                        (_, contractType) => new SubContainerDependencyProvider(
                            contractType, _subIdentifier, _creatorFactory(container), _resolveAll));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var containerCreator = new SubContainerCreatorCached(_creatorFactory(container));

                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                            new SubContainerDependencyProvider(
                                contractType, _subIdentifier, containerCreator, _resolveAll));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }
    }
}





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SubContainerBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: b263fb784fd4b8140b850ff4d68c7aad
timeCreated: 1535189470
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SubContainerPrefabBindingFinalizer.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerPrefabBindingFinalizer : ProviderBindingFinalizer
    {
        readonly object _subIdentifier;
        readonly bool _resolveAll;
        readonly Func<DiContainer, ISubContainerCreator> _subContainerCreatorFactory;

        public SubContainerPrefabBindingFinalizer(
            BindInfo bindInfo,
            object subIdentifier, bool resolveAll,
            Func<DiContainer, ISubContainerCreator> subContainerCreatorFactory)
            : base(bindInfo)
        {
            _subIdentifier = subIdentifier;
            _resolveAll = resolveAll;
            _subContainerCreatorFactory = subContainerCreatorFactory;
        }

        protected override void OnFinalizeBinding(DiContainer container)
        {
            if (BindInfo.ToChoice == ToChoices.Self)
            {
                Assert.IsEmpty(BindInfo.ToTypes);
                FinalizeBindingSelf(container);
            }
            else
            {
                FinalizeBindingConcrete(container, BindInfo.ToTypes);
            }
        }

        void FinalizeBindingConcrete(DiContainer container, List<Type> concreteTypes)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) => new SubContainerDependencyProvider(
                            concreteType, _subIdentifier,
                            _subContainerCreatorFactory(container), _resolveAll));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var containerCreator = new SubContainerCreatorCached(
                        _subContainerCreatorFactory(container));

                    RegisterProvidersForAllContractsPerConcreteType(
                        container,
                        concreteTypes,
                        (_, concreteType) =>
                        new SubContainerDependencyProvider(
                            concreteType, _subIdentifier, containerCreator, _resolveAll));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        void FinalizeBindingSelf(DiContainer container)
        {
            var scope = GetScope();

            switch (scope)
            {
                case ScopeTypes.Transient:
                {
                    RegisterProviderPerContract(
                        container,
                        (_, contractType) => new SubContainerDependencyProvider(
                            contractType, _subIdentifier,
                            _subContainerCreatorFactory(container), _resolveAll));
                    break;
                }
                case ScopeTypes.Singleton:
                {
                    var containerCreator = new SubContainerCreatorCached(
                        _subContainerCreatorFactory(container));

                    RegisterProviderPerContract(
                        container,
                        (_, contractType) =>
                        new SubContainerDependencyProvider(
                            contractType, _subIdentifier, containerCreator, _resolveAll));
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Binding/Finalizers/SubContainerPrefabBindingFinalizer.cs.meta
================================================
fileFormatVersion: 2
guid: da4cb0f689a9b074aa3d2f2da8b38015
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors.meta
================================================
fileFormatVersion: 2
guid: fbb1477b2e261944dad77cce5626aab0
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/EditorStaticInstaller.cs
================================================

namespace Zenject
{
    // Derive from this class, add [InitializeOnLoad], and then call Install
    // in a static constructor to add some editor time bindings
    // For example:
    //
    // [InitializeOnLoad]
    // public class FooInstaller : EditorStaticInstaller<FooInstaller>
    // {
    //     static FooInstaller()
    //     {
    //         Install();
    //     }
    //
    //     public override void InstallBindings()
    //     {
    //         Container.BindInstance("hello world");
    //     }
    // }
    //
    public abstract class EditorStaticInstaller<T> : InstallerBase
        where T : EditorStaticInstaller<T>
    {
        public static void Install()
        {
            StaticContext.Container.Instantiate<T>().InstallBindings();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/EditorStaticInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: fcb2e11e0ed56de48b0ba9b5e3ae10c9
timeCreated: 1486079412
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/EditorWindow.meta
================================================
fileFormatVersion: 2
guid: bd8d602c69b71714babee52a2d454aed
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ObjectGraphVisualizer.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ModestTree;

namespace Zenject
{
    // Responsibilities:
    // - Output a file specifying the full object graph for a given root dependency
    // - This file uses the DOT language with can be fed into GraphViz to generate an image
    // - http://www.graphviz.org/
    public static class ObjectGraphVisualizer
    {
        public static void OutputObjectGraphToFile(
            DiContainer container, string outputPath,
            IEnumerable<Type> externalIgnoreTypes, IEnumerable<Type> contractTypes)
        {
            // Output the entire object graph to file
            var graph = CalculateObjectGraph(container, contractTypes);

            var ignoreTypes = new List<Type>
            {
                typeof(DiContainer),
                typeof(InitializableManager)
            };

            ignoreTypes.AddRange(externalIgnoreTypes);

            var resultStr = "digraph { \n";

            resultStr += "rankdir=LR;\n";

            foreach (var entry in graph)
            {
                if (ShouldIgnoreType(entry.Key, ignoreTypes))
                {
                    continue;
                }

                foreach (var dependencyType in entry.Value)
                {
                    if (ShouldIgnoreType(dependencyType, ignoreTypes))
                    {
                        continue;
                    }

                    resultStr += GetFormattedTypeName(entry.Key) + " -> " + GetFormattedTypeName(dependencyType) + "; \n";
                }
            }

            resultStr += " }";

            File.WriteAllText(outputPath, resultStr);
        }

        static bool ShouldIgnoreType(Type type, List<Type> ignoreTypes)
        {
            return ignoreTypes.Contains(type);
        }

        static Dictionary<Type, List<Type>> CalculateObjectGraph(
            DiContainer container, IEnumerable<Type> contracts)
        {
            var map = new Dictionary<Type, List<Type>>();

            foreach (var contractType in contracts)
            {
                var depends = GetDependencies(container, contractType);

                if (depends.Any())
                {
                    map.Add(contractType, depends);
                }
            }

            return map;
        }

        static List<Type> GetDependencies(
            DiContainer container, Type type)
        {
            var dependencies = new List<Type>();

            foreach (var contractType in container.GetDependencyContracts(type))
            {
                List<Type> dependTypes;

                if (contractType.FullName.StartsWith("System.Collections.Generic.List"))
                {
                    var subTypes = contractType.GenericArguments();
                    Assert.IsEqual(subTypes.Length, 1);

                    var subType = subTypes[0];
                    dependTypes = container.ResolveTypeAll(subType);
                }
                else
                {
                    dependTypes = container.ResolveTypeAll(contractType);
                    Assert.That(dependTypes.Count <= 1);
                }

                foreach (var dependType in dependTypes)
                {
                    dependencies.Add(dependType);
                }
            }

            return dependencies;
        }

        static string GetFormattedTypeName(Type type)
        {
            var str = type.PrettyName();

            // GraphViz does not read names with <, >, or . characters so replace them
            str = str.Replace(">", "_");
            str = str.Replace("<", "_");
            str = str.Replace(".", "_");

            return str;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ObjectGraphVisualizer.cs.meta
================================================
fileFormatVersion: 2
guid: 29f47f2a06418244e8fcbe27db1a0eea
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/SceneParentLoading.meta
================================================
fileFormatVersion: 2
guid: 8b93c2560e2014a4893f387eb7690dbd
folderAsset: yes
timeCreated: 1520777708
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/UnityInspectorListEditor.cs
================================================
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

namespace Zenject
{
    public abstract class UnityInspectorListEditor : Editor
    {
        List<ReorderableList> _installersLists;
        List<SerializedProperty> _installersProperties;

        protected abstract string[] PropertyDisplayNames
        {
            get;
        }

        protected abstract string[] PropertyNames
        {
            get;
        }

        protected abstract string[] PropertyDescriptions
        {
            get;
        }

        public virtual void OnEnable()
        {
            _installersProperties = new List<SerializedProperty>();
            _installersLists = new List<ReorderableList>();

            var descriptions = PropertyDescriptions;
            var names = PropertyNames;
            var displayNames = PropertyDisplayNames;

            Assert.IsEqual(descriptions.Length, names.Length);

            var infos = Enumerable.Range(0, names.Length).Select(i => new { Name = names[i], DisplayName = displayNames[i], Description = descriptions[i] }).ToList();

            foreach (var info in infos)
            {
                var installersProperty = serializedObject.FindProperty(info.Name);
                _installersProperties.Add(installersProperty);

                ReorderableList installersList = new ReorderableList(serializedObject, installersProperty, true, true, true, true);
                _installersLists.Add(installersList);

                var closedName = info.DisplayName;
                var closedDesc = info.Description;

                installersList.drawHeaderCallback += rect =>
                {
                    GUI.Label(rect,
                    new GUIContent(closedName, closedDesc));
                };
                installersList.drawElementCallback += (rect, index, active, focused) =>
                {
                    rect.width -= 40;
                    rect.x += 20;
                    EditorGUI.PropertyField(rect, installersProperty.GetArrayElementAtIndex(index), GUIContent.none, true);
                };
            }
        }

        public sealed override void OnInspectorGUI()
        {
            serializedObject.Update();

            OnGui();

            serializedObject.ApplyModifiedProperties();
        }

        protected virtual void OnGui()
        {
            if (Application.isPlaying)
            {
                GUI.enabled = false;
            }

            foreach (var list in _installersLists)
            {
                list.DoLayoutList();
            }

            GUI.enabled = true;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/UnityInspectorListEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 06d16f2f9107265428d41710db4cbb14
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Zenject-Editor.asmdef
================================================
{
    "name": "Zenject-Editor",
    "references": [
        "Zenject"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": []
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Zenject-Editor.asmdef.meta
================================================
fileFormatVersion: 2
guid: d0acddb179989574c8355991596bd3e6
timeCreated: 1531030222
licenseType: Free
AssemblyDefinitionImporter:
  externalObjects: {}
  userData:
  assetBundleName:
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ZenMenuItems.cs
================================================
#if !NOT_UNITY3D

using System.IO;
using ModestTree;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace Zenject.Internal
{
    public static class ZenMenuItems
    {
        [MenuItem("Edit/Zenject/Validate Current Scenes #&v")]
        public static void ValidateCurrentScene()
        {
            ValidateCurrentSceneInternal();
        }

        [MenuItem("Edit/Zenject/Validate Then Run #&r")]
        public static void ValidateCurrentSceneThenRun()
        {
            if (ValidateCurrentSceneInternal())
            {
                EditorApplication.isPlaying = true;
            }
        }

        [MenuItem("Edit/Zenject/Help...")]
        public static void OpenDocumentation()
        {
            Application.OpenURL("https://github.com/svermeulen/zenject");
        }

        [MenuItem("GameObject/Zenject/Scene Context", false, 9)]
        public static void CreateSceneContext(MenuCommand menuCommand)
        {
            var root = new GameObject("SceneContext").AddComponent<SceneContext>();
            Selection.activeGameObject = root.gameObject;

            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
        }

        [MenuItem("GameObject/Zenject/Decorator Context", false, 9)]
        public static void CreateDecoratorContext(MenuCommand menuCommand)
        {
            var root = new GameObject("DecoratorContext").AddComponent<SceneDecoratorContext>();
            Selection.activeGameObject = root.gameObject;

            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
        }

        [MenuItem("GameObject/Zenject/Game Object Context", false, 9)]
        public static void CreateGameObjectContext(MenuCommand menuCommand)
        {
            var root = new GameObject("GameObjectContext").AddComponent<GameObjectContext>();
            Selection.activeGameObject = root.gameObject;

            EditorSceneManager.MarkSceneDirty(EditorSceneManager.GetActiveScene());
        }

        [MenuItem("Edit/Zenject/Create Project Context")]
        public static void CreateProjectContextInDefaultLocation()
        {
            var fullDirPath = Path.Combine(Application.dataPath, "Resources");

            if (!Directory.Exists(fullDirPath))
            {
                Directory.CreateDirectory(fullDirPath);
            }

            CreateProjectContextInternal("Assets/Resources");
        }

        [MenuItem("Assets/Create/Zenject/Default Scene Contract Config", false, 80)]
        public static void CreateDefaultSceneContractConfig()
        {
            var folderPath = ZenUnityEditorUtil.GetCurrentDirectoryAssetPathFromSelection();

            if (!folderPath.EndsWith("/Resources"))
            {
                EditorUtility.DisplayDialog("Error",
                    "ZenjectDefaultSceneContractConfig objects must be placed directly underneath a folder named 'Resources'.  Please try again.", "Ok");
                return;
            }

            var config = ScriptableObject.CreateInstance<DefaultSceneContractConfig>();

            ZenUnityEditorUtil.SaveScriptableObjectAsset(
                Path.Combine(folderPath, DefaultSceneContractConfig.ResourcePath + ".asset"), config);
        }

        [MenuItem("Assets/Create/Zenject/Scriptable Object Installer", false, 1)]
        public static void CreateScriptableObjectInstaller()
        {
            AddCSharpClassTemplate("Scriptable Object Installer", "UntitledInstaller",
                  "using UnityEngine;"
                + "\nusing Zenject;"
                + "\n"
                + "\n[CreateAssetMenu(fileName = \"CLASS_NAME\", menuName = \"Installers/CLASS_NAME\")]"
                + "\npublic class CLASS_NAME : ScriptableObjectInstaller<CLASS_NAME>"
                + "\n{"
                + "\n    public override void InstallBindings()"
                + "\n    {"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Mono Installer", false, 1)]
        public static void CreateMonoInstaller()
        {
            AddCSharpClassTemplate("Mono Installer", "UntitledInstaller",
                  "using UnityEngine;"
                + "\nusing Zenject;"
                + "\n"
                + "\npublic class CLASS_NAME : MonoInstaller"
                + "\n{"
                + "\n    public override void InstallBindings()"
                + "\n    {"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Installer", false, 1)]
        public static void CreateInstaller()
        {
            AddCSharpClassTemplate("Installer", "UntitledInstaller",
                  "using UnityEngine;"
                + "\nusing Zenject;"
                + "\n"
                + "\npublic class CLASS_NAME : Installer<CLASS_NAME>"
                + "\n{"
                + "\n    public override void InstallBindings()"
                + "\n    {"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Editor Window", false, 20)]
        public static void CreateEditorWindow()
        {
            AddCSharpClassTemplate("Editor Window", "UntitledEditorWindow",
                  "using UnityEngine;"
                + "\nusing UnityEditor;"
                + "\nusing Zenject;"
                + "\n"
                + "\npublic class CLASS_NAME : ZenjectEditorWindow"
                + "\n{"
                + "\n    [MenuItem(\"Window/CLASS_NAME\")]"
                + "\n    public static CLASS_NAME GetOrCreateWindow()"
                + "\n    {"
                + "\n        var window = EditorWindow.GetWindow<CLASS_NAME>();"
                + "\n        window.titleContent = new GUIContent(\"CLASS_NAME\");"
                + "\n        return window;"
                + "\n    }"
                + "\n"
                + "\n    public override void InstallBindings()"
                + "\n    {"
                + "\n        // TODO"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Project Context", false, 40)]
        public static void CreateProjectContext()
        {
            var absoluteDir = ZenUnityEditorUtil.TryGetSelectedFolderPathInProjectsTab();

            if (absoluteDir == null)
            {
                EditorUtility.DisplayDialog("Error",
                    "Could not find directory to place the '{0}.prefab' asset.  Please try again by right clicking in the desired folder within the projects pane."
                    .Fmt(ProjectContext.ProjectContextResourcePath), "Ok");
                return;
            }

            var parentFolderName = Path.GetFileName(absoluteDir);

            if (parentFolderName != "Resources")
            {
                EditorUtility.DisplayDialog("Error",
                    "'{0}.prefab' must be placed inside a directory named 'Resources'.  Please try again by right clicking within the Project pane in a valid Resources folder."
                    .Fmt(ProjectContext.ProjectContextResourcePath), "Ok");
                return;
            }

            CreateProjectContextInternal(absoluteDir);
        }

        static void CreateProjectContextInternal(string absoluteDir)
        {
            var assetPath = ZenUnityEditorUtil.ConvertFullAbsolutePathToAssetPath(absoluteDir);
            var prefabPath = (Path.Combine(assetPath, ProjectContext.ProjectContextResourcePath) + ".prefab").Replace("\\", "/");

            var gameObject = new GameObject();

            try
            {
                gameObject.AddComponent<ProjectContext>();

#if UNITY_2018_3_OR_NEWER
                var prefabObj = PrefabUtility.SaveAsPrefabAsset(gameObject, prefabPath);
#else
                var prefabObj = PrefabUtility.ReplacePrefab(gameObject, PrefabUtility.CreateEmptyPrefab(prefabPath));
#endif

                Selection.activeObject = prefabObj;
            }
            finally
            {
                GameObject.DestroyImmediate(gameObject);
            }

            Debug.Log("Created new ProjectContext at '{0}'".Fmt(prefabPath));
        }

        public static string AddCSharpClassTemplate(
            string friendlyName, string defaultFileName, string templateStr)
        {
            return AddCSharpClassTemplate(
                friendlyName, defaultFileName, templateStr, ZenUnityEditorUtil.GetCurrentDirectoryAssetPathFromSelection());
        }

        public static string AddCSharpClassTemplate(
            string friendlyName, string defaultFileName,
            string templateStr, string folderPath)
        {
            var absolutePath = EditorUtility.SaveFilePanel(
                "Choose name for " + friendlyName,
                folderPath,
                defaultFileName + ".cs",
                "cs");

            if (absolutePath == "")
            {
                // Dialog was cancelled
                return null;
            }

            if (!absolutePath.ToLower().EndsWith(".cs"))
            {
                absolutePath += ".cs";
            }

            var className = Path.GetFileNameWithoutExtension(absolutePath);
            File.WriteAllText(absolutePath, templateStr.Replace("CLASS_NAME", className));

            AssetDatabase.Refresh();

            var assetPath = ZenUnityEditorUtil.ConvertFullAbsolutePathToAssetPath(absolutePath);

            EditorUtility.FocusProjectWindow();
            Selection.activeObject = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(assetPath);

            return assetPath;
        }

        [MenuItem("Edit/Zenject/Validate All Active Scenes")]
        public static void ValidateAllActiveScenes()
        {
            ZenUnityEditorUtil.SaveThenRunPreserveSceneSetup(() =>
                {
                    var numValidated = ZenUnityEditorUtil.ValidateAllActiveScenes();
                    Log.Info("Validated all '{0}' active scenes successfully", numValidated);
                });
        }

        static bool ValidateCurrentSceneInternal()
        {
            return ZenUnityEditorUtil.SaveThenRunPreserveSceneSetup(() =>
                {
                    SceneParentAutomaticLoader.ValidateMultiSceneSetupAndLoadDefaultSceneParents();
                    ZenUnityEditorUtil.ValidateCurrentSceneSetup();
                    Log.Info("All scenes validated successfully");
                });
        }

        [MenuItem("Assets/Create/Zenject/Unit Test", false, 60)]
        public static void CreateUnitTest()
        {
            AddCSharpClassTemplate("Unit Test", "UntitledUnitTest",
                  "using Zenject;"
                + "\nusing NUnit.Framework;"
                + "\n"
                + "\n[TestFixture]"
                + "\npublic class CLASS_NAME : ZenjectUnitTestFixture"
                + "\n{"
                + "\n    [Test]"
                + "\n    public void RunTest1()"
                + "\n    {"
                + "\n        // TODO"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Integration Test", false, 60)]
        public static void CreateIntegrationTest()
        {
            AddCSharpClassTemplate("Integration Test", "UntitledIntegrationTest",
                  "using Zenject;"
                + "\nusing System.Collections;"
                + "\nusing UnityEngine.TestTools;"
                + "\n"
                + "\npublic class CLASS_NAME : ZenjectIntegrationTestFixture"
                + "\n{"
                + "\n    [UnityTest]"
                + "\n    public IEnumerator RunTest1()"
                + "\n    {"
                + "\n        // Setup initial state by creating game objects from scratch, loading prefabs/scenes, etc"
                + "\n"
                + "\n        PreInstall();"
                + "\n"
                + "\n        // Call Container.Bind methods"
                + "\n"
                + "\n        PostInstall();"
                + "\n"
                + "\n        // Add test assertions for expected state"
                + "\n        // Using Container.Resolve or [Inject] fields"
                + "\n        yield break;"
                + "\n    }"
                + "\n}");
        }

        [MenuItem("Assets/Create/Zenject/Scene Test", false, 60)]
        public static void CreateSceneTest()
        {
            AddCSharpClassTemplate("Scene Test Fixture", "UntitledSceneTest",
                  "using Zenject;"
                + "\nusing System.Collections;"
                + "\nusing UnityEngine;"
                + "\nusing UnityEngine.TestTools;"
                + "\n"
                + "\npublic class CLASS_NAME : SceneTestFixture"
                + "\n{"
                + "\n    [UnityTest]"
                + "\n    public IEnumerator TestScene()"
                + "\n    {"
                + "\n        yield return LoadScene(\"InsertSceneNameHere\");"
                + "\n"
                + "\n        // TODO: Add assertions here now that the scene has started"
                + "\n        // Or you can just uncomment to simply wait some time to make sure the scene plays without errors"
                + "\n        //yield return new WaitForSeconds(1.0f);"
                + "\n"
                + "\n        // Note that you can use SceneContainer.Resolve to look up objects that you need for assertions"
                + "\n    }"
                + "\n}");
        }
    }
}
#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ZenMenuItems.cs.meta
================================================
fileFormatVersion: 2
guid: d45338750ad0b4f4b90ed09091927b46
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ZenUnityEditorUtil.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ModestTree;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Zenject.Internal
{
    public static class ZenUnityEditorUtil
    {
        // Returns true if succeeds without errors
        public static bool SaveThenRunPreserveSceneSetup(Action action)
        {
            if (EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo())
            {
                var originalSceneSetup = EditorSceneManager.GetSceneManagerSetup();

                try
                {
                    action();
                    return true;
                }
                catch (Exception e)
                {
                    Log.ErrorException(e);
                    return false;
                }
                finally
                {
                    EditorSceneManager.RestoreSceneManagerSetup(originalSceneSetup);
                }
            }

            return false;
        }

        // Feel free to call this method from an editor script, or a unit test, etc.
        // An exception will be thrown if any validation errors are encountered
        public static void ValidateCurrentSceneSetup()
        {
            bool encounteredError = false;

            Application.LogCallback logCallback = (condition, stackTrace, type) =>
            {
                if (type == LogType.Error || type == LogType.Assert
                    || type == LogType.Exception)
                {
                    encounteredError = true;
                }
            };

            Application.logMessageReceived += logCallback;

            try
            {
                Assert.That(!ProjectContext.HasInstance);
                ProjectContext.ValidateOnNextRun = true;

                foreach (var sceneContext in GetAllSceneContexts())
                {
                    sceneContext.Validate();
                }
            }
            catch (Exception e)
            {
                Log.ErrorException(e);
                encounteredError = true;
            }
            finally
            {
                Application.logMessageReceived -= logCallback;
            }

            if (encounteredError)
            {
                throw new ZenjectException("Zenject Validation Failed!  See errors below for details.");
            }
        }

        // NOTE: An exception will be thrown if any validation errors are encountered
        // Returns the number of scenes that successfully validated
        public static int ValidateAllActiveScenes()
        {
            var activeScenePaths = EditorBuildSettings.scenes.Where(x => x.enabled)
                .Select(x => x.path).ToList();

            foreach (var scenePath in activeScenePaths)
            {
                EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Single);
                ValidateCurrentSceneSetup();
            }

            return activeScenePaths.Count;
        }

        // Don't use this
        public static void RunCurrentSceneSetup()
        {
            Assert.That(!ProjectContext.HasInstance);

            foreach (var sceneContext in GetAllSceneContexts())
            {
                try
                {
                    sceneContext.Run();
                }
                catch (Exception e)
                {
                    // Add a bit more context
                    throw new ZenjectException(
                        "Scene '{0}' Failed To Start!".Fmt(sceneContext.gameObject.scene.name), e);
                }
            }
        }

        public static SceneContext GetSceneContextForScene(Scene scene)
        {
            var sceneContext = TryGetSceneContextForScene(scene);

            Assert.IsNotNull(sceneContext,
                "Could not find scene context for scene '{0}'", scene.name);

            return sceneContext;
        }

        public static SceneContext TryGetSceneContextForScene(Scene scene)
        {
            if (!scene.isLoaded)
            {
                return null;
            }

            var sceneContexts = scene.GetRootGameObjects()
                .SelectMany(x => x.GetComponentsInChildren<SceneContext>()).ToList();

            if (sceneContexts.IsEmpty())
            {
                return null;
            }

            Assert.That(sceneContexts.Count == 1,
                "Found multiple SceneContexts in scene '{0}'.  Expected a maximum of one.", scene.name);

            return sceneContexts[0];
        }

        public static SceneDecoratorContext GetDecoratorContextForScene(Scene scene)
        {
            var decoratorContext = TryGetDecoratorContextForScene(scene);

            Assert.IsNotNull(decoratorContext,
                "Could not find decorator context for scene '{0}'", scene.name);

            return decoratorContext;
        }

        public static SceneDecoratorContext TryGetDecoratorContextForScene(Scene scene)
        {
            if (!scene.isLoaded)
            {
                return null;
            }

            var decoratorContexts = scene.GetRootGameObjects()
                .SelectMany(x => x.GetComponentsInChildren<SceneDecoratorContext>()).ToList();

            if (decoratorContexts.IsEmpty())
            {
                return null;
            }

            Assert.That(decoratorContexts.Count == 1,
                "Found multiple DecoratorContexts in scene '{0}'.  Expected a maximum of one.", scene.name);

            return decoratorContexts[0];
        }

        static IEnumerable<SceneContext> GetAllSceneContexts()
        {
            var decoratedSceneNames = new List<string>();

            for (int i = 0; i < EditorSceneManager.sceneCount; i++)
            {
                var scene = EditorSceneManager.GetSceneAt(i);

                var sceneContext = TryGetSceneContextForScene(scene);
                var decoratorContext = TryGetDecoratorContextForScene(scene);

                if (sceneContext != null)
                {
                    Assert.That(decoratorContext == null,
                        "Found both SceneDecoratorContext and SceneContext in the same scene '{0}'.  This is not allowed", scene.name);

                    decoratedSceneNames.RemoveAll(x => sceneContext.ContractNames.Contains(x));

                    yield return sceneContext;
                }
                else if (decoratorContext != null)
                {
                    Assert.That(!string.IsNullOrEmpty(decoratorContext.DecoratedContractName),
                        "Missing Decorated Contract Name on SceneDecoratorContext in scene '{0}'", scene.name);

                    decoratedSceneNames.Add(decoratorContext.DecoratedContractName);
                }
            }

            Assert.That(decoratedSceneNames.IsEmpty(),
                "Found decorator scenes without a corresponding scene to decorator.  Missing scene contracts: {0}", decoratedSceneNames.Join(", "));
        }

        public static string ConvertAssetPathToAbsolutePath(string assetPath)
        {
            return Path.Combine(
                Path.Combine(Path.GetFullPath(Application.dataPath), ".."), assetPath);
        }

        public static string ConvertFullAbsolutePathToAssetPath(string fullPath)
        {
            fullPath = Path.GetFullPath(fullPath);

            var assetFolderFullPath = Path.GetFullPath(Application.dataPath);

            if (fullPath.Length == assetFolderFullPath.Length)
            {
                Assert.IsEqual(fullPath, assetFolderFullPath);
                return "Assets";
            }

            var assetPath = fullPath.Remove(0, assetFolderFullPath.Length + 1).Replace("\\", "/");
            return "Assets/" + assetPath;
        }

        public static string GetCurrentDirectoryAssetPathFromSelection()
        {
            return ConvertFullAbsolutePathToAssetPath(
                GetCurrentDirectoryAbsolutePathFromSelection());
        }

        public static string GetCurrentDirectoryAbsolutePathFromSelection()
        {
            var folderPath = TryGetSelectedFolderPathInProjectsTab();

            if (folderPath != null)
            {
                return folderPath;
            }

            var filePath = TryGetSelectedFilePathInProjectsTab();

            if (filePath != null)
            {
                return Path.GetDirectoryName(filePath);
            }

            return Application.dataPath;
        }

        public static string TryGetSelectedFilePathInProjectsTab()
        {
            return GetSelectedFilePathsInProjectsTab().OnlyOrDefault();
        }

        public static List<string> GetSelectedFilePathsInProjectsTab()
        {
            return GetSelectedPathsInProjectsTab()
                .Where(x => File.Exists(x)).ToList();
        }

        public static List<string> GetSelectedAssetPathsInProjectsTab()
        {
            var paths = new List<string>();

            UnityEngine.Object[] selectedAssets = Selection.GetFiltered(
                typeof(UnityEngine.Object), SelectionMode.Assets);

            foreach (var item in selectedAssets)
            {
                var assetPath = AssetDatabase.GetAssetPath(item);

                if (!string.IsNullOrEmpty(assetPath))
                {
                    paths.Add(assetPath);
                }
            }

            return paths;
        }

        public static List<string> GetSelectedPathsInProjectsTab()
        {
            var paths = new List<string>();

            UnityEngine.Object[] selectedAssets = Selection.GetFiltered(
                typeof(UnityEngine.Object), SelectionMode.Assets);

            foreach (var item in selectedAssets)
            {
                var relativePath = AssetDatabase.GetAssetPath(item);

                if (!string.IsNullOrEmpty(relativePath))
                {
                    var fullPath = Path.GetFullPath(Path.Combine(
                        Application.dataPath, Path.Combine("..", relativePath)));

                    paths.Add(fullPath);
                }
            }

            return paths;
        }

        // Taken from http://wiki.unity3d.com/index.php?title=CreateScriptableObjectAsset
        public static void SaveScriptableObjectAsset(
            string path, ScriptableObject asset)
        {
            Assert.That(path.EndsWith(".asset"));

            string assetPathAndName = AssetDatabase.GenerateUniqueAssetPath(path);

            AssetDatabase.CreateAsset(asset, assetPathAndName);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            EditorUtility.FocusProjectWindow();
            Selection.activeObject = asset;
        }

        // Note that the path is relative to the Assets folder
        public static List<string> GetSelectedFolderPathsInProjectsTab()
        {
            return GetSelectedPathsInProjectsTab()
                .Where(x => Directory.Exists(x)).ToList();
        }

        // Returns the best guess directory in projects pane
        // Useful when adding to Assets -> Create context menu
        // Returns null if it can't find one
        // Note that the path is relative to the Assets folder for use in AssetDatabase.GenerateUniqueAssetPath etc.
        public static string TryGetSelectedFolderPathInProjectsTab()
        {
            return GetSelectedFolderPathsInProjectsTab().OnlyOrDefault();
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/ZenUnityEditorUtil.cs.meta
================================================
fileFormatVersion: 2
guid: f798e3a2f0079b840804c0516d265f03
timeCreated: 1461710838
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/ContextEditor.cs
================================================
#if !ODIN_INSPECTOR

namespace Zenject
{
    [NoReflectionBaking]
    public class ContextEditor : UnityInspectorListEditor
    {
        protected override string[] PropertyNames
        {
            get
            {
                return new string[]
                {
                    "_scriptableObjectInstallers",
                    "_monoInstallers",
                    "_installerPrefabs",
                };
            }
        }

        protected override string[] PropertyDisplayNames
        {
            get
            {
                return new string[]
                {
                    "Scriptable Object Installers",
                    "Mono Installers",
                    "Prefab Installers",
                };
            }
        }

        protected override string[] PropertyDescriptions
        {
            get
            {
                return new string[]
                {
                    "Drag any assets in your Project that implement ScriptableObjectInstaller here",
                    "Drag any MonoInstallers that you have added to your Scene Hierarchy here.",
                    "Drag any prefabs that contain a MonoInstaller on them here",
                };
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/ContextEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 23155ecdf203bf24480fd49763b73677
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/GameObjectContextEditor.cs
================================================
#if !ODIN_INSPECTOR

using UnityEditor;

namespace Zenject
{
    [CustomEditor(typeof(GameObjectContext))]
    [NoReflectionBaking]
    public class GameObjectContextEditor : RunnableContextEditor
    {
        SerializedProperty _kernel;

        public override void OnEnable()
        {
            base.OnEnable();

            _kernel = serializedObject.FindProperty("_kernel");
        }

        protected override void OnGui()
        {
            base.OnGui();

            EditorGUILayout.PropertyField(_kernel);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/GameObjectContextEditor.cs.meta
================================================
fileFormatVersion: 2
guid: b0873c763efd1e94fb3a56ff80843cf1
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/ProjectContextEditor.cs
================================================
#if !ODIN_INSPECTOR

using UnityEditor;

namespace Zenject
{
    [CustomEditor(typeof(ProjectContext))]
    [NoReflectionBaking]
    public class ProjectContextEditor : ContextEditor
    {
        SerializedProperty _settingsProperty;
        SerializedProperty _editorReflectionBakingCoverageModeProperty;
        SerializedProperty _buildsReflectionBakingCoverageModeProperty;
        SerializedProperty _parentNewObjectsUnderContextProperty;

        public override void OnEnable()
        {
            base.OnEnable();

            _settingsProperty = serializedObject.FindProperty("_settings");
            _editorReflectionBakingCoverageModeProperty = serializedObject.FindProperty("_editorReflectionBakingCoverageMode");
            _buildsReflectionBakingCoverageModeProperty = serializedObject.FindProperty("_buildsReflectionBakingCoverageMode");
            _parentNewObjectsUnderContextProperty = serializedObject.FindProperty("_parentNewObjectsUnderContext");
        }

        protected override void OnGui()
        {
            base.OnGui();

            EditorGUILayout.PropertyField(_settingsProperty, true);
            EditorGUILayout.PropertyField(_editorReflectionBakingCoverageModeProperty, true);
            EditorGUILayout.PropertyField(_buildsReflectionBakingCoverageModeProperty, true);
            EditorGUILayout.PropertyField(_parentNewObjectsUnderContextProperty);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/ProjectContextEditor.cs.meta
================================================
fileFormatVersion: 2
guid: b5ad40b612e67574aad508d053e6965b
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/RunnableContextEditor.cs
================================================
﻿#if !ODIN_INSPECTOR

using UnityEditor;

namespace Zenject
{
    [NoReflectionBaking]
    public class RunnableContextEditor : ContextEditor
    {
        SerializedProperty _autoRun;

        public override void OnEnable()
        {
            base.OnEnable();

            _autoRun = serializedObject.FindProperty("_autoRun");
        }

        protected override void OnGui()
        {
            base.OnGui();

            EditorGUILayout.PropertyField(_autoRun);
        }
    }
}


#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/RunnableContextEditor.cs.meta
================================================
﻿fileFormatVersion: 2
guid: 02bed9738f9c4323ac05524465473dee
timeCreated: 1494728675


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/SceneContextEditor.cs
================================================
#if !ODIN_INSPECTOR

using UnityEditor;

namespace Zenject
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(SceneContext))]
    [NoReflectionBaking]
    public class SceneContextEditor : RunnableContextEditor
    {
        SerializedProperty _contractNameProperty;
        SerializedProperty _parentNamesProperty;
        SerializedProperty _parentNewObjectsUnderSceneContextProperty;

        public override void OnEnable()
        {
            base.OnEnable();

            _contractNameProperty = serializedObject.FindProperty("_contractNames");
            _parentNamesProperty = serializedObject.FindProperty("_parentContractNames");
            _parentNewObjectsUnderSceneContextProperty = serializedObject.FindProperty("_parentNewObjectsUnderSceneContext");
        }

        protected override void OnGui()
        {
            base.OnGui();

            EditorGUILayout.PropertyField(_contractNameProperty, true);
            EditorGUILayout.PropertyField(_parentNamesProperty, true);
            EditorGUILayout.PropertyField(_parentNewObjectsUnderSceneContextProperty);
        }
    }
}


#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/SceneContextEditor.cs.meta
================================================
fileFormatVersion: 2
guid: c04ae1d59f53f514f96e284ba43122f7
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/SceneDecoratorContextEditor.cs
================================================
#if !ODIN_INSPECTOR

using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;
using ModestTree;

namespace Zenject
{
    [CustomEditor(typeof(SceneDecoratorContext))]
    [NoReflectionBaking]
    public class SceneDecoratorContextEditor : ContextEditor
    {
        SerializedProperty _decoratedContractNameProperty;

        protected override string[] PropertyNames
        {
            get
            {
                return base.PropertyNames.Concat(new string[]
                    {
                        "_lateInstallers",
                        "_lateInstallerPrefabs",
                        "_lateScriptableObjectInstallers"
                    })
                    .ToArray();
            }
        }

        protected override string[] PropertyDisplayNames
        {
            get
            {
                return base.PropertyDisplayNames.Concat(new string[]
                    {
                        "Late Installers",
                        "Late Prefab Installers",
                        "Late Scriptable Object Installers"
                    })
                    .ToArray();
            }
        }

        protected override string[] PropertyDescriptions
        {
            get
            {
                return base.PropertyDescriptions.Concat(new string[]
                    {
                        "Drag any MonoInstallers that you have added to your Scene Hierarchy here. They'll be installed after the target installs its bindings",
                        "Drag any prefabs that contain a MonoInstaller on them here. They'll be installed after the target installs its bindings",
                        "Drag any assets in your Project that implement ScriptableObjectInstaller here. They'll be installed after the target installs its bindings"
                    })
                    .ToArray();
            }
        }

        public override void OnEnable()
        {
            base.OnEnable();

            _decoratedContractNameProperty = serializedObject.FindProperty("_decoratedContractName");
        }

        protected override void OnGui()
        {
            base.OnGui();

            EditorGUILayout.PropertyField(_decoratedContractNameProperty);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/Editors/SceneDecoratorContextEditor.cs.meta
================================================
fileFormatVersion: 2
guid: d2b9289e80031104295e10acf518d75a
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/EditorWindow/ZenjectEditorWindow.cs
================================================
using System;
using ModestTree;
using UnityEditor;
using UnityEngine;

namespace Zenject
{
    public abstract class ZenjectEditorWindow : EditorWindow
    {
        [Inject]
        [NonSerialized]
        Kernel _kernel;

        [Inject]
        [NonSerialized]
        GuiRenderableManager _guiRenderableManager;

        [NonSerialized]
        DiContainer _container;

        [NonSerialized]
        Exception _fatalError;

        [NonSerialized]
        GUIStyle _errorTextStyle;

        GUIStyle ErrorTextStyle
        {
            get
            {
                if (_errorTextStyle == null)
                {
                    _errorTextStyle = new GUIStyle(GUI.skin.label);
                    _errorTextStyle.fontSize = 18;
                    _errorTextStyle.normal.textColor = Color.red;
                    _errorTextStyle.wordWrap = true;
                    _errorTextStyle.alignment = TextAnchor.MiddleCenter;
                }

                return _errorTextStyle;
            }
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        public virtual void OnEnable()
        {
            if (_fatalError != null)
            {
                return;
            }

            Initialize();
        }

        protected virtual void Initialize()
        {
            Assert.IsNull(_container);

            _container = new DiContainer(new[] { StaticContext.Container });

            // Make sure we don't create any game objects since editor windows don't have a scene
            _container.AssertOnNewGameObjects = true;

            ZenjectManagersInstaller.Install(_container);

            _container.Bind<Kernel>().AsSingle();
            _container.Bind<GuiRenderableManager>().AsSingle();
            _container.BindInstance(this);

            InstallBindings();

            _container.QueueForInject(this);
            _container.ResolveRoots();

            _kernel.Initialize();
        }

        public virtual void OnDisable()
        {
            if (_fatalError != null)
            {
                return;
            }

            _kernel.Dispose();
        }

        public virtual void Update()
        {
            if (_fatalError != null)
            {
                return;
            }

            try
            {
                _kernel.Tick();
            }
            catch (Exception e)
            {
                Log.ErrorException(e);
                _fatalError = e;
            }

            // We might also consider only calling Repaint when changes occur
            Repaint();
        }

        public virtual void OnGUI()
        {
            if (_fatalError != null)
            {
                var labelWidth = 600;
                var labelHeight = 200;

                GUI.Label(new Rect(Screen.width / 2 - labelWidth / 2, Screen.height / 3 - labelHeight / 2, labelWidth, labelHeight), "Unrecoverable error occurred!  \nSee log for details.", ErrorTextStyle);

                var buttonWidth = 100;
                var buttonHeight = 50;
                var offset = new Vector2(0, 100);

                if (GUI.Button(new Rect(Screen.width / 2 - buttonWidth / 2 + offset.x, Screen.height / 3 - buttonHeight / 2 + offset.y, buttonWidth, buttonHeight), "Reload"))
                {
                    ExecuteFullReload();
                }
            }
            else
            {
                try
                {
                    if (_guiRenderableManager != null)
                    {
                        _guiRenderableManager.OnGui();
                    }
                }
                catch (Exception e)
                {
                    Log.ErrorException(e);
                    _fatalError = e;
                }
            }
        }

        protected virtual void ExecuteFullReload()
        {
            _kernel = null;
            _guiRenderableManager = null;
            _container = null;
            _fatalError = null;

            Initialize();
        }

        public abstract void InstallBindings();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/EditorWindow/ZenjectEditorWindow.cs.meta
================================================
fileFormatVersion: 2
guid: bc25e694ccedbed4893d980ee61d1c8f
timeCreated: 1527961729
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/SceneParentLoading/DefaultSceneContractConfig.cs
================================================
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Zenject.Internal
{
    public class DefaultSceneContractConfig : ScriptableObject
    {
        public const string ResourcePath = "ZenjectDefaultSceneContractConfig";

        public List<ContractInfo> DefaultContracts;

        [Serializable]
        public class ContractInfo
        {
            public string ContractName;
            public SceneAsset Scene;
        }
    }

}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/SceneParentLoading/DefaultSceneContractConfig.cs.meta
================================================
fileFormatVersion: 2
guid: 8620c058a9173b84a97d72ed5e94dbd7
timeCreated: 1520778887
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/SceneParentLoading/SceneParentAutomaticLoader.cs
================================================
﻿using System;
using System.Collections.Generic;
using ModestTree;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Zenject.Internal
{
    [InitializeOnLoad]
    public static class SceneParentAutomaticLoader
    {
        static SceneParentAutomaticLoader()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }

        static void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (state == PlayModeStateChange.ExitingEditMode)
            {
                try
                {
                    ValidateMultiSceneSetupAndLoadDefaultSceneParents();
                }
                catch (Exception e)
                {
                    EditorApplication.isPlaying = false;
                    throw new ZenjectException(
                        "Failure occurred when attempting to load default scene parent contracts!", e);
                }
            }
            else if (state == PlayModeStateChange.EnteredEditMode)
            {
                // It would be cool to restore the initial scene set up here but in order to do this
                // we would have to make sure that the user saves the scene before running which
                // would be too annoying, so just leave any changes we've made alone
            }
        }

        public static void ValidateMultiSceneSetupAndLoadDefaultSceneParents()
        {
            var defaultContractsMap = LoadDefaultContractsMap();

            // NOTE: Even if configs is empty we still want to do the below logic to validate the
            // multi scene setup

            var sceneInfos = GetLoadedZenjectSceneInfos();
            var contractMap = GetCurrentSceneContractsMap(sceneInfos);

            foreach (var sceneInfo in sceneInfos)
            {
                ProcessScene(sceneInfo, contractMap, defaultContractsMap);
            }
        }

        static Dictionary<string, LoadedSceneInfo> GetCurrentSceneContractsMap(
            List<LoadedSceneInfo> sceneInfos)
        {
            var contractMap = new Dictionary<string, LoadedSceneInfo>();

            foreach (var info in sceneInfos)
            {
                AddToContractMap(contractMap, info);
            }

            return contractMap;
        }

        static void ProcessScene(
            LoadedSceneInfo sceneInfo,
            Dictionary<string, LoadedSceneInfo> contractMap,
            Dictionary<string, string> defaultContractsMap)
        {
            if (sceneInfo.SceneContext != null)
            {
                Assert.IsNull(sceneInfo.DecoratorContext);
                ProcessSceneParents(sceneInfo, contractMap, defaultContractsMap);
            }
            else
            {
                Assert.IsNotNull(sceneInfo.DecoratorContext);
                ProcessSceneDecorators(sceneInfo, contractMap, defaultContractsMap);
            }
        }

        static void ProcessSceneDecorators(
            LoadedSceneInfo sceneInfo,
            Dictionary<string, LoadedSceneInfo> contractMap,
            Dictionary<string, string> defaultContractsMap)
        {
            var decoratedContractName = sceneInfo.DecoratorContext.DecoratedContractName;

            LoadedSceneInfo decoratedSceneInfo;

            if (contractMap.TryGetValue(decoratedContractName, out decoratedSceneInfo))
            {
                ValidateDecoratedSceneMatch(sceneInfo, decoratedSceneInfo);
                return;
            }

            decoratedSceneInfo = LoadDefaultSceneForContract(
                sceneInfo, decoratedContractName, defaultContractsMap);

            EditorSceneManager.MoveSceneAfter(decoratedSceneInfo.Scene, sceneInfo.Scene);

            ValidateDecoratedSceneMatch(sceneInfo, decoratedSceneInfo);

            ProcessScene(decoratedSceneInfo, contractMap, defaultContractsMap);
        }

        static void ProcessSceneParents(
            LoadedSceneInfo sceneInfo,
            Dictionary<string, LoadedSceneInfo> contractMap,
            Dictionary<string, string> defaultContractsMap)
        {
            foreach (var parentContractName in sceneInfo.SceneContext.ParentContractNames)
            {
                LoadedSceneInfo parentInfo;

                if (contractMap.TryGetValue(parentContractName, out parentInfo))
                {
                    ValidateParentChildMatch(parentInfo, sceneInfo);
                    continue;
                }

                parentInfo = LoadDefaultSceneForContract(sceneInfo, parentContractName, defaultContractsMap);

                AddToContractMap(contractMap, parentInfo);

                EditorSceneManager.MoveSceneBefore(parentInfo.Scene, sceneInfo.Scene);

                ValidateParentChildMatch(parentInfo, sceneInfo);

                ProcessScene(parentInfo, contractMap, defaultContractsMap);
            }
        }

        static LoadedSceneInfo LoadDefaultSceneForContract(
            LoadedSceneInfo sceneInfo, string contractName, Dictionary<string, string> defaultContractsMap)
        {
            string scenePath;

            if (!defaultContractsMap.TryGetValue(contractName, out scenePath))
            {
                throw Assert.CreateException(
                    "Could not fill contract '{0}' for scene '{1}'.  No scenes with that contract name are loaded, and could not find a match in any default scene contract configs to auto load one either."
                    .Fmt(contractName, sceneInfo.Scene.name));
            }

            Scene scene;

            try
            {
                scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);
            }
            catch (Exception e)
            {
                throw new ZenjectException(
                    "Error while attempting to load contracts for scene '{0}'".Fmt(sceneInfo.Scene.name), e);
            }

            return CreateLoadedSceneInfo(scene);
        }

        static void ValidateDecoratedSceneMatch(
            LoadedSceneInfo decoratorInfo, LoadedSceneInfo decoratedInfo)
        {
            var decoratorIndex = GetSceneIndex(decoratorInfo.Scene);
            var decoratedIndex = GetSceneIndex(decoratedInfo.Scene);
            var activeIndex = GetSceneIndex(EditorSceneManager.GetActiveScene());

            Assert.That(decoratorIndex < decoratedIndex,
                "Decorator scene '{0}' must be loaded before decorated scene '{1}'.  Please drag the decorator scene to be placed above the other scene in the scene hierarchy.",
                decoratorInfo.Scene.name, decoratedInfo.Scene.name);

            if (activeIndex > decoratorIndex)
            {
                EditorSceneManager.SetActiveScene(decoratorInfo.Scene);
            }
        }

        static void ValidateParentChildMatch(
            LoadedSceneInfo parentSceneInfo, LoadedSceneInfo sceneInfo)
        {
            var parentIndex = GetSceneIndex(parentSceneInfo.Scene);
            var childIndex = GetSceneIndex(sceneInfo.Scene);
            var activeIndex = GetSceneIndex(EditorSceneManager.GetActiveScene());

            Assert.That(parentIndex < childIndex,
                "Parent scene '{0}' must be loaded before child scene '{1}'.  Please drag it to be placed above its child in the scene hierarchy.", parentSceneInfo.Scene.name, sceneInfo.Scene.name);

            if (activeIndex > parentIndex)
            {
                EditorSceneManager.SetActiveScene(parentSceneInfo.Scene);
            }
        }

        static int GetSceneIndex(Scene scene)
        {
            for (int i = 0; i < EditorSceneManager.sceneCount; i++)
            {
                if (EditorSceneManager.GetSceneAt(i) == scene)
                {
                    return i;
                }
            }

            throw Assert.CreateException();
        }

        static Dictionary<string, string> LoadDefaultContractsMap()
        {
            var configs = Resources.LoadAll<DefaultSceneContractConfig>(DefaultSceneContractConfig.ResourcePath);

            var map = new Dictionary<string, string>();

            foreach (var config in configs)
            {
                foreach (var info in config.DefaultContracts)
                {
                    if (info.ContractName.Trim().IsEmpty())
                    {
                        Log.Warn("Found empty contract name in default scene contract config at path '{0}'", AssetDatabase.GetAssetPath(config));
                        continue;
                    }

                    Assert.That(!map.ContainsKey(info.ContractName),
                        "Found duplicate contract '{0}' in default scene contract config at '{1}'!  Default contract already specified", info.ContractName, AssetDatabase.GetAssetPath(config));

                    map.Add(info.ContractName, AssetDatabase.GetAssetPath(info.Scene));
                }
            }

            return map;
        }

        static LoadedSceneInfo CreateLoadedSceneInfo(Scene scene)
        {
            var info = TryCreateLoadedSceneInfo(scene);
            Assert.IsNotNull(info, "Expected scene '{0}' to be a zenject scene", scene.name);
            return info;
        }

        static LoadedSceneInfo TryCreateLoadedSceneInfo(Scene scene)
        {
            var sceneContext = ZenUnityEditorUtil.TryGetSceneContextForScene(scene);
            var decoratorContext = ZenUnityEditorUtil.TryGetDecoratorContextForScene(scene);

            if (sceneContext == null && decoratorContext == null)
            {
                return null;
            }

            var info = new LoadedSceneInfo
            {
                Scene = scene
            };

            if (sceneContext != null)
            {
                Assert.IsNull(decoratorContext,
                "Found both SceneContext and SceneDecoratorContext in scene '{0}'", scene.name);

                info.SceneContext = sceneContext;
            }
            else
            {
                Assert.IsNotNull(decoratorContext);

                info.DecoratorContext = decoratorContext;
            }

            return info;
        }

        static List<LoadedSceneInfo> GetLoadedZenjectSceneInfos()
        {
            var result = new List<LoadedSceneInfo>();

            for (int i = 0; i < EditorSceneManager.sceneCount; i++)
            {
                var scene = EditorSceneManager.GetSceneAt(i);
                var info = TryCreateLoadedSceneInfo(scene);

                if (info != null)
                {
                    result.Add(info);
                }
            }

            return result;
        }

        static void AddToContractMap(
            Dictionary<string, LoadedSceneInfo> contractMap, LoadedSceneInfo info)
        {
            if (info.SceneContext == null)
            {
                return;
            }

            foreach (var contractName in info.SceneContext.ContractNames)
            {
                LoadedSceneInfo currentInfo;

                if (contractMap.TryGetValue(contractName, out currentInfo))
                {
                    throw Assert.CreateException(
                        "Found multiple scene contracts with name '{0}'. Scene '{1}' and scene '{2}'",
                        contractName, currentInfo.Scene.name, info.Scene.name);
                }

                contractMap.Add(contractName, info);
            }
        }

        public class LoadedSceneInfo
        {
            public SceneContext SceneContext;
            public SceneDecoratorContext DecoratorContext;
            public Scene Scene;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Editor/SceneParentLoading/SceneParentAutomaticLoader.cs.meta
================================================
fileFormatVersion: 2
guid: c9f09e0752f64214ba3413d7fdc47736
timeCreated: 1520771371
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/FactoryProviderWrapper.cs
================================================
using ModestTree;

namespace Zenject
{
    public class FactoryProviderWrapper<TContract> : IFactory<TContract>
    {
        readonly IProvider _provider;
        readonly InjectContext _injectContext;

        public FactoryProviderWrapper(
            IProvider provider, InjectContext injectContext)
        {
            Assert.That(injectContext.MemberType.DerivesFromOrEqual<TContract>());

            _provider = provider;
            _injectContext = injectContext;
        }

        public TContract Create()
        {
            var instance = _provider.GetInstance(_injectContext);

            if (_injectContext.Container.IsValidating)
            {
                // During validation it is sufficient to just call the _provider.GetInstance
                return default(TContract);
            }

            Assert.That(instance == null
                || instance.GetType().DerivesFromOrEqual(_injectContext.MemberType));

            return (TContract)instance;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/FactoryProviderWrapper.cs.meta
================================================
fileFormatVersion: 2
guid: f1157303ef95f2448a355067327cb83a
timeCreated: 1488133028
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/IFactory.cs
================================================
namespace Zenject
{
    public interface IFactory
    {
    }

    public interface IFactory<out TValue> : IFactory
    {
        TValue Create();
    }

    public interface IFactory<in TParam1, out TValue> : IFactory
    {
        TValue Create(TParam1 param);
    }

    public interface IFactory<in TParam1, in TParam2, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, in TParam8, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, in TParam8, in TParam9, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8, TParam9 param9);
    }

    public interface IFactory<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, in TParam8, in TParam9, in TParam10, out TValue> : IFactory
    {
        TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8, TParam9 param9, TParam10 param10);
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/IFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 62c651ad6c58c1140ac224dc6284fa5e
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/KeyedFactory.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;

namespace Zenject
{
    public abstract class KeyedFactoryBase<TBase, TKey> : IValidatable
    {
        [Inject]
        readonly DiContainer _container = null;

        [InjectOptional]
        readonly List<ValuePair<TKey, Type>> _typePairs = null;

        Dictionary<TKey, Type> _typeMap = null;

        [InjectOptional]
        readonly Type _fallbackType = null;

        protected DiContainer Container
        {
            get { return _container; }
        }

        protected abstract IEnumerable<Type> ProvidedTypes
        {
            get;
        }

        public ICollection<TKey> Keys
        {
            get { return _typeMap.Keys; }
        }

        protected Dictionary<TKey, Type> TypeMap
        {
            get { return _typeMap; }
        }

        [Inject]
        public void Initialize()
        {
            Assert.That(_fallbackType == null || _fallbackType.DerivesFromOrEqual<TBase>(),
                "Expected fallback type '{0}' to derive from '{1}'", _fallbackType, typeof(TBase));

#if UNITY_EDITOR
            var duplicates = _typePairs.Select(x => x.First).GetDuplicates();

            if (!duplicates.IsEmpty())
            {
                throw Assert.CreateException(
                    "Found duplicate values in KeyedFactory: {0}", duplicates.Select(x => x.ToString()).Join(", "));
            }
#endif

            _typeMap = _typePairs.ToDictionary(x => x.First, x => x.Second);
            _typePairs.Clear();
        }

        public bool HasKey(TKey key)
        {
            return _typeMap.ContainsKey(key);
        }

        protected Type GetTypeForKey(TKey key)
        {
            Type keyedType;

            if (!_typeMap.TryGetValue(key, out keyedType))
            {
                Assert.IsNotNull(_fallbackType, "Could not find instance for key '{0}'", key);
                return _fallbackType;
            }

            return keyedType;
        }

        public virtual void Validate()
        {
            foreach (var constructType in _typeMap.Values)
            {
                Container.InstantiateExplicit(
                    constructType, ValidationUtil.CreateDefaultArgs(ProvidedTypes.ToArray()));
            }
        }

        protected static ConditionCopyNonLazyBinder AddBindingInternal<TDerived>(DiContainer container, TKey key)
            where TDerived : TBase
        {
            return container.Bind<ValuePair<TKey, Type>>()
                .FromInstance(ValuePair.New(key, typeof(TDerived)));
        }
    }

    // Zero parameters
    public class KeyedFactory<TBase, TKey> : KeyedFactoryBase<TBase, TKey>
    {
        protected override IEnumerable<Type> ProvidedTypes
        {
            get { return new Type[0]; }
        }

        public virtual TBase Create(TKey key)
        {
            var type = GetTypeForKey(key);
            return (TBase)Container.Instantiate(type);
        }
    }

    // One parameter
    public class KeyedFactory<TBase, TKey, TParam1> : KeyedFactoryBase<TBase, TKey>
    {
        protected override IEnumerable<Type> ProvidedTypes
        {
            get { return new[] { typeof(TParam1) }; }
        }

        public virtual TBase Create(TKey key, TParam1 param1)
        {
            return (TBase)Container.InstantiateExplicit(
                GetTypeForKey(key),
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1)
                });
        }
    }

    // Two parameters
    public class KeyedFactory<TBase, TKey, TParam1, TParam2> : KeyedFactoryBase<TBase, TKey>
    {
        protected override IEnumerable<Type> ProvidedTypes
        {
            get { return new[] { typeof(TParam1), typeof(TParam2) }; }
        }

        public virtual TBase Create(TKey key, TParam1 param1, TParam2 param2)
        {
            return (TBase)Container.InstantiateExplicit(
                GetTypeForKey(key),
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2)
                });
        }
    }

    // Three parameters
    public class KeyedFactory<TBase, TKey, TParam1, TParam2, TParam3> : KeyedFactoryBase<TBase, TKey>
    {
        protected override IEnumerable<Type> ProvidedTypes
        {
            get { return new[] { typeof(TParam1), typeof(TParam2), typeof(TParam3) }; }
        }

        public virtual TBase Create(TKey key, TParam1 param1, TParam2 param2, TParam3 param3)
        {
            return (TBase)Container.InstantiateExplicit(
                GetTypeForKey(key),
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3)
                });
        }
    }

    // Four parameters
    public class KeyedFactory<TBase, TKey, TParam1, TParam2, TParam3, TParam4> : KeyedFactoryBase<TBase, TKey>
    {
        protected override IEnumerable<Type> ProvidedTypes
        {
            get { return new[] { typeof(TParam1), typeof(TParam2), typeof(TParam3), typeof(TParam4) }; }
        }

        public virtual TBase Create(TKey key, TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            return (TBase)Container.InstantiateExplicit(
                GetTypeForKey(key),
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3),
                    InjectUtil.CreateTypePair(param4)
                });
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/KeyedFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 73ed4b67b639aaf4c94f61339a6ff413
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PlaceholderFactory.cs
================================================
using System;
using System.Collections.Generic;
#if !NOT_UNITY3D
using JetBrains.Annotations;
#endif

namespace Zenject
{
    // Zero parameters
    public class PlaceholderFactory<TValue> : PlaceholderFactoryBase<TValue>, IFactory<TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create()
        {
            return CreateInternal(new List<TypeValuePair>());
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get { yield break; }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TValue> : PlaceholderFactory<TValue>
    {
    }

    // One parameter
    public class PlaceholderFactory<TParam1, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get { yield return typeof(TParam1); }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TValue> : PlaceholderFactory<TParam1, TValue>
    {
    }

    // Two parameters
    public class PlaceholderFactory<TParam1, TParam2, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param1, TParam2 param2)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TValue> : PlaceholderFactory<TParam1, TParam2, TValue>
    {
    }

    // Three parameters
    public class PlaceholderFactory<TParam1, TParam2, TParam3, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TParam3, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param1, TParam2 param2, TParam3 param3)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
                yield return typeof(TParam3);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TParam3, TValue> : PlaceholderFactory<TParam1, TParam2, TParam3, TValue>
    {
    }

    // Four parameters
    public class PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3),
                    InjectUtil.CreateTypePair(param4)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
                yield return typeof(TParam3);
                yield return typeof(TParam4);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TParam3, TParam4, TValue>
        : PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TValue>
    {
    }

    // Five parameters
    public class PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3),
                    InjectUtil.CreateTypePair(param4),
                    InjectUtil.CreateTypePair(param5)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
                yield return typeof(TParam3);
                yield return typeof(TParam4);
                yield return typeof(TParam5);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
    {
    }

    // Six parameters
    public class PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
    {
        // Note: Most of the time you should not override this method and should instead
        // use BindFactory<>.FromIFactory if you want to do some custom logic
#if !NOT_UNITY3D
        [NotNull]
#endif
        public virtual TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3),
                    InjectUtil.CreateTypePair(param4),
                    InjectUtil.CreateTypePair(param5),
                    InjectUtil.CreateTypePair(param6)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
                yield return typeof(TParam3);
                yield return typeof(TParam4);
                yield return typeof(TParam5);
                yield return typeof(TParam6);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        : PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
    {
    }

    // Ten parameters
    public class PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
        : PlaceholderFactoryBase<TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
    {
        // If you were hoping to override this method, use BindFactory<>.ToFactory instead
        public virtual TValue Create(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8, TParam9 param9, TParam10 param10)
        {
            return CreateInternal(
                new List<TypeValuePair>
                {
                    InjectUtil.CreateTypePair(param1),
                    InjectUtil.CreateTypePair(param2),
                    InjectUtil.CreateTypePair(param3),
                    InjectUtil.CreateTypePair(param4),
                    InjectUtil.CreateTypePair(param5),
                    InjectUtil.CreateTypePair(param6),
                    InjectUtil.CreateTypePair(param7),
                    InjectUtil.CreateTypePair(param8),
                    InjectUtil.CreateTypePair(param9),
                    InjectUtil.CreateTypePair(param10)
                });
        }

        protected sealed override IEnumerable<Type> ParamTypes
        {
            get
            {
                yield return typeof(TParam1);
                yield return typeof(TParam2);
                yield return typeof(TParam3);
                yield return typeof(TParam4);
                yield return typeof(TParam5);
                yield return typeof(TParam6);
                yield return typeof(TParam7);
                yield return typeof(TParam8);
                yield return typeof(TParam9);
                yield return typeof(TParam10);
            }
        }
    }

    [Obsolete("Zenject.Factory has been renamed to PlaceholderFactory.  Zenject.Factory will be removed in future versions")]
    public class Factory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
        : PlaceholderFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue>
    {
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PlaceholderFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 665a56f53857092408155478e576cfd0
timeCreated: 1486691381
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PlaceholderFactoryBase.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;

namespace Zenject
{
    public interface IPlaceholderFactory : IValidatable
    {
    }

    // Placeholder factories can be used to choose a creation method in an installer, using FactoryBinder
    public abstract class PlaceholderFactoryBase<TValue> : IPlaceholderFactory
    {
        IProvider _provider;
        InjectContext _injectContext;

        [Inject]
        void Construct(IProvider provider, InjectContext injectContext)
        {
            Assert.IsNotNull(provider);
            Assert.IsNotNull(injectContext);

            _provider = provider;
            _injectContext = injectContext;
        }

        protected TValue CreateInternal(List<TypeValuePair> extraArgs)
        {
            try
            {
                var result = _provider.GetInstance(_injectContext, extraArgs);

                if (_injectContext.Container.IsValidating && result is ValidationMarker)
                {
                    return default(TValue);
                }

                Assert.That(result == null || result.GetType().DerivesFromOrEqual<TValue>());

                return (TValue) result;
            }
            catch (Exception e)
            {
                throw new ZenjectException(
                    "Error during construction of type '{0}' via {1}.Create method!".Fmt(typeof(TValue), GetType()), e);
            }
        }

        public virtual void Validate()
        {
            _provider.GetInstance(
                _injectContext, ValidationUtil.CreateDefaultArgs(ParamTypes.ToArray()));
        }

        protected abstract IEnumerable<Type> ParamTypes
        {
            get;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PlaceholderFactoryBase.cs.meta
================================================
fileFormatVersion: 2
guid: 2a15cf923ae4d72418e9951480e9f178
timeCreated: 1527952932
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling.meta
================================================
fileFormatVersion: 2
guid: 0f3fb191ad2b6c74c97f488543a89c82
folderAsset: yes
timeCreated: 1484511595
licenseType: Free
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PrefabFactory.cs
================================================
﻿#if !NOT_UNITY3D

using ModestTree;
using UnityEngine;

namespace Zenject
{
    // This factory type can be useful if you want to control where the prefab comes from at runtime
    // rather than from within the installers

    //No parameters
    public class PrefabFactory<T> : IFactory<UnityEngine.Object, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(UnityEngine.Object prefab)
        {
            Assert.That(prefab != null,
               "Null prefab given to factory create method when instantiating object with type '{0}'.", typeof(T));

            return _container.InstantiatePrefabForComponent<T>(prefab);
        }

        // Note: We can't really validate here without access to the prefab
        // We could validate the class directly with the current container but that fails when the
        // class is inside a GameObjectContext
    }

    // One parameter
    public class PrefabFactory<P1, T> : IFactory<UnityEngine.Object, P1, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(UnityEngine.Object prefab, P1 param)
        {
            Assert.That(prefab != null,
               "Null prefab given to factory create method when instantiating object with type '{0}'.", typeof(T));

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param));
        }
    }

    // Two parameters
    public class PrefabFactory<P1, P2, T> : IFactory<UnityEngine.Object, P1, P2, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(UnityEngine.Object prefab, P1 param, P2 param2)
        {
            Assert.That(prefab != null,
               "Null prefab given to factory create method when instantiating object with type '{0}'.", typeof(T));

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2));
        }
    }

    // Three parameters
    public class PrefabFactory<P1, P2, P3, T> : IFactory<UnityEngine.Object, P1, P2, P3, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(UnityEngine.Object prefab, P1 param, P2 param2, P3 param3)
        {
            Assert.That(prefab != null,
               "Null prefab given to factory create method when instantiating object with type '{0}'.", typeof(T));

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2, param3));
        }
    }

    // Four parameters
    public class PrefabFactory<P1, P2, P3, P4, T> : IFactory<UnityEngine.Object, P1, P2, P3, P4, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(UnityEngine.Object prefab, P1 param, P2 param2, P3 param3, P4 param4)
        {
            Assert.That(prefab != null,
               "Null prefab given to factory create method when instantiating object with type '{0}'.", typeof(T));

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2, param3, param4));
        }
    }
}

#endif





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PrefabFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 39782cb4430018d459f5707002dff73c
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PrefabResourceFactory.cs
================================================
#if !NOT_UNITY3D

using ModestTree;
using UnityEngine;

namespace Zenject
{
    // This factory type can be useful if you want to control where the prefab comes from at runtime
    // rather than from within the installers

    //No parameters
    public class PrefabResourceFactory<T> : IFactory<string, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(string prefabResourceName)
        {
            Assert.That(!string.IsNullOrEmpty(prefabResourceName),
              "Null or empty prefab resource name given to factory create method when instantiating object with type '{0}'.", typeof(T));

            var prefab = (GameObject)Resources.Load(prefabResourceName);
            return _container.InstantiatePrefabForComponent<T>(prefab);
        }

        // Note: We can't really validate here without access to the prefab
        // We could validate the class directly with the current container but that fails when the
        // class is inside a GameObjectContext
    }

    // One parameter
    public class PrefabResourceFactory<P1, T> : IFactory<string, P1, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(string prefabResourceName, P1 param)
        {
            Assert.That(!string.IsNullOrEmpty(prefabResourceName),
              "Null or empty prefab resource name given to factory create method when instantiating object with type '{0}'.", typeof(T));

            var prefab = (GameObject)Resources.Load(prefabResourceName);
            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param));
        }
    }

    // Two parameters
    public class PrefabResourceFactory<P1, P2, T> : IFactory<string, P1, P2, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(string prefabResourceName, P1 param, P2 param2)
        {
            Assert.That(!string.IsNullOrEmpty(prefabResourceName),
              "Null or empty prefab resource name given to factory create method when instantiating object with type '{0}'.", typeof(T));

            var prefab = (GameObject)Resources.Load(prefabResourceName);

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2));
        }
    }

    // Three parameters
    public class PrefabResourceFactory<P1, P2, P3, T> : IFactory<string, P1, P2, P3, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(string prefabResourceName, P1 param, P2 param2, P3 param3)
        {
            Assert.That(!string.IsNullOrEmpty(prefabResourceName),
              "Null or empty prefab resource name given to factory create method when instantiating object with type '{0}'.", typeof(T));

            var prefab = (GameObject)Resources.Load(prefabResourceName);

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2, param3));
        }
    }

    // Four parameters
    public class PrefabResourceFactory<P1, P2, P3, P4, T> : IFactory<string, P1, P2, P3, P4, T>
        //where T : Component
    {
        [Inject]
        readonly DiContainer _container = null;

        public DiContainer Container
        {
            get { return _container; }
        }

        public virtual T Create(string prefabResourceName, P1 param, P2 param2, P3 param3, P4 param4)
        {
            Assert.That(!string.IsNullOrEmpty(prefabResourceName),
              "Null or empty prefab resource name given to factory create method when instantiating object with type '{0}'.", typeof(T));

            var prefab = (GameObject)Resources.Load(prefabResourceName);

            return (T)_container.InstantiatePrefabForComponentExplicit(
                typeof(T), prefab, InjectUtil.CreateArgListExplicit(param, param2, param3, param4));
        }
    }
}

#endif






================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/PrefabResourceFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 5fd50037209abd647b7ae7391717f015
timeCreated: 1534319565
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/IMemoryPool.cs
================================================
using System;

namespace Zenject
{
    public interface IMemoryPool
    {
        int NumTotal { get; }
        int NumActive { get; }
        int NumInactive { get; }

        Type ItemType
        {
            get;
        }

        /// <summary>
        /// Changes pool size by creating new elements or destroying existing elements
        /// This bypasses the configured expansion method (OneAtATime or Doubling)
        /// </summary>
        void Resize(int desiredPoolSize);

        void Clear();

        /// <summary>
        /// Expands the pool by the additional size.
        /// This bypasses the configured expansion method (OneAtATime or Doubling)
        /// </summary>
        /// <param name="numToAdd">The additional number of items to allocate in the pool</param>
        void ExpandBy(int numToAdd);

        /// <summary>
        /// Shrinks the MemoryPool by removing a given number of elements
        /// This bypasses the configured expansion method (OneAtATime or Doubling)
        /// </summary>
        /// <param name="numToRemove">The amount of items to remove from the pool</param>
        void ShrinkBy(int numToRemove);

        void Despawn(object obj);
    }

    public interface IDespawnableMemoryPool<TValue> : IMemoryPool
    {
        void Despawn(TValue item);
    }

    public interface IMemoryPool<TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn();
    }

    public interface IMemoryPool<in TParam1, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param);
    }

    public interface IMemoryPool<in TParam1, in TParam2, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, in TParam4, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7);
    }

    public interface IMemoryPool<in TParam1, in TParam2, in TParam3, in TParam4, in TParam5, in TParam6, in TParam7, in TParam8, TValue> : IDespawnableMemoryPool<TValue>
    {
        TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/IMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 13b8377ec575a1a44a1028ee324ba17a
timeCreated: 1485699960
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MemoryPool.cs
================================================
namespace Zenject
{
    // Zero parameters
    public class MemoryPool<TValue> : MemoryPoolBase<TValue>, IMemoryPool<TValue>, IFactory<TValue>
    {
        public TValue Spawn()
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TValue item)
        {
            // Optional
        }

        TValue IFactory<TValue>.Create()
        {
            return Spawn();
        }
    }

    // One parameter
    public class MemoryPool<TParam1, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TValue>, IFactory<TParam1, TValue>
    {
        public TValue Spawn(TParam1 param)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param, item);
                }
            }

            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TValue>.Create(TParam1 p1)
        {
            return Spawn(p1);
        }
    }

    // Two parameters
    public class MemoryPool<TParam1, TParam2, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TValue>, IFactory<TParam1, TParam2, TValue>
    {
        public TValue Spawn(TParam1 param1, TParam2 param2)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, item);
                }
            }

            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TValue>.Create(TParam1 p1, TParam2 p2)
        {
            return Spawn(p1, p2);
        }
    }

    // Three parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TValue>, IFactory<TParam1, TParam2, TParam3, TValue>
    {
        public TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TValue>.Create(TParam1 p1, TParam2 p2, TParam3 p3)
        {
            return Spawn(p1, p2, p3);
        }
    }

    // Four parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TValue>
    {
        public TValue Spawn(TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, param4, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TParam4, TValue>.Create(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            return Spawn(p1, p2, p3, p4);
        }
    }

    // Five parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>, IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
    {
        public TValue Spawn(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5)
        {
            var item = GetInternal();
            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, param4, param5, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>.Create(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
            return Spawn(p1, p2, p3, p4, p5);
        }
    }

    // Six parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>,
        IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
    {
        public TValue Spawn(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, param4, param5, param6, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>.Create(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6)
        {
            return Spawn(p1, p2, p3, p4, p5, p6);
        }
    }

    // Seven parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>,
        IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
    {
        public TValue Spawn(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, param4, param5, param6, param7, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>.Create(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7)
        {
            return Spawn(p1, p2, p3, p4, p5, p6, p7);
        }
    }

    // Eight parameters
    public class MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
        : MemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>,
        IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
    {
        public TValue Spawn(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6, TParam7 param7, TParam8 param8)
        {
            var item = GetInternal();

            if (!Container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.Reinitialize", GetType()))
#endif
                {
                    Reinitialize(param1, param2, param3, param4, param5, param6, param7, param8, item);
                }
            }
            return item;
        }

        protected virtual void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TParam8 p8, TValue item)
        {
            // Optional
        }

        TValue IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>.Create(
            TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TParam8 p8)
        {
            return Spawn(p1, p2, p3, p4, p5, p6, p7, p8);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 305d88c8b2af3f2479cb45ffb6f2923c
timeCreated: 1485699960
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MemoryPoolBase.cs
================================================
﻿using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class PoolExceededFixedSizeException : Exception
    {
        public PoolExceededFixedSizeException(string errorMessage)
            : base(errorMessage)
        {
        }
    }

    [Serializable]
    public class MemoryPoolSettings
    {
        public int InitialSize;
        public int MaxSize;
        public PoolExpandMethods ExpandMethod;

        public MemoryPoolSettings()
        {
            InitialSize = 0;
            MaxSize = int.MaxValue;
            ExpandMethod = PoolExpandMethods.OneAtATime;
        }

        public MemoryPoolSettings(int initialSize, int maxSize, PoolExpandMethods expandMethod)
        {
            InitialSize = initialSize;
            MaxSize = maxSize;
            ExpandMethod = expandMethod;
        }

        public static readonly MemoryPoolSettings Default = new MemoryPoolSettings();
    }

    [ZenjectAllowDuringValidation]
    public class MemoryPoolBase<TContract> : IValidatable, IMemoryPool, IDisposable
    {
        Stack<TContract> _inactiveItems;
        IFactory<TContract> _factory;
        MemoryPoolSettings _settings;
        DiContainer _container;

        int _activeCount;

        [Inject]
        void Construct(
            IFactory<TContract> factory,
            DiContainer container,
            [InjectOptional]
            MemoryPoolSettings settings)
        {
            _settings = settings ?? MemoryPoolSettings.Default;
            _factory = factory;
            _container = container;

            _inactiveItems = new Stack<TContract>(_settings.InitialSize);

            if (!container.IsValidating)
            {
                for (int i = 0; i < _settings.InitialSize; i++)
                {
                    _inactiveItems.Push(AllocNew());
                }
            }

#if UNITY_EDITOR
            StaticMemoryPoolRegistry.Add(this);
#endif
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        public IEnumerable<TContract> InactiveItems
        {
            get { return _inactiveItems; }
        }

        public int NumTotal
        {
            get { return NumInactive + NumActive; }
        }

        public int NumInactive
        {
            get { return _inactiveItems.Count; }
        }

        public int NumActive
        {
            get { return _activeCount; }
        }

        public Type ItemType
        {
            get { return typeof(TContract); }
        }

        public void Dispose()
        {
#if UNITY_EDITOR
            StaticMemoryPoolRegistry.Remove(this);
#endif
        }

        void IMemoryPool.Despawn(object item)
        {
            Despawn((TContract)item);
        }

        public void Despawn(TContract item)
        {
            Assert.That(!_inactiveItems.Contains(item),
                "Tried to return an item to pool {0} twice", GetType());

            _activeCount--;

            _inactiveItems.Push(item);

#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
            using (ProfileBlock.Start("{0}.OnDespawned", GetType()))
#endif
            {
                OnDespawned(item);
            }

            if (_inactiveItems.Count > _settings.MaxSize)
            {
                Resize(_settings.MaxSize);
            }
        }

        TContract AllocNew()
        {
            try
            {
                var item = _factory.Create();

                if (!_container.IsValidating)
                {
                    Assert.IsNotNull(item, "Factory '{0}' returned null value when creating via {1}!", _factory.GetType(), GetType());
                    OnCreated(item);
                }

                return item;
            }
            catch (Exception e)
            {
                throw new ZenjectException(
                    "Error during construction of type '{0}' via {1}.Create method!".Fmt(
                        typeof(TContract), GetType()), e);
            }
        }

        void IValidatable.Validate()
        {
            try
            {
                _factory.Create();
            }
            catch (Exception e)
            {
                throw new ZenjectException(
                    "Validation for factory '{0}' failed".Fmt(GetType()), e);
            }
        }

        public void Clear()
        {
            Resize(0);
        }

        public void ShrinkBy(int numToRemove)
        {
            Resize(_inactiveItems.Count - numToRemove);
        }

        public void ExpandBy(int numToAdd)
        {
            Resize(_inactiveItems.Count + numToAdd);
        }

        protected TContract GetInternal()
        {
            if (_inactiveItems.Count == 0)
            {
                ExpandPool();
                Assert.That(!_inactiveItems.IsEmpty());
            }

            var item = _inactiveItems.Pop();
            _activeCount++;
            OnSpawned(item);
            return item;
        }

        public void Resize(int desiredPoolSize)
        {
            if (_inactiveItems.Count == desiredPoolSize)
            {
                return;
            }

            if (_settings.ExpandMethod == PoolExpandMethods.Disabled)
            {
                throw new PoolExceededFixedSizeException(
                    "Pool factory '{0}' attempted resize but pool set to fixed size of '{1}'!"
                    .Fmt(GetType(), _inactiveItems.Count));
            }

            Assert.That(desiredPoolSize >= 0, "Attempted to resize the pool to a negative amount");

            while (_inactiveItems.Count > desiredPoolSize)
            {
                OnDestroyed(_inactiveItems.Pop());
            }

            while (desiredPoolSize > _inactiveItems.Count)
            {
                _inactiveItems.Push(AllocNew());
            }

            Assert.IsEqual(_inactiveItems.Count, desiredPoolSize);
        }

        void ExpandPool()
        {
            switch (_settings.ExpandMethod)
            {
                case PoolExpandMethods.Disabled:
                {
                    throw new PoolExceededFixedSizeException(
                        "Pool factory '{0}' exceeded its fixed size of '{1}'!"
                        .Fmt(GetType(), _inactiveItems.Count));
                }
                case PoolExpandMethods.OneAtATime:
                {
                    ExpandBy(1);
                    break;
                }
                case PoolExpandMethods.Double:
                {
                    if (NumTotal == 0)
                    {
                        ExpandBy(1);
                    }
                    else
                    {
                        ExpandBy(NumTotal);
                    }
                    break;
                }
                default:
                {
                    throw Assert.CreateException();
                }
            }
        }

        protected virtual void OnDespawned(TContract item)
        {
            // Optional
        }

        protected virtual void OnSpawned(TContract item)
        {
            // Optional
        }

        protected virtual void OnCreated(TContract item)
        {
            // Optional
        }

        protected virtual void OnDestroyed(TContract item)
        {
            // Optional
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MemoryPoolBase.cs.meta
================================================
fileFormatVersion: 2
guid: ba9d727a5d866fb46a576ab76012b727
timeCreated: 1485703991
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MonoMemoryPool.cs
================================================
using UnityEngine;

namespace Zenject
{
    // Zero parameters
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TValue> : MemoryPool<TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }

    // One parameter
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TParam1, TValue> : MemoryPool<TParam1, TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }

    // Two parameters
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TParam1, TParam2, TValue>
        : MemoryPool<TParam1, TParam2, TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }

    // Three parameters
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TParam1, TParam2, TParam3, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }

    // Four parameters
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }

    // Five parameters
    // NOTE: For this to work, the given component must be at the root game object of the thing
    // you want to use in a pool
    public class MonoMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        where TValue : Component
    {
        Transform _originalParent;

        [Inject]
        public MonoMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            // Record the original parent which will be set to whatever is used in the UnderTransform method
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnSpawned(TValue item)
        {
            item.gameObject.SetActive(true);
        }

        protected override void OnDespawned(TValue item)
        {
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MonoMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 1334aecb808e6c145a993cb441f43bdb
timeCreated: 1485703991
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MonoPoolableMemoryPool.cs
================================================
using UnityEngine;

namespace Zenject
{
    // Zero parameters
    public class MonoPoolableMemoryPool<TValue> : MemoryPool<TValue>
        where TValue : Component, IPoolable
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned();
        }
    }

    // One parameters
    public class MonoPoolableMemoryPool<TParam1, TValue>
        : MemoryPool<TParam1, TValue>
        where TValue : Component, IPoolable<TParam1>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1);
        }
    }

    // Two parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TValue>
        : MemoryPool<TParam1, TParam2, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2);
        }
    }

    // Three parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3);
        }
    }

    // Four parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3, TParam4>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3, p4);
        }
    }

    // Five parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3, p4, p5);
        }
    }

    // Six parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3, p4, p5, p6);
        }
    }

    // Seven parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3, p4, p5, p6, p7);
        }
    }

    // Eight parameters
    public class MonoPoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
        where TValue : Component, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8>
    {
        Transform _originalParent;

        [Inject]
        public MonoPoolableMemoryPool()
        {
        }

        protected override void OnCreated(TValue item)
        {
            item.gameObject.SetActive(false);
            _originalParent = item.transform.parent;
        }

        protected override void OnDestroyed(TValue item)
        {
            GameObject.Destroy(item.gameObject);
        }

        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
            item.gameObject.SetActive(false);

            if (item.transform.parent != _originalParent)
            {
                item.transform.SetParent(_originalParent, false);
            }
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TParam8 p8, TValue item)
        {
            item.gameObject.SetActive(true);
            item.OnSpawned(p1, p2, p3, p4, p5, p6, p7, p8);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/MonoPoolableMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 5475433f41ca61c4a9095affbf60b848
timeCreated: 1528535898
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/PoolableMemoryPool.cs
================================================
namespace Zenject
{
    // Zero parameters
    public class PoolableMemoryPool<TValue>
        : MemoryPool<TValue>
        where TValue : IPoolable
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TValue item)
        {
            item.OnSpawned();
        }
    }

    // One parameters
    public class PoolableMemoryPool<TParam1, TValue>
        : MemoryPool<TParam1, TValue>
        where TValue : IPoolable<TParam1>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TValue item)
        {
            item.OnSpawned(p1);
        }
    }

    // Two parameters
    public class PoolableMemoryPool<TParam1, TParam2, TValue>
        : MemoryPool<TParam1, TParam2, TValue>
        where TValue : IPoolable<TParam1, TParam2>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TValue item)
        {
            item.OnSpawned(p1, p2);
        }
    }

    // Three parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TValue item)
        {
            item.OnSpawned(p1, p2, p3);
        }
    }

    // Four parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3, TParam4>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TValue item)
        {
            item.OnSpawned(p1, p2, p3, p4);
        }
    }

    // Five parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TValue item)
        {
            item.OnSpawned(p1, p2, p3, p4, p5);
        }
    }

    // Six parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TValue item)
        {
            item.OnSpawned(p1, p2, p3, p4, p5, p6);
        }
    }

    // Seven parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TValue item)
        {
            item.OnSpawned(p1, p2, p3, p4, p5, p6, p7);
        }
    }

    // Eight parameters
    public class PoolableMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
        : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TValue>
        where TValue : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8>
    {
        protected override void OnDespawned(TValue item)
        {
            item.OnDespawned();
        }

        protected override void Reinitialize(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TParam8 p8, TValue item)
        {
            item.OnSpawned(p1, p2, p3, p4, p5, p6, p7, p8);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/PoolableMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 7fa0c435e1800a048ac5f7c53e03472d
timeCreated: 1517205083
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/PoolFactory.cs
================================================
using System;

namespace Zenject
{
    // Here we assume that each spawned object does the work of returning itself to the pool
    // in its own Dispose method
    public class PoolWrapperFactory<T> : IFactory<T>
        where T : IDisposable
    {
        readonly IMemoryPool<T> _pool;

        public PoolWrapperFactory(IMemoryPool<T> pool)
        {
            _pool = pool;
        }

        public T Create()
        {
            return _pool.Spawn();
        }
    }

    public class PoolWrapperFactory<TParam1, TValue> : IFactory<TParam1, TValue>
        where TValue : IDisposable
    {
        readonly IMemoryPool<TParam1, TValue> _pool;

        public PoolWrapperFactory(IMemoryPool<TParam1, TValue> pool)
        {
            _pool = pool;
        }

        public TValue Create(TParam1 arg)
        {
            return _pool.Spawn(arg);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/PoolFactory.cs.meta
================================================
fileFormatVersion: 2
guid: 125bde4ab63a4984484c450640ee1702
timeCreated: 1518946218
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Static.meta
================================================
fileFormatVersion: 2
guid: 28d06bc0b4cdf374ca41d78b0ec5dc0a
folderAsset: yes
timeCreated: 1515014902
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util.meta
================================================
fileFormatVersion: 2
guid: 6214acccd2e0c2044921cc068fb3d0a6
folderAsset: yes
timeCreated: 1520607639
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Static/PoolableStaticMemoryPool.cs
================================================
namespace Zenject
{
    public class PoolableStaticMemoryPool<TValue> : StaticMemoryPool<TValue>
        where TValue : class, IPoolable, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TValue value)
        {
            value.OnSpawned();
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TValue> : StaticMemoryPool<TParam1, TValue>
        where TValue : class, IPoolable<TParam1>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TValue value)
        {
            value.OnSpawned(p1);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TValue> : StaticMemoryPool<TParam1, TParam2, TValue>
        where TValue : class, IPoolable<TParam1, TParam2>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TValue value)
        {
            value.OnSpawned(p1, p2);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TParam3, TValue> : StaticMemoryPool<TParam1, TParam2, TParam3, TValue>
        where TValue : class, IPoolable<TParam1, TParam2, TParam3>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TParam3 p3, TValue value)
        {
            value.OnSpawned(p1, p2, p3);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue> : StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        where TValue : class, IPoolable<TParam1, TParam2, TParam3, TParam4>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TValue value)
        {
            value.OnSpawned(p1, p2, p3, p4);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> : StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        where TValue : class, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TValue value)
        {
            value.OnSpawned(p1, p2, p3, p4, p5);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> : StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        where TValue : class, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TValue value)
        {
            value.OnSpawned(p1, p2, p3, p4, p5, p6);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }

    public class PoolableStaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> : StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        where TValue : class, IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7>, new()
    {
        public PoolableStaticMemoryPool()
            : base(OnSpawned, OnDespawned)
        {
        }

        static void OnSpawned(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7, TValue value)
        {
            value.OnSpawned(p1, p2, p3, p4, p5, p6, p7);
        }

        static void OnDespawned(TValue value)
        {
            value.OnDespawned();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Static/PoolableStaticMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 3bf78918a4d09d44695230ef305b6e1a
timeCreated: 1528618262
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Static/StaticMemoryPool.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class StaticMemoryPoolBaseBase<TValue> : IDespawnableMemoryPool<TValue>, IDisposable
        where TValue : class
    {
        // I also tried using ConcurrentBag instead of Stack + lock here but that performed much much worse
        readonly Stack<TValue> _stack = new Stack<TValue>();

        Action<TValue> _onDespawnedMethod;
        int _activeCount;

#if ZEN_MULTITHREADING
        protected readonly object _locker = new object();
#endif

        public StaticMemoryPoolBaseBase(Action<TValue> onDespawnedMethod)
        {
            _onDespawnedMethod = onDespawnedMethod;

#if UNITY_EDITOR
            StaticMemoryPoolRegistry.Add(this);
#endif
        }

        public Action<TValue> OnDespawnedMethod
        {
            set { _onDespawnedMethod = value; }
        }

        public int NumTotal
        {
            get { return NumInactive + NumActive; }
        }

        public int NumActive
        {
            get
            {
#if ZEN_MULTITHREADING
                lock (_locker)
#endif
                {
                    return _activeCount;
                }
            }
        }

        public int NumInactive
        {
            get
            {
#if ZEN_MULTITHREADING
                lock (_locker)
#endif
                {
                    return _stack.Count;
                }
            }
        }

        public Type ItemType
        {
            get { return typeof(TValue); }
        }

        public void Resize(int desiredPoolSize)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                ResizeInternal(desiredPoolSize);
            }
        }

        // We assume here that we're in a lock
        void ResizeInternal(int desiredPoolSize)
        {
            Assert.That(desiredPoolSize >= 0, "Attempted to resize the pool to a negative amount");

            while (_stack.Count > desiredPoolSize)
            {
                _stack.Pop();
            }

            while (desiredPoolSize > _stack.Count)
            {
                _stack.Push(Alloc());
            }

            Assert.IsEqual(_stack.Count, desiredPoolSize);
        }

        public void Dispose()
        {
#if UNITY_EDITOR
            StaticMemoryPoolRegistry.Remove(this);
#endif
        }

        public void ClearActiveCount()
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                _activeCount = 0;
            }
        }

        public void Clear()
        {
            Resize(0);
        }

        public void ShrinkBy(int numToRemove)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                ResizeInternal(_stack.Count - numToRemove);
            }
        }

        public void ExpandBy(int numToAdd)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                ResizeInternal(_stack.Count + numToAdd);
            }
        }

        // We assume here that we're in a lock
        protected TValue SpawnInternal()
        {
            TValue element;

            if (_stack.Count == 0)
            {
                element = Alloc();
            }
            else
            {
                element = _stack.Pop();
            }

            _activeCount++;
            return element;
        }

        void IMemoryPool.Despawn(object item)
        {
            Despawn((TValue)item);
        }

        public void Despawn(TValue element)
        {
            if (_onDespawnedMethod != null)
            {
                _onDespawnedMethod(element);
            }

#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                Assert.That(!_stack.Contains(element), "Attempted to despawn element twice!");

                _activeCount--;
                _stack.Push(element);
            }
        }

        protected abstract TValue Alloc();
    }

    [NoReflectionBaking]
    public abstract class StaticMemoryPoolBase<TValue> : StaticMemoryPoolBaseBase<TValue>
        where TValue : class, new()
    {
        public StaticMemoryPoolBase(Action<TValue> onDespawnedMethod)
            : base(onDespawnedMethod)
        {
        }

        protected override TValue Alloc()
        {
            return new TValue();
        }
    }

    // Zero parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TValue>
        where TValue : class, new()
    {
        Action<TValue> _onSpawnMethod;

        public StaticMemoryPool(
            Action<TValue> onSpawnMethod = null, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            _onSpawnMethod = onSpawnMethod;
        }

        public Action<TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn()
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(item);
                }

                return item;
            }
        }
    }

    // One parameter

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TValue>
        where TValue : class, new()
    {
        Action<TParam1, TValue> _onSpawnMethod;

        public StaticMemoryPool(
            Action<TParam1, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public Action<TParam1, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 param)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(param, item);
                }

                return item;
            }
        }
    }

    // Two parameter

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TValue>
        where TValue : class, new()
    {
        Action<TParam1, TParam2, TValue> _onSpawnMethod;

        public StaticMemoryPool(
            Action<TParam1, TParam2, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public Action<TParam1, TParam2, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, item);
                }

                return item;
            }
        }
    }

    // Three parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TParam3, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TValue>
        where TValue : class, new()
    {
        Action<TParam1, TParam2, TParam3, TValue> _onSpawnMethod;

        public StaticMemoryPool(
            Action<TParam1, TParam2, TParam3, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public Action<TParam1, TParam2, TParam3, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2, TParam3 p3)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, p3, item);
                }

                return item;
            }
        }
    }

    // Four parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue>
        where TValue : class, new()
    {
#if !NET_4_6
        ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TValue> _onSpawnMethod;

        public StaticMemoryPool(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, p3, p4, item);
                }

                return item;
            }
        }
    }

    // Five parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue>
        where TValue : class, new()
    {
#if !NET_4_6
        ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> _onSpawnMethod;

        public StaticMemoryPool(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, p3, p4, p5, item);
                }

                return item;
            }
        }
    }

    // Six parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue>
        where TValue : class, new()
    {
#if !NET_4_6
        ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> _onSpawnMethod;

        public StaticMemoryPool(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, p3, p4, p5, p6, item);
                }

                return item;
            }
        }
    }

    // Seven parameters

    [NoReflectionBaking]
    public class StaticMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> : StaticMemoryPoolBase<TValue>, IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue>
        where TValue : class, new()
    {
#if !NET_4_6
        ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> _onSpawnMethod;

        public StaticMemoryPool(
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> onSpawnMethod, Action<TValue> onDespawnedMethod = null)
            : base(onDespawnedMethod)
        {
            // What's the point of having a param otherwise?
            Assert.IsNotNull(onSpawnMethod);
            _onSpawnMethod = onSpawnMethod;
        }

        public
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> OnSpawnMethod
        {
            set { _onSpawnMethod = value; }
        }

        public TValue Spawn(TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7)
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var item = SpawnInternal();

                if (_onSpawnMethod != null)
                {
                    _onSpawnMethod(p1, p2, p3, p4, p5, p6, p7, item);
                }

                return item;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Static/StaticMemoryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 56b2eb81b3385fd47a0500abeac7b60e
timeCreated: 1528024394
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/ArrayPool.cs
================================================
using System.Collections.Generic;

namespace Zenject
{
    public class ArrayPool<T> : StaticMemoryPoolBaseBase<T[]>
    {
        readonly int _length;

        public ArrayPool(int length)
            : base(OnDespawned)
        {
            _length = length;
        }

        static void OnDespawned(T[] arr)
        {
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = default(T);
            }
        }

        public T[] Spawn()
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                return SpawnInternal();
            }
        }

        protected override T[] Alloc()
        {
            return new T[_length];
        }

        static readonly Dictionary<int, ArrayPool<T>> _pools =
            new Dictionary<int, ArrayPool<T>>();

        public static ArrayPool<T> GetPool(int length)
        {
            ArrayPool<T> pool;

            if (!_pools.TryGetValue(length, out pool))
            {
                pool = new ArrayPool<T>(length);
                _pools.Add(length, pool);
            }

            return pool;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/ArrayPool.cs.meta
================================================
fileFormatVersion: 2
guid: 891d6e713fcfdfc4a95271fdee018e94
timeCreated: 1537870146
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/DictionaryPool.cs
================================================
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    public class DictionaryPool<TKey, TValue> : StaticMemoryPool<Dictionary<TKey, TValue>>
    {
        static DictionaryPool<TKey, TValue> _instance = new DictionaryPool<TKey, TValue>();

        public DictionaryPool()
        {
            OnSpawnMethod = OnSpawned;
            OnDespawnedMethod = OnDespawned;
        }

        public static DictionaryPool<TKey, TValue> Instance
        {
            get { return _instance; }
        }

        static void OnSpawned(Dictionary<TKey, TValue> items)
        {
            Assert.That(items.IsEmpty());
        }

        static void OnDespawned(Dictionary<TKey, TValue> items)
        {
            items.Clear();
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/DictionaryPool.cs.meta
================================================
fileFormatVersion: 2
guid: 031a0490d1684424e9e33b22106cb178
timeCreated: 1520670682
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/HashSetPool.cs
================================================
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    public class HashSetPool<T> : StaticMemoryPool<HashSet<T>>
    {
        static HashSetPool<T> _instance = new HashSetPool<T>();

        public HashSetPool()
        {
            OnSpawnMethod = OnSpawned;
            OnDespawnedMethod = OnDespawned;
        }

        public static HashSetPool<T> Instance
        {
            get { return _instance; }
        }

        static void OnSpawned(HashSet<T> items)
        {
            Assert.That(items.IsEmpty());
        }

        static void OnDespawned(HashSet<T> items)
        {
            items.Clear();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/HashSetPool.cs.meta
================================================
fileFormatVersion: 2
guid: 89c66035001289a4199cb04e17d0bc28
timeCreated: 1520670682
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/ListPool.cs
================================================
using System.Collections.Generic;

namespace Zenject
{
    public class ListPool<T> : StaticMemoryPool<List<T>>
    {
        static ListPool<T> _instance = new ListPool<T>();

        public ListPool()
        {
            OnDespawnedMethod = OnDespawned;
        }

        public static ListPool<T> Instance
        {
            get { return _instance; }
        }

        void OnDespawned(List<T> list)
        {
            list.Clear();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/ListPool.cs.meta
================================================
fileFormatVersion: 2
guid: f30364d1ac067164ea56051cd000b49f
timeCreated: 1520670682
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/PoolCleanupChecker.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;

namespace Zenject
{
    // If you want to ensure that all items are always returned to the pool, include the following
    // in an installer
    // Container.BindInterfacesTo<PoolCleanupChecker>().AsSingle()
    public class PoolCleanupChecker : ILateDisposable
    {
        readonly List<IMemoryPool> _poolFactories;
        readonly List<Type> _ignoredPools;

        public PoolCleanupChecker(
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<IMemoryPool> poolFactories,
            [Inject(Source = InjectSources.Local)]
            List<Type> ignoredPools)
        {
            _poolFactories = poolFactories;
            _ignoredPools = ignoredPools;

            Assert.That(ignoredPools.All(x => x.DerivesFrom<IMemoryPool>()));
        }

        public void LateDispose()
        {
            foreach (var pool in _poolFactories)
            {
                if (!_ignoredPools.Contains(pool.GetType()))
                {
                    Assert.IsEqual(pool.NumActive, 0,
                        "Found active objects in pool '{0}' during dispose.  Did you forget to despawn an object of type '{1}'?".Fmt(pool.GetType(), pool.ItemType));
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/PoolCleanupChecker.cs.meta
================================================
fileFormatVersion: 2
guid: 69aee89274cd16b48aa790ddd5a061d2
timeCreated: 1520670682
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/StaticMemoryPoolRegistry.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
#if UNITY_EDITOR
    public static class StaticMemoryPoolRegistry
    {
        public static event Action<IMemoryPool> PoolAdded = delegate {};
        public static event Action<IMemoryPool> PoolRemoved = delegate {};

        readonly static List<IMemoryPool> _pools = new List<IMemoryPool>();

        public static IEnumerable<IMemoryPool> Pools
        {
            get { return _pools; }
        }

        public static void Add(IMemoryPool memoryPool)
        {
            _pools.Add(memoryPool);
            PoolAdded(memoryPool);
        }

        public static void Remove(IMemoryPool memoryPool)
        {
            _pools.RemoveWithConfirm(memoryPool);
            PoolRemoved(memoryPool);
        }
    }
#endif
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Factories/Pooling/Util/StaticMemoryPoolRegistry.cs.meta
================================================
fileFormatVersion: 2
guid: cccc66ed95242b544bd7f501f0ecb89b
timeCreated: 1521390236
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/InjectContext.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class InjectContext : IDisposable
    {
        BindingId _bindingId;
        Type _objectType;
        InjectContext _parentContext;
        object _objectInstance;
        string _memberName;
        bool _optional;
        InjectSources _sourceType;
        object _fallBackValue;
        object _concreteIdentifier;
        DiContainer _container;

        public InjectContext()
        {
            _bindingId = new BindingId();
            Reset();
        }

        public InjectContext(DiContainer container, Type memberType)
            : this()
        {
            Container = container;
            MemberType = memberType;
        }

        public InjectContext(DiContainer container, Type memberType, object identifier)
            : this(container, memberType)
        {
            Identifier = identifier;
        }

        public InjectContext(DiContainer container, Type memberType, object identifier, bool optional)
            : this(container, memberType, identifier)
        {
            Optional = optional;
        }

        public void Dispose()
        {
            ZenPools.DespawnInjectContext(this);
        }

        public void Reset()
        {
            _objectType = null;
            _parentContext = null;
            _objectInstance = null;
            _memberName = "";
            _optional = false;
            _sourceType = InjectSources.Any;
            _fallBackValue = null;
            _container = null;
            _bindingId.Type = null;
            _bindingId.Identifier = null;
        }

        public BindingId BindingId
        {
            get { return _bindingId; }
        }

        // The type of the object which is having its members injected
        // NOTE: This is null for root calls to Resolve<> or Instantiate<>
        public Type ObjectType
        {
            get { return _objectType; }
            set { _objectType = value; }
        }

        // Parent context that triggered the creation of ObjectType
        // This can be used for very complex conditions using parent info such as identifiers, types, etc.
        // Note that ParentContext.MemberType is not necessarily the same as ObjectType,
        // since the ObjectType could be a derived type from ParentContext.MemberType
        public InjectContext ParentContext
        {
            get { return _parentContext; }
            set { _parentContext = value; }
        }

        // The instance which is having its members injected
        // Note that this is null when injecting into the constructor
        public object ObjectInstance
        {
            get { return _objectInstance; }
            set { _objectInstance = value; }
        }

        // Identifier - most of the time this is null
        // It will match 'foo' in this example:
        //      ... In an installer somewhere:
        //          Container.Bind<Foo>("foo").AsSingle();
        //      ...
        //      ... In a constructor:
        //          public Foo([Inject(Id = "foo") Foo foo)
        public object Identifier
        {
            get { return _bindingId.Identifier; }
            set { _bindingId.Identifier = value; }
        }

        // The constructor parameter name, or field name, or property name
        public string MemberName
        {
            get { return _memberName; }
            set { _memberName = value; }
        }

        // The type of the constructor parameter, field or property
        public Type MemberType
        {
            get { return _bindingId.Type; }
            set { _bindingId.Type = value; }
        }

        // When optional, null is a valid value to be returned
        public bool Optional
        {
            get { return _optional; }
            set { _optional = value; }
        }

        // When set to true, this will only look up dependencies in the local container and will not
        // search in parent containers
        public InjectSources SourceType
        {
            get { return _sourceType; }
            set { _sourceType = value; }
        }

        public object ConcreteIdentifier
        {
            get { return _concreteIdentifier; }
            set { _concreteIdentifier = value; }
        }

        // When optional, this is used to provide the value
        public object FallBackValue
        {
            get { return _fallBackValue; }
            set { _fallBackValue = value; }
        }

        // The container used for this injection
        public DiContainer Container
        {
            get { return _container; }
            set { _container = value; }
        }

        public IEnumerable<InjectContext> ParentContexts
        {
            get
            {
                if (ParentContext == null)
                {
                    yield break;
                }

                yield return ParentContext;

                foreach (var context in ParentContext.ParentContexts)
                {
                    yield return context;
                }
            }
        }

        public IEnumerable<InjectContext> ParentContextsAndSelf
        {
            get
            {
                yield return this;

                foreach (var context in ParentContexts)
                {
                    yield return context;
                }
            }
        }

        // This will return the types of all the objects that are being injected
        // So if you have class Foo which has constructor parameter of type IBar,
        // and IBar resolves to Bar, this will be equal to (Bar, Foo)
        public IEnumerable<Type> AllObjectTypes
        {
            get
            {
                foreach (var context in ParentContextsAndSelf)
                {
                    if (context.ObjectType != null)
                    {
                        yield return context.ObjectType;
                    }
                }
            }
        }

        public InjectContext CreateSubContext(Type memberType)
        {
            return CreateSubContext(memberType, null);
        }

        public InjectContext CreateSubContext(Type memberType, object identifier)
        {
            var subContext = new InjectContext();

            subContext.ParentContext = this;
            subContext.Identifier = identifier;
            subContext.MemberType = memberType;

            // Clear these
            subContext.ConcreteIdentifier = null;
            subContext.MemberName = "";
            subContext.FallBackValue = null;

            // Inherit these ones by default
            subContext.ObjectType = ObjectType;
            subContext.ObjectInstance = ObjectInstance;
            subContext.Optional = Optional;
            subContext.SourceType = SourceType;
            subContext.Container = Container;

            return subContext;
        }

        public InjectContext Clone()
        {
            var clone = new InjectContext();

            clone.ObjectType = ObjectType;
            clone.ParentContext = ParentContext;
            clone.ConcreteIdentifier = ConcreteIdentifier;
            clone.ObjectInstance = ObjectInstance;
            clone.Identifier = Identifier;
            clone.MemberType = MemberType;
            clone.MemberName = MemberName;
            clone.Optional = Optional;
            clone.SourceType = SourceType;
            clone.FallBackValue = FallBackValue;
            clone.Container = Container;

            return clone;
        }

        // This is very useful to print out for debugging purposes
        public string GetObjectGraphString()
        {
            var result = new StringBuilder();

            foreach (var context in ParentContextsAndSelf.Reverse())
            {
                if (context.ObjectType == null)
                {
                    continue;
                }

                result.AppendLine(context.ObjectType.PrettyName());
            }

            return result.ToString();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/InjectContext.cs.meta
================================================
fileFormatVersion: 2
guid: 2005ce29739317b48bcc3c06695da848
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/InjectUtil.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ModestTree;

namespace Zenject
{
    [DebuggerStepThrough]
    public struct TypeValuePair
    {
        public Type Type;
        public object Value;

        public TypeValuePair(Type type, object value)
        {
            Type = type;
            Value = value;
        }
    }

    [DebuggerStepThrough]
    public static class InjectUtil
    {
        public static List<TypeValuePair> CreateArgList(IEnumerable<object> args)
        {
            Assert.That(!args.ContainsItem(null),
                "Cannot include null values when creating a zenject argument list because zenject has no way of deducing the type from a null value.  If you want to allow null, use the Explicit form.");
            return args.Select(x => new TypeValuePair(x.GetType(), x)).ToList();
        }

        public static TypeValuePair CreateTypePair<T>(T param)
        {
            // Use the most derived type that we can find here
            return new TypeValuePair(
                param == null ? typeof(T) : param.GetType(), param);
        }

        public static List<TypeValuePair> CreateArgListExplicit<T>(T param)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param)
            };
        }

        public static List<TypeValuePair> CreateArgListExplicit<TParam1, TParam2>(TParam1 param1, TParam2 param2)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param1),
                CreateTypePair(param2)
            };
        }

        public static List<TypeValuePair> CreateArgListExplicit<TParam1, TParam2, TParam3>(
            TParam1 param1, TParam2 param2, TParam3 param3)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param1),
                CreateTypePair(param2),
                CreateTypePair(param3)
            };
        }

        public static List<TypeValuePair> CreateArgListExplicit<TParam1, TParam2, TParam3, TParam4>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param1),
                CreateTypePair(param2),
                CreateTypePair(param3),
                CreateTypePair(param4)
            };
        }

        public static List<TypeValuePair> CreateArgListExplicit<TParam1, TParam2, TParam3, TParam4, TParam5>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param1),
                CreateTypePair(param2),
                CreateTypePair(param3),
                CreateTypePair(param4),
                CreateTypePair(param5)
            };
        }

        public static List<TypeValuePair> CreateArgListExplicit<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(
            TParam1 param1, TParam2 param2, TParam3 param3, TParam4 param4, TParam5 param5, TParam6 param6)
        {
            return new List<TypeValuePair>
            {
                CreateTypePair(param1),
                CreateTypePair(param2),
                CreateTypePair(param3),
                CreateTypePair(param4),
                CreateTypePair(param5),
                CreateTypePair(param6)
            };
        }

        // Find the first match with the given type and remove it from the list
        // Return true if it was removed
        public static bool PopValueWithType(
            List<TypeValuePair> extraArgMap, Type injectedFieldType, out object value)
        {
            for (int i = 0; i < extraArgMap.Count; i++)
            {
                var arg = extraArgMap[i];

                if (arg.Type.DerivesFromOrEqual(injectedFieldType))
                {
                    value = arg.Value;
                    extraArgMap.RemoveAt(i);
                    return true;
                }
            }

            value = injectedFieldType.GetDefaultValue();
            return false;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/InjectUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 0ebfddbd9452a9c4cb6c9dfe7a25ea53
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/LazyInject.cs
================================================
using ModestTree;

namespace Zenject
{
    [ZenjectAllowDuringValidation]
    [NoReflectionBaking]
    public class LazyInject<T> : IValidatable
    {
        readonly DiContainer _container;
        readonly InjectContext _context;

        bool _hasValue;
        T _value;

        public LazyInject(DiContainer container, InjectContext context)
        {
            Assert.DerivesFromOrEqual<T>(context.MemberType);

            _container = container;
            _context = context;
        }

        void IValidatable.Validate()
        {
            _container.Resolve(_context);
        }

        public T Value
        {
            get
            {
                if (!_hasValue)
                {
                    _value = (T)_container.Resolve(_context);
                    _hasValue = true;
                }

                return _value;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Injection/LazyInject.cs.meta
================================================
fileFormatVersion: 2
guid: 54883063c774a244c898edbc91b859a0
timeCreated: 1529237555
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts.meta
================================================
fileFormatVersion: 2
guid: fc41c06067fc1d4479c3b85aa2707cfb
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/IInstaller.cs
================================================
namespace Zenject
{
    // We extract the interface so that monobehaviours can be installers
    public interface IInstaller
    {
        void InstallBindings();

        bool IsEnabled
        {
            get;
        }
    }

}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/IInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: 65a9d43edcbe33640989f12f980de5d1
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Installer.cs
================================================
namespace Zenject
{
    //
    // I'd recommmend using Installer<> instead, and then always use the approach
    // of calling `MyInstaller.Install(Container)`
    // This way, if you want to add strongly typed parameters later you can do this
    // by deriving from a different Installer<> base class
    //
    public abstract class Installer : InstallerBase
    {
    }

    //
    // Derive from this class then install like this:
    //     FooInstaller.Install(Container);
    //
    public abstract class Installer<TDerived> : InstallerBase
        where TDerived : Installer<TDerived>
    {
        public static void Install(DiContainer container)
        {
            container.Instantiate<TDerived>().InstallBindings();
        }
    }

    // Use these versions to pass parameters to your installer

    public abstract class Installer<TParam1, TDerived> : InstallerBase
        where TDerived : Installer<TParam1, TDerived>
    {
        public static void Install(DiContainer container, TParam1 p1)
        {
            container.InstantiateExplicit<TDerived>(
                InjectUtil.CreateArgListExplicit(p1)).InstallBindings();
        }
    }

    public abstract class Installer<TParam1, TParam2, TDerived> : InstallerBase
        where TDerived : Installer<TParam1, TParam2, TDerived>
    {
        public static void Install(DiContainer container, TParam1 p1, TParam2 p2)
        {
            container.InstantiateExplicit<TDerived>(
                InjectUtil.CreateArgListExplicit(p1, p2)).InstallBindings();
        }
    }

    public abstract class Installer<TParam1, TParam2, TParam3, TDerived> : InstallerBase
        where TDerived : Installer<TParam1, TParam2, TParam3, TDerived>
    {
        public static void Install(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            container.InstantiateExplicit<TDerived>(
                InjectUtil.CreateArgListExplicit(p1, p2, p3)).InstallBindings();
        }
    }

    public abstract class Installer<TParam1, TParam2, TParam3, TParam4, TDerived> : InstallerBase
        where TDerived : Installer<TParam1, TParam2, TParam3, TParam4, TDerived>
    {
        public static void Install(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            container.InstantiateExplicit<TDerived>(
                InjectUtil.CreateArgListExplicit(p1, p2, p3, p4)).InstallBindings();
        }
    }

    public abstract class Installer<TParam1, TParam2, TParam3, TParam4, TParam5, TDerived> : InstallerBase
        where TDerived : Installer<TParam1, TParam2, TParam3, TParam4, TParam5, TDerived>
    {
        public static void Install(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
            container.InstantiateExplicit<TDerived>(
                InjectUtil.CreateArgListExplicit(p1, p2, p3, p4, p5)).InstallBindings();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Installer.cs.meta
================================================
fileFormatVersion: 2
guid: 743eef94d86c79e4189b311a7c7528ce
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/InstallerBase.cs
================================================
namespace Zenject
{
    public abstract class InstallerBase : IInstaller
    {
        [Inject]
        DiContainer _container = null;

        protected DiContainer Container
        {
            get { return _container; }
        }

        public virtual bool IsEnabled
        {
            get { return true; }
        }

        public abstract void InstallBindings();
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/InstallerBase.cs.meta
================================================
fileFormatVersion: 2
guid: d908209e11d07744483c5fea3b406f33
timeCreated: 1465520282
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/MonoInstaller.cs
================================================
#if !NOT_UNITY3D

using ModestTree;

namespace Zenject
{
    // We'd prefer to make this abstract but Unity 5.3.5 has a bug where references
    // can get lost during compile errors for classes that are abstract
    public class MonoInstaller : MonoInstallerBase
    {
    }

    //
    // Derive from this class instead to install like this:
    //     FooInstaller.InstallFromResource(Container);
    // Or
    //     FooInstaller.InstallFromResource("My/Path/ToPrefab", Container);
    //
    // (Instead of needing to add the MonoInstaller via inspector)
    //
    // This approach is needed if you want to pass in strongly parameters to it from
    // another installer
    public class MonoInstaller<TDerived> : MonoInstaller
        where TDerived : MonoInstaller<TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container)
        {
            return InstallFromResource(resourcePath, container, new object[0]);
        }

        public static TDerived InstallFromResource(DiContainer container, object[] extraArgs)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, extraArgs);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, object[] extraArgs)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.Inject(installer, extraArgs);
            installer.InstallBindings();
            return installer;
        }
    }

    public class MonoInstaller<TParam1, TDerived> : MonoInstallerBase
        where TDerived : MonoInstaller<TParam1, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1));
            installer.InstallBindings();
            return installer;
        }
    }

    public class MonoInstaller<TParam1, TParam2, TDerived> : MonoInstallerBase
        where TDerived : MonoInstaller<TParam1, TParam2, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2));
            installer.InstallBindings();
            return installer;
        }
    }

    public class MonoInstaller<TParam1, TParam2, TParam3, TDerived> : MonoInstallerBase
        where TDerived : MonoInstaller<TParam1, TParam2, TParam3, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2, p3);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2, p3));
            installer.InstallBindings();
            return installer;
        }
    }

    public class MonoInstaller<TParam1, TParam2, TParam3, TParam4, TDerived> : MonoInstallerBase
        where TDerived : MonoInstaller<TParam1, TParam2, TParam3, TParam4, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2, p3, p4);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2, p3, p4));
            installer.InstallBindings();
            return installer;
        }
    }

    public class MonoInstaller<TParam1, TParam2, TParam3, TParam4, TParam5, TDerived> : MonoInstallerBase
        where TDerived : MonoInstaller<TParam1, TParam2, TParam3, TParam4, TParam5, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
            return InstallFromResource(MonoInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2, p3, p4, p5);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
            var installer = MonoInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2, p3, p4, p5));
            installer.InstallBindings();
            return installer;
        }
    }

    public static class MonoInstallerUtil
    {
        public static string GetDefaultResourcePath<TInstaller>()
            where TInstaller : MonoInstallerBase
        {
            return "Installers/" + typeof(TInstaller).PrettyName();
        }

        public static TInstaller CreateInstaller<TInstaller>(
            string resourcePath, DiContainer container)
            where TInstaller : MonoInstallerBase
        {
            bool shouldMakeActive;
            var gameObj = container.CreateAndParentPrefabResource(
                resourcePath, GameObjectCreationParameters.Default, null, out shouldMakeActive);

            if (shouldMakeActive && !container.IsValidating)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                {
                    gameObj.SetActive(true);
                }
            }

            var installers = gameObj.GetComponentsInChildren<TInstaller>();

            Assert.That(installers.Length == 1,
                "Could not find unique MonoInstaller with type '{0}' on prefab '{1}'", typeof(TInstaller), gameObj.name);

            return installers[0];
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/MonoInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: 724ff9f6c80e0b044b7db58730dc6075
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/MonoInstallerBase.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Diagnostics;
using UnityEngine;

namespace Zenject
{
    // We'd prefer to make this abstract but Unity 5.3.5 has a bug where references
    // can get lost during compile errors for classes that are abstract
    [DebuggerStepThrough]
    public class MonoInstallerBase : MonoBehaviour, IInstaller
    {
        [Inject]
        protected DiContainer Container
        {
            get; set;
        }

        public virtual bool IsEnabled
        {
            get { return enabled; }
        }

        public virtual void Start()
        {
            // Define this method so we expose the enabled check box
        }

        public virtual void InstallBindings()
        {
            throw new NotImplementedException();
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/MonoInstallerBase.cs.meta
================================================
fileFormatVersion: 2
guid: 93d53e91e1ef3484a99feb7aa58f2b63
timeCreated: 1465520769
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ScriptableObjectInstaller.cs
================================================
#if !NOT_UNITY3D

using ModestTree;
using UnityEngine;

namespace Zenject
{
    // We'd prefer to make this abstract but Unity 5.3.5 has a bug where references
    // can get lost during compile errors for classes that are abstract
    public class ScriptableObjectInstaller : ScriptableObjectInstallerBase
    {
    }

    //
    // Derive from this class instead to install like this:
    //     FooInstaller.InstallFromResource(Container);
    // Or
    //     FooInstaller.InstallFromResource("My/Path/ToScriptableObjectInstance", Container);
    //
    // (Instead of needing to add the ScriptableObjectInstaller directly via inspector)
    //
    // This approach is needed if you want to pass in strongly typed runtime parameters too it
    //
    public class ScriptableObjectInstaller<TDerived> : ScriptableObjectInstaller
        where TDerived : ScriptableObjectInstaller<TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container)
        {
            return InstallFromResource(
                ScriptableObjectInstallerUtil.GetDefaultResourcePath<TDerived>(), container);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container)
        {
            var installer = ScriptableObjectInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.Inject(installer);
            installer.InstallBindings();
            return installer;
        }
    }

    public class ScriptableObjectInstaller<TParam1, TDerived> : ScriptableObjectInstallerBase
        where TDerived : ScriptableObjectInstaller<TParam1, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1)
        {
            return InstallFromResource(
                ScriptableObjectInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1)
        {
            var installer = ScriptableObjectInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1));
            installer.InstallBindings();
            return installer;
        }
    }

    public class ScriptableObjectInstaller<TParam1, TParam2, TDerived> : ScriptableObjectInstallerBase
        where TDerived : ScriptableObjectInstaller<TParam1, TParam2, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2)
        {
            return InstallFromResource(
                ScriptableObjectInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2)
        {
            var installer = ScriptableObjectInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2));
            installer.InstallBindings();
            return installer;
        }
    }

    public class ScriptableObjectInstaller<TParam1, TParam2, TParam3, TDerived> : ScriptableObjectInstallerBase
        where TDerived : ScriptableObjectInstaller<TParam1, TParam2, TParam3, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            return InstallFromResource(
                ScriptableObjectInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2, p3);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            var installer = ScriptableObjectInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2, p3));
            installer.InstallBindings();
            return installer;
        }
    }

    public class ScriptableObjectInstaller<TParam1, TParam2, TParam3, TParam4, TDerived> : ScriptableObjectInstallerBase
        where TDerived : ScriptableObjectInstaller<TParam1, TParam2, TParam3, TParam4, TDerived>
    {
        public static TDerived InstallFromResource(DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            return InstallFromResource(
                ScriptableObjectInstallerUtil.GetDefaultResourcePath<TDerived>(), container, p1, p2, p3, p4);
        }

        public static TDerived InstallFromResource(string resourcePath, DiContainer container, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            var installer = ScriptableObjectInstallerUtil.CreateInstaller<TDerived>(resourcePath, container);
            container.InjectExplicit(installer, InjectUtil.CreateArgListExplicit(p1, p2, p3, p4));
            installer.InstallBindings();
            return installer;
        }
    }

    public static class ScriptableObjectInstallerUtil
    {
        public static string GetDefaultResourcePath<TInstaller>()
            where TInstaller : ScriptableObjectInstallerBase
        {
            return "Installers/" + typeof(TInstaller).PrettyName();
        }

        public static TInstaller CreateInstaller<TInstaller>(
            string resourcePath, DiContainer container)
            where TInstaller : ScriptableObjectInstallerBase
        {
            var installers = Resources.LoadAll(resourcePath);

            Assert.That(installers.Length == 1,
                "Could not find unique ScriptableObjectInstaller with type '{0}' at resource path '{1}'", typeof(TInstaller), resourcePath);

            var installer = installers[0];

            Assert.That(installer is TInstaller,
                "Expected to find installer with type '{0}' at resource path '{1}'", typeof(TInstaller), resourcePath);

            return (TInstaller)installer;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ScriptableObjectInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: 00b9d7602aaf02748aa93779bbf29799
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ScriptableObjectInstallerBase.cs
================================================
#if !NOT_UNITY3D

using System;
using UnityEngine;

namespace Zenject
{
    // We'd prefer to make this abstract but Unity 5.3.5 has a bug where references
    // can get lost during compile errors for classes that are abstract
    public class ScriptableObjectInstallerBase : ScriptableObject, IInstaller
    {
        [Inject]
        DiContainer _container = null;

        protected DiContainer Container
        {
            get { return _container; }
        }

        bool IInstaller.IsEnabled
        {
            get { return true; }
        }

        public virtual void InstallBindings()
        {
            throw new NotImplementedException();
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ScriptableObjectInstallerBase.cs.meta
================================================
fileFormatVersion: 2
guid: 97c39aeade32bd54c8754bc9d6da25ab
timeCreated: 1465523215
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ZenjectBinding.cs
================================================
#if !NOT_UNITY3D

using UnityEngine;
using UnityEngine.Serialization;

namespace Zenject
{
    public class ZenjectBinding : MonoBehaviour
    {
        [Tooltip("The component to add to the Zenject container")]
        [SerializeField]
        Component[] _components = null;

        [Tooltip("Note: This value is optional and can be ignored in most cases.  This can be useful to differentiate multiple bindings of the same type.  For example, if you have multiple cameras in your scene, you can 'name' them by giving each one a different identifier.  For your main camera you might call it 'Main' then any class can refer to it by using an attribute like [Inject(Id = 'Main')]")]
        [SerializeField]
        string _identifier = string.Empty;

        [Tooltip("When set, this will bind the given components to the SceneContext.  It can be used as a shortcut to explicitly dragging the SceneContext into the Context field.  This is useful when using ZenjectBinding inside GameObjectContext.  If your ZenjectBinding is for a component that is not underneath GameObjectContext then it is not necessary to check this")]
        [SerializeField]
        bool _useSceneContext = false;

        [Tooltip("Note: This value is optional and can be ignored in most cases.  This value will determine what container the component gets added to.  If unset, the component will be bound on the most 'local' context.  In most cases this will be the SceneContext, unless this component is underneath a GameObjectContext, or ProjectContext, in which case it will bind to that instead by default.  You can also override this default by providing the Context directly.  This can be useful if you want to bind something that is inside a GameObjectContext to the SceneContext container.")]
        [SerializeField]
        [FormerlySerializedAs("_compositionRoot")]
        Context _context = null;

        [Tooltip("This value is used to determine how to bind this component.  When set to 'Self' is equivalent to calling Container.FromInstance inside an installer. When set to 'AllInterfaces' this is equivalent to calling 'Container.BindInterfaces<MyMonoBehaviour>().ToInstance', and similarly for InterfacesAndSelf")]
        [SerializeField]
        BindTypes _bindType = BindTypes.Self;

        public bool UseSceneContext
        {
            get { return _useSceneContext; }
        }

        public Context Context
        {
            get { return _context; }
            set { _context = value; }
        }

        public Component[] Components
        {
            get { return _components; }
        }

        public string Identifier
        {
            get { return _identifier; }
        }

        public BindTypes BindType
        {
            get { return _bindType; }
        }

        public void Start()
        {
            // Define this method so we expose the enabled check box
        }

        public enum BindTypes
        {
            Self,
            AllInterfaces,
            AllInterfacesAndSelf,
            BaseType
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ZenjectBinding.cs.meta
================================================
fileFormatVersion: 2
guid: 0166d8ff8d905b048b2448179e1f5d11
timeCreated: 1454288321
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData:
  assetBundleName:
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ZenjectManagersInstaller.cs
================================================

namespace Zenject
{
    // This is installed by default in ProjectContext, however, if you are using Zenject outside
    // of Unity then you might want to call this
    //
    // In this case though, you will have to manually call InitializableManager.Initialize,
    // DisposableManager.Dispose, TickableManager.Tick, etc. when appropriate for the environment
    // you are working in
    //
    // You might also want to use this installer in a ZenjectUnitTestFixture
    public class ZenjectManagersInstaller : Installer<ZenjectManagersInstaller>
    {
        public override void InstallBindings()
        {
            Container.Bind(typeof(TickableManager), typeof(InitializableManager), typeof(DisposableManager))
                .ToSelf().AsSingle().CopyIntoAllSubContainers();
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/ZenjectManagersInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: b05e95f8fed82b244b78a5e2df541713
timeCreated: 1529046908
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/Context.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine;
using UnityEngine.Serialization;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Zenject
{
    public abstract class Context : MonoBehaviour
    {
        [SerializeField]
        List<ScriptableObjectInstaller> _scriptableObjectInstallers = new List<ScriptableObjectInstaller>();

        [FormerlySerializedAs("Installers")]
        [FormerlySerializedAs("_installers")]
        [SerializeField]
        List<MonoInstaller> _monoInstallers = new List<MonoInstaller>();

        [SerializeField]
        List<MonoInstaller> _installerPrefabs = new List<MonoInstaller>();

        List<InstallerBase> _normalInstallers = new List<InstallerBase>();
        List<Type> _normalInstallerTypes = new List<Type>();

        public IEnumerable<MonoInstaller> Installers
        {
            get { return _monoInstallers; }
            set
            {
                _monoInstallers.Clear();
                _monoInstallers.AddRange(value);
            }
        }

        public IEnumerable<MonoInstaller> InstallerPrefabs
        {
            get { return _installerPrefabs; }
            set
            {
                _installerPrefabs.Clear();
                _installerPrefabs.AddRange(value);
            }
        }

        public IEnumerable<ScriptableObjectInstaller> ScriptableObjectInstallers
        {
            get { return _scriptableObjectInstallers; }
            set
            {
                _scriptableObjectInstallers.Clear();
                _scriptableObjectInstallers.AddRange(value);
            }
        }

        // Unlike other installer types this has to be set through code
        public IEnumerable<Type> NormalInstallerTypes
        {
            get { return _normalInstallerTypes; }
            set
            {
                Assert.That(value.All(x => x != null && x.DerivesFrom<InstallerBase>()));

                _normalInstallerTypes.Clear();
                _normalInstallerTypes.AddRange(value);
            }
        }

        // Unlike other installer types this has to be set through code
        public IEnumerable<InstallerBase> NormalInstallers
        {
            get { return _normalInstallers; }
            set
            {
                _normalInstallers.Clear();
                _normalInstallers.AddRange(value);
            }
        }

        public abstract DiContainer Container
        {
            get;
        }
        public abstract IEnumerable<GameObject> GetRootGameObjects();


        public void AddNormalInstallerType(Type installerType)
        {
            Assert.IsNotNull(installerType);
            Assert.That(installerType.DerivesFrom<InstallerBase>());

            _normalInstallerTypes.Add(installerType);
        }

        public void AddNormalInstaller(InstallerBase installer)
        {
            _normalInstallers.Add(installer);
        }

        void CheckInstallerPrefabTypes(List<MonoInstaller> installers, List<MonoInstaller> installerPrefabs)
        {
            foreach (var installer in installers)
            {
                Assert.IsNotNull(installer, "Found null installer in Context '{0}'", name);

#if UNITY_EDITOR
#if UNITY_2018_3_OR_NEWER
                Assert.That(!PrefabUtility.IsPartOfPrefabAsset(installer.gameObject),
#else
                Assert.That(PrefabUtility.GetPrefabType(installer.gameObject) != PrefabType.Prefab,
#endif
                    "Found prefab with name '{0}' in the Installer property of Context '{1}'.  You should use the property 'InstallerPrefabs' for this instead.", installer.name, name);
#endif
            }

            foreach (var installerPrefab in installerPrefabs)
            {
                Assert.IsNotNull(installerPrefab, "Found null prefab in Context");

                // We'd like to do this but this is actually a valid case sometimes
                // (eg. loading an asset bundle with a scene containing a scene context when inside unity editor)
//#if UNITY_EDITOR
                //Assert.That(PrefabUtility.GetPrefabType(installerPrefab.gameObject) == PrefabType.Prefab,
                    //"Found non-prefab with name '{0}' in the InstallerPrefabs property of Context '{1}'.  You should use the property 'Installer' for this instead",
                    //installerPrefab.name, this.name);
//#endif
                Assert.That(installerPrefab.GetComponent<MonoInstaller>() != null,
                    "Expected to find component with type 'MonoInstaller' on given installer prefab '{0}'", installerPrefab.name);
            }
        }

        protected void InstallInstallers()
        {
            InstallInstallers(
                _normalInstallers, _normalInstallerTypes, _scriptableObjectInstallers, _monoInstallers, _installerPrefabs);
        }

        protected void InstallInstallers(
            List<InstallerBase> normalInstallers,
            List<Type> normalInstallerTypes,
            List<ScriptableObjectInstaller> scriptableObjectInstallers,
            List<MonoInstaller> installers,
            List<MonoInstaller> installerPrefabs)
        {
            CheckInstallerPrefabTypes(installers, installerPrefabs);

            // Ideally we would just have one flat list of all the installers
            // since that way the user has complete control over the order, but
            // that's not possible since Unity does not allow serializing lists of interfaces
            // (and it has to be an inteface since the scriptable object installers only share
            // the interface)
            //
            // So the best we can do is have a hard-coded order in terms of the installer type
            //
            // The order is:
            //      - Normal installers given directly via code
            //      - ScriptableObject installers
            //      - MonoInstallers in the scene
            //      - Prefab Installers
            //
            // We put ScriptableObject installers before the MonoInstallers because
            // ScriptableObjectInstallers are often used for settings (including settings
            // that are injected into other installers like MonoInstallers)

            var allInstallers = normalInstallers.Cast<IInstaller>()
                .Concat(scriptableObjectInstallers.Cast<IInstaller>())
                .Concat(installers.Cast<IInstaller>()).ToList();

            foreach (var installerPrefab in installerPrefabs)
            {
                Assert.IsNotNull(installerPrefab, "Found null installer prefab in '{0}'", GetType());

                GameObject installerGameObject;

#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("GameObject.Instantiate"))
#endif
                {
                    installerGameObject = GameObject.Instantiate(installerPrefab.gameObject);
                }

                installerGameObject.transform.SetParent(transform, false);
                var installer = installerGameObject.GetComponent<MonoInstaller>();

                Assert.IsNotNull(installer, "Could not find installer component on prefab '{0}'", installerPrefab.name);

                allInstallers.Add(installer);
            }

            foreach (var installerType in normalInstallerTypes)
            {
                var installer = (InstallerBase)Container.Instantiate(installerType);

#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                {
                    installer.InstallBindings();
                }
            }

            foreach (var installer in allInstallers)
            {
                Assert.IsNotNull(installer,
                    "Found null installer in '{0}'", GetType());

                Container.Inject(installer);

#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                {
                    installer.InstallBindings();
                }
            }
        }

        protected void InstallSceneBindings(List<MonoBehaviour> injectableMonoBehaviours)
        {
            foreach (var binding in injectableMonoBehaviours.OfType<ZenjectBinding>())
            {
                if (binding == null)
                {
                    continue;
                }

                if (binding.Context == null || (binding.UseSceneContext && this is SceneContext))
                {
                    binding.Context = this;
                }
            }

            // We'd prefer to use GameObject.FindObjectsOfType<ZenjectBinding>() here
            // instead but that doesn't find inactive gameobjects
            // TODO: Consider changing this
            // Maybe ZenjectBinding could add itself to a registry class on Awake/OnEnable
            // then we could avoid calling the slow Resources.FindObjectsOfTypeAll here
            foreach (var binding in Resources.FindObjectsOfTypeAll<ZenjectBinding>())
            {
                if (binding == null)
                {
                    continue;
                }

                // This is necessary for cases where the ZenjectBinding is inside a GameObjectContext
                // since it won't be caught in the other loop above
                if (this is SceneContext)
                {
                    if (binding.Context == null && binding.UseSceneContext
                        && binding.gameObject.scene == gameObject.scene)
                    {
                        binding.Context = this;
                    }
                }

                if (binding.Context == this)
                {
                    InstallZenjectBinding(binding);
                }
            }
        }

        void InstallZenjectBinding(ZenjectBinding binding)
        {
            if (!binding.enabled)
            {
                return;
            }

            if (binding.Components == null || binding.Components.IsEmpty())
            {
                Log.Warn("Found empty list of components on ZenjectBinding on object '{0}'", binding.name);
                return;
            }

            string identifier = null;

            if (binding.Identifier.Trim().Length > 0)
            {
                identifier = binding.Identifier;
            }

            foreach (var component in binding.Components)
            {
                var bindType = binding.BindType;

                if (component == null)
                {
                    Log.Warn("Found null component in ZenjectBinding on object '{0}'", binding.name);
                    continue;
                }

                var componentType = component.GetType();

                switch (bindType)
                {
                    case ZenjectBinding.BindTypes.Self:
                    {
                        Container.Bind(componentType).WithId(identifier).FromInstance(component);
                        break;
                    }
                    case ZenjectBinding.BindTypes.BaseType:
                    {
                        Container.Bind(componentType.BaseType()).WithId(identifier).FromInstance(component);
                        break;
                    }
                    case ZenjectBinding.BindTypes.AllInterfaces:
                    {
                        Container.Bind(componentType.Interfaces()).WithId(identifier).FromInstance(component);
                        break;
                    }
                    case ZenjectBinding.BindTypes.AllInterfacesAndSelf:
                    {
                        Container.Bind(componentType.Interfaces().Concat(new[] { componentType }).ToArray()).WithId(identifier).FromInstance(component);
                        break;
                    }
                    default:
                    {
                        throw Assert.CreateException();
                    }
                }
            }
        }

        protected abstract void GetInjectableMonoBehaviours(List<MonoBehaviour> components);
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/Context.cs.meta
================================================
fileFormatVersion: 2
guid: be0cf56827265f44bbdeba09329d66ab
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/GameObjectContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;
using UnityEngine.Serialization;
using Zenject.Internal;

#pragma warning disable 649

namespace Zenject
{
    public class GameObjectContext : RunnableContext
    {
        public event Action PreInstall;
        public event Action PostInstall;
        public event Action PreResolve;
        public event Action PostResolve;

        [SerializeField]
        [Tooltip("Note that this field is optional and can be ignored in most cases.  This is really only needed if you want to control the 'Script Execution Order' of your subcontainer.  In this case, define a new class that derives from MonoKernel, add it to this game object, then drag it into this field.  Then you can set a value for 'Script Execution Order' for this new class and this will control when all ITickable/IInitializable classes bound within this subcontainer get called.")]
        [FormerlySerializedAs("_facade")]
        MonoKernel _kernel;

        DiContainer _container;

        // Need to cache this when auto run is false
        DiContainer _parentContainer;

        bool _hasInstalled;

        public override DiContainer Container
        {
            get { return _container; }
        }

        public override IEnumerable<GameObject> GetRootGameObjects()
        {
            return new[] { gameObject };
        }

        [Inject]
        public void Construct(
            DiContainer parentContainer)
        {
            Assert.IsNull(_parentContainer);
            _parentContainer = parentContainer;

            Initialize();
        }

        protected override void RunInternal()
        {
            Install(_parentContainer);
            ResolveAndStart();
        }

        public void Install(DiContainer parentContainer) 
        {
            Assert.That(_parentContainer == null || _parentContainer == parentContainer);

            // We allow calling this explicitly instead of relying on the [Inject] event above
            // so that we can follow the two-pass construction-injection pattern in the providers
            if (_hasInstalled) 
            {
                return;
            }

            _hasInstalled = true;

            Assert.IsNull(_container);
            _container = parentContainer.CreateSubContainer();

            // Do this after creating DiContainer in case it's needed by the pre install logic
            if (PreInstall != null)
            {
                PreInstall();
            }

            var injectableMonoBehaviours = new List<MonoBehaviour>();

            GetInjectableMonoBehaviours(injectableMonoBehaviours);

            foreach (var instance in injectableMonoBehaviours)
            {
                if (instance is MonoKernel)
                {
                    Assert.That(ReferenceEquals(instance, _kernel),
                        "Found MonoKernel derived class that is not hooked up to GameObjectContext.  If you use MonoKernel, you must indicate this to GameObjectContext by dragging and dropping it to the Kernel field in the inspector");
                }

                _container.QueueForInject(instance);
            }

            _container.IsInstalling = true;

            try
            {
                InstallBindings(injectableMonoBehaviours);
            }
            finally
            {
                _container.IsInstalling = false;
            }

            if (PostInstall != null)
            {
                PostInstall();
            }
        }

        void ResolveAndStart() 
        {
            if (PreResolve != null)
            {
                PreResolve();
            }

            _container.ResolveRoots();

            if (PostResolve != null)
            {
                PostResolve();
            }

            // Normally, the IInitializable.Initialize method would be called during MonoKernel.Start
            // However, this behaviour is undesirable for dynamically created objects, since Unity
            // has the strange behaviour of waiting until the end of the frame to call Start() on
            // dynamically created objects, which means that any GameObjectContext that is created
            // dynamically via a factory cannot be used immediately after calling Create(), since
            // it will not have been initialized
            // So we have chosen to diverge from Unity behaviour here and trigger IInitializable.Initialize
            // immediately - but only when the GameObjectContext is created dynamically.  For any
            // GameObjectContext's that are placed in the scene, we still want to execute
            // IInitializable.Initialize during Start()
            if (gameObject.scene.isLoaded && !_container.IsValidating)
            {
                _kernel = _container.Resolve<MonoKernel>();
                _kernel.Initialize();
            }
        }

        protected override void GetInjectableMonoBehaviours(List<MonoBehaviour> monoBehaviours)
        {
            ZenUtilInternal.AddStateMachineBehaviourAutoInjectersUnderGameObject(gameObject);

            // We inject on all components on the root except ourself
            foreach (var monoBehaviour in GetComponents<MonoBehaviour>())
            {
                if (monoBehaviour == null)
                {
                    // Missing script
                    continue;
                }

                if (!ZenUtilInternal.IsInjectableMonoBehaviourType(monoBehaviour.GetType()))
                {
                    continue;
                }

                if (monoBehaviour == this)
                {
                    continue;
                }

                monoBehaviours.Add(monoBehaviour);
            }

            for (int i = 0; i < transform.childCount; i++)
            {
                var child = transform.GetChild(i);

                if (child != null)
                {
                    ZenUtilInternal.GetInjectableMonoBehavioursUnderGameObject(
                        child.gameObject, monoBehaviours);
                }
            }
        }

        void InstallBindings(List<MonoBehaviour> injectableMonoBehaviours)
        {
            _container.DefaultParent = transform;

            _container.Bind<Context>().FromInstance(this);
            _container.Bind<GameObjectContext>().FromInstance(this);

            if (_kernel == null)
            {
                _container.Bind<MonoKernel>()
                    .To<DefaultGameObjectKernel>().FromNewComponentOn(gameObject).AsSingle().NonLazy();
            }
            else
            {
                _container.Bind<MonoKernel>().FromInstance(_kernel).AsSingle().NonLazy();
            }

            InstallSceneBindings(injectableMonoBehaviours);
            InstallInstallers();
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/GameObjectContext.cs.meta
================================================
fileFormatVersion: 2
guid: 08eca9f7688a0a24685b89133b020c8e
timeCreated: 1456086415
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/ProjectContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Threading;
using ModestTree;
using UnityEngine;
using Zenject.Internal;

namespace Zenject
{
    public class ProjectContext : Context
    {
        public static event Action PreInstall;
        public static event Action PostInstall;
        public static event Action PreResolve;
        public static event Action PostResolve;

        public const string ProjectContextResourcePath = "ProjectContext";
        public const string ProjectContextResourcePathOld = "ProjectCompositionRoot";

        static ProjectContext _instance;

        // TODO: Set this to false the next time major version is incremented
        [Tooltip("When true, objects that are created at runtime will be parented to the ProjectContext")]
        [SerializeField]
        bool _parentNewObjectsUnderContext = true;

        [SerializeField]
        ReflectionBakingCoverageModes _editorReflectionBakingCoverageMode = ReflectionBakingCoverageModes.FallbackToDirectReflection;

        [SerializeField]
        ReflectionBakingCoverageModes _buildsReflectionBakingCoverageMode = ReflectionBakingCoverageModes.FallbackToDirectReflection;

        [SerializeField]
        ZenjectSettings _settings = null;

        DiContainer _container;

        public override DiContainer Container
        {
            get { return _container; }
        }

        public static bool HasInstance
        {
            get { return _instance != null; }
        }

        public static ProjectContext Instance
        {
            get
            {
                if (_instance == null)
                {
                    InstantiateAndInitialize();
                    Assert.IsNotNull(_instance);
                }

                return _instance;
            }
        }

        public static bool ValidateOnNextRun
        {
            get;
            set;
        }

        public override IEnumerable<GameObject> GetRootGameObjects()
        {
            return new[] { gameObject };
        }

        public static GameObject TryGetPrefab()
        {
            var prefabs = Resources.LoadAll(ProjectContextResourcePath, typeof(GameObject));

            if (prefabs.Length > 0)
            {
                Assert.That(prefabs.Length == 1,
                    "Found multiple project context prefabs at resource path '{0}'", ProjectContextResourcePath);
                return (GameObject)prefabs[0];
            }

            prefabs = Resources.LoadAll(ProjectContextResourcePathOld, typeof(GameObject));

            if (prefabs.Length > 0)
            {
                Assert.That(prefabs.Length == 1,
                    "Found multiple project context prefabs at resource path '{0}'", ProjectContextResourcePathOld);
                return (GameObject)prefabs[0];
            }

            return null;
        }

        static void InstantiateAndInitialize()
        {
#if UNITY_EDITOR
            ProfileBlock.UnityMainThread = Thread.CurrentThread;
#endif

            Assert.That(FindObjectsOfType<ProjectContext>().IsEmpty(),
                "Tried to create multiple instances of ProjectContext!");

            var prefab = TryGetPrefab();

            var prefabWasActive = false;

#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("GameObject.Instantiate"))
#endif
            {
                if (prefab == null)
                {
                    _instance = new GameObject("ProjectContext")
                        .AddComponent<ProjectContext>();
                }
                else
                {
                    prefabWasActive = prefab.activeSelf;

                    GameObject gameObjectInstance;
#if UNITY_EDITOR
                    if(prefabWasActive)
                    {
                        // This ensures the prefab's Awake() methods don't fire (and, if in the editor, that the prefab file doesn't get modified)
                        gameObjectInstance = GameObject.Instantiate(prefab, ZenUtilInternal.GetOrCreateInactivePrefabParent());
                        gameObjectInstance.SetActive(false);
                        gameObjectInstance.transform.SetParent(null, false);
                    }
                    else
                    {
                        gameObjectInstance = GameObject.Instantiate(prefab);
                    }
#else
                    if(prefabWasActive)
                    {
                        prefab.SetActive(false);
                        gameObjectInstance = GameObject.Instantiate(prefab);
                        prefab.SetActive(true);
                    }
                    else
                    {
                        gameObjectInstance = GameObject.Instantiate(prefab);
                    }
#endif

                    _instance = gameObjectInstance.GetComponent<ProjectContext>();

                    Assert.IsNotNull(_instance,
                        "Could not find ProjectContext component on prefab 'Resources/{0}.prefab'", ProjectContextResourcePath);
                }
            }

            // Note: We use Initialize instead of awake here in case someone calls
            // ProjectContext.Instance while ProjectContext is initializing
            _instance.Initialize();

            if (prefabWasActive)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                {
                    // We always instantiate it as disabled so that Awake and Start events are triggered after inject
                    _instance.gameObject.SetActive(true);
                }
            }
        }

        public bool ParentNewObjectsUnderContext
        {
            get { return _parentNewObjectsUnderContext; }
            set { _parentNewObjectsUnderContext = value; }
        }

        public void EnsureIsInitialized()
        {
            // Do nothing - Initialize occurs in Instance property
        }

        public void Awake()
        {
            if (Application.isPlaying)
                // DontDestroyOnLoad can only be called when in play mode and otherwise produces errors
                // ProjectContext is created during design time (in an empty scene) when running validation
                // and also when running unit tests
                // In these cases we don't need DontDestroyOnLoad so just skip it
            {
                DontDestroyOnLoad(gameObject);
            }
        }

        void Initialize()
        {
            Assert.IsNull(_container);

            if (Application.isEditor)
            {
                TypeAnalyzer.ReflectionBakingCoverageMode = _editorReflectionBakingCoverageMode;
            }
            else
            {
                TypeAnalyzer.ReflectionBakingCoverageMode = _buildsReflectionBakingCoverageMode;
            }

            var isValidating = ValidateOnNextRun;

            // Reset immediately to ensure it doesn't get used in another run
            ValidateOnNextRun = false;

            _container = new DiContainer(
                new[] { StaticContext.Container }, isValidating);

            // Do this after creating DiContainer in case it's needed by the pre install logic
            if (PreInstall != null)
            {
                PreInstall();
            }

            var injectableMonoBehaviours = new List<MonoBehaviour>();
            GetInjectableMonoBehaviours(injectableMonoBehaviours);

            foreach (var instance in injectableMonoBehaviours)
            {
                _container.QueueForInject(instance);
            }

            _container.IsInstalling = true;

            try
            {
                InstallBindings(injectableMonoBehaviours);
            }
            finally
            {
                _container.IsInstalling = false;
            }

            if (PostInstall != null)
            {
                PostInstall();
            }

            if (PreResolve != null)
            {
                PreResolve();
            }

            _container.ResolveRoots();

            if (PostResolve != null)
            {
                PostResolve();
            }
        }

        protected override void GetInjectableMonoBehaviours(List<MonoBehaviour> monoBehaviours)
        {
            ZenUtilInternal.AddStateMachineBehaviourAutoInjectersUnderGameObject(gameObject);
            ZenUtilInternal.GetInjectableMonoBehavioursUnderGameObject(gameObject, monoBehaviours);
        }

        void InstallBindings(List<MonoBehaviour> injectableMonoBehaviours)
        {
            if (_parentNewObjectsUnderContext)
            {
                _container.DefaultParent = transform;
            }
            else
            {
                _container.DefaultParent = null;
            }

            _container.Settings = _settings ?? ZenjectSettings.Default;

            _container.Bind<ZenjectSceneLoader>().AsSingle();

            ZenjectManagersInstaller.Install(_container);

            _container.Bind<Context>().FromInstance(this);

            _container.Bind(typeof(ProjectKernel), typeof(MonoKernel))
                .To<ProjectKernel>().FromNewComponentOn(gameObject).AsSingle().NonLazy();

            _container.Bind<SceneContextRegistry>().AsSingle();

            InstallSceneBindings(injectableMonoBehaviours);

            InstallInstallers();

        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/ProjectContext.cs.meta
================================================
fileFormatVersion: 2
guid: a4e6589720da476459dc6dd71624b071
timeCreated: 1487808999
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/RunnableContext.cs
================================================
﻿using ModestTree;
using UnityEngine;

#if !NOT_UNITY3D

namespace Zenject
{
    public abstract class RunnableContext : Context
    {
        [Tooltip("When false, wait until run method is explicitly called. Otherwise run on initialize")]
        [SerializeField]
        bool _autoRun = true;

        static bool _staticAutoRun = true;

        public bool Initialized { get; private set; }

        protected void Initialize()
        {
            if (_staticAutoRun && _autoRun)
            {
                Run();
            }
            else
            {
                // True should always be default
                _staticAutoRun = true;
            }
        }

        public void Run()
        {
            Assert.That(!Initialized,
                "The context already has been initialized!");

            RunInternal();

            Initialized = true;
        }

        protected abstract void RunInternal();

        public static T CreateComponent<T>(GameObject gameObject) where T : RunnableContext
        {
            _staticAutoRun = false;

            var result = gameObject.AddComponent<T>();
            Assert.That(_staticAutoRun); // Should be reset
            return result;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/RunnableContext.cs.meta
================================================
﻿fileFormatVersion: 2
guid: 13e9b26d23f6422cb282cc27631fc9e2
timeCreated: 1494725784


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/SceneContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;
using UnityEngine;
using UnityEngine.Serialization;
using Zenject.Internal;
using UnityEngine.Events;

namespace Zenject
{
    public class SceneContext : RunnableContext
    {
        public event Action PreInstall;
        public event Action PostInstall;
        public event Action PreResolve;
        public event Action PostResolve;

        public UnityEvent OnPreInstall;
        public UnityEvent OnPostInstall;
        public UnityEvent OnPreResolve;
        public UnityEvent OnPostResolve;

        public static Action<DiContainer> ExtraBindingsInstallMethod;
        public static Action<DiContainer> ExtraBindingsLateInstallMethod;

        public static IEnumerable<DiContainer> ParentContainers;

        [FormerlySerializedAs("ParentNewObjectsUnderRoot")]
        [FormerlySerializedAs("_parentNewObjectsUnderRoot")]
        [Tooltip("When true, objects that are created at runtime will be parented to the SceneContext")]
        [SerializeField]
        bool _parentNewObjectsUnderSceneContext;

        [Tooltip("Optional contract names for this SceneContext, allowing contexts in subsequently loaded scenes to depend on it and be parented to it, and also for previously loaded decorators to be included")]
        [SerializeField]
        List<string> _contractNames = new List<string>();

        [Tooltip("Optional contract names of SceneContexts in previously loaded scenes that this context depends on and to which it should be parented")]
        [SerializeField]
        List<string> _parentContractNames = new List<string>();

        DiContainer _container;

        readonly List<SceneDecoratorContext> _decoratorContexts = new List<SceneDecoratorContext>();

        bool _hasInstalled;
        bool _hasResolved;

        public override DiContainer Container
        {
            get { return _container; }
        }

        public bool HasResolved
        {
            get { return _hasResolved; }
        }

        public bool HasInstalled
        {
            get { return _hasInstalled; }
        }

        public bool IsValidating
        {
            get
            {
                return ProjectContext.Instance.Container.IsValidating;
            }
        }

        public IEnumerable<string> ContractNames
        {
            get { return _contractNames; }
            set
            {
                _contractNames.Clear();
                _contractNames.AddRange(value);
            }
        }

        public IEnumerable<string> ParentContractNames
        {
            get
            {
                var result = new List<string>();
                result.AddRange(_parentContractNames);
                return result;
            }
            set
            {
                _parentContractNames = value.ToList();
            }
        }

        public bool ParentNewObjectsUnderSceneContext
        {
            get { return _parentNewObjectsUnderSceneContext; }
            set { _parentNewObjectsUnderSceneContext = value; }
        }

        public void Awake()
        {
#if ZEN_INTERNAL_PROFILING
            ProfileTimers.ResetAll();
            using (ProfileTimers.CreateTimedBlock("Other"))
#endif
            {
                Initialize();
            }
        }

        public void Validate()
        {
            Assert.That(IsValidating);

            Install();
            Resolve();
        }

        protected override void RunInternal()
        {
            // We always want to initialize ProjectContext as early as possible
            ProjectContext.Instance.EnsureIsInitialized();

#if UNITY_EDITOR
            using (ProfileBlock.Start("Zenject.SceneContext.Install"))
#endif
            {
                Install();
            }

#if UNITY_EDITOR
            using (ProfileBlock.Start("Zenject.SceneContext.Resolve"))
#endif
            {
                Resolve();
            }
        }

        public override IEnumerable<GameObject> GetRootGameObjects()
        {
            return ZenUtilInternal.GetRootGameObjects(gameObject.scene);
        }

        IEnumerable<DiContainer> GetParentContainers()
        {
            var parentContractNames = ParentContractNames;

            if (parentContractNames.IsEmpty())
            {
                if (ParentContainers != null)
                {
                    var tempParentContainer = ParentContainers;

                    // Always reset after using it - it is only used to pass the reference
                    // between scenes via ZenjectSceneLoader
                    ParentContainers = null;

                    return tempParentContainer;
                }

                return new[] { ProjectContext.Instance.Container };
            }

            Assert.IsNull(ParentContainers,
                "Scene cannot have both a parent scene context name set and also an explicit parent container given");

            var parentContainers = UnityUtil.AllLoadedScenes
                .Except(gameObject.scene)
                .SelectMany(scene => scene.GetRootGameObjects())
                .SelectMany(root => root.GetComponentsInChildren<SceneContext>())
                .Where(sceneContext => sceneContext.ContractNames.Where(x => parentContractNames.Contains(x)).Any())
                .Select(x => x.Container)
                .ToList();

            if (!parentContainers.Any())
            {
                throw Assert.CreateException(
                    "SceneContext on object {0} of scene {1} requires at least one of contracts '{2}', but none of the loaded SceneContexts implements that contract.",
                    gameObject.name,
                    gameObject.scene.name,
                    parentContractNames.Join(", "));
            }

            return parentContainers;
        }

        List<SceneDecoratorContext> LookupDecoratorContexts()
        {
            if (_contractNames.IsEmpty())
            {
                return new List<SceneDecoratorContext>();
            }

            return UnityUtil.AllLoadedScenes
                .Except(gameObject.scene)
                .SelectMany(scene => scene.GetRootGameObjects())
                .SelectMany(root => root.GetComponentsInChildren<SceneDecoratorContext>())
                .Where(decoratorContext => _contractNames.Contains(decoratorContext.DecoratedContractName))
                .ToList();
        }

        public void Install()
        {
            Assert.That(!_hasInstalled);
            _hasInstalled = true;

            Assert.IsNull(_container);

            var parents = GetParentContainers();
            Assert.That(!parents.IsEmpty());
            Assert.That(parents.All(x => x.IsValidating == parents.First().IsValidating));

            _container = new DiContainer(parents, parents.First().IsValidating);

            // Do this after creating DiContainer in case it's needed by the pre install logic
            if (PreInstall != null)
            {
                PreInstall();
            }

            if (OnPreInstall != null)
            {
                OnPreInstall.Invoke();
            }

            Assert.That(_decoratorContexts.IsEmpty());
            _decoratorContexts.AddRange(LookupDecoratorContexts());

            if (_parentNewObjectsUnderSceneContext)
            {
                _container.DefaultParent = transform;
            }
            else
            {
                _container.DefaultParent = null;
            }

            // Record all the injectable components in the scene BEFORE installing the installers
            // This is nice for cases where the user calls InstantiatePrefab<>, etc. in their installer
            // so that it doesn't inject on the game object twice
            // InitialComponentsInjecter will also guarantee that any component that is injected into
            // another component has itself been injected
            var injectableMonoBehaviours = new List<MonoBehaviour>();
            GetInjectableMonoBehaviours(injectableMonoBehaviours);
            foreach (var instance in injectableMonoBehaviours)
            {
                _container.QueueForInject(instance);
            }

            foreach (var decoratorContext in _decoratorContexts)
            {
                decoratorContext.Initialize(_container);
            }

            _container.IsInstalling = true;

            try
            {
                InstallBindings(injectableMonoBehaviours);
            }
            finally
            {
                _container.IsInstalling = false;
            }

            if (PostInstall != null)
            {
                PostInstall();
            }

            if (OnPostInstall != null)
            {
                OnPostInstall.Invoke();
            }
        }

        public void Resolve()
        {
            if (PreResolve != null)
            {
                PreResolve();
            }

            if (OnPreResolve != null)
            {
                OnPreResolve.Invoke();
            }

            Assert.That(_hasInstalled);
            Assert.That(!_hasResolved);
            _hasResolved = true;

            _container.ResolveRoots();

            if (PostResolve != null)
            {
                PostResolve();
            }

            if (OnPostResolve != null)
            {
                OnPostResolve.Invoke();
            }
        }

        void InstallBindings(List<MonoBehaviour> injectableMonoBehaviours)
        {
            _container.Bind(typeof(Context), typeof(SceneContext)).To<SceneContext>().FromInstance(this);
            _container.BindInterfacesTo<SceneContextRegistryAdderAndRemover>().AsSingle();

            // Add to registry first and remove from registry last
            _container.BindExecutionOrder<SceneContextRegistryAdderAndRemover>(-1);

            foreach (var decoratorContext in _decoratorContexts)
            {
                decoratorContext.InstallDecoratorSceneBindings();
            }

            InstallSceneBindings(injectableMonoBehaviours);

            _container.Bind(typeof(SceneKernel), typeof(MonoKernel))
                .To<SceneKernel>().FromNewComponentOn(gameObject).AsSingle().NonLazy();

            _container.Bind<ZenjectSceneLoader>().AsSingle();

            if (ExtraBindingsInstallMethod != null)
            {
                ExtraBindingsInstallMethod(_container);
                // Reset extra bindings for next time we change scenes
                ExtraBindingsInstallMethod = null;
            }

            // Always install the installers last so they can be injected with
            // everything above
            foreach (var decoratorContext in _decoratorContexts)
            {
                decoratorContext.InstallDecoratorInstallers();
            }

            InstallInstallers();

            foreach (var decoratorContext in _decoratorContexts)
            {
                decoratorContext.InstallLateDecoratorInstallers();
            }

            if (ExtraBindingsLateInstallMethod != null)
            {
                ExtraBindingsLateInstallMethod(_container);
                // Reset extra bindings for next time we change scenes
                ExtraBindingsLateInstallMethod = null;
            }
        }

        protected override void GetInjectableMonoBehaviours(List<MonoBehaviour> monoBehaviours)
        {
            var scene = gameObject.scene;

            ZenUtilInternal.AddStateMachineBehaviourAutoInjectersInScene(scene);
            ZenUtilInternal.GetInjectableMonoBehavioursInScene(scene, monoBehaviours);
        }

        // These methods can be used for cases where you need to create the SceneContext entirely in code
        // Note that if you use these methods that you have to call Run() yourself
        // This is useful because it allows you to create a SceneContext and configure it how you want
        // and add what installers you want before kicking off the Install/Resolve
        public static SceneContext Create()
        {
            return CreateComponent<SceneContext>(
                new GameObject("SceneContext"));
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/SceneContext.cs.meta
================================================
fileFormatVersion: 2
guid: 89715ad69b973a14899afa2c6730b30b
timeCreated: 1435941958
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -9999
  icon: {instanceID: 0}
  userData:
  assetBundleName:
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/SceneDecoratorContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;
using UnityEngine.Serialization;
using Zenject.Internal;

namespace Zenject
{
    public class SceneDecoratorContext : Context
    {
        [SerializeField]
        List<MonoInstaller> _lateInstallers = new List<MonoInstaller>();

        [SerializeField]
        List<MonoInstaller> _lateInstallerPrefabs = new List<MonoInstaller>();

        [SerializeField]
        List<ScriptableObjectInstaller> _lateScriptableObjectInstallers = new List<ScriptableObjectInstaller>();

        public IEnumerable<MonoInstaller> LateInstallers
        {
            get { return _lateInstallers; }
            set
            {
                _lateInstallers.Clear();
                _lateInstallers.AddRange(value);
            }
        }

        public IEnumerable<MonoInstaller> LateInstallerPrefabs
        {
            get { return _lateInstallerPrefabs; }
            set
            {
                _lateInstallerPrefabs.Clear();
                _lateInstallerPrefabs.AddRange(value);
            }
        }

        public IEnumerable<ScriptableObjectInstaller> LateScriptableObjectInstallers
        {
            get { return _lateScriptableObjectInstallers; }
            set
            {
                _lateScriptableObjectInstallers.Clear();
                _lateScriptableObjectInstallers.AddRange(value);
            }
        }

        [FormerlySerializedAs("SceneName")]
        [SerializeField]
        string _decoratedContractName = null;

        DiContainer _container;
        readonly List<MonoBehaviour> _injectableMonoBehaviours = new List<MonoBehaviour>();

        public string DecoratedContractName
        {
            get { return _decoratedContractName; }
        }

        public override DiContainer Container
        {
            get
            {
                Assert.IsNotNull(_container);
                return _container;
            }
        }

        public override IEnumerable<GameObject> GetRootGameObjects()
        {
            // This method should never be called because SceneDecoratorContext's are not bound
            // to the container
            throw Assert.CreateException();
        }

        public void Initialize(DiContainer container)
        {
            Assert.IsNull(_container);
            Assert.That(_injectableMonoBehaviours.IsEmpty());

            _container = container;

            GetInjectableMonoBehaviours(_injectableMonoBehaviours);

            foreach (var instance in _injectableMonoBehaviours)
            {
                container.QueueForInject(instance);
            }
        }

        public void InstallDecoratorSceneBindings()
        {
            _container.Bind<SceneDecoratorContext>().FromInstance(this);
            InstallSceneBindings(_injectableMonoBehaviours);
        }

        public void InstallDecoratorInstallers()
        {
            InstallInstallers();
        }

        protected override void GetInjectableMonoBehaviours(List<MonoBehaviour> monoBehaviours)
        {
            var scene = gameObject.scene;

            ZenUtilInternal.AddStateMachineBehaviourAutoInjectersInScene(scene);
            ZenUtilInternal.GetInjectableMonoBehavioursInScene(scene, monoBehaviours);
        }

        public void InstallLateDecoratorInstallers()
        {
            InstallInstallers(new List<InstallerBase>(), new List<Type>(), _lateScriptableObjectInstallers, _lateInstallers, _lateInstallerPrefabs);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/SceneDecoratorContext.cs.meta
================================================
fileFormatVersion: 2
guid: ed7323e8fdd8c26438c6485f2060dad0
timeCreated: 1487808999
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/StaticContext.cs
================================================
#if !NOT_UNITY3D

namespace Zenject
{
    // For some platforms, it's desirable to be able to add dependencies to Zenject before
    // Unity even starts up (eg. WSA as described here https://github.com/svermeulen/Zenject/issues/118)
    // In those cases you can call StaticContext.Container.BindX to add dependencies
    // Anything you add there will then be injected everywhere, since all other contexts
    // should be children of StaticContext
    public static class StaticContext
    {
        static DiContainer _container;

        // Useful sometimes to call from play mode tests
        public static void Clear()
        {
            _container = null;
        }

        public static bool HasContainer
        {
            get { return _container != null; }
        }

        public static DiContainer Container
        {
            get
            {
                if (_container == null)
                {
                    _container = new DiContainer();
                }

                return _container;
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Install/Contexts/StaticContext.cs.meta
================================================
fileFormatVersion: 2
guid: 668a9feb769954340b35901a0c829397
timeCreated: 1462834162
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Assert.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Zenject;

namespace ModestTree
{
    public static class Assert
    {
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void That(bool condition)
        {
            if (!condition)
            {
                throw CreateException("Assert hit!");
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotEmpty(string str)
        {
            if (String.IsNullOrEmpty(str))
            {
                throw CreateException("Unexpected null or empty string");
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        // This is better because IsEmpty with IEnumerable causes a memory alloc
        public static void IsEmpty<T>(IList<T> list)
        {
            if (list.Count != 0)
            {
                throw CreateException(
                    "Expected collection to be empty but instead found '{0}' elements", list.Count);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsEmpty<T>(IEnumerable<T> sequence)
        {
            if (!sequence.IsEmpty())
            {
                throw CreateException("Expected collection to be empty but instead found '{0}' elements",
                    sequence.Count());
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsType<T>(object obj)
        {
            IsType<T>(obj, "");
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsType<T>(object obj, string message)
        {
            if (!(obj is T))
            {
                throw CreateException("Assert Hit! {0}\nWrong type found. Expected '{1}' (left) but found '{2}' (right). ", message, typeof(T).PrettyName(), obj.GetType().PrettyName());
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void DerivesFrom<T>(Type type)
        {
            if (!type.DerivesFrom<T>())
            {
                throw CreateException("Expected type '{0}' to derive from '{1}'", type.Name, typeof(T).Name);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void DerivesFromOrEqual<T>(Type type)
        {
            if (!type.DerivesFromOrEqual<T>())
            {
                throw CreateException("Expected type '{0}' to derive from or be equal to '{1}'", type.Name, typeof(T).Name);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void DerivesFrom(Type childType, Type parentType)
        {
            if (!childType.DerivesFrom(parentType))
            {
                throw CreateException("Expected type '{0}' to derive from '{1}'", childType.Name, parentType.Name);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void DerivesFromOrEqual(Type childType, Type parentType)
        {
            if (!childType.DerivesFromOrEqual(parentType))
            {
                throw CreateException("Expected type '{0}' to derive from or be equal to '{1}'", childType.Name, parentType.Name);
            }
        }

        // Use AssertEquals to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsEqual(object left, object right)
        {
            IsEqual(left, right, "");
        }

        // Use AssertEquals to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsEqual(object left, object right, Func<string> messageGenerator)
        {
            if (!object.Equals(left, right))
            {
                left = left ?? "<NULL>";
                right = right ?? "<NULL>";
                throw CreateException("Assert Hit! {0}.  Expected '{1}' (left) but found '{2}' (right). ", messageGenerator(), left, right);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsApproximately(float left, float right, float epsilon = 0.00001f)
        {
            bool isEqual = Math.Abs(left - right) < epsilon;

            if (!isEqual)
            {
                throw CreateException("Assert Hit! Expected '{0}' (left) but found '{1}' (right). ", left, right);
            }
        }

        // Use AssertEquals to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsEqual(object left, object right, string message)
        {
            if (!object.Equals(left, right))
            {
                left = left ?? "<NULL>";
                right = right ?? "<NULL>";
                throw CreateException("Assert Hit! {0}\nExpected '{1}' (left) but found '{2}' (right). ", message, left, right);
            }
        }

        // Use Assert.IsNotEqual to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotEqual(object left, object right)
        {
            IsNotEqual(left, right, "");
        }

        // Use Assert.IsNotEqual to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotEqual(object left, object right, Func<string> messageGenerator)
        {
            if(object.Equals(left, right))
            {
                left = left ?? "<NULL>";
                right = right ?? "<NULL>";
                throw CreateException("Assert Hit! {0}.  Expected '{1}' (left) to differ from '{2}' (right). ", messageGenerator(), left, right);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNull(object val)
        {
            if (val != null)
            {
                throw CreateException(
                    "Assert Hit! Expected null pointer but instead found '{0}'", val);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNull(object val, string message)
        {
            if (val != null)
            {
                throw CreateException(
                    "Assert Hit! {0}", message);
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNull(object val, string message, object p1)
        {
            if (val != null)
            {
                throw CreateException(
                    "Assert Hit! {0}", message.Fmt(p1));
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotNull(object val)
        {
            if (val == null)
            {
                throw CreateException("Assert Hit! Found null pointer when value was expected");
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotNull(object val, string message)
        {
            if (val == null)
            {
                throw CreateException("Assert Hit! {0}", message);
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotNull(object val, string message, object p1)
        {
            if (val == null)
            {
                throw CreateException("Assert Hit! {0}", message.Fmt(p1));
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotNull(object val, string message, object p1, object p2)
        {
            if (val == null)
            {
                throw CreateException("Assert Hit! {0}", message.Fmt(p1, p2));
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotEmpty<T>(IEnumerable<T> val, string message = "")
        {
            if (!val.Any())
            {
                throw CreateException("Assert Hit! Expected empty collection but found {0} values. {1}", val.Count(), message);
            }
        }

        // Use Assert.IsNotEqual to get better error output (with values)
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void IsNotEqual(object left, object right, string message)
        {
            if (object.Equals(left, right))
            {
                left = left ?? "<NULL>";
                right = right ?? "<NULL>";
                throw CreateException("Assert Hit! {0}. Unexpected value found '{1}'. ", message, left);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void Warn(bool condition)
        {
            if (!condition)
            {
                ModestTree.Log.Warn("Warning!  See call stack");
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void Warn(bool condition, Func<string> messageGenerator)
        {
            if (!condition)
            {
                ModestTree.Log.Warn("Warning Assert hit! " + messageGenerator());
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void That(
            bool condition, string message)
        {
            if (!condition)
            {
                throw CreateException("Assert hit! " + message);
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void That(
            bool condition, string message, object p1)
        {
            if (!condition)
            {
                throw CreateException("Assert hit! " + message.Fmt(p1));
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void That(
            bool condition, string message, object p1, object p2)
        {
            if (!condition)
            {
                throw CreateException("Assert hit! " + message.Fmt(p1, p2));
            }
        }

        // We don't use params here to avoid the memory alloc
#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void That(
            bool condition, string message, object p1, object p2, object p3)
        {
            if (!condition)
            {
                throw CreateException("Assert hit! " + message.Fmt(p1, p2, p3));
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void Warn(bool condition, string message)
        {
            if (!condition)
            {
                ModestTree.Log.Warn("Warning Assert hit! " + message);
            }
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void Throws(Action action)
        {
            Throws<Exception>(action);
        }

#if ZEN_STRIP_ASSERTS_IN_BUILDS
        [Conditional("UNITY_EDITOR")]
#endif
        public static void Throws<TException>(Action action)
            where TException : Exception
        {
            try
            {
                action();
            }
            catch (TException)
            {
                return;
            }

            throw CreateException(
                "Expected to receive exception of type '{0}' but nothing was thrown", typeof(TException).Name);
        }

        public static ZenjectException CreateException()
        {
            return new ZenjectException("Assert hit!");
        }

        public static ZenjectException CreateException(string message)
        {
            return new ZenjectException(message);
        }

        public static ZenjectException CreateException(string message, params object[] parameters)
        {
            return new ZenjectException(message.Fmt(parameters));
        }

        public static ZenjectException CreateException(Exception innerException, string message, params object[] parameters)
        {
            return new ZenjectException(message.Fmt(parameters), innerException);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Assert.cs.meta
================================================
fileFormatVersion: 2
guid: 2968c9f42475ea146aec3ced9cbd99ad
timeCreated: 1427464253
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Func.cs
================================================
#if !NET_4_6

namespace ModestTree.Util
{
    // C# 3.5 only defines Func and Action to a maximum of 4 generic parameters
    // Note that if you are using .NET framework > 3.5 you will have to comment these out to avoid ambiguous errors
    public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);

    public delegate void Action<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public delegate void Action<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Func.cs.meta
================================================
fileFormatVersion: 2
guid: cf53ad544fd972d4eb4716fb02fb5e9e
timeCreated: 1491195389
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/LinqExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;
using ModestTree.Util;

namespace ModestTree
{
    public static class LinqExtensions
    {
        public static IEnumerable<T> Yield<T>(this T item)
        {
            yield return item;
        }

        // Return the first item when the list is of length one and otherwise returns default
        public static TSource OnlyOrDefault<TSource>(this IEnumerable<TSource> source)
        {
            Assert.IsNotNull(source);

            if (source.Count() > 1)
            {
                return default(TSource);
            }

            return source.FirstOrDefault();
        }

        // These are more efficient than Count() in cases where the size of the collection is not known
        public static bool HasAtLeast<T>(this IEnumerable<T> enumerable, int amount)
        {
            return enumerable.Take(amount).Count() == amount;
        }

        public static bool HasMoreThan<T>(this IEnumerable<T> enumerable, int amount)
        {
            return enumerable.HasAtLeast(amount+1);
        }

        public static bool HasLessThan<T>(this IEnumerable<T> enumerable, int amount)
        {
            return enumerable.HasAtMost(amount-1);
        }

        public static bool HasAtMost<T>(this IEnumerable<T> enumerable, int amount)
        {
            return enumerable.Take(amount + 1).Count() <= amount;
        }

        public static bool IsEmpty<T>(this IEnumerable<T> enumerable)
        {
            return !enumerable.Any();
        }

        public static IEnumerable<T> GetDuplicates<T>(this IEnumerable<T> list)
        {
            return list.GroupBy(x => x).Where(x => x.Skip(1).Any()).Select(x => x.Key);
        }

        public static IEnumerable<T> Except<T>(this IEnumerable<T> list, T item)
        {
            return list.Except(item.Yield());
        }

        // LINQ already has a method called "Contains" that does the same thing as this
        // BUT it fails to work with Mono 3.5 in some cases.
        // For example the following prints False, True in Mono 3.5 instead of True, True like it should:
        //
        // IEnumerable<string> args = new string[]
        // {
        //     "",
        //     null,
        // };

        // Log.Info(args.ContainsItem(null));
        // Log.Info(args.Where(x => x == null).Any());
        public static bool ContainsItem<T>(this IEnumerable<T> list, T value)
        {
            // Use object.Equals to support null values
            return list.Where(x => object.Equals(x, value)).Any();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/LinqExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 68fac2f8aa1edec4b9ef45794638a59c
timeCreated: 1427464292
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Log.cs
================================================
using System;
using System.Diagnostics;

namespace ModestTree
{
    // Simple wrapper around unity's logging system
    public static class Log
    {
        // Strip out debug logs outside of unity
        [Conditional("UNITY_EDITOR")]
        public static void Debug(string message, params object[] args)
        {
#if NOT_UNITY3D
            //Console.WriteLine(message.Fmt(args));
#else
            //UnityEngine.Debug.Log(message.Fmt(args));
#endif
        }

        /////////////

        public static void Info(string message, params object[] args)
        {
#if NOT_UNITY3D
            Console.WriteLine(message.Fmt(args));
#else
            UnityEngine.Debug.Log(message.Fmt(args));
#endif
        }

        /////////////

        public static void Warn(string message, params object[] args)
        {
#if NOT_UNITY3D
            Console.WriteLine(message.Fmt(args));
#else
            UnityEngine.Debug.LogWarning(message.Fmt(args));
#endif
        }

        /////////////

        public static void Trace(string message, params object[] args)
        {
#if NOT_UNITY3D
            Console.WriteLine(message.Fmt(args));
#else
            UnityEngine.Debug.Log(message.Fmt(args));
#endif
        }

        /////////////

        public static void ErrorException(Exception e)
        {
#if NOT_UNITY3D
            Console.WriteLine(e.ToString());
#else
            UnityEngine.Debug.LogException(e);
#endif
        }

        public static void ErrorException(string message, Exception e)
        {
#if NOT_UNITY3D
            Console.WriteLine(message);
#else
            UnityEngine.Debug.LogError(message);
            UnityEngine.Debug.LogException(e);
#endif
        }

        public static void Error(string message, params object[] args)
        {
#if NOT_UNITY3D
            Console.WriteLine(message.Fmt(args));
#else
            UnityEngine.Debug.LogError(message.Fmt(args));
#endif
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/Log.cs.meta
================================================
fileFormatVersion: 2
guid: 622a24d4c6769414495ea1786bfee872
timeCreated: 1427464253
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/MiscExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ModestTree
{
    public static class MiscExtensions
    {
        // We'd prefer to use the name Format here but that conflicts with
        // the existing string.Format method
        public static string Fmt(this string s, params object[] args)
        {
            // Do in-place change to avoid the memory alloc
            // This should be fine because the params is always used instead of directly
            // passing an array
            for (int i = 0; i < args.Length; i++)
            {
                var arg = args[i];

                if (arg == null)
                {
                    // This is much more understandable than just the empty string
                    args[i] = "NULL";
                }
                else if (arg is Type)
                {
                    // This often reads much better sometimes
                    args[i] = ((Type)arg).PrettyName();
                }
            }

            return String.Format(s, args);
        }

        public static int IndexOf<T>(this IList<T> list, T item)
        {
            for (int i = 0; i < list.Count; i++)
            {
                if (object.Equals(list[i], item))
                {
                    return i;
                }
            }

            return -1;
        }

        public static string Join(this IEnumerable<string> values, string separator)
        {
            return string.Join(separator, values.ToArray());
        }

        // When using C# 4.6, for some reason the normal AddRange causes some allocations
        // https://issuetracker.unity3d.com/issues/dot-net-4-dot-6-unexpected-gc-allocations-in-list-dot-addrange
        public static void AllocFreeAddRange<T>(this IList<T> list, IList<T> items)
        {
            for (int i = 0; i < items.Count; i++)
            {
                list.Add(items[i]);
            }
        }

        // Most of the time when you call remove you always intend on removing something
        // so assert in that case
        public static void RemoveWithConfirm<T>(this IList<T> list, T item)
        {
            bool removed = list.Remove(item);
            Assert.That(removed);
        }

        public static void RemoveWithConfirm<T>(this LinkedList<T> list, T item)
        {
            bool removed = list.Remove(item);
            Assert.That(removed);
        }

        public static void RemoveWithConfirm<TKey, TVal>(this IDictionary<TKey, TVal> dictionary, TKey key)
        {
            bool removed = dictionary.Remove(key);
            Assert.That(removed);
        }

        public static void RemoveWithConfirm<T>(this HashSet<T> set, T item)
        {
            bool removed = set.Remove(item);
            Assert.That(removed);
        }

        public static TVal GetValueAndRemove<TKey, TVal>(this IDictionary<TKey, TVal> dictionary, TKey key)
        {
            TVal val = dictionary[key];
            dictionary.RemoveWithConfirm(key);
            return val;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/MiscExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: da4e9bf39c1ac464d84d2f743a25f8d1
timeCreated: 1427464359
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/PreserveAttribute.cs
================================================
using System;

namespace ModestTree.Util
{
    [AttributeUsage(AttributeTargets.All, AllowMultiple = false)]
    public class PreserveAttribute : Attribute
    {
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/PreserveAttribute.cs.meta
================================================
fileFormatVersion: 2
guid: de17d24691e2bfd458a9d10cb1d49098
timeCreated: 1453682156
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/TypeExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace ModestTree
{
    public static class TypeExtensions
    {
        static readonly Dictionary<Type, bool> _isClosedGenericType = new Dictionary<Type, bool>();
        static readonly Dictionary<Type, bool> _isOpenGenericType = new Dictionary<Type, bool>();
        static readonly Dictionary<Type, bool> _isValueType = new Dictionary<Type, bool>();
        static readonly Dictionary<Type, Type[]> _interfaces = new Dictionary<Type, Type[]>();

        public static bool DerivesFrom<T>(this Type a)
        {
            return DerivesFrom(a, typeof(T));
        }

        // This seems easier to think about than IsAssignableFrom
        public static bool DerivesFrom(this Type a, Type b)
        {
            return b != a && a.DerivesFromOrEqual(b);
        }

        public static bool DerivesFromOrEqual<T>(this Type a)
        {
            return DerivesFromOrEqual(a, typeof(T));
        }

        public static bool DerivesFromOrEqual(this Type a, Type b)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return b == a || b.GetTypeInfo().IsAssignableFrom(a.GetTypeInfo());
#else
            return b == a || b.IsAssignableFrom(a);
#endif
        }

#if !(UNITY_WSA && ENABLE_DOTNET)
        // TODO: Is it possible to do this on WSA?
        public static bool IsAssignableToGenericType(Type givenType, Type genericType)
        {
            var interfaceTypes = givenType.Interfaces();

            foreach (var it in interfaceTypes)
            {
                if (it.IsGenericType && it.GetGenericTypeDefinition() == genericType)
                {
                    return true;
                }
            }

            if (givenType.IsGenericType && givenType.GetGenericTypeDefinition() == genericType)
            {
                return true;
            }

            Type baseType = givenType.BaseType;

            if (baseType == null)
            {
                return false;
            }

            return IsAssignableToGenericType(baseType, genericType);
        }
#endif

        public static bool IsEnum(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsEnum;
#else
            return type.IsEnum;
#endif
        }

        public static bool IsValueType(this Type type)
        {
            bool result;
            if (!_isValueType.TryGetValue(type, out result))
            {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
                result = type.GetTypeInfo().IsValueType;
#else
                result = type.IsValueType;
#endif
                _isValueType[type] = result;
            }
            return result;
        }

        public static MethodInfo[] DeclaredInstanceMethods(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetRuntimeMethods()
                .Where(x => x.DeclaringType == type).ToArray();
#else
            return type.GetMethods(
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
#endif
        }

        public static PropertyInfo[] DeclaredInstanceProperties(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            // There doesn't appear to be an IsStatic member on PropertyInfo
            return type.GetRuntimeProperties()
                .Where(x => x.DeclaringType == type).ToArray();
#else
            return type.GetProperties(
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
#endif
        }

        public static FieldInfo[] DeclaredInstanceFields(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetRuntimeFields()
                .Where(x => x.DeclaringType == type && !x.IsStatic).ToArray();
#else
            return type.GetFields(
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
#endif
        }

#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
        public static bool IsAssignableFrom(this Type a, Type b)
        {
            return a.GetTypeInfo().IsAssignableFrom(b.GetTypeInfo());
        }
#endif

        public static Type BaseType(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().BaseType;
#else
            return type.BaseType;
#endif
        }

        public static bool IsGenericType(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsGenericType;
#else
            return type.IsGenericType;
#endif
        }
        public static bool IsGenericTypeDefinition(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsGenericTypeDefinition;
#else
            return type.IsGenericTypeDefinition;
#endif
        }

        public static bool IsPrimitive(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsPrimitive;
#else
            return type.IsPrimitive;
#endif
        }

        public static bool IsInterface(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsInterface;
#else
            return type.IsInterface;
#endif
        }

        public static bool ContainsGenericParameters(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().ContainsGenericParameters;
#else
            return type.ContainsGenericParameters;
#endif
        }

        public static bool IsAbstract(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsAbstract;
#else
            return type.IsAbstract;
#endif
        }

        public static bool IsSealed(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().IsSealed;
#else
            return type.IsSealed;
#endif
        }

        public static MethodInfo Method(this Delegate del)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return del.GetMethodInfo();
#else
            return del.Method;
#endif
        }

        public static Type[] GenericArguments(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().GenericTypeArguments;
#else
            return type.GetGenericArguments();
#endif
        }

        public static Type[] Interfaces(this Type type)
        {
            Type[] result;
            if (!_interfaces.TryGetValue(type, out result))
            {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
                result = type.GetTypeInfo().ImplementedInterfaces.ToArray();
#else
                result = type.GetInterfaces();
#endif
                _interfaces.Add(type, result);
            }
            return result;
        }

        public static ConstructorInfo[] Constructors(this Type type)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().DeclaredConstructors.ToArray();
#else
            return type.GetConstructors(
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
#endif
        }

        public static object GetDefaultValue(this Type type)
        {
#if ENABLE_IL2CPP
            // Workaround for IL2CPP returning default(T) for Activator.CreateInstance(typeof(T?))
            if (type.IsGenericType() && type.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                return null;
            }
#endif

            if (type.IsValueType())
            {
                return Activator.CreateInstance(type);
            }

            return null;
        }

        public static bool IsClosedGenericType(this Type type)
        {
            bool result;
            if (!_isClosedGenericType.TryGetValue(type, out result))
            {
                result = type.IsGenericType() && type != type.GetGenericTypeDefinition();
                _isClosedGenericType[type] = result;
            }
            return result;
        }

        public static IEnumerable<Type> GetParentTypes(this Type type)
        {
            if (type == null || type.BaseType() == null || type == typeof(object) || type.BaseType() == typeof(object))
            {
                yield break;
            }

            yield return type.BaseType();

            foreach (var ancestor in type.BaseType().GetParentTypes())
            {
                yield return ancestor;
            }
        }

        public static bool IsOpenGenericType(this Type type)
        {
            bool result;
            if (!_isOpenGenericType.TryGetValue(type, out result))
            {
                result = type.IsGenericType() && type == type.GetGenericTypeDefinition();
                _isOpenGenericType[type] = result;
            }
            return result;
        }

        public static T GetAttribute<T>(this MemberInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes<T>().Single();
        }

        public static T TryGetAttribute<T>(this MemberInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes<T>().OnlyOrDefault();
        }

        public static bool HasAttribute(
            this MemberInfo provider, params Type[] attributeTypes)
        {
            return provider.AllAttributes(attributeTypes).Any();
        }

        public static bool HasAttribute<T>(this MemberInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes(typeof(T)).Any();
        }

        public static IEnumerable<T> AllAttributes<T>(
            this MemberInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes(typeof(T)).Cast<T>();
        }

        public static IEnumerable<Attribute> AllAttributes(
            this MemberInfo provider, params Type[] attributeTypes)
        {
            Attribute[] allAttributes;
#if NETFX_CORE
            allAttributes = provider.GetCustomAttributes<Attribute>(true).ToArray();
#else
            allAttributes = System.Attribute.GetCustomAttributes(provider, typeof(Attribute), true);
#endif
            if (attributeTypes.Length == 0)
            {
                return allAttributes;
            }

            return allAttributes.Where(a => attributeTypes.Any(x => a.GetType().DerivesFromOrEqual(x)));
        }

        // We could avoid this duplication here by using ICustomAttributeProvider but this class
        // does not exist on the WP8 platform
        public static bool HasAttribute(
            this ParameterInfo provider, params Type[] attributeTypes)
        {
            return provider.AllAttributes(attributeTypes).Any();
        }

        public static bool HasAttribute<T>(this ParameterInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes(typeof(T)).Any();
        }

        public static IEnumerable<T> AllAttributes<T>(
            this ParameterInfo provider)
            where T : Attribute
        {
            return provider.AllAttributes(typeof(T)).Cast<T>();
        }

        public static IEnumerable<Attribute> AllAttributes(
            this ParameterInfo provider, params Type[] attributeTypes)
        {
            Attribute[] allAttributes;
#if NETFX_CORE
            allAttributes = provider.GetCustomAttributes<Attribute>(true).ToArray();
#else
            allAttributes = System.Attribute.GetCustomAttributes(provider, typeof(Attribute), true);
#endif
            if (attributeTypes.Length == 0)
            {
                return allAttributes;
            }

            return allAttributes.Where(a => attributeTypes.Any(x => a.GetType().DerivesFromOrEqual(x)));
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/TypeExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 2697c251f47f2bc40b32922c5a796f65
timeCreated: 1427464253
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/TypeStringFormatter.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace ModestTree
{
    public static class TypeStringFormatter
    {
        static readonly Dictionary<Type, string> _prettyNameCache = new Dictionary<Type, string>();

        public static string PrettyName(this Type type)
        {
            string prettyName;

            if (!_prettyNameCache.TryGetValue(type, out prettyName))
            {
                prettyName = PrettyNameInternal(type);
                _prettyNameCache.Add(type, prettyName);
            }

            return prettyName;
        }

        static string PrettyNameInternal(Type type)
        {
            var sb = new StringBuilder();

            if (type.IsNested)
            {
                sb.Append(type.DeclaringType.PrettyName());
                sb.Append(".");
            }

            if (type.IsArray)
            {
                sb.Append(type.GetElementType().PrettyName());
                sb.Append("[]");
            }
            else
            {
                var name = GetCSharpTypeName(type.Name);

                if (type.IsGenericType())
                {
                    var quoteIndex = name.IndexOf('`');

                    if (quoteIndex != -1)
                    {
                        sb.Append(name.Substring(0, name.IndexOf('`')));
                    }
                    else
                    {
                        sb.Append(name);
                    }

                    sb.Append("<");

                    if (type.IsGenericTypeDefinition())
                    {
                        var numArgs = type.GenericArguments().Count();

                        if (numArgs > 0)
                        {
                            sb.Append(new String(',', numArgs - 1));
                        }
                    }
                    else
                    {
                        sb.Append(string.Join(", ", type.GenericArguments().Select(t => t.PrettyName()).ToArray()));
                    }

                    sb.Append(">");
                }
                else
                {
                    sb.Append(name);
                }
            }

            return sb.ToString();
        }

        static string GetCSharpTypeName(string typeName)
        {
            switch (typeName)
            {
                case "String":
                case "Object":
                case "Void":
                case "Byte":
                case "Double":
                case "Decimal":
                    return typeName.ToLower();
                case "Int16":
                    return "short";
                case "Int32":
                    return "int";
                case "Int64":
                    return "long";
                case "Single":
                    return "float";
                case "Boolean":
                    return "bool";
                default:
                    return typeName;
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/TypeStringFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 94a0a9a58e17e3d438c169678c9795f7
timeCreated: 1538018650
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/ValuePair.cs
================================================
using System;
using System.Collections.Generic;

namespace ModestTree.Util
{
    public class ValuePair<T1, T2>
    {
        public readonly T1 First;
        public readonly T2 Second;

        public ValuePair()
        {
            First = default(T1);
            Second = default(T2);
        }

        public ValuePair(T1 first, T2 second)
        {
            First = first;
            Second = second;
        }

        public override bool Equals(Object obj)
        {
            var that = obj as ValuePair<T1, T2>;

            if (that == null)
            {
                return false;
            }

            return Equals(that);
        }

        public bool Equals(ValuePair<T1, T2> that)
        {
            if (that == null)
            {
                return false;
            }

            return object.Equals(First, that.First) && object.Equals(Second, that.Second);
        }

        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + (First == null ? 0 : First.GetHashCode());
                hash = hash * 29 + (Second == null ? 0 : Second.GetHashCode());
                return hash;
            }
        }
    }

    public class ValuePair<T1, T2, T3>
    {
        public readonly T1 First;
        public readonly T2 Second;
        public readonly T3 Third;

        public ValuePair()
        {
            First = default(T1);
            Second = default(T2);
            Third = default(T3);
        }

        public ValuePair(T1 first, T2 second, T3 third)
        {
            First = first;
            Second = second;
            Third = third;
        }

        public override bool Equals(Object obj)
        {
            var that = obj as ValuePair<T1, T2, T3>;

            if (that == null)
            {
                return false;
            }

            return Equals(that);
        }

        public bool Equals(ValuePair<T1, T2, T3> that)
        {
            if (that == null)
            {
                return false;
            }

            return object.Equals(First, that.First) && object.Equals(Second, that.Second) && object.Equals(Third, that.Third);
        }

        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + (First == null ? 0 : First.GetHashCode());
                hash = hash * 29 + (Second == null ? 0 : Second.GetHashCode());
                hash = hash * 29 + (Third == null ? 0 : Third.GetHashCode());
                return hash;
            }
        }
    }

    public class ValuePair<T1, T2, T3, T4>
    {
        public readonly T1 First;
        public readonly T2 Second;
        public readonly T3 Third;
        public readonly T4 Fourth;

        public ValuePair()
        {
            First = default(T1);
            Second = default(T2);
            Third = default(T3);
            Fourth = default(T4);
        }

        public ValuePair(T1 first, T2 second, T3 third, T4 fourth)
        {
            First = first;
            Second = second;
            Third = third;
            Fourth = fourth;
        }

        public override bool Equals(Object obj)
        {
            var that = obj as ValuePair<T1, T2, T3, T4>;

            if (that == null)
            {
                return false;
            }

            return Equals(that);
        }

        public bool Equals(ValuePair<T1, T2, T3, T4> that)
        {
            if (that == null)
            {
                return false;
            }

            return object.Equals(First, that.First) && object.Equals(Second, that.Second)
                && object.Equals(Third, that.Third) && object.Equals(Fourth, that.Fourth);
        }

        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + (First == null ? 0 : First.GetHashCode());
                hash = hash * 29 + (Second == null ? 0 : Second.GetHashCode());
                hash = hash * 29 + (Third == null ? 0 : Third.GetHashCode());
                hash = hash * 29 + (Fourth == null ? 0 : Fourth.GetHashCode());
                return hash;
            }
        }
    }

    public static class ValuePair
    {
        public static ValuePair<T1, T2> New<T1, T2>(T1 first, T2 second)
        {
            return new ValuePair<T1, T2>(first, second);
        }

        public static ValuePair<T1, T2, T3> New<T1, T2, T3>(T1 first, T2 second, T3 third)
        {
            return new ValuePair<T1, T2, T3>(first, second, third);
        }

        public static ValuePair<T1, T2, T3, T4> New<T1, T2, T3, T4>(T1 first, T2 second, T3 third, T4 fourth)
        {
            return new ValuePair<T1, T2, T3, T4>(first, second, third, fourth);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Internal/ValuePair.cs.meta
================================================
fileFormatVersion: 2
guid: a3c968adce0a9a24e949dc4eedb496e8
timeCreated: 1478449513
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/BindingId.cs
================================================
using System;
using System.Diagnostics;
using ModestTree;

namespace Zenject
{
    [DebuggerStepThrough]
    public struct BindingId : IEquatable<BindingId>
    {
        Type _type;
        object _identifier;

        public BindingId(Type type, object identifier)
        {
            _type = type;
            _identifier = identifier;
        }

        public Type Type
        {
            get { return _type; }
            set { _type = value; }
        }

        public object Identifier
        {
            get { return _identifier; }
            set { _identifier = value; }
        }

        public override string ToString()
        {
            if (_identifier == null)
            {
                return _type.PrettyName();
            }

            return "{0} (ID: {1})".Fmt(_type, _identifier);
        }

        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + _type.GetHashCode();
                hash = hash * 29 + (_identifier == null ? 0 : _identifier.GetHashCode());
                return hash;
            }
        }

        public override bool Equals(object other)
        {
            if (other is BindingId)
            {
                BindingId otherId = (BindingId)other;
                return otherId == this;
            }

            return false;
        }

        public bool Equals(BindingId that)
        {
            return this == that;
        }

        public static bool operator ==(BindingId left, BindingId right)
        {
            return left.Type == right.Type && Equals(left.Identifier, right.Identifier);
        }

        public static bool operator !=(BindingId left, BindingId right)
        {
            return !left.Equals(right);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/BindingId.cs.meta
================================================
fileFormatVersion: 2
guid: 05e8238358230bf4e9cbb692280d28f1
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/DiContainer.cs.meta
================================================
fileFormatVersion: 2
guid: de4283f91e0232a4897afd2a0af141bc
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/IInstantiator.cs
================================================
using System;
using System.Collections.Generic;

#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    // You can optionally inject this interface into your classes/factories
    // rather than using DiContainer which contains many methods you might not need
    public interface IInstantiator
    {
        // Use this method to create any non-monobehaviour
        // Any fields marked [Inject] will be set using the bindings on the container
        // Any methods marked with a [Inject] will be called
        // Any constructor parameters will be filled in with values from the container
        T Instantiate<T>();
        T Instantiate<T>(IEnumerable<object> extraArgs);

        object Instantiate(Type concreteType);
        object Instantiate(Type concreteType, IEnumerable<object> extraArgs);

#if !NOT_UNITY3D

        // Add new component to existing game object and fill in its dependencies
        // NOTE: Gameobject here is not a prefab prototype, it is an instance
        TContract InstantiateComponent<TContract>(GameObject gameObject)
            where TContract : Component;
        TContract InstantiateComponent<TContract>(
            GameObject gameObject, IEnumerable<object> extraArgs)
            where TContract : Component;
        Component InstantiateComponent(
            Type componentType, GameObject gameObject);
        Component InstantiateComponent(
            Type componentType, GameObject gameObject, IEnumerable<object> extraArgs);

        T InstantiateComponentOnNewGameObject<T>()
            where T : Component;
        T InstantiateComponentOnNewGameObject<T>(string gameObjectName)
            where T : Component;
        T InstantiateComponentOnNewGameObject<T>(IEnumerable<object> extraArgs)
            where T : Component;
        T InstantiateComponentOnNewGameObject<T>(string gameObjectName, IEnumerable<object> extraArgs)
            where T : Component;

        // Create a new game object from a prefab and fill in dependencies for all children
        GameObject InstantiatePrefab(UnityEngine.Object prefab);
        GameObject InstantiatePrefab(
            UnityEngine.Object prefab, Transform parentTransform);
        GameObject InstantiatePrefab(
            UnityEngine.Object prefab, Vector3 position, Quaternion rotation, Transform parentTransform);

        // Create a new game object from a resource path and fill in dependencies for all children
        GameObject InstantiatePrefabResource(string resourcePath);
        GameObject InstantiatePrefabResource(
            string resourcePath, Transform parentTransform);
        GameObject InstantiatePrefabResource(
            string resourcePath, Vector3 position, Quaternion rotation, Transform parentTransform);

        // Same as InstantiatePrefab but returns a component after it's initialized
        // and optionally allows extra arguments for the given component type
        T InstantiatePrefabForComponent<T>(UnityEngine.Object prefab);
        T InstantiatePrefabForComponent<T>(
            UnityEngine.Object prefab, IEnumerable<object> extraArgs);
        T InstantiatePrefabForComponent<T>(
            UnityEngine.Object prefab, Transform parentTransform);
        T InstantiatePrefabForComponent<T>(
            UnityEngine.Object prefab, Transform parentTransform, IEnumerable<object> extraArgs);
        T InstantiatePrefabForComponent<T>(
            UnityEngine.Object prefab, Vector3 position, Quaternion rotation, Transform parentTransform);
        T InstantiatePrefabForComponent<T>(
            UnityEngine.Object prefab, Vector3 position, Quaternion rotation, Transform parentTransform, IEnumerable<object> extraArgs);
        object InstantiatePrefabForComponent(
            Type concreteType, UnityEngine.Object prefab, Transform parentTransform, IEnumerable<object> extraArgs);

        // Same as InstantiatePrefabResource but returns a component after it's initialized
        // and optionally allows extra arguments for the given component type
        T InstantiatePrefabResourceForComponent<T>(string resourcePath);
        T InstantiatePrefabResourceForComponent<T>(
            string resourcePath, IEnumerable<object> extraArgs);
        T InstantiatePrefabResourceForComponent<T>(
            string resourcePath, Transform parentTransform);
        T InstantiatePrefabResourceForComponent<T>(
            string resourcePath, Transform parentTransform, IEnumerable<object> extraArgs);
        T InstantiatePrefabResourceForComponent<T>(
            string resourcePath, Vector3 position, Quaternion rotation, Transform parentTransform);
        T InstantiatePrefabResourceForComponent<T>(
            string resourcePath, Vector3 position, Quaternion rotation, Transform parentTransform, IEnumerable<object> extraArgs);
        object InstantiatePrefabResourceForComponent(
            Type concreteType, string resourcePath, Transform parentTransform, IEnumerable<object> extraArgs);

        T InstantiateScriptableObjectResource<T>(string resourcePath)
            where T : ScriptableObject;
        T InstantiateScriptableObjectResource<T>(
            string resourcePath, IEnumerable<object> extraArgs)
            where T : ScriptableObject;
        object InstantiateScriptableObjectResource(
            Type scriptableObjectType, string resourcePath);
        object InstantiateScriptableObjectResource(
            Type scriptableObjectType, string resourcePath, IEnumerable<object> extraArgs);

        GameObject CreateEmptyGameObject(string name);
#endif
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/IInstantiator.cs.meta
================================================
fileFormatVersion: 2
guid: 27acc83df7708be4185afec9bd506165
timeCreated: 1523188912
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/LazyInstanceInjector.cs
================================================

using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    // When the app starts up, typically there is a list of instances that need to be injected
    // The question is, what is the order that they should be injected?  Originally we would
    // just iterate over the list and inject in whatever order they were in
    // What is better than that though, is to inject based on their dependency order
    // So if A depends on B then it would be nice if B was always injected before A
    // That way, in [Inject] methods for A, A can access members on B knowing that it's
    // already been initialized.
    // So in order to do this, we add the initial pool of instances to this class then
    // notify this class whenever an instance is resolved via a FromInstance binding
    // That way we can lazily call inject on-demand whenever the instance is requested
    [NoReflectionBaking]
    public class LazyInstanceInjector
    {
        readonly DiContainer _container;
        readonly HashSet<object> _instancesToInject = new HashSet<object>();

        public LazyInstanceInjector(DiContainer container)
        {
            _container = container;
        }

        public IEnumerable<object> Instances
        {
            get { return _instancesToInject; }
        }

        public void AddInstance(object instance)
        {
            _instancesToInject.Add(instance);
        }

        public void AddInstances(IEnumerable<object> instances)
        {
            _instancesToInject.UnionWith(instances);
        }

        public void LazyInject(object instance)
        {
            if (_instancesToInject.Remove(instance))
            {
                _container.Inject(instance);
            }
        }

        public void LazyInjectAll()
        {
#if UNITY_EDITOR
            using (ProfileBlock.Start("Zenject.LazyInstanceInjector.LazyInjectAll"))
#endif
            {
                var tempList = new List<object>();

                while (!_instancesToInject.IsEmpty())
                {
                    tempList.Clear();
                    tempList.AddRange(_instancesToInject);

                    foreach (var instance in tempList)
                    {
                        // We use LazyInject instead of calling _container.inject directly
                        // Because it might have already been lazily injected
                        // as a result of a previous call to inject
                        LazyInject(instance);
                    }
                }
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/LazyInstanceInjector.cs.meta
================================================
fileFormatVersion: 2
guid: c7bd2a03033e83a4c9dab4d27166b412
timeCreated: 1476651829
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/LookupId.cs
================================================
using ModestTree;

namespace Zenject.Internal
{
    [NoReflectionBaking]
    public class LookupId
    {
        public IProvider Provider;
        public BindingId BindingId;

        public LookupId()
        {
        }

        public LookupId(IProvider provider, BindingId bindingId)
        {
            Assert.IsNotNull(provider);
            Assert.IsNotNull(bindingId);

            Provider = provider;
            BindingId = bindingId;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 23 + Provider.GetHashCode();
            hash = hash * 23 + BindingId.GetHashCode();
            return hash;
        }

        public void Reset()
        {
            Provider = null;
            BindingId.Type = null;
            BindingId.Identifier = null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/LookupId.cs.meta
================================================
fileFormatVersion: 2
guid: 75d6ff51a82574249bd77fb5fd40d948
timeCreated: 1535860932
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/SingletonMarkRegistry.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject.Internal
{
    [NoReflectionBaking]
    public class SingletonMarkRegistry
    {
        readonly HashSet<Type> _boundSingletons = new HashSet<Type>();
        readonly HashSet<Type> _boundNonSingletons = new HashSet<Type>();

        public void MarkNonSingleton(Type type)
        {
            Assert.That(!_boundSingletons.Contains(type),
                "Found multiple creation bindings for type '{0}' in addition to AsSingle.  The AsSingle binding must be the definitive creation binding.  If this is intentional, use AsCached instead of AsSingle.", type);
            _boundNonSingletons.Add(type);
        }

        public void MarkSingleton(Type type)
        {
            bool added = _boundSingletons.Add(type);
            Assert.That(added, "Attempted to use AsSingle multiple times for type '{0}'.  As of Zenject 6+, AsSingle as can no longer be used for the same type across different bindings.  See the upgrade guide for details.", type);

            Assert.That(!_boundNonSingletons.Contains(type),
                "Found multiple creation bindings for type '{0}' in addition to AsSingle.  The AsSingle binding must be the definitive creation binding.  If this is intentional, use AsCached instead of AsSingle.", type);
        }

    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/SingletonMarkRegistry.cs.meta
================================================
fileFormatVersion: 2
guid: 3844511961cf2ee40948fbe1569a2f31
timeCreated: 1520759760
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/ZenjectSettings.cs
================================================
using System;
#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    public enum ValidationErrorResponses
    {
        Log,
        Throw
    }

    public enum RootResolveMethods
    {
        NonLazyOnly,
        All
    }

    public enum SignalDefaultSyncModes
    {
        Synchronous,
        Asynchronous
    }

    public enum SignalMissingHandlerResponses
    {
        Ignore,
        Throw,
        Warn
    }

    [Serializable]
    [ZenjectAllowDuringValidation]
    [NoReflectionBaking]
    public class ZenjectSettings
    {
        public static ZenjectSettings Default = new ZenjectSettings();

#if !NOT_UNITY3D
        [SerializeField]
#endif
        bool _ensureDeterministicDestructionOrderOnApplicationQuit;

#if !NOT_UNITY3D
        [SerializeField]
#endif
        bool _displayWarningWhenResolvingDuringInstall;

#if !NOT_UNITY3D
        [SerializeField]
#endif
        RootResolveMethods _validationRootResolveMethod;

#if !NOT_UNITY3D
        [SerializeField]
#endif
        ValidationErrorResponses _validationErrorResponse;

#if !NOT_UNITY3D
        [SerializeField]
#endif
        SignalSettings _signalSettings;

        public ZenjectSettings(
            ValidationErrorResponses validationErrorResponse,
            RootResolveMethods validationRootResolveMethod = RootResolveMethods.NonLazyOnly,
            bool displayWarningWhenResolvingDuringInstall = true,
            bool ensureDeterministicDestructionOrderOnApplicationQuit = false,
            SignalSettings signalSettings = null)
        {
            _validationErrorResponse = validationErrorResponse;
            _validationRootResolveMethod = validationRootResolveMethod;
            _displayWarningWhenResolvingDuringInstall = displayWarningWhenResolvingDuringInstall;
            _ensureDeterministicDestructionOrderOnApplicationQuit =ensureDeterministicDestructionOrderOnApplicationQuit;
            _signalSettings = signalSettings ?? SignalSettings.Default;
        }

        // Need to define an emtpy constructor since this is created by unity serialization
        // even if the above constructor has defaults for all
        public ZenjectSettings()
            : this(ValidationErrorResponses.Log)
        {
        }

        public SignalSettings Signals
        {
            get { return _signalSettings; }
        }

        // Setting this to Log can be more useful because it will print out
        // multiple validation errors at once so you can fix multiple problems before
        // attempting validation again
        public ValidationErrorResponses ValidationErrorResponse
        {
            get { return _validationErrorResponse; }
        }

        // Settings this to true will ensure that every binding in the container can be
        // instantiated with all its dependencies, and not just those bindings that will be
        // constructed as part of the object graph generated from the nonlazy bindings
        public RootResolveMethods ValidationRootResolveMethod
        {
            get { return _validationRootResolveMethod; }
        }

        public bool DisplayWarningWhenResolvingDuringInstall
        {
            get { return _displayWarningWhenResolvingDuringInstall; }
        }

        // When this is set to true and the application is exitted, all the scenes will be
        // destroyed in the reverse order in which they were loaded, and then the project context
        // will be destroyed last
        // When this is set to false (the default) the order that this occurs in is not predictable
        // It is set to false by default because manually destroying objects during OnApplicationQuit
        // event can cause crashes on android (see github issue #468)
        public bool EnsureDeterministicDestructionOrderOnApplicationQuit
        {
            get { return _ensureDeterministicDestructionOrderOnApplicationQuit; }
        }

        [Serializable]
        public class SignalSettings
        {
            public static SignalSettings Default = new SignalSettings();

#if !NOT_UNITY3D
            [SerializeField]
#endif
            SignalDefaultSyncModes _defaultSyncMode;

#if !NOT_UNITY3D
            [SerializeField]
#endif
            SignalMissingHandlerResponses _missingHandlerDefaultResponse;

#if !NOT_UNITY3D
            [SerializeField]
#endif
            bool _requireStrictUnsubscribe;

#if !NOT_UNITY3D
            [SerializeField]
#endif
            int _defaultAsyncTickPriority;

            public SignalSettings(
                SignalDefaultSyncModes defaultSyncMode,
                SignalMissingHandlerResponses missingHandlerDefaultResponse = SignalMissingHandlerResponses.Warn,
                bool requireStrictUnsubscribe = false,
                // Run right after all the unspecified tick priorities so that the effects of the
                // signal are handled during the same frame when they are triggered
                int defaultAsyncTickPriority = 1)
            {
                _defaultSyncMode = defaultSyncMode;
                _missingHandlerDefaultResponse = missingHandlerDefaultResponse;
                _requireStrictUnsubscribe = requireStrictUnsubscribe;
                _defaultAsyncTickPriority = defaultAsyncTickPriority;
            }

            // Need to define an emtpy constructor since this is created by unity serialization
            // even if the above constructor has defaults for all
            public SignalSettings()
                : this(SignalDefaultSyncModes.Synchronous)
            {
            }

            public int DefaultAsyncTickPriority
            {
                get { return _defaultAsyncTickPriority; }
            }

            public SignalDefaultSyncModes DefaultSyncMode
            {
                get { return _defaultSyncMode; }
            }

            public SignalMissingHandlerResponses MissingHandlerDefaultResponse
            {
                get { return _missingHandlerDefaultResponse; }
            }

            public bool RequireStrictUnsubscribe
            {
                get { return _requireStrictUnsubscribe; }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Main/ZenjectSettings.cs.meta
================================================
fileFormatVersion: 2
guid: 1581703805dca9046a9197095cbbf3d1
timeCreated: 1527493251
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/CachedOpenTypeProvider.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class CachedOpenTypeProvider : IProvider
    {
        readonly IProvider _creator;
        readonly List<List<object>> _cachedInstances = new List<List<object>>();

#if ZEN_MULTITHREADING
        readonly object _locker = new object();
#else
        bool _isCreatingInstance;
#endif

        public CachedOpenTypeProvider(IProvider creator)
        {
            Assert.That(creator.TypeVariesBasedOnMemberType);
            _creator = creator;
        }

        public bool IsCached
        {
            get { return true; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get
            {
                // Should not call this
                throw Assert.CreateException();
            }
        }

        public int NumInstances
        {
            get
            {
#if ZEN_MULTITHREADING
                lock (_locker)
#endif
                {
                    return _cachedInstances.Select(x => x.Count).Sum();
                }
            }
        }

        // This method can be called if you want to clear the memory for an AsSingle instance,
        // See isssue https://github.com/svermeulen/Zenject/issues/441
        public void ClearCache()
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                _cachedInstances.Clear();
            }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _creator.GetInstanceType(context);
        }

        List<object> TryGetMatchFromCache(Type memberType)
        {
            List<object> result = null;

            for (int i = 0; i < _cachedInstances.Count; i++) 
            {
                var instanceList = _cachedInstances[i];

                bool matchesAll = true;

                for (int k = 0; k < instanceList.Count; k++) 
                {
                    var instance = instanceList[k];

                    if (instance == null) 
                    {
                        if (memberType.IsValueType()) 
                        {
                            matchesAll = false;
                            break;
                        }

                        continue;
                    }

                    if (!instance.GetType().DerivesFromOrEqual(memberType)) 
                    {
                        matchesAll = false;
                        break;
                    }
                }

                if (matchesAll) 
                {
                    Assert.IsNull(result); // Is there any case where this is hit?
                    result = instanceList;
                }
            }

            return result;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                var instances = TryGetMatchFromCache(context.MemberType);

                if (instances != null)
                {
                    injectAction = null;
                    buffer.AllocFreeAddRange(instances);
                    return;
                }

#if !ZEN_MULTITHREADING
                // This should only happen with constructor injection
                // Field or property injection should allow circular dependencies
                if (_isCreatingInstance)
                {
                    var instanceType = _creator.GetInstanceType(context);
                    throw Assert.CreateException(
                        "Found circular dependency when creating type '{0}'. Object graph:\n {1}{2}\n",
                        instanceType, context.GetObjectGraphString(), instanceType);
                }

                _isCreatingInstance = true;
#endif

                instances = new List<object>();
                _creator.GetAllInstancesWithInjectSplit(
                    context, args, out injectAction, instances);
                Assert.IsNotNull(instances);

                _cachedInstances.Add(instances);
#if !ZEN_MULTITHREADING
                _isCreatingInstance = false;
#endif
                buffer.AllocFreeAddRange(instances);
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/CachedOpenTypeProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 4a09a4770eaace44a84d9d627f0bd161
timeCreated: 1528211680
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/CachedProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class CachedProvider : IProvider
    {
        readonly IProvider _creator;

        List<object> _instances;

#if ZEN_MULTITHREADING
        readonly object _locker = new object();
#else
        bool _isCreatingInstance;
#endif

        public CachedProvider(IProvider creator)
        {
            _creator = creator;
        }

        public bool IsCached
        {
            get { return true; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get
            {
                // Should not call this
                throw Assert.CreateException();
            }
        }

        public int NumInstances
        {
            get
            {
#if ZEN_MULTITHREADING
                lock (_locker)
#endif
                {
                    return _instances == null ? 0 : _instances.Count;
                }
            }
        }

        // This method can be called if you want to clear the memory for an AsSingle instance,
        // See isssue https://github.com/svermeulen/Zenject/issues/441
        public void ClearCache()
        {
#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                _instances = null;
            }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _creator.GetInstanceType(context);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                if (_instances != null)
                {
                    injectAction = null;
                    buffer.AllocFreeAddRange(_instances);
                    return;
                }

#if !ZEN_MULTITHREADING
                // This should only happen with constructor injection
                // Field or property injection should allow circular dependencies
                if (_isCreatingInstance)
                {
                    var instanceType = _creator.GetInstanceType(context);
                    throw Assert.CreateException(
                        "Found circular dependency when creating type '{0}'. Object graph:\n {1}{2}\n",
                        instanceType, context.GetObjectGraphString(), instanceType);
                }

                _isCreatingInstance = true;
#endif

                var instances = new List<object>();
                _creator.GetAllInstancesWithInjectSplit(context, args, out injectAction, instances);
                Assert.IsNotNull(instances);

                _instances = instances;
#if !ZEN_MULTITHREADING
                _isCreatingInstance = false;
#endif
                buffer.AllocFreeAddRange(instances);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/CachedProvider.cs.meta
================================================
fileFormatVersion: 2
guid: e6e16beb21a2f0d4db901700c6ed3099
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders.meta
================================================
fileFormatVersion: 2
guid: d80a7db637267834388a31f2b7ddcf36
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/Decorator.meta
================================================
fileFormatVersion: 2
guid: 88c8658f07bf600408a596245682c306
folderAsset: yes
timeCreated: 1528368268
licenseType: Free
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GameObjectProviders.meta
================================================
fileFormatVersion: 2
guid: 5c4a4be4639cdfc4c8d00456887fefb6
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GetterProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class GetterProvider<TObj, TResult> : IProvider
    {
        readonly DiContainer _container;
        readonly object _identifier;
        readonly Func<TObj, TResult> _method;
        readonly bool _matchAll;
        readonly InjectSources _sourceType;

        public GetterProvider(
            object identifier, Func<TObj, TResult> method,
            DiContainer container, InjectSources sourceType, bool matchAll)
        {
            _container = container;
            _identifier = identifier;
            _method = method;
            _matchAll = matchAll;
            _sourceType = sourceType;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TResult);
        }

        InjectContext GetSubContext(InjectContext parent)
        {
            var subContext = parent.CreateSubContext(
                typeof(TObj), _identifier);

            subContext.Optional = false;
            subContext.SourceType = _sourceType;

            return subContext;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(typeof(TResult).DerivesFromOrEqual(context.MemberType));

            injectAction = null;

            if (_container.IsValidating)
            {
                // All we can do is validate that the getter object can be resolved
                if (_matchAll)
                {
                    _container.ResolveAll(GetSubContext(context));
                }
                else
                {
                    _container.Resolve(GetSubContext(context));
                }

                buffer.Add(new ValidationMarker(typeof(TResult)));
                return;
            }

            if (_matchAll)
            {
                Assert.That(buffer.Count == 0);
                _container.ResolveAll(GetSubContext(context), buffer);

                for (int i = 0; i < buffer.Count; i++)
                {
                    buffer[i] = _method((TObj)buffer[i]);
                }
            }
            else
            {
                buffer.Add(_method(
                    (TObj)_container.Resolve(GetSubContext(context))));
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GetterProvider.cs.meta
================================================
fileFormatVersion: 2
guid: ce3e2ecdd52e4db469d9bc497ff5e5f5
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IFactoryProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    public abstract class IFactoryProviderBase<TContract> : IProvider
    {
        public IFactoryProviderBase(
            DiContainer container, Guid factoryId)
        {
            Container = container;
            FactoryId = factoryId;
        }

        public bool IsCached
        {
            get { return false; }
        }

        protected Guid FactoryId
        {
            get;
            private set;
        }

        protected DiContainer Container
        {
            get;
            private set;
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TContract);
        }

        public abstract void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer);
    }

    // Zero parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(
            DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.That(args.IsEmpty());

            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(((IFactory<TContract>)factory).Create());
            }
        }
    }

    // One parameter

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here

                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(((IFactory<TParam1, TContract>)factory).Create((TParam1)args[0].Value));
            }
        }
    }

    // Two parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value));
            }
        }
    }

    // Three parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TParam3, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TParam3, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TParam3, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value));
            }
        }
    }

    // Four parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TParam3, TParam4, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TParam3, TParam4, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value));
            }
        }
    }

    // Five parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value));
            }
        }
    }

    // Six parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 6);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value,
                        (TParam6)args[5].Value));
            }
        }
    }

    // Ten parameters

    [NoReflectionBaking]
    public class IFactoryProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract> : IFactoryProviderBase<TContract>
    {
        public IFactoryProvider(DiContainer container, Guid factoryId)
            : base(container, factoryId)
        {
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 10);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());
            Assert.That(args[6].Type.DerivesFromOrEqual<TParam7>());
            Assert.That(args[7].Type.DerivesFromOrEqual<TParam8>());
            Assert.That(args[8].Type.DerivesFromOrEqual<TParam9>());
            Assert.That(args[9].Type.DerivesFromOrEqual<TParam10>());

            // Do this even when validating in case it has its own dependencies
            var factory = Container.ResolveId(typeof(IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>), FactoryId);

            injectAction = null;
            if (Container.IsValidating)
            {
                // We assume here that we are creating a user-defined factory so there's
                // nothing else we can validate here
                buffer.Add(new ValidationMarker(typeof(TContract)));
            }
            else
            {
                buffer.Add(
                    ((IFactory<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TContract>)factory).Create(
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value,
                        (TParam6)args[5].Value,
                        (TParam7)args[6].Value,
                        (TParam8)args[7].Value,
                        (TParam9)args[8].Value,
                        (TParam10)args[9].Value));
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IFactoryProvider.cs.meta
================================================
fileFormatVersion: 2
guid: eaf07c2b7ad9f684dac7f1da2ee67f5c
timeCreated: 1520700396
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/InstanceProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class InstanceProvider : IProvider
    {
        readonly object _instance;
        readonly Type _instanceType;
        readonly DiContainer _container;
        readonly Action<InjectContext, object> _instantiateCallback;

        public InstanceProvider(
            Type instanceType, object instance, DiContainer container, Action<InjectContext, object> instantiateCallback)
        {
            _instanceType = instanceType;
            _instance = instance;
            _container = container;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return true; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _instanceType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.That(args.Count == 0);
            Assert.IsNotNull(context);

            Assert.That(_instanceType.DerivesFromOrEqual(context.MemberType));

            injectAction = () =>
            {
                object instance = _container.LazyInject(_instance);

                if (_instantiateCallback != null)
                {
                    _instantiateCallback(context, instance);
                }
            };

            buffer.Add(_instance);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/InstanceProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 1d3d5b3bdf966444099f2dfdf3a313fd
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IProvider.cs
================================================
using System;
using System.Collections.Generic;

namespace Zenject
{
    // The given InjectContext values here should always be non-null
    public interface IProvider
    {
        bool TypeVariesBasedOnMemberType
        {
            get;
        }

        bool IsCached
        {
            get;
        }

        Type GetInstanceType(InjectContext context);

        // Return an instance which might be not yet injected to.
        // injectAction should handle the actual injection
        // This way, providers that call CreateInstance() can store the instance immediately,
        // and then return that if something gets created during injection that refers back
        // to the newly created instance
        void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> instances);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 438b6366f2f1221448e9a71e09ac0329
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IProviderExtensions.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    public static class IProviderExtensions
    {
        static readonly List<TypeValuePair> EmptyArgList = new List<TypeValuePair>();

        public static void GetAllInstancesWithInjectSplit(
            this IProvider creator, InjectContext context, out Action injectAction, List<object> buffer)
        {
            creator.GetAllInstancesWithInjectSplit(
                context, EmptyArgList, out injectAction, buffer);
        }

        public static void GetAllInstances(
            this IProvider creator, InjectContext context, List<object> buffer)
        {
            creator.GetAllInstances(context, EmptyArgList, buffer);
        }

        public static void GetAllInstances(
            this IProvider creator, InjectContext context, List<TypeValuePair> args, List<object> buffer)
        {
            Assert.IsNotNull(context);

            Action injectAction;
            creator.GetAllInstancesWithInjectSplit(context, args, out injectAction, buffer);

            if (injectAction != null)
            {
                injectAction.Invoke();
            }
        }

        public static object TryGetInstance(
            this IProvider creator, InjectContext context)
        {
            return creator.TryGetInstance(context, EmptyArgList);
        }

        public static object TryGetInstance(
            this IProvider creator, InjectContext context, List<TypeValuePair> args)
        {
            var allInstances = ZenPools.SpawnList<object>();

            try
            {
                creator.GetAllInstances(context, args, allInstances);

                if (allInstances.Count == 0)
                {
                    return null;
                }

                Assert.That(allInstances.Count == 1,
                    "Provider returned multiple instances when one or zero was expected");

                return allInstances[0];
            }
            finally
            {
                ZenPools.DespawnList(allInstances);
            }
        }

        public static object GetInstance(
            this IProvider creator, InjectContext context)
        {
            return creator.GetInstance(context, EmptyArgList);
        }

        public static object GetInstance(
            this IProvider creator, InjectContext context, List<TypeValuePair> args)
        {
            var allInstances = ZenPools.SpawnList<object>();

            try
            {
                creator.GetAllInstances(context, args, allInstances);

                Assert.That(allInstances.Count > 0,
                    "Provider returned zero instances when one was expected when looking up type '{0}'", context.MemberType);

                Assert.That(allInstances.Count == 1,
                    "Provider returned multiple instances when only one was expected when looking up type '{0}'", context.MemberType);

                return allInstances[0];
            }
            finally
            {
                ZenPools.DespawnList(allInstances);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/IProviderExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 2377e3000d1616e4d8cb29c183f216b4
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodMultipleProviderUntyped.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MethodMultipleProviderUntyped : IProvider
    {
        readonly DiContainer _container;
        readonly Func<InjectContext, IEnumerable<object>> _method;

        public MethodMultipleProviderUntyped(
            Func<InjectContext, IEnumerable<object>> method,
            DiContainer container)
        {
            _container = container;
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return context.MemberType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            injectAction = null;
            if (_container.IsValidating && !TypeAnalyzer.ShouldAllowDuringValidation(context.MemberType))
            {
                buffer.Add(new ValidationMarker(context.MemberType));
            }
            else
            {
                var result = _method(context);

                if (result == null)
                {
                    throw Assert.CreateException(
                        "Method '{0}' returned null when list was expected. Object graph:\n {1}",
                        _method.ToDebugString(), context.GetObjectGraphString());
                }

                foreach (var obj in result)
                {
                    buffer.Add(obj);
                }
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodMultipleProviderUntyped.cs.meta
================================================
fileFormatVersion: 2
guid: dd9674ffe36a06141afeab1ebbc399f0
timeCreated: 1529046908
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MethodProvider<TReturn> : IProvider
    {
        readonly DiContainer _container;
        readonly Func<InjectContext, TReturn> _method;

        public MethodProvider(
            Func<InjectContext, TReturn> method,
            DiContainer container)
        {
            _container = container;
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TReturn);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(typeof(TReturn).DerivesFromOrEqual(context.MemberType));

            injectAction = null;
            if (_container.IsValidating && !TypeAnalyzer.ShouldAllowDuringValidation(context.MemberType))
            {
                buffer.Add(new ValidationMarker(typeof(TReturn)));
            }
            else
            {
                // We cannot do a null assert here because in some cases they might intentionally
                // return null
                buffer.Add(_method(context));
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 22a7321581383d141b4c11983b83e67b
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderMultiple.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MethodProviderMultiple<TReturn> : IProvider
    {
        readonly DiContainer _container;
        readonly Func<InjectContext, IEnumerable<TReturn>> _method;

        public MethodProviderMultiple(
            Func<InjectContext, IEnumerable<TReturn>> method,
            DiContainer container)
        {
            _container = container;
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TReturn);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(typeof(TReturn).DerivesFromOrEqual(context.MemberType));

            injectAction = null;
            if (_container.IsValidating && !TypeAnalyzer.ShouldAllowDuringValidation(context.MemberType))
            {
                buffer.Add(new ValidationMarker(typeof(TReturn)));
            }
            else
            {
                var result = _method(context);

                if (result == null)
                {
                    throw Assert.CreateException(
                        "Method '{0}' returned null when list was expected. Object graph:\n {1}",
                        _method.ToDebugString(), context.GetObjectGraphString());
                }

                foreach (var obj in result)
                {
                    buffer.Add(obj);
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderMultiple.cs.meta
================================================
fileFormatVersion: 2
guid: 0e5a590d4406d6e46ba319046057db53
timeCreated: 1485738781
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderSimple.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MethodProviderSimple<TReturn> : IProvider
    {
        readonly Func<TReturn> _method;

        public MethodProviderSimple(Func<TReturn> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TReturn);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(typeof(TReturn).DerivesFromOrEqual(context.MemberType));

            injectAction = null;
            buffer.Add(_method());
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderSimple.cs.meta
================================================
fileFormatVersion: 2
guid: eee2b774c35c53641b09b0c1e9620e03
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderUntyped.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class MethodProviderUntyped : IProvider
    {
        readonly DiContainer _container;
        readonly Func<InjectContext, object> _method;

        public MethodProviderUntyped(
            Func<InjectContext, object> method,
            DiContainer container)
        {
            _container = container;
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return context.MemberType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            injectAction = null;
            if (_container.IsValidating && !TypeAnalyzer.ShouldAllowDuringValidation(context.MemberType))
            {
                buffer.Add(new ValidationMarker(context.MemberType));
            }
            else
            {
                var result = _method(context);

                if (result == null)
                {
                    Assert.That(!context.MemberType.IsPrimitive(),
                        "Invalid value returned from FromMethod.  Expected non-null.");
                }
                else
                {
                    Assert.That(result.GetType().DerivesFromOrEqual(context.MemberType));
                }

                buffer.Add(result);
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderUntyped.cs.meta
================================================
fileFormatVersion: 2
guid: bddc7ee81ed8fd84cbf60eebf5cb3e41
timeCreated: 1465495310
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderWithContainer.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    // Zero params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TValue> : IProvider
    {
        readonly Func<DiContainer, TValue> _method;

        public MethodProviderWithContainer(Func<DiContainer, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(_method(context.Container));
            }
        }
    }

    // One params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TValue> : IProvider
    {
        readonly Func<DiContainer, TParam1, TValue> _method;

        public MethodProviderWithContainer(Func<DiContainer, TParam1, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value));
            }
        }
    }

    // Two params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TValue> : IProvider
    {
        readonly Func<DiContainer, TParam1, TParam2, TValue> _method;

        public MethodProviderWithContainer(Func<DiContainer, TParam1, TParam2, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value));
            }
        }
    }

    // Three params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TParam3, TValue> : IProvider
    {
        readonly Func<DiContainer, TParam1, TParam2, TParam3, TValue> _method;

        public MethodProviderWithContainer(Func<DiContainer, TParam1, TParam2, TParam3, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));
            Assert.That(args[2].Type.DerivesFromOrEqual(typeof(TParam3)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value));
            }
        }
    }

    // Four params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TValue> : IProvider
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TValue> _method;

        public MethodProviderWithContainer(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));
            Assert.That(args[2].Type.DerivesFromOrEqual(typeof(TParam3)));
            Assert.That(args[3].Type.DerivesFromOrEqual(typeof(TParam4)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value));
            }
        }
    }

    // Five params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> : IProvider
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TValue> _method;

        public MethodProviderWithContainer(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));
            Assert.That(args[2].Type.DerivesFromOrEqual(typeof(TParam3)));
            Assert.That(args[3].Type.DerivesFromOrEqual(typeof(TParam4)));
            Assert.That(args[4].Type.DerivesFromOrEqual(typeof(TParam5)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value));
            }
        }
    }

    // Six params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> : IProvider
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> _method;

        public MethodProviderWithContainer(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));
            Assert.That(args[2].Type.DerivesFromOrEqual(typeof(TParam3)));
            Assert.That(args[3].Type.DerivesFromOrEqual(typeof(TParam4)));
            Assert.That(args[4].Type.DerivesFromOrEqual(typeof(TParam5)));
            Assert.That(args[5].Type.DerivesFromOrEqual(typeof(TParam6)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value,
                        (TParam6)args[5].Value));
            }
        }
    }

    // Ten params

    [NoReflectionBaking]
    public class MethodProviderWithContainer<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue> : IProvider
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue> _method;

        public MethodProviderWithContainer(
#if !NET_4_6
            ModestTree.Util.
#endif
            Func<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10, TValue> method)
        {
            _method = method;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TValue);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 10);
            Assert.IsNotNull(context);

            Assert.That(typeof(TValue).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual(typeof(TParam1)));
            Assert.That(args[1].Type.DerivesFromOrEqual(typeof(TParam2)));
            Assert.That(args[2].Type.DerivesFromOrEqual(typeof(TParam3)));
            Assert.That(args[3].Type.DerivesFromOrEqual(typeof(TParam4)));
            Assert.That(args[4].Type.DerivesFromOrEqual(typeof(TParam5)));
            Assert.That(args[5].Type.DerivesFromOrEqual(typeof(TParam6)));
            Assert.That(args[6].Type.DerivesFromOrEqual(typeof(TParam7)));
            Assert.That(args[7].Type.DerivesFromOrEqual(typeof(TParam8)));
            Assert.That(args[8].Type.DerivesFromOrEqual(typeof(TParam9)));
            Assert.That(args[9].Type.DerivesFromOrEqual(typeof(TParam10)));

            injectAction = null;
            if (context.Container.IsValidating)
            {
                // Don't do anything when validating, we can't make any assumptions on the given method
                buffer.Add(new ValidationMarker(typeof(TValue)));
            }
            else
            {
                buffer.Add(
                    _method(
                        context.Container,
                        (TParam1)args[0].Value,
                        (TParam2)args[1].Value,
                        (TParam3)args[2].Value,
                        (TParam4)args[3].Value,
                        (TParam5)args[4].Value,
                        (TParam6)args[5].Value,
                        (TParam7)args[6].Value,
                        (TParam8)args[7].Value,
                        (TParam9)args[8].Value,
                        (TParam10)args[9].Value));
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/MethodProviderWithContainer.cs.meta
================================================
fileFormatVersion: 2
guid: eb5886f51fc492043bf8d0cc8f4daa2e
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PoolableMemoryPoolProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    public abstract class PoolableMemoryPoolProviderBase<TContract> : IProvider
    {
        public PoolableMemoryPoolProviderBase(
            DiContainer container, Guid poolId)
        {
            Container = container;
            PoolId = poolId;
        }

        public bool IsCached
        {
            get { return false; }
        }

        protected Guid PoolId
        {
            get;
            private set;
        }

        protected DiContainer Container
        {
            get;
            private set;
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(TContract);
        }

        public abstract void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer);
    }

    // Zero parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<IMemoryPool>
        where TMemoryPool : MemoryPool<IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.That(args.IsEmpty());

            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(_pool));
        }
    }

    // One parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn((TParam1)args[0].Value, _pool));
        }
    }

    // Two parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TParam2, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, TParam2, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, TParam2, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                _pool));
        }
    }

    // Three parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, TParam2, TParam3, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                _pool));
        }
    }

    // Four parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                _pool));
        }
    }

    // Five parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                (TParam5)args[4].Value,
                _pool));
        }
    }

    // Six parameters

    [NoReflectionBaking]
    public class PoolableMemoryPoolProvider<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TContract, TMemoryPool> : PoolableMemoryPoolProviderBase<TContract>, IValidatable
        where TContract : IPoolable<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool>
        where TMemoryPool : MemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, IMemoryPool, TContract>
    {
        TMemoryPool _pool;

        public PoolableMemoryPoolProvider(
            DiContainer container, Guid poolId)
            : base(container, poolId)
        {
        }

        public void Validate()
        {
            Container.ResolveId<TMemoryPool>(PoolId);
        }

        public override void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEqual(args.Count, 6);
            Assert.IsNotNull(context);

            Assert.That(typeof(TContract).DerivesFromOrEqual(context.MemberType));
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());

            injectAction = null;

            if (_pool == null)
            {
                _pool = Container.ResolveId<TMemoryPool>(PoolId);
            }

            buffer.Add(_pool.Spawn(
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                (TParam5)args[4].Value,
                (TParam6)args[5].Value,
                _pool));
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PoolableMemoryPoolProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 6857585e55699ab4da01454c662e0e3b
timeCreated: 1528529860
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators.meta
================================================
fileFormatVersion: 2
guid: 4a029f9358245bf4e99fcb7fcc19ba28
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders.meta
================================================
fileFormatVersion: 2
guid: 4248afcd0d89aa54da8d2c34a41c5712
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ProviderUtil.cs
================================================
using System;
using ModestTree;

namespace Zenject
{
    public static class ProviderUtil
    {
        public static Type GetTypeToInstantiate(Type contractType, Type concreteType)
        {
#if !(UNITY_WSA && ENABLE_DOTNET)
            // TODO: Is it possible to do this on WSA?

            if (concreteType.IsOpenGenericType())
            {
                return concreteType.MakeGenericType(contractType.GetGenericArguments());
            }
#endif

            Assert.DerivesFromOrEqual(concreteType, contractType);
            return concreteType;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ProviderUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 278c72df466e8b049bc7ce6feb535cb1
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ResolveProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class ResolveProvider : IProvider
    {
        readonly object _identifier;
        readonly DiContainer _container;
        readonly Type _contractType;
        readonly bool _isOptional;
        readonly InjectSources _source;
        readonly bool _matchAll;

        public ResolveProvider(
            Type contractType, DiContainer container, object identifier,
            bool isOptional, InjectSources source, bool matchAll)
        {
            _contractType = contractType;
            _identifier = identifier;
            _container = container;
            _isOptional = isOptional;
            _source = source;
            _matchAll = matchAll;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _contractType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);
            Assert.IsNotNull(context);

            Assert.That(_contractType.DerivesFromOrEqual(context.MemberType));

            injectAction = null;
            if (_matchAll)
            {
                _container.ResolveAll(GetSubContext(context), buffer);
            }
            else
            {
                buffer.Add(_container.Resolve(GetSubContext(context)));
            }
        }

        InjectContext GetSubContext(InjectContext parent)
        {
            var subContext = parent.CreateSubContext(_contractType, _identifier);

            subContext.SourceType = _source;
            subContext.Optional = _isOptional;

            return subContext;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ResolveProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 35df94e99ddd0c04c86cf0bcefa85ad8
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ResourceProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class ResourceProvider : IProvider
    {
        readonly Type _resourceType;
        readonly string _resourcePath;
        readonly bool _matchSingle;

        public ResourceProvider(
            string resourcePath, Type resourceType, bool matchSingle)
        {
            _resourceType = resourceType;
            _resourcePath = resourcePath;
            _matchSingle = matchSingle;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _resourceType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);

            Assert.IsNotNull(context);

            if (_matchSingle)
            {
                var obj = Resources.Load(_resourcePath, _resourceType);

                Assert.That(obj != null,
                "Could not find resource at path '{0}' with type '{1}'", _resourcePath, _resourceType);

                // Are there any resource types which can be injected?
                injectAction = null;
                buffer.Add(obj);
                return;
            }

            var objects = Resources.LoadAll(_resourcePath, _resourceType);

            Assert.That(objects.Length > 0,
            "Could not find resource at path '{0}' with type '{1}'", _resourcePath, _resourceType);

            // Are there any resource types which can be injected?
            injectAction = null;

            buffer.AllocFreeAddRange(objects);
        }
    }
}

#endif





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ResourceProvider.cs.meta
================================================
fileFormatVersion: 2
guid: f16c8e5eed02ac8478e8c236c1677db3
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ScriptableObjectInstanceProvider.cs
================================================
﻿#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class ScriptableObjectInstanceProvider : IProvider
    {
        readonly DiContainer _container;
        readonly Type _resourceType;
        readonly List<TypeValuePair> _extraArguments;
        readonly bool _createNew;
        readonly object _concreteIdentifier;
        readonly Action<InjectContext, object> _instantiateCallback;
        readonly UnityEngine.Object _resource;

        public ScriptableObjectInstanceProvider(
            UnityEngine.Object resource, Type resourceType,
            DiContainer container, IEnumerable<TypeValuePair> extraArguments,
            bool createNew, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
        {
            _container = container;
            Assert.DerivesFromOrEqual<ScriptableObject>(resourceType);

            _resource = resource;
            _extraArguments = extraArguments.ToList();
            _resourceType = resourceType;
            _createNew = createNew;
            _concreteIdentifier = concreteIdentifier;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _resourceType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            if (_createNew)
            {
                buffer.Add(UnityEngine.ScriptableObject.Instantiate(_resource));
            }
            else
            {
                buffer.Add(_resource);
            }

            injectAction = () =>
            {
                for (int i = 0; i < buffer.Count; i++)
                {
                    var obj = buffer[i];

                    var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                    extraArgs.AllocFreeAddRange(_extraArguments);
                    extraArgs.AllocFreeAddRange(args);

                    _container.InjectExplicit(
                        obj, _resourceType, extraArgs, context, _concreteIdentifier);

                    ZenPools.DespawnList(extraArgs);

                    if (_instantiateCallback != null)
                    {
                        _instantiateCallback(context, obj);
                    }
                }
            };
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ScriptableObjectInstanceProvider.cs.meta
================================================
fileFormatVersion: 2
guid: dd4cee241217b5947b3a223dabefec0a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ScriptableObjectResourceProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class ScriptableObjectResourceProvider : IProvider
    {
        readonly DiContainer _container;
        readonly Type _resourceType;
        readonly string _resourcePath;
        readonly List<TypeValuePair> _extraArguments;
        readonly bool _createNew;
        readonly object _concreteIdentifier;
        readonly Action<InjectContext, object> _instantiateCallback;

        public ScriptableObjectResourceProvider(
            string resourcePath, Type resourceType,
            DiContainer container, IEnumerable<TypeValuePair> extraArguments,
            bool createNew, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
        {
            _container = container;
            Assert.DerivesFromOrEqual<ScriptableObject>(resourceType);

            _extraArguments = extraArguments.ToList();
            _resourceType = resourceType;
            _resourcePath = resourcePath;
            _createNew = createNew;
            _concreteIdentifier = concreteIdentifier;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _resourceType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            if (_createNew)
            {
                var objects = Resources.LoadAll(_resourcePath, _resourceType);

                for (int i = 0; i < objects.Length; i++)
                {
                    buffer.Add(ScriptableObject.Instantiate(objects[i]));
                }
            }
            else
            {
                buffer.AllocFreeAddRange(
                    Resources.LoadAll(_resourcePath, _resourceType));
            }

            Assert.That(buffer.Count > 0,
            "Could not find resource at path '{0}' with type '{1}'", _resourcePath, _resourceType);

            injectAction = () =>
            {
                for (int i = 0; i < buffer.Count; i++)
                {
                    var obj = buffer[i];

                    var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                    extraArgs.AllocFreeAddRange(_extraArguments);
                    extraArgs.AllocFreeAddRange(args);

                    _container.InjectExplicit(
                        obj, _resourceType, extraArgs, context, _concreteIdentifier);

                    ZenPools.DespawnList(extraArgs);

                    if (_instantiateCallback != null)
                    {
                        _instantiateCallback(context, obj);
                    }
                }
            };
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ScriptableObjectResourceProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 5753f1f4d468e7649b017dee98c6301d
timeCreated: 1486668547
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators.meta
================================================
fileFormatVersion: 2
guid: 60492d3348bd7624a9f7f00d1e20ae8e
folderAsset: yes
timeCreated: 1461708046
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerDependencyProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerDependencyProvider : IProvider
    {
        readonly ISubContainerCreator _subContainerCreator;
        readonly Type _dependencyType;
        readonly object _identifier;
        readonly bool _resolveAll;

        // if concreteType is null we use the contract type from inject context
        public SubContainerDependencyProvider(
            Type dependencyType,
            object identifier,
            ISubContainerCreator subContainerCreator, bool resolveAll)
        {
            _subContainerCreator = subContainerCreator;
            _dependencyType = dependencyType;
            _identifier = identifier;
            _resolveAll = resolveAll;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _dependencyType;
        }

        InjectContext CreateSubContext(
            InjectContext parent, DiContainer subContainer)
        {
            var subContext = parent.CreateSubContext(_dependencyType, _identifier);

            subContext.Container = subContainer;

            // This is important to avoid infinite loops
            subContext.SourceType = InjectSources.Local;

            return subContext;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            var subContainer = _subContainerCreator.CreateSubContainer(args, context, out injectAction);

            var subContext = CreateSubContext(context, subContainer);

            if (_resolveAll)
            {
                subContainer.ResolveAll(subContext, buffer);
                return;
            }

            buffer.Add(subContainer.Resolve(subContext));
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerDependencyProvider.cs.meta
================================================
fileFormatVersion: 2
guid: d569147915c61b64f9841ca4948f7d3f
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/TransientProvider.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class TransientProvider : IProvider
    {
        readonly DiContainer _container;
        readonly Type _concreteType;
        readonly List<TypeValuePair> _extraArguments;
        readonly object _concreteIdentifier;
        readonly Action<InjectContext, object> _instantiateCallback;

        public TransientProvider(
            Type concreteType, DiContainer container,
            IEnumerable<TypeValuePair> extraArguments, string bindingContext,
            object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
        {
            Assert.That(!concreteType.IsAbstract(),
                "Expected non-abstract type for given binding but instead found type '{0}'{1}",
                concreteType, bindingContext == null ? "" : " when binding '{0}'".Fmt(bindingContext));

            _container = container;
            _concreteType = concreteType;
            _extraArguments = extraArguments.ToList();
            _concreteIdentifier = concreteIdentifier;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return _concreteType.IsOpenGenericType(); }
        }

        public Type GetInstanceType(InjectContext context)
        {
            if (!_concreteType.DerivesFromOrEqual(context.MemberType))
            {
                return null;
            }

            return GetTypeToCreate(context.MemberType);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            var instanceType = GetTypeToCreate(context.MemberType);

            var extraArgs = ZenPools.SpawnList<TypeValuePair>();

            extraArgs.AllocFreeAddRange(_extraArguments);
            extraArgs.AllocFreeAddRange(args);

            var instance = _container.InstantiateExplicit(instanceType, false, extraArgs, context, _concreteIdentifier);

            injectAction = () =>
            {
                _container.InjectExplicit(
                    instance, instanceType, extraArgs, context, _concreteIdentifier);

                Assert.That(extraArgs.Count == 0);
                ZenPools.DespawnList(extraArgs);

                if (_instantiateCallback != null)
                {
                    _instantiateCallback(context, instance);
                }
            };

            buffer.Add(instance);
        }

        Type GetTypeToCreate(Type contractType)
        {
            return ProviderUtil.GetTypeToInstantiate(contractType, _concreteType);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/TransientProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 84c5bc61bc03f17468a1953edb7dcd42
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders.meta
================================================
fileFormatVersion: 2
guid: 5a0ec9eb479742940a10701ec8a1d087
folderAsset: yes
timeCreated: 1461708047
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromGameObjectComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class GetFromGameObjectComponentProvider : IProvider
    {
        readonly GameObject _gameObject;
        readonly Type _componentType;
        readonly bool _matchSingle;

        // if concreteType is null we use the contract type from inject context
        public GetFromGameObjectComponentProvider(
            Type componentType, GameObject gameObject, bool matchSingle)
        {
            _componentType = componentType;
            _matchSingle = matchSingle;
            _gameObject = gameObject;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            injectAction = null;

            if (_matchSingle)
            {
                var match = _gameObject.GetComponent(_componentType);

                Assert.IsNotNull(match, "Could not find component with type '{0}' on prefab '{1}'",
                _componentType, _gameObject.name);

                buffer.Add(match);
                return;
            }

            var allComponents = _gameObject.GetComponents(_componentType);

            Assert.That(allComponents.Length >= 1,
            "Expected to find at least one component with type '{0}' on prefab '{1}'",
            _componentType, _gameObject.name);

            buffer.AllocFreeAddRange(allComponents);
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromGameObjectComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 8d5cdba9f2e79364dbf4f3d242fd22da
timeCreated: 1529229722
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromGameObjectGetterComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class GetFromGameObjectGetterComponentProvider : IProvider
    {
        readonly Func<InjectContext, GameObject> _gameObjectGetter;
        readonly Type _componentType;
        readonly bool _matchSingle;

        // if concreteType is null we use the contract type from inject context
        public GetFromGameObjectGetterComponentProvider(
            Type componentType, Func<InjectContext, GameObject> gameObjectGetter, bool matchSingle)
        {
            _componentType = componentType;
            _matchSingle = matchSingle;
            _gameObjectGetter = gameObjectGetter;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            injectAction = null;

            if (context.Container.IsValidating)
            {
                buffer.Add(new ValidationMarker(_componentType));
            }
            else
            {
                var gameObject = _gameObjectGetter(context);

                if (_matchSingle)
                {
                    var match = gameObject.GetComponent(_componentType);

                    Assert.IsNotNull(match, "Could not find component with type '{0}' on game object '{1}'",
                    _componentType, gameObject.name);

                    buffer.Add(match);
                    return;
                }

                var allComponents = gameObject.GetComponents(_componentType);

                Assert.That(allComponents.Length >= 1,
                "Expected to find at least one component with type '{0}' on prefab '{1}'",
                _componentType, gameObject.name);

                buffer.AllocFreeAddRange(allComponents);
            }
        }
    }
}

#endif





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromGameObjectGetterComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 766643a5935eb704a929da28681bf70e
timeCreated: 1529230207
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromPrefabComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class GetFromPrefabComponentProvider : IProvider
    {
        readonly IPrefabInstantiator _prefabInstantiator;
        readonly Type _componentType;
        readonly bool _matchSingle;

        // if concreteType is null we use the contract type from inject context
        public GetFromPrefabComponentProvider(
            Type componentType,
            IPrefabInstantiator prefabInstantiator, bool matchSingle)
        {
            _prefabInstantiator = prefabInstantiator;
            _componentType = componentType;
            _matchSingle = matchSingle;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            var gameObject = _prefabInstantiator.Instantiate(context, args, out injectAction);

            // NOTE: Need to set includeInactive to true here, because prefabs are always
            // instantiated as disabled until injection occurs, so that Awake / OnEnabled is executed
            // after injection has occurred

            if (_matchSingle)
            {
                var match = gameObject.GetComponentInChildren(_componentType, true);

                Assert.IsNotNull(match, "Could not find component with type '{0}' on prefab '{1}'",
                _componentType, _prefabInstantiator.GetPrefab(context).name);

                buffer.Add(match);
                return;
            }

            var allComponents = gameObject.GetComponentsInChildren(_componentType, true);

            Assert.That(allComponents.Length >= 1,
                "Expected to find at least one component with type '{0}' on prefab '{1}'",
                _componentType, _prefabInstantiator.GetPrefab(context).name);

            buffer.AllocFreeAddRange(allComponents);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/GetFromPrefabComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: e6a49432e004bd8409d3ddea6a45a3f8
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/InstantiateOnPrefabComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class InstantiateOnPrefabComponentProvider : IProvider
    {
        readonly IPrefabInstantiator _prefabInstantiator;
        readonly Type _componentType;

        // if concreteType is null we use the contract type from inject context
        public InstantiateOnPrefabComponentProvider(
            Type componentType,
            IPrefabInstantiator prefabInstantiator)
        {
            _prefabInstantiator = prefabInstantiator;
            _componentType = componentType;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            var gameObject = _prefabInstantiator.Instantiate(context, args, out injectAction);

            var component = gameObject.AddComponent(_componentType);

            buffer.Add(component);
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/InstantiateOnPrefabComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: e6836adf19243a045ba39e67ade6dd59
timeCreated: 1505729206
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToCurrentGameObjectComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class AddToCurrentGameObjectComponentProvider : IProvider
    {
        readonly Type _componentType;
        readonly DiContainer _container;
        readonly List<TypeValuePair> _extraArguments;
        readonly object _concreteIdentifier;
        readonly Action<InjectContext, object> _instantiateCallback;

        public AddToCurrentGameObjectComponentProvider(
            DiContainer container, Type componentType,
            IEnumerable<TypeValuePair> extraArguments, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
        {
            Assert.That(componentType.DerivesFrom<Component>());

            _extraArguments = extraArguments.ToList();
            _componentType = componentType;
            _container = container;
            _concreteIdentifier = concreteIdentifier;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        protected Type ComponentType
        {
            get { return _componentType; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            Assert.That(context.ObjectType.DerivesFrom<Component>(),
                "Object '{0}' can only be injected into MonoBehaviour's since it was bound with 'FromNewComponentSibling'. Attempted to inject into non-MonoBehaviour '{1}'",
                context.MemberType, context.ObjectType);

            object instance;

            if (!_container.IsValidating || TypeAnalyzer.ShouldAllowDuringValidation(_componentType))
            {
                var gameObj = ((Component)context.ObjectInstance).gameObject;

                var componentInstance = gameObj.GetComponent(_componentType);
                instance = componentInstance;

                // Use componentInstance so that it triggers unity's overloaded comparison operator
                // So if the component is there but missing then it returns null
                // (https://github.com/svermeulen/Zenject/issues/582)
                if (componentInstance != null)
                {
                    injectAction = null;
                    buffer.Add(instance);
                    return;
                }

                instance = gameObj.AddComponent(_componentType);
            }
            else
            {
                instance = new ValidationMarker(_componentType);
            }

            // Note that we don't just use InstantiateComponentOnNewGameObjectExplicit here
            // because then circular references don't work

            injectAction = () =>
            {
                var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                extraArgs.AllocFreeAddRange(_extraArguments);
                extraArgs.AllocFreeAddRange(args);

                _container.InjectExplicit(instance, _componentType, extraArgs, context, _concreteIdentifier);

                Assert.That(extraArgs.IsEmpty());
                ZenPools.DespawnList(extraArgs);

                if (_instantiateCallback != null)
                {
                    _instantiateCallback(context, instance);
                }
            };

            buffer.Add(instance);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToCurrentGameObjectComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 3b0521d85aeb9ee479dcb29ef4d88547
timeCreated: 1465651364
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToExistingGameObjectComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class AddToExistingGameObjectComponentProvider : AddToGameObjectComponentProviderBase
    {
        readonly GameObject _gameObject;

        public AddToExistingGameObjectComponentProvider(
            GameObject gameObject, DiContainer container, Type componentType,
            IEnumerable<TypeValuePair> extraArguments, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
            : base(container, componentType, extraArguments, concreteIdentifier, instantiateCallback)
        {
            _gameObject = gameObject;
        }

        // This will cause [Inject] to be triggered after awake / start
        // We could return true, but what if toggling active has other negative repercussions?
        // For now let's just not do anything
        protected override bool ShouldToggleActive
        {
            get { return false; }
        }

        protected override GameObject GetGameObject(InjectContext context)
        {
            return _gameObject;
        }
    }

    [NoReflectionBaking]
    public class AddToExistingGameObjectComponentProviderGetter : AddToGameObjectComponentProviderBase
    {
        readonly Func<InjectContext, GameObject> _gameObjectGetter;

        public AddToExistingGameObjectComponentProviderGetter(
            Func<InjectContext, GameObject> gameObjectGetter, DiContainer container, Type componentType,
            List<TypeValuePair> extraArguments, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
            : base(container, componentType, extraArguments, concreteIdentifier, instantiateCallback)
        {
            _gameObjectGetter = gameObjectGetter;
        }

        // This will cause [Inject] to be triggered after awake / start
        // We could return true, but what if toggling active has other negative repercussions?
        // For now let's just not do anything
        protected override bool ShouldToggleActive
        {
            get { return false; }
        }

        protected override GameObject GetGameObject(InjectContext context)
        {
            var gameObj = _gameObjectGetter(context);
            Assert.IsNotNull(gameObj, "Provided Func<InjectContext, GameObject> returned null value for game object when using FromComponentOn");
            return gameObj;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToExistingGameObjectComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 669e8af5b17774d45acea73d348e6dca
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToGameObjectComponentProviderBase.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class AddToGameObjectComponentProviderBase : IProvider
    {
        readonly Type _componentType;
        readonly DiContainer _container;
        readonly List<TypeValuePair> _extraArguments;
        readonly object _concreteIdentifier;
        readonly Action<InjectContext, object> _instantiateCallback;

        public AddToGameObjectComponentProviderBase(
            DiContainer container, Type componentType,
            IEnumerable<TypeValuePair> extraArguments, object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
        {
            Assert.That(componentType.DerivesFrom<Component>());

            _extraArguments = extraArguments.ToList();
            _componentType = componentType;
            _container = container;
            _concreteIdentifier = concreteIdentifier;
            _instantiateCallback = instantiateCallback;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        protected Type ComponentType
        {
            get { return _componentType; }
        }

        protected abstract bool ShouldToggleActive
        {
            get;
        }

        public Type GetInstanceType(InjectContext context)
        {
            return _componentType;
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsNotNull(context);

            object instance;

            // We still want to make sure we can get the game object during validation
            var gameObj = GetGameObject(context);

            var wasActive = gameObj.activeSelf;

            if (wasActive && ShouldToggleActive)
            {
                // We need to do this in some cases to ensure that [Inject] always gets
                // called before awake / start
                gameObj.SetActive(false);
            }

            if (!_container.IsValidating || TypeAnalyzer.ShouldAllowDuringValidation(_componentType))
            {
                if (_componentType == typeof(Transform))
                    // Treat transform as a special case because it's the one component that's always automatically added
                    // Otherwise, calling AddComponent below will fail and return null
                    // This is nice to allow doing things like
                    //      Container.Bind<Transform>().FromNewComponentOnNewGameObject();
                {
                    instance = gameObj.transform;
                }
                else
                {
                    instance = gameObj.AddComponent(_componentType);
                }

                Assert.IsNotNull(instance);
            }
            else
            {
                instance = new ValidationMarker(_componentType);
            }

            injectAction = () =>
            {
                try
                {
                    var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                    extraArgs.AllocFreeAddRange(_extraArguments);
                    extraArgs.AllocFreeAddRange(args);

                    _container.InjectExplicit(instance, _componentType, extraArgs, context, _concreteIdentifier);

                    Assert.That(extraArgs.Count == 0);

                    ZenPools.DespawnList(extraArgs);

                    if (_instantiateCallback != null)
                    {
                        _instantiateCallback(context, instance);
                    }
                }
                finally
                {
                    if (wasActive && ShouldToggleActive)
                    {
                        gameObj.SetActive(true);
                    }
                }
            };

            buffer.Add(instance);
        }

        protected abstract GameObject GetGameObject(InjectContext context);
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToGameObjectComponentProviderBase.cs.meta
================================================
fileFormatVersion: 2
guid: d818f8110e5b31d4eb27001e5c5b3eb9
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToNewGameObjectComponentProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class AddToNewGameObjectComponentProvider : AddToGameObjectComponentProviderBase
    {
        readonly GameObjectCreationParameters _gameObjectBindInfo;

        public AddToNewGameObjectComponentProvider(
            DiContainer container, Type componentType,
            IEnumerable<TypeValuePair> extraArguments, GameObjectCreationParameters gameObjectBindInfo,
            object concreteIdentifier,
            Action<InjectContext, object> instantiateCallback)
            : base(container, componentType, extraArguments, concreteIdentifier, instantiateCallback)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
        }

        protected override bool ShouldToggleActive
        {
            get { return true; }
        }

        protected override GameObject GetGameObject(InjectContext context)
        {
            if (_gameObjectBindInfo.Name == null)
            {
                _gameObjectBindInfo.Name = ComponentType.Name;
            }

            return Container.CreateEmptyGameObject(_gameObjectBindInfo, context);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/ComponentProviders/AddToGameObjectComponentProviders/AddToNewGameObjectComponentProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 6e1085d337c03dd42a1d5493c11d9d23
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/Decorator/DecoratorProvider.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject.Internal
{
    public interface IDecoratorProvider
    {
        void GetAllInstances(
            IProvider provider, InjectContext context, List<object> buffer);
    }

    [NoReflectionBaking]
    public class DecoratorProvider<TContract> : IDecoratorProvider
    {
        readonly Dictionary<IProvider, List<object>> _cachedInstances =
            new Dictionary<IProvider, List<object>>();

        readonly DiContainer _container;
        readonly List<Guid> _factoryBindIds = new List<Guid>();

        List<IFactory<TContract, TContract>> _decoratorFactories;

#if ZEN_MULTITHREADING
        readonly object _locker = new object();
#endif

        public DecoratorProvider(DiContainer container)
        {
            _container = container;
        }

        public void AddFactoryId(Guid factoryBindId)
        {
            _factoryBindIds.Add(factoryBindId);
        }

        void LazyInitializeDecoratorFactories()
        {
            if (_decoratorFactories == null)
            {
                _decoratorFactories = new List<IFactory<TContract, TContract>>();

                for (int i = 0; i < _factoryBindIds.Count; i++)
                {
                    var bindId = _factoryBindIds[i];
                    var factory = _container.ResolveId<IFactory<TContract, TContract>>(bindId);
                    _decoratorFactories.Add(factory);
                }
            }
        }

        public void GetAllInstances(
            IProvider provider, InjectContext context, List<object> buffer)
        {
            if (provider.IsCached)
            {
                List<object> instances;

#if ZEN_MULTITHREADING
                lock (_locker)
#endif
                {
                    if (!_cachedInstances.TryGetValue(provider, out instances))
                    {
                        instances = new List<object>();
                        WrapProviderInstances(provider, context, instances);
                        _cachedInstances.Add(provider, instances);
                    }
                }

                buffer.AllocFreeAddRange(instances);
            }
            else
            {
                WrapProviderInstances(provider, context, buffer);
            }
        }

        void WrapProviderInstances(IProvider provider, InjectContext context, List<object> buffer)
        {
            LazyInitializeDecoratorFactories();

            provider.GetAllInstances(context, buffer);

            for (int i = 0; i < buffer.Count; i++)
            {
                buffer[i] = DecorateInstance(buffer[i], context);
            }
        }

        object DecorateInstance(object instance, InjectContext context)
        {
            for (int i = 0; i < _decoratorFactories.Count; i++)
            {
                instance = _decoratorFactories[i].Create(
                    context.Container.IsValidating ? default(TContract) : (TContract)instance);
            }

            return instance;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/Decorator/DecoratorProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 7a9aaabef2c47874a8b557ade27987eb
timeCreated: 1528368269
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GameObjectProviders/EmptyGameObjectProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class EmptyGameObjectProvider : IProvider
    {
        readonly DiContainer _container;
        readonly GameObjectCreationParameters _gameObjectBindInfo;

        public EmptyGameObjectProvider(
            DiContainer container, GameObjectCreationParameters gameObjectBindInfo)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
            _container = container;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(GameObject);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            Assert.IsEmpty(args);

            injectAction = null;

            var gameObj = _container.CreateEmptyGameObject(_gameObjectBindInfo, context);
            buffer.Add(gameObj);
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GameObjectProviders/EmptyGameObjectProvider.cs.meta
================================================
fileFormatVersion: 2
guid: f8f4db421196f5849b2139200fdea1a3
timeCreated: 1461708055
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GameObjectProviders/PrefabGameObjectProvider.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabGameObjectProvider : IProvider
    {
        readonly IPrefabInstantiator _prefabCreator;

        public PrefabGameObjectProvider(
            IPrefabInstantiator prefabCreator)
        {
            _prefabCreator = prefabCreator;
        }

        public bool IsCached
        {
            get { return false; }
        }

        public bool TypeVariesBasedOnMemberType
        {
            get { return false; }
        }

        public Type GetInstanceType(InjectContext context)
        {
            return typeof(GameObject);
        }

        public void GetAllInstancesWithInjectSplit(
            InjectContext context, List<TypeValuePair> args, out Action injectAction, List<object> buffer)
        {
            var instance = _prefabCreator.Instantiate(context, args, out injectAction);

            buffer.Add(instance);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/GameObjectProviders/PrefabGameObjectProvider.cs.meta
================================================
fileFormatVersion: 2
guid: d776b7406750d7f4c816cd0c03e4e254
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/IPrefabInstantiator.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Zenject
{
    public interface IPrefabInstantiator
    {
        Type ArgumentTarget
        {
            get;
        }

        List<TypeValuePair> ExtraArguments
        {
            get;
        }

        GameObjectCreationParameters GameObjectCreationParameters
        {
            get;
        }

        GameObject Instantiate(InjectContext context, List<TypeValuePair> args, out Action injectAction);

        UnityEngine.Object GetPrefab(InjectContext context);
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/IPrefabInstantiator.cs.meta
================================================
fileFormatVersion: 2
guid: 45b8fa051fd4fb84b94f6384e6dbe092
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/PrefabInstantiator.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using Zenject.Internal;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabInstantiator : IPrefabInstantiator
    {
        readonly IPrefabProvider _prefabProvider;
        readonly DiContainer _container;
        readonly List<TypeValuePair> _extraArguments;
        readonly GameObjectCreationParameters _gameObjectBindInfo;
        readonly Type _argumentTarget;
        readonly List<Type> _instantiateCallbackTypes;
        readonly Action<InjectContext, object> _instantiateCallback;

        public PrefabInstantiator(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Type argumentTarget,
            IEnumerable<Type> instantiateCallbackTypes,
            IEnumerable<TypeValuePair> extraArguments,
            IPrefabProvider prefabProvider,
            Action<InjectContext, object> instantiateCallback)
        {
            _prefabProvider = prefabProvider;
            _extraArguments = extraArguments.ToList();
            _container = container;
            _gameObjectBindInfo = gameObjectBindInfo;
            _argumentTarget = argumentTarget;
            _instantiateCallbackTypes = instantiateCallbackTypes.ToList();
            _instantiateCallback = instantiateCallback;
        }

        public GameObjectCreationParameters GameObjectCreationParameters
        {
            get { return _gameObjectBindInfo; }
        }

        public Type ArgumentTarget
        {
            get { return _argumentTarget; }
        }

        public List<TypeValuePair> ExtraArguments
        {
            get { return _extraArguments; }
        }

        public UnityEngine.Object GetPrefab(InjectContext context)
        {
            return _prefabProvider.GetPrefab(context);
        }

        public GameObject Instantiate(InjectContext context, List<TypeValuePair> args, out Action injectAction)
        {
            Assert.That(_argumentTarget == null || _argumentTarget.DerivesFromOrEqual(context.MemberType));

            bool shouldMakeActive;
            var gameObject = _container.CreateAndParentPrefab(
                GetPrefab(context), _gameObjectBindInfo, context, out shouldMakeActive);
            Assert.IsNotNull(gameObject);

            injectAction = () =>
            {
                var allArgs = ZenPools.SpawnList<TypeValuePair>();

                allArgs.AllocFreeAddRange(_extraArguments);
                allArgs.AllocFreeAddRange(args);

                if (_argumentTarget == null)
                {
                    Assert.That(
                        allArgs.IsEmpty(),
                        "Unexpected arguments provided to prefab instantiator.  Arguments are not allowed if binding multiple components in the same binding");
                }

                if (_argumentTarget == null || allArgs.IsEmpty())
                {
                    _container.InjectGameObject(gameObject);
                }
                else
                {
                    _container.InjectGameObjectForComponentExplicit(
                        gameObject, _argumentTarget, allArgs, context, null);

                    Assert.That(allArgs.Count == 0);
                }

                ZenPools.DespawnList<TypeValuePair>(allArgs);

                if (shouldMakeActive && !_container.IsValidating)
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                    {
                        gameObject.SetActive(true);
                    }
                }

                if (_instantiateCallback != null)
                {
                    var callbackObjects = ZenPools.SpawnHashSet<object>();

                    foreach (var type in _instantiateCallbackTypes)
                    {
                        var obj = gameObject.GetComponentInChildren(type);

                        if (obj != null)
                        {
                            callbackObjects.Add(obj);
                        }
                    }

                    foreach (var obj in callbackObjects)
                    {
                        _instantiateCallback(context, obj);
                    }

                    ZenPools.DespawnHashSet(callbackObjects);
                }
            };

            return gameObject;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/PrefabInstantiator.cs.meta
================================================
fileFormatVersion: 2
guid: 7dfc3341d0446554996b2969abf2d1ff
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/PrefabInstantiatorCached.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabInstantiatorCached : IPrefabInstantiator
    {
        readonly IPrefabInstantiator _subInstantiator;

        GameObject _gameObject;

        public PrefabInstantiatorCached(IPrefabInstantiator subInstantiator)
        {
            _subInstantiator = subInstantiator;
        }

        public List<TypeValuePair> ExtraArguments
        {
            get { return _subInstantiator.ExtraArguments; }
        }

        public Type ArgumentTarget
        {
            get { return _subInstantiator.ArgumentTarget; }
        }

        public GameObjectCreationParameters GameObjectCreationParameters
        {
            get { return _subInstantiator.GameObjectCreationParameters; }
        }

        public UnityEngine.Object GetPrefab(InjectContext context)
        {
            return _subInstantiator.GetPrefab(context);
        }

        public GameObject Instantiate(InjectContext context, List<TypeValuePair> args, out Action injectAction)
        {
            // We can't really support arguments if we are using the cached value since
            // the arguments might change when called after the first time
            Assert.IsEmpty(args);

            if (_gameObject != null)
            {
                injectAction = null;
                return _gameObject;
            }

            _gameObject = _subInstantiator.Instantiate(context, new List<TypeValuePair>(), out injectAction);
            return _gameObject;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabCreators/PrefabInstantiatorCached.cs.meta
================================================
fileFormatVersion: 2
guid: 293ee607ccfdf63458a26d0e6bdebaaa
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/IPrefabProvider.cs
================================================
#if !NOT_UNITY3D

namespace Zenject
{
    public interface IPrefabProvider
    {
        UnityEngine.Object GetPrefab(InjectContext context);
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/IPrefabProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 3b63b8088376c9a499e7f506a237392d
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProvider.cs
================================================
#if !NOT_UNITY3D

using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabProvider : IPrefabProvider
    {
        readonly UnityEngine.Object _prefab;

        public PrefabProvider(UnityEngine.Object prefab)
        {
            Assert.IsNotNull(prefab);
            _prefab = prefab;
        }

        public UnityEngine.Object GetPrefab(InjectContext _)
        {
            return _prefab;
        }
    }
}

#endif





================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 3628433a045792f4297abd34b5a1a34c
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProviderCustom.cs
================================================
#if !NOT_UNITY3D

using ModestTree;
using UnityEngine;
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabProviderCustom : IPrefabProvider
    {
        readonly Func<InjectContext, UnityEngine.Object> _getter;

        public PrefabProviderCustom(Func<InjectContext, UnityEngine.Object> getter)
        {
            _getter = getter;
        }

        public UnityEngine.Object GetPrefab(InjectContext context)
        {
            var prefab = _getter(context);
            Assert.That(prefab != null, "Custom prefab provider returned null");
            return prefab;
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProviderCustom.cs.meta
================================================
fileFormatVersion: 2
guid: f6f578cfe9da346348878e4a26617ee0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProviderResource.cs
================================================
#if !NOT_UNITY3D

using ModestTree;
using UnityEngine;

namespace Zenject
{
    [NoReflectionBaking]
    public class PrefabProviderResource : IPrefabProvider
    {
        readonly string _resourcePath;

        public PrefabProviderResource(string resourcePath)
        {
            _resourcePath = resourcePath;
        }

        public UnityEngine.Object GetPrefab(InjectContext context)
        {
            var prefab = (GameObject)Resources.Load(_resourcePath);

            Assert.That(prefab != null,
                "Expected to find prefab at resource path '{0}'", _resourcePath);

            return prefab;
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/PrefabProviders/PrefabProviderResource.cs.meta
================================================
fileFormatVersion: 2
guid: 6fa6b8670ec5932489c4102d45d987ff
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/ISubContainerCreator.cs
================================================
using System.Collections.Generic;
using System;

namespace Zenject
{
    public interface ISubContainerCreator
    {
        DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/ISubContainerCreator.cs.meta
================================================
fileFormatVersion: 2
guid: 83273a08f84aa9a48b37fe0b1bae0958
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorBindInfo.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorBindInfo
    {
        // Null = means no custom default parent
        public string DefaultParentName
        {
            get; set;
        }

        public bool CreateKernel
        {
            get; set;
        }

        public Type KernelType
        {
            get; set;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorBindInfo.cs.meta
================================================
fileFormatVersion: 2
guid: 2d894c838f0dcc34bb38d1311af9ea56
timeCreated: 1534923025
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstaller.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorByInstaller : ISubContainerCreator
    {
        readonly Type _installerType;
        readonly DiContainer _container;
        readonly List<TypeValuePair> _extraArgs;
        readonly SubContainerCreatorBindInfo _containerBindInfo;

        public SubContainerCreatorByInstaller(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Type installerType,
            IEnumerable<TypeValuePair> extraArgs)
        {
            _installerType = installerType;
            _container = container;
            _extraArgs = extraArgs.ToList();
            _containerBindInfo = containerBindInfo;

            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);
        }

        public SubContainerCreatorByInstaller(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Type installerType)
            : this(container, containerBindInfo, installerType, new List<TypeValuePair>())
        {
        }

        public DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            var subContainer = _container.CreateSubContainer();

            SubContainerCreatorUtil.ApplyBindSettings(_containerBindInfo, subContainer);

            var extraArgs = ZenPools.SpawnList<TypeValuePair>();

            extraArgs.AllocFreeAddRange(_extraArgs);
            extraArgs.AllocFreeAddRange(args);

            var installer = (InstallerBase)subContainer.InstantiateExplicit(
                _installerType, extraArgs);

            ZenPools.DespawnList(extraArgs);

            installer.InstallBindings();

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: d932bdf1cc240394a94c9fd81dfa9218
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstance.cs
================================================
using System.Collections.Generic;
using System;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorByInstance : ISubContainerCreator
    {
        readonly DiContainer _subcontainer;

        public SubContainerCreatorByInstance(DiContainer subcontainer)
        {
            _subcontainer = subcontainer;
        }

        public DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.That(args.IsEmpty());

            injectAction = null;

            // It is assumed here that the subcontainer has already had ResolveRoots called elsewhere
            // Since most likely you are adding a subcontainer that is already in a context or
            // something rather than directly using DiContainer.CreateSubContainer
            return _subcontainer;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstance.cs.meta
================================================
fileFormatVersion: 2
guid: 1ea58c024bbd4e846be07059bf23c524
timeCreated: 1535189469
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstanceGetter.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorByInstanceGetter : ISubContainerCreator
    {
        readonly Func<InjectContext, DiContainer> _subcontainerGetter;

        public SubContainerCreatorByInstanceGetter(
            Func<InjectContext, DiContainer> subcontainerGetter)
        {
            _subcontainerGetter = subcontainerGetter;
        }

        public DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.That(args.IsEmpty());

            injectAction = null;

            // It is assumed here that the subcontainer has already had ResolveRoots called elsewhere
            // Since most likely you are adding a subcontainer that is already in a context or
            // something rather than directly using DiContainer.CreateSubContainer
            return _subcontainerGetter(context);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByInstanceGetter.cs.meta
================================================
fileFormatVersion: 2
guid: 164cf97cfe8f32441beb85b9b3c05868
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByMethod.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    // Zero parameters

    [NoReflectionBaking]
    public abstract class SubContainerCreatorByMethodBase : ISubContainerCreator
    {
        readonly DiContainer _container;
        readonly SubContainerCreatorBindInfo _containerBindInfo;

        public SubContainerCreatorByMethodBase(
            DiContainer container, SubContainerCreatorBindInfo containerBindInfo)
        {
            _container = container;
            _containerBindInfo = containerBindInfo;
        }

        public abstract DiContainer CreateSubContainer(
            List<TypeValuePair> args, InjectContext context, out Action injectAction);

        protected DiContainer CreateEmptySubContainer()
        {
            var subContainer = _container.CreateSubContainer();
            SubContainerCreatorUtil.ApplyBindSettings(_containerBindInfo, subContainer);
            return subContainer;
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod : SubContainerCreatorByMethodBase
    {
        readonly Action<DiContainer> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Action<DiContainer> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEmpty(args);

            var subContainer = CreateEmptySubContainer();

            _installMethod(subContainer);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // One parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1> : SubContainerCreatorByMethodBase
    {
        readonly Action<DiContainer, TParam1> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Action<DiContainer, TParam1> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(subContainer, (TParam1)args[0].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // Two parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2> : SubContainerCreatorByMethodBase
    {
        readonly Action<DiContainer, TParam1, TParam2> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Action<DiContainer, TParam1, TParam2> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // Three parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2, TParam3> : SubContainerCreatorByMethodBase
    {
        readonly Action<DiContainer, TParam1, TParam2, TParam3> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
            Action<DiContainer, TParam1, TParam2, TParam3> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // Four parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4> : SubContainerCreatorByMethodBase
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // Five parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5> : SubContainerCreatorByMethodBase
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                (TParam5)args[4].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // Six parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> : SubContainerCreatorByMethodBase
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                (TParam5)args[4].Value,
                (TParam6)args[5].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }

    // 10 parameters

    [NoReflectionBaking]
    public class SubContainerCreatorByMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> : SubContainerCreatorByMethodBase
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> _installMethod;

        public SubContainerCreatorByMethod(
            DiContainer container,
            SubContainerCreatorBindInfo containerBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installMethod)
            : base(container, containerBindInfo)
        {
            _installMethod = installMethod;
        }

        public override DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            Assert.IsEqual(args.Count, 10);

            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());
            Assert.That(args[6].Type.DerivesFromOrEqual<TParam7>());
            Assert.That(args[7].Type.DerivesFromOrEqual<TParam8>());
            Assert.That(args[8].Type.DerivesFromOrEqual<TParam9>());
            Assert.That(args[9].Type.DerivesFromOrEqual<TParam10>());

            var subContainer = CreateEmptySubContainer();

            _installMethod(
                subContainer,
                (TParam1)args[0].Value,
                (TParam2)args[1].Value,
                (TParam3)args[2].Value,
                (TParam4)args[3].Value,
                (TParam5)args[4].Value,
                (TParam6)args[5].Value,
                (TParam7)args[6].Value,
                (TParam8)args[7].Value,
                (TParam9)args[8].Value,
                (TParam10)args[9].Value);

            injectAction = () => 
            {
                subContainer.ResolveRoots();
            };

            return subContainer;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByMethod.cs.meta
================================================
fileFormatVersion: 2
guid: 5f4bb37c4e2a5bf44865ed1ab3bef21e
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewGameObjectDynamicContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class SubContainerCreatorByNewGameObjectDynamicContext : SubContainerCreatorDynamicContext
    {
        readonly GameObjectCreationParameters _gameObjectBindInfo;

        public SubContainerCreatorByNewGameObjectDynamicContext(
            DiContainer container, GameObjectCreationParameters gameObjectBindInfo)
            : base(container)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
        }

        protected override GameObject CreateGameObject(InjectContext context, out bool shouldMakeActive)
        {
            shouldMakeActive = true;
            var gameObject = Container.CreateEmptyGameObject(_gameObjectBindInfo, null);
            gameObject.SetActive(false);
            return gameObject;
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectInstaller : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly Type _installerType;
        readonly List<TypeValuePair> _extraArgs;

        public SubContainerCreatorByNewGameObjectInstaller(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Type installerType, List<TypeValuePair> extraArgs)
            : base(container, gameObjectBindInfo)
        {
            _installerType = installerType;
            _extraArgs = extraArgs;

            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                        extraArgs.AllocFreeAddRange(_extraArgs);
                        extraArgs.AllocFreeAddRange(args);

                        var installer = (InstallerBase)subContainer.InstantiateExplicit(
                            _installerType, extraArgs);

                        ZenPools.DespawnList(extraArgs);

                        installer.InstallBindings();
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly Action<DiContainer> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.That(args.IsEmpty());
            context.AddNormalInstaller(
                new ActionInstaller(_installerMethod));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly Action<DiContainer, TParam1> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer, (TParam1)args[0].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly Action<DiContainer, TParam1, TParam2> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1, TParam2> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly Action<DiContainer, TParam1, TParam2, TParam3> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value,
                            (TParam6)args[5].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewGameObjectMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> : SubContainerCreatorByNewGameObjectDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> _installerMethod;

        public SubContainerCreatorByNewGameObjectMethod(
            DiContainer container,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
            : base(container, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 10);

            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());
            Assert.That(args[6].Type.DerivesFromOrEqual<TParam7>());
            Assert.That(args[7].Type.DerivesFromOrEqual<TParam8>());
            Assert.That(args[8].Type.DerivesFromOrEqual<TParam9>());
            Assert.That(args[9].Type.DerivesFromOrEqual<TParam10>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value,
                            (TParam6)args[5].Value,
                            (TParam7)args[6].Value,
                            (TParam8)args[7].Value,
                            (TParam9)args[8].Value,
                            (TParam10)args[9].Value);
                    }));
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewGameObjectDynamicContext.cs.meta
================================================
fileFormatVersion: 2
guid: 7c2c6880c82d78140818fe3204a0279b
timeCreated: 1538467080
licenseType: Pro
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefab.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefab : ISubContainerCreator
    {
        readonly GameObjectCreationParameters _gameObjectBindInfo;
        readonly IPrefabProvider _prefabProvider;
        readonly DiContainer _container;

        public SubContainerCreatorByNewPrefab(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
            _prefabProvider = prefabProvider;
            _container = container;
        }

        public DiContainer CreateSubContainer(
            List<TypeValuePair> args, InjectContext parentContext, out Action injectAction)
        {
            Assert.That(args.IsEmpty());

            var prefab = _prefabProvider.GetPrefab(parentContext);

            bool shouldMakeActive;
            var gameObject = _container.CreateAndParentPrefab(
                prefab, _gameObjectBindInfo, null, out shouldMakeActive);

            var context = gameObject.GetComponent<GameObjectContext>();

            Assert.That(context != null,
                "Expected prefab with name '{0}' to contain a component of type 'GameObjectContext' on the root", prefab.name);

            context.Install(_container);

            injectAction = () =>
            {
                // Note: We don't need to call ResolveRoots here because GameObjectContext does this for us
                _container.Inject(context);

                if (shouldMakeActive && !_container.IsValidating)
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                    {
                        gameObject.SetActive(true);
                    }
                }
            };

            return context.Container;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefab.cs.meta
================================================
fileFormatVersion: 2
guid: 17fc7cad09fe4e94f939551c85abf6d9
timeCreated: 1486859770
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefabDynamicContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class SubContainerCreatorByNewPrefabDynamicContext : SubContainerCreatorDynamicContext
    {
        readonly IPrefabProvider _prefabProvider;
        readonly GameObjectCreationParameters _gameObjectBindInfo;

        public SubContainerCreatorByNewPrefabDynamicContext(
            DiContainer container,
            IPrefabProvider prefabProvider, GameObjectCreationParameters gameObjectBindInfo)
            : base(container)
        {
            _prefabProvider = prefabProvider;
            _gameObjectBindInfo = gameObjectBindInfo;
        }

        protected override GameObject CreateGameObject(InjectContext context, out bool shouldMakeActive)
        {
            var prefab = _prefabProvider.GetPrefab(context);

            var gameObj = Container.CreateAndParentPrefab(
                prefab, _gameObjectBindInfo, null, out shouldMakeActive);

            if (gameObj.GetComponent<GameObjectContext>() != null)
            {
                throw Assert.CreateException(
                    "Found GameObjectContext already attached to prefab with name '{0}'!  When using ByNewPrefabMethod or ByNewPrefabInstaller, the GameObjectContext is added to the prefab dynamically", prefab.name);
            }

            return gameObj;
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabInstaller : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly Type _installerType;
        readonly List<TypeValuePair> _extraArgs;

        public SubContainerCreatorByNewPrefabInstaller(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
            Type installerType, List<TypeValuePair> extraArgs)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerType = installerType;
            _extraArgs = extraArgs;

            Assert.That(installerType.DerivesFrom<InstallerBase>(),
                "Invalid installer type given during bind command.  Expected type '{0}' to derive from 'Installer<>'", installerType);
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        var extraArgs = ZenPools.SpawnList<TypeValuePair>();

                        extraArgs.AllocFreeAddRange(_extraArgs);
                        extraArgs.AllocFreeAddRange(args);

                        var installer = (InstallerBase)subContainer.InstantiateExplicit(
                            _installerType, extraArgs);

                        ZenPools.DespawnList(extraArgs);

                        installer.InstallBindings();
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly Action<DiContainer> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.That(args.IsEmpty());
            context.AddNormalInstaller(
                new ActionInstaller(_installerMethod));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly Action<DiContainer, TParam1> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 1);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer, (TParam1)args[0].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly Action<DiContainer, TParam1, TParam2> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1, TParam2> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 2);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly Action<DiContainer, TParam1, TParam2, TParam3> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
            Action<DiContainer, TParam1, TParam2, TParam3> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 3);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 4);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 5);
            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value,
                            (TParam6)args[5].Value);
                    }));
        }
    }

    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabMethod<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> : SubContainerCreatorByNewPrefabDynamicContext
    {
        readonly
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> _installerMethod;

        public SubContainerCreatorByNewPrefabMethod(
            DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo,
#if !NET_4_6
            ModestTree.Util.
#endif
            Action<DiContainer, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TParam8, TParam9, TParam10> installerMethod)
            : base(container, prefabProvider, gameObjectBindInfo)
        {
            _installerMethod = installerMethod;
        }

        protected override void AddInstallers(List<TypeValuePair> args, GameObjectContext context)
        {
            Assert.IsEqual(args.Count, 10);

            Assert.That(args[0].Type.DerivesFromOrEqual<TParam1>());
            Assert.That(args[1].Type.DerivesFromOrEqual<TParam2>());
            Assert.That(args[2].Type.DerivesFromOrEqual<TParam3>());
            Assert.That(args[3].Type.DerivesFromOrEqual<TParam4>());
            Assert.That(args[4].Type.DerivesFromOrEqual<TParam5>());
            Assert.That(args[5].Type.DerivesFromOrEqual<TParam6>());
            Assert.That(args[6].Type.DerivesFromOrEqual<TParam7>());
            Assert.That(args[7].Type.DerivesFromOrEqual<TParam8>());
            Assert.That(args[8].Type.DerivesFromOrEqual<TParam9>());
            Assert.That(args[9].Type.DerivesFromOrEqual<TParam10>());

            context.AddNormalInstaller(
                new ActionInstaller(subContainer =>
                    {
                        _installerMethod(subContainer,
                            (TParam1)args[0].Value,
                            (TParam2)args[1].Value,
                            (TParam3)args[2].Value,
                            (TParam4)args[3].Value,
                            (TParam5)args[4].Value,
                            (TParam6)args[5].Value,
                            (TParam7)args[6].Value,
                            (TParam8)args[7].Value,
                            (TParam9)args[8].Value,
                            (TParam10)args[9].Value);
                    }));
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefabDynamicContext.cs.meta
================================================
fileFormatVersion: 2
guid: 53f151c86cd3c4c46ada71b737004d36
timeCreated: 1505722322
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefabWithParams.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorByNewPrefabWithParams : ISubContainerCreator
    {
        readonly DiContainer _container;
        readonly IPrefabProvider _prefabProvider;
        readonly Type _installerType;
        readonly GameObjectCreationParameters _gameObjectBindInfo;

        public SubContainerCreatorByNewPrefabWithParams(
            Type installerType, DiContainer container, IPrefabProvider prefabProvider,
            GameObjectCreationParameters gameObjectBindInfo)
        {
            _gameObjectBindInfo = gameObjectBindInfo;
            _prefabProvider = prefabProvider;
            _container = container;
            _installerType = installerType;
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        IEnumerable<InjectableInfo> GetAllInjectableIncludingBaseTypes() 
        {
            var info = TypeAnalyzer.GetInfo(_installerType);

            while (info != null) 
            {
                foreach (var injectable in info.AllInjectables) 
                {
                    yield return injectable;
                }

                info = info.BaseTypeInfo;
            }
        }

        DiContainer CreateTempContainer(List<TypeValuePair> args)
        {
            var tempSubContainer = Container.CreateSubContainer();

            var allInjectables = GetAllInjectableIncludingBaseTypes();

            foreach (var argPair in args)
            {
                // We need to intelligently match on the exact parameters here to avoid the issue
                // brought up in github issue #217
                var match = allInjectables
                    .Where(x => argPair.Type.DerivesFromOrEqual(x.MemberType))
                    .OrderBy(x => ZenUtilInternal.GetInheritanceDelta(argPair.Type, x.MemberType)).FirstOrDefault();

                Assert.That(match != null,
                    "Could not find match for argument type '{0}' when injecting into sub container installer '{1}'",
                    argPair.Type, _installerType);

                tempSubContainer.Bind(match.MemberType)
                    .FromInstance(argPair.Value).WhenInjectedInto(_installerType);
            }

            return tempSubContainer;
        }

        public DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext parentContext, out Action injectAction)
        {
            Assert.That(!args.IsEmpty());

            var prefab = _prefabProvider.GetPrefab(parentContext);
            var tempContainer = CreateTempContainer(args);

            bool shouldMakeActive;
            var gameObject = tempContainer.CreateAndParentPrefab(
                prefab, _gameObjectBindInfo, null, out shouldMakeActive);

            var context = gameObject.GetComponent<GameObjectContext>();

            Assert.That(context != null,
                "Expected prefab with name '{0}' to container a component of type 'GameObjectContext'", prefab.name);

            context.Install(tempContainer);

            injectAction = () => 
            {
                // Note: We don't need to call ResolveRoots here because GameObjectContext does this for us
                tempContainer.Inject(context);

                if (shouldMakeActive && !_container.IsValidating)
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                    {
                        gameObject.SetActive(true);
                    }
                }
            };

            return context.Container;
        }
    }
}

#endif




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorByNewPrefabWithParams.cs.meta
================================================
fileFormatVersion: 2
guid: 07cb33e44f032a840a46b8b699927d0a
timeCreated: 1486859770
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorCached.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class SubContainerCreatorCached : ISubContainerCreator
    {
        readonly ISubContainerCreator _subCreator;

#if ZEN_MULTITHREADING
        readonly object _locker = new object();
#else
        bool _isLookingUp;
#endif
        DiContainer _subContainer;

        public SubContainerCreatorCached(ISubContainerCreator subCreator)
        {
            _subCreator = subCreator;
        }

        public DiContainer CreateSubContainer(List<TypeValuePair> args, InjectContext context, out Action injectAction)
        {
            // We can't really support arguments if we are using the cached value since
            // the arguments might change when called after the first time
            Assert.IsEmpty(args);

#if ZEN_MULTITHREADING
            lock (_locker)
#endif
            {
                if (_subContainer == null)
                {
#if !ZEN_MULTITHREADING
                    Assert.That(!_isLookingUp,
                        "Found unresolvable circular dependency when looking up sub container!  Object graph:\n {0}", context.GetObjectGraphString());
                    _isLookingUp = true;
#endif

                    _subContainer = _subCreator.CreateSubContainer(
                            new List<TypeValuePair>(), context, out injectAction);

#if !ZEN_MULTITHREADING
                    _isLookingUp = false;
#endif

                    Assert.IsNotNull(_subContainer);
                }
                else 
                {
                    injectAction = null;
                }

                return _subContainer;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorCached.cs.meta
================================================
fileFormatVersion: 2
guid: 64db75da3b9de56409556af4513979c2
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorDynamicContext.cs
================================================
#if !NOT_UNITY3D

using System;
using System.Collections.Generic;
using UnityEngine;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    [NoReflectionBaking]
    public abstract class SubContainerCreatorDynamicContext : ISubContainerCreator
    {
        readonly DiContainer _container;

        public SubContainerCreatorDynamicContext(DiContainer container)
        {
            _container = container;
        }

        protected DiContainer Container
        {
            get { return _container; }
        }

        public DiContainer CreateSubContainer(
            List<TypeValuePair> args, InjectContext parentContext, out Action injectAction)
        {
            bool shouldMakeActive;
            var gameObj = CreateGameObject(parentContext, out shouldMakeActive);

            var context = gameObj.AddComponent<GameObjectContext>();

            AddInstallers(args, context);

            context.Install(_container);

            injectAction = () => 
            {
                // Note: We don't need to call ResolveRoots here because GameObjectContext does this for us
                _container.Inject(context);

                if (shouldMakeActive && !_container.IsValidating)
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
                    {
                        gameObj.SetActive(true);
                    }
                }
            };

            return context.Container;
        }

        protected abstract void AddInstallers(List<TypeValuePair> args, GameObjectContext context);
        protected abstract GameObject CreateGameObject(InjectContext context, out bool shouldMakeActive);
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorDynamicContext.cs.meta
================================================
fileFormatVersion: 2
guid: ba4736ebcee13cb4b9feca861072c740
timeCreated: 1538467080
licenseType: Pro
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorUtil.cs
================================================
using System;
using ModestTree;
#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject
{
    public static class SubContainerCreatorUtil
    {
        public static void ApplyBindSettings(
            SubContainerCreatorBindInfo subContainerBindInfo, DiContainer subContainer)
        {
            if (subContainerBindInfo.CreateKernel)
            {
                var parentContainer = subContainer.ParentContainers.OnlyOrDefault();
                Assert.IsNotNull(parentContainer, "Could not find unique container when using WithKernel!");

                if (subContainerBindInfo.KernelType != null)
                {
                    parentContainer.Bind(typeof(Kernel).Interfaces()).To(subContainerBindInfo.KernelType)
                        .FromSubContainerResolve()
                        .ByInstance(subContainer).AsCached();
                    subContainer.Bind(subContainerBindInfo.KernelType).AsCached();
                }
                else
                {
                    parentContainer.BindInterfacesTo<Kernel>().FromSubContainerResolve()
                        .ByInstance(subContainer).AsCached();
                    subContainer.Bind<Kernel>().AsCached();
                }

#if !NOT_UNITY3D
                if (subContainerBindInfo.DefaultParentName != null)
                {
                    DefaultGameObjectParentInstaller.Install(
                        subContainer, subContainerBindInfo.DefaultParentName);
                }
#endif
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Providers/SubContainerCreators/SubContainerCreatorUtil.cs.meta
================================================
fileFormatVersion: 2
guid: c07a01bd5fbd00d43a50854896a92472
timeCreated: 1534923026
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/DisposableManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;

namespace Zenject
{
    public class DisposableManager : IDisposable
    {
        readonly List<DisposableInfo> _disposables = new List<DisposableInfo>();
        readonly List<LateDisposableInfo> _lateDisposables = new List<LateDisposableInfo>();
        bool _disposed;
        bool _lateDisposed;

        [Inject]
        public DisposableManager(
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<IDisposable> disposables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ILateDisposable> lateDisposables,
            [Inject(Id = "Late", Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> latePriorities)
        {
            foreach (var disposable in disposables)
            {
                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var match = priorities.Where(x => disposable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)x.Second).SingleOrDefault();
                int priority = match.HasValue ? match.Value : 0;

                _disposables.Add(new DisposableInfo(disposable, priority));
            }

            foreach (var lateDisposable in lateDisposables)
            {
                var match = latePriorities.Where(x => lateDisposable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)x.Second).SingleOrDefault();
                int priority = match.HasValue ? match.Value : 0;

                _lateDisposables.Add(new LateDisposableInfo(lateDisposable, priority));
            }
        }

        public void Add(IDisposable disposable)
        {
            Add(disposable, 0);
        }

        public void Add(IDisposable disposable, int priority)
        {
            _disposables.Add(
                new DisposableInfo(disposable, priority));
        }

        public void AddLate(ILateDisposable disposable)
        {
            AddLate(disposable, 0);
        }

        public void AddLate(ILateDisposable disposable, int priority)
        {
            _lateDisposables.Add(
                new LateDisposableInfo(disposable, priority));
        }

        public void Remove(IDisposable disposable)
        {
            _disposables.RemoveWithConfirm(
                _disposables.Where(x => ReferenceEquals(x.Disposable, disposable)).Single());
        }

        public void LateDispose()
        {
            Assert.That(!_lateDisposed, "Tried to late dispose DisposableManager twice!");
            _lateDisposed = true;

            // Dispose in the reverse order that they are initialized in
            var disposablesOrdered = _lateDisposables.OrderBy(x => x.Priority).Reverse().ToList();

#if UNITY_EDITOR
            foreach (var disposable in disposablesOrdered.Select(x => x.LateDisposable).GetDuplicates())
            {
                Assert.That(false, "Found duplicate ILateDisposable with type '{0}'".Fmt(disposable.GetType()));
            }
#endif

            foreach (var disposable in disposablesOrdered)
            {
                try
                {
                    disposable.LateDisposable.LateDispose();
                }
                catch (Exception e)
                {
                    throw Assert.CreateException(
                        e, "Error occurred while late disposing ILateDisposable with type '{0}'", disposable.LateDisposable.GetType());
                }
            }
        }

        public void Dispose()
        {
            Assert.That(!_disposed, "Tried to dispose DisposableManager twice!");
            _disposed = true;

            // Dispose in the reverse order that they are initialized in
            var disposablesOrdered = _disposables.OrderBy(x => x.Priority).Reverse().ToList();

#if UNITY_EDITOR
            foreach (var disposable in disposablesOrdered.Select(x => x.Disposable).GetDuplicates())
            {
                Assert.That(false, "Found duplicate IDisposable with type '{0}'".Fmt(disposable.GetType()));
            }
#endif

            foreach (var disposable in disposablesOrdered)
            {
                try
                {
                    disposable.Disposable.Dispose();
                }
                catch (Exception e)
                {
                    throw Assert.CreateException(
                        e, "Error occurred while disposing IDisposable with type '{0}'", disposable.Disposable.GetType());
                }
            }
        }

        struct DisposableInfo
        {
            public IDisposable Disposable;
            public int Priority;

            public DisposableInfo(IDisposable disposable, int priority)
            {
                Disposable = disposable;
                Priority = priority;
            }
        }

        class LateDisposableInfo
        {
            public ILateDisposable LateDisposable;
            public int Priority;

            public LateDisposableInfo(ILateDisposable lateDisposable, int priority)
            {
                LateDisposable = lateDisposable;
                Priority = priority;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/DisposableManager.cs.meta
================================================
fileFormatVersion: 2
guid: e62fabfe4695e4a439003c1c1fd5d008
timeCreated: 1461708054
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/GuiRenderableManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;

namespace Zenject
{
    // See comment in IGuiRenderable.cs for usage
    public class GuiRenderableManager
    {
        List<RenderableInfo> _renderables;

        public GuiRenderableManager(
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<IGuiRenderable> renderables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _renderables = new List<RenderableInfo>();

            foreach (var renderable in renderables)
            {
                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var matches = priorities
                    .Where(x => renderable.GetType().DerivesFromOrEqual(x.First))
                    .Select(x => x.Second).ToList();

                int priority = matches.IsEmpty() ? 0 : matches.Distinct().Single();

                _renderables.Add(
                    new RenderableInfo(renderable, priority));
            }

            _renderables = _renderables.OrderBy(x => x.Priority).ToList();

#if UNITY_EDITOR
            foreach (var renderable in _renderables.Select(x => x.Renderable).GetDuplicates())
            {
                Assert.That(false, "Found duplicate IGuiRenderable with type '{0}'".Fmt(renderable.GetType()));
            }
#endif
        }

        public void OnGui()
        {
            foreach (var renderable in _renderables)
            {
                try
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                    using (ProfileBlock.Start("{0}.GuiRender()", renderable.Renderable.GetType()))
#endif
                    {
                        renderable.Renderable.GuiRender();
                    }
                }
                catch (Exception e)
                {
                    throw Assert.CreateException(
                        e, "Error occurred while calling {0}.GuiRender", renderable.Renderable.GetType());
                }
            }
        }

        class RenderableInfo
        {
            public IGuiRenderable Renderable;
            public int Priority;

            public RenderableInfo(IGuiRenderable renderable, int priority)
            {
                Renderable = renderable;
                Priority = priority;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/GuiRenderableManager.cs.meta
================================================
fileFormatVersion: 2
guid: 5ca4a43d84d9d554080d313280363783
timeCreated: 1484528928
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/GuiRenderer.cs
================================================
using UnityEngine;

namespace Zenject
{
    public class GuiRenderer : MonoBehaviour
    {
        GuiRenderableManager _renderableManager;

        [Inject]
        void Construct(GuiRenderableManager renderableManager)
        {
            _renderableManager = renderableManager;
        }

        public void OnGUI()
        {
            _renderableManager.OnGui();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/GuiRenderer.cs.meta
================================================
fileFormatVersion: 2
guid: d6ee197c5aed3b048b76b82a9be3d094
timeCreated: 1484530704
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -9995
  icon: {instanceID: 0}
  userData:
  assetBundleName:
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/InitializableManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;

namespace Zenject
{
    // Responsibilities:
    // - Run Initialize() on all Iinitializable's, in the order specified by InitPriority
    public class InitializableManager
    {
        List<InitializableInfo> _initializables;

        protected bool _hasInitialized;

        [Inject]
        public InitializableManager(
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<IInitializable> initializables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _initializables = new List<InitializableInfo>();

            for (int i = 0; i < initializables.Count; i++)
            {
                var initializable = initializables[i];

                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var matches = priorities.Where(x => initializable.GetType().DerivesFromOrEqual(x.First)).Select(x => x.Second).ToList();
                int priority = matches.IsEmpty() ? 0 : matches.Distinct().Single();

                _initializables.Add(new InitializableInfo(initializable, priority));
            }
        }

        public void Add(IInitializable initializable)
        {
            Add(initializable, 0);
        }

        public void Add(IInitializable initializable, int priority)
        {
            Assert.That(!_hasInitialized);
            _initializables.Add(
                new InitializableInfo(initializable, priority));
        }

        public void Initialize()
        {
            Assert.That(!_hasInitialized);
            _hasInitialized = true;

            _initializables = _initializables.OrderBy(x => x.Priority).ToList();

#if UNITY_EDITOR
            foreach (var initializable in _initializables.Select(x => x.Initializable).GetDuplicates())
            {
                Assert.That(false, "Found duplicate IInitializable with type '{0}'".Fmt(initializable.GetType()));
            }
#endif

            foreach (var initializable in _initializables)
            {
                try
                {
#if ZEN_INTERNAL_PROFILING
                    using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                    using (ProfileBlock.Start("{0}.Initialize()", initializable.Initializable.GetType()))
#endif
                    {
                        initializable.Initializable.Initialize();
                    }
                }
                catch (Exception e)
                {
                    throw Assert.CreateException(
                        e, "Error occurred while initializing IInitializable with type '{0}'", initializable.Initializable.GetType());
                }
            }
        }

        class InitializableInfo
        {
            public IInitializable Initializable;
            public int Priority;

            public InitializableInfo(IInitializable initializable, int priority)
            {
                Initializable = initializable;
                Priority = priority;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/InitializableManager.cs.meta
================================================
fileFormatVersion: 2
guid: 8e5838132ef34e14ea93d2e3b30b7140
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels.meta
================================================
fileFormatVersion: 2
guid: 605550c45d7550e498dfe6968192459d
folderAsset: yes
timeCreated: 1462650136
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/PoolableManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;

namespace Zenject
{
    public class PoolableManager
    {
        readonly List<IPoolable> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned()
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned();
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable Poolable;
            public int Priority;

            public PoolableInfo(IPoolable poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }

    /// <summary>
    /// A modified version of PoolableManager that adds a generic argument, allowing
    /// the passing of a parameter to all IPoolable<T> objects in the container.
    /// </summary>
    public class PoolableManager<T>
    {
        readonly List<IPoolable<T>> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable<T>> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable<T> poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned(T param)
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned(param);
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable<T> Poolable;
            public int Priority;

            public PoolableInfo(IPoolable<T> poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }

    /// <summary>
    /// A modified version of PoolableManager that adds a generic argument, allowing
    /// the passing of a parameter to all IPoolable<T1, T2> objects in the container.
    /// </summary>
    public class PoolableManager<T1, T2>
    {
        readonly List<IPoolable<T1, T2>> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable<T1, T2>> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable<T1, T2> poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned(T1 p1, T2 p2)
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned(p1, p2);
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable<T1, T2> Poolable;
            public int Priority;

            public PoolableInfo(IPoolable<T1, T2> poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }

    /// <summary>
    /// A modified version of PoolableManager that adds a generic argument, allowing
    /// the passing of a parameter to all IPoolable<T1, T2> objects in the container.
    /// </summary>
    public class PoolableManager<T1, T2, T3>
    {
        readonly List<IPoolable<T1, T2, T3>> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable<T1, T2, T3>> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable<T1, T2, T3> poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned(T1 p1, T2 p2, T3 p3)
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned(p1, p2, p3);
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable<T1, T2, T3> Poolable;
            public int Priority;

            public PoolableInfo(IPoolable<T1, T2, T3> poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }

    /// <summary>
    /// A modified version of PoolableManager that adds a generic argument, allowing
    /// the passing of a parameter to all IPoolable<T1, T2> objects in the container.
    /// </summary>
    public class PoolableManager<T1, T2, T3, T4>
    {
        readonly List<IPoolable<T1, T2, T3, T4>> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable<T1, T2, T3, T4>> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable<T1, T2, T3, T4> poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned(T1 p1, T2 p2, T3 p3, T4 p4)
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned(p1, p2, p3, p4);
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable<T1, T2, T3, T4> Poolable;
            public int Priority;

            public PoolableInfo(IPoolable<T1, T2, T3, T4> poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }


    /// <summary>
    /// A modified version of PoolableManager that adds a generic argument, allowing
    /// the passing of a parameter to all IPoolable<T1, T2> objects in the container.
    /// </summary>
    public class PoolableManager<T1, T2, T3, T4, T5>
    {
        readonly List<IPoolable<T1, T2, T3, T4, T5>> _poolables;

        bool _isSpawned;

        public PoolableManager(
            [InjectLocal]
            List<IPoolable<T1, T2, T3, T4, T5>> poolables,
            [Inject(Optional = true, Source = InjectSources.Local)]
            List<ValuePair<Type, int>> priorities)
        {
            _poolables = poolables.Select(x => CreatePoolableInfo(x, priorities))
                .OrderBy(x => x.Priority).Select(x => x.Poolable).ToList();
        }

        PoolableInfo CreatePoolableInfo(IPoolable<T1, T2, T3, T4, T5> poolable, List<ValuePair<Type, int>> priorities)
        {
            var match = priorities.Where(x => poolable.GetType().DerivesFromOrEqual(x.First)).Select(x => (int?)(x.Second)).SingleOrDefault();
            int priority = match.HasValue ? match.Value : 0;

            return new PoolableInfo(poolable, priority);
        }

        public void TriggerOnSpawned(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)
        {
            Assert.That(!_isSpawned);
            _isSpawned = true;

            for (int i = 0; i < _poolables.Count; i++)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnSpawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnSpawned(p1, p2, p3, p4, p5);
                }
            }
        }

        public void TriggerOnDespawned()
        {
            Assert.That(_isSpawned);
            _isSpawned = false;

            // Call OnDespawned in the reverse order just like how dispose works
            for (int i = _poolables.Count - 1; i >= 0; i--)
            {
#if ZEN_INTERNAL_PROFILING
                using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
                using (ProfileBlock.Start("{0}.OnDespawned", _poolables[i].GetType()))
#endif
                {
                    _poolables[i].OnDespawned();
                }
            }
        }

        struct PoolableInfo
        {
            public IPoolable<T1, T2, T3, T4, T5> Poolable;
            public int Priority;

            public PoolableInfo(IPoolable<T1, T2, T3, T4, T5> poolable, int priority)
            {
                Poolable = poolable;
                Priority = priority;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/PoolableManager.cs.meta
================================================
fileFormatVersion: 2
guid: aef2cb2ede47a96439cbb34a8935111a
timeCreated: 1528650779
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/SceneContextRegistry.cs
================================================
using System.Collections.Generic;
using ModestTree;
using UnityEngine.SceneManagement;

namespace Zenject
{
    public class SceneContextRegistry
    {
        readonly Dictionary<Scene, SceneContext> _map = new Dictionary<Scene, SceneContext>();

        public IEnumerable<SceneContext> SceneContexts
        {
            get { return _map.Values; }
        }

        public void Add(SceneContext context)
        {
            Assert.That(!_map.ContainsKey(context.gameObject.scene));
            _map.Add(context.gameObject.scene, context);
        }

        public SceneContext GetSceneContextForScene(string name)
        {
            var scene = SceneManager.GetSceneByName(name);
            Assert.That(scene.IsValid(), "Could not find scene with name '{0}'", name);
            return GetSceneContextForScene(scene);
        }

        public SceneContext GetSceneContextForScene(Scene scene)
        {
            return _map[scene];
        }

        public SceneContext TryGetSceneContextForScene(string name)
        {
            var scene = SceneManager.GetSceneByName(name);
            Assert.That(scene.IsValid(), "Could not find scene with name '{0}'", name);
            return TryGetSceneContextForScene(scene);
        }

        public SceneContext TryGetSceneContextForScene(Scene scene)
        {
            SceneContext context;

            if (_map.TryGetValue(scene, out context))
            {
                return context;
            }

            return null;
        }

        public DiContainer GetContainerForScene(Scene scene)
        {
            var container = TryGetContainerForScene(scene);

            if (container != null)
            {
                return container;
            }

            throw Assert.CreateException(
                "Unable to find DiContainer for scene '{0}'", scene.name);
        }

        public DiContainer TryGetContainerForScene(Scene scene)
        {
            if (scene == ProjectContext.Instance.gameObject.scene)
            {
                return ProjectContext.Instance.Container;
            }

            var sceneContext = TryGetSceneContextForScene(scene);

            if (sceneContext != null)
            {
                return sceneContext.Container;
            }

            return null;
        }

        public void Remove(SceneContext context)
        {
            bool removed = _map.Remove(context.gameObject.scene);

            if (!removed)
            {
                Log.Warn("Failed to remove SceneContext from SceneContextRegistry");
            }
        }
    }

}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/SceneContextRegistry.cs.meta
================================================
fileFormatVersion: 2
guid: 11e438b2dc7552349949f24c14de14be
timeCreated: 1510660712
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/SceneContextRegistryAdderAndRemover.cs
================================================
using System;

namespace Zenject
{
    public class SceneContextRegistryAdderAndRemover : IInitializable, IDisposable
    {
        readonly SceneContextRegistry _registry;
        readonly SceneContext _sceneContext;

        public SceneContextRegistryAdderAndRemover(
            SceneContext sceneContext,
            SceneContextRegistry registry)
        {
            _registry = registry;
            _sceneContext = sceneContext;
        }

        public void Initialize()
        {
            _registry.Add(_sceneContext);
        }

        public void Dispose()
        {
            _registry.Remove(_sceneContext);
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/SceneContextRegistryAdderAndRemover.cs.meta
================================================
fileFormatVersion: 2
guid: b13656f05675c384181e749264e6bcf9
timeCreated: 1510660712
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/TaskUpdater.cs
================================================
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ModestTree;

namespace Zenject
{
    // Update tasks once per frame based on a priority
    [DebuggerStepThrough]
    public abstract class TaskUpdater<TTask>
    {
        readonly LinkedList<TaskInfo> _tasks = new LinkedList<TaskInfo>();
        readonly List<TaskInfo> _queuedTasks = new List<TaskInfo>();

        IEnumerable<TaskInfo> AllTasks
        {
            get { return ActiveTasks.Concat(_queuedTasks); }
        }

        IEnumerable<TaskInfo> ActiveTasks
        {
            get { return _tasks; }
        }

        public void AddTask(TTask task, int priority)
        {
            AddTaskInternal(task, priority);
        }

        void AddTaskInternal(TTask task, int priority)
        {
            Assert.That(!AllTasks.Select(x => x.Task).ContainsItem(task),
                "Duplicate task added to DependencyRoot with name '" + task.GetType().FullName + "'");

            // Wait until next frame to add the task, otherwise whether it gets updated
            // on the current frame depends on where in the update order it was added
            // from, so you might get off by one frame issues
            _queuedTasks.Add(new TaskInfo(task, priority));
        }

        public void RemoveTask(TTask task)
        {
            var info = AllTasks.Where(x => ReferenceEquals(x.Task, task)).SingleOrDefault();

            Assert.IsNotNull(info, "Tried to remove a task not added to DependencyRoot, task = " + task.GetType().Name);

            Assert.That(!info.IsRemoved, "Tried to remove task twice, task = " + task.GetType().Name);
            info.IsRemoved = true;
        }

        public void OnFrameStart()
        {
            // See above comment
            AddQueuedTasks();
        }

        public void UpdateAll()
        {
            UpdateRange(int.MinValue, int.MaxValue);
        }

        public void UpdateRange(int minPriority, int maxPriority)
        {
            var node = _tasks.First;

            while (node != null)
            {
                var next = node.Next;
                var taskInfo = node.Value;

                // Make sure that tasks with priority of int.MaxValue are updated when maxPriority is int.MaxValue
                if (!taskInfo.IsRemoved && taskInfo.Priority >= minPriority
                    && (maxPriority == int.MaxValue || taskInfo.Priority < maxPriority))
                {
                    UpdateItem(taskInfo.Task);
                }

                node = next;
            }

            ClearRemovedTasks(_tasks);
        }

        void ClearRemovedTasks(LinkedList<TaskInfo> tasks)
        {
            var node = tasks.First;

            while (node != null)
            {
                var next = node.Next;
                var info = node.Value;

                if (info.IsRemoved)
                {
                    //ModestTree.Log.Debug("Removed task '" + info.Task.GetType().ToString() + "'");
                    tasks.Remove(node);
                }

                node = next;
            }
        }

        void AddQueuedTasks()
        {
            for (int i = 0; i < _queuedTasks.Count; i++)
            {
                var task = _queuedTasks[i];

                if (!task.IsRemoved)
                {
                    InsertTaskSorted(task);
                }
            }
            _queuedTasks.Clear();
        }

        void InsertTaskSorted(TaskInfo task)
        {
            for (var current = _tasks.First; current != null; current = current.Next)
            {
                if (current.Value.Priority > task.Priority)
                {
                    _tasks.AddBefore(current, task);
                    return;
                }
            }

            _tasks.AddLast(task);
        }

        protected abstract void UpdateItem(TTask task);

        class TaskInfo
        {
            public TTask Task;
            public int Priority;
            public bool IsRemoved;

            public TaskInfo(TTask task, int priority)
            {
                Task = task;
                Priority = priority;
            }
        }
    }

    public class TickablesTaskUpdater : TaskUpdater<ITickable>
    {
        protected override void UpdateItem(ITickable task)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
            using (ProfileBlock.Start("{0}.Tick()", task.GetType()))
#endif
            {
                task.Tick();
            }
        }
    }

    public class LateTickablesTaskUpdater : TaskUpdater<ILateTickable>
    {
        protected override void UpdateItem(ILateTickable task)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
            using (ProfileBlock.Start("{0}.LateTick()", task.GetType()))
#endif
            {
                task.LateTick();
            }
        }
    }

    public class FixedTickablesTaskUpdater : TaskUpdater<IFixedTickable>
    {
        protected override void UpdateItem(IFixedTickable task)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("User Code"))
#endif
#if UNITY_EDITOR
            using (ProfileBlock.Start("{0}.FixedTick()", task.GetType()))
#endif
            {
                task.FixedTick();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/TaskUpdater.cs.meta
================================================
fileFormatVersion: 2
guid: 4e52124c243adb44aaf26eed3a8413c8
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/TickableManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;
#if ZEN_SIGNALS_ADD_UNIRX
using UniRx;
#endif

namespace Zenject
{
    public class TickableManager
    {
        [Inject(Optional = true, Source = InjectSources.Local)]
        readonly List<ITickable> _tickables = null;

        [Inject(Optional = true, Source = InjectSources.Local)]
        readonly List<IFixedTickable> _fixedTickables = null;

        [Inject(Optional = true, Source = InjectSources.Local)]
        readonly List<ILateTickable> _lateTickables = null;

        [Inject(Optional = true, Source = InjectSources.Local)]
        readonly List<ValuePair<Type, int>> _priorities = null;

        [Inject(Optional = true, Id = "Fixed", Source = InjectSources.Local)]
        readonly List<ValuePair<Type, int>> _fixedPriorities = null;

        [Inject(Optional = true, Id = "Late", Source = InjectSources.Local)]
        readonly List<ValuePair<Type, int>> _latePriorities = null;

#if ZEN_SIGNALS_ADD_UNIRX
        readonly Subject<Unit> _tickStream = new Subject<Unit>();
        readonly Subject<Unit> _lateTickStream = new Subject<Unit>();
        readonly Subject<Unit> _fixedTickStream = new Subject<Unit>();
#endif

        readonly TickablesTaskUpdater _updater = new TickablesTaskUpdater();
        readonly FixedTickablesTaskUpdater _fixedUpdater = new FixedTickablesTaskUpdater();
        readonly LateTickablesTaskUpdater _lateUpdater = new LateTickablesTaskUpdater();

        bool _isPaused;

        [Inject]
        public TickableManager()
        {
        }

#if ZEN_SIGNALS_ADD_UNIRX
        public IObservable<Unit> TickStream
        {
            get { return _tickStream; }
        }

        public IObservable<Unit> LateTickStream
        {
            get { return _lateTickStream; }
        }

        public IObservable<Unit> FixedTickStream
        {
            get { return _fixedTickStream; }
        }
#endif

        public IEnumerable<ITickable> Tickables
        {
            get { return _tickables; }
        }

        public bool IsPaused
        {
            get { return _isPaused; }
            set { _isPaused = value; }
        }

        [Inject]
        public void Initialize()
        {
            InitTickables();
            InitFixedTickables();
            InitLateTickables();
        }

        void InitFixedTickables()
        {
            foreach (var type in _fixedPriorities.Select(x => x.First))
            {
                Assert.That(type.DerivesFrom<IFixedTickable>(),
                    "Expected type '{0}' to drive from IFixedTickable while checking priorities in TickableHandler", type);
            }

            foreach (var tickable in _fixedTickables)
            {
                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var matches = _fixedPriorities.Where(x => tickable.GetType().DerivesFromOrEqual(x.First)).Select(x => x.Second).ToList();
                int priority = matches.IsEmpty() ? 0 : matches.Distinct().Single();

                _fixedUpdater.AddTask(tickable, priority);
            }
        }

        void InitTickables()
        {
            foreach (var type in _priorities.Select(x => x.First))
            {
                Assert.That(type.DerivesFrom<ITickable>(),
                    "Expected type '{0}' to drive from ITickable while checking priorities in TickableHandler", type);
            }

            foreach (var tickable in _tickables)
            {
                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var matches = _priorities.Where(x => tickable.GetType().DerivesFromOrEqual(x.First)).Select(x => x.Second).ToList();
                int priority = matches.IsEmpty() ? 0 : matches.Distinct().Single();

                _updater.AddTask(tickable, priority);
            }
        }

        void InitLateTickables()
        {
            foreach (var type in _latePriorities.Select(x => x.First))
            {
                Assert.That(type.DerivesFrom<ILateTickable>(),
                    "Expected type '{0}' to drive from ILateTickable while checking priorities in TickableHandler", type);
            }

            foreach (var tickable in _lateTickables)
            {
                // Note that we use zero for unspecified priority
                // This is nice because you can use negative or positive for before/after unspecified
                var matches = _latePriorities.Where(x => tickable.GetType().DerivesFromOrEqual(x.First)).Select(x => x.Second).ToList();
                int priority = matches.IsEmpty() ? 0 : matches.Distinct().Single();

                _lateUpdater.AddTask(tickable, priority);
            }
        }

        public void Add(ITickable tickable, int priority)
        {
            _updater.AddTask(tickable, priority);
        }

        public void Add(ITickable tickable)
        {
            Add(tickable, 0);
        }

        public void AddLate(ILateTickable tickable, int priority)
        {
            _lateUpdater.AddTask(tickable, priority);
        }

        public void AddLate(ILateTickable tickable)
        {
            AddLate(tickable, 0);
        }

        public void AddFixed(IFixedTickable tickable, int priority)
        {
            _fixedUpdater.AddTask(tickable, priority);
        }

        public void AddFixed(IFixedTickable tickable)
        {
            _fixedUpdater.AddTask(tickable, 0);
        }

        public void Remove(ITickable tickable)
        {
            _updater.RemoveTask(tickable);
        }

        public void RemoveLate(ILateTickable tickable)
        {
            _lateUpdater.RemoveTask(tickable);
        }

        public void RemoveFixed(IFixedTickable tickable)
        {
            _fixedUpdater.RemoveTask(tickable);
        }

        public void Update()
        {
            if(IsPaused)
            {
                return;
            }

            _updater.OnFrameStart();
            _updater.UpdateAll();

#if ZEN_SIGNALS_ADD_UNIRX
            _tickStream.OnNext(Unit.Default);
#endif
        }

        public void FixedUpdate()
        {
            if(IsPaused)
            {
                return;
            }

            _fixedUpdater.OnFrameStart();
            _fixedUpdater.UpdateAll();

#if ZEN_SIGNALS_ADD_UNIRX
            _fixedTickStream.OnNext(Unit.Default);
#endif
        }

        public void LateUpdate()
        {
            if(IsPaused)
            {
                return;
            }

            _lateUpdater.OnFrameStart();
            _lateUpdater.UpdateAll();

#if ZEN_SIGNALS_ADD_UNIRX
            _lateTickStream.OnNext(Unit.Default);
#endif
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/TickableManager.cs.meta
================================================
fileFormatVersion: 2
guid: 2fa54cf0e36bd194faa8f877e9f699a4
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/DecoratableMonoKernel.cs
================================================
﻿namespace Zenject
{
    public interface IDecoratableMonoKernel
    {
        bool ShouldInitializeOnStart();
        void Initialize();
        void Update();
        void FixedUpdate();
        void LateUpdate();
        void Dispose();
        void LateDispose();
    }

    public class DecoratableMonoKernel : IDecoratableMonoKernel
    {
        [InjectLocal] 
        public TickableManager TickableManager { get; protected set; } = null;

        [InjectLocal]
        public InitializableManager InitializableManager { get; protected set; } = null;

        [InjectLocal]
        public DisposableManager DisposablesManager { get; protected set; } = null;
        
        
        public virtual bool ShouldInitializeOnStart() => true;
        
        public virtual void Initialize()
        {
            InitializableManager.Initialize();
        }

        public void Update()
        {
            TickableManager.Update();
        }

        public void FixedUpdate()
        {
            TickableManager.FixedUpdate();
        }

        public void LateUpdate()
        {
            TickableManager.LateUpdate();
        }

        public void Dispose()
        {
            DisposablesManager.Dispose();
        }

        public void LateDispose()
        {
            DisposablesManager.LateDispose();
        }
    }

    public abstract class BaseMonoKernelDecorator : IDecoratableMonoKernel
    {
        [Inject] 
        protected IDecoratableMonoKernel DecoratedMonoKernel;

        public virtual bool ShouldInitializeOnStart() => DecoratedMonoKernel.ShouldInitializeOnStart();
        public virtual void Initialize() => DecoratedMonoKernel.Initialize();
        public virtual void Update() => DecoratedMonoKernel.Update();
        public virtual void FixedUpdate() => DecoratedMonoKernel.FixedUpdate();
        public virtual void LateUpdate() => DecoratedMonoKernel.LateUpdate();
        public virtual void Dispose() => DecoratedMonoKernel.Dispose();
        public virtual void LateDispose() => DecoratedMonoKernel.LateDispose();
    }
    
}


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/DecoratableMonoKernel.cs.meta
================================================
﻿fileFormatVersion: 2
guid: f054684b4d0f44a1904823270ae3f137
timeCreated: 1587868417


================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/DefaultGameObjectKernel.cs
================================================
#if !NOT_UNITY3D

namespace Zenject
{
    public class DefaultGameObjectKernel : MonoKernel
    {
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/DefaultGameObjectKernel.cs.meta
================================================
fileFormatVersion: 2
guid: 1c47912ae4e51a84d92f1acf689997c8
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -9996
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/Kernel.cs
================================================
using System;
using System.Diagnostics;

namespace Zenject
{
    [DebuggerStepThrough]
    public class Kernel : IInitializable, IDisposable, ITickable, ILateTickable, IFixedTickable, ILateDisposable
    {
        [InjectLocal]
        TickableManager _tickableManager = null;

        [InjectLocal]
        InitializableManager _initializableManager = null;

        [InjectLocal]
        DisposableManager _disposablesManager = null;

        public virtual void Initialize()
        {
            _initializableManager.Initialize();
        }

        public virtual void Dispose()
        {
            _disposablesManager.Dispose();
        }

        public virtual void LateDispose()
        {
            _disposablesManager.LateDispose();
        }

        public virtual void Tick()
        {
            _tickableManager.Update();
        }

        public virtual void LateTick()
        {
            _tickableManager.LateUpdate();
        }

        public virtual void FixedTick()
        {
            _tickableManager.FixedUpdate();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/Kernel.cs.meta
================================================
fileFormatVersion: 2
guid: 8a25347f1a9a6b544b4ef8b643824a6f
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/MonoKernel.cs
================================================
#if !NOT_UNITY3D

#pragma warning disable 649

using ModestTree;
using UnityEngine;
using UnityEngine.Analytics;

namespace Zenject
{
    public abstract class MonoKernel : MonoBehaviour
    {
        [InjectLocal]
        TickableManager _tickableManager = null;

        [InjectLocal]
        InitializableManager _initializableManager = null;

        [InjectLocal]
        DisposableManager _disposablesManager = null;

        [InjectOptional] 
        private IDecoratableMonoKernel decoratableMonoKernel;

        bool _hasInitialized;
        bool _isDestroyed;

        protected bool IsDestroyed
        {
            get { return _isDestroyed; }
        }

        public virtual void Start()
        {
            if (decoratableMonoKernel?.ShouldInitializeOnStart()??true)
            {
                Initialize();
            }
        }

        public void Initialize()
        {
            // We don't put this in start in case Start is overridden
            if (!_hasInitialized)
            {
                _hasInitialized = true;

                if (decoratableMonoKernel != null)
                {
                    decoratableMonoKernel.Initialize();
                }
                else
                {
                    _initializableManager.Initialize();
                }
            }
        }

        public virtual void Update()
        {
            // Don't spam the log every frame if initialization fails and leaves it as null
            if (_tickableManager != null)
            {
                if (decoratableMonoKernel != null)
                {
                    decoratableMonoKernel.Update();
                }
                else
                {
                    _tickableManager.Update();
                }
            }
        }

        public virtual void FixedUpdate()
        {
            // Don't spam the log every frame if initialization fails and leaves it as null
            if (_tickableManager != null)
            {
                if (decoratableMonoKernel != null)
                {
                    decoratableMonoKernel.FixedUpdate();
                }
                else
                {
                    _tickableManager.FixedUpdate();
                }
            }
        }

        public virtual void LateUpdate()
        {
            // Don't spam the log every frame if initialization fails and leaves it as null
            if (_tickableManager != null)
            {
                if (decoratableMonoKernel != null)
                {
                    decoratableMonoKernel.LateUpdate();
                }
                else
                {
                    _tickableManager.LateUpdate();
                }
            }
        }

        public virtual void OnDestroy()
        {
            // _disposablesManager can be null if we get destroyed before the Start event
            if (_disposablesManager != null)
            {
                Assert.That(!_isDestroyed);
                _isDestroyed = true;

                if (decoratableMonoKernel != null)
                {
                    decoratableMonoKernel.Dispose();
                    decoratableMonoKernel.LateDispose();
                }
                else
                {
                    _disposablesManager.Dispose();
                    _disposablesManager.LateDispose();
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/MonoKernel.cs.meta
================================================
fileFormatVersion: 2
guid: 0ed09ac17d1c3ca44b8064ce22ebba27
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/ProjectKernel.cs
================================================
#if !NOT_UNITY3D

using System.Collections.Generic;
using System.Linq;
using ModestTree;
using UnityEngine.SceneManagement;

namespace Zenject
{
    public class ProjectKernel : MonoKernel
    {
        [Inject]
        ZenjectSettings _settings = null;

        [Inject]
        SceneContextRegistry _contextRegistry = null;

        // One issue with relying on MonoKernel.OnDestroy to call IDisposable.Dispose
        // is that the order that OnDestroy is called in is difficult to predict
        // One good thing is that it does follow the heirarchy order (so root game objects
        // will have thier OnDestroy called before child objects)
        // However, the order that OnDestroy is called for the root game objects themselves
        // is largely random
        // Within an individual scene, this can be helped somewhat by placing all game objects
        // underneath the SceneContext and then also checking the 'ParentNewObjectsUnderRoot'
        // property to ensure any new game objects will also be parented underneath SceneContext
        // By doing this, we can be guaranteed to have any bound IDisposable's have their
        // Dispose called before any game object is destroyed in the scene
        // However, when using multiple scenes (each with their own SceneContext) the order
        // that these SceneContext game objects are destroyed is random
        // So to address that, we explicitly call GameObject.DestroyImmediate for all
        // SceneContext's in the reverse order that the scenes were loaded in below
        // (this works because OnApplicationQuit is always called before OnDestroy)
        // Note that this only works when stopping the app and not when changing scenes
        // When changing scenes, if you have multiple scenes loaded at once, you will have to
        // manually unload the scenes in the reverse order they were loaded before going to
        // the new scene, if you require a predictable destruction order.  Or you can always use
        // ZenjectSceneLoader which will do this for you
        public void OnApplicationQuit()
        {
            if (_settings.EnsureDeterministicDestructionOrderOnApplicationQuit)
            {
                DestroyEverythingInOrder();
            }
        }

        public void DestroyEverythingInOrder()
        {
            ForceUnloadAllScenes(true);

            // Destroy project context after all scenes
            Assert.That(!IsDestroyed);
            DestroyImmediate(gameObject);
            Assert.That(IsDestroyed);
        }

        public void ForceUnloadAllScenes(bool immediate = false)
        {
            // OnApplicationQuit should always be called before OnDestroy
            // (Unless it is destroyed manually)
            Assert.That(!IsDestroyed);

            var sceneOrder = new List<Scene>();

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                sceneOrder.Add(SceneManager.GetSceneAt(i));
            }

            // Destroy the scene contexts from bottom to top
            // Since this is the reverse order that they were loaded in
            foreach (var sceneContext in _contextRegistry.SceneContexts.OrderByDescending(x => sceneOrder.IndexOf(x.gameObject.scene)).ToList())
            {
                if (immediate)
                {
                    DestroyImmediate(sceneContext.gameObject);
                }
                else
                {
                    Destroy(sceneContext.gameObject);
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/ProjectKernel.cs.meta
================================================
fileFormatVersion: 2
guid: 374b2cd725ea28a46a6377959bb73c9c
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -9998
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/SceneKernel.cs
================================================
#if !NOT_UNITY3D

using ModestTree;

namespace Zenject
{
    public class SceneKernel : MonoKernel
    {
        // Only needed to set "script execution order" in unity project settings

#if ZEN_INTERNAL_PROFILING
        public override void Start()
        {
            base.Start();
            Log.Info("SceneContext.Awake detailed profiling: {0}", ProfileTimers.FormatResults());
        }
#endif
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Runtime/Kernels/SceneKernel.cs.meta
================================================
fileFormatVersion: 2
guid: aff38aaefd39d0d41a92c2707718d15c
timeCreated: 1461708052
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -9997
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Usage/link.xml
================================================
<linker>
    <assembly fullname="Zenject-usage" preserve="all"/>
</linker>



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Usage/link.xml.meta
================================================
fileFormatVersion: 2
guid: 78cde942f7000eb41900aa4d3c9249d7
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Usage/Zenject-usage.dll.meta
================================================
fileFormatVersion: 2
guid: 700aed094b237904eb96e963264dd6ff
timeCreated: 1527419737
licenseType: Free
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  isPreloaded: 0
  isOverridable: 0
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ActionInstaller.cs
================================================
using System;

namespace Zenject
{
    public class ActionInstaller : Installer<ActionInstaller>
    {
        readonly Action<DiContainer> _installMethod;

        public ActionInstaller(Action<DiContainer> installMethod)
        {
            _installMethod = installMethod;
        }

        public override void InstallBindings()
        {
            _installMethod(Container);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ActionInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: e182a0b67fa936e40bebc0dc2f28743a
timeCreated: 1476911606
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/CheatSheet.cs
================================================
using System.Linq;
using ModestTree;
using UnityEngine;

#pragma warning disable 219

namespace Zenject
{
    public class CheatSheet : Installer<CheatSheet>
    {
        public override void InstallBindings()
        {
            // Create a new instance of Foo for every class that asks for it
            Container.Bind<Foo>().AsTransient();

            // Create a new instance of Foo for every class that asks for an IFoo
            Container.Bind<IFoo>().To<Foo>().AsTransient();

            // Non generic version of the above
            Container.Bind(typeof(IFoo)).To(typeof(Foo)).AsTransient();

            ///////////// AsSingle

            // Create one definitive instance of Foo and re-use that for every class that asks for it
            Container.Bind<Foo>().AsSingle();

            // Create one definitive instance of Foo and re-use that for every class that asks for IFoo
            Container.Bind<IFoo>().To<Foo>().AsSingle();

            // Bind the same instance to multiple types
            // In this example, the same instance of Foo will be used for all three types
            // (we have to use the non-generic version of Bind when mapping to multiple types)
            Container.Bind(typeof(Foo), typeof(IFoo), typeof(IFoo2)).To<Foo>().AsSingle();

            ///////////// BindInterfaces

            // This will have the exact same effect as the above line
            // Bind all interfaces that Foo implements and Foo itself to a new singleton of type Foo
            Container.BindInterfacesAndSelfTo<Foo>().AsSingle();

            // Bind only the interfaces that Foo implements to an instance of Foo
            // This can be useful if you don't want any classes to directly reference the concrete
            // derived type
            Container.BindInterfacesTo<Foo>().AsSingle();

            ///////////// FromInstance

            // Use the given instance everywhere that Foo is used
            // Note that in this case there's no good reason to use FromInstance
            Container.Bind<Foo>().FromInstance(new Foo());

            // This is simply a shortcut for the above binding
            // This can be a bit nicer since the type argument can be deduced from the parameter
            Container.BindInstance(new Foo());

            // Bind multiple instances at once
            Container.BindInstances(new Foo(), new Bar());

            ///////////// Binding primitive types

            // BindInstance is more commonly used with primitive types
            // Use the number 10 every time an int is requested
            Container.Bind<int>().FromInstance(10);
            Container.Bind<bool>().FromInstance(false);

            // Or equivalently:
            Container.BindInstance(10);
            Container.BindInstance(false);

            // You'd never really want to do the above though - you should almost always use a When condition for primitive values
            Container.BindInstance(10).WhenInjectedInto<Foo>();

            ///////////// FromMethod

            // Create instance of Foo when requested, using the given method
            // Note that for more complex construction scenarios, you might consider using a factory
            // instead with FromFactory
            Container.Bind<Foo>().FromMethod(GetFoo);

            // Randomly return one of several different implementations of IFoo
            // We use Instantiate here instead of just new so that Foo1 gets its members injected
            Container.Bind<IFoo>().FromMethod(GetRandomFoo);

            // You an also use an anonymouse delegate directly
            Container.Bind<Foo>().FromMethod(ctx => new Foo());

            // This is equivalent to AsTransient
            Container.Bind<Foo>().FromMethod(ctx => ctx.Container.Instantiate<Foo>());

            InstallMore();
        }

        Foo GetFoo(InjectContext ctx)
        {
            return new Foo();
        }

        IFoo GetRandomFoo(InjectContext ctx)
        {
            switch (Random.Range(0, 3))
            {
                case 0:
                {
                    return ctx.Container.Instantiate<Foo1>();
                }
                case 1:
                {
                    return ctx.Container.Instantiate<Foo2>();
                }
            }

            return ctx.Container.Instantiate<Foo3>();
        }

        void InstallMore()
        {
            ///////////// FromResolveGetter

            // Bind to a property on another dependency
            // This can be helpful to reduce coupling between classes
            Container.Bind<Foo>().AsSingle();

            Container.Bind<Bar>().FromResolveGetter<Foo>(foo => foo.GetBar());

            // Another example using values
            Container.Bind<string>().FromResolveGetter<Foo>(foo => foo.GetTitle());

            ///////////// FromNewComponentOnNewGameObject

            // Create a new game object at the root of the scene and add the Foo MonoBehaviour to it
            Container.Bind<Foo>().FromNewComponentOnNewGameObject().AsSingle();

            // You can also specify the game object name to use using WithGameObjectName
            Container.Bind<Foo>().FromNewComponentOnNewGameObject().WithGameObjectName("Foo1").AsSingle();

            // Bind to an interface instead
            Container.Bind<IFoo>().To<Foo>().FromNewComponentOnNewGameObject().AsSingle();

            ///////////// FromComponentInNewPrefab (singleton)

            // Create a new game object at the root of the scene using the given prefab
            // After zenject creates a new GameObject from the given prefab, it will
            // search the prefab for a component of type 'Foo' and return that
            GameObject prefab = null;
            Container.Bind<Foo>().FromComponentInNewPrefab(prefab).AsSingle();

            // Bind to interface instead
            Container.Bind<IFoo>().To<Foo>().FromComponentInNewPrefab(prefab).AsSingle();

            // You can also add multiple components
            // Note here that only one instance of the given prefab will be
            // created
            // For this to work, there must be both a Foo MonoBehaviour and
            // a Bar MonoBehaviour somewhere on the prefab
            Container.Bind(typeof(Foo), typeof(Bar)).FromComponentInNewPrefab(prefab).AsSingle();

            ///////////// FromComponentInNewPrefab (Transient)

            // Instantiate a new copy of 'prefab' every time an instance of Foo is
            // requested by a constructor parameter, injected field, etc.
            Container.Bind<Foo>().FromComponentInNewPrefab(prefab).AsTransient();

            // Bind to interface instead
            Container.Bind<IFoo>().To<Foo>().FromComponentInNewPrefab(prefab);

            ///////////// Identifiers

            // Bind a globally accessible string with the name 'PlayerName'
            // Note however that a better option might be to create a Settings object and bind
            // that instead
            Container.Bind<string>().WithId("PlayerName").FromInstance("name of the player");

            // This is the equivalent of the line above, and is a bit more readable
            Container.BindInstance("name of the player").WithId("PlayerName");

            // We can also use IDs to bind multiple instances of the same type:
            Container.BindInstance("foo").WithId("FooA");
            Container.BindInstance("asdf").WithId("FooB");

            InstallMore2();
        }

        // Then when we inject these dependencies we have to use the same ID:
        public class Norf
        {
            [Inject(Id = "FooA")]
            public string Foo;
        }

        public class Qux
        {
            [Inject(Id = "FooB")]
            public string Foo;
        }

        public void InstallMore2()
        {
            ///////////// AsCached

            // In this example, we bind three instances of Foo, including one without an ID
            // We have to use AsCached here because Foo is not a singleton, but we also
            // do not want a new Foo created every time like AsTransient
            // This will result in a maximum of 3 instances of Foo
            Container.Bind<Foo>().AsCached();
            Container.Bind<Foo>().WithId("FooA").AsCached();
            Container.Bind<Foo>().WithId("FooA").AsCached();

            InstallMore3();
        }

        // When an ID is unspecified in an [Inject] field, it will use the first
        // instance
        // Bindings without IDs can therefore be used as a default and we can
        // specify IDs for specific versions of the same type
        public class Norf2
        {
            [Inject]
            public Foo Foo;
        }

        // Qux2._foo will be the same instance as Norf2._foo
        // This is because we are using AsCached rather than AsTransient
        public class Qux2
        {
            [Inject]
            public Foo Foo;

            [Inject(Id = "FooA")]
            public Foo Foo2;
        }

        public void InstallMore3()
        {
            ///////////// Conditions

            // This will make Foo only visible to Bar
            // If we add Foo to the constructor of any other class it won't find it
            Container.Bind<Foo>().AsSingle().WhenInjectedInto<Bar>();

            // Use different implementations of IFoo dependending on which
            // class is being injected
            Container.Bind<IFoo>().To<Foo1>().AsSingle().WhenInjectedInto<Bar>();
            Container.Bind<IFoo>().To<Foo2>().AsSingle().WhenInjectedInto<Qux>();

            // Use "Foo1" as the default implementation except when injecting into
            // class Qux, in which case use Foo2
            // This works because if there is a condition match, that takes precedence
            Container.Bind<IFoo>().To<Foo1>().AsSingle();
            Container.Bind<IFoo>().To<Foo2>().AsSingle().WhenInjectedInto<Qux>();

            // Allow depending on Foo in only a few select classes
            Container.Bind<Foo>().AsSingle().WhenInjectedInto(typeof(Bar), typeof(Qux), typeof(Baz));

            // Supply "my game" for any strings that are injected into the Gui class with the identifier "Title"
            Container.BindInstance("my game").WithId("Title").WhenInjectedInto<Gui>();

            // Supply 5 for all ints that are injected into the Gui class
            Container.BindInstance(5).WhenInjectedInto<Gui>();

            // Supply 5 for all ints that are injected into a parameter or field
            // inside type Gui that is named 'width'
            // Note that this is usually not a good idea since the name of a field can change
            // easily and break the binding but shown here as an example of a more complex
            // condition
            Container.BindInstance(5.0f).When(ctx =>
                ctx.ObjectType == typeof(Gui) && ctx.MemberName == "width");

            // Create a new 'Foo' for every class that is created as part of the
            // construction of the 'Bar' class
            // So if Bar has a constructor parameter of type Qux, and Qux has
            // a constructor parameter of type IFoo, a new Foo will be created
            // for that case
            Container.Bind<IFoo>().To<Foo>().AsTransient().When(
                ctx => ctx.AllObjectTypes.Contains(typeof(Bar)));

            ///////////// Complex conditions example

            var foo1 = new Foo();
            var foo2 = new Foo();

            Container.Bind<Bar>().WithId("Bar1").AsCached();
            Container.Bind<Bar>().WithId("Bar2").AsCached();

            // Here we use the 'ParentContexts' property of inject context to sync multiple corresponding identifiers
            Container.BindInstance(foo1).When(c => c.ParentContexts.Where(x => x.MemberType == typeof(Bar) && Equals(x.Identifier, "Bar1")).Any());
            Container.BindInstance(foo2).When(c => c.ParentContexts.Where(x => x.MemberType == typeof(Bar) && Equals(x.Identifier, "Bar2")).Any());

            // This results in:
            Assert.That(Container.ResolveId<Bar>("Bar1").Foo == foo1);
            Assert.That(Container.ResolveId<Bar>("Bar2").Foo == foo2);

            ///////////// FromResolve

            // FromResolve does another lookup on the container
            // This will result in IBar, IFoo, and Foo, all being bound to the same instance of
            // Foo which is assume to exist somewhere on the given prefab
            GameObject fooPrefab = null;
            Container.Bind<Foo>().FromComponentInNewPrefab(fooPrefab).AsSingle();
            Container.Bind<IBar>().To<Foo>().FromResolve();
            Container.Bind<IFoo>().To<IBar>().FromResolve();

            // This will result in the same behaviour as the above
            Container.Bind(typeof(Foo), typeof(IBar), typeof(IFoo)).To<Foo>().FromComponentInNewPrefab(fooPrefab).AsSingle();

            InstallMore4();
        }

        public class FooInstaller : Installer<FooInstaller>
        {
            public FooInstaller(string foo)
            {
            }

            public override void InstallBindings()
            {
            }
        }

        public class FooInstallerWithArgs : Installer<string, FooInstallerWithArgs>
        {
            public FooInstallerWithArgs(string foo)
            {
            }

            public override void InstallBindings()
            {
            }
        }

        void InstallMore4()
        {
            ///////////// Installing Other Installers

            // Immediately call InstallBindings() on FooInstaller
            FooInstaller.Install(Container);

            // Before calling FooInstaller, configure a property of it
            Container.BindInstance("foo").WhenInjectedInto<FooInstaller>();
            FooInstaller.Install(Container);

            // The arguments can also be added to the Installer<> generic arguments to make them
            // strongly typed
            FooInstallerWithArgs.Install(Container, "foo");

            ///////////// Manual Use of Container

            // This will fill in any parameters marked as [Inject] and also call any [Inject] methods
            var foo = new Foo();
            Container.Inject(foo);

            // Return an instance for IFoo, using the bindings that have been added previously
            // Internally it is what is triggered when you fill in a constructor parameter of type IFoo
            // Note: It will throw an exception if it cannot find a match
            Container.Resolve<IFoo>();

            // Same as the above except returns null when it can't find the given type
            Container.TryResolve<IFoo>();

            // Return a list of 2 instances of type Foo
            // Note that in this case simply calling Resolve<IFoo> will trigger an exception
            Container.BindInstance(new Foo());
            Container.BindInstance(new Foo());
            var foos = Container.ResolveAll<IFoo>();

            // Create a new instance of Foo and inject on any of its members
            // And fill in any constructor parameters Foo might have
            Container.Instantiate<Foo>();

            GameObject prefab1 = null;
            GameObject prefab2 = null;

            // Instantiate a new prefab and have any injectables filled in on the prefab
            GameObject go = Container.InstantiatePrefab(prefab1);

            // Instantiate a new prefab and return a specific monobehaviour
            Foo foo2 = Container.InstantiatePrefabForComponent<Foo>(prefab2);

            // Add a new component to an existing game object
            Foo foo3 = Container.InstantiateComponent<Foo>(go);
        }

        public interface IFoo2
        {
        }

        public interface IFoo
        {
        }

        public interface IBar : IFoo
        {
        }

        public class Foo : MonoBehaviour, IFoo, IFoo2, IBar
        {
            public Bar GetBar()
            {
                return new Bar();
            }

            public string GetTitle()
            {
                return "title";
            }
        }

        public class Foo1 : IFoo
        {
        }

        public class Foo2 : IFoo
        {
        }

        public class Foo3 : IFoo
        {
        }

        public class Baz
        {
        }

        public class Gui
        {
        }

        public class Bar : IBar
        {
            public Foo Foo
            {
                get
                {
                    return null;
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/CheatSheet.cs.meta
================================================
fileFormatVersion: 2
guid: 1d2fc6db101e75248ab98ad463a99ffa
timeCreated: 1528895686
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/DefaultGameObjectParentInstaller.cs
================================================
#if !NOT_UNITY3D

using System;
using UnityEngine;

namespace Zenject
{
    public class DefaultGameObjectParentInstaller : Installer<string, DefaultGameObjectParentInstaller>
    {
        readonly string _name;

        public DefaultGameObjectParentInstaller(string name)
        {
            _name = name;
        }

        public override void InstallBindings()
        {
#if !ZEN_TESTS_OUTSIDE_UNITY
            var defaultParent = new GameObject(_name);

            defaultParent.transform.SetParent(
                Container.InheritedDefaultParent, false);

            Container.DefaultParent = defaultParent.transform;

            Container.Bind<IDisposable>()
                .To<DefaultParentObjectDestroyer>().AsCached().WithArguments(defaultParent);

            // Always destroy the default parent last so that the non-monobehaviours get a chance
            // to clean it up if they want to first
            Container.BindDisposableExecutionOrder<DefaultParentObjectDestroyer>(int.MinValue);
#endif
        }

        class DefaultParentObjectDestroyer : IDisposable
        {
            readonly GameObject _gameObject;

            public DefaultParentObjectDestroyer(GameObject gameObject)
            {
                _gameObject = gameObject;
            }

            public void Dispose()
            {
                GameObject.Destroy(_gameObject);
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/DefaultGameObjectParentInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: dd79d0a4f0b28314cbd6701ff5ab9062
timeCreated: 1538629352
licenseType: Pro
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/DisposeBlock.cs
================================================
using System;
using System.Collections.Generic;
using ModestTree;

namespace Zenject
{
    [NoReflectionBaking]
    public class DisposeBlock : IDisposable
    {
        static readonly StaticMemoryPool<DisposeBlock> _pool =
            new StaticMemoryPool<DisposeBlock>(OnSpawned, OnDespawned);

        List<IDisposable> _disposables;
        List<SpawnedObjectPoolPair> _objectPoolPairs;

        static void OnSpawned(DisposeBlock that)
        {
            Assert.IsNull(that._disposables);
            Assert.IsNull(that._objectPoolPairs);
        }

        static void OnDespawned(DisposeBlock that)
        {
            if (that._disposables != null)
            {
                // Dispose in reverse order since usually that makes the most sense
                for (int i = that._disposables.Count - 1; i >= 0; i--)
                {
                    that._disposables[i].Dispose();
                }
                ListPool<IDisposable>.Instance.Despawn(that._disposables);
                that._disposables = null;
            }

            if (that._objectPoolPairs != null)
            {
                // Dispose in reverse order since usually that makes the most sense
                for (int i = that._objectPoolPairs.Count - 1; i >= 0; i--)
                {
                    var pair = that._objectPoolPairs[i];
                    pair.Pool.Despawn(pair.Object);
                }
                ListPool<SpawnedObjectPoolPair>.Instance.Despawn(that._objectPoolPairs);
                that._objectPoolPairs = null;
            }
        }

        void LazyInitializeDisposableList()
        {
            if (_disposables == null)
            {
                _disposables = ListPool<IDisposable>.Instance.Spawn();
            }
        }

        public void AddRange<T>(IList<T> disposables)
            where T : IDisposable
        {
            LazyInitializeDisposableList();
            for (int i = 0; i < disposables.Count; i++)
            {
                _disposables.Add(disposables[i]);
            }
        }

        public void Add(IDisposable disposable)
        {
            LazyInitializeDisposableList();
            Assert.That(!_disposables.Contains(disposable));
            _disposables.Add(disposable);
        }

        public void Remove(IDisposable disposable)
        {
            Assert.IsNotNull(_disposables);
            _disposables.RemoveWithConfirm(disposable);
        }

        void StoreSpawnedObject<T>(T obj, IDespawnableMemoryPool<T> pool)
        {
            if (typeof(T).DerivesFrom<IDisposable>())
            {
                Add((IDisposable)obj);
            }
            else
            {
                // This allocation is ok because it's a struct
                var pair = new SpawnedObjectPoolPair
                {
                    Pool = pool,
                    Object = obj
                };

                if (_objectPoolPairs == null)
                {
                    _objectPoolPairs = ListPool<SpawnedObjectPoolPair>.Instance.Spawn();
                }
                _objectPoolPairs.Add(pair);
            }
        }

        public T Spawn<T>(IMemoryPool<T> pool)
        {
            var obj = pool.Spawn();
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1>(IMemoryPool<TParam1, TValue> pool, TParam1 p1)
        {
            var obj = pool.Spawn(p1);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2>(IMemoryPool<TParam1, TParam2, TValue> pool, TParam1 p1, TParam2 p2)
        {
            var obj = pool.Spawn(p1, p2);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2, TParam3>(IMemoryPool<TParam1, TParam2, TParam3, TValue> pool, TParam1 p1, TParam2 p2, TParam3 p3)
        {
            var obj = pool.Spawn(p1, p2, p3);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2, TParam3, TParam4>(IMemoryPool<TParam1, TParam2, TParam3, TParam4, TValue> pool, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4)
        {
            var obj = pool.Spawn(p1, p2, p3, p4);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2, TParam3, TParam4, TParam5>(IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TValue> pool, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5)
        {
            var obj = pool.Spawn(p1, p2, p3, p4, p5);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TValue> pool, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6)
        {
            var obj = pool.Spawn(p1, p2, p3, p4, p5, p6);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public TValue Spawn<TValue, TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7>(IMemoryPool<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6, TParam7, TValue> pool, TParam1 p1, TParam2 p2, TParam3 p3, TParam4 p4, TParam5 p5, TParam6 p6, TParam7 p7)
        {
            var obj = pool.Spawn(p1, p2, p3, p4, p5, p6, p7);
            StoreSpawnedObject(obj, pool);
            return obj;
        }

        public List<T> SpawnList<T>(IEnumerable<T> elements)
        {
            var list = SpawnList<T>();
            list.AddRange(elements);
            return list;
        }

        public List<T> SpawnList<T>()
        {
            return Spawn(ListPool<T>.Instance);
        }

        public static DisposeBlock Spawn()
        {
            return _pool.Spawn();
        }

        public void Dispose()
        {
            _pool.Despawn(this);
        }

        struct SpawnedObjectPoolPair
        {
            public IMemoryPool Pool;
            public object Object;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/DisposeBlock.cs.meta
================================================
fileFormatVersion: 2
guid: 031fb76cf466ade4baf3269c39c146bd
timeCreated: 1519832826
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ExecutionOrderInstaller.cs
================================================
using System;
using System.Collections.Generic;

namespace Zenject
{
    public class ExecutionOrderInstaller : Installer<List<Type>, ExecutionOrderInstaller>
    {
        List<Type> _typeOrder;

        public ExecutionOrderInstaller(List<Type> typeOrder)
        {
            _typeOrder = typeOrder;
        }

        public override void InstallBindings()
        {
            // All tickables without explicit priorities assigned are given order of zero,
            // so put all of these before that (ie. negative)
            int order = -1 * _typeOrder.Count;

            foreach (var type in _typeOrder)
            {
                Container.BindExecutionOrder(type, order);
                order++;
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ExecutionOrderInstaller.cs.meta
================================================
fileFormatVersion: 2
guid: cad41a65c3c0b0f46a659557b2d716e0
timeCreated: 1461708053
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ProfileBlock.cs
================================================
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using ModestTree;
#if UNITY_EDITOR
using UnityEngine.Profiling;
using System.Threading;
#endif

namespace Zenject
{
    [NoReflectionBaking]
    public class ProfileBlock : IDisposable
    {
#if UNITY_EDITOR
        static int _blockCount;
        static ProfileBlock _instance = new ProfileBlock();
        static Dictionary<int, string> _nameCache = new Dictionary<int, string>();

        ProfileBlock()
        {
        }

        public static Thread UnityMainThread
        {
            get; set;
        }

        public static Regex ProfilePattern
        {
            get;
            set;
        }

        static int GetHashCode(object p1, object p2)
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + p1.GetHashCode();
                hash = hash * 29 + p2.GetHashCode();
                return hash;
            }
        }

        static int GetHashCode(object p1, object p2, object p3)
        {
            unchecked // Overflow is fine, just wrap
            {
                int hash = 17;
                hash = hash * 29 + p1.GetHashCode();
                hash = hash * 29 + p2.GetHashCode();
                hash = hash * 29 + p3.GetHashCode();
                return hash;
            }
        }

        public static ProfileBlock Start(string sampleNameFormat, object obj1, object obj2)
        {
#if ZEN_TESTS_OUTSIDE_UNITY
            return null;
#else
            if (UnityMainThread == null
                || !UnityMainThread.Equals(Thread.CurrentThread))
            {
                return null;
            }

            if (!Profiler.enabled)
            {
                return null;
            }

            // We need to ensure that we do not have per-frame allocations in ProfileBlock
            // to avoid infecting the test too much, so use a cache of formatted strings given
            // the input values
            // This only works if the input values do not change per frame
            var hash = GetHashCode(sampleNameFormat, obj1, obj2);

            string formatString;

            if (!_nameCache.TryGetValue(hash, out formatString))
            {
                formatString = string.Format(sampleNameFormat, obj1, obj2);
                _nameCache.Add(hash, formatString);
            }

            return StartInternal(formatString);
#endif
        }

        public static ProfileBlock Start(string sampleNameFormat, object obj)
        {
#if ZEN_TESTS_OUTSIDE_UNITY
            return null;
#else
            if (UnityMainThread == null
                || !UnityMainThread.Equals(Thread.CurrentThread))
            {
                return null;
            }

            if (!Profiler.enabled)
            {
                return null;
            }

            // We need to ensure that we do not have per-frame allocations in ProfileBlock
            // to avoid infecting the test too much, so use a cache of formatted strings given
            // the input values
            // This only works if the input values do not change per frame
            var hash = GetHashCode(sampleNameFormat, obj);

            string formatString;

            if (!_nameCache.TryGetValue(hash, out formatString))
            {
                formatString = string.Format(sampleNameFormat, obj);
                _nameCache.Add(hash, formatString);
            }

            return StartInternal(formatString);
#endif
        }

        public static ProfileBlock Start(string sampleName)
        {
#if ZEN_TESTS_OUTSIDE_UNITY
            return null;
#else
            if (UnityMainThread == null
                || !UnityMainThread.Equals(Thread.CurrentThread))
            {
                return null;
            }

            if (!Profiler.enabled)
            {
                return null;
            }

            return StartInternal(sampleName);
#endif
        }

        static ProfileBlock StartInternal(string sampleName)
        {
            Assert.That(Profiler.enabled);

            if (ProfilePattern == null || ProfilePattern.Match(sampleName).Success)
            {
                Profiler.BeginSample(sampleName);
                _blockCount++;
                return _instance;
            }

            return null;
        }

        public void Dispose()
        {
            _blockCount--;
            Assert.That(_blockCount >= 0);
            Profiler.EndSample();
        }

#else
        ProfileBlock(string sampleName, bool rootBlock)
        {
        }

        ProfileBlock(string sampleName)
            : this(sampleName, false)
        {
        }

        public static Regex ProfilePattern
        {
            get;
            set;
        }

        public static ProfileBlock Start()
        {
            return null;
        }

        public static ProfileBlock Start(string sampleNameFormat, object obj1, object obj2)
        {
            return null;
        }

        // Remove the call completely for builds
        public static ProfileBlock Start(string sampleNameFormat, object obj)
        {
            return null;
        }

        // Remove the call completely for builds
        public static ProfileBlock Start(string sampleName)
        {
            return null;
        }

        public void Dispose()
        {
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ProfileBlock.cs.meta
================================================
fileFormatVersion: 2
guid: 952433523e6a6e445adc4ac7e2086e7d
timeCreated: 1485104137
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ProfileTimers.cs
================================================
#if ZEN_INTERNAL_PROFILING

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using ModestTree;

namespace Zenject
{
    // Similar to ProfileBlock except used for measuring speed of zenject specifically
    // And does not use unity's profiler
    public static class ProfileTimers
    {
        static Dictionary<string, TimerInfo> _timers = new Dictionary<string, TimerInfo>();

        public static void ResetAll()
        {
            foreach (var timer in _timers.Values)
            {
                timer.Reset();
            }
        }

        public static string FormatResults()
        {
            var result = new StringBuilder();

            // Uncomment if you only want to see zenject related info
            //var timers = _timers.Where(x => x.Key != "User Code");
            var timers = _timers;

            var total = timers.Select(x => x.Value.TotalMilliseconds).Sum();

            result.Append("Total time tracked: {0:0.00} ms.  Details:".Fmt(total));

            foreach (var pair in timers.OrderByDescending(x => x.Value.TotalMilliseconds))
            {
                var time = pair.Value.TotalMilliseconds;
                var percent = 100.0 * (time / total);
                var name = pair.Key;

                result.Append("\n  {0:00.0}% ({1:00000}x) ({2:0000} ms) {3}".Fmt(percent, pair.Value.CallCount, time, name));
            }

            return result.ToString();
        }

        public static double GetTimerElapsedMilliseconds(string name)
        {
            return _timers[name].TotalMilliseconds;
        }

        public static IDisposable CreateTimedBlock(string name)
        {
            TimerInfo timer;

            if (!_timers.TryGetValue(name, out timer))
            {
                timer = new TimerInfo();
                _timers.Add(name, timer);
            }

            timer.CallCount++;

            if (timer.IsRunning)
            {
                return null;
            }

            return TimedBlock.Pool.Spawn(timer);
        }

        class TimedBlock : IDisposable
        {
            public static StaticMemoryPool<TimerInfo, TimedBlock> Pool =
                new StaticMemoryPool<TimerInfo, TimedBlock>(OnSpawned, OnDespawned);

            readonly List<TimerInfo> _pausedTimers = new List<TimerInfo>();

            TimerInfo _exclusiveTimer;

            static void OnSpawned(
                TimerInfo exclusiveTimer, TimedBlock instance)
            {
                Assert.That(instance._pausedTimers.Count == 0);

                instance._exclusiveTimer = exclusiveTimer;

                foreach (var timer in _timers.Values)
                {
                    if (exclusiveTimer == timer)
                    {
                        Assert.That(!timer.IsRunning);
                        timer.Resume();
                    }
                    else if (timer.IsRunning)
                    {
                        timer.Pause();
                        instance._pausedTimers.Add(timer);
                    }
                }
            }

            static void OnDespawned(TimedBlock instance)
            {
                Assert.That(instance._exclusiveTimer.IsRunning);
                instance._exclusiveTimer.Pause();

                foreach (var timer in instance._pausedTimers)
                {
                    Assert.That(!timer.IsRunning);
                    timer.Resume();
                }

                instance._pausedTimers.Clear();
            }

            public void Dispose()
            {
                Pool.Despawn(this);
            }
        }

        public class TimerInfo
        {
            readonly Stopwatch _timer;

            public TimerInfo()
            {
                _timer = new Stopwatch();
            }

            public int CallCount
            {
                get; set;
            }

            public double TotalMilliseconds
            {
                get { return _timer.Elapsed.TotalMilliseconds; }
            }

            public bool IsRunning
            {
                get { return _timer.IsRunning; }
            }

            public void Reset()
            {
                _timer.Reset();
            }

            public void Resume()
            {
                _timer.Start();
            }

            public void Pause()
            {
                _timer.Stop();
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ProfileTimers.cs.meta
================================================
fileFormatVersion: 2
guid: 81cad1ee2d8c20942a68a4228e09ff1d
timeCreated: 1537522729
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionInfoTypeInfoConverter.cs
================================================
//#define ZEN_DO_NOT_USE_COMPILED_EXPRESSIONS

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using ModestTree;
#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject.Internal
{
    public static class ReflectionInfoTypeInfoConverter
    {
        public static InjectTypeInfo.InjectMethodInfo ConvertMethod(
            ReflectionTypeInfo.InjectMethodInfo injectMethod)
        {
            var methodInfo = injectMethod.MethodInfo;
            var action = TryCreateActionForMethod(methodInfo);

            if (action == null)
            {
                action = (obj, args) => methodInfo.Invoke(obj, args);
            }

            return new InjectTypeInfo.InjectMethodInfo(
                action,
                injectMethod.Parameters.Select(x => x.InjectableInfo).ToArray(),
                methodInfo.Name);
        }

        public static InjectTypeInfo.InjectConstructorInfo ConvertConstructor(
            ReflectionTypeInfo.InjectConstructorInfo injectConstructor, Type type)
        {
            return new InjectTypeInfo.InjectConstructorInfo(
                TryCreateFactoryMethod(type, injectConstructor),
                injectConstructor.Parameters.Select(x => x.InjectableInfo).ToArray());
        }

        public static InjectTypeInfo.InjectMemberInfo ConvertField(
            Type parentType, ReflectionTypeInfo.InjectFieldInfo injectField)
        {
            return new InjectTypeInfo.InjectMemberInfo(
                GetSetter(parentType, injectField.FieldInfo), injectField.InjectableInfo);
        }

        public static InjectTypeInfo.InjectMemberInfo ConvertProperty(
            Type parentType, ReflectionTypeInfo.InjectPropertyInfo injectProperty)
        {
            return new InjectTypeInfo.InjectMemberInfo(
                GetSetter(parentType, injectProperty.PropertyInfo), injectProperty.InjectableInfo);
        }

        static ZenFactoryMethod TryCreateFactoryMethod(
            Type type, ReflectionTypeInfo.InjectConstructorInfo reflectionInfo)
        {
#if !NOT_UNITY3D
            if (type.DerivesFromOrEqual<Component>())
            {
                return null;
            }
#endif

            if (type.IsAbstract())
            {
                Assert.That(reflectionInfo.Parameters.IsEmpty());
                return null;
            }

            var constructor = reflectionInfo.ConstructorInfo;

            var factoryMethod = TryCreateFactoryMethodCompiledLambdaExpression(type, constructor);

            if (factoryMethod == null)
            {
                if (constructor == null)
                {
                    // No choice in this case except to use the slow Activator.CreateInstance
                    // as far as I know
                    // This should be rare though and only seems to occur when instantiating
                    // structs on platforms that don't support lambda expressions
                    // Non-structs should always have a default constructor
                    factoryMethod = args =>
                    {
                        Assert.That(args.Length == 0);
                        return Activator.CreateInstance(type, new object[0]);
                    };
                }
                else
                {
                    factoryMethod = constructor.Invoke;
                }
            }

            return factoryMethod;
        }

        static ZenFactoryMethod TryCreateFactoryMethodCompiledLambdaExpression(
            Type type, ConstructorInfo constructor)
        {
#if NET_4_6 && !ENABLE_IL2CPP && !ZEN_DO_NOT_USE_COMPILED_EXPRESSIONS

            if (type.ContainsGenericParameters)
            {
                return null;
            }

            ParameterExpression param = Expression.Parameter(typeof(object[]));

            if (constructor == null)
            {
                return Expression.Lambda<ZenFactoryMethod>(
                    Expression.Convert(
                        Expression.New(type), typeof(object)), param).Compile();
            }

            ParameterInfo[] par = constructor.GetParameters();
            Expression[] args = new Expression[par.Length];

            for (int i = 0; i != par.Length; ++i)
            {
                args[i] = Expression.Convert(
                    Expression.ArrayIndex(
                        param, Expression.Constant(i)), par[i].ParameterType);
            }

            return Expression.Lambda<ZenFactoryMethod>(
                Expression.Convert(
                    Expression.New(constructor, args), typeof(object)), param).Compile();
#else
            return null;
#endif
        }

        static ZenInjectMethod TryCreateActionForMethod(MethodInfo methodInfo)
        {
#if NET_4_6 && !ENABLE_IL2CPP && !ZEN_DO_NOT_USE_COMPILED_EXPRESSIONS

            if (methodInfo.DeclaringType.ContainsGenericParameters)
            {
                return null;
            }

            ParameterInfo[] par = methodInfo.GetParameters();

            if (par.Any(x => x.ParameterType.ContainsGenericParameters))
            {
                return null;
            }

            Expression[] args = new Expression[par.Length];
            ParameterExpression argsParam = Expression.Parameter(typeof(object[]));
            ParameterExpression instanceParam = Expression.Parameter(typeof(object));

            for (int i = 0; i != par.Length; ++i)
            {
                args[i] = Expression.Convert(
                    Expression.ArrayIndex(
                        argsParam, Expression.Constant(i)), par[i].ParameterType);
            }

            return Expression.Lambda<ZenInjectMethod>(
                Expression.Call(
                    Expression.Convert(instanceParam, methodInfo.DeclaringType), methodInfo, args),
                instanceParam, argsParam).Compile();
#else
            return null;
#endif
        }

#if !(UNITY_WSA && ENABLE_DOTNET) || UNITY_EDITOR
        static IEnumerable<FieldInfo> GetAllFields(Type t, BindingFlags flags)
        {
            if (t == null)
            {
                return Enumerable.Empty<FieldInfo>();
            }

            return t.GetFields(flags).Concat(GetAllFields(t.BaseType, flags)).Distinct();
        }

        static ZenMemberSetterMethod GetOnlyPropertySetter(
            Type parentType,
            string propertyName)
        {
            Assert.That(parentType != null);
            Assert.That(!string.IsNullOrEmpty(propertyName));

            var allFields = GetAllFields(
                parentType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).ToList();

            var writeableFields = allFields.Where(f => f.Name == string.Format("<" + propertyName + ">k__BackingField", propertyName)).ToList();

            if (!writeableFields.Any())
            {
                throw new ZenjectException(string.Format(
                    "Can't find backing field for get only property {0} on {1}.\r\n{2}",
                    propertyName, parentType.FullName, string.Join(";", allFields.Select(f => f.Name).ToArray())));
            }

            return (injectable, value) => writeableFields.ForEach(f => f.SetValue(injectable, value));
        }
#endif

        static ZenMemberSetterMethod GetSetter(Type parentType, MemberInfo memInfo)
        {
            var setterMethod = TryGetSetterAsCompiledExpression(parentType, memInfo);

            if (setterMethod != null)
            {
                return setterMethod;
            }

            var fieldInfo = memInfo as FieldInfo;
            var propInfo = memInfo as PropertyInfo;

            if (fieldInfo != null)
            {
                return ((injectable, value) => fieldInfo.SetValue(injectable, value));
            }

            Assert.IsNotNull(propInfo);

#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return ((object injectable, object value) => propInfo.SetValue(injectable, value, null));
#else
            if (propInfo.CanWrite)
            {
                return ((injectable, value) => propInfo.SetValue(injectable, value, null));
            }

            return GetOnlyPropertySetter(parentType, propInfo.Name);
#endif
        }

        static ZenMemberSetterMethod TryGetSetterAsCompiledExpression(Type parentType, MemberInfo memInfo)
        {
#if NET_4_6 && !ENABLE_IL2CPP && !ZEN_DO_NOT_USE_COMPILED_EXPRESSIONS

            if (parentType.ContainsGenericParameters)
            {
                return null;
            }

            var fieldInfo = memInfo as FieldInfo;
            var propInfo = memInfo as PropertyInfo;

            // It seems that for readonly fields, we have to use the slower approach below
            // As discussed here: https://www.productiverage.com/trying-to-set-a-readonly-autoproperty-value-externally-plus-a-little-benchmarkdotnet
            // We have to skip value types because those can only be set by reference using an lambda expression
            if (!parentType.IsValueType() && (fieldInfo == null || !fieldInfo.IsInitOnly) && (propInfo == null || propInfo.CanWrite))
            {
                Type memberType = fieldInfo != null
                    ? fieldInfo.FieldType : propInfo.PropertyType;

                var typeParam = Expression.Parameter(typeof(object));
                var valueParam = Expression.Parameter(typeof(object));

                return Expression.Lambda<ZenMemberSetterMethod>(
                    Expression.Assign(
                        Expression.MakeMemberAccess(Expression.Convert(typeParam, parentType), memInfo),
                        Expression.Convert(valueParam, memberType)),
                        typeParam, valueParam).Compile();
            }
#endif

            return null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionInfoTypeInfoConverter.cs.meta
================================================
fileFormatVersion: 2
guid: e36c348f078bc444fa1e5b22aca27bad
timeCreated: 1536916212
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionTypeInfo.cs
================================================
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Zenject.Internal
{
    [NoReflectionBaking]
    public class ReflectionTypeInfo
    {
        public readonly Type Type;
        public readonly Type BaseType;
        public readonly List<InjectPropertyInfo> InjectProperties;
        public readonly List<InjectFieldInfo> InjectFields;
        public readonly InjectConstructorInfo InjectConstructor;
        public readonly List<InjectMethodInfo> InjectMethods;

        public ReflectionTypeInfo(
            Type type,
            Type baseType,
            InjectConstructorInfo injectConstructor,
            List<InjectMethodInfo> injectMethods,
            List<InjectFieldInfo> injectFields,
            List<InjectPropertyInfo> injectProperties)
        {
            Type = type;
            BaseType = baseType;
            InjectFields = injectFields;
            InjectConstructor = injectConstructor;
            InjectMethods = injectMethods;
            InjectProperties = injectProperties;
        }

        [NoReflectionBaking]
        public class InjectFieldInfo
        {
            public readonly FieldInfo FieldInfo;
            public readonly InjectableInfo InjectableInfo;

            public InjectFieldInfo(
                FieldInfo fieldInfo,
                InjectableInfo injectableInfo)
            {
                InjectableInfo = injectableInfo;
                FieldInfo = fieldInfo;
            }
        }

        [NoReflectionBaking]
        public class InjectParameterInfo
        {
            public readonly ParameterInfo ParameterInfo;
            public readonly InjectableInfo InjectableInfo;

            public InjectParameterInfo(
                ParameterInfo parameterInfo,
                InjectableInfo injectableInfo)
            {
                InjectableInfo = injectableInfo;
                ParameterInfo = parameterInfo;
            }
        }

        [NoReflectionBaking]
        public class InjectPropertyInfo
        {
            public readonly PropertyInfo PropertyInfo;
            public readonly InjectableInfo InjectableInfo;

            public InjectPropertyInfo(
                PropertyInfo propertyInfo,
                InjectableInfo injectableInfo)
            {
                InjectableInfo = injectableInfo;
                PropertyInfo = propertyInfo;
            }
        }

        [NoReflectionBaking]
        public class InjectMethodInfo
        {
            public readonly MethodInfo MethodInfo;
            public readonly List<InjectParameterInfo> Parameters;

            public InjectMethodInfo(
                MethodInfo methodInfo,
                List<InjectParameterInfo> parameters)
            {
                MethodInfo = methodInfo;
                Parameters = parameters;
            }
        }

        [NoReflectionBaking]
        public class InjectConstructorInfo
        {
            public readonly ConstructorInfo ConstructorInfo;
            public readonly List<InjectParameterInfo> Parameters;

            public InjectConstructorInfo(
                ConstructorInfo constructorInfo,
                List<InjectParameterInfo> parameters)
            {
                ConstructorInfo = constructorInfo;
                Parameters = parameters;
            }
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionTypeInfo.cs.meta
================================================
fileFormatVersion: 2
guid: 5490313f008f146458b6228165838735
timeCreated: 1536916212
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionUtil.cs
================================================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace ModestTree
{
    public static class ReflectionUtil
    {
        public static Array CreateArray(Type elementType, List<object> instances)
        {
            var array = Array.CreateInstance(elementType, instances.Count);

            for (int i = 0; i < instances.Count; i++)
            {
                var instance = instances[i];

                if (instance != null)
                {
                    Assert.That(instance.GetType().DerivesFromOrEqual(elementType),
                        "Wrong type when creating array, expected something assignable from '"+ elementType +"', but found '" + instance.GetType() + "'");
                }

                array.SetValue(instance, i);
            }

            return array;
        }

        public static IList CreateGenericList(Type elementType, List<object> instances)
        {
            var genericType = typeof(List<>).MakeGenericType(elementType);

            var list = (IList)Activator.CreateInstance(genericType);

            for (int i = 0; i < instances.Count; i++)
            {
                var instance = instances[i];

                if (instance != null)
                {
                    Assert.That(instance.GetType().DerivesFromOrEqual(elementType),
                        "Wrong type when creating generic list, expected something assignable from '"+ elementType +"', but found '" + instance.GetType() + "'");
                }

                list.Add(instance);
            }

            return list;
        }

        public static string ToDebugString(this MethodInfo method)
        {
            return "{0}.{1}".Fmt(method.DeclaringType.PrettyName(), method.Name);
        }

        public static string ToDebugString(this Action action)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1>(this Action<TParam1> action)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2>(this Action<TParam1, TParam2> action)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3>(this Action<TParam1, TParam2, TParam3> action)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3, TParam4>(this Action<TParam1, TParam2, TParam3, TParam4> action)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3, TParam4, TParam5>(this
#if NET_4_6
            Action<TParam1, TParam2, TParam3, TParam4, TParam5> action)
#else
            ModestTree.Util.Action<TParam1, TParam2, TParam3, TParam4, TParam5> action)
#endif
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6>(this
#if NET_4_6
            Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> action)
#else
            ModestTree.Util.Action<TParam1, TParam2, TParam3, TParam4, TParam5, TParam6> action)
#endif
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return action.ToString();
#else
            return action.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1>(this Func<TParam1> func)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return func.ToString();
#else
            return func.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2>(this Func<TParam1, TParam2> func)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return func.ToString();
#else
            return func.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3>(this Func<TParam1, TParam2, TParam3> func)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return func.ToString();
#else
            return func.Method.ToDebugString();
#endif
        }

        public static string ToDebugString<TParam1, TParam2, TParam3, TParam4>(this Func<TParam1, TParam2, TParam3, TParam4> func)
        {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return func.ToString();
#else
            return func.Method.ToDebugString();
#endif
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ReflectionUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 7c74b10dac7e87e4095f8e3157eb040d
timeCreated: 1520399530
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/TypeAnalyzer.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using ModestTree;
using Zenject.Internal;

namespace Zenject
{
    public delegate InjectTypeInfo ZenTypeInfoGetter();

    public enum ReflectionBakingCoverageModes
    {
        FallbackToDirectReflection,
        NoCheckAssumeFullCoverage,
        FallbackToDirectReflectionWithWarning
    }

    public static class TypeAnalyzer
    {
        static Dictionary<Type, InjectTypeInfo> _typeInfo = new Dictionary<Type, InjectTypeInfo>();

        // We store this separately from InjectTypeInfo because this flag is needed for contract
        // types whereas InjectTypeInfo is only needed for types that are instantiated, and
        // we want to minimize the types that generate InjectTypeInfo for
        static Dictionary<Type, bool> _allowDuringValidation = new Dictionary<Type, bool>();

        // Use double underscores for generated methods since this is also what the C# compiler does
        // for things like anonymous methods
        public const string ReflectionBakingGetInjectInfoMethodName = "__zenCreateInjectTypeInfo";
        public const string ReflectionBakingFactoryMethodName = "__zenCreate";
        public const string ReflectionBakingInjectMethodPrefix = "__zenInjectMethod";
        public const string ReflectionBakingFieldSetterPrefix = "__zenFieldSetter";
        public const string ReflectionBakingPropertySetterPrefix = "__zenPropertySetter";

        public static ReflectionBakingCoverageModes ReflectionBakingCoverageMode
        {
            get; set;
        }

        public static bool ShouldAllowDuringValidation<T>()
        {
            return ShouldAllowDuringValidation(typeof(T));
        }

        public static bool ShouldAllowDuringValidation(Type type)
        {
            bool shouldAllow;

            if (!_allowDuringValidation.TryGetValue(type, out shouldAllow))
            {
                shouldAllow = ShouldAllowDuringValidationInternal(type);
                _allowDuringValidation.Add(type, shouldAllow);
            }

            return shouldAllow;
        }

        static bool ShouldAllowDuringValidationInternal(Type type)
        {
            // During validation, do not instantiate or inject anything except for
            // Installers, IValidatable's, or types marked with attribute ZenjectAllowDuringValidation
            // You would typically use ZenjectAllowDuringValidation attribute for data that you
            // inject into factories

            if (type.DerivesFrom<IInstaller>() || type.DerivesFrom<IValidatable>())
            {
                return true;
            }

#if !NOT_UNITY3D
            if (type.DerivesFrom<Context>())
            {
                return true;
            }
#endif

#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            return type.GetTypeInfo().GetCustomAttribute<ZenjectAllowDuringValidationAttribute>() != null;
#else
            return type.HasAttribute<ZenjectAllowDuringValidationAttribute>();
#endif
        }

        public static bool HasInfo<T>()
        {
            return HasInfo(typeof(T));
        }

        public static bool HasInfo(Type type)
        {
            return TryGetInfo(type) != null;
        }

        public static InjectTypeInfo GetInfo<T>()
        {
            return GetInfo(typeof(T));
        }

        public static InjectTypeInfo GetInfo(Type type)
        {
            var info = TryGetInfo(type);
            Assert.IsNotNull(info, "Unable to get type info for type '{0}'", type);
            return info;
        }

        public static InjectTypeInfo TryGetInfo<T>()
        {
            return TryGetInfo(typeof(T));
        }

        public static InjectTypeInfo TryGetInfo(Type type)
        {
            InjectTypeInfo info;

#if ZEN_MULTITHREADING
            lock (_typeInfo)
#endif
            {
                if (_typeInfo.TryGetValue(type, out info))
                {
                    return info;
                }
            }

#if UNITY_EDITOR
            using (ProfileBlock.Start("Zenject Reflection"))
#endif
            {
                info = GetInfoInternal(type);
            }

            if (info != null)
            {
                Assert.IsEqual(info.Type, type);
                Assert.IsNull(info.BaseTypeInfo);

                var baseType = type.BaseType();

                if (baseType != null && !ShouldSkipTypeAnalysis(baseType))
                {
                    info.BaseTypeInfo = TryGetInfo(baseType);
                }
            }

#if ZEN_MULTITHREADING
            lock (_typeInfo)
#endif
            {
                _typeInfo[type] = info;
            }

            return info;
        }

        static InjectTypeInfo GetInfoInternal(Type type)
        {
            if (ShouldSkipTypeAnalysis(type))
            {
                return null;
            }

#if ZEN_INTERNAL_PROFILING
            // Make sure that the static constructor logic doesn't inflate our profile measurements
            using (ProfileTimers.CreateTimedBlock("User Code"))
            {
                RuntimeHelpers.RunClassConstructor(type.TypeHandle);
            }
#endif

#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Type Analysis - Calling Baked Reflection Getter"))
#endif
            {
                var getInfoMethod = type.GetMethod(
                    ReflectionBakingGetInjectInfoMethodName,
                    BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public);

                if (getInfoMethod != null)
                {
#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
                    var infoGetter = (ZenTypeInfoGetter)getInfoMethod.CreateDelegate(
                        typeof(ZenTypeInfoGetter), null);
#else
                    var infoGetter = ((ZenTypeInfoGetter)Delegate.CreateDelegate(
                        typeof(ZenTypeInfoGetter), getInfoMethod));
#endif

                    return infoGetter();
                }
            }

            if (ReflectionBakingCoverageMode == ReflectionBakingCoverageModes.NoCheckAssumeFullCoverage)
            {
                // If we are confident that the reflection baking supplies all the injection information,
                // then we can avoid the costs of doing reflection on types that were not covered
                // by the baking
                return null;
            }

#if !(UNITY_WSA && ENABLE_DOTNET) || UNITY_EDITOR
            if (ReflectionBakingCoverageMode == ReflectionBakingCoverageModes.FallbackToDirectReflectionWithWarning)
            {
                Log.Warn("No reflection baking information found for type '{0}' - using more costly direct reflection instead", type);
            }
#endif

#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Type Analysis - Direct Reflection"))
#endif
            {
                return CreateTypeInfoFromReflection(type);
            }
        }

        public static bool ShouldSkipTypeAnalysis(Type type)
        {
            return type == null || type.IsEnum() || type.IsArray || type.IsInterface()
                || type.ContainsGenericParameters() || IsStaticType(type)
                || type == typeof(object);
        }

        static bool IsStaticType(Type type)
        {
            // Apparently this is unique to static classes
            return type.IsAbstract() && type.IsSealed();
        }

        static InjectTypeInfo CreateTypeInfoFromReflection(Type type)
        {
            var reflectionInfo = ReflectionTypeAnalyzer.GetReflectionInfo(type);

            var injectConstructor = ReflectionInfoTypeInfoConverter.ConvertConstructor(
                reflectionInfo.InjectConstructor, type);

            var injectMethods = reflectionInfo.InjectMethods.Select(
                ReflectionInfoTypeInfoConverter.ConvertMethod).ToArray();

            var memberInfos = reflectionInfo.InjectFields.Select(
                x => ReflectionInfoTypeInfoConverter.ConvertField(type, x)).Concat(
                    reflectionInfo.InjectProperties.Select(
                        x => ReflectionInfoTypeInfoConverter.ConvertProperty(type, x))).ToArray();

            return new InjectTypeInfo(
                type, injectConstructor, injectMethods, memberInfos);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/TypeAnalyzer.cs.meta
================================================
fileFormatVersion: 2
guid: 7359cd850f5a96d47ad4606d14dac326
timeCreated: 1461708051
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/UnityUtil.cs
================================================
#if !NOT_UNITY3D

using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace ModestTree.Util
{
    public static class UnityUtil
    {
        public static IEnumerable<Scene> AllScenes
        {
            get
            {
                for (int i = 0; i < SceneManager.sceneCount; i++)
                {
                    yield return SceneManager.GetSceneAt(i);
                }
            }
        }

        public static IEnumerable<Scene> AllLoadedScenes
        {
            get { return AllScenes.Where(scene => scene.isLoaded); }
        }

        public static bool IsAltKeyDown
        {
            get { return Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt); }
        }

        public static bool IsControlKeyDown
        {
            get { return Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl); }
        }

        public static bool IsShiftKeyDown
        {
            get { return Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift); }
        }

        public static bool WasShiftKeyJustPressed
        {
            get { return Input.GetKeyDown(KeyCode.LeftShift) || Input.GetKeyDown(KeyCode.RightShift); }
        }

        public static bool WasAltKeyJustPressed
        {
            get { return Input.GetKeyDown(KeyCode.LeftAlt) || Input.GetKeyDown(KeyCode.RightAlt); }
        }

        public static int GetDepthLevel(Transform transform)
        {
            if (transform == null)
            {
                return 0;
            }

            return 1 + GetDepthLevel(transform.parent);
        }

        public static GameObject GetRootParentOrSelf(GameObject gameObject)
        {
            return GetParentsAndSelf(gameObject.transform).Select(x => x.gameObject).LastOrDefault();
        }

        public static IEnumerable<Transform> GetParents(Transform transform)
        {
            if (transform == null)
            {
                yield break;
            }

            foreach (var ancestor in GetParentsAndSelf(transform.parent))
            {
                yield return ancestor;
            }
        }

        public static IEnumerable<Transform> GetParentsAndSelf(Transform transform)
        {
            if (transform == null)
            {
                yield break;
            }

            yield return transform;

            foreach (var ancestor in GetParentsAndSelf(transform.parent))
            {
                yield return ancestor;
            }
        }

        public static IEnumerable<Component> GetComponentsInChildrenTopDown(GameObject gameObject, bool includeInactive)
        {
            return gameObject.GetComponentsInChildren<Component>(includeInactive)
                .OrderBy(x =>
                    x == null ? int.MinValue : GetDepthLevel(x.transform));
        }

        public static IEnumerable<Component> GetComponentsInChildrenBottomUp(GameObject gameObject, bool includeInactive)
        {
            return gameObject.GetComponentsInChildren<Component>(includeInactive)
                .OrderByDescending(x =>
                    x == null ? int.MinValue : GetDepthLevel(x.transform));
        }

        public static IEnumerable<GameObject> GetDirectChildrenAndSelf(GameObject obj)
        {
            yield return obj;

            foreach (Transform child in obj.transform)
            {
                yield return child.gameObject;
            }
        }

        public static IEnumerable<GameObject> GetDirectChildren(GameObject obj)
        {
            foreach (Transform child in obj.transform)
            {
                yield return child.gameObject;
            }
        }

        public static IEnumerable<GameObject> GetAllGameObjects()
        {
            return GameObject.FindObjectsOfType<Transform>().Select(x => x.gameObject);
        }

        public static List<GameObject> GetAllRootGameObjects()
        {
            return GetAllGameObjects().Where(x => x.transform.parent == null).ToList();
        }
    }
}
#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/UnityUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 136cacfad8fe5404aad05dda29a777e4
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ValidationUtil.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;

namespace Zenject
{
    public static class ValidationUtil
    {
        // This method can be used during validation for cases where we need to pass arguments
        public static List<TypeValuePair> CreateDefaultArgs(params Type[] argTypes)
        {
            return argTypes.Select(x => new TypeValuePair(x, x.GetDefaultValue())).ToList();
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ValidationUtil.cs.meta
================================================
fileFormatVersion: 2
guid: 018820e0bcd9a4049a305127c0cf1407
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenAutoInjecter.cs
================================================
using ModestTree;
using UnityEngine;

namespace Zenject
{
    public class ZenAutoInjecter : MonoBehaviour
    {
        [SerializeField]
        ContainerSources _containerSource = ContainerSources.SearchHierarchy;

        bool _hasInjected;

        public ContainerSources ContainerSource
        {
            get { return _containerSource; }
            set { _containerSource = value; }
        }

        // Make sure they don't cause injection to happen twice
        [Inject]
        public void Construct()
        {
            if (!_hasInjected)
            {
                throw Assert.CreateException(
                    "ZenAutoInjecter was injected!  Do not use ZenAutoInjecter for objects that are instantiated through zenject or which exist in the initial scene hierarchy");
            }
        }

        public void Awake()
        {
            _hasInjected = true;
            LookupContainer().InjectGameObject(gameObject);
        }

        DiContainer LookupContainer()
        {
            if (_containerSource == ContainerSources.ProjectContext)
            {
                return ProjectContext.Instance.Container;
            }

            if (_containerSource == ContainerSources.SceneContext)
            {
                return GetContainerForCurrentScene();
            }

            Assert.IsEqual(_containerSource, ContainerSources.SearchHierarchy);

            var parentContext = transform.GetComponentInParent<Context>();

            if (parentContext != null)
            {
                return parentContext.Container;
            }

            return GetContainerForCurrentScene();
        }

        DiContainer GetContainerForCurrentScene()
        {
            return ProjectContext.Instance.Container.Resolve<SceneContextRegistry>()
                .GetContainerForScene(gameObject.scene);
        }

        public enum ContainerSources
        {
            SceneContext,
            ProjectContext,
            SearchHierarchy
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenAutoInjecter.cs.meta
================================================
fileFormatVersion: 2
guid: 717a02054ef2699498e6bd4234fd7995
timeCreated: 1510660712
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenjectException.cs
================================================
using System;
using System.Diagnostics;

namespace Zenject
{
    [DebuggerStepThrough]
    [NoReflectionBaking]
    public class ZenjectException : Exception
    {
        public ZenjectException(string message)
            : base(message)
        {
        }

        public ZenjectException(
            string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenjectException.cs.meta
================================================
fileFormatVersion: 2
guid: 60bbf1e064ae9674185f3f301957c914
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenjectSceneLoader.cs
================================================
#if !NOT_UNITY3D

using System;
using ModestTree;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Zenject
{
    public enum LoadSceneRelationship
    {
        // This will use the ProjectContext container as parent for the new scene
        // This is similar to just running the new scene normally
        None,
        // This will use current scene as parent for the new scene
        // This will allow the new scene to refer to dependencies in the current scene
        Child,
        // This will use the parent of the current scene as the parent for the next scene
        // In most cases this will be the same as None
        Sibling
    }

    public class ZenjectSceneLoader
    {
        readonly ProjectKernel _projectKernel;
        readonly DiContainer _sceneContainer;

        public ZenjectSceneLoader(
            [InjectOptional]
            SceneContext sceneRoot,
            ProjectKernel projectKernel)
        {
            _projectKernel = projectKernel;
            _sceneContainer = sceneRoot == null ? null : sceneRoot.Container;
        }

        public void LoadScene(
            string sceneName,
            LoadSceneMode loadMode = LoadSceneMode.Single,
            Action<DiContainer> extraBindings = null,
            LoadSceneRelationship containerMode = LoadSceneRelationship.None,
            Action<DiContainer> extraBindingsLate = null)
        {
            PrepareForLoadScene(loadMode, extraBindings, extraBindingsLate, containerMode);

            Assert.That(Application.CanStreamedLevelBeLoaded(sceneName),
                "Unable to load scene '{0}'", sceneName);

            SceneManager.LoadScene(sceneName, loadMode);

            // It would be nice here to actually verify that the new scene has a SceneContext
            // if we have extra binding hooks, or LoadSceneRelationship != None, but
            // we can't do that in this case since the scene isn't loaded until the next frame
        }

            public AsyncOperation LoadSceneAsync(
            string sceneName,
            LoadSceneMode loadMode = LoadSceneMode.Single,
            Action<DiContainer> extraBindings = null,
            LoadSceneRelationship containerMode = LoadSceneRelationship.None,
            Action<DiContainer> extraBindingsLate = null)
        {
            PrepareForLoadScene(loadMode, extraBindings, extraBindingsLate, containerMode);

            Assert.That(Application.CanStreamedLevelBeLoaded(sceneName),
                "Unable to load scene '{0}'", sceneName);

            return SceneManager.LoadSceneAsync(sceneName, loadMode);
        }

        void PrepareForLoadScene(
            LoadSceneMode loadMode,
            Action<DiContainer> extraBindings,
            Action<DiContainer> extraBindingsLate,
            LoadSceneRelationship containerMode)
        {
            if (loadMode == LoadSceneMode.Single)
            {
                Assert.IsEqual(containerMode, LoadSceneRelationship.None);

                // Here we explicitly unload all existing scenes rather than relying on Unity to
                // do this for us.  The reason we do this is to ensure a deterministic destruction
                // order for everything in the scene and in the container.
                // See comment at ProjectKernel.OnApplicationQuit for more details
                _projectKernel.ForceUnloadAllScenes();
            }

            if (containerMode == LoadSceneRelationship.None)
            {
                SceneContext.ParentContainers = null;
            }
            else if (containerMode == LoadSceneRelationship.Child)
            {
                if (_sceneContainer == null)
                {
                    SceneContext.ParentContainers = null;
                }
                else
                {
                    SceneContext.ParentContainers = new[] { _sceneContainer };
                }
            }
            else
            {
                Assert.IsNotNull(_sceneContainer,
                    "Cannot use LoadSceneRelationship.Sibling when loading scenes from ProjectContext");
                Assert.IsEqual(containerMode, LoadSceneRelationship.Sibling);
                SceneContext.ParentContainers = _sceneContainer.ParentContainers;
            }

            SceneContext.ExtraBindingsInstallMethod = extraBindings;
            SceneContext.ExtraBindingsLateInstallMethod = extraBindingsLate;
        }

        public void LoadScene(
            int sceneIndex,
            LoadSceneMode loadMode = LoadSceneMode.Single,
            Action<DiContainer> extraBindings = null,
            LoadSceneRelationship containerMode = LoadSceneRelationship.None,
            Action<DiContainer> extraBindingsLate = null)
        {
            PrepareForLoadScene(loadMode, extraBindings, extraBindingsLate, containerMode);

            Assert.That(Application.CanStreamedLevelBeLoaded(sceneIndex),
                "Unable to load scene '{0}'", sceneIndex);

            SceneManager.LoadScene(sceneIndex, loadMode);

            // It would be nice here to actually verify that the new scene has a SceneContext
            // if we have extra binding hooks, or LoadSceneRelationship != None, but
            // we can't do that in this case since the scene isn't loaded until the next frame
        }

        public AsyncOperation LoadSceneAsync(
            int sceneIndex,
            LoadSceneMode loadMode = LoadSceneMode.Single,
            Action<DiContainer> extraBindings = null,
            LoadSceneRelationship containerMode = LoadSceneRelationship.None,
            Action<DiContainer> extraBindingsLate = null)
        {
            PrepareForLoadScene(loadMode, extraBindings, extraBindingsLate, containerMode);

            Assert.That(Application.CanStreamedLevelBeLoaded(sceneIndex),
                "Unable to load scene '{0}'", sceneIndex);

            return SceneManager.LoadSceneAsync(sceneIndex, loadMode);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenjectSceneLoader.cs.meta
================================================
fileFormatVersion: 2
guid: 097ddf2608210fe44a9d215a1721d857
timeCreated: 1461708048
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenPools.cs
================================================
using System;
using System.Collections.Generic;

namespace Zenject.Internal
{
    public static class ZenPools
    {
#if ZEN_INTERNAL_NO_POOLS
        public static InjectContext SpawnInjectContext(DiContainer container, Type memberType)
        {
            return new InjectContext(container, memberType);
        }

        public static void DespawnInjectContext(InjectContext context)
        {
        }

        public static List<T> SpawnList<T>()
        {
            return new List<T>();
        }

        public static void DespawnList<T>(List<T> list)
        {
        }

        public static void DespawnArray<T>(T[] arr)
        {
        }

        public static T[] SpawnArray<T>(int length)
        {
            return new T[length];
        }

        public static HashSet<T> SpawnHashSet<T>()
        {
            return new HashSet<T>();
        }

        public static Dictionary<TKey, TValue> SpawnDictionary<TKey, TValue>()
        {
            return new Dictionary<TKey, TValue>();
        }

        public static void DespawnDictionary<TKey, TValue>(Dictionary<TKey, TValue> dictionary)
        {
        }

        public static void DespawnHashSet<T>(HashSet<T> set)
        {
        }

        public static LookupId SpawnLookupId(IProvider provider, BindingId bindingId)
        {
            return new LookupId(provider, bindingId);
        }

        public static void DespawnLookupId(LookupId lookupId)
        {
        }

        public static BindInfo SpawnBindInfo()
        {
            return new BindInfo();
        }

        public static void DespawnBindInfo(BindInfo bindInfo)
        {
        }

        public static BindStatement SpawnStatement()
        {
            return new BindStatement();
        }

        public static void DespawnStatement(BindStatement statement)
        {
        }
#else
        static readonly StaticMemoryPool<InjectContext> _contextPool = new StaticMemoryPool<InjectContext>();
        static readonly StaticMemoryPool<LookupId> _lookupIdPool = new StaticMemoryPool<LookupId>();
        static readonly StaticMemoryPool<BindInfo> _bindInfoPool = new StaticMemoryPool<BindInfo>();
        static readonly StaticMemoryPool<BindStatement> _bindStatementPool = new StaticMemoryPool<BindStatement>();

        public static HashSet<T> SpawnHashSet<T>()
        {
            return HashSetPool<T>.Instance.Spawn();
        }

        public static Dictionary<TKey, TValue> SpawnDictionary<TKey, TValue>()
        {
            return DictionaryPool<TKey, TValue>.Instance.Spawn();
        }

        public static BindStatement SpawnStatement()
        {
            return _bindStatementPool.Spawn();
        }

        public static void DespawnStatement(BindStatement statement)
        {
            statement.Reset();
            _bindStatementPool.Despawn(statement);
        }

        public static BindInfo SpawnBindInfo()
        {
            return _bindInfoPool.Spawn();
        }

        public static void DespawnBindInfo(BindInfo bindInfo)
        {
            bindInfo.Reset();
            _bindInfoPool.Despawn(bindInfo);
        }

        public static void DespawnDictionary<TKey, TValue>(Dictionary<TKey, TValue> dictionary)
        {
            DictionaryPool<TKey, TValue>.Instance.Despawn(dictionary);
        }

        public static void DespawnHashSet<T>(HashSet<T> set)
        {
            HashSetPool<T>.Instance.Despawn(set);
        }

        public static LookupId SpawnLookupId(IProvider provider, BindingId bindingId)
        {
            var lookupId = _lookupIdPool.Spawn();

            lookupId.Provider = provider;
            lookupId.BindingId = bindingId;

            return lookupId;
        }

        public static void DespawnLookupId(LookupId lookupId)
        {
            lookupId.Reset();
            _lookupIdPool.Despawn(lookupId);
        }

        public static List<T> SpawnList<T>()
        {
            return ListPool<T>.Instance.Spawn();
        }

        public static void DespawnList<T>(List<T> list)
        {
            ListPool<T>.Instance.Despawn(list);
        }

        public static void DespawnArray<T>(T[] arr)
        {
            ArrayPool<T>.GetPool(arr.Length).Despawn(arr);
        }

        public static T[] SpawnArray<T>(int length)
        {
            return ArrayPool<T>.GetPool(length).Spawn();
        }

        public static InjectContext SpawnInjectContext(DiContainer container, Type memberType)
        {
            var context = _contextPool.Spawn();

            context.Container = container;
            context.MemberType = memberType;

            return context;
        }

        public static void DespawnInjectContext(InjectContext context)
        {
            context.Reset();
            _contextPool.Despawn(context);
        }
#endif

        public static InjectContext SpawnInjectContext(
            DiContainer container, InjectableInfo injectableInfo, InjectContext currentContext,
            object targetInstance, Type targetType, object concreteIdentifier)
        {
            var context = SpawnInjectContext(container, injectableInfo.MemberType);

            context.ObjectType = targetType;
            context.ParentContext = currentContext;
            context.ObjectInstance = targetInstance;
            context.Identifier = injectableInfo.Identifier;
            context.MemberName = injectableInfo.MemberName;
            context.Optional = injectableInfo.Optional;
            context.SourceType = injectableInfo.SourceType;
            context.FallBackValue = injectableInfo.DefaultValue;
            context.ConcreteIdentifier = concreteIdentifier;

            return context;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenPools.cs.meta
================================================
fileFormatVersion: 2
guid: 14ff296505fe79448b0c79ec09977477
timeCreated: 1535860932
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenReflectionTypeAnalyzer.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using ModestTree;
#if !NOT_UNITY3D
using UnityEngine;
#endif

namespace Zenject.Internal
{
    public static class ReflectionTypeAnalyzer
    {
        static readonly HashSet<Type> _injectAttributeTypes;

        static ReflectionTypeAnalyzer()
        {
            _injectAttributeTypes = new HashSet<Type>();
            _injectAttributeTypes.Add(typeof(InjectAttributeBase));
        }

        public static void AddCustomInjectAttribute<T>()
            where T : Attribute
        {
            AddCustomInjectAttribute(typeof(T));
        }

        public static void AddCustomInjectAttribute(Type type)
        {
            Assert.That(type.DerivesFrom<Attribute>());
            _injectAttributeTypes.Add(type);
        }

        public static ReflectionTypeInfo GetReflectionInfo(Type type)
        {
            Assert.That(!type.IsEnum(), "Tried to analyze enum type '{0}'.  This is not supported", type);
            Assert.That(!type.IsArray, "Tried to analyze array type '{0}'.  This is not supported", type);

            var baseType = type.BaseType();

            if (baseType == typeof(object))
            {
                baseType = null;
            }

            return new ReflectionTypeInfo(
                type, baseType, GetConstructorInfo(type), GetMethodInfos(type),
                GetFieldInfos(type), GetPropertyInfos(type));
        }

        static List<ReflectionTypeInfo.InjectPropertyInfo> GetPropertyInfos(Type type)
        {
            return type.DeclaredInstanceProperties()
                .Where(x => _injectAttributeTypes.Any(a => x.HasAttribute(a)))
                .Select(x => new ReflectionTypeInfo.InjectPropertyInfo(
                    x, GetInjectableInfoForMember(type, x))).ToList();
        }

        static List<ReflectionTypeInfo.InjectFieldInfo> GetFieldInfos(Type type)
        {
            return type.DeclaredInstanceFields()
                .Where(x => _injectAttributeTypes.Any(a => x.HasAttribute(a)))
                .Select(x => new ReflectionTypeInfo.InjectFieldInfo(
                    x, GetInjectableInfoForMember(type, x)))
                .ToList();
        }

        static List<ReflectionTypeInfo.InjectMethodInfo> GetMethodInfos(Type type)
        {
            var injectMethodInfos = new List<ReflectionTypeInfo.InjectMethodInfo>();

            // Note that unlike with fields and properties we use GetCustomAttributes
            // This is so that we can ignore inherited attributes, which is necessary
            // otherwise a base class method marked with [Inject] would cause all overridden
            // derived methods to be added as well
            var methodInfos = type.DeclaredInstanceMethods()
                .Where(x => _injectAttributeTypes.Any(a => x.GetCustomAttributes(a, false).Any())).ToList();

            for (int i = 0; i < methodInfos.Count; i++)
            {
                var methodInfo = methodInfos[i];
                var injectAttr = methodInfo.AllAttributes<InjectAttributeBase>().SingleOrDefault();

                if (injectAttr != null)
                {
                    Assert.That(!injectAttr.Optional && injectAttr.Id == null && injectAttr.Source == InjectSources.Any,
                        "Parameters of InjectAttribute do not apply to constructors and methodInfos");
                }

                var injectParamInfos = methodInfo.GetParameters()
                    .Select(x => CreateInjectableInfoForParam(type, x)).ToList();

                injectMethodInfos.Add(
                    new ReflectionTypeInfo.InjectMethodInfo(methodInfo, injectParamInfos));
            }

            return injectMethodInfos;
        }

        static ReflectionTypeInfo.InjectConstructorInfo GetConstructorInfo(Type type)
        {
            var args = new List<ReflectionTypeInfo.InjectParameterInfo>();

            var constructor = TryGetInjectConstructor(type);

            if (constructor != null)
            {
                args.AddRange(constructor.GetParameters().Select(
                    x => CreateInjectableInfoForParam(type, x)));
            }

            return new ReflectionTypeInfo.InjectConstructorInfo(constructor, args);
        }

        static ReflectionTypeInfo.InjectParameterInfo CreateInjectableInfoForParam(
            Type parentType, ParameterInfo paramInfo)
        {
            var injectAttributes = paramInfo.AllAttributes<InjectAttributeBase>().ToList();

            Assert.That(injectAttributes.Count <= 1,
                "Found multiple 'Inject' attributes on type parameter '{0}' of type '{1}'.  Parameter should only have one", paramInfo.Name, parentType);

            var injectAttr = injectAttributes.SingleOrDefault();

            object identifier = null;
            bool isOptional = false;
            InjectSources sourceType = InjectSources.Any;

            if (injectAttr != null)
            {
                identifier = injectAttr.Id;
                isOptional = injectAttr.Optional;
                sourceType = injectAttr.Source;
            }

            bool isOptionalWithADefaultValue = (paramInfo.Attributes & ParameterAttributes.HasDefault) == ParameterAttributes.HasDefault;

            return new ReflectionTypeInfo.InjectParameterInfo(
                paramInfo,
                new InjectableInfo(
                    isOptionalWithADefaultValue || isOptional,
                    identifier,
                    paramInfo.Name,
                    paramInfo.ParameterType,
                    isOptionalWithADefaultValue ? paramInfo.DefaultValue : null,
                    sourceType));
        }

        static InjectableInfo GetInjectableInfoForMember(Type parentType, MemberInfo memInfo)
        {
            var injectAttributes = memInfo.AllAttributes<InjectAttributeBase>().ToList();

            Assert.That(injectAttributes.Count <= 1,
            "Found multiple 'Inject' attributes on type field '{0}' of type '{1}'.  Field should only container one Inject attribute", memInfo.Name, parentType);

            var injectAttr = injectAttributes.SingleOrDefault();

            object identifier = null;
            bool isOptional = false;
            InjectSources sourceType = InjectSources.Any;

            if (injectAttr != null)
            {
                identifier = injectAttr.Id;
                isOptional = injectAttr.Optional;
                sourceType = injectAttr.Source;
            }

            Type memberType = memInfo is FieldInfo
                ? ((FieldInfo)memInfo).FieldType : ((PropertyInfo)memInfo).PropertyType;

            return new InjectableInfo(
                isOptional,
                identifier,
                memInfo.Name,
                memberType,
                null,
                sourceType);
        }

        static ConstructorInfo TryGetInjectConstructor(Type type)
        {
#if !NOT_UNITY3D
            if (type.DerivesFromOrEqual<Component>())
            {
                return null;
            }
#endif

            if (type.IsAbstract())
            {
                return null;
            }

            var constructors = type.Constructors();

#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
            // WP8 generates a dummy constructor with signature (internal Classname(UIntPtr dummy))
            // So just ignore that
            constructors = constructors.Where(c => !IsWp8GeneratedConstructor(c)).ToArray();
#endif

            if (constructors.IsEmpty())
            {
                return null;
            }

            if (constructors.HasMoreThan(1))
            {
                var explicitConstructor = (from c in constructors where _injectAttributeTypes.Any(a => c.HasAttribute(a)) select c).SingleOrDefault();

                if (explicitConstructor != null)
                {
                    return explicitConstructor;
                }

                // If there is only one public constructor then use that
                // This makes decent sense but is also necessary on WSA sometimes since the WSA generated
                // constructor can sometimes be private with zero parameters
                var singlePublicConstructor = constructors.Where(x => x.IsPublic).OnlyOrDefault();

                if (singlePublicConstructor != null)
                {
                    return singlePublicConstructor;
                }

                // Choose the one with the least amount of arguments
                // This might result in some non obvious errors like null reference exceptions
                // but is probably the best trade-off since it allows zenject to be more compatible
                // with libraries that don't depend on zenject at all
                // Discussion here - https://github.com/svermeulen/Zenject/issues/416
                return constructors.OrderBy(x => x.GetParameters().Count()).First();
            }

            return constructors[0];
        }

#if UNITY_WSA && ENABLE_DOTNET && !UNITY_EDITOR
        static bool IsWp8GeneratedConstructor(ConstructorInfo c)
        {
            ParameterInfo[] args = c.GetParameters();

            if (args.Length == 1)
            {
                return args[0].ParameterType == typeof(UIntPtr)
                    && (string.IsNullOrEmpty(args[0].Name) || args[0].Name == "dummy");
            }

            if (args.Length == 2)
            {
                return args[0].ParameterType == typeof(UIntPtr)
                    && args[1].ParameterType == typeof(Int64*)
                    && (string.IsNullOrEmpty(args[0].Name) || args[0].Name == "dummy")
                    && (string.IsNullOrEmpty(args[1].Name) || args[1].Name == "dummy");
            }

            return false;
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenReflectionTypeAnalyzer.cs.meta
================================================
fileFormatVersion: 2
guid: 046b222c5a2e0994cb5c424ed912f808
timeCreated: 1536916211
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenUtilInternal.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ModestTree;
using ModestTree.Util;
#if !NOT_UNITY3D
using UnityEngine.SceneManagement;
using UnityEngine;
#endif

namespace Zenject.Internal
{
    public static class ZenUtilInternal
    {
#if UNITY_EDITOR
        static GameObject _disabledIndestructibleGameObject;
#endif

        // Due to the way that Unity overrides the Equals operator,
        // normal null checks such as (x == null) do not always work as
        // expected
        // In those cases you can use this function which will also
        // work with non-unity objects
        public static bool IsNull(System.Object obj)
        {
            return obj == null || obj.Equals(null);
        }

#if UNITY_EDITOR
        // This can be useful if you are running code outside unity
        // since in that case you have to make sure to avoid calling anything
        // inside Unity DLLs
        public static bool IsOutsideUnity()
        {
            return AppDomain.CurrentDomain.FriendlyName != "Unity Child Domain";
        }
#endif

        public static bool AreFunctionsEqual(Delegate left, Delegate right)
        {
            return left.Target == right.Target && left.Method() == right.Method();
        }

        // Taken from here:
        // http://stackoverflow.com/questions/28937324/in-c-how-could-i-get-a-classs-inheritance-distance-to-base-class/28937542#28937542
        public static int GetInheritanceDelta(Type derived, Type parent)
        {
            Assert.That(derived.DerivesFromOrEqual(parent));

            if (parent.IsInterface())
            {
                // Not sure if we can calculate this so just return 1
                return 1;
            }

            if (derived == parent)
            {
                return 0;
            }

            int distance = 1;

            Type child = derived;

            while ((child = child.BaseType()) != parent)
            {
                distance++;
            }

            return distance;
        }

#if !NOT_UNITY3D
        public static IEnumerable<SceneContext> GetAllSceneContexts()
        {
            foreach (var scene in UnityUtil.AllLoadedScenes)
            {
                var contexts = scene.GetRootGameObjects()
                    .SelectMany(root => root.GetComponentsInChildren<SceneContext>()).ToList();

                if (contexts.IsEmpty())
                {
                    continue;
                }

                Assert.That(contexts.Count == 1,
                    "Found multiple scene contexts in scene '{0}'", scene.name);

                yield return contexts[0];
            }
        }

        public static void AddStateMachineBehaviourAutoInjectersInScene(Scene scene)
        {
            foreach (var rootObj in GetRootGameObjects(scene))
            {
                if (rootObj != null)
                {
                    AddStateMachineBehaviourAutoInjectersUnderGameObject(rootObj);
                }
            }
        }

        // Call this before calling GetInjectableMonoBehavioursUnderGameObject to ensure that the StateMachineBehaviour's
        // also get injected properly
        // The StateMachineBehaviour's cannot be retrieved until after the Start() method so we
        // need to use ZenjectStateMachineBehaviourAutoInjecter to do the injection at that
        // time for us
        public static void AddStateMachineBehaviourAutoInjectersUnderGameObject(GameObject root)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Searching Hierarchy"))
#endif
            {
                // var animators = root.GetComponentsInChildren<Animator>(true);

                // foreach (var animator in animators)
                // {
                //     if (animator.gameObject.GetComponent<ZenjectStateMachineBehaviourAutoInjecter>() == null)
                //     {
                //         animator.gameObject.AddComponent<ZenjectStateMachineBehaviourAutoInjecter>();
                //     }
                // }
            }
        }

        public static void GetInjectableMonoBehavioursInScene(
            Scene scene, List<MonoBehaviour> monoBehaviours)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Searching Hierarchy"))
#endif
            {
                foreach (var rootObj in GetRootGameObjects(scene))
                {
                    if (rootObj != null)
                    {
                        GetInjectableMonoBehavioursUnderGameObjectInternal(rootObj, monoBehaviours);
                    }
                }
            }
        }

        // NOTE: This method will not return components that are within a GameObjectContext
        // It returns monobehaviours in a bottom-up order
        public static void GetInjectableMonoBehavioursUnderGameObject(
            GameObject gameObject, List<MonoBehaviour> injectableComponents)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Searching Hierarchy"))
#endif
            {
                GetInjectableMonoBehavioursUnderGameObjectInternal(gameObject, injectableComponents);
            }
        }

        static void GetInjectableMonoBehavioursUnderGameObjectInternal(
            GameObject gameObject, List<MonoBehaviour> injectableComponents)
        {
            if (gameObject == null)
            {
                return;
            }

            var monoBehaviours = gameObject.GetComponents<MonoBehaviour>();

            for (int i = 0; i < monoBehaviours.Length; i++)
            {
                var monoBehaviour = monoBehaviours[i];

                // Can be null for broken component references
                if (monoBehaviour != null
                        && monoBehaviour.GetType().DerivesFromOrEqual<GameObjectContext>())
                {
                    // Need to make sure we don't inject on any MonoBehaviour's that are below a GameObjectContext
                    // Since that is the responsibility of the GameObjectContext
                    // BUT we do want to inject on the GameObjectContext itself
                    injectableComponents.Add(monoBehaviour);
                    return;
                }
            }

            // Recurse first so it adds components bottom up though it shouldn't really matter much
            // because it should always inject in the dependency order
            for (int i = 0; i < gameObject.transform.childCount; i++)
            {
                var child = gameObject.transform.GetChild(i);

                if (child != null)
                {
                    GetInjectableMonoBehavioursUnderGameObjectInternal(child.gameObject, injectableComponents);
                }
            }

            for (int i = 0; i < monoBehaviours.Length; i++)
            {
                var monoBehaviour = monoBehaviours[i];

                // Can be null for broken component references
                if (monoBehaviour != null
                    && IsInjectableMonoBehaviourType(monoBehaviour.GetType()))
                {
                    injectableComponents.Add(monoBehaviour);
                }
            }
        }

        public static bool IsInjectableMonoBehaviourType(Type type)
        {
            // Do not inject on installers since these are always injected before they are installed
            return type != null && !type.DerivesFrom<MonoInstaller>() && TypeAnalyzer.HasInfo(type);
        }

        public static IEnumerable<GameObject> GetRootGameObjects(Scene scene)
        {
#if ZEN_INTERNAL_PROFILING
            using (ProfileTimers.CreateTimedBlock("Searching Hierarchy"))
#endif
            {
                if (scene.isLoaded)
                {
                    return scene.GetRootGameObjects()
                        .Where(x => x.GetComponent<ProjectContext>() == null);
                }

                // Note: We can't use scene.GetRootObjects() here because that apparently fails with an exception
                // about the scene not being loaded yet when executed in Awake
                // We also can't use GameObject.FindObjectsOfType<Transform>() because that does not include inactive game objects
                // So we use Resources.FindObjectsOfTypeAll, even though that may include prefabs.  However, our assumption here
                // is that prefabs do not have their "scene" property set correctly so this should work
                //
                // It's important here that we only inject into root objects that are part of our scene, to properly support
                // multi-scene editing features of Unity 5.x
                //
                // Also, even with older Unity versions, if there is an object that is marked with DontDestroyOnLoad, then it will
                // be injected multiple times when another scene is loaded
                //
                // We also make sure not to inject into the project root objects which are injected by ProjectContext.
                return Resources.FindObjectsOfTypeAll<GameObject>()
                    .Where(x => x.transform.parent == null
                            && x.GetComponent<ProjectContext>() == null
                            && x.scene == scene);
            }
        }

#if UNITY_EDITOR
        // Returns a Transform in the DontDestroyOnLoad scene (or, if we're not in play mode, within the current active scene)
        // whose GameObject is inactive, and whose hide flags are set to HideAndDontSave. We can instantiate prefabs in here
        // without any of their Awake() methods firing.
        public static Transform GetOrCreateInactivePrefabParent()
        {
            if(_disabledIndestructibleGameObject == null || (!Application.isPlaying && _disabledIndestructibleGameObject.scene != SceneManager.GetActiveScene()))
            {
                var go = new GameObject("ZenUtilInternal_PrefabParent");
                go.hideFlags = HideFlags.HideAndDontSave;
                go.SetActive(false);

                if(Application.isPlaying)
                {
                    UnityEngine.Object.DontDestroyOnLoad(go);
                }

                _disabledIndestructibleGameObject = go;
            }

            return _disabledIndestructibleGameObject.transform;
        }
#endif

#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Util/ZenUtilInternal.cs.meta
================================================
fileFormatVersion: 2
guid: 401238e59d733ab48aaea1a582241b29
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Validation/IValidatable.cs
================================================
namespace Zenject
{
    public interface IValidatable
    {
        void Validate();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Validation/IValidatable.cs.meta
================================================
fileFormatVersion: 2
guid: 5d2a7156fffca9b439f7734d94ccf336
timeCreated: 1461708050
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Validation/ValidationMarker.cs
================================================
using System;

namespace Zenject
{
    [NoReflectionBaking]
    public class ValidationMarker
    {
        public ValidationMarker(
            Type markedType, bool instantiateFailed)
        {
            MarkedType = markedType;
            InstantiateFailed = instantiateFailed;
        }

        public ValidationMarker(Type markedType)
            : this(markedType, false)
        {
        }

        public bool InstantiateFailed
        {
            get;
            private set;
        }

        public Type MarkedType
        {
            get;
            private set;
        }
    }
}




================================================
FILE: src/MessagePipe.Unity/Assets/Plugins/Zenject/Source/Validation/ValidationMarker.cs.meta
================================================
fileFormatVersion: 2
guid: 27e4cef6504bc0243b1893240d22b72d
timeCreated: 1461708049
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scenes/NewBehaviourScript.cs
================================================
using Cysharp.Threading.Tasks;
using MessagePipe;
using System;
using UnityEngine;
using UnityEngine.UI;
// using VContainer;

public class NewBehaviourScript : MonoBehaviour
{
    public Button button1;
    public Button button2;
    public Button button3;
    public Button button4;

    IPublisher<int> publisher;
    ISubscriber<int> subscriber;
    IDisposable disposable;
    int id = 0;

    public void Start()
    {
        var builder = new BuiltinContainerBuilder();

        builder.AddMessagePipe(x => { x.EnableCaptureStackTrace = true; });
        builder.AddMessageBroker<int>();

        var resolver = builder.BuildServiceProvider();
        GlobalMessagePipe.SetProvider(resolver);

        publisher = resolver.GetRequiredService<IPublisher<int>>();
        subscriber = resolver.GetRequiredService<ISubscriber<int>>();

        button1.onClick.AddListener(FooSubscribe);
        button2.onClick.AddListener(BarSubscribe);
        button3.onClick.AddListener(() =>
        {
            disposable = DisposableBag.Create(disposable, subscriber.Subscribe(x => Debug.Log($"{id}:Baz")));
        });
        button4.onClick.AddListener(UnSubscribeAll);

        disposable = DisposableBag.Empty;
        Forever().Forget();
    }

    void FooSubscribe()
    {
        disposable = DisposableBag.Create(disposable, subscriber.Subscribe(x => Debug.Log($"{id}:Foo1")));
        disposable = DisposableBag.Create(disposable, subscriber.Subscribe(x => Debug.Log($"{id}:Foo2")));
    }

    void BarSubscribe()
    {
        disposable = DisposableBag.Create(disposable, subscriber.Subscribe(x => Debug.Log($"{id}:Bar")));
    }

    //void BazSubscribe()
    //{
    //    disposable = DisposableBag.Create(disposable, subscriber.Subscribe(x => Debug.Log($"{id}:Baz")));
    //}

    void UnSubscribeAll()
    {
        disposable.Dispose();
        disposable = DisposableBag.Empty;
    }

    async UniTaskVoid Forever()
    {
        var cts = this.GetCancellationTokenOnDestroy();
        while (!cts.IsCancellationRequested)
        {
            await UniTask.Yield();
        }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Scenes/NewBehaviourScript.cs.meta
================================================
fileFormatVersion: 2
guid: 85268bbd52374064cbc7f4b636b57791
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scenes/SampleScene.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 0
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 500
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 500
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 2
    m_PVRDenoiserTypeDirect: 0
    m_PVRDenoiserTypeIndirect: 0
    m_PVRDenoiserTypeAO: 0
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 0
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_UseShadowmask: 1
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &149702784
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 149702787}
  - component: {fileID: 149702786}
  - component: {fileID: 149702785}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &149702785
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 149702784}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &149702786
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 149702784}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!4 &149702787
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 149702784}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &158974944
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 158974945}
  - component: {fileID: 158974948}
  - component: {fileID: 158974947}
  - component: {fileID: 158974946}
  m_Layer: 5
  m_Name: Button (1)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &158974945
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 158974944}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1406702908}
  m_Father: {fileID: 713999792}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -502, y: 135}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &158974946
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 158974944}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 158974947}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &158974947
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 158974944}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &158974948
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 158974944}
  m_CullTransparentMesh: 0
--- !u!1 &209320821
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 209320822}
  - component: {fileID: 209320825}
  - component: {fileID: 209320824}
  - component: {fileID: 209320823}
  m_Layer: 5
  m_Name: Button
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &209320822
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 209320821}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1126003972}
  m_Father: {fileID: 713999792}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -522, y: 206}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &209320823
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 209320821}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 209320824}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &209320824
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 209320821}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &209320825
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 209320821}
  m_CullTransparentMesh: 0
--- !u!1 &375649550
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 375649551}
  - component: {fileID: 375649553}
  - component: {fileID: 375649552}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &375649551
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 375649550}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1366262146}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &375649552
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 375649550}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &375649553
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 375649550}
  m_CullTransparentMesh: 0
--- !u!1 &519420028
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 519420032}
  - component: {fileID: 519420031}
  - component: {fileID: 519420030}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &519420030
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 85268bbd52374064cbc7f4b636b57791, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  button1: {fileID: 209320823}
  button2: {fileID: 158974946}
  button3: {fileID: 1212778654}
  button4: {fileID: 1366262147}
--- !u!20 &519420031
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 2
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 1
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 0
  m_HDR: 1
  m_AllowMSAA: 0
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 0
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &519420032
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 713999792}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &713999791
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 713999792}
  - component: {fileID: 713999795}
  - component: {fileID: 713999794}
  - component: {fileID: 713999793}
  m_Layer: 5
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &713999792
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 713999791}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_Children:
  - {fileID: 209320822}
  - {fileID: 158974945}
  - {fileID: 1212778653}
  - {fileID: 1366262146}
  m_Father: {fileID: 519420032}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!114 &713999793
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 713999791}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &713999794
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 713999791}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
--- !u!223 &713999795
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 713999791}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_AdditionalShaderChannelsFlag: 0
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!1 &894169767
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 894169768}
  - component: {fileID: 894169770}
  - component: {fileID: 894169769}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &894169768
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 894169767}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1212778653}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &894169769
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 894169767}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &894169770
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 894169767}
  m_CullTransparentMesh: 0
--- !u!1 &1126003971
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1126003972}
  - component: {fileID: 1126003974}
  - component: {fileID: 1126003973}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1126003972
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1126003971}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 209320822}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1126003973
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1126003971}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &1126003974
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1126003971}
  m_CullTransparentMesh: 0
--- !u!1 &1212778652
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1212778653}
  - component: {fileID: 1212778656}
  - component: {fileID: 1212778655}
  - component: {fileID: 1212778654}
  m_Layer: 5
  m_Name: Button (2)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1212778653
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1212778652}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 894169768}
  m_Father: {fileID: 713999792}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -522, y: 73}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1212778654
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1212778652}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 1212778655}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &1212778655
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1212778652}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &1212778656
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1212778652}
  m_CullTransparentMesh: 0
--- !u!1 &1366262145
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1366262146}
  - component: {fileID: 1366262149}
  - component: {fileID: 1366262148}
  - component: {fileID: 1366262147}
  m_Layer: 5
  m_Name: Button (3)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1366262146
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1366262145}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 375649551}
  m_Father: {fileID: 713999792}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -163, y: 119}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1366262147
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1366262145}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 1366262148}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &1366262148
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1366262145}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &1366262149
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1366262145}
  m_CullTransparentMesh: 0
--- !u!1 &1406702907
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1406702908}
  - component: {fileID: 1406702910}
  - component: {fileID: 1406702909}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1406702908
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1406702907}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 158974945}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1406702909
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1406702907}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &1406702910
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1406702907}
  m_CullTransparentMesh: 0



================================================
FILE: src/MessagePipe.Unity/Assets/Scenes/SampleScene.unity.meta
================================================
fileFormatVersion: 2
guid: 2cda990e2423bbf4892e6590ba056729
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/GameLifetimeScope.cs
================================================
using UnityEngine;
using VContainer;
using VContainer.Unity;
using MessagePipe;
using System;

public class GameLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        var options = builder.RegisterMessagePipe(x => { x.EnableCaptureStackTrace = true; });
        builder.RegisterMessageBroker<int>(options);


        builder.RegisterEntryPoint<MessagePipeDemo>(Lifetime.Singleton);
    }

    // Register IPublisher<T>/ISubscriber<T> and global filter.
    static void RegisterMessageBroker<T>(IContainerBuilder builder, MessagePipeOptions options)
    {
        builder.RegisterMessageBroker<T>(options);

        // setup for global filters.
        options.AddGlobalMessageHandlerFilter<MyMessageHandlerFilter<T>>();
    }

    static void RegisterRequest<TRequest, TResponse, THandler>(IContainerBuilder builder, MessagePipeOptions options)
        where THandler : IRequestHandler
    {
        builder.RegisterRequestHandler<TRequest, TResponse, THandler>(options);
        options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter<TRequest, TResponse>>();
    }
}

public class MyMessageHandlerFilter<T> : MessageHandlerFilter<T>
{
    public override void Handle(T message, System.Action<T> next)
    {
        throw new System.NotImplementedException();
    }
}

public class MyRequestHandlerFilter<TReq, TRes> : RequestHandlerFilter<TReq, TRes>
{
    public override TRes Invoke(TReq request, System.Func<TReq, TRes> next)
    {
        throw new System.NotImplementedException();
    }
}

public class MessagePipeDemo : VContainer.Unity.IStartable
{
    readonly IPublisher<int> publisher;
    readonly ISubscriber<int> subscriber;

    public MessagePipeDemo(IPublisher<int> publisher, ISubscriber<int> subscriber, IObjectResolver resolver)
    {
        this.publisher = publisher;
        this.subscriber = subscriber;

        GlobalMessagePipe.SetProvider(resolver.AsServiceProvider());
    }

    public void Start()
    {



        var d = DisposableBag.CreateBuilder();

        // subscriber.Subscribe(x => Debug.Log("P1:" + x));





        subscriber.Subscribe(x => Debug.Log("P1:" + x)).AddTo(d);
        subscriber.Subscribe(x => Debug.Log("P2:" + x)).AddTo(d);

        publisher.Publish(10);
        publisher.Publish(20);
        publisher.Publish(30);

        var disposable = d.Build();
        // disposable.Dispose();
    }
}













================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/GameLifetimeScope.cs.meta
================================================
fileFormatVersion: 2
guid: caaffaee565da524f87d9bed3830c4ca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack.meta
================================================
fileFormatVersion: 2
guid: fe1defebffd68484980913cbd1885aa7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations.meta
================================================
fileFormatVersion: 2
guid: e0e16c3ff3c3e6e48bf776d2c334fd7f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/BitOperations.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// <auto-generated />

#if !NETCOREAPP

using System.Runtime.CompilerServices;

// Some routines inspired by the Stanford Bit Twiddling Hacks by Sean Eron Anderson:
// http://graphics.stanford.edu/~seander/bithacks.html

namespace System.Numerics
{
    /// <summary>
    /// Utility methods for intrinsic bit-twiddling operations.
    /// The methods use hardware intrinsics when available on the underlying platform,
    /// otherwise they use optimized software fallbacks.
    /// </summary>
    internal static class BitOperations
    {
        /// <summary>
        /// Rotates the specified value left by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROL.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint RotateLeft(uint value, int offset)
            => (value << offset) | (value >> (32 - offset));
   }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/BitOperations.cs.meta
================================================
fileFormatVersion: 2
guid: 9b03a72c1f30f7a4f92f859479703d3c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/BufferWriter.cs
================================================
// <auto-generated /> // We want to keep this file as-is since it's shared with other repos.

// Copyright (c) .NET Foundation. All rights reserved.
// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePack
{
    /// <summary>
    /// A fast access struct that wraps <see cref="IBufferWriter{T}"/>.
    /// </summary>
    internal ref struct BufferWriter
    {
        /// <summary>
        /// The underlying <see cref="IBufferWriter{T}"/>.
        /// </summary>
        private IBufferWriter<byte> _output;

        /// <summary>
        /// The result of the last call to <see cref="IBufferWriter{T}.GetSpan(int)"/>, less any bytes already "consumed" with <see cref="Advance(int)"/>.
        /// Backing field for the <see cref="Span"/> property.
        /// </summary>
        private Span<byte> _span;

        /// <summary>
        /// The result of the last call to <see cref="IBufferWriter{T}.GetMemory(int)"/>, less any bytes already "consumed" with <see cref="Advance(int)"/>.
        /// </summary>
        private ArraySegment<byte> _segment;

        /// <summary>
        /// The number of uncommitted bytes (all the calls to <see cref="Advance(int)"/> since the last call to <see cref="Commit"/>).
        /// </summary>
        private int _buffered;

        /// <summary>
        /// The total number of bytes written with this writer.
        /// Backing field for the <see cref="BytesCommitted"/> property.
        /// </summary>
        private long _bytesCommitted;

        private SequencePool _sequencePool;

        private SequencePool.Rental _rental;

        /// <summary>
        /// Initializes a new instance of the <see cref="BufferWriter"/> struct.
        /// </summary>
        /// <param name="output">The <see cref="IBufferWriter{T}"/> to be wrapped.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public BufferWriter(IBufferWriter<byte> output)
        {
            _buffered = 0;
            _bytesCommitted = 0;
            _output = output ?? throw new ArgumentNullException(nameof(output));

            _sequencePool = default;
            _rental = default;

            var memory = _output.GetMemoryCheckResult();
            MemoryMarshal.TryGetArray(memory, out _segment);
            _span = memory.Span;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BufferWriter"/> struct.
        /// </summary>
        /// <param name="sequencePool">The pool from which to draw an <see cref="IBufferWriter{T}"/> if required..</param>
        /// <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal BufferWriter(SequencePool sequencePool, byte[] array)
        {
            _buffered = 0;
            _bytesCommitted = 0;
            _sequencePool = sequencePool ?? throw new ArgumentNullException(nameof(sequencePool));
            _rental = default;
            _output = null;

            _segment = new ArraySegment<byte>(array);
            _span = _segment.AsSpan();
        }

        /// <summary>
        /// Gets the result of the last call to <see cref="IBufferWriter{T}.GetSpan(int)"/>.
        /// </summary>
        public Span<byte> Span => _span;

        /// <summary>
        /// Gets the total number of bytes written with this writer.
        /// </summary>
        public long BytesCommitted => _bytesCommitted;

        /// <summary>
        /// Gets the <see cref="IBufferWriter{T}"/> underlying this instance.
        /// </summary>
        internal IBufferWriter<byte> UnderlyingWriter => _output;

        internal SequencePool.Rental SequenceRental => _rental;

        public Span<byte> GetSpan(int sizeHint)
        {
            Ensure(sizeHint);
            return this.Span;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref byte GetPointer(int sizeHint)
        {
            Ensure(sizeHint);

            if (_segment.Array != null)
            {
                return ref _segment.Array[_segment.Offset + _buffered];
            }
            else
            {
                return ref _span.GetPinnableReference();
            }
        }

        /// <summary>
        /// Calls <see cref="IBufferWriter{T}.Advance(int)"/> on the underlying writer
        /// with the number of uncommitted bytes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Commit()
        {
            var buffered = _buffered;
            if (buffered > 0)
            {
                this.MigrateToSequence();

                _bytesCommitted += buffered;
                _buffered = 0;
                _output.Advance(buffered);
                _span = default;
            }
        }

        /// <summary>
        /// Used to indicate that part of the buffer has been written to.
        /// </summary>
        /// <param name="count">The number of bytes written to.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Advance(int count)
        {
            _buffered += count;
            _span = _span.Slice(count);
        }

        /// <summary>
        /// Copies the caller's buffer into this writer and calls <see cref="Advance(int)"/> with the length of the source buffer.
        /// </summary>
        /// <param name="source">The buffer to copy in.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Write(ReadOnlySpan<byte> source)
        {
            if (_span.Length >= source.Length)
            {
                source.CopyTo(_span);
                Advance(source.Length);
            }
            else
            {
                WriteMultiBuffer(source);
            }
        }

        /// <summary>
        /// Acquires a new buffer if necessary to ensure that some given number of bytes can be written to a single buffer.
        /// </summary>
        /// <param name="count">The number of bytes that must be allocated in a single buffer.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Ensure(int count = 1)
        {
            if (_span.Length < count)
            {
                EnsureMore(count);
            }
        }

        /// <summary>
        /// Gets the span to the bytes written if they were never committed to the underlying buffer writer.
        /// </summary>
        /// <param name="span"></param>
        /// <returns></returns>
        internal bool TryGetUncommittedSpan(out ReadOnlySpan<byte> span)
        {
            if (this._sequencePool != null)
            {
                span = _segment.AsSpan(0, _buffered);
                return true;
            }

            span = default;
            return false;
        }

        /// <summary>
        /// Gets a fresh span to write to, with an optional minimum size.
        /// </summary>
        /// <param name="count">The minimum size for the next requested buffer.</param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void EnsureMore(int count = 0)
        {
            if (_buffered > 0)
            {
                Commit();
            }
            else
            {
                this.MigrateToSequence();
            }

            var memory = _output.GetMemoryCheckResult(count);
            MemoryMarshal.TryGetArray(memory, out _segment);
            _span = memory.Span;
        }

        /// <summary>
        /// Copies the caller's buffer into this writer, potentially across multiple buffers from the underlying writer.
        /// </summary>
        /// <param name="source">The buffer to copy into this writer.</param>
        private void WriteMultiBuffer(ReadOnlySpan<byte> source)
        {
            int copiedBytes = 0;
            int bytesLeftToCopy = source.Length;
            while (bytesLeftToCopy > 0)
            {
                if (_span.Length == 0)
                {
                    EnsureMore();
                }

                var writable = Math.Min(bytesLeftToCopy, _span.Length);
                source.Slice(copiedBytes, writable).CopyTo(_span);
                copiedBytes += writable;
                bytesLeftToCopy -= writable;
                Advance(writable);
            }
        }

        private void MigrateToSequence()
        {
            if (this._sequencePool != null)
            {
                // We were writing to our private scratch memory, so we have to copy it into the actual writer.
                _rental = _sequencePool.Rent();
                _output = _rental.Value;
                var realSpan = _output.GetSpan(_buffered);
                _segment.AsSpan(0, _buffered).CopyTo(realSpan);
                _sequencePool = null;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/BufferWriter.cs.meta
================================================
fileFormatVersion: 2
guid: 2ed92c5d94108c44c93e31cd211ef1a6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ExtensionHeader.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

namespace MessagePack
{
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    struct ExtensionHeader : IEquatable<ExtensionHeader>
    {
        public sbyte TypeCode { get; private set; }

        public uint Length { get; private set; }

        public ExtensionHeader(sbyte typeCode, uint length)
        {
            this.TypeCode = typeCode;
            this.Length = length;
        }

        public ExtensionHeader(sbyte typeCode, int length)
        {
            this.TypeCode = typeCode;
            this.Length = (uint)length;
        }

        public bool Equals(ExtensionHeader other) => this.TypeCode == other.TypeCode && this.Length == other.Length;
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ExtensionHeader.cs.meta
================================================
fileFormatVersion: 2
guid: 27ccbf9800df8ad48be2d278e288b37e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ExtensionResult.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;

namespace MessagePack
{
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    struct ExtensionResult
    {
        public ExtensionResult(sbyte typeCode, Memory<byte> data)
        {
            this.TypeCode = typeCode;
            this.Data = new ReadOnlySequence<byte>(data);
        }

        public ExtensionResult(sbyte typeCode, ReadOnlySequence<byte> data)
        {
            this.TypeCode = typeCode;
            this.Data = data;
        }

        public sbyte TypeCode { get; private set; }

        public ReadOnlySequence<byte> Data { get; private set; }

        public ExtensionHeader Header => new ExtensionHeader(this.TypeCode, (uint)this.Data.Length);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ExtensionResult.cs.meta
================================================
fileFormatVersion: 2
guid: 3e64fdfe376c995419f98e1384f33b3e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters.meta
================================================
fileFormatVersion: 2
guid: 52e59336e1f963c42b6bb11eec01f72b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/HashCode.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// <auto-generated />

/*

The xxHash32 implementation is based on the code published by Yann Collet:
https://raw.githubusercontent.com/Cyan4973/xxHash/5c174cfa4e45a42f94082dc0d4539b39696afea1/xxhash.c

  xxHash - Fast Hash algorithm
  Copyright (C) 2012-2016, Yann Collet

  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  You can contact the author at :
  - xxHash homepage: http://www.xxhash.com
  - xxHash source repository : https://github.com/Cyan4973/xxHash

*/

#if !NETCOREAPP

using System.Collections.Generic;
using System.ComponentModel;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace System
{
    // xxHash32 is used for the hash code.
    // https://github.com/Cyan4973/xxHash

    internal struct HashCode
    {
        private static readonly uint s_seed = GenerateGlobalSeed();

        private const uint Prime1 = 2654435761U;
        private const uint Prime2 = 2246822519U;
        private const uint Prime3 = 3266489917U;
        private const uint Prime4 = 668265263U;
        private const uint Prime5 = 374761393U;

        private uint _v1, _v2, _v3, _v4;
        private uint _queue1, _queue2, _queue3;
        private uint _length;

        private static uint GenerateGlobalSeed()
        {
            var bytes = new byte[4];
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(bytes);
            }

            return BitConverter.ToUInt32(bytes, 0);
        }

        public static int Combine<T1>(T1 value1)
        {
            unchecked
            {
                // Provide a way of diffusing bits from something with a limited
                // input hash space. For example, many enums only have a few
                // possible hashes, only using the bottom few bits of the code. Some
                // collections are built on the assumption that hashes are spread
                // over a larger space, so diffusing the bits may help the
                // collection work more efficiently.

                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);

                uint hash = MixEmptyState();
                hash += 4;

                hash = QueueRound(hash, hc1);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2>(T1 value1, T2 value2)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);

                uint hash = MixEmptyState();
                hash += 8;

                hash = QueueRound(hash, hc1);
                hash = QueueRound(hash, hc2);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);

                uint hash = MixEmptyState();
                hash += 12;

                hash = QueueRound(hash, hc1);
                hash = QueueRound(hash, hc2);
                hash = QueueRound(hash, hc3);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);
                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);

                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);

                v1 = Round(v1, hc1);
                v2 = Round(v2, hc2);
                v3 = Round(v3, hc3);
                v4 = Round(v4, hc4);

                uint hash = MixState(v1, v2, v3, v4);
                hash += 16;

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);
                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);
                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);

                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);

                v1 = Round(v1, hc1);
                v2 = Round(v2, hc2);
                v3 = Round(v3, hc3);
                v4 = Round(v4, hc4);

                uint hash = MixState(v1, v2, v3, v4);
                hash += 20;

                hash = QueueRound(hash, hc5);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);
                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);
                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);
                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);

                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);

                v1 = Round(v1, hc1);
                v2 = Round(v2, hc2);
                v3 = Round(v3, hc3);
                v4 = Round(v4, hc4);

                uint hash = MixState(v1, v2, v3, v4);
                hash += 24;

                hash = QueueRound(hash, hc5);
                hash = QueueRound(hash, hc6);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);
                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);
                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);
                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);
                uint hc7 = (uint)(value7?.GetHashCode() ?? 0);

                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);

                v1 = Round(v1, hc1);
                v2 = Round(v2, hc2);
                v3 = Round(v3, hc3);
                v4 = Round(v4, hc4);

                uint hash = MixState(v1, v2, v3, v4);
                hash += 28;

                hash = QueueRound(hash, hc5);
                hash = QueueRound(hash, hc6);
                hash = QueueRound(hash, hc7);

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
        {
            unchecked
            {
                uint hc1 = (uint)(value1?.GetHashCode() ?? 0);
                uint hc2 = (uint)(value2?.GetHashCode() ?? 0);
                uint hc3 = (uint)(value3?.GetHashCode() ?? 0);
                uint hc4 = (uint)(value4?.GetHashCode() ?? 0);
                uint hc5 = (uint)(value5?.GetHashCode() ?? 0);
                uint hc6 = (uint)(value6?.GetHashCode() ?? 0);
                uint hc7 = (uint)(value7?.GetHashCode() ?? 0);
                uint hc8 = (uint)(value8?.GetHashCode() ?? 0);

                Initialize(out uint v1, out uint v2, out uint v3, out uint v4);

                v1 = Round(v1, hc1);
                v2 = Round(v2, hc2);
                v3 = Round(v3, hc3);
                v4 = Round(v4, hc4);

                v1 = Round(v1, hc5);
                v2 = Round(v2, hc6);
                v3 = Round(v3, hc7);
                v4 = Round(v4, hc8);

                uint hash = MixState(v1, v2, v3, v4);
                hash += 32;

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void Initialize(out uint v1, out uint v2, out uint v3, out uint v4)
        {
            unchecked
            {
                v1 = s_seed + Prime1 + Prime2;
                v2 = s_seed + Prime2;
                v3 = s_seed;
                v4 = s_seed - Prime1;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint Round(uint hash, uint input)
        {
            unchecked
            {
                return BitOperations.RotateLeft(hash + input * Prime2, 13) * Prime1;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint QueueRound(uint hash, uint queuedValue)
        {
            unchecked
            {
                return BitOperations.RotateLeft(hash + queuedValue * Prime3, 17) * Prime4;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint MixState(uint v1, uint v2, uint v3, uint v4)
        {
            unchecked
            {
                return BitOperations.RotateLeft(v1, 1) + BitOperations.RotateLeft(v2, 7) + BitOperations.RotateLeft(v3, 12) + BitOperations.RotateLeft(v4, 18);
            }
        }

        private static uint MixEmptyState()
        {
            unchecked
            {
                return s_seed + Prime5;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint MixFinal(uint hash)
        {
            unchecked
            {
                hash ^= hash >> 15;
                hash *= Prime2;
                hash ^= hash >> 13;
                hash *= Prime3;
                hash ^= hash >> 16;
                return hash;
            }
        }

        public void Add<T>(T value)
        {
            Add(value?.GetHashCode() ?? 0);
        }

        public void Add<T>(T value, IEqualityComparer<T> comparer)
        {
            Add(comparer != null ? comparer.GetHashCode(value) : (value?.GetHashCode() ?? 0));
        }

        private void Add(int value)
        {
            unchecked
            {
                // The original xxHash works as follows:
                // 0. Initialize immediately. We can't do this in a struct (no
                //    default ctor).
                // 1. Accumulate blocks of length 16 (4 uints) into 4 accumulators.
                // 2. Accumulate remaining blocks of length 4 (1 uint) into the
                //    hash.
                // 3. Accumulate remaining blocks of length 1 into the hash.

                // There is no need for #3 as this type only accepts ints. _queue1,
                // _queue2 and _queue3 are basically a buffer so that when
                // ToHashCode is called we can execute #2 correctly.

                // We need to initialize the xxHash32 state (_v1 to _v4) lazily (see
                // #0) nd the last place that can be done if you look at the
                // original code is just before the first block of 16 bytes is mixed
                // in. The xxHash32 state is never used for streams containing fewer
                // than 16 bytes.

                // To see what's really going on here, have a look at the Combine
                // methods.

                uint val = (uint)value;

                // Storing the value of _length locally shaves of quite a few bytes
                // in the resulting machine code.
                uint previousLength = _length++;
                uint position = previousLength % 4;

                // Switch can't be inlined.

                if (position == 0)
                    _queue1 = val;
                else if (position == 1)
                    _queue2 = val;
                else if (position == 2)
                    _queue3 = val;
                else // position == 3
                {
                    if (previousLength == 3)
                        Initialize(out _v1, out _v2, out _v3, out _v4);

                    _v1 = Round(_v1, _queue1);
                    _v2 = Round(_v2, _queue2);
                    _v3 = Round(_v3, _queue3);
                    _v4 = Round(_v4, val);
                }
            }
        }

        public int ToHashCode()
        {
            unchecked
            {
                // Storing the value of _length locally shaves of quite a few bytes
                // in the resulting machine code.
                uint length = _length;

                // position refers to the *next* queue position in this method, so
                // position == 1 means that _queue1 is populated; _queue2 would have
                // been populated on the next call to Add.
                uint position = length % 4;

                // If the length is less than 4, _v1 to _v4 don't contain anything
                // yet. xxHash32 treats this differently.

                uint hash = length < 4 ? MixEmptyState() : MixState(_v1, _v2, _v3, _v4);

                // _length is incremented once per Add(Int32) and is therefore 4
                // times too small (xxHash length is in bytes, not ints).

                hash += length * 4;

                // Mix what remains in the queue

                // Switch can't be inlined right now, so use as few branches as
                // possible by manually excluding impossible scenarios (position > 1
                // is always false if position is not > 0).
                if (position > 0)
                {
                    hash = QueueRound(hash, _queue1);
                    if (position > 1)
                    {
                        hash = QueueRound(hash, _queue2);
                        if (position > 2)
                            hash = QueueRound(hash, _queue3);
                    }
                }

                hash = MixFinal(hash);
                return (int)hash;
            }
        }

#pragma warning disable 0809
        // Obsolete member 'memberA' overrides non-obsolete member 'memberB'.
        // Disallowing GetHashCode and Equals is by design

        // * We decided to not override GetHashCode() to produce the hash code
        //   as this would be weird, both naming-wise as well as from a
        //   behavioral standpoint (GetHashCode() should return the object's
        //   hash code, not the one being computed).

        // * Even though ToHashCode() can be called safely multiple times on
        //   this implementation, it is not part of the contract. If the
        //   implementation has to change in the future we don't want to worry
        //   about people who might have incorrectly used this type.

        [Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", error: true)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => throw new NotSupportedException();

        [Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes.", error: true)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => throw new NotSupportedException();
#pragma warning restore 0809
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/HashCode.cs.meta
================================================
fileFormatVersion: 2
guid: 56e9bfe9ee9b0354b8765ebefbac8d67
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/IFormatterResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack
{
    /// <summary>
    /// Allows querying for a formatter for serializing or deserializing a particular <see cref="Type" />.
    /// </summary>
    public interface IFormatterResolver
    {
        /// <summary>
        /// Gets an <see cref="IMessagePackFormatter{T}"/> instance that can serialize or deserialize some type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type of value to be serialized or deserialized.</typeparam>
        /// <returns>A formatter, if this resolver supplies one for type <typeparamref name="T"/>; otherwise <c>null</c>.</returns>
        IMessagePackFormatter<T> GetFormatter<T>();
    }

    public static class FormatterResolverExtensions
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IMessagePackFormatter<T> GetFormatterWithVerify<T>(this IFormatterResolver resolver)
        {
            if (resolver is null)
            {
                throw new ArgumentNullException(nameof(resolver));
            }

            IMessagePackFormatter<T> formatter;
            try
            {
                formatter = resolver.GetFormatter<T>();
            }
            catch (TypeInitializationException ex)
            {
                // The fact that we're using static constructors to initialize this is an internal detail.
                // Rethrow the inner exception if there is one.
                // Do it carefully so as to not stomp on the original callstack.
                Throw(ex);
                return default; // not reachable
            }

            if (formatter == null)
            {
                Throw(typeof(T), resolver);
            }

            return formatter;
        }

        private static void Throw(TypeInitializationException ex)
        {
            ExceptionDispatchInfo.Capture(ex.InnerException ?? ex).Throw();
        }

        private static void Throw(Type t, IFormatterResolver resolver)
        {
            throw new FormatterNotRegisteredException(t.FullName + " is not registered in resolver: " + resolver.GetType());
        }

        private static readonly ThreadsafeTypeKeyHashTable<Func<IFormatterResolver, IMessagePackFormatter>> FormatterGetters =
            new ThreadsafeTypeKeyHashTable<Func<IFormatterResolver, IMessagePackFormatter>>();

        private static readonly MethodInfo GetFormatterRuntimeMethod = typeof(IFormatterResolver).GetRuntimeMethod(nameof(IFormatterResolver.GetFormatter), Type.EmptyTypes);

        public static object GetFormatterDynamic(this IFormatterResolver resolver, Type type)
        {
            if (resolver is null)
            {
                throw new ArgumentNullException(nameof(resolver));
            }

            if (type is null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!FormatterGetters.TryGetValue(type, out var formatterGetter))
            {
                var genericMethod = GetFormatterRuntimeMethod.MakeGenericMethod(type);
                var inputResolver = Expression.Parameter(typeof(IFormatterResolver), "inputResolver");
                formatterGetter = Expression.Lambda<Func<IFormatterResolver, IMessagePackFormatter>>(
                    Expression.Call(inputResolver, genericMethod), inputResolver).Compile();
                FormatterGetters.TryAdd(type, formatterGetter);
            }

            return formatterGetter(resolver);
        }

        internal static object GetFormatterDynamicWithVerify(this IFormatterResolver resolver, Type type)
        {
            var result = GetFormatterDynamic(resolver, type);
            if (result == null)
            {
                Throw(type, resolver);
            }

            return result;
        }
    }

    public class FormatterNotRegisteredException : MessagePackSerializationException
    {
        public FormatterNotRegisteredException(string message)
            : base(message)
        {
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/IFormatterResolver.cs.meta
================================================
fileFormatVersion: 2
guid: ad1508639e1c32f489af46c74b5d3966
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal.meta
================================================
fileFormatVersion: 2
guid: d7a05f3cbf054f34dab0e7fb217dadfa
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4.meta
================================================
fileFormatVersion: 2
guid: ef309bf3cc7790348a8342cc8df3fc5b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePack.asmdef
================================================
{
    "name": "MessagePack",
    "references": [
        "MessagePack.Annotations"
    ],
    "optionalUnityReferences": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": true,
    "precompiledReferences": [
        "System.Memory.dll",
        "System.Buffers.dll",
        "System.Threading.Tasks.Extensions.dll",
        "System.Runtime.CompilerServices.Unsafe.dll",
        "System.Runtime.Extensions.dll"
    ],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": []
}


================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePack.asmdef.meta
================================================
fileFormatVersion: 2
guid: bbde805d927e795439d7a746d1749cab
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackCode.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Text;

namespace MessagePack
{
    /// <summary>
    /// https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion.
    /// </summary>
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    enum MessagePackType : byte
    {
        Unknown = 0,

        Integer = 1,
        Nil = 2,
        Boolean = 3,
        Float = 4,
        String = 5,
        Binary = 6,
        Array = 7,
        Map = 8,
        Extension = 9,
    }

    /// <summary>
    /// The core type codes as defined by msgpack.
    /// </summary>
    /// <seealso href="https://github.com/msgpack/msgpack/blob/master/spec.md#overview" />
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    static class MessagePackCode
    {
        public const byte MinFixInt = 0x00; // 0
        public const byte MaxFixInt = 0x7f; // 127
        public const byte MinFixMap = 0x80; // 128
        public const byte MaxFixMap = 0x8f; // 143
        public const byte MinFixArray = 0x90; // 144
        public const byte MaxFixArray = 0x9f; // 159
        public const byte MinFixStr = 0xa0; // 160
        public const byte MaxFixStr = 0xbf; // 191
        public const byte Nil = 0xc0;
        public const byte NeverUsed = 0xc1;
        public const byte False = 0xc2;
        public const byte True = 0xc3;
        public const byte Bin8 = 0xc4;
        public const byte Bin16 = 0xc5;
        public const byte Bin32 = 0xc6;
        public const byte Ext8 = 0xc7;
        public const byte Ext16 = 0xc8;
        public const byte Ext32 = 0xc9;
        public const byte Float32 = 0xca;
        public const byte Float64 = 0xcb;
        public const byte UInt8 = 0xcc;
        public const byte UInt16 = 0xcd;
        public const byte UInt32 = 0xce;
        public const byte UInt64 = 0xcf;
        public const byte Int8 = 0xd0;
        public const byte Int16 = 0xd1;
        public const byte Int32 = 0xd2;
        public const byte Int64 = 0xd3;
        public const byte FixExt1 = 0xd4;
        public const byte FixExt2 = 0xd5;
        public const byte FixExt4 = 0xd6;
        public const byte FixExt8 = 0xd7;
        public const byte FixExt16 = 0xd8;
        public const byte Str8 = 0xd9;
        public const byte Str16 = 0xda;
        public const byte Str32 = 0xdb;
        public const byte Array16 = 0xdc;
        public const byte Array32 = 0xdd;
        public const byte Map16 = 0xde;
        public const byte Map32 = 0xdf;
        public const byte MinNegativeFixInt = 0xe0; // 224
        public const byte MaxNegativeFixInt = 0xff; // 255

        private static readonly MessagePackType[] TypeLookupTable = new MessagePackType[256];
        private static readonly string[] FormatNameTable = new string[256];

        static MessagePackCode()
        {
            // Init Lookup Table
            for (int i = MinFixInt; i <= MaxFixInt; i++)
            {
                TypeLookupTable[i] = MessagePackType.Integer;
                FormatNameTable[i] = "positive fixint";
            }

            for (int i = MinFixMap; i <= MaxFixMap; i++)
            {
                TypeLookupTable[i] = MessagePackType.Map;
                FormatNameTable[i] = "fixmap";
            }

            for (int i = MinFixArray; i <= MaxFixArray; i++)
            {
                TypeLookupTable[i] = MessagePackType.Array;
                FormatNameTable[i] = "fixarray";
            }

            for (int i = MinFixStr; i <= MaxFixStr; i++)
            {
                TypeLookupTable[i] = MessagePackType.String;
                FormatNameTable[i] = "fixstr";
            }

            TypeLookupTable[Nil] = MessagePackType.Nil;
            TypeLookupTable[NeverUsed] = MessagePackType.Unknown;
            TypeLookupTable[False] = MessagePackType.Boolean;
            TypeLookupTable[True] = MessagePackType.Boolean;
            TypeLookupTable[Bin8] = MessagePackType.Binary;
            TypeLookupTable[Bin16] = MessagePackType.Binary;
            TypeLookupTable[Bin32] = MessagePackType.Binary;
            TypeLookupTable[Ext8] = MessagePackType.Extension;
            TypeLookupTable[Ext16] = MessagePackType.Extension;
            TypeLookupTable[Ext32] = MessagePackType.Extension;
            TypeLookupTable[Float32] = MessagePackType.Float;
            TypeLookupTable[Float64] = MessagePackType.Float;
            TypeLookupTable[UInt8] = MessagePackType.Integer;
            TypeLookupTable[UInt16] = MessagePackType.Integer;
            TypeLookupTable[UInt32] = MessagePackType.Integer;
            TypeLookupTable[UInt64] = MessagePackType.Integer;
            TypeLookupTable[Int8] = MessagePackType.Integer;
            TypeLookupTable[Int16] = MessagePackType.Integer;
            TypeLookupTable[Int32] = MessagePackType.Integer;
            TypeLookupTable[Int64] = MessagePackType.Integer;
            TypeLookupTable[FixExt1] = MessagePackType.Extension;
            TypeLookupTable[FixExt2] = MessagePackType.Extension;
            TypeLookupTable[FixExt4] = MessagePackType.Extension;
            TypeLookupTable[FixExt8] = MessagePackType.Extension;
            TypeLookupTable[FixExt16] = MessagePackType.Extension;
            TypeLookupTable[Str8] = MessagePackType.String;
            TypeLookupTable[Str16] = MessagePackType.String;
            TypeLookupTable[Str32] = MessagePackType.String;
            TypeLookupTable[Array16] = MessagePackType.Array;
            TypeLookupTable[Array32] = MessagePackType.Array;
            TypeLookupTable[Map16] = MessagePackType.Map;
            TypeLookupTable[Map32] = MessagePackType.Map;

            FormatNameTable[Nil] = "nil";
            FormatNameTable[NeverUsed] = "(never used)";
            FormatNameTable[False] = "false";
            FormatNameTable[True] = "true";
            FormatNameTable[Bin8] = "bin 8";
            FormatNameTable[Bin16] = "bin 16";
            FormatNameTable[Bin32] = "bin 32";
            FormatNameTable[Ext8] = "ext 8";
            FormatNameTable[Ext16] = "ext 16";
            FormatNameTable[Ext32] = "ext 32";
            FormatNameTable[Float32] = "float 32";
            FormatNameTable[Float64] = "float 64";
            FormatNameTable[UInt8] = "uint 8";
            FormatNameTable[UInt16] = "uint 16";
            FormatNameTable[UInt32] = "uint 32";
            FormatNameTable[UInt64] = "uint 64";
            FormatNameTable[Int8] = "int 8";
            FormatNameTable[Int16] = "int 16";
            FormatNameTable[Int32] = "int 32";
            FormatNameTable[Int64] = "int 64";
            FormatNameTable[FixExt1] = "fixext 1";
            FormatNameTable[FixExt2] = "fixext 2";
            FormatNameTable[FixExt4] = "fixext 4";
            FormatNameTable[FixExt8] = "fixext 8";
            FormatNameTable[FixExt16] = "fixext 16";
            FormatNameTable[Str8] = "str 8";
            FormatNameTable[Str16] = "str 16";
            FormatNameTable[Str32] = "str 32";
            FormatNameTable[Array16] = "array 16";
            FormatNameTable[Array32] = "array 32";
            FormatNameTable[Map16] = "map 16";
            FormatNameTable[Map32] = "map 32";

            for (int i = MinNegativeFixInt; i <= MaxNegativeFixInt; i++)
            {
                TypeLookupTable[i] = MessagePackType.Integer;
                FormatNameTable[i] = "negative fixint";
            }
        }

        public static MessagePackType ToMessagePackType(byte code)
        {
            return TypeLookupTable[code];
        }

        public static string ToFormatName(byte code)
        {
            return FormatNameTable[code];
        }

        /// <summary>
        /// Checks whether a given messagepack code represents an integer that might include a sign (i.e. might be a negative number).
        /// </summary>
        /// <param name="code">The messagepack code.</param>
        /// <returns>A boolean value.</returns>
        internal static bool IsSignedInteger(byte code)
        {
            switch (code)
            {
                case Int8:
                case Int16:
                case Int32:
                case Int64:
                    return true;
                default:
                    return code >= MinNegativeFixInt && code <= MaxNegativeFixInt;
            }
        }
    }

    /// <summary>
    /// The officially defined messagepack extension type codes.
    /// </summary>
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    static class ReservedMessagePackExtensionTypeCode
    {
        public const sbyte DateTime = -1;
    }

#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    static class MessagePackRange
    {
        public const int MinFixNegativeInt = -32;
        public const int MaxFixNegativeInt = -1;
        public const int MaxFixPositiveInt = 127;
        public const int MinFixStringLength = 0;
        public const int MaxFixStringLength = 31;
        public const int MaxFixMapCount = 15;
        public const int MaxFixArrayCount = 15;
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackCode.cs.meta
================================================
fileFormatVersion: 2
guid: 5abed96afe37b3c4e8d58b04054129c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackCompression.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace MessagePack
{
    /// <summary>
    /// Identifies the various compression schemes which might be applied at the msgpack level.
    /// </summary>
    public enum MessagePackCompression
    {
        /// <summary>
        /// No compression is applied at the msgpack level.
        /// </summary>
        None,

        /// <summary>
        /// Compresses an entire msgpack sequence as a single lz4 block format.
        /// This is the simple compression that achieves best compression ratio,
        /// at the cost of copying the entire sequence when necessary to get contiguous memory.
        /// </summary>
        /// <remarks>
        /// Uses msgpack type code ext99 and is compatible with v1 of this library.
        /// </remarks>
        /// <devremarks>
        /// See also ThisLibraryExtensionTypeCodes.Lz4Block
        /// </devremarks>
        Lz4Block,

        /// <summary>
        /// Compresses an entire msgpack sequence as a array of lz4 block format.
        /// This is compressed/decompressed in chunks that do not consume LOH,
        /// but the compression ratio is slightly sacrificed.
        /// </summary>
        /// <remarks>
        /// Uses msgpack type code ext98 in array.
        /// </remarks>
        /// <devremarks>
        /// See also ThisLibraryExtensionTypeCodes.Lz4BlockArray
        /// </devremarks>
        Lz4BlockArray,
    }

#pragma warning disable SA1649 // File name should match first type name

    /// <summary>
    /// Extensions for <see cref="MessagePackCompression"/>.
    /// </summary>
    internal static class MessagePackCompressionExtensions
    {
        public static bool IsCompression(this MessagePackCompression compression)
        {
            return compression != MessagePackCompression.None;
        }
    }

#pragma warning restore SA1649 // File name should match first type name
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackCompression.cs.meta
================================================
fileFormatVersion: 2
guid: 726b009260cea9e45a7c8541e288ca31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackReader.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using MessagePack.Internal;

namespace MessagePack
{
    /// <summary>
    /// A primitive types reader for the MessagePack format.
    /// </summary>
    /// <remarks>
    /// <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
    /// </remarks>
    /// <exception cref="MessagePackSerializationException">Thrown when reading methods fail due to invalid data.</exception>
    /// <exception cref="EndOfStreamException">Thrown by reading methods when there are not enough bytes to read the required value.</exception>
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    ref partial struct MessagePackReader
    {
        /// <summary>
        /// The reader over the sequence.
        /// </summary>
        private SequenceReader<byte> reader;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackReader"/> struct.
        /// </summary>
        /// <param name="memory">The buffer to read from.</param>
        public MessagePackReader(ReadOnlyMemory<byte> memory)
            : this()
        {
            this.reader = new SequenceReader<byte>(memory);
            this.Depth = 0;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackReader"/> struct.
        /// </summary>
        /// <param name="readOnlySequence">The sequence to read from.</param>
        public MessagePackReader(in ReadOnlySequence<byte> readOnlySequence)
            : this()
        {
            this.reader = new SequenceReader<byte>(readOnlySequence);
            this.Depth = 0;
        }

        /// <summary>
        /// Gets or sets the cancellation token for this deserialization operation.
        /// </summary>
        public CancellationToken CancellationToken { get; set; }

        /// <summary>
        /// Gets or sets the present depth of the object graph being deserialized.
        /// </summary>
        public int Depth { get; set; }

        /// <summary>
        /// Gets the <see cref="ReadOnlySequence{T}"/> originally supplied to the constructor.
        /// </summary>
        public ReadOnlySequence<byte> Sequence => this.reader.Sequence;

        /// <summary>
        /// Gets the current position of the reader within <see cref="Sequence"/>.
        /// </summary>
        public SequencePosition Position => this.reader.Position;

        /// <summary>
        /// Gets the number of bytes consumed by the reader.
        /// </summary>
        public long Consumed => this.reader.Consumed;

        /// <summary>
        /// Gets a value indicating whether the reader is at the end of the sequence.
        /// </summary>
        public bool End => this.reader.End;

        /// <summary>
        /// Gets a value indicating whether the reader position is pointing at a nil value.
        /// </summary>
        /// <exception cref="EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        public bool IsNil => this.NextCode == MessagePackCode.Nil;

        /// <summary>
        /// Gets the next message pack type to be read.
        /// </summary>
        public MessagePackType NextMessagePackType => MessagePackCode.ToMessagePackType(this.NextCode);

        /// <summary>
        /// Gets the type of the next MessagePack block.
        /// </summary>
        /// <exception cref="EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        /// <remarks>
        /// See <see cref="MessagePackCode"/> for valid message pack codes and ranges.
        /// </remarks>
        public byte NextCode
        {
            get
            {
                ThrowInsufficientBufferUnless(this.reader.TryPeek(out byte code));
                return code;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackReader"/> struct,
        /// with the same settings as this one, but with its own buffer to read from.
        /// </summary>
        /// <param name="readOnlySequence">The sequence to read from.</param>
        /// <returns>The new reader.</returns>
        public MessagePackReader Clone(in ReadOnlySequence<byte> readOnlySequence) => new MessagePackReader(readOnlySequence)
        {
            CancellationToken = this.CancellationToken,
            Depth = this.Depth,
        };

        /// <summary>
        /// Creates a new <see cref="MessagePackReader"/> at this reader's current position.
        /// The two readers may then be used independently without impacting each other.
        /// </summary>
        /// <returns>A new <see cref="MessagePackReader"/>.</returns>
        /// <devremarks>
        /// Since this is a struct, copying it completely is as simple as returning itself
        /// from a property that isn't a "ref return" property.
        /// </devremarks>
        public MessagePackReader CreatePeekReader() => this;

        /// <summary>
        /// Advances the reader to the next MessagePack primitive to be read.
        /// </summary>
        /// <remarks>
        /// The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
        /// To get the raw MessagePack sequence that was skipped, use <see cref="ReadRaw()"/> instead.
        /// </remarks>
        public void Skip() => ThrowInsufficientBufferUnless(this.TrySkip());

        /// <summary>
        /// Advances the reader to the next MessagePack primitive to be read.
        /// </summary>
        /// <returns><c>true</c> if the entire structure beginning at the current <see cref="Position"/> is found in the <see cref="Sequence"/>; <c>false</c> otherwise.</returns>
        /// <remarks>
        /// The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
        /// To get the raw MessagePack sequence that was skipped, use <see cref="ReadRaw()"/> instead.
        /// WARNING: when false is returned, the position of the reader is undefined.
        /// </remarks>
        internal bool TrySkip()
        {
            if (this.reader.Remaining == 0)
            {
                return false;
            }

            byte code = this.NextCode;
            switch (code)
            {
                case MessagePackCode.Nil:
                case MessagePackCode.True:
                case MessagePackCode.False:
                    return this.reader.TryAdvance(1);
                case MessagePackCode.Int8:
                case MessagePackCode.UInt8:
                    return this.reader.TryAdvance(2);
                case MessagePackCode.Int16:
                case MessagePackCode.UInt16:
                    return this.reader.TryAdvance(3);
                case MessagePackCode.Int32:
                case MessagePackCode.UInt32:
                case MessagePackCode.Float32:
                    return this.reader.TryAdvance(5);
                case MessagePackCode.Int64:
                case MessagePackCode.UInt64:
                case MessagePackCode.Float64:
                    return this.reader.TryAdvance(9);
                case MessagePackCode.Map16:
                case MessagePackCode.Map32:
                    return this.TrySkipNextMap();
                case MessagePackCode.Array16:
                case MessagePackCode.Array32:
                    return this.TrySkipNextArray();
                case MessagePackCode.Str8:
                case MessagePackCode.Str16:
                case MessagePackCode.Str32:
                    return this.TryGetStringLengthInBytes(out int length) && this.reader.TryAdvance(length);
                case MessagePackCode.Bin8:
                case MessagePackCode.Bin16:
                case MessagePackCode.Bin32:
                    return this.TryGetBytesLength(out length) && this.reader.TryAdvance(length);
                case MessagePackCode.FixExt1:
                case MessagePackCode.FixExt2:
                case MessagePackCode.FixExt4:
                case MessagePackCode.FixExt8:
                case MessagePackCode.FixExt16:
                case MessagePackCode.Ext8:
                case MessagePackCode.Ext16:
                case MessagePackCode.Ext32:
                    return this.TryReadExtensionFormatHeader(out ExtensionHeader header) && this.reader.TryAdvance(header.Length);
                default:
                    if ((code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt) ||
                        (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt))
                    {
                        return this.reader.TryAdvance(1);
                    }

                    if (code >= MessagePackCode.MinFixMap && code <= MessagePackCode.MaxFixMap)
                    {
                        return this.TrySkipNextMap();
                    }

                    if (code >= MessagePackCode.MinFixArray && code <= MessagePackCode.MaxFixArray)
                    {
                        return this.TrySkipNextArray();
                    }

                    if (code >= MessagePackCode.MinFixStr && code <= MessagePackCode.MaxFixStr)
                    {
                        return this.TryGetStringLengthInBytes(out length) && this.reader.TryAdvance(length);
                    }

                    // We don't actually expect to ever hit this point, since every code is supported.
                    Debug.Fail("Missing handler for code: " + code);
                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads a <see cref="MessagePackCode.Nil"/> value.
        /// </summary>
        /// <returns>A nil value.</returns>
        public Nil ReadNil()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            return code == MessagePackCode.Nil
                ? Nil.Default
                : throw ThrowInvalidCode(code);
        }

        /// <summary>
        /// Reads nil if it is the next token.
        /// </summary>
        /// <returns><c>true</c> if the next token was nil; <c>false</c> otherwise.</returns>
        /// <exception cref="EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryReadNil()
        {
            if (this.NextCode == MessagePackCode.Nil)
            {
                this.reader.Advance(1);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads a sequence of bytes without any decoding.
        /// </summary>
        /// <param name="length">The number of bytes to read.</param>
        /// <returns>The sequence of bytes read.</returns>
        public ReadOnlySequence<byte> ReadRaw(long length)
        {
            try
            {
                ReadOnlySequence<byte> result = this.reader.Sequence.Slice(this.reader.Position, length);
                this.reader.Advance(length);
                return result;
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw ThrowNotEnoughBytesException(ex);
            }
        }

        /// <summary>
        /// Reads the next MessagePack primitive.
        /// </summary>
        /// <returns>The raw MessagePack sequence.</returns>
        /// <remarks>
        /// The entire primitive is read, including content of maps or arrays, or any other type with payloads.
        /// </remarks>
        public ReadOnlySequence<byte> ReadRaw()
        {
            SequencePosition initialPosition = this.Position;
            this.Skip();
            return this.Sequence.Slice(initialPosition, this.Position);
        }

        /// <summary>
        /// Read an array header from
        /// <see cref="MessagePackCode.Array16"/>,
        /// <see cref="MessagePackCode.Array32"/>, or
        /// some built-in code between <see cref="MessagePackCode.MinFixArray"/> and <see cref="MessagePackCode.MaxFixArray"/>.
        /// </summary>
        /// <exception cref="EndOfStreamException">
        /// Thrown if the header cannot be read in the bytes left in the <see cref="Sequence"/>
        /// or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
        /// </exception>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        public int ReadArrayHeader()
        {
            ThrowInsufficientBufferUnless(this.TryReadArrayHeader(out int count));

            // Protect against corrupted or mischievious data that may lead to allocating way too much memory.
            // We allow for each primitive to be the minimal 1 byte in size.
            // Formatters that know each element is larger can optionally add a stronger check.
            ThrowInsufficientBufferUnless(this.reader.Remaining >= count);

            return count;
        }

        /// <summary>
        /// Reads an array header from
        /// <see cref="MessagePackCode.Array16"/>,
        /// <see cref="MessagePackCode.Array32"/>, or
        /// some built-in code between <see cref="MessagePackCode.MinFixArray"/> and <see cref="MessagePackCode.MaxFixArray"/>
        /// if there is sufficient buffer to read it.
        /// </summary>
        /// <param name="count">Receives the number of elements in the array if the entire array header could be read.</param>
        /// <returns><c>true</c> if there was sufficient buffer and an array header was found; <c>false</c> if the buffer incompletely describes an array header.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        /// <remarks>
        /// When this method returns <c>false</c> the position of the reader is left in an undefined position.
        /// The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryReadArrayHeader(out int count)
        {
            count = -1;
            if (!this.reader.TryRead(out byte code))
            {
                return false;
            }

            switch (code)
            {
                case MessagePackCode.Array16:
                    if (!this.reader.TryReadBigEndian(out short shortValue))
                    {
                        return false;
                    }

                    count = unchecked((ushort)shortValue);
                    break;
                case MessagePackCode.Array32:
                    if (!this.reader.TryReadBigEndian(out int intValue))
                    {
                        return false;
                    }

                    count = intValue;
                    break;
                default:
                    if (code >= MessagePackCode.MinFixArray && code <= MessagePackCode.MaxFixArray)
                    {
                        count = code & 0xF;
                        break;
                    }

                    throw ThrowInvalidCode(code);
            }

            return true;
        }

        /// <summary>
        /// Read a map header from
        /// <see cref="MessagePackCode.Map16"/>,
        /// <see cref="MessagePackCode.Map32"/>, or
        /// some built-in code between <see cref="MessagePackCode.MinFixMap"/> and <see cref="MessagePackCode.MaxFixMap"/>.
        /// </summary>
        /// <returns>The number of key=value pairs in the map.</returns>
        /// <exception cref="EndOfStreamException">
        /// Thrown if the header cannot be read in the bytes left in the <see cref="Sequence"/>
        /// or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
        /// </exception>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        public int ReadMapHeader()
        {
            ThrowInsufficientBufferUnless(this.TryReadMapHeader(out int count));

            // Protect against corrupted or mischievious data that may lead to allocating way too much memory.
            // We allow for each primitive to be the minimal 1 byte in size, and we have a key=value map, so that's 2 bytes.
            // Formatters that know each element is larger can optionally add a stronger check.
            ThrowInsufficientBufferUnless(this.reader.Remaining >= count * 2);

            return count;
        }

        /// <summary>
        /// Reads a map header from
        /// <see cref="MessagePackCode.Map16"/>,
        /// <see cref="MessagePackCode.Map32"/>, or
        /// some built-in code between <see cref="MessagePackCode.MinFixMap"/> and <see cref="MessagePackCode.MaxFixMap"/>
        /// if there is sufficient buffer to read it.
        /// </summary>
        /// <param name="count">Receives the number of key=value pairs in the map if the entire map header can be read.</param>
        /// <returns><c>true</c> if there was sufficient buffer and a map header was found; <c>false</c> if the buffer incompletely describes an map header.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        /// <remarks>
        /// When this method returns <c>false</c> the position of the reader is left in an undefined position.
        /// The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
        /// </remarks>
        public bool TryReadMapHeader(out int count)
        {
            count = -1;
            if (!this.reader.TryRead(out byte code))
            {
                return false;
            }

            switch (code)
            {
                case MessagePackCode.Map16:
                    if (!this.reader.TryReadBigEndian(out short shortValue))
                    {
                        return false;
                    }

                    count = unchecked((ushort)shortValue);
                    break;
                case MessagePackCode.Map32:
                    if (!this.reader.TryReadBigEndian(out int intValue))
                    {
                        return false;
                    }

                    count = intValue;
                    break;
                default:
                    if (code >= MessagePackCode.MinFixMap && code <= MessagePackCode.MaxFixMap)
                    {
                        count = (byte)(code & 0xF);
                        break;
                    }

                    throw ThrowInvalidCode(code);
            }

            return true;
        }

        /// <summary>
        /// Reads a boolean value from either a <see cref="MessagePackCode.False"/> or <see cref="MessagePackCode.True"/>.
        /// </summary>
        /// <returns>The value.</returns>
        public bool ReadBoolean()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));
            switch (code)
            {
                case MessagePackCode.True:
                    return true;
                case MessagePackCode.False:
                    return false;
                default:
                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads a <see cref="char"/> from any of:
        /// <see cref="MessagePackCode.UInt8"/>,
        /// <see cref="MessagePackCode.UInt16"/>,
        /// or anything between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>.
        /// </summary>
        /// <returns>A character.</returns>
        public char ReadChar() => (char)this.ReadUInt16();

        /// <summary>
        /// Reads an <see cref="float"/> value from any value encoded with:
        /// <see cref="MessagePackCode.Float32"/>,
        /// <see cref="MessagePackCode.Int8"/>,
        /// <see cref="MessagePackCode.Int16"/>,
        /// <see cref="MessagePackCode.Int32"/>,
        /// <see cref="MessagePackCode.Int64"/>,
        /// <see cref="MessagePackCode.UInt8"/>,
        /// <see cref="MessagePackCode.UInt16"/>,
        /// <see cref="MessagePackCode.UInt32"/>,
        /// <see cref="MessagePackCode.UInt64"/>,
        /// or some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// or some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>.
        /// </summary>
        /// <returns>The value.</returns>
        public unsafe float ReadSingle()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.Float32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out float floatValue));
                    return floatValue;
                case MessagePackCode.Float64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out double doubleValue));
                    return (float)doubleValue;
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteValue));
                    return sbyteValue;
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortValue));
                    return shortValue;
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intValue));
                    return intValue;
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longValue));
                    return longValue;
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteValue));
                    return byteValue;
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortValue));
                    return ushortValue;
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintValue));
                    return uintValue;
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongValue));
                    return ulongValue;
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return unchecked((sbyte)code);
                    }
                    else if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="double"/> value from any value encoded with:
        /// <see cref="MessagePackCode.Float64"/>,
        /// <see cref="MessagePackCode.Float32"/>,
        /// <see cref="MessagePackCode.Int8"/>,
        /// <see cref="MessagePackCode.Int16"/>,
        /// <see cref="MessagePackCode.Int32"/>,
        /// <see cref="MessagePackCode.Int64"/>,
        /// <see cref="MessagePackCode.UInt8"/>,
        /// <see cref="MessagePackCode.UInt16"/>,
        /// <see cref="MessagePackCode.UInt32"/>,
        /// <see cref="MessagePackCode.UInt64"/>,
        /// or some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// or some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>.
        /// </summary>
        /// <returns>The value.</returns>
        public unsafe double ReadDouble()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.Float64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out double doubleValue));
                    return doubleValue;
                case MessagePackCode.Float32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out float floatValue));
                    return floatValue;
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteValue));
                    return unchecked((sbyte)byteValue);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortValue));
                    return shortValue;
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intValue));
                    return intValue;
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longValue));
                    return longValue;
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byteValue));
                    return byteValue;
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out shortValue));
                    return unchecked((ushort)shortValue);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out intValue));
                    return unchecked((uint)intValue);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out longValue));
                    return unchecked((ulong)longValue);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return unchecked((sbyte)code);
                    }
                    else if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads a <see cref="DateTime"/> from a value encoded with
        /// <see cref="MessagePackCode.FixExt4"/>,
        /// <see cref="MessagePackCode.FixExt8"/>, or
        /// <see cref="MessagePackCode.Ext8"/>.
        /// Expects extension type code <see cref="ReservedMessagePackExtensionTypeCode.DateTime"/>.
        /// </summary>
        /// <returns>The value.</returns>
        public DateTime ReadDateTime() => this.ReadDateTime(this.ReadExtensionFormatHeader());

        /// <summary>
        /// Reads a <see cref="DateTime"/> from a value encoded with
        /// <see cref="MessagePackCode.FixExt4"/>,
        /// <see cref="MessagePackCode.FixExt8"/>,
        /// <see cref="MessagePackCode.Ext8"/>.
        /// Expects extension type code <see cref="ReservedMessagePackExtensionTypeCode.DateTime"/>.
        /// </summary>
        /// <param name="header">The extension header that was already read.</param>
        /// <returns>The value.</returns>
        public DateTime ReadDateTime(ExtensionHeader header)
        {
            if (header.TypeCode != ReservedMessagePackExtensionTypeCode.DateTime)
            {
                throw new MessagePackSerializationException(string.Format("Extension TypeCode is invalid. typeCode: {0}", header.TypeCode));
            }

            switch (header.Length)
            {
                case 4:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intValue));
                    return DateTimeConstants.UnixEpoch.AddSeconds(unchecked((uint)intValue));
                case 8:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longValue));
                    ulong ulongValue = unchecked((ulong)longValue);
                    long nanoseconds = (long)(ulongValue >> 34);
                    ulong seconds = ulongValue & 0x00000003ffffffffL;
                    return DateTimeConstants.UnixEpoch.AddSeconds(seconds).AddTicks(nanoseconds / DateTimeConstants.NanosecondsPerTick);
                case 12:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out intValue));
                    nanoseconds = unchecked((uint)intValue);
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out longValue));
                    return DateTimeConstants.UnixEpoch.AddSeconds(longValue).AddTicks(nanoseconds / DateTimeConstants.NanosecondsPerTick);
                default:
                    throw new MessagePackSerializationException($"Length of extension was {header.Length}. Either 4 or 8 were expected.");
            }
        }

        /// <summary>
        /// Reads a span of bytes, whose length is determined by a header of one of these types:
        /// <see cref="MessagePackCode.Bin8"/>,
        /// <see cref="MessagePackCode.Bin16"/>,
        /// <see cref="MessagePackCode.Bin32"/>,
        /// or to support OldSpec compatibility:
        /// <see cref="MessagePackCode.Str16"/>,
        /// <see cref="MessagePackCode.Str32"/>,
        /// or something between <see cref="MessagePackCode.MinFixStr"/> and <see cref="MessagePackCode.MaxFixStr"/>.
        /// </summary>
        /// <returns>
        /// A sequence of bytes, or <c>null</c> if the read token is <see cref="MessagePackCode.Nil"/>.
        /// The data is a slice from the original sequence passed to this reader's constructor.
        /// </returns>
        public ReadOnlySequence<byte>? ReadBytes()
        {
            if (this.TryReadNil())
            {
                return null;
            }

            int length = this.GetBytesLength();
            ThrowInsufficientBufferUnless(this.reader.Remaining >= length);
            ReadOnlySequence<byte> result = this.reader.Sequence.Slice(this.reader.Position, length);
            this.reader.Advance(length);
            return result;
        }

        /// <summary>
        /// Reads a string of bytes, whose length is determined by a header of one of these types:
        /// <see cref="MessagePackCode.Str8"/>,
        /// <see cref="MessagePackCode.Str16"/>,
        /// <see cref="MessagePackCode.Str32"/>,
        /// or a code between <see cref="MessagePackCode.MinFixStr"/> and <see cref="MessagePackCode.MaxFixStr"/>.
        /// </summary>
        /// <returns>
        /// The sequence of bytes, or <c>null</c> if the read token is <see cref="MessagePackCode.Nil"/>.
        /// The data is a slice from the original sequence passed to this reader's constructor.
        /// </returns>
        public ReadOnlySequence<byte>? ReadStringSequence()
        {
            if (this.TryReadNil())
            {
                return null;
            }

            int length = this.GetStringLengthInBytes();
            ThrowInsufficientBufferUnless(this.reader.Remaining >= length);
            ReadOnlySequence<byte> result = this.reader.Sequence.Slice(this.reader.Position, length);
            this.reader.Advance(length);
            return result;
        }

        /// <summary>
        /// Reads a string of bytes, whose length is determined by a header of one of these types:
        /// <see cref="MessagePackCode.Str8"/>,
        /// <see cref="MessagePackCode.Str16"/>,
        /// <see cref="MessagePackCode.Str32"/>,
        /// or a code between <see cref="MessagePackCode.MinFixStr"/> and <see cref="MessagePackCode.MaxFixStr"/>.
        /// </summary>
        /// <param name="span">Receives the span to the string.</param>
        /// <returns>
        /// <c>true</c> if the string is contiguous in memory such that it could be set as a single span.
        /// <c>false</c> if the read token is <see cref="MessagePackCode.Nil"/> or the string is not in a contiguous span.
        /// </returns>
        /// <remarks>
        /// Callers should generally be prepared for a <c>false</c> result and failover to calling <see cref="ReadStringSequence"/>
        /// which can represent a <c>null</c> result and handle strings that are not contiguous in memory.
        /// </remarks>
        public bool TryReadStringSpan(out ReadOnlySpan<byte> span)
        {
            if (this.IsNil)
            {
                span = default;
                return false;
            }

            long oldPosition = this.reader.Consumed;
            int length = this.GetStringLengthInBytes();
            ThrowInsufficientBufferUnless(this.reader.Remaining >= length);

            if (this.reader.CurrentSpanIndex + length <= this.reader.CurrentSpan.Length)
            {
                span = this.reader.CurrentSpan.Slice(this.reader.CurrentSpanIndex, length);
                this.reader.Advance(length);
                return true;
            }
            else
            {
                this.reader.Rewind(this.reader.Consumed - oldPosition);
                span = default;
                return false;
            }
        }

        /// <summary>
        /// Reads a string, whose length is determined by a header of one of these types:
        /// <see cref="MessagePackCode.Str8"/>,
        /// <see cref="MessagePackCode.Str16"/>,
        /// <see cref="MessagePackCode.Str32"/>,
        /// or a code between <see cref="MessagePackCode.MinFixStr"/> and <see cref="MessagePackCode.MaxFixStr"/>.
        /// </summary>
        /// <returns>A string, or <c>null</c> if the current msgpack token is <see cref="MessagePackCode.Nil"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ReadString()
        {
            if (this.TryReadNil())
            {
                return null;
            }

            int byteLength = this.GetStringLengthInBytes();

            ReadOnlySpan<byte> unreadSpan = this.reader.UnreadSpan;
            //UnityEngine.Debug.Log(reader.CurrentSpan[0]);
            //UnityEngine.Debug.Log(unreadSpan[0]);
            if (unreadSpan.Length >= byteLength)
            {
                // Fast path: all bytes to decode appear in the same span.
                string value = StringEncoding.UTF8.GetString(unreadSpan.Slice(0, byteLength));
                this.reader.Advance(byteLength);
                return value;
            }
            else
            {
                return this.ReadStringSlow(byteLength);
            }
        }

        /// <summary>
        /// Reads an extension format header, based on one of these codes:
        /// <see cref="MessagePackCode.FixExt1"/>,
        /// <see cref="MessagePackCode.FixExt2"/>,
        /// <see cref="MessagePackCode.FixExt4"/>,
        /// <see cref="MessagePackCode.FixExt8"/>,
        /// <see cref="MessagePackCode.FixExt16"/>,
        /// <see cref="MessagePackCode.Ext8"/>,
        /// <see cref="MessagePackCode.Ext16"/>, or
        /// <see cref="MessagePackCode.Ext32"/>.
        /// </summary>
        /// <returns>The extension header.</returns>
        /// <exception cref="EndOfStreamException">
        /// Thrown if the header cannot be read in the bytes left in the <see cref="Sequence"/>
        /// or if it is clear that there are insufficient bytes remaining after the header to include all the bytes the header claims to be there.
        /// </exception>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        public ExtensionHeader ReadExtensionFormatHeader()
        {
            ThrowInsufficientBufferUnless(this.TryReadExtensionFormatHeader(out ExtensionHeader header));

            // Protect against corrupted or mischievious data that may lead to allocating way too much memory.
            ThrowInsufficientBufferUnless(this.reader.Remaining >= header.Length);

            return header;
        }

        /// <summary>
        /// Reads an extension format header, based on one of these codes:
        /// <see cref="MessagePackCode.FixExt1"/>,
        /// <see cref="MessagePackCode.FixExt2"/>,
        /// <see cref="MessagePackCode.FixExt4"/>,
        /// <see cref="MessagePackCode.FixExt8"/>,
        /// <see cref="MessagePackCode.FixExt16"/>,
        /// <see cref="MessagePackCode.Ext8"/>,
        /// <see cref="MessagePackCode.Ext16"/>, or
        /// <see cref="MessagePackCode.Ext32"/>
        /// if there is sufficient buffer to read it.
        /// </summary>
        /// <param name="extensionHeader">Receives the extension header if the remaining bytes in the <see cref="Sequence"/> fully describe the header.</param>
        /// <returns>The number of key=value pairs in the map.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        /// <remarks>
        /// When this method returns <c>false</c> the position of the reader is left in an undefined position.
        /// The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
        /// </remarks>
        public bool TryReadExtensionFormatHeader(out ExtensionHeader extensionHeader)
        {
            extensionHeader = default;
            if (!this.reader.TryRead(out byte code))
            {
                return false;
            }

            uint length;
            switch (code)
            {
                case MessagePackCode.FixExt1:
                    length = 1;
                    break;
                case MessagePackCode.FixExt2:
                    length = 2;
                    break;
                case MessagePackCode.FixExt4:
                    length = 4;
                    break;
                case MessagePackCode.FixExt8:
                    length = 8;
                    break;
                case MessagePackCode.FixExt16:
                    length = 16;
                    break;
                case MessagePackCode.Ext8:
                    if (!this.reader.TryRead(out byte byteLength))
                    {
                        return false;
                    }

                    length = byteLength;
                    break;
                case MessagePackCode.Ext16:
                    if (!this.reader.TryReadBigEndian(out short shortLength))
                    {
                        return false;
                    }

                    length = unchecked((ushort)shortLength);
                    break;
                case MessagePackCode.Ext32:
                    if (!this.reader.TryReadBigEndian(out int intLength))
                    {
                        return false;
                    }

                    length = unchecked((uint)intLength);
                    break;
                default:
                    throw ThrowInvalidCode(code);
            }

            if (!this.reader.TryRead(out byte typeCode))
            {
                return false;
            }

            extensionHeader = new ExtensionHeader(unchecked((sbyte)typeCode), length);
            return true;
        }

        /// <summary>
        /// Reads an extension format header and data, based on one of these codes:
        /// <see cref="MessagePackCode.FixExt1"/>,
        /// <see cref="MessagePackCode.FixExt2"/>,
        /// <see cref="MessagePackCode.FixExt4"/>,
        /// <see cref="MessagePackCode.FixExt8"/>,
        /// <see cref="MessagePackCode.FixExt16"/>,
        /// <see cref="MessagePackCode.Ext8"/>,
        /// <see cref="MessagePackCode.Ext16"/>, or
        /// <see cref="MessagePackCode.Ext32"/>.
        /// </summary>
        /// <returns>
        /// The extension format.
        /// The data is a slice from the original sequence passed to this reader's constructor.
        /// </returns>
        public ExtensionResult ReadExtensionFormat()
        {
            ExtensionHeader header = this.ReadExtensionFormatHeader();
            try
            {
                ReadOnlySequence<byte> data = this.reader.Sequence.Slice(this.reader.Position, header.Length);
                this.reader.Advance(header.Length);
                return new ExtensionResult(header.TypeCode, data);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw ThrowNotEnoughBytesException(ex);
            }
        }

        /// <summary>
        /// Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
        /// the promised data.
        /// </summary>
        private static EndOfStreamException ThrowNotEnoughBytesException() => throw new EndOfStreamException();

        /// <summary>
        /// Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
        /// the promised data.
        /// </summary>
        private static EndOfStreamException ThrowNotEnoughBytesException(Exception innerException) => throw new EndOfStreamException(new EndOfStreamException().Message, innerException);

        /// <summary>
        /// Throws an <see cref="MessagePackSerializationException"/> explaining an unexpected code was encountered.
        /// </summary>
        /// <param name="code">The code that was encountered.</param>
        /// <returns>Nothing. This method always throws.</returns>
        private static Exception ThrowInvalidCode(byte code)
        {
            throw new MessagePackSerializationException(string.Format("Unexpected msgpack code {0} ({1}) encountered.", code, MessagePackCode.ToFormatName(code)));
        }

        /// <summary>
        /// Throws <see cref="EndOfStreamException"/> if a condition is false.
        /// </summary>
        /// <param name="condition">A boolean value.</param>
        /// <exception cref="EndOfStreamException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        private static void ThrowInsufficientBufferUnless(bool condition)
        {
            if (!condition)
            {
                ThrowNotEnoughBytesException();
            }
        }

        private int GetBytesLength()
        {
            ThrowInsufficientBufferUnless(this.TryGetBytesLength(out int length));
            return length;
        }

        private bool TryGetBytesLength(out int length)
        {
            if (!this.reader.TryRead(out byte code))
            {
                length = 0;
                return false;
            }

            // In OldSpec mode, Bin didn't exist, so Str was used. Str8 didn't exist either.
            switch (code)
            {
                case MessagePackCode.Bin8:
                    if (this.reader.TryRead(out byte byteLength))
                    {
                        length = byteLength;
                        return true;
                    }

                    break;
                case MessagePackCode.Bin16:
                case MessagePackCode.Str16: // OldSpec compatibility
                    if (this.reader.TryReadBigEndian(out short shortLength))
                    {
                        length = unchecked((ushort)shortLength);
                        return true;
                    }

                    break;
                case MessagePackCode.Bin32:
                case MessagePackCode.Str32: // OldSpec compatibility
                    if (this.reader.TryReadBigEndian(out length))
                    {
                        return true;
                    }

                    break;
                default:
                    // OldSpec compatibility
                    if (code >= MessagePackCode.MinFixStr && code <= MessagePackCode.MaxFixStr)
                    {
                        length = code & 0x1F;
                        return true;
                    }

                    throw ThrowInvalidCode(code);
            }

            length = 0;
            return false;
        }

        /// <summary>
        /// Gets the length of the next string.
        /// </summary>
        /// <param name="length">Receives the length of the next string, if there were enough bytes to read it.</param>
        /// <returns><c>true</c> if there were enough bytes to read the length of the next string; <c>false</c> otherwise.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool TryGetStringLengthInBytes(out int length)
        {
            if (!this.reader.TryRead(out byte code))
            {
                length = 0;
                return false;
            }

            if (code >= MessagePackCode.MinFixStr && code <= MessagePackCode.MaxFixStr)
            {
                length = code & 0x1F;
                return true;
            }

            return this.TryGetStringLengthInBytesSlow(code, out length);
        }

        /// <summary>
        /// Gets the length of the next string.
        /// </summary>
        /// <returns>The length of the next string.</returns>
        private int GetStringLengthInBytes()
        {
            ThrowInsufficientBufferUnless(this.TryGetStringLengthInBytes(out int length));
            return length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool TryGetStringLengthInBytesSlow(byte code, out int length)
        {
            switch (code)
            {
                case MessagePackCode.Str8:
                    if (this.reader.TryRead(out byte byteValue))
                    {
                        length = byteValue;
                        return true;
                    }

                    break;
                case MessagePackCode.Str16:
                    if (this.reader.TryReadBigEndian(out short shortValue))
                    {
                        length = unchecked((ushort)shortValue);
                        return true;
                    }

                    break;
                case MessagePackCode.Str32:
                    if (this.reader.TryReadBigEndian(out int intValue))
                    {
                        length = intValue;
                        return true;
                    }

                    break;
                default:
                    if (code >= MessagePackCode.MinFixStr && code <= MessagePackCode.MaxFixStr)
                    {
                        length = code & 0x1F;
                        return true;
                    }

                    throw ThrowInvalidCode(code);
            }

            length = 0;
            return false;
        }

        /// <summary>
        /// Reads a string assuming that it is spread across multiple spans in the <see cref="ReadOnlySequence{T}"/>.
        /// </summary>
        /// <param name="byteLength">The length of the string to be decoded, in bytes.</param>
        /// <returns>The decoded string.</returns>
        private string ReadStringSlow(int byteLength)
        {
            ThrowInsufficientBufferUnless(this.reader.Remaining >= byteLength);

            // We need to decode bytes incrementally across multiple spans.
            int maxCharLength = StringEncoding.UTF8.GetMaxCharCount(byteLength);
            char[] charArray = ArrayPool<char>.Shared.Rent(maxCharLength);
            System.Text.Decoder decoder = StringEncoding.UTF8.GetDecoder();

            int remainingByteLength = byteLength;
            int initializedChars = 0;
            while (remainingByteLength > 0)
            {
                int bytesRead = Math.Min(remainingByteLength, this.reader.UnreadSpan.Length);
                remainingByteLength -= bytesRead;
                bool flush = remainingByteLength == 0;
#if NETCOREAPP
                initializedChars += decoder.GetChars(this.reader.UnreadSpan.Slice(0, bytesRead), charArray.AsSpan(initializedChars), flush);
#else
                unsafe
                {
                    fixed (byte* pUnreadSpan = this.reader.UnreadSpan)
                    fixed (char* pCharArray = &charArray[initializedChars])
                    {
                        initializedChars += decoder.GetChars(pUnreadSpan, bytesRead, pCharArray, charArray.Length - initializedChars, flush);
                    }
                }
#endif
                this.reader.Advance(bytesRead);
            }

            string value = new string(charArray, 0, initializedChars);
            ArrayPool<char>.Shared.Return(charArray);
            return value;
        }

        private bool TrySkipNextArray() => this.TryReadArrayHeader(out int count) && this.TrySkip(count);

        private bool TrySkipNextMap() => this.TryReadMapHeader(out int count) && this.TrySkip(count * 2);

        private bool TrySkip(int count)
        {
            for (int i = 0; i < count; i++)
            {
                if (!this.TrySkip())
                {
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackReader.cs.meta
================================================
fileFormatVersion: 2
guid: 80f6863e06d288f489fcea7b5654b2cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSecurity.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.ExceptionServices;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack
{
    /// <summary>
    /// Settings related to security, particularly relevant when deserializing data from untrusted sources.
    /// </summary>
    public class MessagePackSecurity
    {
        /// <summary>
        /// Gets an instance preconfigured with settings that omit all protections. Useful for deserializing fully-trusted and valid msgpack sequences.
        /// </summary>
        public static readonly MessagePackSecurity TrustedData = new MessagePackSecurity();

        /// <summary>
        /// Gets an instance preconfigured with protections applied with reasonable settings for deserializing untrusted msgpack sequences.
        /// </summary>
        public static readonly MessagePackSecurity UntrustedData = new MessagePackSecurity
        {
            HashCollisionResistant = true,
            MaximumObjectGraphDepth = 500,
        };

        private readonly ObjectFallbackEqualityComparer objectFallbackEqualityComparer;

        private MessagePackSecurity()
        {
            this.objectFallbackEqualityComparer = new ObjectFallbackEqualityComparer(this);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSecurity"/> class
        /// with properties copied from a provided template.
        /// </summary>
        /// <param name="copyFrom">The template to copy from.</param>
        protected MessagePackSecurity(MessagePackSecurity copyFrom)
            : this()
        {
            if (copyFrom is null)
            {
                throw new ArgumentNullException(nameof(copyFrom));
            }

            this.HashCollisionResistant = copyFrom.HashCollisionResistant;
            this.MaximumObjectGraphDepth = copyFrom.MaximumObjectGraphDepth;
        }

        /// <summary>
        /// Gets a value indicating whether data to be deserialized is untrusted and thus should not be allowed to create
        /// dictionaries or other hash-based collections unless the hashed type has a hash collision resistant implementation available.
        /// This can mitigate some denial of service attacks when deserializing untrusted code.
        /// </summary>
        /// <value>
        /// The value is <c>false</c> for <see cref="TrustedData"/> and <c>true</c> for <see cref="UntrustedData"/>.
        /// </value>
        public bool HashCollisionResistant { get; private set; }

        /// <summary>
        /// Gets the maximum depth of an object graph that may be deserialized.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This value can be reduced to avoid a stack overflow that would crash the process when deserializing a msgpack sequence designed to cause deep recursion.
        /// A very short callstack on a thread with 1MB of total stack space might deserialize ~2000 nested arrays before crashing due to a stack overflow.
        /// Since stack space occupied may vary by the kind of object deserialized, a conservative value for this property to defend against stack overflow attacks might be 500.
        /// </para>
        /// </remarks>
        public int MaximumObjectGraphDepth { get; private set; } = int.MaxValue;

        /// <summary>
        /// Gets a copy of these options with the <see cref="MaximumObjectGraphDepth"/> property set to a new value.
        /// </summary>
        /// <param name="maximumObjectGraphDepth">The new value for the <see cref="MaximumObjectGraphDepth"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSecurity WithMaximumObjectGraphDepth(int maximumObjectGraphDepth)
        {
            if (this.MaximumObjectGraphDepth == maximumObjectGraphDepth)
            {
                return this;
            }

            var clone = this.Clone();
            clone.MaximumObjectGraphDepth = maximumObjectGraphDepth;
            return clone;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="HashCollisionResistant"/> property set to a new value.
        /// </summary>
        /// <param name="hashCollisionResistant">The new value for the <see cref="HashCollisionResistant"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSecurity WithHashCollisionResistant(bool hashCollisionResistant)
        {
            if (this.HashCollisionResistant == hashCollisionResistant)
            {
                return this;
            }

            var clone = this.Clone();
            clone.HashCollisionResistant = hashCollisionResistant;
            return clone;
        }

        /// <summary>
        /// Gets an <see cref="IEqualityComparer{T}"/> that is suitable to use with a hash-based collection.
        /// </summary>
        /// <typeparam name="T">The type of key that will be hashed in the collection.</typeparam>
        /// <returns>The <see cref="IEqualityComparer{T}"/> to use.</returns>
        /// <remarks>
        /// When <see cref="HashCollisionResistant"/> is active, this will be a collision resistant instance which may reject certain key types.
        /// When <see cref="HashCollisionResistant"/> is not active, this will be <see cref="EqualityComparer{T}.Default"/>.
        /// </remarks>
        public IEqualityComparer<T> GetEqualityComparer<T>()
        {
            return this.HashCollisionResistant ? GetHashCollisionResistantEqualityComparer<T>() : EqualityComparer<T>.Default;
        }

        /// <summary>
        /// Gets an <see cref="IEqualityComparer"/> that is suitable to use with a hash-based collection.
        /// </summary>
        /// <returns>The <see cref="IEqualityComparer"/> to use.</returns>
        /// <remarks>
        /// When <see cref="HashCollisionResistant"/> is active, this will be a collision resistant instance which may reject certain key types.
        /// When <see cref="HashCollisionResistant"/> is not active, this will be <see cref="EqualityComparer{T}.Default"/>.
        /// </remarks>
        public IEqualityComparer GetEqualityComparer()
        {
            return this.HashCollisionResistant ? GetHashCollisionResistantEqualityComparer() : EqualityComparer<object>.Default;
        }

        /// <summary>
        /// Returns a hash collision resistant equality comparer.
        /// </summary>
        /// <typeparam name="T">The type of key that will be hashed in the collection.</typeparam>
        /// <returns>A hash collision resistant equality comparer.</returns>
        protected virtual IEqualityComparer<T> GetHashCollisionResistantEqualityComparer<T>()
        {
            IEqualityComparer<T> result = null;
            if (typeof(T).GetTypeInfo().IsEnum)
            {
                Type underlyingType = typeof(T).GetTypeInfo().GetEnumUnderlyingType();
                result =
                    underlyingType == typeof(sbyte) ? CollisionResistantHasher<T>.Instance :
                    underlyingType == typeof(byte) ? CollisionResistantHasher<T>.Instance :
                    underlyingType == typeof(short) ? CollisionResistantHasher<T>.Instance :
                    underlyingType == typeof(ushort) ? CollisionResistantHasher<T>.Instance :
                    underlyingType == typeof(int) ? CollisionResistantHasher<T>.Instance :
                    underlyingType == typeof(uint) ? CollisionResistantHasher<T>.Instance :
                    null;
            }
            else
            {
                // For anything 32-bits and under, our fallback base secure hasher is usually adequate since it makes the hash unpredictable.
                // We should have special implementations for any value that is larger than 32-bits in order to make sure
                // that all the data gets hashed securely rather than trivially and predictably compressed into 32-bits before being hashed.
                // We also have to specially handle some 32-bit types (e.g. float) where multiple in-memory representations should hash to the same value.
                // Any type supported by the PrimitiveObjectFormatter should be added here if supporting it as a key in a collection makes sense.
                result =
                    // 32-bits or smaller:
                    typeof(T) == typeof(bool) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(char) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(sbyte) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(byte) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(short) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(ushort) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(int) ? CollisionResistantHasher<T>.Instance :
                    typeof(T) == typeof(uint) ? CollisionResistantHasher<T>.Instance :

                    // Larger than 32-bits (or otherwise require special handling):
                    typeof(T) == typeof(long) ? (IEqualityComparer<T>)Int64EqualityComparer.Instance :
                    typeof(T) == typeof(ulong) ? (IEqualityComparer<T>)UInt64EqualityComparer.Instance :
                    typeof(T) == typeof(float) ? (IEqualityComparer<T>)SingleEqualityComparer.Instance :
                    typeof(T) == typeof(double) ? (IEqualityComparer<T>)DoubleEqualityComparer.Instance :
                    typeof(T) == typeof(string) ? (IEqualityComparer<T>)StringEqualityComparer.Instance :
                    typeof(T) == typeof(Guid) ? (IEqualityComparer<T>)GuidEqualityComparer.Instance :
                    typeof(T) == typeof(DateTime) ? (IEqualityComparer<T>)DateTimeEqualityComparer.Instance :
                    typeof(T) == typeof(DateTimeOffset) ? (IEqualityComparer<T>)DateTimeOffsetEqualityComparer.Instance :
                    typeof(T) == typeof(object) ? (IEqualityComparer<T>)this.objectFallbackEqualityComparer :
                    null;
            }

            // Any type we don't explicitly whitelist here shouldn't be allowed to use as the key in a hash-based collection since it isn't known to be hash resistant.
            // This method can of course be overridden to add more hash collision resistant type support, or the deserializing party can indicate that the data is Trusted
            // so that this method doesn't even get called.
            return result ?? throw new TypeAccessException($"No hash-resistant equality comparer available for type: {typeof(T)}");
        }

        /// <summary>
        /// Checks the depth of the deserializing graph and increments it by 1.
        /// </summary>
        /// <param name="reader">The reader that is involved in deserialization.</param>
        /// <remarks>
        /// Callers should decrement <see cref="MessagePackReader.Depth"/> after exiting that edge in the graph.
        /// </remarks>
        /// <exception cref="InsufficientExecutionStackException">Thrown if <see cref="MessagePackReader.Depth"/> is already at or exceeds <see cref="MaximumObjectGraphDepth"/>.</exception>
        /// <remarks>
        /// Rather than wrap the body of every <see cref="IMessagePackFormatter{T}.Deserialize"/> method,
        /// this should wrap *calls* to these methods. They need not appear in pure "thunk" methods that simply delegate the deserialization to another formatter.
        /// In this way, we can avoid repeatedly incrementing and decrementing the counter when deserializing each element of a collection.
        /// </remarks>
        public void DepthStep(ref MessagePackReader reader)
        {
            if (reader.Depth >= this.MaximumObjectGraphDepth)
            {
                throw new InsufficientExecutionStackException($"This msgpack sequence has an object graph that exceeds the maximum depth allowed of {MaximumObjectGraphDepth}.");
            }

            reader.Depth++;
        }

        /// <summary>
        /// Returns a hash collision resistant equality comparer.
        /// </summary>
        /// <returns>A hash collision resistant equality comparer.</returns>
        protected virtual IEqualityComparer GetHashCollisionResistantEqualityComparer() => (IEqualityComparer)this.GetHashCollisionResistantEqualityComparer<object>();

        /// <summary>
        /// Creates a new instance that is a copy of this one.
        /// </summary>
        /// <remarks>
        /// Derived types should override this method to instantiate their own derived type.
        /// </remarks>
        protected virtual MessagePackSecurity Clone() => new MessagePackSecurity(this);

        /// <summary>
        /// A hash collision resistant implementation of <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <typeparam name="T">The type of key that will be hashed.</typeparam>
        private class CollisionResistantHasher<T> : IEqualityComparer<T>, IEqualityComparer
        {
            internal static readonly CollisionResistantHasher<T> Instance = new CollisionResistantHasher<T>();

            public bool Equals(T x, T y) => EqualityComparer<T>.Default.Equals(x, y);

            bool IEqualityComparer.Equals(object x, object y) => ((IEqualityComparer)EqualityComparer<T>.Default).Equals(x, y);

            public int GetHashCode(object obj) => this.GetHashCode((T)obj);

            public virtual int GetHashCode(T value) => HashCode.Combine(value);
        }

        /// <summary>
        /// A special hash-resistent equality comparer that defers picking the actual implementation
        /// till it can check the runtime type of each value to be hashed.
        /// </summary>
        private class ObjectFallbackEqualityComparer : IEqualityComparer<object>, IEqualityComparer
        {
            private static readonly MethodInfo GetHashCollisionResistantEqualityComparerOpenGenericMethod = typeof(MessagePackSecurity).GetTypeInfo().DeclaredMethods.Single(m => m.Name == nameof(MessagePackSecurity.GetHashCollisionResistantEqualityComparer) && m.IsGenericMethod);
            private readonly MessagePackSecurity security;
            private readonly ThreadsafeTypeKeyHashTable<IEqualityComparer> equalityComparerCache = new ThreadsafeTypeKeyHashTable<IEqualityComparer>();

            internal ObjectFallbackEqualityComparer(MessagePackSecurity security)
            {
                this.security = security ?? throw new ArgumentNullException(nameof(security));
            }

            bool IEqualityComparer<object>.Equals(object x, object y) => EqualityComparer<object>.Default.Equals(x, y);

            bool IEqualityComparer.Equals(object x, object y) => ((IEqualityComparer)EqualityComparer<object>.Default).Equals(x, y);

            public int GetHashCode(object value)
            {
                if (value is null)
                {
                    return 0;
                }

                Type valueType = value.GetType();

                // Take care to avoid recursion.
                if (valueType == typeof(object))
                {
                    // We can trust object.GetHashCode() to be collision resistant.
                    return value.GetHashCode();
                }

                if (!equalityComparerCache.TryGetValue(valueType, out IEqualityComparer equalityComparer))
                {
                    try
                    {
                        equalityComparer = (IEqualityComparer)GetHashCollisionResistantEqualityComparerOpenGenericMethod.MakeGenericMethod(valueType).Invoke(this.security, Array.Empty<object>());
                    }
                    catch (TargetInvocationException ex)
                    {
                        ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
                    }

                    equalityComparerCache.TryAdd(valueType, equalityComparer);
                }

                return equalityComparer.GetHashCode(value);
            }
        }

        private class UInt64EqualityComparer : CollisionResistantHasher<ulong>
        {
            internal static new readonly UInt64EqualityComparer Instance = new UInt64EqualityComparer();

            public override int GetHashCode(ulong value) => HashCode.Combine((uint)(value >> 32), unchecked((uint)value));
        }

        private class Int64EqualityComparer : CollisionResistantHasher<long>
        {
            internal static new readonly Int64EqualityComparer Instance = new Int64EqualityComparer();

            public override int GetHashCode(long value) => HashCode.Combine((int)(value >> 32), unchecked((int)value));
        }

        private class SingleEqualityComparer : CollisionResistantHasher<float>
        {
            internal static new readonly SingleEqualityComparer Instance = new SingleEqualityComparer();

            public override unsafe int GetHashCode(float value)
            {
                // Special check for 0.0 so that the hash of 0.0 and -0.0 will equal.
                if (value == 0.0f)
                {
                    return HashCode.Combine(0);
                }

                // Standardize on the binary representation of NaN prior to hashing.
                if (float.IsNaN(value))
                {
                    value = float.NaN;
                }

                long l = *(long*)&value;
                return HashCode.Combine((int)(l >> 32), unchecked((int)l));
            }
        }

        private class DoubleEqualityComparer : CollisionResistantHasher<double>
        {
            internal static new readonly DoubleEqualityComparer Instance = new DoubleEqualityComparer();

            public override unsafe int GetHashCode(double value)
            {
                // Special check for 0.0 so that the hash of 0.0 and -0.0 will equal.
                if (value == 0.0)
                {
                    return HashCode.Combine(0);
                }

                // Standardize on the binary representation of NaN prior to hashing.
                if (double.IsNaN(value))
                {
                    value = double.NaN;
                }

                long l = *(long*)&value;
                return HashCode.Combine((int)(l >> 32), unchecked((int)l));
            }
        }

        private class GuidEqualityComparer : CollisionResistantHasher<Guid>
        {
            internal static new readonly GuidEqualityComparer Instance = new GuidEqualityComparer();

            public override unsafe int GetHashCode(Guid value)
            {
                var hash = default(HashCode);
                int* pGuid = (int*)&value;
                for (int i = 0; i < sizeof(Guid) / sizeof(int); i++)
                {
                    hash.Add(pGuid[i]);
                }

                return hash.ToHashCode();
            }
        }

        private class StringEqualityComparer : CollisionResistantHasher<string>
        {
            internal static new readonly StringEqualityComparer Instance = new StringEqualityComparer();

            public override int GetHashCode(string value)
            {
#if NETCOREAPP
                // .NET Core already has a secure string hashing function. Just use it.
                return value?.GetHashCode() ?? 0;
#else
                var hash = default(HashCode);
                for (int i = 0; i < value.Length; i++)
                {
                    hash.Add(value[i]);
                }

                return hash.ToHashCode();
#endif
            }
        }

        private class DateTimeEqualityComparer : CollisionResistantHasher<DateTime>
        {
            internal static new readonly DateTimeEqualityComparer Instance = new DateTimeEqualityComparer();

            public override unsafe int GetHashCode(DateTime value) => HashCode.Combine((int)(value.Ticks >> 32), unchecked((int)value.Ticks), value.Kind);
        }

        private class DateTimeOffsetEqualityComparer : CollisionResistantHasher<DateTimeOffset>
        {
            internal static new readonly DateTimeOffsetEqualityComparer Instance = new DateTimeOffsetEqualityComparer();

            public override unsafe int GetHashCode(DateTimeOffset value) => HashCode.Combine((int)(value.UtcTicks >> 32), unchecked((int)value.UtcTicks));
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSecurity.cs.meta
================================================
fileFormatVersion: 2
guid: a3c0e646c712f8d4f95190e18802ec99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializationException.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

namespace MessagePack
{
    /// <summary>
    /// An exception thrown during serializing an object graph or deserializing a messagepack sequence.
    /// </summary>
    [Serializable]
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    class MessagePackSerializationException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializationException"/> class.
        /// </summary>
        public MessagePackSerializationException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializationException"/> class.
        /// </summary>
        /// <param name="message">The exception message.</param>
        public MessagePackSerializationException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializationException"/> class.
        /// </summary>
        /// <param name="message">The exception message.</param>
        /// <param name="inner">The inner exception.</param>
        public MessagePackSerializationException(string message, Exception inner)
            : base(message, inner)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializationException"/> class.
        /// </summary>
        /// <param name="info">Serialization info.</param>
        /// <param name="context">Serialization context.</param>
        protected MessagePackSerializationException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context)
            : base(info, context)
        {
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializationException.cs.meta
================================================
fileFormatVersion: 2
guid: 807a473ed38c2614db8e2e945c346dbb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using MessagePack.LZ4;
using Nerdbank.Streams;

namespace MessagePack
{
    /// <summary>
    /// High-Level API of MessagePack for C#.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("ApiDesign", "RS0026:Do not add multiple public overloads with optional parameters", Justification = "Each overload has sufficiently unique required parameters.")]
    public static partial class MessagePackSerializer
    {
        private const int LZ4NotCompressionSizeInLz4BlockType = 64;
        private const int MaxHintSize = 1024 * 1024;

        /// <summary>
        /// Gets or sets the default set of options to use when not explicitly specified for a method call.
        /// </summary>
        /// <value>The default value is <see cref="MessagePackSerializerOptions.Standard"/>.</value>
        /// <remarks>
        /// This is an AppDomain or process-wide setting.
        /// If you're writing a library, you should NOT set or rely on this property but should instead pass
        /// in <see cref="MessagePackSerializerOptions.Standard"/> (or the required options) explicitly to every method call
        /// to guarantee appropriate behavior in any application.
        /// If you are an app author, realize that setting this property impacts the entire application so it should only be
        /// set once, and before any use of <see cref="MessagePackSerializer"/> occurs.
        /// </remarks>
        public static MessagePackSerializerOptions DefaultOptions { get; set; } = MessagePackSerializerOptions.Standard;

        /// <summary>
        /// A thread-local, recyclable array that may be used for short bursts of code.
        /// </summary>
        [ThreadStatic]
        private static byte[] scratchArray;

        /// <summary>
        /// Serializes a given value with the specified buffer writer.
        /// </summary>
        /// <param name="writer">The buffer writer to serialize with.</param>
        /// <param name="value">The value to serialize.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        public static void Serialize<T>(IBufferWriter<byte> writer, T value, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            var fastWriter = new MessagePackWriter(writer)
            {
                CancellationToken = cancellationToken,
            };
            Serialize(ref fastWriter, value, options);
            fastWriter.Flush();
        }

        /// <summary>
        /// Serializes a given value with the specified buffer writer.
        /// </summary>
        /// <param name="writer">The buffer writer to serialize with.</param>
        /// <param name="value">The value to serialize.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        public static void Serialize<T>(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options = null)
        {
            options = options ?? DefaultOptions;
            bool originalOldSpecValue = writer.OldSpec;
            if (options.OldSpec.HasValue)
            {
                writer.OldSpec = options.OldSpec.Value;
            }

            try
            {
                if (options.Compression.IsCompression() && !PrimitiveChecker<T>.IsMessagePackFixedSizePrimitive)
                {
                    using (var scratchRental = SequencePool.Shared.Rent())
                    {
                        var scratch = scratchRental.Value;
                        MessagePackWriter scratchWriter = writer.Clone(scratch);
                        options.Resolver.GetFormatterWithVerify<T>().Serialize(ref scratchWriter, value, options);
                        scratchWriter.Flush();
                        ToLZ4BinaryCore(scratch, ref writer, options.Compression);
                    }
                }
                else
                {
                    options.Resolver.GetFormatterWithVerify<T>().Serialize(ref writer, value, options);
                }
            }
            catch (Exception ex)
            {
                throw new MessagePackSerializationException($"Failed to serialize {typeof(T).FullName} value.", ex);
            }
            finally
            {
                writer.OldSpec = originalOldSpecValue;
            }
        }

        /// <summary>
        /// Serializes a given value with the specified buffer writer.
        /// </summary>
        /// <param name="value">The value to serialize.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>A byte array with the serialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        public static byte[] Serialize<T>(T value, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            byte[] array = scratchArray;
            if (array == null)
            {
                scratchArray = array = new byte[65536];
            }

            var msgpackWriter = new MessagePackWriter(SequencePool.Shared, array)
            {
                CancellationToken = cancellationToken,
            };
            Serialize(ref msgpackWriter, value, options);
            return msgpackWriter.FlushAndGetArray();
        }

        /// <summary>
        /// Serializes a given value to the specified stream.
        /// </summary>
        /// <param name="stream">The stream to serialize to.</param>
        /// <param name="value">The value to serialize.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        public static void Serialize<T>(Stream stream, T value, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SequencePool.Rental sequenceRental = SequencePool.Shared.Rent())
            {
                Serialize<T>(sequenceRental.Value, value, options, cancellationToken);

                try
                {
                    foreach (ReadOnlyMemory<byte> segment in sequenceRental.Value.AsReadOnlySequence)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        stream.Write(segment.Span);
                    }
                }
                catch (Exception ex)
                {
                    throw new MessagePackSerializationException("Error occurred while writing the serialized data to the stream.", ex);
                }
            }
        }

        /// <summary>
        /// Serializes a given value to the specified stream.
        /// </summary>
        /// <param name="stream">The stream to serialize to.</param>
        /// <param name="value">The value to serialize.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>A task that completes with the result of the async serialization operation.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        public static async Task SerializeAsync<T>(Stream stream, T value, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();
            using (SequencePool.Rental sequenceRental = SequencePool.Shared.Rent())
            {
                Serialize<T>(sequenceRental.Value, value, options, cancellationToken);

                try
                {
                    foreach (ReadOnlyMemory<byte> segment in sequenceRental.Value.AsReadOnlySequence)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        await stream.WriteAsync(segment, cancellationToken).ConfigureAwait(false);
                    }
                }
                catch (Exception ex)
                {
                    throw new MessagePackSerializationException("Error occurred while writing the serialized data to the stream.", ex);
                }
            }
        }

        /// <summary>
        /// Deserializes a value of a given type from a sequence of bytes.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="byteSequence">The sequence to deserialize from.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        public static T Deserialize<T>(in ReadOnlySequence<byte> byteSequence, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            var reader = new MessagePackReader(byteSequence)
            {
                CancellationToken = cancellationToken,
            };
            return Deserialize<T>(ref reader, options);
        }

        /// <summary>
        /// Deserializes a value of a given type from a sequence of bytes.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="reader">The reader to deserialize from.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        public static T Deserialize<T>(ref MessagePackReader reader, MessagePackSerializerOptions options = null)
        {
            options = options ?? DefaultOptions;

            try
            {
                if (options.Compression.IsCompression())
                {
                    using (var msgPackUncompressedRental = SequencePool.Shared.Rent())
                    {
                        var msgPackUncompressed = msgPackUncompressedRental.Value;
                        if (TryDecompress(ref reader, msgPackUncompressed))
                        {
                            MessagePackReader uncompressedReader = reader.Clone(msgPackUncompressed.AsReadOnlySequence);
                            return options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref uncompressedReader, options);
                        }
                        else
                        {
                            return options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
                        }
                    }
                }
                else
                {
                    return options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
                }
            }
            catch (Exception ex)
            {
                throw new MessagePackSerializationException($"Failed to deserialize {typeof(T).FullName} value.", ex);
            }
        }

        /// <summary>
        /// Deserializes a value of a given type from a sequence of bytes.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="buffer">The buffer to deserialize from.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        public static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            var reader = new MessagePackReader(buffer)
            {
                CancellationToken = cancellationToken,
            };
            return Deserialize<T>(ref reader, options);
        }

        /// <summary>
        /// Deserializes a value of a given type from a sequence of bytes.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="buffer">The memory to deserialize from.</param>
        /// <param name="bytesRead">The number of bytes read.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        public static T Deserialize<T>(ReadOnlyMemory<byte> buffer, out int bytesRead, CancellationToken cancellationToken = default) => Deserialize<T>(buffer, options: null, out bytesRead, cancellationToken);

        /// <summary>
        /// Deserializes a value of a given type from a sequence of bytes.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="buffer">The memory to deserialize from.</param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="bytesRead">The number of bytes read.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        public static T Deserialize<T>(ReadOnlyMemory<byte> buffer, MessagePackSerializerOptions options, out int bytesRead, CancellationToken cancellationToken = default)
        {
            var reader = new MessagePackReader(buffer)
            {
                CancellationToken = cancellationToken,
            };
            T result = Deserialize<T>(ref reader, options);
            bytesRead = buffer.Slice(0, (int)reader.Consumed).Length;
            return result;
        }

        /// <summary>
        /// Deserializes the entire content of a <see cref="Stream"/>.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="stream">
        /// The stream to deserialize from.
        /// The entire stream will be read, and the first msgpack token deserialized will be returned.
        /// If <see cref="Stream.CanSeek"/> is true on the stream, its position will be set to just after the last deserialized byte.
        /// </param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        /// <remarks>
        /// If multiple top-level msgpack data structures are expected on the stream, use <see cref="MessagePackStreamReader"/> instead.
        /// </remarks>
        public static T Deserialize<T>(Stream stream, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            if (TryDeserializeFromMemoryStream(stream, options, cancellationToken, out T result))
            {
                return result;
            }

            using (var sequenceRental = SequencePool.Shared.Rent())
            {
                var sequence = sequenceRental.Value;
                try
                {
                    int bytesRead;
                    do
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        Span<byte> span = sequence.GetSpan(stream.CanSeek ? (int)Math.Min(MaxHintSize, stream.Length - stream.Position) : 0);
                        bytesRead = stream.Read(span);
                        sequence.Advance(bytesRead);
                    }
                    while (bytesRead > 0);
                }
                catch (Exception ex)
                {
                    throw new MessagePackSerializationException("Error occurred while reading from the stream.", ex);
                }

                return DeserializeFromSequenceAndRewindStreamIfPossible<T>(stream, options, sequence, cancellationToken);
            }
        }

        /// <summary>
        /// Deserializes the entire content of a <see cref="Stream"/>.
        /// </summary>
        /// <typeparam name="T">The type of value to deserialize.</typeparam>
        /// <param name="stream">
        /// The stream to deserialize from.
        /// The entire stream will be read, and the first msgpack token deserialized will be returned.
        /// If <see cref="Stream.CanSeek"/> is true on the stream, its position will be set to just after the last deserialized byte.
        /// </param>
        /// <param name="options">The options. Use <c>null</c> to use default options.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The deserialized value.</returns>
        /// <exception cref="MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        /// <remarks>
        /// If multiple top-level msgpack data structures are expected on the stream, use <see cref="MessagePackStreamReader"/> instead.
        /// </remarks>
        public static async ValueTask<T> DeserializeAsync<T>(Stream stream, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            if (TryDeserializeFromMemoryStream(stream, options, cancellationToken, out T result))
            {
                return result;
            }

            using (var sequenceRental = SequencePool.Shared.Rent())
            {
                var sequence = sequenceRental.Value;
                try
                {
                    int bytesRead;
                    do
                    {
                        Memory<byte> memory = sequence.GetMemory(stream.CanSeek ? (int)Math.Min(MaxHintSize, stream.Length - stream.Position) : 0);
                        bytesRead = await stream.ReadAsync(memory, cancellationToken).ConfigureAwait(false);
                        sequence.Advance(bytesRead);
                    }
                    while (bytesRead > 0);
                }
                catch (Exception ex)
                {
                    throw new MessagePackSerializationException("Error occurred while reading from the stream.", ex);
                }

                return DeserializeFromSequenceAndRewindStreamIfPossible<T>(stream, options, sequence, cancellationToken);
            }
        }

        private delegate int LZ4Transform(ReadOnlySpan<byte> input, Span<byte> output);

        private static readonly LZ4Transform LZ4CodecEncode = LZ4Codec.Encode;
        private static readonly LZ4Transform LZ4CodecDecode = LZ4Codec.Decode;

        private static bool TryDeserializeFromMemoryStream<T>(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken, out T result)
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (stream is MemoryStream ms && ms.TryGetBuffer(out ArraySegment<byte> streamBuffer))
            {
                result = Deserialize<T>(streamBuffer.AsMemory(checked((int)ms.Position)), options, out int bytesRead, cancellationToken);

                // Emulate that we had actually "read" from the stream.
                ms.Seek(bytesRead, SeekOrigin.Current);
                return true;
            }

            result = default;
            return false;
        }

        private static T DeserializeFromSequenceAndRewindStreamIfPossible<T>(Stream streamToRewind, MessagePackSerializerOptions options, ReadOnlySequence<byte> sequence, CancellationToken cancellationToken)
        {
            if (streamToRewind is null)
            {
                throw new ArgumentNullException(nameof(streamToRewind));
            }

            var reader = new MessagePackReader(sequence)
            {
                CancellationToken = cancellationToken,
            };
            T result = Deserialize<T>(ref reader, options);

            if (streamToRewind.CanSeek && !reader.End)
            {
                // Reverse the stream as many bytes as we left unread.
                int bytesNotRead = checked((int)reader.Sequence.Slice(reader.Position).Length);
                streamToRewind.Seek(-bytesNotRead, SeekOrigin.Current);
            }

            return result;
        }

        /// <summary>
        /// Performs LZ4 compression or decompression.
        /// </summary>
        /// <param name="input">The input for the operation.</param>
        /// <param name="output">The buffer to write the result of the operation.</param>
        /// <param name="lz4Operation">The LZ4 codec transformation.</param>
        /// <returns>The number of bytes written to the <paramref name="output"/>.</returns>
        private static int LZ4Operation(in ReadOnlySequence<byte> input, Span<byte> output, LZ4Transform lz4Operation)
        {
            ReadOnlySpan<byte> inputSpan;
            byte[] rentedInputArray = null;
            if (input.IsSingleSegment)
            {
                inputSpan = input.First.Span;
            }
            else
            {
                rentedInputArray = ArrayPool<byte>.Shared.Rent((int)input.Length);
                input.CopyTo(rentedInputArray);
                inputSpan = rentedInputArray.AsSpan(0, (int)input.Length);
            }

            try
            {
                return lz4Operation(inputSpan, output);
            }
            finally
            {
                if (rentedInputArray != null)
                {
                    ArrayPool<byte>.Shared.Return(rentedInputArray);
                }
            }
        }

        private static bool TryDecompress(ref MessagePackReader reader, IBufferWriter<byte> writer)
        {
            if (!reader.End)
            {
                // Try to find LZ4Block
                if (reader.NextMessagePackType == MessagePackType.Extension)
                {
                    MessagePackReader peekReader = reader.CreatePeekReader();
                    ExtensionHeader header = peekReader.ReadExtensionFormatHeader();
                    if (header.TypeCode == ThisLibraryExtensionTypeCodes.Lz4Block)
                    {
                        // Read the extension using the original reader, so we "consume" it.
                        ExtensionResult extension = reader.ReadExtensionFormat();
                        var extReader = new MessagePackReader(extension.Data);

                        // The first part of the extension payload is a MessagePack-encoded Int32 that
                        // tells us the length the data will be AFTER decompression.
                        int uncompressedLength = extReader.ReadInt32();

                        // The rest of the payload is the compressed data itself.
                        ReadOnlySequence<byte> compressedData = extReader.Sequence.Slice(extReader.Position);

                        Span<byte> uncompressedSpan = writer.GetSpan(uncompressedLength).Slice(0, uncompressedLength);
                        int actualUncompressedLength = LZ4Operation(compressedData, uncompressedSpan, LZ4CodecDecode);
                        Debug.Assert(actualUncompressedLength == uncompressedLength, "Unexpected length of uncompressed data.");
                        writer.Advance(actualUncompressedLength);
                        return true;
                    }
                }

                // Try to find LZ4BlockArray
                if (reader.NextMessagePackType == MessagePackType.Array)
                {
                    MessagePackReader peekReader = reader.CreatePeekReader();
                    var arrayLength = peekReader.ReadArrayHeader();
                    if (arrayLength != 0 && peekReader.NextMessagePackType == MessagePackType.Extension)
                    {
                        ExtensionHeader header = peekReader.ReadExtensionFormatHeader();
                        if (header.TypeCode == ThisLibraryExtensionTypeCodes.Lz4BlockArray)
                        {
                            // switch peekReader as original reader.
                            reader = peekReader;

                            // Read from [Ext(98:int,int...), bin,bin,bin...]
                            var sequenceCount = arrayLength - 1;
                            var uncompressedLengths = ArrayPool<int>.Shared.Rent(sequenceCount);
                            try
                            {
                                for (int i = 0; i < sequenceCount; i++)
                                {
                                    uncompressedLengths[i] = reader.ReadInt32();
                                }

                                for (int i = 0; i < sequenceCount; i++)
                                {
                                    var uncompressedLength = uncompressedLengths[i];
                                    var lz4Block = reader.ReadBytes();
                                    Span<byte> uncompressedSpan = writer.GetSpan(uncompressedLength).Slice(0, uncompressedLength);
                                    var actualUncompressedLength = LZ4Operation(lz4Block.Value, uncompressedSpan, LZ4CodecDecode);
                                    Debug.Assert(actualUncompressedLength == uncompressedLength, "Unexpected length of uncompressed data.");
                                    writer.Advance(actualUncompressedLength);
                                }

                                return true;
                            }
                            finally
                            {
                                ArrayPool<int>.Shared.Return(uncompressedLengths);
                            }
                        }
                    }
                }
            }

            return false;
        }

        private static void ToLZ4BinaryCore(in ReadOnlySequence<byte> msgpackUncompressedData, ref MessagePackWriter writer, MessagePackCompression compression)
        {
            if (compression == MessagePackCompression.Lz4Block)
            {
                if (msgpackUncompressedData.Length < LZ4NotCompressionSizeInLz4BlockType)
                {
                    writer.WriteRaw(msgpackUncompressedData);
                    return;
                }

                var maxCompressedLength = LZ4Codec.MaximumOutputLength((int)msgpackUncompressedData.Length);
                var lz4Span = ArrayPool<byte>.Shared.Rent(maxCompressedLength);
                try
                {
                    int lz4Length = LZ4Operation(msgpackUncompressedData, lz4Span, LZ4CodecEncode);

                    const int LengthOfUncompressedDataSizeHeader = 5;
                    writer.WriteExtensionFormatHeader(new ExtensionHeader(ThisLibraryExtensionTypeCodes.Lz4Block, LengthOfUncompressedDataSizeHeader + (uint)lz4Length));
                    writer.WriteInt32((int)msgpackUncompressedData.Length);
                    writer.WriteRaw(lz4Span.AsSpan(0, lz4Length));
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(lz4Span);
                }
            }
            else if (compression == MessagePackCompression.Lz4BlockArray)
            {
                // Write to [Ext(98:int,int...), bin,bin,bin...]
                var sequenceCount = 0;
                var extHeaderSize = 0;
                foreach (var item in msgpackUncompressedData)
                {
                    sequenceCount++;
                    extHeaderSize += GetUInt32WriteSize((uint)item.Length);
                }

                writer.WriteArrayHeader(sequenceCount + 1);
                writer.WriteExtensionFormatHeader(new ExtensionHeader(ThisLibraryExtensionTypeCodes.Lz4BlockArray, extHeaderSize));
                {
                    foreach (var item in msgpackUncompressedData)
                    {
                        writer.Write(item.Length);
                    }
                }

                foreach (var item in msgpackUncompressedData)
                {
                    var maxCompressedLength = LZ4Codec.MaximumOutputLength(item.Length);
                    var lz4Span = writer.GetSpan(maxCompressedLength + 5);
                    int lz4Length = LZ4Codec.Encode(item.Span, lz4Span.Slice(5, lz4Span.Length - 5));
                    WriteBin32Header((uint)lz4Length, lz4Span);
                    writer.Advance(lz4Length + 5);
                }
            }
            else
            {
                throw new ArgumentException("Invalid MessagePackCompression Code. Code:" + compression);
            }
        }

        private static int GetUInt32WriteSize(uint value)
        {
            if (value <= MessagePackRange.MaxFixPositiveInt)
            {
                return 1;
            }
            else if (value <= byte.MaxValue)
            {
                return 2;
            }
            else if (value <= ushort.MaxValue)
            {
                return 3;
            }
            else
            {
                return 5;
            }
        }

        private static void WriteBin32Header(uint value, Span<byte> span)
        {
            unchecked
            {
                span[0] = MessagePackCode.Bin32;

                // Write to highest index first so the JIT skips bounds checks on subsequent writes.
                span[4] = (byte)value;
                span[3] = (byte)(value >> 8);
                span[2] = (byte)(value >> 16);
                span[1] = (byte)(value >> 24);
            }
        }

        private static class PrimitiveChecker<T>
        {
            public static readonly bool IsMessagePackFixedSizePrimitive;

            static PrimitiveChecker()
            {
                IsMessagePackFixedSizePrimitive = IsMessagePackFixedSizePrimitiveTypeHelper(typeof(T));
            }
        }

        private static bool IsMessagePackFixedSizePrimitiveTypeHelper(Type type)
        {
            return type == typeof(short)
                || type == typeof(int)
                || type == typeof(long)
                || type == typeof(ushort)
                || type == typeof(uint)
                || type == typeof(ulong)
                || type == typeof(float)
                || type == typeof(double)
                || type == typeof(bool)
                || type == typeof(byte)
                || type == typeof(sbyte)
                || type == typeof(char)
            ;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.cs.meta
================================================
fileFormatVersion: 2
guid: d33e055ed9d0f484d9048fb29fa84ba3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.Json.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using MessagePack.Formatters;
using Nerdbank.Streams;

namespace MessagePack
{
    // JSON API
    public partial class MessagePackSerializer
    {
        /// <summary>
        /// Serialize an object to JSON string.
        /// </summary>
        /// <exception cref="MessagePackSerializationException">Thrown if an error occurs during serialization.</exception>
        public static void SerializeToJson<T>(TextWriter textWriter, T obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            using (var sequenceRental = SequencePool.Shared.Rent())
            {
                var msgpackWriter = new MessagePackWriter(sequenceRental.Value)
                {
                    CancellationToken = cancellationToken,
                };
                Serialize(ref msgpackWriter, obj, options);
                msgpackWriter.Flush();
                var msgpackReader = new MessagePackReader(sequenceRental.Value)
                {
                    CancellationToken = cancellationToken,
                };
                ConvertToJson(ref msgpackReader, textWriter, options);
            }
        }

        /// <summary>
        /// Serialize an object to JSON string.
        /// </summary>
        /// <exception cref="MessagePackSerializationException">Thrown if an error occurs during serialization.</exception>
        public static string SerializeToJson<T>(T obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            var writer = new StringWriter();
            SerializeToJson(writer, obj, options, cancellationToken);
            return writer.ToString();
        }

        /// <summary>
        /// Convert a message-pack binary to a JSON string.
        /// </summary>
        /// <exception cref="MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        public static string ConvertToJson(ReadOnlyMemory<byte> bytes, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default) => ConvertToJson(new ReadOnlySequence<byte>(bytes), options, cancellationToken);

        /// <summary>
        /// Convert a message-pack binary to a JSON string.
        /// </summary>
        /// <exception cref="MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        public static string ConvertToJson(in ReadOnlySequence<byte> bytes, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            var jsonWriter = new StringWriter();
            var reader = new MessagePackReader(bytes)
            {
                CancellationToken = cancellationToken,
            };
            ConvertToJson(ref reader, jsonWriter, options);
            return jsonWriter.ToString();
        }

        /// <summary>
        /// Convert a message-pack binary to a JSON string.
        /// </summary>
        /// <exception cref="MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        public static void ConvertToJson(ref MessagePackReader reader, TextWriter jsonWriter, MessagePackSerializerOptions options = null)
        {
            if (reader.End)
            {
                return;
            }

            options = options ?? DefaultOptions;
            try
            {
                if (options.Compression.IsCompression())
                {
                    using (var scratchRental = SequencePool.Shared.Rent())
                    {
                        if (TryDecompress(ref reader, scratchRental.Value))
                        {
                            var scratchReader = new MessagePackReader(scratchRental.Value)
                            {
                                CancellationToken = reader.CancellationToken,
                            };
                            if (scratchReader.End)
                            {
                                return;
                            }

                            ToJsonCore(ref scratchReader, jsonWriter, options);
                        }
                        else
                        {
                            ToJsonCore(ref reader, jsonWriter, options);
                        }
                    }
                }
                else
                {
                    ToJsonCore(ref reader, jsonWriter, options);
                }
            }
            catch (Exception ex)
            {
                throw new MessagePackSerializationException("Error occurred while translating msgpack to JSON.", ex);
            }
        }

        /// <summary>
        /// Translates the given JSON to MessagePack.
        /// </summary>
        public static void ConvertFromJson(string str, ref MessagePackWriter writer, MessagePackSerializerOptions options = null)
        {
            using (var sr = new StringReader(str))
            {
                ConvertFromJson(sr, ref writer, options);
            }
        }

        /// <summary>
        /// Translates the given JSON to MessagePack.
        /// </summary>
        public static byte[] ConvertFromJson(string str, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            using (var scratchRental = SequencePool.Shared.Rent())
            {
                var writer = new MessagePackWriter(scratchRental.Value)
                {
                    CancellationToken = cancellationToken,
                };
                using (var sr = new StringReader(str))
                {
                    ConvertFromJson(sr, ref writer, options);
                }

                writer.Flush();
                return scratchRental.Value.AsReadOnlySequence.ToArray();
            }
        }

        /// <summary>
        /// Translates the given JSON to MessagePack.
        /// </summary>
        public static void ConvertFromJson(TextReader reader, ref MessagePackWriter writer, MessagePackSerializerOptions options = null)
        {
            options = options ?? DefaultOptions;
            if (options.Compression.IsCompression())
            {
                using (var scratchRental = SequencePool.Shared.Rent())
                {
                    MessagePackWriter scratchWriter = writer.Clone(scratchRental.Value);
                    using (var jr = new TinyJsonReader(reader, false))
                    {
                        FromJsonCore(jr, ref scratchWriter);
                    }

                    scratchWriter.Flush();
                    ToLZ4BinaryCore(scratchRental.Value, ref writer, options.Compression);
                }
            }
            else
            {
                using (var jr = new TinyJsonReader(reader, false))
                {
                    FromJsonCore(jr, ref writer);
                }
            }
        }

        private static uint FromJsonCore(TinyJsonReader jr, ref MessagePackWriter writer)
        {
            uint count = 0;
            while (jr.Read())
            {
                switch (jr.TokenType)
                {
                    case TinyJsonToken.None:
                        break;
                    case TinyJsonToken.StartObject:
                        // Set up a scratch area to serialize the collection since we don't know its length yet, which must be written first.
                        using (var scratchRental = SequencePool.Shared.Rent())
                        {
                            MessagePackWriter scratchWriter = writer.Clone(scratchRental.Value);
                            var mapCount = FromJsonCore(jr, ref scratchWriter);
                            scratchWriter.Flush();

                            mapCount = mapCount / 2; // remove propertyname string count.
                            writer.WriteMapHeader(mapCount);
                            writer.WriteRaw(scratchRental.Value);
                        }

                        count++;
                        break;
                    case TinyJsonToken.EndObject:
                        return count; // break
                    case TinyJsonToken.StartArray:
                        // Set up a scratch area to serialize the collection since we don't know its length yet, which must be written first.
                        using (var scratchRental = SequencePool.Shared.Rent())
                        {
                            MessagePackWriter scratchWriter = writer.Clone(scratchRental.Value);
                            var arrayCount = FromJsonCore(jr, ref scratchWriter);
                            scratchWriter.Flush();

                            writer.WriteArrayHeader(arrayCount);
                            writer.WriteRaw(scratchRental.Value);
                        }

                        count++;
                        break;
                    case TinyJsonToken.EndArray:
                        return count; // break
                    case TinyJsonToken.Number:
                        ValueType v = jr.ValueType;
                        if (v == ValueType.Double)
                        {
                            writer.Write(jr.DoubleValue);
                        }
                        else if (v == ValueType.Long)
                        {
                            writer.Write(jr.LongValue);
                        }
                        else if (v == ValueType.ULong)
                        {
                            writer.Write(jr.ULongValue);
                        }
                        else if (v == ValueType.Decimal)
                        {
                            DecimalFormatter.Instance.Serialize(ref writer, jr.DecimalValue, null);
                        }

                        count++;
                        break;
                    case TinyJsonToken.String:
                        writer.Write(jr.StringValue);
                        count++;
                        break;
                    case TinyJsonToken.True:
                        writer.Write(true);
                        count++;
                        break;
                    case TinyJsonToken.False:
                        writer.Write(false);
                        count++;
                        break;
                    case TinyJsonToken.Null:
                        writer.WriteNil();
                        count++;
                        break;
                    default:
                        break;
                }
            }

            return count;
        }

        private static void ToJsonCore(ref MessagePackReader reader, TextWriter writer, MessagePackSerializerOptions options)
        {
            MessagePackType type = reader.NextMessagePackType;
            switch (type)
            {
                case MessagePackType.Integer:
                    if (MessagePackCode.IsSignedInteger(reader.NextCode))
                    {
                        writer.Write(reader.ReadInt64().ToString(CultureInfo.InvariantCulture));
                    }
                    else
                    {
                        writer.Write(reader.ReadUInt64().ToString(CultureInfo.InvariantCulture));
                    }

                    break;
                case MessagePackType.Boolean:
                    writer.Write(reader.ReadBoolean() ? "true" : "false");
                    break;
                case MessagePackType.Float:
                    if (reader.NextCode == MessagePackCode.Float32)
                    {
                        writer.Write(reader.ReadSingle().ToString(CultureInfo.InvariantCulture));
                    }
                    else
                    {
                        writer.Write(reader.ReadDouble().ToString(CultureInfo.InvariantCulture));
                    }

                    break;
                case MessagePackType.String:
                    WriteJsonString(reader.ReadString(), writer);
                    break;
                case MessagePackType.Binary:
                    ArraySegment<byte> segment = ByteArraySegmentFormatter.Instance.Deserialize(ref reader, DefaultOptions);
                    writer.Write("\"" + Convert.ToBase64String(segment.Array, segment.Offset, segment.Count) + "\"");
                    break;
                case MessagePackType.Array:
                    {
                        int length = reader.ReadArrayHeader();
                        options.Security.DepthStep(ref reader);
                        try
                        {
                            writer.Write("[");
                            for (int i = 0; i < length; i++)
                            {
                                ToJsonCore(ref reader, writer, options);

                                if (i != length - 1)
                                {
                                    writer.Write(",");
                                }
                            }

                            writer.Write("]");
                        }
                        finally
                        {
                            reader.Depth--;
                        }

                        return;
                    }

                case MessagePackType.Map:
                    {
                        int length = reader.ReadMapHeader();
                        options.Security.DepthStep(ref reader);
                        try
                        {
                            writer.Write("{");
                            for (int i = 0; i < length; i++)
                            {
                                // write key
                                {
                                    MessagePackType keyType = reader.NextMessagePackType;
                                    if (keyType == MessagePackType.String || keyType == MessagePackType.Binary)
                                    {
                                        ToJsonCore(ref reader, writer, options);
                                    }
                                    else
                                    {
                                        writer.Write("\"");
                                        ToJsonCore(ref reader, writer, options);
                                        writer.Write("\"");
                                    }
                                }

                                writer.Write(":");

                                // write body
                                {
                                    ToJsonCore(ref reader, writer, options);
                                }

                                if (i != length - 1)
                                {
                                    writer.Write(",");
                                }
                            }

                            writer.Write("}");
                        }
                        finally
                        {
                            reader.Depth--;
                        }

                        return;
                    }

                case MessagePackType.Extension:
                    ExtensionHeader extHeader = reader.ReadExtensionFormatHeader();
                    if (extHeader.TypeCode == ReservedMessagePackExtensionTypeCode.DateTime)
                    {
                        DateTime dt = reader.ReadDateTime(extHeader);
                        writer.Write("\"");
                        writer.Write(dt.ToString("o", CultureInfo.InvariantCulture));
                        writer.Write("\"");
                    }
#if !UNITY_2018_3_OR_NEWER
                    else if (extHeader.TypeCode == ThisLibraryExtensionTypeCodes.TypelessFormatter)
                    {
                        // prepare type name token
                        var privateBuilder = new StringBuilder();
                        var typeNameTokenBuilder = new StringBuilder();
                        SequencePosition positionBeforeTypeNameRead = reader.Position;
                        ToJsonCore(ref reader, new StringWriter(typeNameTokenBuilder), options);
                        int typeNameReadSize = (int)reader.Sequence.Slice(positionBeforeTypeNameRead, reader.Position).Length;
                        if (extHeader.Length > typeNameReadSize)
                        {
                            // object map or array
                            MessagePackType typeInside = reader.NextMessagePackType;
                            if (typeInside != MessagePackType.Array && typeInside != MessagePackType.Map)
                            {
                                privateBuilder.Append("{");
                            }

                            ToJsonCore(ref reader, new StringWriter(privateBuilder), options);

                            // insert type name token to start of object map or array
                            if (typeInside != MessagePackType.Array)
                            {
                                typeNameTokenBuilder.Insert(0, "\"$type\":");
                            }

                            if (typeInside != MessagePackType.Array && typeInside != MessagePackType.Map)
                            {
                                privateBuilder.Append("}");
                            }

                            if (privateBuilder.Length > 2)
                            {
                                typeNameTokenBuilder.Append(",");
                            }

                            privateBuilder.Insert(1, typeNameTokenBuilder.ToString());

                            writer.Write(privateBuilder.ToString());
                        }
                        else
                        {
                            writer.Write("{\"$type\":\"" + typeNameTokenBuilder.ToString() + "}");
                        }
                    }
#endif
                    else
                    {
                        var data = reader.ReadRaw((long)extHeader.Length);
                        writer.Write("[");
                        writer.Write(extHeader.TypeCode);
                        writer.Write(",");
                        writer.Write("\"");
                        writer.Write(Convert.ToBase64String(data.ToArray()));
                        writer.Write("\"");
                        writer.Write("]");
                    }

                    break;
                case MessagePackType.Nil:
                    reader.Skip();
                    writer.Write("null");
                    break;
                default:
                    throw new MessagePackSerializationException($"code is invalid. code: {reader.NextCode} format: {MessagePackCode.ToFormatName(reader.NextCode)}");
            }
        }

        // escape string
        private static void WriteJsonString(string value, TextWriter builder)
        {
            builder.Write('\"');

            var len = value.Length;
            for (int i = 0; i < len; i++)
            {
                var c = value[i];
                switch (c)
                {
                    case '"':
                        builder.Write("\\\"");
                        break;
                    case '\\':
                        builder.Write("\\\\");
                        break;
                    case '\b':
                        builder.Write("\\b");
                        break;
                    case '\f':
                        builder.Write("\\f");
                        break;
                    case '\n':
                        builder.Write("\\n");
                        break;
                    case '\r':
                        builder.Write("\\r");
                        break;
                    case '\t':
                        builder.Write("\\t");
                        break;
                    default:
                        builder.Write(c);
                        break;
                }
            }

            builder.Write('\"');
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.Json.cs.meta
================================================
fileFormatVersion: 2
guid: 8b519a41377bf3a489ab6db1e1044458
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.NonGeneric.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace MessagePack
{
    public partial class MessagePackSerializer
    {
        private static readonly Func<Type, CompiledMethods> CreateCompiledMethods;
        private static readonly MessagePack.Internal.ThreadsafeTypeKeyHashTable<CompiledMethods> Serializes = new MessagePack.Internal.ThreadsafeTypeKeyHashTable<CompiledMethods>(capacity: 64);

        static MessagePackSerializer()
        {
            CreateCompiledMethods = t => new CompiledMethods(t);
        }

        /// <seealso cref="Serialize{T}(ref MessagePackWriter, T, MessagePackSerializerOptions)"/>
        public static void Serialize(Type type, ref MessagePackWriter writer, object obj, MessagePackSerializerOptions options = null)
        {
            GetOrAdd(type).Serialize_MessagePackWriter_T_Options.Invoke(ref writer, obj, options);
        }

        /// <seealso cref="Serialize{T}(IBufferWriter{byte}, T, MessagePackSerializerOptions, CancellationToken)"/>
        public static void Serialize(Type type, IBufferWriter<byte> writer, object obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            GetOrAdd(type).Serialize_IBufferWriter_T_Options_CancellationToken.Invoke(writer, obj, options, cancellationToken);
        }

        /// <seealso cref="Serialize{T}(T, MessagePackSerializerOptions, CancellationToken)"/>
        public static byte[] Serialize(Type type, object obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).Serialize_T_Options.Invoke(obj, options, cancellationToken);
        }

        /// <seealso cref="Serialize{T}(Stream, T, MessagePackSerializerOptions, CancellationToken)"/>
        public static void Serialize(Type type, Stream stream, object obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            GetOrAdd(type).Serialize_Stream_T_Options_CancellationToken.Invoke(stream, obj, options, cancellationToken);
        }

        /// <seealso cref="SerializeAsync{T}(Stream, T, MessagePackSerializerOptions, CancellationToken)"/>
        public static Task SerializeAsync(Type type, Stream stream, object obj, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).SerializeAsync_Stream_T_Options_CancellationToken.Invoke(stream, obj, options, cancellationToken);
        }

        /// <seealso cref="Deserialize{T}(ref MessagePackReader, MessagePackSerializerOptions)"/>
        public static object Deserialize(Type type, ref MessagePackReader reader, MessagePackSerializerOptions options = null)
        {
            return GetOrAdd(type).Deserialize_MessagePackReader_Options.Invoke(ref reader, options);
        }

        /// <seealso cref="Deserialize{T}(Stream, MessagePackSerializerOptions, CancellationToken)"/>
        public static object Deserialize(Type type, Stream stream, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).Deserialize_Stream_Options_CancellationToken.Invoke(stream, options, cancellationToken);
        }

        /// <seealso cref="DeserializeAsync{T}(Stream, MessagePackSerializerOptions, CancellationToken)"/>
        public static ValueTask<object> DeserializeAsync(Type type, Stream stream, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).DeserializeAsync_Stream_Options_CancellationToken.Invoke(stream, options, cancellationToken);
        }

        /// <seealso cref="Deserialize{T}(ReadOnlyMemory{byte}, MessagePackSerializerOptions, CancellationToken)"/>
        public static object Deserialize(Type type, ReadOnlyMemory<byte> bytes, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).Deserialize_ReadOnlyMemory_Options.Invoke(bytes, options, cancellationToken);
        }

        /// <seealso cref="Deserialize{T}(in ReadOnlySequence{byte}, MessagePackSerializerOptions, CancellationToken)"/>
        public static object Deserialize(Type type, ReadOnlySequence<byte> bytes, MessagePackSerializerOptions options = null, CancellationToken cancellationToken = default)
        {
            return GetOrAdd(type).Deserialize_ReadOnlySequence_Options_CancellationToken.Invoke(bytes, options, cancellationToken);
        }

        private static async ValueTask<object> DeserializeObjectAsync<T>(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken) => await DeserializeAsync<T>(stream, options, cancellationToken).ConfigureAwait(false);

        private static CompiledMethods GetOrAdd(Type type)
        {
            return Serializes.GetOrAdd(type, CreateCompiledMethods);
        }

        private class CompiledMethods
        {
            internal delegate void MessagePackWriterSerialize(ref MessagePackWriter writer, object value, MessagePackSerializerOptions options);

            internal delegate object MessagePackReaderDeserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);

            private const bool PreferInterpretation =
#if ENABLE_IL2CPP
                true;
#else
                false;
#endif

#pragma warning disable SA1310 // Field names should not contain underscore
#pragma warning disable SA1307 // Accessible fields should begin with upper-case letter
#pragma warning disable SA1401 // Fields should be private
            internal readonly Func<object, MessagePackSerializerOptions, CancellationToken, byte[]> Serialize_T_Options;
            internal readonly Action<Stream, object, MessagePackSerializerOptions, CancellationToken> Serialize_Stream_T_Options_CancellationToken;
            internal readonly Func<Stream, object, MessagePackSerializerOptions, CancellationToken, Task> SerializeAsync_Stream_T_Options_CancellationToken;
            internal readonly MessagePackWriterSerialize Serialize_MessagePackWriter_T_Options;
            internal readonly Action<IBufferWriter<byte>, object, MessagePackSerializerOptions, CancellationToken> Serialize_IBufferWriter_T_Options_CancellationToken;

            internal readonly MessagePackReaderDeserialize Deserialize_MessagePackReader_Options;
            internal readonly Func<Stream, MessagePackSerializerOptions, CancellationToken, object> Deserialize_Stream_Options_CancellationToken;
            internal readonly Func<Stream, MessagePackSerializerOptions, CancellationToken, ValueTask<object>> DeserializeAsync_Stream_Options_CancellationToken;

            internal readonly Func<ReadOnlyMemory<byte>, MessagePackSerializerOptions, CancellationToken, object> Deserialize_ReadOnlyMemory_Options;
            internal readonly Func<ReadOnlySequence<byte>, MessagePackSerializerOptions, CancellationToken, object> Deserialize_ReadOnlySequence_Options_CancellationToken;
#pragma warning restore SA1401 // Fields should be private
#pragma warning restore SA1307 // Accessible fields should begin with upper-case letter
#pragma warning restore SA1310 // Field names should not contain underscore

            internal CompiledMethods(Type type)
            {
                TypeInfo ti = type.GetTypeInfo();
                {
                    // public static byte[] Serialize<T>(T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo serialize = GetMethod(nameof(Serialize), type, new Type[] { null, typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Serialize_T_Options = (x, y, z) => (byte[])serialize.Invoke(null, new object[] { x, y, z });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(object), "obj");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param3 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");

                    MethodCallExpression body = Expression.Call(
                        null,
                        serialize,
                        ti.IsValueType ? Expression.Unbox(param1, type) : Expression.Convert(param1, type),
                        param2,
                        param3);
                    Func<object, MessagePackSerializerOptions, CancellationToken, byte[]> lambda = Expression.Lambda<Func<object, MessagePackSerializerOptions, CancellationToken, byte[]>>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.Serialize_T_Options = lambda;
#endif
                }

                {
                    // public static void Serialize<T>(Stream stream, T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo serialize = GetMethod(nameof(Serialize), type, new Type[] { typeof(Stream), null, typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Serialize_Stream_T_Options_CancellationToken = (x, y, z, a) => serialize.Invoke(null, new object[] { x, y, z, a });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(Stream), "stream");
                    ParameterExpression param2 = Expression.Parameter(typeof(object), "obj");
                    ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param4 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");

                    MethodCallExpression body = Expression.Call(
                        null,
                        serialize,
                        param1,
                        ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                        param3,
                        param4);
                    Action<Stream, object, MessagePackSerializerOptions, CancellationToken> lambda = Expression.Lambda<Action<Stream, object, MessagePackSerializerOptions, CancellationToken>>(body, param1, param2, param3, param4).Compile(PreferInterpretation);

                    this.Serialize_Stream_T_Options_CancellationToken = lambda;
#endif
                }

                {
                    // public static Task SerializeAsync<T>(Stream stream, T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo serialize = GetMethod(nameof(SerializeAsync), type, new Type[] { typeof(Stream), null, typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.SerializeAsync_Stream_T_Options_CancellationToken = (x, y, z, a) => (Task)serialize.Invoke(null, new object[] { x, y, z, a });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(Stream), "stream");
                    ParameterExpression param2 = Expression.Parameter(typeof(object), "obj");
                    ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param4 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");

                    MethodCallExpression body = Expression.Call(
                        null,
                        serialize,
                        param1,
                        ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                        param3,
                        param4);
                    Func<Stream, object, MessagePackSerializerOptions, CancellationToken, Task> lambda = Expression.Lambda<Func<Stream, object, MessagePackSerializerOptions, CancellationToken, Task>>(body, param1, param2, param3, param4).Compile(PreferInterpretation);

                    this.SerializeAsync_Stream_T_Options_CancellationToken = lambda;
#endif
                }

                {
                    // public static Task Serialize<T>(IBufferWriter<byte> writer, T obj, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo serialize = GetMethod(nameof(Serialize), type, new Type[] { typeof(IBufferWriter<byte>), null, typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Serialize_IBufferWriter_T_Options_CancellationToken = (x, y, z, a) => serialize.Invoke(null, new object[] { x, y, z, a });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(IBufferWriter<byte>), "writer");
                    ParameterExpression param2 = Expression.Parameter(typeof(object), "obj");
                    ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param4 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");

                    MethodCallExpression body = Expression.Call(
                        null,
                        serialize,
                        param1,
                        ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                        param3,
                        param4);
                    Action<IBufferWriter<byte>, object, MessagePackSerializerOptions, CancellationToken> lambda = Expression.Lambda<Action<IBufferWriter<byte>, object, MessagePackSerializerOptions, CancellationToken>>(body, param1, param2, param3, param4).Compile(PreferInterpretation);

                    this.Serialize_IBufferWriter_T_Options_CancellationToken = lambda;
#endif
                }

                {
                    // public static void Serialize<T>(ref MessagePackWriter writer, T obj, MessagePackSerializerOptions options)
                    MethodInfo serialize = GetMethod(nameof(Serialize), type, new Type[] { typeof(MessagePackWriter).MakeByRefType(), null, typeof(MessagePackSerializerOptions) });
#if ENABLE_IL2CPP
                    this.Serialize_MessagePackWriter_T_Options = (ref MessagePackWriter x, object y, MessagePackSerializerOptions z) => ThrowRefStructNotSupported();
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(MessagePackWriter).MakeByRefType(), "writer");
                    ParameterExpression param2 = Expression.Parameter(typeof(object), "obj");
                    ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");

                    MethodCallExpression body = Expression.Call(
                        null,
                        serialize,
                        param1,
                        ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                        param3);
                    MessagePackWriterSerialize lambda = Expression.Lambda<MessagePackWriterSerialize>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.Serialize_MessagePackWriter_T_Options = lambda;
#endif
                }

                {
                    // public static T Deserialize<T>(ref MessagePackReader reader, MessagePackSerializerOptions options)
                    MethodInfo deserialize = GetMethod(nameof(Deserialize), type, new Type[] { typeof(MessagePackReader).MakeByRefType(), typeof(MessagePackSerializerOptions) });
#if ENABLE_IL2CPP
                    this.Deserialize_MessagePackReader_Options = (ref MessagePackReader reader, MessagePackSerializerOptions options) => { ThrowRefStructNotSupported(); return null; };
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(MessagePackReader).MakeByRefType(), "reader");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    UnaryExpression body = Expression.Convert(Expression.Call(null, deserialize, param1, param2), typeof(object));
                    MessagePackReaderDeserialize lambda = Expression.Lambda<MessagePackReaderDeserialize>(body, param1, param2).Compile();

                    this.Deserialize_MessagePackReader_Options = lambda;
#endif
                }

                {
                    // public static T Deserialize<T>(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo deserialize = GetMethod(nameof(Deserialize), type, new Type[] { typeof(Stream), typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Deserialize_Stream_Options_CancellationToken = (x, y, z) => deserialize.Invoke(null, new object[] { x, y, z });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(Stream), "stream");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param3 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");
                    UnaryExpression body = Expression.Convert(Expression.Call(null, deserialize, param1, param2, param3), typeof(object));
                    Func<Stream, MessagePackSerializerOptions, CancellationToken, object> lambda = Expression.Lambda<Func<Stream, MessagePackSerializerOptions, CancellationToken, object>>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.Deserialize_Stream_Options_CancellationToken = lambda;
#endif
                }

                {
                    // public static ValueTask<object> DeserializeObjectAsync<T>(Stream stream, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo deserialize = GetMethod(nameof(DeserializeObjectAsync), type, new Type[] { typeof(Stream), typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.DeserializeAsync_Stream_Options_CancellationToken = (x, y, z) => (ValueTask<object>)deserialize.Invoke(null, new object[] { x, y, z });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(Stream), "stream");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param3 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");
                    UnaryExpression body = Expression.Convert(Expression.Call(null, deserialize, param1, param2, param3), typeof(ValueTask<object>));
                    Func<Stream, MessagePackSerializerOptions, CancellationToken, ValueTask<object>> lambda = Expression.Lambda<Func<Stream, MessagePackSerializerOptions, CancellationToken, ValueTask<object>>>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.DeserializeAsync_Stream_Options_CancellationToken = lambda;
#endif
                }

                {
                    // public static T Deserialize<T>(ReadOnlyMemory<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo deserialize = GetMethod(nameof(Deserialize), type, new Type[] { typeof(ReadOnlyMemory<byte>), typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Deserialize_ReadOnlyMemory_Options = (x, y, z) => deserialize.Invoke(null, new object[] { x, y, z });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(ReadOnlyMemory<byte>), "bytes");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param3 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");
                    UnaryExpression body = Expression.Convert(Expression.Call(null, deserialize, param1, param2, param3), typeof(object));
                    Func<ReadOnlyMemory<byte>, MessagePackSerializerOptions, CancellationToken, object> lambda = Expression.Lambda<Func<ReadOnlyMemory<byte>, MessagePackSerializerOptions, CancellationToken, object>>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.Deserialize_ReadOnlyMemory_Options = lambda;
#endif
                }

                {
                    // public static T Deserialize<T>(ReadOnlySequence<byte> bytes, MessagePackSerializerOptions options, CancellationToken cancellationToken)
                    MethodInfo deserialize = GetMethod(nameof(Deserialize), type, new Type[] { typeof(ReadOnlySequence<byte>).MakeByRefType(), typeof(MessagePackSerializerOptions), typeof(CancellationToken) });
#if ENABLE_IL2CPP
                    this.Deserialize_ReadOnlySequence_Options_CancellationToken = (x, y, z) => deserialize.Invoke(null, new object[] { x, y, z });
#else
                    ParameterExpression param1 = Expression.Parameter(typeof(ReadOnlySequence<byte>), "bytes");
                    ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");
                    ParameterExpression param3 = Expression.Parameter(typeof(CancellationToken), "cancellationToken");
                    UnaryExpression body = Expression.Convert(Expression.Call(null, deserialize, param1, param2, param3), typeof(object));
                    Func<ReadOnlySequence<byte>, MessagePackSerializerOptions, CancellationToken, object> lambda = Expression.Lambda<Func<ReadOnlySequence<byte>, MessagePackSerializerOptions, CancellationToken, object>>(body, param1, param2, param3).Compile(PreferInterpretation);

                    this.Deserialize_ReadOnlySequence_Options_CancellationToken = lambda;
#endif
                }
            }

            private static void ThrowRefStructNotSupported()
            {
                // C# 8.0 is not supported call `ref struct` via reflection. (It is milestoned at .NET 6)
                throw new NotSupportedException("MessagePackWriter/Reader overload is not supported in MessagePackSerializer.NonGenerics.");
            }

            // null is generic type marker.
            private static MethodInfo GetMethod(string methodName, Type type, Type[] parameters)
            {
                return typeof(MessagePackSerializer).GetRuntimeMethods().Single(x =>
                {
                    if (methodName != x.Name)
                    {
                        return false;
                    }

                    ParameterInfo[] ps = x.GetParameters();
                    if (ps.Length != parameters.Length)
                    {
                        return false;
                    }

                    for (int i = 0; i < ps.Length; i++)
                    {
                        if (parameters[i] == null && ps[i].ParameterType.IsGenericParameter)
                        {
                            continue;
                        }

                        if (ps[i].ParameterType != parameters[i])
                        {
                            return false;
                        }
                    }

                    return true;
                })
                .MakeGenericMethod(type);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializer.NonGeneric.cs.meta
================================================
fileFormatVersion: 2
guid: e094e2dba201ea84ba880d525ce8532e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializerOptions.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace MessagePack
{
#if !DYNAMICCODEDUMPER
    /// <summary>
    /// An immutable description of options for running the <see cref="MessagePackSerializer"/>.
    /// </summary>
#endif
    public class MessagePackSerializerOptions
    {
        // see:http://msdn.microsoft.com/en-us/library/w3f99sx1.aspx
        internal static readonly Regex AssemblyNameVersionSelectorRegex = new Regex(@", Version=\d+.\d+.\d+.\d+, Culture=[\w-]+, PublicKeyToken=(?:null|[a-f0-9]{16})$", RegexOptions.Compiled);

        /// <summary>
        /// A collection of known dangerous types that are not expected in a typical MessagePack stream,
        /// and thus are rejected by the default implementation of <see cref="ThrowIfDeserializingTypeIsDisallowed(Type)"/>.
        /// </summary>
        private static readonly HashSet<string> DisallowedTypes = new HashSet<string>
        {
            "System.CodeDom.Compiler.TempFileCollection",
            "System.Management.IWbemClassObjectFreeThreaded",
        };

#if !DYNAMICCODEDUMPER
        /// <summary>
        /// Gets a good default set of options that uses the <see cref="Resolvers.StandardResolver"/> and no compression.
        /// </summary>
        public static MessagePackSerializerOptions Standard => MessagePackSerializerOptionsDefaultSettingsLazyInitializationHelper.Standard;
#endif

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializerOptions"/> class.
        /// </summary>
        protected internal MessagePackSerializerOptions(IFormatterResolver resolver)
        {
            this.Resolver = resolver ?? throw new ArgumentNullException(nameof(resolver));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackSerializerOptions"/> class
        /// with members initialized from an existing instance.
        /// </summary>
        /// <param name="copyFrom">The options to copy from.</param>
        protected MessagePackSerializerOptions(MessagePackSerializerOptions copyFrom)
        {
            if (copyFrom == null)
            {
                throw new ArgumentNullException(nameof(copyFrom));
            }

            this.Resolver = copyFrom.Resolver;
            this.Compression = copyFrom.Compression;
            this.OldSpec = copyFrom.OldSpec;
            this.OmitAssemblyVersion = copyFrom.OmitAssemblyVersion;
            this.AllowAssemblyVersionMismatch = copyFrom.AllowAssemblyVersionMismatch;
            this.Security = copyFrom.Security;
        }

        /// <summary>
        /// Gets the resolver to use for complex types.
        /// </summary>
        /// <value>An instance of <see cref="IFormatterResolver"/>. Never <c>null</c>.</value>
        /// <exception cref="ArgumentNullException">Thrown if an attempt is made to set this property to <c>null</c>.</exception>
        public IFormatterResolver Resolver { get; private set; }

        /// <summary>
        /// Gets the compression scheme to apply to serialized sequences.
        /// </summary>
        /// <remarks>
        /// When set to something other than <see cref="MessagePackCompression.None"/>,
        /// deserialization can still work on uncompressed sequences,
        /// and serialization may not compress if msgpack sequences are short enough that compression would not likely be advantageous.
        /// </remarks>
        public MessagePackCompression Compression { get; private set; }

        /// <summary>
        /// Gets a value indicating whether to serialize with <see cref="MessagePackWriter.OldSpec"/> set to some value
        /// causing messagepack spec compliance to be explicitly set to the old or new format.
        /// </summary>
        /// <value>
        /// A null value means the <see cref="MessagePackWriter"/>'s default or previous setting will be used.
        /// A non-null value will be applied to the <see cref="MessagePackWriter.OldSpec"/> property for the duration of a
        /// serialization and then reverted to its prior setting.
        /// </value>
        /// <remarks>
        /// Reading always supports both new and old spec.
        /// </remarks>
        public bool? OldSpec { get; private set; }

        /// <summary>
        /// Gets a value indicating whether serialization should omit assembly version, culture and public key token metadata when using the typeless formatter.
        /// </summary>
        /// <value>The default value is <c>false</c>.</value>
        public bool OmitAssemblyVersion { get; private set; }

        /// <summary>
        /// Gets a value indicating whether deserialization may instantiate types from an assembly with a different version if a matching version cannot be found.
        /// </summary>
        /// <value>The default value is <c>false</c>.</value>
        public bool AllowAssemblyVersionMismatch { get; private set; }

        /// <summary>
        /// Gets the security-related options for deserializing messagepack sequences.
        /// </summary>
        /// <value>
        /// The default value is to use <see cref="MessagePackSecurity.TrustedData"/>.
        /// </value>
        public MessagePackSecurity Security { get; private set; } = MessagePackSecurity.TrustedData;

        /// <summary>
        /// Gets a type given a string representation of the type.
        /// </summary>
        /// <param name="typeName">The name of the type to load. This is typically the <see cref="Type.AssemblyQualifiedName"/> but may use the assembly's simple name.</param>
        /// <returns>The loaded type or <c>null</c> if no matching type could be found.</returns>
        public virtual Type LoadType(string typeName)
        {
            Type result = Type.GetType(typeName, false);
            if (result == null && this.AllowAssemblyVersionMismatch)
            {
                string shortenedName = AssemblyNameVersionSelectorRegex.Replace(typeName, string.Empty);
                if (shortenedName != typeName)
                {
                    result = Type.GetType(shortenedName, false);
                }
            }

            return result;
        }

        /// <summary>
        /// Checks whether a given type may be deserialized.
        /// </summary>
        /// <param name="type">The type to be instantiated.</param>
        /// <exception cref="TypeAccessException">Thrown if the <paramref name="type"/> is not allowed to be deserialized.</exception>
        /// <remarks>
        /// This method provides a means for an important security mitigation when using the Typeless formatter to prevent untrusted messagepack from
        /// deserializing objects that may be harmful if instantiated, disposed or finalized.
        /// The default implementation throws for only a few known dangerous types.
        /// Applications that deserialize from untrusted sources should override this method and throw if the type is not among the expected set.
        /// </remarks>
        public virtual void ThrowIfDeserializingTypeIsDisallowed(Type type)
        {
            if (DisallowedTypes.Contains(type.FullName))
            {
                throw new MessagePackSerializationException("Deserialization attempted to create the type " + type.FullName + " which is not allowed.");
            }
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="Resolver"/> property set to a new value.
        /// </summary>
        /// <param name="resolver">The new value for the <see cref="Resolver"/>.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithResolver(IFormatterResolver resolver)
        {
            if (this.Resolver == resolver)
            {
                return this;
            }

            var result = this.Clone();
            result.Resolver = resolver;
            return result;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="Compression"/> property set to a new value.
        /// </summary>
        /// <param name="compression">The new value for the <see cref="Compression"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithCompression(MessagePackCompression compression)
        {
            if (this.Compression == compression)
            {
                return this;
            }

            var result = this.Clone();
            result.Compression = compression;
            return result;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="OldSpec"/> property set to a new value.
        /// </summary>
        /// <param name="oldSpec">The new value for the <see cref="OldSpec"/>.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithOldSpec(bool? oldSpec = true)
        {
            if (this.OldSpec == oldSpec)
            {
                return this;
            }

            var result = this.Clone();
            result.OldSpec = oldSpec;
            return result;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="OmitAssemblyVersion"/> property set to a new value.
        /// </summary>
        /// <param name="omitAssemblyVersion">The new value for the <see cref="OmitAssemblyVersion"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithOmitAssemblyVersion(bool omitAssemblyVersion)
        {
            if (this.OmitAssemblyVersion == omitAssemblyVersion)
            {
                return this;
            }

            var result = this.Clone();
            result.OmitAssemblyVersion = omitAssemblyVersion;
            return result;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="AllowAssemblyVersionMismatch"/> property set to a new value.
        /// </summary>
        /// <param name="allowAssemblyVersionMismatch">The new value for the <see cref="AllowAssemblyVersionMismatch"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithAllowAssemblyVersionMismatch(bool allowAssemblyVersionMismatch)
        {
            if (this.AllowAssemblyVersionMismatch == allowAssemblyVersionMismatch)
            {
                return this;
            }

            var result = this.Clone();
            result.AllowAssemblyVersionMismatch = allowAssemblyVersionMismatch;
            return result;
        }

        /// <summary>
        /// Gets a copy of these options with the <see cref="Security"/> property set to a new value.
        /// </summary>
        /// <param name="security">The new value for the <see cref="Security"/> property.</param>
        /// <returns>The new instance; or the original if the value is unchanged.</returns>
        public MessagePackSerializerOptions WithSecurity(MessagePackSecurity security)
        {
            if (security is null)
            {
                throw new ArgumentNullException(nameof(security));
            }

            if (this.Security == security)
            {
                return this;
            }

            var result = this.Clone();
            result.Security = security;
            return result;
        }

        /// <summary>
        /// Creates a clone of this instance with the same properties set.
        /// </summary>
        /// <returns>The cloned instance. Guaranteed to be a new instance.</returns>
        /// <exception cref="NotSupportedException">Thrown if this instance is a derived type that doesn't override this method.</exception>
        protected virtual MessagePackSerializerOptions Clone()
        {
            if (this.GetType() != typeof(MessagePackSerializerOptions))
            {
                throw new NotSupportedException($"The derived type {this.GetType().FullName} did not override the {nameof(Clone)} method as required.");
            }

            return new MessagePackSerializerOptions(this);
        }

#if !DYNAMICCODEDUMPER
        private static class MessagePackSerializerOptionsDefaultSettingsLazyInitializationHelper
        {
            public static readonly MessagePackSerializerOptions Standard = new MessagePackSerializerOptions(Resolvers.StandardResolver.Instance);
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackSerializerOptions.cs.meta
================================================
fileFormatVersion: 2
guid: 621e07593f75d314eb0388aa92ef6805
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackStreamReader.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Nerdbank.Streams;

namespace MessagePack
{
    /// <summary>
    /// Reads one or more messagepack data structures from a <see cref="Stream"/>.
    /// </summary>
    /// <remarks>
    /// This class is *not* thread-safe. Do not call more than one member at once and be sure any call completes (including asynchronous tasks)
    /// before calling the next one.
    /// </remarks>
    public partial class MessagePackStreamReader : IDisposable
    {
        private readonly Stream stream;
        private readonly bool leaveOpen;
        private SequencePool.Rental sequenceRental = SequencePool.Shared.Rent();
        private SequencePosition? endOfLastMessage;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackStreamReader"/> class.
        /// </summary>
        /// <param name="stream">The stream to read from. This stream will be disposed of when this <see cref="MessagePackStreamReader"/> is disposed.</param>
        public MessagePackStreamReader(Stream stream)
            : this(stream, leaveOpen: false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessagePackStreamReader"/> class.
        /// </summary>
        /// <param name="stream">The stream to read from.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after this <see cref="MessagePackStreamReader"/> is disposed; otherwise, false.</param>
        public MessagePackStreamReader(Stream stream, bool leaveOpen)
        {
            this.stream = stream ?? throw new ArgumentNullException(nameof(stream));
            this.leaveOpen = leaveOpen;
        }

        /// <summary>
        /// Gets any bytes that have been read since the last complete message returned from <see cref="ReadAsync(CancellationToken)"/>.
        /// </summary>
        public ReadOnlySequence<byte> RemainingBytes => this.endOfLastMessage.HasValue ? this.ReadData.AsReadOnlySequence.Slice(this.endOfLastMessage.Value) : this.ReadData.AsReadOnlySequence;

        /// <summary>
        /// Gets the sequence that we read data from the <see cref="stream"/> into.
        /// </summary>
        private Sequence<byte> ReadData => this.sequenceRental.Value;

        /// <summary>
        /// Reads the next whole (top-level) messagepack data structure.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>
        /// A task whose result is the next whole data structure from the stream, or <c>null</c> if the stream ends.
        /// The returned sequence is valid until this <see cref="MessagePackStreamReader"/> is disposed or
        /// until this method is called again, whichever comes first.
        /// </returns>
        /// <remarks>
        /// When <c>null</c> is the result of the returned task,
        /// any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="RemainingBytes"/> property.
        /// </remarks>
        public async ValueTask<ReadOnlySequence<byte>?> ReadAsync(CancellationToken cancellationToken)
        {
            this.RecycleLastMessage();

            while (true)
            {
                // Check if we have a complete message and return it if we have it.
                // We do this before reading anything since a previous read may have brought in several messages.
                cancellationToken.ThrowIfCancellationRequested();
                if (this.TryReadNextMessage(out ReadOnlySequence<byte> completeMessage))
                {
                    return completeMessage;
                }

                if (!await this.TryReadMoreDataAsync(cancellationToken).ConfigureAwait(false))
                {
                    // We've reached the end of the stream.
                    // We already checked for a complete message with what we already had, so evidently it's not a complete message.
                    return null;
                }
            }
        }

        /// <summary>
        /// Arranges for the next read operation to start by reading from the underlying <see cref="Stream"/>
        /// instead of any data buffered from a previous read.
        /// </summary>
        /// <remarks>
        /// This is appropriate if the underlying <see cref="Stream"/> has been repositioned such that
        /// any previously buffered data is no longer applicable to what the caller wants to read.
        /// </remarks>
        public void DiscardBufferedData()
        {
            this.sequenceRental.Value.Reset();
            this.endOfLastMessage = default;
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            if (!this.leaveOpen)
            {
                this.stream.Dispose();
            }

            this.sequenceRental.Dispose();
            this.sequenceRental = default;
        }

        /// <summary>
        /// Recycle memory from a previously returned message.
        /// </summary>
        private void RecycleLastMessage()
        {
            if (this.endOfLastMessage.HasValue)
            {
                // A previously returned message can now be safely recycled since the caller wants more.
                this.ReadData.AdvanceTo(this.endOfLastMessage.Value);
                this.endOfLastMessage = null;
            }
        }

        /// <summary>
        /// Read more data from the stream into the <see cref="ReadData"/> buffer.
        /// </summary>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns><c>true</c> if more data was read; <c>false</c> if the end of the stream had already been reached.</returns>
        private async Task<bool> TryReadMoreDataAsync(CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            Memory<byte> buffer = this.ReadData.GetMemory(sizeHint: 0);
            int bytesRead = 0;
            try
            {
                bytesRead = await this.stream.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
                return bytesRead > 0;
            }
            finally
            {
                // Keep our state clean in case the caller wants to call us again.
                this.ReadData.Advance(bytesRead);
            }
        }

        /// <summary>
        /// Checks whether the content in <see cref="ReadData"/> include a complete messagepack structure.
        /// </summary>
        /// <param name="completeMessage">Receives the sequence of the first complete data structure found, if any.</param>
        /// <returns><c>true</c> if a complete data structure was found; <c>false</c> otherwise.</returns>
        private bool TryReadNextMessage(out ReadOnlySequence<byte> completeMessage)
        {
            if (this.ReadData.Length > 0)
            {
                var reader = new MessagePackReader(this.ReadData);

                // Perf opportunity: instead of skipping from the start each time, we could incrementally skip across tries
                // possibly as easy as simply keeping a count of how many tokens still need to be skipped (that we know about).
                if (reader.TrySkip())
                {
                    this.endOfLastMessage = reader.Position;
                    completeMessage = reader.Sequence.Slice(0, reader.Position);
                    return true;
                }
            }

            completeMessage = default;
            return false;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackStreamReader.cs.meta
================================================
fileFormatVersion: 2
guid: 40b616b9ee299b04c97f5efb6c1cde9c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MessagePackWriter.cs.meta
================================================
fileFormatVersion: 2
guid: a22e47d7013792844bd7882f11f25e1d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MonoProtection.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Threading;

namespace MessagePack
{
    /// <summary>
    /// Special behavior for running on the mono runtime.
    /// </summary>
    internal struct MonoProtection
    {
        /// <summary>
        /// Gets a value indicating whether the mono runtime is executing this code.
        /// </summary>
        internal static bool IsRunningOnMono => Type.GetType("Mono.Runtime") != null;

        /// <summary>
        /// A lock that we enter on mono when generating dynamic types.
        /// </summary>
        private static readonly object RefEmitLock = new object();

        /// <summary>
        /// The method to call within the expression of a <c>using</c> statement whose block surrounds all Ref.Emit code.
        /// </summary>
        /// <returns>The value to be disposed of to exit the Ref.Emit lock.</returns>
        /// <remarks>
        /// This is a no-op except when running on Mono.
        /// <see href="https://github.com/mono/mono/issues/20369#issuecomment-690316456">Mono's implementation of Ref.Emit is not thread-safe</see> so we have to lock around all use of it
        /// when using that runtime.
        /// </remarks>
        internal static MonoProtectionDisposal EnterRefEmitLock() => IsRunningOnMono ? new MonoProtectionDisposal(RefEmitLock) : default;
    }

    internal struct MonoProtectionDisposal : IDisposable
    {
        private readonly object lockObject;

        internal MonoProtectionDisposal(object lockObject)
        {
            this.lockObject = lockObject;
            Monitor.Enter(lockObject);
        }

        public void Dispose()
        {
            if (this.lockObject is object)
            {
                Monitor.Exit(this.lockObject);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/MonoProtection.cs.meta
================================================
guid: 593f3b742b875ea48943776d02f8d3a9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Nil.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;

namespace MessagePack
{
#if MESSAGEPACK_INTERNAL
    internal
#else
    public
#endif
    struct Nil : IEquatable<Nil>
    {
        public static readonly Nil Default = default(Nil);

        public override bool Equals(object obj)
        {
            return obj is Nil;
        }

        public bool Equals(Nil other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            return 0;
        }

        public override string ToString()
        {
            return "()";
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Nil.cs.meta
================================================
fileFormatVersion: 2
guid: f5ce64c07ab69e449bdf3e4144c199dd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/package.json
================================================
{
    "name": "com.neuecc.messagepack",
    "displayName": "MessagePack",
    "version": "2.2.60",
    "unity": "2018.4",
    "description": "Extremely Fast MessagePack Serializer for C#.",
    "keywords": [ "Serializer" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/package.json.meta
================================================
fileFormatVersion: 2
guid: 3b8639f4c743fac45bc51854f278b3b1
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers.meta
================================================
fileFormatVersion: 2
guid: 2f263bacc77eeb840ae8872f2025f96a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SafeBitConverter.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.InteropServices;

namespace MessagePack
{
    internal static class SafeBitConverter
    {
        internal static long ToInt64(ReadOnlySpan<byte> value)
        {
#if UNITY_ANDROID
            if (BitConverter.IsLittleEndian)
            {
                int i1 = value[0] | (value[1] << 8) | (value[2] << 16) | (value[3] << 24);
                int i2 = value[4] | (value[5] << 8) | (value[6] << 16) | (value[7] << 24);
                return (uint)i1 | ((long)i2 << 32);
            }
            else
            {
                int i1 = (value[0] << 24) | (value[1] << 16) | (value[2] << 8) | value[3];
                int i2 = (value[4] << 24) | (value[5] << 16) | (value[6] << 8) | value[7];
                return (uint)i2 | ((long)i1 << 32);
            }
#else
            return MemoryMarshal.Cast<byte, long>(value)[0];
#endif
        }

        internal static ulong ToUInt64(ReadOnlySpan<byte> value) => unchecked((ulong)ToInt64(value));

        internal static ushort ToUInt16(ReadOnlySpan<byte> value)
        {
#if UNITY_ANDROID
            if (BitConverter.IsLittleEndian)
            {
                return (ushort)(value[0] | (value[1] << 8));
            }
            else
            {
                return (ushort)((value[0] << 8) | value[1]);
            }
#else
            return MemoryMarshal.Cast<byte, ushort>(value)[0];
#endif
        }

        internal static uint ToUInt32(ReadOnlySpan<byte> value)
        {
#if UNITY_ANDROID
            if (BitConverter.IsLittleEndian)
            {
                return (uint)(value[0] | (value[1] << 8) | (value[2] << 16) | (value[3] << 24));
            }
            else
            {
                return (uint)((value[0] << 24) | (value[1] << 16) | (value[2] << 8) | value[3]);
            }
#else
            return MemoryMarshal.Cast<byte, uint>(value)[0];
#endif
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SafeBitConverter.cs.meta
================================================
fileFormatVersion: 2
guid: 1a2f0bfda50859f4abf45bc978ea8b16
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequencePool.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections.Generic;
using Nerdbank.Streams;

namespace MessagePack
{
    /// <summary>
    /// A thread-safe, alloc-free reusable object pool.
    /// </summary>
    internal class SequencePool
    {
        /// <summary>
        /// A thread-safe pool of reusable <see cref="Sequence{T}"/> objects.
        /// </summary>
        /// <remarks>
        /// We use a <see cref="maxSize"/> that allows every processor to be involved in messagepack serialization concurrently,
        /// plus one nested serialization per processor (since LZ4 and sometimes other nested serializations may exist).
        /// </remarks>
        internal static readonly SequencePool Shared = new SequencePool(Environment.ProcessorCount * 2);

        /// <summary>
        /// The value to use for <see cref="Sequence{T}.MinimumSpanLength"/>.
        /// </summary>
        /// <remarks>
        /// Individual users that want a different value for this can modify the setting on the rented <see cref="Sequence{T}"/>
        /// or by supplying their own <see cref="IBufferWriter{T}" />.
        /// </remarks>
        /// <devremarks>
        /// We use 32KB so that when LZ4Codec.MaximumOutputLength is used on this length it does not require a
        /// buffer that would require the Large Object Heap.
        /// </devremarks>
        private const int MinimumSpanLength = 32 * 1024;

        private readonly int maxSize;
        private readonly Stack<Sequence<byte>> pool = new Stack<Sequence<byte>>();

        /// <summary>
        /// The array pool which we share with all <see cref="Sequence{T}"/> objects created by this <see cref="SequencePool"/> instance.
        /// </summary>
        /// <devremarks>
        /// We allow 100 arrays to be shared (instead of the default 50) and reduce the max array length from the default 1MB to something more reasonable for our expected use.
        /// </devremarks>
        private readonly ArrayPool<byte> arrayPool = ArrayPool<byte>.Create(80 * 1024, 100);

        /// <summary>
        /// Initializes a new instance of the <see cref="SequencePool"/> class.
        /// </summary>
        /// <param name="maxSize">The maximum size to allow the pool to grow.</param>
        internal SequencePool(int maxSize)
        {
            this.maxSize = maxSize;
        }

        /// <summary>
        /// Gets an instance of <see cref="Sequence{T}"/>
        /// This is taken from the recycled pool if one is available; otherwise a new one is created.
        /// </summary>
        /// <returns>The rental tracker that provides access to the object as well as a means to return it.</returns>
        internal Rental Rent()
        {
            lock (this.pool)
            {
                if (this.pool.Count > 0)
                {
                    return new Rental(this, this.pool.Pop());
                }
            }

            // Configure the newly created object to share a common array pool with the other instances,
            // otherwise each one will have its own ArrayPool which would likely waste a lot of memory.
            return new Rental(this, new Sequence<byte>(this.arrayPool) { MinimumSpanLength = MinimumSpanLength });
        }

        private void Return(Sequence<byte> value)
        {
            value.Reset();
            lock (this.pool)
            {
                if (this.pool.Count < this.maxSize)
                {
                    // Reset to preferred settings in case the renter changed them.
                    value.MinimumSpanLength = MinimumSpanLength;

                    this.pool.Push(value);
                }
            }
        }

        internal struct Rental : IDisposable
        {
            private readonly SequencePool owner;

            internal Rental(SequencePool owner, Sequence<byte> value)
            {
                this.owner = owner;
                this.Value = value;
            }

            /// <summary>
            /// Gets the recyclable object.
            /// </summary>
            public Sequence<byte> Value { get; }

            /// <summary>
            /// Returns the recyclable object to the pool.
            /// </summary>
            /// <remarks>
            /// The instance is cleaned first, if a clean delegate was provided.
            /// It is dropped instead of being returned to the pool if the pool is already at its maximum size.
            /// </remarks>
            public void Dispose()
            {
                this.owner?.Return(this.Value);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequencePool.cs.meta
================================================
fileFormatVersion: 2
guid: 97164d8f34ce72f459fc5dff3dc7370f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequenceReader.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information. */

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MessagePack
{
    internal ref partial struct SequenceReader<T>
        where T : unmanaged, IEquatable<T>
    {
        /// <summary>
        /// A value indicating whether we're using <see cref="sequence"/> (as opposed to <see cref="memory"/>.
        /// </summary>
        private bool usingSequence;

        /// <summary>
        /// Backing for the entire sequence when we're not using <see cref="memory"/>.
        /// </summary>
        private ReadOnlySequence<T> sequence;

        /// <summary>
        /// The position at the start of the <see cref="CurrentSpan"/>.
        /// </summary>
        private SequencePosition currentPosition;

        /// <summary>
        /// The position at the end of the <see cref="CurrentSpan"/>.
        /// </summary>
        private SequencePosition nextPosition;

        /// <summary>
        /// Backing for the entire sequence when we're not using <see cref="sequence"/>.
        /// </summary>
        private ReadOnlyMemory<T> memory;

        /// <summary>
        /// A value indicating whether there is unread data remaining.
        /// </summary>
        private bool moreData;

        /// <summary>
        /// The total number of elements in the sequence.
        /// </summary>
        private long length;

        /// <summary>
        /// Initializes a new instance of the <see cref="SequenceReader{T}"/> struct
        /// over the given <see cref="ReadOnlySequence{T}"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SequenceReader(in ReadOnlySequence<T> sequence)
        {
            this.usingSequence = true;
            this.CurrentSpanIndex = 0;
            this.Consumed = 0;
            this.sequence = sequence;
            this.memory = default;
            this.currentPosition = sequence.Start;
            this.length = -1;

            ReadOnlySpan<T> first = sequence.First.Span;
            this.nextPosition = sequence.GetPosition(first.Length);
            this.CurrentSpan = first;
            this.moreData = first.Length > 0;

            if (!this.moreData && !sequence.IsSingleSegment)
            {
                this.moreData = true;
                this.GetNextSpan();
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SequenceReader{T}"/> struct
        /// over the given <see cref="ReadOnlyMemory{T}"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SequenceReader(ReadOnlyMemory<T> memory)
        {
            this.usingSequence = false;
            this.CurrentSpanIndex = 0;
            this.Consumed = 0;
            this.memory = memory;
            this.CurrentSpan = memory.Span;
            this.length = memory.Length;
            this.moreData = memory.Length > 0;

            this.currentPosition = default;
            this.nextPosition = default;
            this.sequence = default;
        }

        /// <summary>
        /// Gets a value indicating whether there is no more data in the <see cref="Sequence"/>.
        /// </summary>
        public bool End => !this.moreData;

        /// <summary>
        /// Gets the underlying <see cref="ReadOnlySequence{T}"/> for the reader.
        /// </summary>
        public ReadOnlySequence<T> Sequence
        {
            get
            {
                if (this.sequence.IsEmpty && !this.memory.IsEmpty)
                {
                    // We're in memory mode (instead of sequence mode).
                    // Lazily fill in the sequence data.
                    this.sequence = new ReadOnlySequence<T>(this.memory);
                    this.currentPosition = this.sequence.Start;
                    this.nextPosition = this.sequence.End;
                }

                return this.sequence;
            }
        }

        /// <summary>
        /// Gets the current position in the <see cref="Sequence"/>.
        /// </summary>
        public SequencePosition Position
            => this.Sequence.GetPosition(this.CurrentSpanIndex, this.currentPosition);

        /// <summary>
        /// Gets the current segment in the <see cref="Sequence"/> as a span.
        /// </summary>
        public ReadOnlySpan<T> CurrentSpan { get; private set; }

        /// <summary>
        /// Gets the index in the <see cref="CurrentSpan"/>.
        /// </summary>
        public int CurrentSpanIndex { get; private set; }

        /// <summary>
        /// Gets the unread portion of the <see cref="CurrentSpan"/>.
        /// </summary>
        public ReadOnlySpan<T> UnreadSpan
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => this.CurrentSpan.Slice(this.CurrentSpanIndex);
        }

        /// <summary>
        /// Gets the total number of <typeparamref name="T"/>'s processed by the reader.
        /// </summary>
        public long Consumed { get; private set; }

        /// <summary>
        /// Gets remaining <typeparamref name="T"/>'s in the reader's <see cref="Sequence"/>.
        /// </summary>
        public long Remaining => this.Length - this.Consumed;

        /// <summary>
        /// Gets count of <typeparamref name="T"/> in the reader's <see cref="Sequence"/>.
        /// </summary>
        public long Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (this.length < 0)
                {
                    // Cache the length
                    this.length = this.Sequence.Length;
                }

                return this.length;
            }
        }

        /// <summary>
        /// Peeks at the next value without advancing the reader.
        /// </summary>
        /// <param name="value">The next value or default if at the end.</param>
        /// <returns>False if at the end of the reader.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryPeek(out T value)
        {
            if (this.moreData)
            {
                value = this.CurrentSpan[this.CurrentSpanIndex];
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        /// <summary>
        /// Read the next value and advance the reader.
        /// </summary>
        /// <param name="value">The next value or default if at the end.</param>
        /// <returns>False if at the end of the reader.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryRead(out T value)
        {
            if (this.End)
            {
                value = default;
                return false;
            }

            value = this.CurrentSpan[this.CurrentSpanIndex];
            this.CurrentSpanIndex++;
            this.Consumed++;

            if (this.CurrentSpanIndex >= this.CurrentSpan.Length)
            {
                if (this.usingSequence)
                {
                    this.GetNextSpan();
                }
                else
                {
                    this.moreData = false;
                }
            }

            return true;
        }

        /// <summary>
        /// Move the reader back the specified number of items.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rewind(long count)
        {
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count));
            }

            this.Consumed -= count;

            if (this.CurrentSpanIndex >= count)
            {
                this.CurrentSpanIndex -= (int)count;
                this.moreData = true;
            }
            else if (this.usingSequence)
            {
                // Current segment doesn't have enough data, scan backward through segments
                this.RetreatToPreviousSpan(this.Consumed);
            }
            else
            {
                throw new ArgumentOutOfRangeException("Rewind went past the start of the memory.");
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void RetreatToPreviousSpan(long consumed)
        {
            Debug.Assert(this.usingSequence, "usingSequence");
            this.ResetReader();
            this.Advance(consumed);
        }

        private void ResetReader()
        {
            Debug.Assert(this.usingSequence, "usingSequence");
            this.CurrentSpanIndex = 0;
            this.Consumed = 0;
            this.currentPosition = this.Sequence.Start;
            this.nextPosition = this.currentPosition;

            if (this.Sequence.TryGet(ref this.nextPosition, out ReadOnlyMemory<T> memory, advance: true))
            {
                this.moreData = true;

                if (memory.Length == 0)
                {
                    this.CurrentSpan = default;

                    // No data in the first span, move to one with data
                    this.GetNextSpan();
                }
                else
                {
                    this.CurrentSpan = memory.Span;
                }
            }
            else
            {
                // No data in any spans and at end of sequence
                this.moreData = false;
                this.CurrentSpan = default;
            }
        }

        /// <summary>
        /// Get the next segment with available data, if any.
        /// </summary>
        private void GetNextSpan()
        {
            Debug.Assert(this.usingSequence, "usingSequence");
            if (!this.Sequence.IsSingleSegment)
            {
                SequencePosition previousNextPosition = this.nextPosition;
                while (this.Sequence.TryGet(ref this.nextPosition, out ReadOnlyMemory<T> memory, advance: true))
                {
                    this.currentPosition = previousNextPosition;
                    if (memory.Length > 0)
                    {
                        this.CurrentSpan = memory.Span;
                        this.CurrentSpanIndex = 0;
                        return;
                    }
                    else
                    {
                        this.CurrentSpan = default;
                        this.CurrentSpanIndex = 0;
                        previousNextPosition = this.nextPosition;
                    }
                }
            }

            this.moreData = false;
        }

        /// <summary>
        /// Move the reader ahead the specified number of items.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Advance(long count)
        {
            const long TooBigOrNegative = unchecked((long)0xFFFFFFFF80000000);
            if ((count & TooBigOrNegative) == 0 && this.CurrentSpan.Length - this.CurrentSpanIndex > (int)count)
            {
                this.CurrentSpanIndex += (int)count;
                this.Consumed += count;
            }
            else if (this.usingSequence)
            {
                // Can't satisfy from the current span
                this.AdvanceToNextSpan(count);
            }
            else if (this.CurrentSpan.Length - this.CurrentSpanIndex == (int)count)
            {
                this.CurrentSpanIndex += (int)count;
                this.Consumed += count;
                this.moreData = false;
            }
            else
            {
                throw new ArgumentOutOfRangeException(nameof(count));
            }
        }

        /// <summary>
        /// Unchecked helper to avoid unnecessary checks where you know count is valid.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void AdvanceCurrentSpan(long count)
        {
            Debug.Assert(count >= 0, "count >= 0");

            this.Consumed += count;
            this.CurrentSpanIndex += (int)count;
            if (this.usingSequence && this.CurrentSpanIndex >= this.CurrentSpan.Length)
            {
                this.GetNextSpan();
            }
        }

        /// <summary>
        /// Only call this helper if you know that you are advancing in the current span
        /// with valid count and there is no need to fetch the next one.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void AdvanceWithinSpan(long count)
        {
            Debug.Assert(count >= 0, "count >= 0");

            this.Consumed += count;
            this.CurrentSpanIndex += (int)count;

            Debug.Assert(this.CurrentSpanIndex < this.CurrentSpan.Length, "this.CurrentSpanIndex < this.CurrentSpan.Length");
        }

        /// <summary>
        /// Move the reader ahead the specified number of items
        /// if there are enough elements remaining in the sequence.
        /// </summary>
        /// <returns><c>true</c> if there were enough elements to advance; otherwise <c>false</c>.</returns>
        internal bool TryAdvance(long count)
        {
            if (this.Remaining < count)
            {
                return false;
            }

            this.Advance(count);
            return true;
        }

        private void AdvanceToNextSpan(long count)
        {
            Debug.Assert(this.usingSequence, "usingSequence");
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count));
            }

            this.Consumed += count;
            while (this.moreData)
            {
                int remaining = this.CurrentSpan.Length - this.CurrentSpanIndex;

                if (remaining > count)
                {
                    this.CurrentSpanIndex += (int)count;
                    count = 0;
                    break;
                }

                // As there may not be any further segments we need to
                // push the current index to the end of the span.
                this.CurrentSpanIndex += remaining;
                count -= remaining;
                Debug.Assert(count >= 0, "count >= 0");

                this.GetNextSpan();

                if (count == 0)
                {
                    break;
                }
            }

            if (count != 0)
            {
                // Not enough data left- adjust for where we actually ended and throw
                this.Consumed -= count;
                throw new ArgumentOutOfRangeException(nameof(count));
            }
        }

        /// <summary>
        /// Copies data from the current <see cref="Position"/> to the given <paramref name="destination"/> span.
        /// </summary>
        /// <param name="destination">Destination to copy to.</param>
        /// <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryCopyTo(Span<T> destination)
        {
            ReadOnlySpan<T> firstSpan = this.UnreadSpan;
            if (firstSpan.Length >= destination.Length)
            {
                firstSpan.Slice(0, destination.Length).CopyTo(destination);
                return true;
            }

            return this.TryCopyMultisegment(destination);
        }

        internal bool TryCopyMultisegment(Span<T> destination)
        {
            if (this.Remaining < destination.Length)
            {
                return false;
            }

            ReadOnlySpan<T> firstSpan = this.UnreadSpan;
            Debug.Assert(firstSpan.Length < destination.Length, "firstSpan.Length < destination.Length");
            firstSpan.CopyTo(destination);
            int copied = firstSpan.Length;

            SequencePosition next = this.nextPosition;
            while (this.Sequence.TryGet(ref next, out ReadOnlyMemory<T> nextSegment, true))
            {
                if (nextSegment.Length > 0)
                {
                    ReadOnlySpan<T> nextSpan = nextSegment.Span;
                    int toCopy = Math.Min(nextSpan.Length, destination.Length - copied);
                    nextSpan.Slice(0, toCopy).CopyTo(destination.Slice(copied));
                    copied += toCopy;
                    if (copied >= destination.Length)
                    {
                        break;
                    }
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequenceReader.cs.meta
================================================
fileFormatVersion: 2
guid: 73a26645b66741b4081b24bbec4379c9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequenceReaderExtensions.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information. */

using System;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MessagePack
{
    internal static partial class SequenceReaderExtensions
    {
        /// <summary>
        /// Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
        /// structs- see remarks for full details.
        /// </summary>
        /// <remarks>
        /// IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of its members to
        /// behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
        /// overloads such as <see cref="TryReadBigEndian(ref SequenceReader{byte}, out short)"/>.
        /// </remarks>
        /// <returns>
        /// True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static unsafe bool TryRead<T>(ref this SequenceReader<byte> reader, out T value)
            where T : unmanaged
        {
            ReadOnlySpan<byte> span = reader.UnreadSpan;
            if (span.Length < sizeof(T))
            {
                return TryReadMultisegment(ref reader, out value);
            }

            value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(span));
            reader.Advance(sizeof(T));
            return true;
        }

#if UNITY_ANDROID

        /// <summary>
        /// In Android 32bit device(armv7) + IL2CPP does not work correctly on Unsafe.ReadUnaligned.
        /// Perhaps it is about memory alignment bug of Unity's IL2CPP VM.
        /// For a workaround, read memory manually.
        /// https://github.com/neuecc/MessagePack-CSharp/issues/748
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static unsafe bool TryRead(ref this SequenceReader<byte> reader, out long value)
        {
            ReadOnlySpan<byte> span = reader.UnreadSpan;
            if (span.Length < sizeof(long))
            {
                return TryReadMultisegment(ref reader, out value);
            }

            value = MessagePack.SafeBitConverter.ToInt64(span);
            reader.Advance(sizeof(long));
            return true;
        }

#endif

        private static unsafe bool TryReadMultisegment<T>(ref SequenceReader<byte> reader, out T value)
            where T : unmanaged
        {
            Debug.Assert(reader.UnreadSpan.Length < sizeof(T), "reader.UnreadSpan.Length < sizeof(T)");

            // Not enough data in the current segment, try to peek for the data we need.
            T buffer = default;
            Span<byte> tempSpan = new Span<byte>(&buffer, sizeof(T));

            if (!reader.TryCopyTo(tempSpan))
            {
                value = default;
                return false;
            }

            value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(tempSpan));
            reader.Advance(sizeof(T));
            return true;
        }

#if UNITY_ANDROID

        private static unsafe bool TryReadMultisegment(ref SequenceReader<byte> reader, out long value)
        {
            Debug.Assert(reader.UnreadSpan.Length < sizeof(long), "reader.UnreadSpan.Length < sizeof(long)");

            // Not enough data in the current segment, try to peek for the data we need.
            long buffer = default;
            Span<byte> tempSpan = new Span<byte>(&buffer, sizeof(long));

            if (!reader.TryCopyTo(tempSpan))
            {
                value = default;
                return false;
            }

            value = MessagePack.SafeBitConverter.ToInt64(tempSpan);
            reader.Advance(sizeof(long));
            return true;
        }

#endif

        /// <summary>
        /// Reads an <see cref="sbyte"/> from the next position in the sequence.
        /// </summary>
        /// <param name="reader">The reader to read from.</param>
        /// <param name="value">Receives the value read.</param>
        /// <returns><c>true</c> if there was another byte in the sequence; <c>false</c> otherwise.</returns>
        public static bool TryRead(ref this SequenceReader<byte> reader, out sbyte value)
        {
            if (TryRead(ref reader, out byte byteValue))
            {
                value = unchecked((sbyte)byteValue);
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Reads an <see cref="Int16"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="Int16"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out short value)
        {
            if (!BitConverter.IsLittleEndian)
            {
                return reader.TryRead(out value);
            }

            return TryReadReverseEndianness(ref reader, out value);
        }

        /// <summary>
        /// Reads an <see cref="UInt16"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="UInt16"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out ushort value)
        {
            if (TryReadBigEndian(ref reader, out short shortValue))
            {
                value = unchecked((ushort)shortValue);
                return true;
            }

            value = default;
            return false;
        }

        private static bool TryReadReverseEndianness(ref SequenceReader<byte> reader, out short value)
        {
            if (reader.TryRead(out value))
            {
                value = BinaryPrimitives.ReverseEndianness(value);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads an <see cref="Int32"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="Int32"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out int value)
        {
            if (!BitConverter.IsLittleEndian)
            {
                return reader.TryRead(out value);
            }

            return TryReadReverseEndianness(ref reader, out value);
        }

        /// <summary>
        /// Reads an <see cref="UInt32"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="UInt32"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out uint value)
        {
            if (TryReadBigEndian(ref reader, out int intValue))
            {
                value = unchecked((uint)intValue);
                return true;
            }

            value = default;
            return false;
        }

        private static bool TryReadReverseEndianness(ref SequenceReader<byte> reader, out int value)
        {
            if (reader.TryRead(out value))
            {
                value = BinaryPrimitives.ReverseEndianness(value);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads an <see cref="Int64"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="Int64"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out long value)
        {
            if (!BitConverter.IsLittleEndian)
            {
                return reader.TryRead(out value);
            }

            return TryReadReverseEndianness(ref reader, out value);
        }

        /// <summary>
        /// Reads an <see cref="UInt64"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for an <see cref="UInt64"/>.</returns>
        public static bool TryReadBigEndian(ref this SequenceReader<byte> reader, out ulong value)
        {
            if (TryReadBigEndian(ref reader, out long longValue))
            {
                value = unchecked((ulong)longValue);
                return true;
            }

            value = default;
            return false;
        }

        private static bool TryReadReverseEndianness(ref SequenceReader<byte> reader, out long value)
        {
            if (reader.TryRead(out value))
            {
                value = BinaryPrimitives.ReverseEndianness(value);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads a <see cref="Single"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for a <see cref="Single"/>.</returns>
        public static unsafe bool TryReadBigEndian(ref this SequenceReader<byte> reader, out float value)
        {
            if (TryReadBigEndian(ref reader, out int intValue))
            {
                value = *(float*)&intValue;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Reads a <see cref="Double"/> as big endian.
        /// </summary>
        /// <returns>False if there wasn't enough data for a <see cref="Double"/>.</returns>
        public static unsafe bool TryReadBigEndian(ref this SequenceReader<byte> reader, out double value)
        {
            if (TryReadBigEndian(ref reader, out long longValue))
            {
                value = *(double*)&longValue;
                return true;
            }

            value = default;
            return false;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/SequenceReaderExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 74337ad77e62e5942b20dc45b62ddeab
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/StreamPolyfillExtensions.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft;

namespace MessagePack
{
#if !SPAN_BUILTIN
    internal static class StreamPolyfillExtensions
    {
        /// <summary>
        /// Reads from the stream into a memory buffer.
        /// </summary>
        /// <param name="stream">The stream to read from.</param>
        /// <param name="buffer">The buffer to read directly into.</param>
        /// <returns>The number of bytes actually read.</returns>
        internal static int Read(this Stream stream, Span<byte> buffer)
        {
            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            byte[] array = ArrayPool<byte>.Shared.Rent(buffer.Length);
            try
            {
                int bytesRead = stream.Read(array, 0, buffer.Length);
                new Span<byte>(array, 0, bytesRead).CopyTo(buffer);
                return bytesRead;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Reads from the stream into a memory buffer.
        /// </summary>
        /// <param name="stream">The stream to read from.</param>
        /// <param name="buffer">The buffer to read directly into.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        /// <returns>The number of bytes actually read.</returns>
        /// <devremarks>
        /// This method shamelessly copied from the .NET Core 2.1 Stream class: https://github.com/dotnet/coreclr/blob/a113b1c803783c9d64f1f0e946ff9a853e3bc140/src/System.Private.CoreLib/shared/System/IO/Stream.cs#L366-L391.
        /// </devremarks>
        internal static ValueTask<int> ReadAsync(this Stream stream, Memory<byte> buffer, CancellationToken cancellationToken = default)
        {
            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            if (MemoryMarshal.TryGetArray(buffer, out ArraySegment<byte> array))
            {
                return new ValueTask<int>(stream.ReadAsync(array.Array, array.Offset, array.Count, cancellationToken));
            }
            else
            {
                byte[] sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
                return FinishReadAsync(stream.ReadAsync(sharedBuffer, 0, buffer.Length, cancellationToken), sharedBuffer, buffer);

                async ValueTask<int> FinishReadAsync(Task<int> readTask, byte[] localBuffer, Memory<byte> localDestination)
                {
                    try
                    {
                        int result = await readTask.ConfigureAwait(false);
                        new Span<byte>(localBuffer, 0, result).CopyTo(localDestination.Span);
                        return result;
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(localBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Writes a span to the stream.
        /// </summary>
        /// <param name="stream">The stream to write to.</param>
        /// <param name="buffer">The buffer to write.</param>
        internal static void Write(this Stream stream, ReadOnlySpan<byte> buffer)
        {
            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
            try
            {
                buffer.CopyTo(sharedBuffer);
                stream.Write(sharedBuffer, 0, buffer.Length);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(sharedBuffer);
            }
        }

        /// <summary>
        /// Writes a span to the stream.
        /// </summary>
        /// <param name="stream">The stream to write to.</param>
        /// <param name="buffer">The buffer to write.</param>
        /// <param name="cancellationToken">A cancellation token.</param>
        internal static async ValueTask WriteAsync(this Stream stream, ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
        {
            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
            try
            {
                buffer.CopyTo(sharedBuffer);
                await stream.WriteAsync(sharedBuffer, 0, buffer.Length, cancellationToken).ConfigureAwait(false);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(sharedBuffer);
            }
        }
    }
#endif
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/StreamPolyfillExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: a129c39f0ce55af4fac3a1a6bcc1380e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/StringEncoding.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace MessagePack
{
    internal static class StringEncoding
    {
        internal static readonly Encoding UTF8 = new UTF8Encoding(false);

#if !NETCOREAPP // Define the extension method only where an instance method does not already exist.
        internal static unsafe string GetString(this Encoding encoding, ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length == 0)
            {
                return string.Empty;
            }

            fixed (byte* pBytes = bytes)
            {
                return encoding.GetString(pBytes, bytes.Length);
            }
        }
#endif
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/StringEncoding.cs.meta
================================================
fileFormatVersion: 2
guid: 1d573b17dc675bc4482fbc3e79f86dca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4.meta
================================================
fileFormatVersion: 2
guid: ebe1a66c497ddd04581d1497f91b9a90
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ThisLibraryExtensionTypeCodes.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace MessagePack
{
    /// <summary>
    /// The extension type codes that this library defines for just this library.
    /// </summary>
    internal static class ThisLibraryExtensionTypeCodes
    {
        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityVector2 = 30;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityVector3 = 31;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityVector4 = 32;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityQuaternion = 33;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityColor = 34;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityBounds = 35;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityRect = 36;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityInt = 37;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityFloat = 38;

        /// <summary>
        /// For Unity's UnsafeBlitFormatter.
        /// </summary>
        internal const sbyte UnityDouble = 39;

        /// <summary>
        /// The LZ4 array block compression extension.
        /// </summary>
        internal const sbyte Lz4BlockArray = 98;

        /// <summary>
        /// The LZ4 single block compression extension.
        /// </summary>
        internal const sbyte Lz4Block = 99;

        /// <summary>
        /// For the <see cref="Formatters.TypelessFormatter"/>.
        /// </summary>
        internal const sbyte TypelessFormatter = 100;
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/ThisLibraryExtensionTypeCodes.cs.meta
================================================
fileFormatVersion: 2
guid: 1d1907f02cbdd5942a88a8770336fe7e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity.meta
================================================
fileFormatVersion: 2
guid: 722fdb902e10c1b4aa65d3ca8891e760
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Utilities.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;

namespace MessagePack
{
    /// <summary>
    /// Internal utilities and extension methods for various external types.
    /// </summary>
    internal static class Utilities
    {
        /// <summary>
        /// A value indicating whether we're running on mono.
        /// </summary>
#if UNITY_2018_3_OR_NEWER
        internal const bool IsMono = true; // hard code since we haven't tested whether mono is detected on all unity platforms.
#else
        internal static readonly bool IsMono = Type.GetType("Mono.Runtime") is Type;
#endif

        internal delegate void GetWriterBytesAction<TArg>(ref MessagePackWriter writer, TArg argument);

        internal static byte[] GetWriterBytes<TArg>(TArg arg, GetWriterBytesAction<TArg> action)
        {
            using (var sequenceRental = SequencePool.Shared.Rent())
            {
                var writer = new MessagePackWriter(sequenceRental.Value);
                action(ref writer, arg);
                writer.Flush();
                return sequenceRental.Value.AsReadOnlySequence.ToArray();
            }
        }

        internal static Memory<T> GetMemoryCheckResult<T>(this IBufferWriter<T> bufferWriter, int size = 0)
        {
            var memory = bufferWriter.GetMemory(size);
            if (memory.IsEmpty)
            {
                throw new InvalidOperationException("The underlying IBufferWriter<byte>.GetMemory(int) method returned an empty memory block, which is not allowed. This is a bug in " + bufferWriter.GetType().FullName);
            }

            return memory;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Utilities.cs.meta
================================================
fileFormatVersion: 2
guid: f968cf11be4a47f42a5b1fcb33a6bf6b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/Attributes.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = true)]
    public class MessagePackObjectAttribute : Attribute
    {
        public bool KeyAsPropertyName { get; private set; }

        public MessagePackObjectAttribute(bool keyAsPropertyName = false)
        {
            this.KeyAsPropertyName = keyAsPropertyName;
        }
    }

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class KeyAttribute : Attribute
    {
        public int? IntKey { get; private set; }

        public string StringKey { get; private set; }

        public KeyAttribute(int x)
        {
            this.IntKey = x;
        }

        public KeyAttribute(string x)
        {
            this.StringKey = x;
        }
    }

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class IgnoreMemberAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public class UnionAttribute : Attribute
    {
        /// <summary>
        /// Gets the distinguishing value that identifies a particular subtype.
        /// </summary>
        public int Key { get; private set; }

        /// <summary>
        /// Gets the derived or implementing type.
        /// </summary>
        public Type SubType { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnionAttribute"/> class.
        /// </summary>
        /// <param name="key">The distinguishing value that identifies a particular subtype.</param>
        /// <param name="subType">The derived or implementing type.</param>
        public UnionAttribute(int key, Type subType)
        {
            this.Key = key;
            this.SubType = subType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UnionAttribute"/> class.
        /// </summary>
        /// <param name="key">The distinguishing value that identifies a particular subtype.</param>
        /// <param name="subType">The full name (should be assembly qualified) of the derived or implementing type.</param>
        public UnionAttribute(int key, string subType)
        {
            this.Key = key;
            this.SubType = Type.GetType(subType, throwOnError: true);
        }
    }

    [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false, Inherited = true)]
    public class SerializationConstructorAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Enum | AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
    public class MessagePackFormatterAttribute : Attribute
    {
        public Type FormatterType { get; private set; }

        public object[] Arguments { get; private set; }

        public MessagePackFormatterAttribute(Type formatterType)
        {
            this.FormatterType = formatterType;
        }

        public MessagePackFormatterAttribute(Type formatterType, params object[] arguments)
        {
            this.FormatterType = formatterType;
            this.Arguments = arguments;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/Attributes.cs.meta
================================================
fileFormatVersion: 2
guid: f684d4f03d4f86149990459d3054e2af
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/IMessagePackSerializationCallbackReceiver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace MessagePack
{
    public interface IMessagePackSerializationCallbackReceiver
    {
        void OnBeforeSerialize();

        void OnAfterDeserialize();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/IMessagePackSerializationCallbackReceiver.cs.meta
================================================
fileFormatVersion: 2
guid: b1714a0e4e8a7354e90f52000abdddd9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/MessagePack.Annotations.asmdef
================================================
﻿{
	"name": "MessagePack.Annotations"
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Annotations/MessagePack.Annotations.asmdef.meta
================================================
fileFormatVersion: 2
guid: 5a46ad82eac024e4fbb6a0516a5def17
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/CollectionFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class ArrayFormatter<T> : IMessagePackFormatter<T[]>
    {
        public void Serialize(ref MessagePackWriter writer, T[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                writer.WriteArrayHeader(value.Length);

                for (int i = 0; i < value.Length; i++)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, value[i], options);
                }
            }
        }

        public T[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<T>();
            }

            IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();
            var array = new T[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    array[i] = formatter.Deserialize(ref reader, options);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ByteMemoryFormatter : IMessagePackFormatter<Memory<byte>>
    {
        public static readonly ByteMemoryFormatter Instance = new ByteMemoryFormatter();

        private ByteMemoryFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Memory<byte> value, MessagePackSerializerOptions options)
        {
            writer.Write(value.Span);
        }

        public Memory<byte> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBytes() is ReadOnlySequence<byte> bytes ? new Memory<byte>(bytes.ToArray()) : default;
        }
    }

    public sealed class ByteReadOnlyMemoryFormatter : IMessagePackFormatter<ReadOnlyMemory<byte>>
    {
        public static readonly ByteReadOnlyMemoryFormatter Instance = new ByteReadOnlyMemoryFormatter();

        private ByteReadOnlyMemoryFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, ReadOnlyMemory<byte> value, MessagePackSerializerOptions options)
        {
            writer.Write(value.Span);
        }

        public ReadOnlyMemory<byte> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBytes() is ReadOnlySequence<byte> bytes ? new ReadOnlyMemory<byte>(bytes.ToArray()) : default;
        }
    }

    public sealed class ByteReadOnlySequenceFormatter : IMessagePackFormatter<ReadOnlySequence<byte>>
    {
        public static readonly ByteReadOnlySequenceFormatter Instance = new ByteReadOnlySequenceFormatter();

        private ByteReadOnlySequenceFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, ReadOnlySequence<byte> value, MessagePackSerializerOptions options)
        {
            writer.WriteBinHeader(checked((int)value.Length));
            foreach (ReadOnlyMemory<byte> segment in value)
            {
                writer.WriteRaw(segment.Span);
            }
        }

        public ReadOnlySequence<byte> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBytes() is ReadOnlySequence<byte> bytes ? new ReadOnlySequence<byte>(bytes.ToArray()) : default;
        }
    }

    public sealed class ByteArraySegmentFormatter : IMessagePackFormatter<ArraySegment<byte>>
    {
        public static readonly ByteArraySegmentFormatter Instance = new ByteArraySegmentFormatter();

        private ByteArraySegmentFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, ArraySegment<byte> value, MessagePackSerializerOptions options)
        {
            if (value.Array == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value);
            }
        }

        public ArraySegment<byte> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBytes() is ReadOnlySequence<byte> bytes ? new ArraySegment<byte>(bytes.ToArray()) : default;
        }
    }

    public sealed class MemoryFormatter<T> : IMessagePackFormatter<Memory<T>>
    {
        public void Serialize(ref MessagePackWriter writer, Memory<T> value, MessagePackSerializerOptions options)
        {
            var formatter = options.Resolver.GetFormatterWithVerify<ReadOnlyMemory<T>>();
            formatter.Serialize(ref writer, value, options);
        }

        public Memory<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return options.Resolver.GetFormatterWithVerify<T[]>().Deserialize(ref reader, options);
        }
    }

    public sealed class ReadOnlyMemoryFormatter<T> : IMessagePackFormatter<ReadOnlyMemory<T>>
    {
        public void Serialize(ref MessagePackWriter writer, ReadOnlyMemory<T> value, MessagePackSerializerOptions options)
        {
            IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

            var span = value.Span;
            writer.WriteArrayHeader(span.Length);

            for (int i = 0; i < span.Length; i++)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, span[i], options);
            }
        }

        public ReadOnlyMemory<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return options.Resolver.GetFormatterWithVerify<T[]>().Deserialize(ref reader, options);
        }
    }

    public sealed class ReadOnlySequenceFormatter<T> : IMessagePackFormatter<ReadOnlySequence<T>>
    {
        public void Serialize(ref MessagePackWriter writer, ReadOnlySequence<T> value, MessagePackSerializerOptions options)
        {
            IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

            writer.WriteArrayHeader(checked((int)value.Length));
            foreach (ReadOnlyMemory<T> segment in value)
            {
                ReadOnlySpan<T> span = segment.Span;
                for (int i = 0; i < span.Length; i++)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, span[i], options);
                }
            }
        }

        public ReadOnlySequence<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new ReadOnlySequence<T>(options.Resolver.GetFormatterWithVerify<T[]>().Deserialize(ref reader, options));
        }
    }

    public sealed class ArraySegmentFormatter<T> : IMessagePackFormatter<ArraySegment<T>>
    {
        public void Serialize(ref MessagePackWriter writer, ArraySegment<T> value, MessagePackSerializerOptions options)
        {
            if (value.Array == null)
            {
                writer.WriteNil();
            }
            else
            {
                var formatter = options.Resolver.GetFormatterWithVerify<Memory<T>>();
                formatter.Serialize(ref writer, value, options);
            }
        }

        public ArraySegment<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                T[] array = options.Resolver.GetFormatterWithVerify<T[]>().Deserialize(ref reader, options);
                return new ArraySegment<T>(array);
            }
        }
    }

    // List<T> is popular format, should avoid abstraction.
    public sealed class ListFormatter<T> : IMessagePackFormatter<List<T>>
    {
        public void Serialize(ref MessagePackWriter writer, List<T> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                var c = value.Count;
                writer.WriteArrayHeader(c);

                for (int i = 0; i < c; i++)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, value[i], options);
                }
            }
        }

        public List<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                var len = reader.ReadArrayHeader();
                var list = new List<T>((int)len);
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int i = 0; i < len; i++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        list.Add(formatter.Deserialize(ref reader, options));
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return list;
            }
        }
    }

    public abstract class CollectionFormatterBase<TElement, TIntermediate, TEnumerator, TCollection> : IMessagePackFormatter<TCollection>
        where TCollection : IEnumerable<TElement>
        where TEnumerator : IEnumerator<TElement>
    {
        public void Serialize(ref MessagePackWriter writer, TCollection value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                IMessagePackFormatter<TElement> formatter = options.Resolver.GetFormatterWithVerify<TElement>();

                // Optimize iteration(array is fastest)
                if (value is TElement[] array)
                {
                    writer.WriteArrayHeader(array.Length);

                    foreach (TElement item in array)
                    {
                        writer.CancellationToken.ThrowIfCancellationRequested();
                        formatter.Serialize(ref writer, item, options);
                    }
                }
                else
                {
                    // knows count or not.
                    var seqCount = this.GetCount(value);
                    if (seqCount != null)
                    {
                        writer.WriteArrayHeader(seqCount.Value);

                        // Unity's foreach struct enumerator causes boxing so iterate manually.
                        using (var e = this.GetSourceEnumerator(value))
                        {
                            while (e.MoveNext())
                            {
                                writer.CancellationToken.ThrowIfCancellationRequested();
                                formatter.Serialize(ref writer, e.Current, options);
                            }
                        }
                    }
                    else
                    {
                        using (var scratchRental = SequencePool.Shared.Rent())
                        {
                            var scratch = scratchRental.Value;
                            MessagePackWriter scratchWriter = writer.Clone(scratch);
                            var count = 0;
                            using (var e = this.GetSourceEnumerator(value))
                            {
                                while (e.MoveNext())
                                {
                                    writer.CancellationToken.ThrowIfCancellationRequested();
                                    count++;
                                    formatter.Serialize(ref scratchWriter, e.Current, options);
                                }
                            }

                            scratchWriter.Flush();
                            writer.WriteArrayHeader(count);
                            writer.WriteRaw(scratch.AsReadOnlySequence);
                        }
                    }
                }
            }
        }

        public TCollection Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(TCollection);
            }
            else
            {
                IMessagePackFormatter<TElement> formatter = options.Resolver.GetFormatterWithVerify<TElement>();

                var len = reader.ReadArrayHeader();

                TIntermediate list = this.Create(len, options);
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int i = 0; i < len; i++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        this.Add(list, i, formatter.Deserialize(ref reader, options), options);
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return this.Complete(list);
            }
        }

        // abstraction for serialize
        protected virtual int? GetCount(TCollection sequence)
        {
            var collection = sequence as ICollection<TElement>;
            if (collection != null)
            {
                return collection.Count;
            }
            else
            {
                var c2 = sequence as IReadOnlyCollection<TElement>;
                if (c2 != null)
                {
                    return c2.Count;
                }
            }

            return null;
        }

        // Some collections can use struct iterator, this is optimization path
        protected abstract TEnumerator GetSourceEnumerator(TCollection source);

        // abstraction for deserialize
        protected abstract TIntermediate Create(int count, MessagePackSerializerOptions options);

        protected abstract void Add(TIntermediate collection, int index, TElement value, MessagePackSerializerOptions options);

        protected abstract TCollection Complete(TIntermediate intermediateCollection);
    }

    public abstract class CollectionFormatterBase<TElement, TIntermediate, TCollection> : CollectionFormatterBase<TElement, TIntermediate, IEnumerator<TElement>, TCollection>
        where TCollection : IEnumerable<TElement>
    {
        protected override IEnumerator<TElement> GetSourceEnumerator(TCollection source)
        {
            return source.GetEnumerator();
        }
    }

    public abstract class CollectionFormatterBase<TElement, TCollection> : CollectionFormatterBase<TElement, TCollection, TCollection>
        where TCollection : IEnumerable<TElement>
    {
        protected sealed override TCollection Complete(TCollection intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class GenericCollectionFormatter<TElement, TCollection> : CollectionFormatterBase<TElement, TCollection>
         where TCollection : ICollection<TElement>, new()
    {
        protected override TCollection Create(int count, MessagePackSerializerOptions options)
        {
            return new TCollection();
        }

        protected override void Add(TCollection collection, int index, TElement value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }
    }

    public sealed class LinkedListFormatter<T> : CollectionFormatterBase<T, LinkedList<T>, LinkedList<T>.Enumerator, LinkedList<T>>
    {
        protected override void Add(LinkedList<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.AddLast(value);
        }

        protected override LinkedList<T> Complete(LinkedList<T> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override LinkedList<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new LinkedList<T>();
        }

        protected override LinkedList<T>.Enumerator GetSourceEnumerator(LinkedList<T> source)
        {
            return source.GetEnumerator();
        }
    }

    public sealed class QueueFormatter<T> : CollectionFormatterBase<T, Queue<T>, Queue<T>.Enumerator, Queue<T>>
    {
        protected override int? GetCount(Queue<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(Queue<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Enqueue(value);
        }

        protected override Queue<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new Queue<T>(count);
        }

        protected override Queue<T>.Enumerator GetSourceEnumerator(Queue<T> source)
        {
            return source.GetEnumerator();
        }

        protected override Queue<T> Complete(Queue<T> intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    // should deserialize reverse order.
    public sealed class StackFormatter<T> : CollectionFormatterBase<T, T[], Stack<T>.Enumerator, Stack<T>>
    {
        protected override int? GetCount(Stack<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            // add reverse
            collection[collection.Length - 1 - index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override Stack<T>.Enumerator GetSourceEnumerator(Stack<T> source)
        {
            return source.GetEnumerator();
        }

        protected override Stack<T> Complete(T[] intermediateCollection)
        {
            return new Stack<T>(intermediateCollection);
        }
    }

    public sealed class HashSetFormatter<T> : CollectionFormatterBase<T, HashSet<T>, HashSet<T>.Enumerator, HashSet<T>>
    {
        protected override int? GetCount(HashSet<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(HashSet<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override HashSet<T> Complete(HashSet<T> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override HashSet<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new HashSet<T>(options.Security.GetEqualityComparer<T>());
        }

        protected override HashSet<T>.Enumerator GetSourceEnumerator(HashSet<T> source)
        {
            return source.GetEnumerator();
        }
    }

    public sealed class ReadOnlyCollectionFormatter<T> : CollectionFormatterBase<T, T[], ReadOnlyCollection<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override ReadOnlyCollection<T> Complete(T[] intermediateCollection)
        {
            return new ReadOnlyCollection<T>(intermediateCollection);
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }
    }

    [Obsolete("Use " + nameof(InterfaceListFormatter2<int>) + " instead.")]
    public sealed class InterfaceListFormatter<T> : CollectionFormatterBase<T, T[], IList<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override IList<T> Complete(T[] intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    [Obsolete("Use " + nameof(InterfaceCollectionFormatter2<int>) + " instead.")]
    public sealed class InterfaceCollectionFormatter<T> : CollectionFormatterBase<T, T[], ICollection<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override ICollection<T> Complete(T[] intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class InterfaceListFormatter2<T> : CollectionFormatterBase<T, List<T>, IList<T>>
    {
        protected override void Add(List<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override List<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new List<T>(count);
        }

        protected override IList<T> Complete(List<T> intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class InterfaceCollectionFormatter2<T> : CollectionFormatterBase<T, List<T>, ICollection<T>>
    {
        protected override void Add(List<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override List<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new List<T>(count);
        }

        protected override ICollection<T> Complete(List<T> intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class InterfaceEnumerableFormatter<T> : CollectionFormatterBase<T, T[], IEnumerable<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override IEnumerable<T> Complete(T[] intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    // [Key, [Array]]
    public sealed class InterfaceGroupingFormatter<TKey, TElement> : IMessagePackFormatter<IGrouping<TKey, TElement>>
    {
        public void Serialize(ref MessagePackWriter writer, IGrouping<TKey, TElement> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(2);
                options.Resolver.GetFormatterWithVerify<TKey>().Serialize(ref writer, value.Key, options);
                options.Resolver.GetFormatterWithVerify<IEnumerable<TElement>>().Serialize(ref writer, value, options);
            }
        }

        public IGrouping<TKey, TElement> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                var count = reader.ReadArrayHeader();

                if (count != 2)
                {
                    throw new MessagePackSerializationException("Invalid Grouping format.");
                }

                options.Security.DepthStep(ref reader);
                try
                {
                    TKey key = options.Resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);
                    IEnumerable<TElement> value = options.Resolver.GetFormatterWithVerify<IEnumerable<TElement>>().Deserialize(ref reader, options);
                    return new Grouping<TKey, TElement>(key, value);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class InterfaceLookupFormatter<TKey, TElement> : CollectionFormatterBase<IGrouping<TKey, TElement>, Dictionary<TKey, IGrouping<TKey, TElement>>, ILookup<TKey, TElement>>
    {
        protected override void Add(Dictionary<TKey, IGrouping<TKey, TElement>> collection, int index, IGrouping<TKey, TElement> value, MessagePackSerializerOptions options)
        {
            collection.Add(value.Key, value);
        }

        protected override ILookup<TKey, TElement> Complete(Dictionary<TKey, IGrouping<TKey, TElement>> intermediateCollection)
        {
            return new Lookup<TKey, TElement>(intermediateCollection);
        }

        protected override Dictionary<TKey, IGrouping<TKey, TElement>> Create(int count, MessagePackSerializerOptions options)
        {
            return new Dictionary<TKey, IGrouping<TKey, TElement>>(count);
        }
    }

    internal class Grouping<TKey, TElement> : IGrouping<TKey, TElement>
    {
        private readonly TKey key;
        private readonly IEnumerable<TElement> elements;

        public Grouping(TKey key, IEnumerable<TElement> elements)
        {
            this.key = key;
            this.elements = elements;
        }

        public TKey Key
        {
            get
            {
                return this.key;
            }
        }

        public IEnumerator<TElement> GetEnumerator()
        {
            return this.elements.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.elements.GetEnumerator();
        }
    }

    internal class Lookup<TKey, TElement> : ILookup<TKey, TElement>
    {
        private readonly Dictionary<TKey, IGrouping<TKey, TElement>> groupings;

        public Lookup(Dictionary<TKey, IGrouping<TKey, TElement>> groupings)
        {
            this.groupings = groupings;
        }

        public IEnumerable<TElement> this[TKey key]
        {
            get
            {
                return this.groupings[key];
            }
        }

        public int Count
        {
            get
            {
                return this.groupings.Count;
            }
        }

        public bool Contains(TKey key)
        {
            return this.groupings.ContainsKey(key);
        }

        public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
        {
            return this.groupings.Values.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.groupings.Values.GetEnumerator();
        }
    }

    /* NonGenerics */

    public sealed class NonGenericListFormatter<T> : IMessagePackFormatter<T>
        where T : class, IList, new()
    {
        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteArrayHeader(value.Count);
            foreach (var item in value)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, item, options);
            }
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(T);
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var count = reader.ReadArrayHeader();

            var list = new T();
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    list.Add(formatter.Deserialize(ref reader, options));
                }
            }
            finally
            {
                reader.Depth--;
            }

            return list;
        }
    }

    public sealed class NonGenericInterfaceCollectionFormatter : IMessagePackFormatter<ICollection>
    {
        public static readonly IMessagePackFormatter<ICollection> Instance = new NonGenericInterfaceCollectionFormatter();

        private NonGenericInterfaceCollectionFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, ICollection value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteArrayHeader(value.Count);
            foreach (var item in value)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, item, options);
            }
        }

        public ICollection Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(ICollection);
            }

            var count = reader.ReadArrayHeader();
            if (count == 0)
            {
                return Array.Empty<object>();
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var list = new object[count];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    list[i] = formatter.Deserialize(ref reader, options);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return list;
        }
    }

    public sealed class NonGenericInterfaceEnumerableFormatter : IMessagePackFormatter<IEnumerable>
    {
        public static readonly IMessagePackFormatter<IEnumerable> Instance = new NonGenericInterfaceEnumerableFormatter();

        private NonGenericInterfaceEnumerableFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, IEnumerable value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            using (var scratchRental = SequencePool.Shared.Rent())
            {
                var scratch = scratchRental.Value;
                MessagePackWriter scratchWriter = writer.Clone(scratch);
                var count = 0;
                var e = value.GetEnumerator();
                try
                {
                    while (e.MoveNext())
                    {
                        writer.CancellationToken.ThrowIfCancellationRequested();
                        count++;
                        formatter.Serialize(ref scratchWriter, e.Current, options);
                    }
                }
                finally
                {
                    if (e is IDisposable d)
                    {
                        d.Dispose();
                    }
                }

                scratchWriter.Flush();
                writer.WriteArrayHeader(count);
                writer.WriteRaw(scratch.AsReadOnlySequence);
            }
        }

        public IEnumerable Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(IEnumerable);
            }

            var count = reader.ReadArrayHeader();
            if (count == 0)
            {
                return Array.Empty<object>();
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var list = new object[count];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    list[i] = formatter.Deserialize(ref reader, options);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return list;
        }
    }

    public sealed class NonGenericInterfaceListFormatter : IMessagePackFormatter<IList>
    {
        public static readonly IMessagePackFormatter<IList> Instance = new NonGenericInterfaceListFormatter();

        private NonGenericInterfaceListFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, IList value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteArrayHeader(value.Count);
            foreach (var item in value)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, item, options);
            }
        }

        public IList Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(IList);
            }

            var count = reader.ReadArrayHeader();
            if (count == 0)
            {
                return Array.Empty<object>();
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var list = new object[count];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    list[i] = formatter.Deserialize(ref reader, options);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return list;
        }
    }

    public sealed class NonGenericDictionaryFormatter<T> : IMessagePackFormatter<T>
        where T : class, IDictionary, new()
    {
        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteMapHeader(value.Count);
            foreach (DictionaryEntry item in value)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, item.Key, options);
                formatter.Serialize(ref writer, item.Value, options);
            }
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var count = reader.ReadMapHeader();

            var dict = CollectionHelpers<T, IEqualityComparer>.CreateHashCollection(count, options.Security.GetEqualityComparer());
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    var key = formatter.Deserialize(ref reader, options);
                    var value = formatter.Deserialize(ref reader, options);
                    dict.Add(key, value);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return dict;
        }
    }

    public sealed class NonGenericInterfaceDictionaryFormatter : IMessagePackFormatter<IDictionary>
    {
        public static readonly IMessagePackFormatter<IDictionary> Instance = new NonGenericInterfaceDictionaryFormatter();

        private NonGenericInterfaceDictionaryFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, IDictionary value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteMapHeader(value.Count);
            foreach (DictionaryEntry item in value)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                formatter.Serialize(ref writer, item.Key, options);
                formatter.Serialize(ref writer, item.Value, options);
            }
        }

        public IDictionary Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            IMessagePackFormatter<object> formatter = options.Resolver.GetFormatterWithVerify<object>();

            var count = reader.ReadMapHeader();

            var dict = new Dictionary<object, object>(count, options.Security.GetEqualityComparer<object>());
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    reader.CancellationToken.ThrowIfCancellationRequested();
                    var key = formatter.Deserialize(ref reader, options);
                    var value = formatter.Deserialize(ref reader, options);
                    dict.Add(key, value);
                }
            }
            finally
            {
                reader.Depth--;
            }

            return dict;
        }
    }

    public sealed class ObservableCollectionFormatter<T> : CollectionFormatterBase<T, ObservableCollection<T>>
    {
        protected override void Add(ObservableCollection<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override ObservableCollection<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new ObservableCollection<T>();
        }
    }

    public sealed class ReadOnlyObservableCollectionFormatter<T> : CollectionFormatterBase<T, ObservableCollection<T>, ReadOnlyObservableCollection<T>>
    {
        protected override void Add(ObservableCollection<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override ObservableCollection<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new ObservableCollection<T>();
        }

        protected override ReadOnlyObservableCollection<T> Complete(ObservableCollection<T> intermediateCollection)
        {
            return new ReadOnlyObservableCollection<T>(intermediateCollection);
        }
    }

    public sealed class InterfaceReadOnlyListFormatter<T> : CollectionFormatterBase<T, T[], IReadOnlyList<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override IReadOnlyList<T> Complete(T[] intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class InterfaceReadOnlyCollectionFormatter<T> : CollectionFormatterBase<T, T[], IReadOnlyCollection<T>>
    {
        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection[index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override IReadOnlyCollection<T> Complete(T[] intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class InterfaceSetFormatter<T> : CollectionFormatterBase<T, HashSet<T>, ISet<T>>
    {
        protected override void Add(HashSet<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override ISet<T> Complete(HashSet<T> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override HashSet<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new HashSet<T>(options.Security.GetEqualityComparer<T>());
        }
    }

    public sealed class ConcurrentBagFormatter<T> : CollectionFormatterBase<T, System.Collections.Concurrent.ConcurrentBag<T>>
    {
        protected override int? GetCount(ConcurrentBag<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(ConcurrentBag<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Add(value);
        }

        protected override ConcurrentBag<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new ConcurrentBag<T>();
        }
    }

    public sealed class ConcurrentQueueFormatter<T> : CollectionFormatterBase<T, System.Collections.Concurrent.ConcurrentQueue<T>>
    {
        protected override int? GetCount(ConcurrentQueue<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(ConcurrentQueue<T> collection, int index, T value, MessagePackSerializerOptions options)
        {
            collection.Enqueue(value);
        }

        protected override ConcurrentQueue<T> Create(int count, MessagePackSerializerOptions options)
        {
            return new ConcurrentQueue<T>();
        }
    }

    public sealed class ConcurrentStackFormatter<T> : CollectionFormatterBase<T, T[], ConcurrentStack<T>>
    {
        protected override int? GetCount(ConcurrentStack<T> sequence)
        {
            return sequence.Count;
        }

        protected override void Add(T[] collection, int index, T value, MessagePackSerializerOptions options)
        {
            // add reverse
            collection[collection.Length - 1 - index] = value;
        }

        protected override T[] Create(int count, MessagePackSerializerOptions options)
        {
            return count == 0 ? Array.Empty<T>() : new T[count];
        }

        protected override ConcurrentStack<T> Complete(T[] intermediateCollection)
        {
            return new ConcurrentStack<T>(intermediateCollection);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/CollectionFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: d1185cc5503e9de47b44ccaf43b6d665
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/CollectionHelpers`2.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Linq.Expressions;

namespace MessagePack.Formatters
{
    /// <summary>
    /// Provides general helpers for creating collections (including dictionaries).
    /// </summary>
    /// <typeparam name="TCollection">The concrete type of collection to create.</typeparam>
    /// <typeparam name="TEqualityComparer">The type of equality comparer that we would hope to pass into the collection's constructor.</typeparam>
    internal static class CollectionHelpers<TCollection, TEqualityComparer>
        where TCollection : new()
    {
        /// <summary>
        /// The delegate that will create the collection, if the typical (int count, IEqualityComparer{T} equalityComparer) constructor was found.
        /// </summary>
        private static Func<int, TEqualityComparer, TCollection> collectionCreator;

        /// <summary>
        /// Initializes static members of the <see cref="CollectionHelpers{TCollection, TEqualityComparer}"/> class.
        /// </summary>
        /// <remarks>
        /// Initializes a delegate that is optimized to create a collection of a given size and using the given equality comparer, if possible.
        /// </remarks>
        static CollectionHelpers()
        {
            var ctor = typeof(TCollection).GetConstructor(new Type[] { typeof(int), typeof(TEqualityComparer) });
            if (ctor != null)
            {
                ParameterExpression param1 = Expression.Parameter(typeof(int), "count");
                ParameterExpression param2 = Expression.Parameter(typeof(TEqualityComparer), "equalityComparer");
                NewExpression body = Expression.New(ctor, param1, param2);
                collectionCreator = Expression.Lambda<Func<int, TEqualityComparer, TCollection>>(body, param1, param2).Compile();
            }
        }

        /// <summary>
        /// Initializes a new instance of the <typeparamref name="TCollection"/> collection.
        /// </summary>
        /// <param name="count">The number of elements the collection should be prepared to receive.</param>
        /// <param name="equalityComparer">The equality comparer to initialize the collection with.</param>
        /// <returns>The newly initialized collection.</returns>
        /// <remarks>
        /// Use of the <paramref name="count"/> and <paramref name="equalityComparer"/> are a best effort.
        /// If we can't find a constructor on the collection in the expected shape, we'll just instantiate the collection with its default constructor.
        /// </remarks>
        internal static TCollection CreateHashCollection(int count, TEqualityComparer equalityComparer) => collectionCreator != null ? collectionCreator.Invoke(count, equalityComparer) : new TCollection();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/CollectionHelpers`2.cs.meta
================================================
fileFormatVersion: 2
guid: 7aad614464db2c44a86b3b012e69b609
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DateTimeFormatters.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    /// <summary>
    /// Serialize by .NET native DateTime binary format.
    /// </summary>
    public sealed class NativeDateTimeFormatter : IMessagePackFormatter<DateTime>
    {
        public static readonly NativeDateTimeFormatter Instance = new NativeDateTimeFormatter();

        public void Serialize(ref MessagePackWriter writer, DateTime value, MessagePackSerializerOptions options)
        {
            var dateData = value.ToBinary();
            writer.Write(dateData);
        }

        public DateTime Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            var dateData = reader.ReadInt64();
            return DateTime.FromBinary(dateData);
        }
    }

    public sealed class NativeDateTimeArrayFormatter : IMessagePackFormatter<DateTime[]>
    {
        public static readonly NativeDateTimeArrayFormatter Instance = new NativeDateTimeArrayFormatter();

        public void Serialize(ref MessagePackWriter writer, DateTime[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i].ToBinary());
                }
            }
        }

        public DateTime[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<DateTime>();
            }

            var array = new DateTime[len];
            for (int i = 0; i < array.Length; i++)
            {
                var dateData = reader.ReadInt64();
                array[i] = DateTime.FromBinary(dateData);
            }

            return array;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DateTimeFormatters.cs.meta
================================================
fileFormatVersion: 2
guid: 619edb2526be60b41b30abdd4f514a3b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DictionaryFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    // unfortunately, can't use IDictionary<KVP> because supports IReadOnlyDictionary.
    public abstract class DictionaryFormatterBase<TKey, TValue, TIntermediate, TEnumerator, TDictionary> : IMessagePackFormatter<TDictionary>
        where TDictionary : IEnumerable<KeyValuePair<TKey, TValue>>
        where TEnumerator : IEnumerator<KeyValuePair<TKey, TValue>>
    {
        public void Serialize(ref MessagePackWriter writer, TDictionary value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                IFormatterResolver resolver = options.Resolver;
                IMessagePackFormatter<TKey> keyFormatter = resolver.GetFormatterWithVerify<TKey>();
                IMessagePackFormatter<TValue> valueFormatter = resolver.GetFormatterWithVerify<TValue>();

                int count;
                {
                    var col = value as ICollection<KeyValuePair<TKey, TValue>>;
                    if (col != null)
                    {
                        count = col.Count;
                    }
                    else
                    {
                        var col2 = value as IReadOnlyCollection<KeyValuePair<TKey, TValue>>;
                        if (col2 != null)
                        {
                            count = col2.Count;
                        }
                        else
                        {
                            throw new MessagePackSerializationException("DictionaryFormatterBase's TDictionary supports only ICollection<KVP> or IReadOnlyCollection<KVP>");
                        }
                    }
                }

                writer.WriteMapHeader(count);

                TEnumerator e = this.GetSourceEnumerator(value);
                try
                {
                    while (e.MoveNext())
                    {
                        writer.CancellationToken.ThrowIfCancellationRequested();
                        KeyValuePair<TKey, TValue> item = e.Current;
                        keyFormatter.Serialize(ref writer, item.Key, options);
                        valueFormatter.Serialize(ref writer, item.Value, options);
                    }
                }
                finally
                {
                    e.Dispose();
                }
            }
        }

        public TDictionary Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default(TDictionary);
            }
            else
            {
                IFormatterResolver resolver = options.Resolver;
                IMessagePackFormatter<TKey> keyFormatter = resolver.GetFormatterWithVerify<TKey>();
                IMessagePackFormatter<TValue> valueFormatter = resolver.GetFormatterWithVerify<TValue>();

                var len = reader.ReadMapHeader();

                TIntermediate dict = this.Create(len, options);
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int i = 0; i < len; i++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        TKey key = keyFormatter.Deserialize(ref reader, options);

                        TValue value = valueFormatter.Deserialize(ref reader, options);

                        this.Add(dict, i, key, value, options);
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return this.Complete(dict);
            }
        }

        // abstraction for serialize

        // Some collections can use struct iterator, this is optimization path
        protected abstract TEnumerator GetSourceEnumerator(TDictionary source);

        // abstraction for deserialize
        protected abstract TIntermediate Create(int count, MessagePackSerializerOptions options);

        protected abstract void Add(TIntermediate collection, int index, TKey key, TValue value, MessagePackSerializerOptions options);

        protected abstract TDictionary Complete(TIntermediate intermediateCollection);
    }

    public abstract class DictionaryFormatterBase<TKey, TValue, TIntermediate, TDictionary> : DictionaryFormatterBase<TKey, TValue, TIntermediate, IEnumerator<KeyValuePair<TKey, TValue>>, TDictionary>
        where TDictionary : IEnumerable<KeyValuePair<TKey, TValue>>
    {
        protected override IEnumerator<KeyValuePair<TKey, TValue>> GetSourceEnumerator(TDictionary source)
        {
            return source.GetEnumerator();
        }
    }

    public abstract class DictionaryFormatterBase<TKey, TValue, TDictionary> : DictionaryFormatterBase<TKey, TValue, TDictionary, TDictionary>
        where TDictionary : IDictionary<TKey, TValue>
    {
        protected override TDictionary Complete(TDictionary intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class DictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, Dictionary<TKey, TValue>, Dictionary<TKey, TValue>.Enumerator, Dictionary<TKey, TValue>>
    {
        protected override void Add(Dictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override Dictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());
        }

        protected override Dictionary<TKey, TValue>.Enumerator GetSourceEnumerator(Dictionary<TKey, TValue> source)
        {
            return source.GetEnumerator();
        }
    }

    public sealed class GenericDictionaryFormatter<TKey, TValue, TDictionary> : DictionaryFormatterBase<TKey, TValue, TDictionary>
        where TDictionary : IDictionary<TKey, TValue>, new()
    {
        protected override void Add(TDictionary collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override TDictionary Create(int count, MessagePackSerializerOptions options)
        {
            return CollectionHelpers<TDictionary, IEqualityComparer<TKey>>.CreateHashCollection(count, options.Security.GetEqualityComparer<TKey>());
        }
    }

    public sealed class InterfaceDictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, Dictionary<TKey, TValue>, IDictionary<TKey, TValue>>
    {
        protected override void Add(Dictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());
        }

        protected override IDictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> intermediateCollection)
        {
            return intermediateCollection;
        }
    }

    public sealed class SortedListFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, SortedList<TKey, TValue>>
    {
        protected override void Add(SortedList<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override SortedList<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new SortedList<TKey, TValue>(count);
        }
    }

    public sealed class SortedDictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, SortedDictionary<TKey, TValue>, SortedDictionary<TKey, TValue>.Enumerator, SortedDictionary<TKey, TValue>>
    {
        protected override void Add(SortedDictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override SortedDictionary<TKey, TValue> Complete(SortedDictionary<TKey, TValue> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override SortedDictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new SortedDictionary<TKey, TValue>();
        }

        protected override SortedDictionary<TKey, TValue>.Enumerator GetSourceEnumerator(SortedDictionary<TKey, TValue> source)
        {
            return source.GetEnumerator();
        }
    }

    public sealed class ReadOnlyDictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, Dictionary<TKey, TValue>, ReadOnlyDictionary<TKey, TValue>>
    {
        protected override void Add(Dictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override ReadOnlyDictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> intermediateCollection)
        {
            return new ReadOnlyDictionary<TKey, TValue>(intermediateCollection);
        }

        protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());
        }
    }

    public sealed class InterfaceReadOnlyDictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, Dictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>>
    {
        protected override void Add(Dictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.Add(key, value);
        }

        protected override IReadOnlyDictionary<TKey, TValue> Complete(Dictionary<TKey, TValue> intermediateCollection)
        {
            return intermediateCollection;
        }

        protected override Dictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            return new Dictionary<TKey, TValue>(count, options.Security.GetEqualityComparer<TKey>());
        }
    }

    public sealed class ConcurrentDictionaryFormatter<TKey, TValue> : DictionaryFormatterBase<TKey, TValue, System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue>>
    {
        protected override void Add(ConcurrentDictionary<TKey, TValue> collection, int index, TKey key, TValue value, MessagePackSerializerOptions options)
        {
            collection.TryAdd(key, value);
        }

        protected override ConcurrentDictionary<TKey, TValue> Create(int count, MessagePackSerializerOptions options)
        {
            // concurrent dictionary can't access defaultConcurrecyLevel so does not use count overload.
            return new ConcurrentDictionary<TKey, TValue>(options.Security.GetEqualityComparer<TKey>());
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DictionaryFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: abfb83d1822bbfc409f1f182e365e8ea
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DynamicObjectTypeFallbackFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Linq.Expressions;
using System.Reflection;

namespace MessagePack.Formatters
{
    /// <summary>
    /// This formatter can serialize any value whose static type is <see cref="object"/>
    /// for which another resolver can provide a formatter for the runtime type.
    /// Its deserialization is limited to forwarding all calls to the <see cref="PrimitiveObjectFormatter"/>.
    /// </summary>
    public sealed class DynamicObjectTypeFallbackFormatter : IMessagePackFormatter<object>
    {
        public static readonly IMessagePackFormatter<object> Instance = new DynamicObjectTypeFallbackFormatter();

        private delegate void SerializeMethod(object dynamicFormatter, ref MessagePackWriter writer, object value, MessagePackSerializerOptions options);

        private static readonly Internal.ThreadsafeTypeKeyHashTable<SerializeMethod> SerializerDelegates = new Internal.ThreadsafeTypeKeyHashTable<SerializeMethod>();

        private DynamicObjectTypeFallbackFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, object value, MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            Type type = value.GetType();
            TypeInfo ti = type.GetTypeInfo();

            if (type == typeof(object))
            {
                // serialize to empty map
                writer.WriteMapHeader(0);
                return;
            }

            if (PrimitiveObjectFormatter.IsSupportedType(type, ti, value))
            {
                if (!(value is System.Collections.IDictionary || value is System.Collections.ICollection))
                {
                    PrimitiveObjectFormatter.Instance.Serialize(ref writer, value, options);
                    return;
                }
            }

            object formatter = options.Resolver.GetFormatterDynamicWithVerify(type);
            if (!SerializerDelegates.TryGetValue(type, out SerializeMethod serializerDelegate))
            {
                lock (SerializerDelegates)
                {
                    if (!SerializerDelegates.TryGetValue(type, out serializerDelegate))
                    {
                        Type formatterType = typeof(IMessagePackFormatter<>).MakeGenericType(type);
                        ParameterExpression param0 = Expression.Parameter(typeof(object), "formatter");
                        ParameterExpression param1 = Expression.Parameter(typeof(MessagePackWriter).MakeByRefType(), "writer");
                        ParameterExpression param2 = Expression.Parameter(typeof(object), "value");
                        ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");

                        MethodInfo serializeMethodInfo = formatterType.GetRuntimeMethod("Serialize", new[] { typeof(MessagePackWriter).MakeByRefType(), type, typeof(MessagePackSerializerOptions) });

                        MethodCallExpression body = Expression.Call(
                            Expression.Convert(param0, formatterType),
                            serializeMethodInfo,
                            param1,
                            ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                            param3);

                        serializerDelegate = Expression.Lambda<SerializeMethod>(body, param0, param1, param2, param3).Compile();

                        SerializerDelegates.TryAdd(type, serializerDelegate);
                    }
                }
            }

            serializerDelegate(formatter, ref writer, value, options);
        }

        public object Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return PrimitiveObjectFormatter.Instance.Deserialize(ref reader, options);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/DynamicObjectTypeFallbackFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 13f8970ea4cf5834783e2cf34116798a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/EnumAsStringFormatter`1.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.Serialization;

namespace MessagePack.Formatters
{
    // Note:This implementation is 'not' fastest, should more improve.
    public sealed class EnumAsStringFormatter<T> : IMessagePackFormatter<T>
    {
        private readonly IReadOnlyDictionary<string, T> nameValueMapping;
        private readonly IReadOnlyDictionary<T, string> valueNameMapping;
        private readonly IReadOnlyDictionary<string, string> clrToSerializationName;
        private readonly IReadOnlyDictionary<string, string> serializationToClrName;
        private readonly bool enumMemberOverridesPresent;
        private readonly bool isFlags;

        public EnumAsStringFormatter()
        {
            this.isFlags = typeof(T).GetCustomAttribute<FlagsAttribute>() is object;

            var fields = typeof(T).GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);
            var nameValueMapping = new Dictionary<string, T>(fields.Length);
            var valueNameMapping = new Dictionary<T, string>();
            Dictionary<string, string> clrToSerializationName = null;
            Dictionary<string, string> serializationToClrName = null;

            foreach (FieldInfo enumValueMember in fields)
            {
                string name = enumValueMember.Name;
                T value = (T)enumValueMember.GetValue(null);

                // Consider the case where the serialized form of the enum value is overridden via an attribute.
                var attribute = enumValueMember.GetCustomAttribute<EnumMemberAttribute>();
                if (attribute?.IsValueSetExplicitly ?? false)
                {
                    clrToSerializationName = clrToSerializationName ?? new Dictionary<string, string>();
                    serializationToClrName = serializationToClrName ?? new Dictionary<string, string>();

                    clrToSerializationName.Add(name, attribute.Value);
                    serializationToClrName.Add(attribute.Value, name);

                    name = attribute.Value;
                    this.enumMemberOverridesPresent = true;
                }

                nameValueMapping[name] = value;
                valueNameMapping[value] = name;
            }

            this.nameValueMapping = nameValueMapping;
            this.valueNameMapping = valueNameMapping;
            this.clrToSerializationName = clrToSerializationName;
            this.serializationToClrName = serializationToClrName;
        }

        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            // Enum.ToString() is slow, so avoid it when we can.
            if (!this.valueNameMapping.TryGetValue(value, out string valueString))
            {
                // fallback for flags, values with no name, etc
                valueString = this.GetSerializedNames(value.ToString());
            }

            writer.Write(valueString);
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            string name = reader.ReadString();

            // Avoid Enum.Parse when we can because it is too slow.
            if (!this.nameValueMapping.TryGetValue(name, out T value))
            {
                value = (T)Enum.Parse(typeof(T), this.GetClrNames(name));
            }

            return value;
        }

        private string GetClrNames(string serializedNames)
        {
            if (this.enumMemberOverridesPresent && this.isFlags && serializedNames.IndexOf(", ", StringComparison.Ordinal) >= 0)
            {
                return Translate(serializedNames, this.serializationToClrName);
            }

            // We don't need to consider the trivial case of no commas because our caller would have found that in the lookup table and not called us.
            return serializedNames;
        }

        private string GetSerializedNames(string clrNames)
        {
            if (this.enumMemberOverridesPresent && this.isFlags && clrNames.IndexOf(", ", StringComparison.Ordinal) >= 0)
            {
                return Translate(clrNames, this.clrToSerializationName);
            }

            // We don't need to consider the trivial case of no commas because our caller would have found that in the lookup table and not called us.
            return clrNames;
        }

        private static string Translate(string items, IReadOnlyDictionary<string, string> mapping)
        {
            string[] elements = items.Split(',');

            for (int i = 0; i < elements.Length; i++)
            {
                // Trim the leading space if there is one (due to the delimiter being ", ").
                if (i > 0 && elements[i].Length > 0 && elements[i][0] == ' ')
                {
                    elements[i] = elements[i].Substring(1);
                }

                if (mapping.TryGetValue(elements[i], out string substituteValue))
                {
                    elements[i] = substituteValue;
                }
            }

            return string.Join(", ", elements);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/EnumAsStringFormatter`1.cs.meta
================================================
fileFormatVersion: 2
guid: 4dc4ef7e6eaadef48b04d66cb80b5697
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/ExpandoObjectFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Collections.Generic;
using System.Dynamic;

namespace MessagePack.Formatters
{
    public class ExpandoObjectFormatter : IMessagePackFormatter<ExpandoObject>
    {
        public static readonly IMessagePackFormatter<ExpandoObject> Instance = new ExpandoObjectFormatter();

        private ExpandoObjectFormatter()
        {
        }

        public ExpandoObject Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            var result = new ExpandoObject();
            int count = reader.ReadMapHeader();
            if (count > 0)
            {
                IFormatterResolver resolver = options.Resolver;
                IMessagePackFormatter<string> keyFormatter = resolver.GetFormatterWithVerify<string>();
                IMessagePackFormatter<object> valueFormatter = resolver.GetFormatterWithVerify<object>();
                IDictionary<string, object> dictionary = result;

                options.Security.DepthStep(ref reader);
                try
                {
                    for (int i = 0; i < count; i++)
                    {
                        string key = keyFormatter.Deserialize(ref reader, options);
                        object value = valueFormatter.Deserialize(ref reader, options);
                        dictionary.Add(key, value);
                    }
                }
                finally
                {
                    reader.Depth--;
                }
            }

            return result;
        }

        public void Serialize(ref MessagePackWriter writer, ExpandoObject value, MessagePackSerializerOptions options)
        {
            var dict = (IDictionary<string, object>)value;
            var keyFormatter = options.Resolver.GetFormatterWithVerify<string>();
            var valueFormatter = options.Resolver.GetFormatterWithVerify<object>();

            writer.WriteMapHeader(dict.Count);
            foreach (var item in dict)
            {
                keyFormatter.Serialize(ref writer, item.Key, options);
                valueFormatter.Serialize(ref writer, item.Value, options);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/ExpandoObjectFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 3f013651a80f23245b9fe0ca2db89012
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/GenericEnumFormatter`1.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.CompilerServices;

namespace MessagePack.Formatters
{
    public sealed class GenericEnumFormatter<T> : IMessagePackFormatter<T>
        where T : Enum
    {
        private delegate void EnumSerialize(ref MessagePackWriter writer, ref T value);

        private delegate T EnumDeserialize(ref MessagePackReader reader);

        private readonly EnumSerialize serializer;
        private readonly EnumDeserialize deserializer;

        public GenericEnumFormatter()
        {
            var underlyingType = typeof(T).GetEnumUnderlyingType();
            switch (Type.GetTypeCode(underlyingType))
            {
#pragma warning disable SA1107 // Avoid multiple statements on same line.
                case TypeCode.Byte:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, Byte>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadByte(); return Unsafe.As<Byte, T>(ref v); };
                    break;
                case TypeCode.Int16:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, Int16>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadInt16(); return Unsafe.As<Int16, T>(ref v); };
                    break;
                case TypeCode.Int32:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, Int32>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadInt32(); return Unsafe.As<Int32, T>(ref v); };
                    break;
                case TypeCode.Int64:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, Int64>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadInt64(); return Unsafe.As<Int64, T>(ref v); };
                    break;
                case TypeCode.SByte:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, SByte>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadSByte(); return Unsafe.As<SByte, T>(ref v); };
                    break;
                case TypeCode.UInt16:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, UInt16>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadUInt16(); return Unsafe.As<UInt16, T>(ref v); };
                    break;
                case TypeCode.UInt32:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, UInt32>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadUInt32(); return Unsafe.As<UInt32, T>(ref v); };
                    break;
                case TypeCode.UInt64:
                    serializer = (ref MessagePackWriter writer, ref T value) => writer.Write(Unsafe.As<T, UInt64>(ref value));
                    deserializer = (ref MessagePackReader reader) => { var v = reader.ReadUInt64(); return Unsafe.As<UInt64, T>(ref v); };
                    break;
                default:
                    break;
#pragma warning restore SA1107 // Avoid multiple statements on same line.
            }
        }

        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            serializer(ref writer, ref value);
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return deserializer(ref reader);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/GenericEnumFormatter`1.cs.meta
================================================
fileFormatVersion: 2
guid: 16ee992e15116754bae00d06d3968ec1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/IgnoreFormatter`1.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Buffers;

namespace MessagePack.Formatters
{
    public sealed class IgnoreFormatter<T> : IMessagePackFormatter<T>
    {
        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            writer.WriteNil();
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            reader.Skip();
            return default(T);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/IgnoreFormatter`1.cs.meta
================================================
fileFormatVersion: 2
guid: 8916acfe5213bf940913b28c051e8231
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/IMessagePackFormatter`1.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Buffers;
using System.ComponentModel;

namespace MessagePack.Formatters
{
#pragma warning disable SA1649 // File name should match first type name
    /// <summary>
    /// A base interface for <see cref="IMessagePackFormatter{T}"/> so that all generic implementations
    /// can be detected by a common base type.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMessagePackFormatter
    {
    }
#pragma warning restore SA1649 // File name should match first type name

    /// <summary>
    /// The contract for serialization of some specific type.
    /// </summary>
    /// <typeparam name="T">The type to be serialized or deserialized.</typeparam>
    public interface IMessagePackFormatter<T> : IMessagePackFormatter
    {
        /// <summary>
        /// Serializes a value.
        /// </summary>
        /// <param name="writer">The writer to use when serializing the value.</param>
        /// <param name="value">The value to be serialized.</param>
        /// <param name="options">The serialization settings to use, including the resolver to use to obtain formatters for types that make up the composite type <typeparamref name="T"/>.</param>
        void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options);

        /// <summary>
        /// Deserializes a value.
        /// </summary>
        /// <param name="reader">The reader to deserialize from.</param>
        /// <param name="options">The serialization settings to use, including the resolver to use to obtain formatters for types that make up the composite type <typeparamref name="T"/>.</param>
        /// <returns>The deserialized value.</returns>
        T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/IMessagePackFormatter`1.cs.meta
================================================
fileFormatVersion: 2
guid: 88421097d73e1de479d2004c6c23d2e1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/MultiDimensionalArrayFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    /* multi dimensional array serialize to [i, j, [seq]] */

    public sealed class TwoDimensionalArrayFormatter<T> : IMessagePackFormatter<T[,]>
    {
        private const int ArrayLength = 3;

        public void Serialize(ref MessagePackWriter writer, T[,] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                var i = value.GetLength(0);
                var j = value.GetLength(1);

                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                writer.WriteArrayHeader(ArrayLength);
                writer.Write(i);
                writer.Write(j);

                writer.WriteArrayHeader(value.Length);
                foreach (T item in value)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, item, options);
                }
            }
        }

        public T[,] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                var len = reader.ReadArrayHeader();
                if (len != ArrayLength)
                {
                    throw new MessagePackSerializationException("Invalid T[,] format");
                }

                var iLength = reader.ReadInt32();
                var jLength = reader.ReadInt32();
                var maxLen = reader.ReadArrayHeader();

                var array = new T[iLength, jLength];

                var i = 0;
                var j = -1;
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int loop = 0; loop < maxLen; loop++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        if (j < jLength - 1)
                        {
                            j++;
                        }
                        else
                        {
                            j = 0;
                            i++;
                        }

                        array[i, j] = formatter.Deserialize(ref reader, options);
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return array;
            }
        }
    }

    public sealed class ThreeDimensionalArrayFormatter<T> : IMessagePackFormatter<T[,,]>
    {
        private const int ArrayLength = 4;

        public void Serialize(ref MessagePackWriter writer, T[,,] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                var i = value.GetLength(0);
                var j = value.GetLength(1);
                var k = value.GetLength(2);

                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                writer.WriteArrayHeader(ArrayLength);
                writer.Write(i);
                writer.Write(j);
                writer.Write(k);

                writer.WriteArrayHeader(value.Length);
                foreach (T item in value)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, item, options);
                }
            }
        }

        public T[,,] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                var len = reader.ReadArrayHeader();
                if (len != ArrayLength)
                {
                    throw new MessagePackSerializationException("Invalid T[,,] format");
                }

                var iLength = reader.ReadInt32();
                var jLength = reader.ReadInt32();
                var kLength = reader.ReadInt32();
                var maxLen = reader.ReadArrayHeader();

                var array = new T[iLength, jLength, kLength];

                var i = 0;
                var j = 0;
                var k = -1;
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int loop = 0; loop < maxLen; loop++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        if (k < kLength - 1)
                        {
                            k++;
                        }
                        else if (j < jLength - 1)
                        {
                            k = 0;
                            j++;
                        }
                        else
                        {
                            k = 0;
                            j = 0;
                            i++;
                        }

                        array[i, j, k] = formatter.Deserialize(ref reader, options);
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return array;
            }
        }
    }

    public sealed class FourDimensionalArrayFormatter<T> : IMessagePackFormatter<T[,,,]>
    {
        private const int ArrayLength = 5;

        public void Serialize(ref MessagePackWriter writer, T[,,,] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                var i = value.GetLength(0);
                var j = value.GetLength(1);
                var k = value.GetLength(2);
                var l = value.GetLength(3);

                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                writer.WriteArrayHeader(ArrayLength);
                writer.Write(i);
                writer.Write(j);
                writer.Write(k);
                writer.Write(l);

                writer.WriteArrayHeader(value.Length);
                foreach (T item in value)
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();
                    formatter.Serialize(ref writer, item, options);
                }
            }
        }

        public T[,,,] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                IMessagePackFormatter<T> formatter = options.Resolver.GetFormatterWithVerify<T>();

                var len = reader.ReadArrayHeader();
                if (len != ArrayLength)
                {
                    throw new MessagePackSerializationException("Invalid T[,,,] format");
                }

                var iLength = reader.ReadInt32();
                var jLength = reader.ReadInt32();
                var kLength = reader.ReadInt32();
                var lLength = reader.ReadInt32();
                var maxLen = reader.ReadArrayHeader();
                var array = new T[iLength, jLength, kLength, lLength];

                var i = 0;
                var j = 0;
                var k = 0;
                var l = -1;
                options.Security.DepthStep(ref reader);
                try
                {
                    for (int loop = 0; loop < maxLen; loop++)
                    {
                        reader.CancellationToken.ThrowIfCancellationRequested();
                        if (l < lLength - 1)
                        {
                            l++;
                        }
                        else if (k < kLength - 1)
                        {
                            l = 0;
                            k++;
                        }
                        else if (j < jLength - 1)
                        {
                            l = 0;
                            k = 0;
                            j++;
                        }
                        else
                        {
                            l = 0;
                            k = 0;
                            j = 0;
                            i++;
                        }

                        array[i, j, k, l] = formatter.Deserialize(ref reader, options);
                    }
                }
                finally
                {
                    reader.Depth--;
                }

                return array;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/MultiDimensionalArrayFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: ea25d9a859415b944a2932f414c2e353
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/NilFormatter.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace MessagePack.Formatters
{
    public class NilFormatter : IMessagePackFormatter<Nil>
    {
        public static readonly IMessagePackFormatter<Nil> Instance = new NilFormatter();

        private NilFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Nil value, MessagePackSerializerOptions options)
        {
            writer.WriteNil();
        }

        public Nil Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadNil();
        }
    }

    // NullableNil is same as Nil.
    public class NullableNilFormatter : IMessagePackFormatter<Nil?>
    {
        public static readonly IMessagePackFormatter<Nil?> Instance = new NullableNilFormatter();

        private NullableNilFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Nil? value, MessagePackSerializerOptions options)
        {
            writer.WriteNil();
        }

        public Nil? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadNil();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/NilFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: cb4a59c3b8b4d144db65ac850daf0e53
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/NullableFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class NullableFormatter<T> : IMessagePackFormatter<T?>
        where T : struct
    {
        public void Serialize(ref MessagePackWriter writer, T? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                options.Resolver.GetFormatterWithVerify<T>().Serialize(ref writer, value.Value, options);
            }
        }

        public T? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                reader.ReadNil();
                return null;
            }
            else
            {
                return options.Resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
            }
        }
    }

    public sealed class StaticNullableFormatter<T> : IMessagePackFormatter<T?>
        where T : struct
    {
        private readonly IMessagePackFormatter<T> underlyingFormatter;

        public StaticNullableFormatter(IMessagePackFormatter<T> underlyingFormatter)
        {
            this.underlyingFormatter = underlyingFormatter;
        }

        public void Serialize(ref MessagePackWriter writer, T? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                this.underlyingFormatter.Serialize(ref writer, value.Value, options);
            }
        }

        public T? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                return this.underlyingFormatter.Deserialize(ref reader, options);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/NullableFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 05a403acf284b814abe1eabfbde39d1e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/PrimitiveObjectFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Net.Security;
using System.Reflection;

namespace MessagePack.Formatters
{
    public class PrimitiveObjectFormatter : IMessagePackFormatter<object>
    {
        public static readonly IMessagePackFormatter<object> Instance = new PrimitiveObjectFormatter();

        private static readonly Dictionary<Type, int> TypeToJumpCode = new Dictionary<Type, int>()
        {
            // When adding types whose size exceeds 32-bits, add support in MessagePackSecurity.GetHashCollisionResistantEqualityComparer<T>()
            { typeof(Boolean), 0 },
            { typeof(Char), 1 },
            { typeof(SByte), 2 },
            { typeof(Byte), 3 },
            { typeof(Int16), 4 },
            { typeof(UInt16), 5 },
            { typeof(Int32), 6 },
            { typeof(UInt32), 7 },
            { typeof(Int64), 8 },
            { typeof(UInt64), 9 },
            { typeof(Single), 10 },
            { typeof(Double), 11 },
            { typeof(DateTime), 12 },
            { typeof(string), 13 },
            { typeof(byte[]), 14 },
        };

        protected PrimitiveObjectFormatter()
        {
        }

        public static bool IsSupportedType(Type type, TypeInfo typeInfo, object value)
        {
            if (value == null)
            {
                return true;
            }

            if (TypeToJumpCode.ContainsKey(type))
            {
                return true;
            }

            if (typeInfo.IsEnum)
            {
                return true;
            }

            if (value is System.Collections.IDictionary)
            {
                return true;
            }

            if (value is System.Collections.ICollection)
            {
                return true;
            }

            return false;
        }

        public void Serialize(ref MessagePackWriter writer, object value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            Type t = value.GetType();

            int code;
            if (TypeToJumpCode.TryGetValue(t, out code))
            {
                switch (code)
                {
                    case 0:
                        writer.Write((bool)value);
                        return;
                    case 1:
                        writer.Write((char)value);
                        return;
                    case 2:
                        writer.WriteInt8((sbyte)value);
                        return;
                    case 3:
                        writer.WriteUInt8((byte)value);
                        return;
                    case 4:
                        writer.WriteInt16((Int16)value);
                        return;
                    case 5:
                        writer.WriteUInt16((UInt16)value);
                        return;
                    case 6:
                        writer.WriteInt32((Int32)value);
                        return;
                    case 7:
                        writer.WriteUInt32((UInt32)value);
                        return;
                    case 8:
                        writer.WriteInt64((Int64)value);
                        return;
                    case 9:
                        writer.WriteUInt64((UInt64)value);
                        return;
                    case 10:
                        writer.Write((Single)value);
                        return;
                    case 11:
                        writer.Write((double)value);
                        return;
                    case 12:
                        writer.Write((DateTime)value);
                        return;
                    case 13:
                        writer.Write((string)value);
                        return;
                    case 14:
                        writer.Write((byte[])value);
                        return;
                    default:
                        throw new MessagePackSerializationException("Not supported primitive object resolver. type:" + t.Name);
                }
            }
            else
            {
#if UNITY_2018_3_OR_NEWER && !NETFX_CORE
                if (t.IsEnum)
#else
                if (t.GetTypeInfo().IsEnum)
#endif
                {
                    Type underlyingType = Enum.GetUnderlyingType(t);
                    var code2 = TypeToJumpCode[underlyingType];
                    switch (code2)
                    {
                        case 2:
                            writer.WriteInt8((sbyte)value);
                            return;
                        case 3:
                            writer.WriteUInt8((byte)value);
                            return;
                        case 4:
                            writer.WriteInt16((Int16)value);
                            return;
                        case 5:
                            writer.WriteUInt16((UInt16)value);
                            return;
                        case 6:
                            writer.WriteInt32((Int32)value);
                            return;
                        case 7:
                            writer.WriteUInt32((UInt32)value);
                            return;
                        case 8:
                            writer.WriteInt64((Int64)value);
                            return;
                        case 9:
                            writer.WriteUInt64((UInt64)value);
                            return;
                        default:
                            break;
                    }
                }
                else if (value is System.Collections.IDictionary)
                {
                    // check IDictionary first
                    var d = value as System.Collections.IDictionary;
                    writer.WriteMapHeader(d.Count);
                    foreach (System.Collections.DictionaryEntry item in d)
                    {
                        this.Serialize(ref writer, item.Key, options);
                        this.Serialize(ref writer, item.Value, options);
                    }

                    return;
                }
                else if (value is System.Collections.ICollection)
                {
                    var c = value as System.Collections.ICollection;
                    writer.WriteArrayHeader(c.Count);
                    foreach (var item in c)
                    {
                        this.Serialize(ref writer, item, options);
                    }

                    return;
                }
            }

            throw new MessagePackSerializationException("Not supported primitive object resolver. type:" + t.Name);
        }

        public object Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            MessagePackType type = reader.NextMessagePackType;
            IFormatterResolver resolver = options.Resolver;
            switch (type)
            {
                case MessagePackType.Integer:
                    var code = reader.NextCode;
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return reader.ReadSByte();
                    }
                    else if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return reader.ReadByte();
                    }
                    else if (code == MessagePackCode.Int8)
                    {
                        return reader.ReadSByte();
                    }
                    else if (code == MessagePackCode.Int16)
                    {
                        return reader.ReadInt16();
                    }
                    else if (code == MessagePackCode.Int32)
                    {
                        return reader.ReadInt32();
                    }
                    else if (code == MessagePackCode.Int64)
                    {
                        return reader.ReadInt64();
                    }
                    else if (code == MessagePackCode.UInt8)
                    {
                        return reader.ReadByte();
                    }
                    else if (code == MessagePackCode.UInt16)
                    {
                        return reader.ReadUInt16();
                    }
                    else if (code == MessagePackCode.UInt32)
                    {
                        return reader.ReadUInt32();
                    }
                    else if (code == MessagePackCode.UInt64)
                    {
                        return reader.ReadUInt64();
                    }

                    throw new MessagePackSerializationException("Invalid primitive bytes.");
                case MessagePackType.Boolean:
                    return reader.ReadBoolean();
                case MessagePackType.Float:
                    if (reader.NextCode == MessagePackCode.Float32)
                    {
                        return reader.ReadSingle();
                    }
                    else
                    {
                        return reader.ReadDouble();
                    }

                case MessagePackType.String:
                    return reader.ReadString();
                case MessagePackType.Binary:
                    // We must copy the sequence returned by ReadBytes since the reader's sequence is only valid during deserialization.
                    return reader.ReadBytes()?.ToArray();
                case MessagePackType.Extension:
                    ExtensionHeader ext = reader.ReadExtensionFormatHeader();
                    if (ext.TypeCode == ReservedMessagePackExtensionTypeCode.DateTime)
                    {
                        return reader.ReadDateTime(ext);
                    }

                    throw new MessagePackSerializationException("Invalid primitive bytes.");
                case MessagePackType.Array:
                    {
                        var length = reader.ReadArrayHeader();
                        if (length == 0)
                        {
                            return Array.Empty<object>();
                        }

                        IMessagePackFormatter<object> objectFormatter = resolver.GetFormatter<object>();
                        var array = new object[length];
                        options.Security.DepthStep(ref reader);
                        try
                        {
                            for (int i = 0; i < length; i++)
                            {
                                array[i] = objectFormatter.Deserialize(ref reader, options);
                            }
                        }
                        finally
                        {
                            reader.Depth--;
                        }

                        return array;
                    }

                case MessagePackType.Map:
                    {
                        var length = reader.ReadMapHeader();

                        options.Security.DepthStep(ref reader);
                        try
                        {
                            return this.DeserializeMap(ref reader, length, options);
                        }
                        finally
                        {
                            reader.Depth--;
                        }
                    }

                case MessagePackType.Nil:
                    reader.ReadNil();
                    return null;
                default:
                    throw new MessagePackSerializationException("Invalid primitive bytes.");
            }
        }

        protected virtual object DeserializeMap(ref MessagePackReader reader, int length, MessagePackSerializerOptions options)
        {
            IMessagePackFormatter<object> objectFormatter = options.Resolver.GetFormatter<object>();
            var dictionary = new Dictionary<object, object>(length, options.Security.GetEqualityComparer<object>());
            for (int i = 0; i < length; i++)
            {
                var key = objectFormatter.Deserialize(ref reader, options);
                var value = objectFormatter.Deserialize(ref reader, options);
                dictionary.Add(key, value);
            }

            return dictionary;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/PrimitiveObjectFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 5e9c746624d882945a740f31fc8ebda9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/StandardClassLibraryFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using MessagePack.Internal;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    // NET40 -> BigInteger, Complex, Tuple

    // byte[] is special. represents bin type.
    public sealed class ByteArrayFormatter : IMessagePackFormatter<byte[]>
    {
        public static readonly ByteArrayFormatter Instance = new ByteArrayFormatter();

        private ByteArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, byte[] value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public byte[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBytes()?.ToArray();
        }
    }

    public sealed class NullableStringFormatter : IMessagePackFormatter<String>
    {
        public static readonly NullableStringFormatter Instance = new NullableStringFormatter();

        private NullableStringFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, string value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public string Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadString();
        }
    }

    public sealed class NullableStringArrayFormatter : IMessagePackFormatter<String[]>
    {
        public static readonly NullableStringArrayFormatter Instance = new NullableStringArrayFormatter();

        private NullableStringArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, String[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public String[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<String>();
            }

            var array = new String[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadString();
            }

            return array;
        }
    }

    public sealed class DecimalFormatter : IMessagePackFormatter<Decimal>
    {
        public static readonly DecimalFormatter Instance = new DecimalFormatter();

        private DecimalFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, decimal value, MessagePackSerializerOptions options)
        {
            var dest = writer.GetSpan(MessagePackRange.MaxFixStringLength);
            if (System.Buffers.Text.Utf8Formatter.TryFormat(value, dest.Slice(1), out var written))
            {
                // write header
                dest[0] = (byte)(MessagePackCode.MinFixStr | written);
                writer.Advance(written + 1);
            }
            else
            {
                // reset writer's span previously acquired that does not use
                writer.Advance(0);
                writer.Write(value.ToString(CultureInfo.InvariantCulture));
            }
        }

        public decimal Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (!(reader.ReadStringSequence() is ReadOnlySequence<byte> sequence))
            {
                throw new MessagePackSerializationException(string.Format("Unexpected msgpack code {0} ({1}) encountered.", MessagePackCode.Nil, MessagePackCode.ToFormatName(MessagePackCode.Nil)));
            }

            if (sequence.IsSingleSegment)
            {
                var span = sequence.First.Span;
                if (System.Buffers.Text.Utf8Parser.TryParse(span, out decimal result, out var bytesConsumed))
                {
                    if (span.Length != bytesConsumed)
                    {
                        throw new MessagePackSerializationException("Unexpected length of string.");
                    }

                    return result;
                }
            }
            else
            {
                // sequence.Length is not free
                var seqLen = (int)sequence.Length;
                if (seqLen < 128)
                {
                    Span<byte> span = stackalloc byte[seqLen];
                    sequence.CopyTo(span);
                    if (System.Buffers.Text.Utf8Parser.TryParse(span, out decimal result, out var bytesConsumed))
                    {
                        if (seqLen != bytesConsumed)
                        {
                            throw new MessagePackSerializationException("Unexpected length of string.");
                        }

                        return result;
                    }
                }
                else
                {
                    var rentArray = ArrayPool<byte>.Shared.Rent(seqLen);
                    try
                    {
                        sequence.CopyTo(rentArray);
                        if (System.Buffers.Text.Utf8Parser.TryParse(rentArray.AsSpan(0, seqLen), out decimal result, out var bytesConsumed))
                        {
                            if (seqLen != bytesConsumed)
                            {
                                throw new MessagePackSerializationException("Unexpected length of string.");
                            }

                            return result;
                        }
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(rentArray);
                    }
                }
            }

            throw new MessagePackSerializationException("Can't parse to decimal, input string was not in a correct format.");
        }
    }

    public sealed class TimeSpanFormatter : IMessagePackFormatter<TimeSpan>
    {
        public static readonly IMessagePackFormatter<TimeSpan> Instance = new TimeSpanFormatter();

        private TimeSpanFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, TimeSpan value, MessagePackSerializerOptions options)
        {
            writer.Write(value.Ticks);
            return;
        }

        public TimeSpan Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return new TimeSpan(reader.ReadInt64());
        }
    }

    public sealed class DateTimeOffsetFormatter : IMessagePackFormatter<DateTimeOffset>
    {
        public static readonly IMessagePackFormatter<DateTimeOffset> Instance = new DateTimeOffsetFormatter();

        private DateTimeOffsetFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, DateTimeOffset value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(new DateTime(value.Ticks, DateTimeKind.Utc)); // current ticks as is
            writer.Write((short)value.Offset.TotalMinutes); // offset is normalized in minutes
            return;
        }

        public DateTimeOffset Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            var count = reader.ReadArrayHeader();

            if (count != 2)
            {
                throw new MessagePackSerializationException("Invalid DateTimeOffset format.");
            }

            DateTime utc = reader.ReadDateTime();

            var dtOffsetMinutes = reader.ReadInt16();

            return new DateTimeOffset(utc.Ticks, TimeSpan.FromMinutes(dtOffsetMinutes));
        }
    }

    public sealed class GuidFormatter : IMessagePackFormatter<Guid>
    {
        public static readonly IMessagePackFormatter<Guid> Instance = new GuidFormatter();

        private GuidFormatter()
        {
        }

        public unsafe void Serialize(ref MessagePackWriter writer, Guid value, MessagePackSerializerOptions options)
        {
            byte* pBytes = stackalloc byte[36];
            Span<byte> bytes = new Span<byte>(pBytes, 36);
            new GuidBits(ref value).Write(bytes);
            writer.WriteString(bytes);
        }

        public Guid Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            ReadOnlySequence<byte> segment = reader.ReadStringSequence().Value;
            if (segment.Length != 36)
            {
                throw new MessagePackSerializationException("Unexpected length of string.");
            }

            GuidBits result;
            if (segment.IsSingleSegment)
            {
                result = new GuidBits(segment.First.Span);
            }
            else
            {
                Span<byte> bytes = stackalloc byte[36];
                segment.CopyTo(bytes);
                result = new GuidBits(bytes);
            }

            return result.Value;
        }
    }

    public sealed class UriFormatter : IMessagePackFormatter<Uri>
    {
        public static readonly IMessagePackFormatter<Uri> Instance = new UriFormatter();

        private UriFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Uri value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.OriginalString);
            }
        }

        public Uri Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                return new Uri(reader.ReadString(), UriKind.RelativeOrAbsolute);
            }
        }
    }

    public sealed class VersionFormatter : IMessagePackFormatter<Version>
    {
        public static readonly IMessagePackFormatter<Version> Instance = new VersionFormatter();

        private VersionFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Version value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.ToString());
            }
        }

        public Version Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                return new Version(reader.ReadString());
            }
        }
    }

    public sealed class KeyValuePairFormatter<TKey, TValue> : IMessagePackFormatter<KeyValuePair<TKey, TValue>>
    {
        public void Serialize(ref MessagePackWriter writer, KeyValuePair<TKey, TValue> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<TKey>().Serialize(ref writer, value.Key, options);
            resolver.GetFormatterWithVerify<TValue>().Serialize(ref writer, value.Value, options);
            return;
        }

        public KeyValuePair<TKey, TValue> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            var count = reader.ReadArrayHeader();

            if (count != 2)
            {
                throw new MessagePackSerializationException("Invalid KeyValuePair format.");
            }

            IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);
            try
            {
                TKey key = resolver.GetFormatterWithVerify<TKey>().Deserialize(ref reader, options);
                TValue value = resolver.GetFormatterWithVerify<TValue>().Deserialize(ref reader, options);
                return new KeyValuePair<TKey, TValue>(key, value);
            }
            finally
            {
                reader.Depth--;
            }
        }
    }

    public sealed class StringBuilderFormatter : IMessagePackFormatter<StringBuilder>
    {
        public static readonly IMessagePackFormatter<StringBuilder> Instance = new StringBuilderFormatter();

        private StringBuilderFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, StringBuilder value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.ToString());
            }
        }

        public StringBuilder Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                return new StringBuilder(reader.ReadString());
            }
        }
    }

    public sealed class BitArrayFormatter : IMessagePackFormatter<BitArray>
    {
        public static readonly IMessagePackFormatter<BitArray> Instance = new BitArrayFormatter();

        private BitArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, BitArray value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                var len = value.Length;
                writer.WriteArrayHeader(len);
                for (int i = 0; i < len; i++)
                {
                    writer.Write(value.Get(i));
                }

                return;
            }
        }

        public BitArray Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                var len = reader.ReadArrayHeader();

                var array = new BitArray(len);
                for (int i = 0; i < len; i++)
                {
                    array[i] = reader.ReadBoolean();
                }

                return array;
            }
        }
    }

    public sealed class BigIntegerFormatter : IMessagePackFormatter<System.Numerics.BigInteger>
    {
        public static readonly IMessagePackFormatter<System.Numerics.BigInteger> Instance = new BigIntegerFormatter();

        private BigIntegerFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, System.Numerics.BigInteger value, MessagePackSerializerOptions options)
        {
#if NETCOREAPP
            if (!writer.OldSpec)
            {
                // try to get bin8 buffer.
                var span = writer.GetSpan(byte.MaxValue);
                if (value.TryWriteBytes(span.Slice(2), out var written))
                {
                    span[0] = MessagePackCode.Bin8;
                    span[1] = (byte)written;

                    writer.Advance(written + 2);
                    return;
                }
                else
                {
                    // reset writer's span previously acquired that does not use
                    writer.Advance(0);
                }
            }
#endif

            writer.Write(value.ToByteArray());
            return;
        }

        public System.Numerics.BigInteger Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            ReadOnlySequence<byte> bytes = reader.ReadBytes().Value;
#if NETCOREAPP
            if (bytes.IsSingleSegment)
            {
                return new System.Numerics.BigInteger(bytes.First.Span);
            }
            else
            {
                byte[] bytesArray = ArrayPool<byte>.Shared.Rent((int)bytes.Length);
                try
                {
                    bytes.CopyTo(bytesArray);
                    return new System.Numerics.BigInteger(bytesArray.AsSpan(0, (int)bytes.Length));
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(bytesArray);
                }
            }
#else
            return new System.Numerics.BigInteger(bytes.ToArray());
#endif
        }
    }

    public sealed class ComplexFormatter : IMessagePackFormatter<System.Numerics.Complex>
    {
        public static readonly IMessagePackFormatter<System.Numerics.Complex> Instance = new ComplexFormatter();

        private ComplexFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, System.Numerics.Complex value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.Real);
            writer.Write(value.Imaginary);
            return;
        }

        public System.Numerics.Complex Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            var count = reader.ReadArrayHeader();

            if (count != 2)
            {
                throw new MessagePackSerializationException("Invalid Complex format.");
            }

            var real = reader.ReadDouble();

            var imaginary = reader.ReadDouble();

            return new System.Numerics.Complex(real, imaginary);
        }
    }

    public sealed class LazyFormatter<T> : IMessagePackFormatter<Lazy<T>>
    {
        public void Serialize(ref MessagePackWriter writer, Lazy<T> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T>().Serialize(ref writer, value.Value, options);
            }
        }

        public Lazy<T> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }
            else
            {
                options.Security.DepthStep(ref reader);
                try
                {
                    // deserialize immediately(no delay, because capture byte[] causes memory leak)
                    IFormatterResolver resolver = options.Resolver;
                    T v = resolver.GetFormatterWithVerify<T>().Deserialize(ref reader, options);
                    return new Lazy<T>(() => v);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    /// <summary>
    /// Serializes any instance of <see cref="Type"/> by its <see cref="Type.AssemblyQualifiedName"/> value.
    /// </summary>
    /// <typeparam name="T">The <see cref="Type"/> class itself or a derived type.</typeparam>
    public sealed class TypeFormatter<T> : IMessagePackFormatter<T>
        where T : Type
    {
        public static readonly IMessagePackFormatter<T> Instance = new TypeFormatter<T>();

        private TypeFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.AssemblyQualifiedName);
            }
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            return (T)Type.GetType(reader.ReadString(), throwOnError: true);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/StandardClassLibraryFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: ae4d882aeb27bc54e991d848a5683387
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/TypelessFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !UNITY_2018_3_OR_NEWER

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using MessagePack.Internal;

namespace MessagePack.Formatters
{
#pragma warning disable SA1649 // File name should match first type name

    /// <summary>
    /// Force serialize object as typeless.
    /// </summary>
    public sealed class ForceTypelessFormatter<T> : IMessagePackFormatter<T>
    {
        public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
        {
            TypelessFormatter.Instance.Serialize(ref writer, (object)value, options);
        }

        public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return (T)TypelessFormatter.Instance.Deserialize(ref reader, options);
        }
    }

#pragma warning restore SA1649 // File name should match first type name

    /// <summary>
    /// For `object` field that holds derived from `object` value, ex: var arr = new object[] { 1, "a", new Model() };.
    /// </summary>
    public sealed class TypelessFormatter : IMessagePackFormatter<object>
    {
        private delegate void SerializeMethod(object dynamicContractlessFormatter, ref MessagePackWriter writer, object value, MessagePackSerializerOptions options);

        private delegate object DeserializeMethod(object dynamicContractlessFormatter, ref MessagePackReader reader, MessagePackSerializerOptions options);

        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly IMessagePackFormatter<object> Instance = new TypelessFormatter();

        private static readonly ThreadsafeTypeKeyHashTable<SerializeMethod> Serializers = new ThreadsafeTypeKeyHashTable<SerializeMethod>();
        private static readonly ThreadsafeTypeKeyHashTable<DeserializeMethod> Deserializers = new ThreadsafeTypeKeyHashTable<DeserializeMethod>();
        private static readonly ThreadsafeTypeKeyHashTable<byte[]> FullTypeNameCache = new ThreadsafeTypeKeyHashTable<byte[]>();
        private static readonly ThreadsafeTypeKeyHashTable<byte[]> ShortenedTypeNameCache = new ThreadsafeTypeKeyHashTable<byte[]>();
        private static readonly AsymmetricKeyHashTable<byte[], ArraySegment<byte>, Type> TypeCache = new AsymmetricKeyHashTable<byte[], ArraySegment<byte>, Type>(new StringArraySegmentByteAscymmetricEqualityComparer());

        private static readonly HashSet<Type> UseBuiltinTypes = new HashSet<Type>
        {
            typeof(Boolean),
            ////typeof(Char),
            typeof(SByte),
            typeof(Byte),
            typeof(Int16),
            typeof(UInt16),
            typeof(Int32),
            typeof(UInt32),
            typeof(Int64),
            typeof(UInt64),
            typeof(Single),
            typeof(Double),
            typeof(string),
            typeof(byte[]),

            // array should save their types.
            ////typeof(Boolean[]),
            ////typeof(Char[]),
            ////typeof(SByte[]),
            ////typeof(Int16[]),
            ////typeof(UInt16[]),
            ////typeof(Int32[]),
            ////typeof(UInt32[]),
            ////typeof(Int64[]),
            ////typeof(UInt64[]),
            ////typeof(Single[]),
            ////typeof(Double[]),
            ////typeof(string[]),

            typeof(Boolean?),
            ////typeof(Char?),
            typeof(SByte?),
            typeof(Byte?),
            typeof(Int16?),
            typeof(UInt16?),
            typeof(Int32?),
            typeof(UInt32?),
            typeof(Int64?),
            typeof(UInt64?),
            typeof(Single?),
            typeof(Double?),
        };

        //ForceSizePrimitiveObjectResolver.Instance,
        //ContractlessStandardResolverAllowPrivate.Instance);

        // mscorlib or System.Private.CoreLib
        private static readonly bool IsMscorlib = typeof(int).AssemblyQualifiedName.Contains("mscorlib");

        static TypelessFormatter()
        {
            Serializers.TryAdd(typeof(object), _ => (object p1, ref MessagePackWriter p2, object p3, MessagePackSerializerOptions p4) => { });
            Deserializers.TryAdd(typeof(object), _ => (object p1, ref MessagePackReader p2, MessagePackSerializerOptions p3) => new object());
        }

        private string BuildTypeName(Type type, MessagePackSerializerOptions options)
        {
            if (options.OmitAssemblyVersion)
            {
                string full = type.AssemblyQualifiedName;

                var shortened = MessagePackSerializerOptions.AssemblyNameVersionSelectorRegex.Replace(full, string.Empty);
                if (Type.GetType(shortened, false) == null)
                {
                    // if type cannot be found with shortened name - use full name
                    shortened = full;
                }

                return shortened;
            }
            else
            {
                return type.AssemblyQualifiedName;
            }
        }

        public void Serialize(ref MessagePackWriter writer, object value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            Type type = value.GetType();

            byte[] typeName;
            var typeNameCache = options.OmitAssemblyVersion ? ShortenedTypeNameCache : FullTypeNameCache;
            if (!typeNameCache.TryGetValue(type, out typeName))
            {
                TypeInfo ti = type.GetTypeInfo();
                if (ti.IsAnonymous() || UseBuiltinTypes.Contains(type))
                {
                    typeName = null;
                }
                else
                {
                    typeName = StringEncoding.UTF8.GetBytes(this.BuildTypeName(type, options));
                }

                typeNameCache.TryAdd(type, typeName);
            }

            if (typeName == null)
            {
                DynamicObjectTypeFallbackFormatter.Instance.Serialize(ref writer, value, options);
                return;
            }

            var formatter = options.Resolver.GetFormatterDynamicWithVerify(type);

            // don't use GetOrAdd for avoid closure capture.
            if (!Serializers.TryGetValue(type, out SerializeMethod serializeMethod))
            {
                // double check locking...
                lock (Serializers)
                {
                    if (!Serializers.TryGetValue(type, out serializeMethod))
                    {
                        TypeInfo ti = type.GetTypeInfo();

                        Type formatterType = typeof(IMessagePackFormatter<>).MakeGenericType(type);
                        ParameterExpression param0 = Expression.Parameter(typeof(object), "formatter");
                        ParameterExpression param1 = Expression.Parameter(typeof(MessagePackWriter).MakeByRefType(), "writer");
                        ParameterExpression param2 = Expression.Parameter(typeof(object), "value");
                        ParameterExpression param3 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");

                        MethodInfo serializeMethodInfo = formatterType.GetRuntimeMethod("Serialize", new[] { typeof(MessagePackWriter).MakeByRefType(), type, typeof(MessagePackSerializerOptions) });

                        MethodCallExpression body = Expression.Call(
                            Expression.Convert(param0, formatterType),
                            serializeMethodInfo,
                            param1,
                            ti.IsValueType ? Expression.Unbox(param2, type) : Expression.Convert(param2, type),
                            param3);

                        serializeMethod = Expression.Lambda<SerializeMethod>(body, param0, param1, param2, param3).Compile();

                        Serializers.TryAdd(type, serializeMethod);
                    }
                }
            }

            // mark will be written at the end, when size is known
            using (var scratchRental = SequencePool.Shared.Rent())
            {
                MessagePackWriter scratchWriter = writer.Clone(scratchRental.Value);
                scratchWriter.WriteString(typeName);
                serializeMethod(formatter, ref scratchWriter, value, options);
                scratchWriter.Flush();

                // mark as extension with code 100
                writer.WriteExtensionFormat(new ExtensionResult((sbyte)ThisLibraryExtensionTypeCodes.TypelessFormatter, scratchRental.Value));
            }
        }

        public object Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            if (reader.NextMessagePackType == MessagePackType.Extension)
            {
                MessagePackReader peekReader = reader.CreatePeekReader();
                ExtensionHeader ext = peekReader.ReadExtensionFormatHeader();
                if (ext.TypeCode == ThisLibraryExtensionTypeCodes.TypelessFormatter)
                {
                    reader = peekReader; // commit the experimental read made earlier.

                    // it has type name serialized
                    ReadOnlySequence<byte> typeName = reader.ReadStringSequence().Value;
                    ArraySegment<byte> typeNameArraySegment;
                    byte[] rented = null;
                    if (!typeName.IsSingleSegment || !MemoryMarshal.TryGetArray(typeName.First, out typeNameArraySegment))
                    {
                        rented = ArrayPool<byte>.Shared.Rent((int)typeName.Length);
                        typeName.CopyTo(rented);
                        typeNameArraySegment = new ArraySegment<byte>(rented, 0, (int)typeName.Length);
                    }

                    var result = this.DeserializeByTypeName(typeNameArraySegment, ref reader, options);

                    if (rented != null)
                    {
                        ArrayPool<byte>.Shared.Return(rented);
                    }

                    return result;
                }
            }

            // fallback
            return DynamicObjectTypeFallbackFormatter.Instance.Deserialize(ref reader, options);
        }

        /// <summary>
        /// Does not support deserializing of anonymous types
        /// Type should be covered by preceeding resolvers in complex/standard resolver.
        /// </summary>
        private object DeserializeByTypeName(ArraySegment<byte> typeName, ref MessagePackReader byteSequence, MessagePackSerializerOptions options)
        {
            // try get type with assembly name, throw if not found
            Type type;
            if (!TypeCache.TryGetValue(typeName, out type))
            {
                var buffer = new byte[typeName.Count];
                Buffer.BlockCopy(typeName.Array, typeName.Offset, buffer, 0, buffer.Length);
                var str = StringEncoding.UTF8.GetString(buffer);
                type = options.LoadType(str);
                if (type == null)
                {
                    if (IsMscorlib && str.Contains("System.Private.CoreLib"))
                    {
                        str = str.Replace("System.Private.CoreLib", "mscorlib");
                        type = Type.GetType(str, true); // throw
                    }
                    else if (!IsMscorlib && str.Contains("mscorlib"))
                    {
                        str = str.Replace("mscorlib", "System.Private.CoreLib");
                        type = Type.GetType(str, true); // throw
                    }
                    else
                    {
                        type = Type.GetType(str, true); // re-throw
                    }
                }

                TypeCache.TryAdd(buffer, type);
            }

            options.ThrowIfDeserializingTypeIsDisallowed(type);

            var formatter = options.Resolver.GetFormatterDynamicWithVerify(type);

            if (!Deserializers.TryGetValue(type, out DeserializeMethod deserializeMethod))
            {
                lock (Deserializers)
                {
                    if (!Deserializers.TryGetValue(type, out deserializeMethod))
                    {
                        TypeInfo ti = type.GetTypeInfo();

                        Type formatterType = typeof(IMessagePackFormatter<>).MakeGenericType(type);
                        ParameterExpression param0 = Expression.Parameter(typeof(object), "formatter");
                        ParameterExpression param1 = Expression.Parameter(typeof(MessagePackReader).MakeByRefType(), "reader");
                        ParameterExpression param2 = Expression.Parameter(typeof(MessagePackSerializerOptions), "options");

                        MethodInfo deserializeMethodInfo = formatterType.GetRuntimeMethod("Deserialize", new[] { typeof(MessagePackReader).MakeByRefType(), typeof(MessagePackSerializerOptions) });

                        MethodCallExpression deserialize = Expression.Call(
                            Expression.Convert(param0, formatterType),
                            deserializeMethodInfo,
                            param1,
                            param2);

                        Expression body = deserialize;
                        if (ti.IsValueType)
                        {
                            body = Expression.Convert(deserialize, typeof(object));
                        }

                        deserializeMethod = Expression.Lambda<DeserializeMethod>(body, param0, param1, param2).Compile();

                        Deserializers.TryAdd(type, deserializeMethod);
                    }
                }
            }

            return deserializeMethod(formatter, ref byteSequence, options);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/TypelessFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 368d3024351ce2e4abc42297e26c5108
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/UnsafeBinaryFormatters.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class NativeGuidFormatter : IMessagePackFormatter<Guid>
    {
        /// <summary>
        /// Unsafe binary Guid formatter. this is only allowed on LittleEndian environment.
        /// </summary>
        public static readonly IMessagePackFormatter<Guid> Instance = new NativeGuidFormatter();

        private NativeGuidFormatter()
        {
        }

        /* Guid's underlying _a,...,_k field is sequential and same layout as .NET Framework and Mono(Unity).
         * But target machines must be same endian so restrict only for little endian. */

        public unsafe void Serialize(ref MessagePackWriter writer, Guid value, MessagePackSerializerOptions options)
        {
            if (!BitConverter.IsLittleEndian)
            {
                throw new InvalidOperationException("NativeGuidFormatter only allows on little endian env.");
            }

            var valueSpan = new ReadOnlySpan<byte>(&value, sizeof(Guid));
            writer.Write(valueSpan);
        }

        public unsafe Guid Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (!BitConverter.IsLittleEndian)
            {
                throw new InvalidOperationException("NativeGuidFormatter only allows on little endian env.");
            }

            ReadOnlySequence<byte> valueSequence = reader.ReadBytes().Value;
            if (valueSequence.Length != sizeof(Guid))
            {
                throw new MessagePackSerializationException("Invalid Guid Size.");
            }

            Guid result;
            var resultSpan = new Span<byte>(&result, sizeof(Guid));
            valueSequence.CopyTo(resultSpan);
            return result;
        }
    }

    public sealed class NativeDecimalFormatter : IMessagePackFormatter<Decimal>
    {
        /// <summary>
        /// Unsafe binary Decimal formatter. this is only allows on LittleEndian environment.
        /// </summary>
        public static readonly IMessagePackFormatter<Decimal> Instance = new NativeDecimalFormatter();

        private NativeDecimalFormatter()
        {
        }

        /* decimal underlying "flags, hi, lo, mid" fields are sequential and same layuout with .NET Framework and Mono(Unity)
         * But target machines must be same endian so restrict only for little endian. */

        public unsafe void Serialize(ref MessagePackWriter writer, Decimal value, MessagePackSerializerOptions options)
        {
            if (!BitConverter.IsLittleEndian)
            {
                throw new InvalidOperationException("NativeDecimalFormatter only allows on little endian env.");
            }

            var valueSpan = new ReadOnlySpan<byte>(&value, sizeof(Decimal));
            writer.Write(valueSpan);
        }

        public unsafe Decimal Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (!BitConverter.IsLittleEndian)
            {
                throw new InvalidOperationException("NativeDecimalFormatter only allows on little endian env.");
            }

            ReadOnlySequence<byte> valueSequence = reader.ReadBytes().Value;
            if (valueSequence.Length != sizeof(decimal))
            {
                throw new MessagePackSerializationException("Invalid decimal Size.");
            }

            decimal result;
            var resultSpan = new Span<byte>(&result, sizeof(decimal));
            valueSequence.CopyTo(resultSpan);
            return result;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Formatters/UnsafeBinaryFormatters.cs.meta
================================================
fileFormatVersion: 2
guid: 0b4bd9957393761499af403a5ef7ebfa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/AsymmetricKeyHashTable.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !UNITY_2018_3_OR_NEWER

using System;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Internal
{
    /* Safe for multiple-read, single-write.
     * Add and Get Key is asymmetric. */

    internal interface IAsymmetricEqualityComparer<TKey1, TKey2>
    {
        int GetHashCode(TKey1 key1);

        int GetHashCode(TKey2 key2);

        bool Equals(TKey1 x, TKey1 y); // when used rehash

        bool Equals(TKey1 x, TKey2 y); // when used get
    }

    internal class StringArraySegmentByteAscymmetricEqualityComparer : IAsymmetricEqualityComparer<byte[], ArraySegment<byte>>
    {
        private static readonly bool Is32Bit = IntPtr.Size == 4;

        public bool Equals(byte[] x, byte[] y)
        {
            if (x.Length != y.Length)
            {
                return false;
            }

            for (int i = 0; i < x.Length; i++)
            {
                if (x[i] != y[i])
                {
                    return false;
                }
            }

            return true;
        }

        public bool Equals(byte[] x, ArraySegment<byte> y)
        {
            return x.AsSpan().SequenceEqual(y);
        }

        public int GetHashCode(byte[] key1)
        {
            return this.GetHashCode(new ArraySegment<byte>(key1, 0, key1.Length));
        }

        public int GetHashCode(ArraySegment<byte> key2)
        {
            unchecked
            {
                if (Is32Bit)
                {
                    return (int)FarmHash.Hash32(key2);
                }
                else
                {
                    return (int)FarmHash.Hash64(key2);
                }
            }
        }
    }

    internal sealed class AsymmetricKeyHashTable<TKey1, TKey2, TValue>
    {
        private Entry[] buckets;
        private int size; // only use in writer lock

        private readonly object writerLock = new object();
        private readonly float loadFactor;
        private readonly IAsymmetricEqualityComparer<TKey1, TKey2> comparer;

        public AsymmetricKeyHashTable(IAsymmetricEqualityComparer<TKey1, TKey2> comparer)
            : this(4, 0.72f, comparer)
        {
        }

        public AsymmetricKeyHashTable(int capacity, float loadFactor, IAsymmetricEqualityComparer<TKey1, TKey2> comparer)
        {
            var tableSize = CalculateCapacity(capacity, loadFactor);
            this.buckets = new Entry[tableSize];
            this.loadFactor = loadFactor;
            this.comparer = comparer;
        }

        public TValue AddOrGet(TKey1 key1, Func<TKey1, TValue> valueFactory)
        {
            TValue v;
            this.TryAddInternal(key1, valueFactory, out v);
            return v;
        }

        public bool TryAdd(TKey1 key, TValue value)
        {
            return this.TryAdd(key, _ => value); // closure capture
        }

        public bool TryAdd(TKey1 key, Func<TKey1, TValue> valueFactory)
        {
            return this.TryAddInternal(key, valueFactory, out TValue _);
        }

        private bool TryAddInternal(TKey1 key, Func<TKey1, TValue> valueFactory, out TValue resultingValue)
        {
            lock (this.writerLock)
            {
                var nextCapacity = CalculateCapacity(this.size + 1, this.loadFactor);

                if (this.buckets.Length < nextCapacity)
                {
                    // rehash
                    var nextBucket = new Entry[nextCapacity];
                    for (int i = 0; i < this.buckets.Length; i++)
                    {
                        Entry e = this.buckets[i];
                        while (e != null)
                        {
                            var newEntry = new Entry { Key = e.Key, Value = e.Value, Hash = e.Hash };
                            this.AddToBuckets(nextBucket, key, newEntry, null, out resultingValue);
                            e = e.Next;
                        }
                    }

                    // add entry(if failed to add, only do resize)
                    var successAdd = this.AddToBuckets(nextBucket, key, null, valueFactory, out resultingValue);

                    // replace field(threadsafe for read)
                    VolatileWrite(ref this.buckets, nextBucket);

                    if (successAdd)
                    {
                        this.size++;
                    }

                    return successAdd;
                }
                else
                {
                    // add entry(insert last is thread safe for read)
                    var successAdd = this.AddToBuckets(this.buckets, key, null, valueFactory, out resultingValue);
                    if (successAdd)
                    {
                        this.size++;
                    }

                    return successAdd;
                }
            }
        }

        private bool AddToBuckets(Entry[] buckets, TKey1 newKey, Entry newEntryOrNull, Func<TKey1, TValue> valueFactory, out TValue resultingValue)
        {
            var h = (newEntryOrNull != null) ? newEntryOrNull.Hash : this.comparer.GetHashCode(newKey);
            if (buckets[h & (buckets.Length - 1)] == null)
            {
                if (newEntryOrNull != null)
                {
                    resultingValue = newEntryOrNull.Value;
                    VolatileWrite(ref buckets[h & (buckets.Length - 1)], newEntryOrNull);
                }
                else
                {
                    resultingValue = valueFactory(newKey);
                    VolatileWrite(ref buckets[h & (buckets.Length - 1)], new Entry { Key = newKey, Value = resultingValue, Hash = h });
                }
            }
            else
            {
                Entry searchLastEntry = buckets[h & (buckets.Length - 1)];
                while (true)
                {
                    if (this.comparer.Equals(searchLastEntry.Key, newKey))
                    {
                        resultingValue = searchLastEntry.Value;
                        return false;
                    }

                    if (searchLastEntry.Next == null)
                    {
                        if (newEntryOrNull != null)
                        {
                            resultingValue = newEntryOrNull.Value;
                            VolatileWrite(ref searchLastEntry.Next, newEntryOrNull);
                        }
                        else
                        {
                            resultingValue = valueFactory(newKey);
                            VolatileWrite(ref searchLastEntry.Next, new Entry { Key = newKey, Value = resultingValue, Hash = h });
                        }

                        break;
                    }

                    searchLastEntry = searchLastEntry.Next;
                }
            }

            return true;
        }

        public bool TryGetValue(TKey2 key, out TValue value)
        {
            Entry[] table = this.buckets;
            var hash = this.comparer.GetHashCode(key);
            Entry entry = table[hash & table.Length - 1];

            if (entry == null)
            {
                goto NOT_FOUND;
            }

            if (this.comparer.Equals(entry.Key, key))
            {
                value = entry.Value;
                return true;
            }

            Entry next = entry.Next;
            while (next != null)
            {
                if (this.comparer.Equals(next.Key, key))
                {
                    value = next.Value;
                    return true;
                }

                next = next.Next;
            }

NOT_FOUND:
            value = default(TValue);
            return false;
        }

        private static int CalculateCapacity(int collectionSize, float loadFactor)
        {
            var initialCapacity = (int)(((float)collectionSize) / loadFactor);
            var capacity = 1;
            while (capacity < initialCapacity)
            {
                capacity <<= 1;
            }

            if (capacity < 8)
            {
                return 8;
            }

            return capacity;
        }

        private static void VolatileWrite(ref Entry location, Entry value)
        {
            System.Threading.Volatile.Write(ref location, value);
        }

        private static void VolatileWrite(ref Entry[] location, Entry[] value)
        {
            System.Threading.Volatile.Write(ref location, value);
        }

        private class Entry
        {
#pragma warning disable SA1401 // Fields should be private
            internal TKey1 Key;
            internal TValue Value;
            internal int Hash;
            internal Entry Next;
#pragma warning restore SA1401 // Fields should be private

            // from debugger only
            public override string ToString()
            {
                return "Count:" + this.Count;
            }

            internal int Count
            {
                get
                {
                    var count = 1;
                    Entry n = this;
                    while (n.Next != null)
                    {
                        count++;
                        n = n.Next;
                    }

                    return count;
                }
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/AsymmetricKeyHashTable.cs.meta
================================================
fileFormatVersion: 2
guid: fe3bf5c42bc27c1429b9e8bd1839b8e0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/AutomataDictionary.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

#pragma warning disable SA1509 // Opening braces should not be preceded by blank line

namespace MessagePack.Internal
{
    // Key = long, Value = int for UTF8String Dictionary

    /// <remarks>
    /// This code is used by dynamically generated code as well as AOT generated code,
    /// and thus must be public for the "C# generated and compiled into saved assembly" scenario.
    /// </remarks>
    public class AutomataDictionary : IEnumerable<KeyValuePair<string, int>>
    {
        private readonly AutomataNode root;

        public AutomataDictionary()
        {
            this.root = new AutomataNode(0);
        }

        public void Add(string str, int value)
        {
            ReadOnlySpan<byte> bytes = Encoding.UTF8.GetBytes(str);
            AutomataNode node = this.root;

            while (bytes.Length > 0)
            {
                var key = AutomataKeyGen.GetKey(ref bytes);

                if (bytes.Length == 0)
                {
                    node = node.Add(key, value, str);
                }
                else
                {
                    node = node.Add(key);
                }
            }
        }

        public bool TryGetValue(in ReadOnlySequence<byte> bytes, out int value) => this.TryGetValue(bytes.ToArray(), out value);

        public bool TryGetValue(ReadOnlySpan<byte> bytes, out int value)
        {
            AutomataNode node = this.root;

            while (bytes.Length > 0 && node != null)
            {
                node = node.SearchNext(ref bytes);
            }

            if (node == null)
            {
                value = -1;
                return false;
            }
            else
            {
                value = node.Value;
                return true;
            }
        }

        // for debugging
        public override string ToString()
        {
            var sb = new StringBuilder();
            ToStringCore(this.root.YieldChildren(), sb, 0);
            return sb.ToString();
        }

        private static void ToStringCore(IEnumerable<AutomataNode> nexts, StringBuilder sb, int depth)
        {
            foreach (AutomataNode item in nexts)
            {
                if (depth != 0)
                {
                    sb.Append(' ', depth * 2);
                }

                sb.Append("[" + item.Key + "]");
                if (item.Value != -1)
                {
                    sb.Append("(" + item.OriginalKey + ")");
                    sb.Append(" = ");
                    sb.Append(item.Value);
                }

                sb.AppendLine();
                ToStringCore(item.YieldChildren(), sb, depth + 1);
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        public IEnumerator<KeyValuePair<string, int>> GetEnumerator()
        {
            return YieldCore(this.root.YieldChildren()).GetEnumerator();
        }

        private static IEnumerable<KeyValuePair<string, int>> YieldCore(IEnumerable<AutomataNode> nexts)
        {
            foreach (AutomataNode item in nexts)
            {
                if (item.Value != -1)
                {
                    yield return new KeyValuePair<string, int>(item.OriginalKey, item.Value);
                }

                foreach (KeyValuePair<string, int> x in YieldCore(item.YieldChildren()))
                {
                    yield return x;
                }
            }
        }

        /* IL Emit */

#if !NET_STANDARD_2_0

        public void EmitMatch(ILGenerator il, LocalBuilder bytesSpan, LocalBuilder key, Action<KeyValuePair<string, int>> onFound, Action onNotFound)
        {
            this.root.EmitSearchNext(il, bytesSpan, key, onFound, onNotFound);
        }

#endif

        private class AutomataNode : IComparable<AutomataNode>
        {
#pragma warning disable SA1401 // Fields should be private
            internal ulong Key;
            internal int Value;
            internal string OriginalKey;
#pragma warning restore SA1401 // Fields should be private

            private AutomataNode[] nexts;
            private ulong[] nextKeys;
            private int count;

            public bool HasChildren
            {
                get { return this.count != 0; }
            }

            public AutomataNode(ulong key)
            {
                this.Key = key;
                this.Value = -1;
                this.nexts = Array.Empty<AutomataNode>();
                this.nextKeys = Array.Empty<ulong>();
                this.count = 0;
                this.OriginalKey = null;
            }

            public AutomataNode Add(ulong key)
            {
                var index = Array.BinarySearch(this.nextKeys, 0, this.count, key);
                if (index < 0)
                {
                    if (this.nexts.Length == this.count)
                    {
                        Array.Resize<AutomataNode>(ref this.nexts, (this.count == 0) ? 4 : (this.count * 2));
                        Array.Resize<ulong>(ref this.nextKeys, (this.count == 0) ? 4 : (this.count * 2));
                    }

                    this.count++;

                    var nextNode = new AutomataNode(key);
                    this.nexts[this.count - 1] = nextNode;
                    this.nextKeys[this.count - 1] = key;
                    Array.Sort(this.nexts, 0, this.count);
                    Array.Sort(this.nextKeys, 0, this.count);
                    return nextNode;
                }
                else
                {
                    return this.nexts[index];
                }
            }

            public AutomataNode Add(ulong key, int value, string originalKey)
            {
                AutomataNode v = this.Add(key);
                v.Value = value;
                v.OriginalKey = originalKey;
                return v;
            }

            public AutomataNode SearchNext(ref ReadOnlySpan<byte> value)
            {
                var key = AutomataKeyGen.GetKey(ref value);
                if (this.count < 4)
                {
                    // linear search
                    for (int i = 0; i < this.count; i++)
                    {
                        if (this.nextKeys[i] == key)
                        {
                            return this.nexts[i];
                        }
                    }
                }
                else
                {
                    // binary search
                    var index = BinarySearch(this.nextKeys, 0, this.count, key);
                    if (index >= 0)
                    {
                        return this.nexts[index];
                    }
                }

                return null;
            }

            internal static int BinarySearch(ulong[] array, int index, int length, ulong value)
            {
                int lo = index;
                int hi = index + length - 1;
                while (lo <= hi)
                {
                    int i = lo + ((hi - lo) >> 1);

                    var arrayValue = array[i];
                    int order;
                    if (arrayValue < value)
                    {
                        order = -1;
                    }
                    else if (arrayValue > value)
                    {
                        order = 1;
                    }
                    else
                    {
                        order = 0;
                    }

                    if (order == 0)
                    {
                        return i;
                    }

                    if (order < 0)
                    {
                        lo = i + 1;
                    }
                    else
                    {
                        hi = i - 1;
                    }
                }

                return ~lo;
            }

            public int CompareTo(AutomataNode other)
            {
                return this.Key.CompareTo(other.Key);
            }

            public IEnumerable<AutomataNode> YieldChildren()
            {
                for (int i = 0; i < this.count; i++)
                {
                    yield return this.nexts[i];
                }
            }

#if !NET_STANDARD_2_0

            // SearchNext(ref ReadOnlySpan<byte> bytes)
            public void EmitSearchNext(ILGenerator il, LocalBuilder bytesSpan, LocalBuilder key, Action<KeyValuePair<string, int>> onFound, Action onNotFound)
            {
                // key = AutomataKeyGen.GetKey(ref bytesSpan);
                il.EmitLdloca(bytesSpan);
                il.EmitCall(AutomataKeyGen.GetKeyMethod);
                il.EmitStloc(key);

                // match children.
                EmitSearchNextCore(il, bytesSpan, key, onFound, onNotFound, this.nexts, this.count);
            }

            private static void EmitSearchNextCore(ILGenerator il, LocalBuilder bytesSpan, LocalBuilder key, Action<KeyValuePair<string, int>> onFound, Action onNotFound, AutomataNode[] nexts, int count)
            {
                if (count < 4)
                {
                    // linear-search
                    AutomataNode[] valueExists = nexts.Take(count).Where(x => x.Value != -1).ToArray();
                    AutomataNode[] childrenExists = nexts.Take(count).Where(x => x.HasChildren).ToArray();
                    Label gotoSearchNext = il.DefineLabel();
                    Label gotoNotFound = il.DefineLabel();

                    {
                              // bytesSpan.Length
                        il.EmitLdloca(bytesSpan);
                        il.EmitCall(typeof(ReadOnlySpan<byte>).GetRuntimeProperty(nameof(ReadOnlySpan<byte>.Length)).GetMethod);
                        if (childrenExists.Length != 0 && valueExists.Length == 0)
                        {
                            il.Emit(OpCodes.Brfalse, gotoNotFound); // if(bytesSpan.Length == 0)
                        }
                        else
                        {
                            il.Emit(OpCodes.Brtrue, gotoSearchNext); // if(bytesSpan.Length != 0)
                        }
                    }

                    {
                        Label[] ifValueNexts = Enumerable.Range(0, Math.Max(valueExists.Length - 1, 0)).Select(_ => il.DefineLabel()).ToArray();
                        for (int i = 0; i < valueExists.Length; i++)
                        {
                            Label notFoundLabel = il.DefineLabel();
                            if (i != 0)
                            {
                                il.MarkLabel(ifValueNexts[i - 1]);
                            }

                            il.EmitLdloc(key);
                            il.EmitULong(valueExists[i].Key);
                            il.Emit(OpCodes.Bne_Un, notFoundLabel);

                            // found
                            onFound(new KeyValuePair<string, int>(valueExists[i].OriginalKey, valueExists[i].Value));

                            // notfound
                            il.MarkLabel(notFoundLabel);
                            if (i != valueExists.Length - 1)
                            {
                                il.Emit(OpCodes.Br, ifValueNexts[i]);
                            }
                            else
                            {
                                onNotFound();
                            }
                        }
                    }

                    il.MarkLabel(gotoSearchNext);
                    Label[] ifRecNext = Enumerable.Range(0, Math.Max(childrenExists.Length - 1, 0)).Select(_ => il.DefineLabel()).ToArray();
                    for (int i = 0; i < childrenExists.Length; i++)
                    {
                        Label notFoundLabel = il.DefineLabel();
                        if (i != 0)
                        {
                            il.MarkLabel(ifRecNext[i - 1]);
                        }

                        il.EmitLdloc(key);
                        il.EmitULong(childrenExists[i].Key);
                        il.Emit(OpCodes.Bne_Un, notFoundLabel);

                        // found
                        childrenExists[i].EmitSearchNext(il, bytesSpan, key, onFound, onNotFound);

                        // notfound
                        il.MarkLabel(notFoundLabel);
                        if (i != childrenExists.Length - 1)
                        {
                            il.Emit(OpCodes.Br, ifRecNext[i]);
                        }
                        else
                        {
                            onNotFound();
                        }
                    }

                    il.MarkLabel(gotoNotFound);
                    onNotFound();
                }
                else
                {
                    // binary-search
                    var midline = count / 2;
                    var mid = nexts[midline].Key;
                    AutomataNode[] l = nexts.Take(count).Take(midline).ToArray();
                    AutomataNode[] r = nexts.Take(count).Skip(midline).ToArray();

                    Label gotoRight = il.DefineLabel();

                    // if(key < mid)
                    il.EmitLdloc(key);
                    il.EmitULong(mid);
                    il.Emit(OpCodes.Bge_Un, gotoRight);
                    EmitSearchNextCore(il, bytesSpan, key, onFound, onNotFound, l, l.Length);

                    // else
                    il.MarkLabel(gotoRight);
                    EmitSearchNextCore(il, bytesSpan, key, onFound, onNotFound, r, r.Length);
                }
            }

#endif
        }
    }

    /// <remarks>
    /// This is used by dynamically generated code. It can be made internal after we enable our dynamic assemblies to access internals.
    /// But that trick may require net46, so maybe we should leave this as public.
    /// </remarks>
    public static class AutomataKeyGen
    {
        public static readonly MethodInfo GetKeyMethod = typeof(AutomataKeyGen).GetRuntimeMethod(nameof(GetKey), new[] { typeof(ReadOnlySpan<byte>).MakeByRefType() });

        public static ulong GetKey(ref ReadOnlySpan<byte> span)
        {
            ulong key;

            unchecked
            {
                if (span.Length >= 8)
                {
                    key = SafeBitConverter.ToUInt64(span);
                    span = span.Slice(8);
                }
                else
                {
                    switch (span.Length)
                    {
                        case 1:
                            {
                                key = span[0];
                                span = span.Slice(1);
                                break;
                            }

                        case 2:
                            {
                                key = SafeBitConverter.ToUInt16(span);
                                span = span.Slice(2);
                                break;
                            }

                        case 3:
                            {
                                var a = span[0];
                                var b = SafeBitConverter.ToUInt16(span.Slice(1));
                                key = a | (ulong)b << 8;
                                span = span.Slice(3);
                                break;
                            }

                        case 4:
                            {
                                key = SafeBitConverter.ToUInt32(span);
                                span = span.Slice(4);
                                break;
                            }

                        case 5:
                            {
                                var a = span[0];
                                var b = SafeBitConverter.ToUInt32(span.Slice(1));
                                key = a | (ulong)b << 8;
                                span = span.Slice(5);
                                break;
                            }

                        case 6:
                            {
                                ulong a = SafeBitConverter.ToUInt16(span);
                                ulong b = SafeBitConverter.ToUInt32(span.Slice(2));
                                key = a | (b << 16);
                                span = span.Slice(6);
                                break;
                            }

                        case 7:
                            {
                                var a = span[0];
                                var b = SafeBitConverter.ToUInt16(span.Slice(1));
                                var c = SafeBitConverter.ToUInt32(span.Slice(3));
                                key = a | (ulong)b << 8 | (ulong)c << 24;
                                span = span.Slice(7);
                                break;
                            }

                        default:
                            throw new MessagePackSerializationException("Not Supported Length");
                    }
                }

                return key;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/AutomataDictionary.cs.meta
================================================
fileFormatVersion: 2
guid: 14776842f04657842b044268a62cf6b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ByteArrayStringHashTable.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace MessagePack.Internal
{
    // like ArraySegment<byte> hashtable.
    // Add is safe for construction phase only and requires capacity(does not do rehash)
    // and specialized for internal use(nongenerics, TValue is int)

    // internal, but code generator requires this class
    // or at least PerfBenchmarkDotNet
    public class ByteArrayStringHashTable : IEnumerable<KeyValuePair<string, int>>
    {
        private readonly Entry[][] buckets; // immutable array(faster than linkedlist)
        private readonly ulong indexFor;

        public ByteArrayStringHashTable(int capacity)
            : this(capacity, 0.42f) // default: 0.75f -> 0.42f
        {
        }

        public ByteArrayStringHashTable(int capacity, float loadFactor)
        {
            var tableSize = CalculateCapacity(capacity, loadFactor);
            this.buckets = new Entry[tableSize][];
            this.indexFor = (ulong)this.buckets.Length - 1;
        }

        public void Add(string key, int value)
        {
            if (!this.TryAddInternal(Encoding.UTF8.GetBytes(key), value))
            {
                throw new ArgumentException("Key was already exists. Key:" + key);
            }
        }

        public void Add(byte[] key, int value)
        {
            if (!this.TryAddInternal(key, value))
            {
                throw new ArgumentException("Key was already exists. Key:" + key);
            }
        }

        private bool TryAddInternal(byte[] key, int value)
        {
            var h = ByteArrayGetHashCode(key);
            var entry = new Entry { Key = key, Value = value };

            Entry[] array = this.buckets[h & this.indexFor];
            if (array == null)
            {
                this.buckets[h & this.indexFor] = new[] { entry };
            }
            else
            {
                // check duplicate
                for (int i = 0; i < array.Length; i++)
                {
                    byte[] e = array[i].Key;
                    if (key.AsSpan().SequenceEqual(e))
                    {
                        return false;
                    }
                }

                var newArray = new Entry[array.Length + 1];
                Array.Copy(array, newArray, array.Length);
                array = newArray;
                array[array.Length - 1] = entry;
                this.buckets[h & this.indexFor] = array;
            }

            return true;
        }

        public bool TryGetValue(in ReadOnlySequence<byte> key, out int value) => this.TryGetValue(CodeGenHelpers.GetSpanFromSequence(key), out value);

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public bool TryGetValue(ReadOnlySpan<byte> key, out int value)
        {
            Entry[][] table = this.buckets;
            var hash = ByteArrayGetHashCode(key);
            Entry[] entry = table[hash & this.indexFor];

            if (entry == null)
            {
                value = default(int);
                return false;
            }

            ref Entry v = ref entry[0];
            if (key.SequenceEqual(v.Key))
            {
                value = v.Value;
                return true;
            }

            return TryGetValueSlow(key, entry, out value);
        }

        private bool TryGetValueSlow(ReadOnlySpan<byte> key, Entry[] entry, out int value)
        {
            for (int i = 1; i < entry.Length; i++)
            {
                ref Entry v = ref entry[i];
                if (key.SequenceEqual(v.Key))
                {
                    value = v.Value;
                    return true;
                }
            }

            value = default(int);
            return false;
        }

        private static readonly bool Is32Bit = IntPtr.Size == 4;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static ulong ByteArrayGetHashCode(ReadOnlySpan<byte> x)
        {
            // FarmHash https://github.com/google/farmhash
            if (Is32Bit)
            {
                return (ulong)FarmHash.Hash32(x);
            }
            else
            {
                return FarmHash.Hash64(x);
            }
        }

        private static int CalculateCapacity(int collectionSize, float loadFactor)
        {
            var initialCapacity = (int)(((float)collectionSize) / loadFactor);
            var capacity = 1;
            while (capacity < initialCapacity)
            {
                capacity <<= 1;
            }

            if (capacity < 8)
            {
                return 8;
            }

            return capacity;
        }

        // only for Debug use
        public IEnumerator<KeyValuePair<string, int>> GetEnumerator()
        {
            Entry[][] b = this.buckets;

            foreach (Entry[] item in b)
            {
                if (item == null)
                {
                    continue;
                }

                foreach (Entry item2 in item)
                {
                    yield return new KeyValuePair<string, int>(Encoding.UTF8.GetString(item2.Key), item2.Value);
                }
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        private struct Entry
        {
            public byte[] Key;
            public int Value;

            // for debugging
            public override string ToString()
            {
                return "(" + Encoding.UTF8.GetString(this.Key) + ", " + this.Value + ")";
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ByteArrayStringHashTable.cs.meta
================================================
fileFormatVersion: 2
guid: 4df68ce4d7981d244b9a6e7991ef717d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/CodeGenHelpers.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.ComponentModel;

namespace MessagePack.Internal
{
    /// <summary>
    /// Helpers for generated code.
    /// </summary>
    /// <remarks>
    /// This code is used by dynamically generated code as well as AOT generated code,
    /// and thus must be public for the "C# generated and compiled into saved assembly" scenario.
    /// </remarks>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static class CodeGenHelpers
    {
        /// <summary>
        /// Gets the messagepack encoding for a given string.
        /// </summary>
        /// <param name="value">The string to encode.</param>
        /// <returns>The messagepack encoding for <paramref name="value"/>, including messagepack header and UTF-8 bytes.</returns>
        public static byte[] GetEncodedStringBytes(string value)
        {
            var byteCount = StringEncoding.UTF8.GetByteCount(value);
            if (byteCount <= MessagePackRange.MaxFixStringLength)
            {
                var bytes = new byte[byteCount + 1];
                bytes[0] = (byte)(MessagePackCode.MinFixStr | byteCount);
                StringEncoding.UTF8.GetBytes(value, 0, value.Length, bytes, 1);
                return bytes;
            }
            else if (byteCount <= byte.MaxValue)
            {
                var bytes = new byte[byteCount + 2];
                bytes[0] = MessagePackCode.Str8;
                bytes[1] = unchecked((byte)byteCount);
                StringEncoding.UTF8.GetBytes(value, 0, value.Length, bytes, 2);
                return bytes;
            }
            else if (byteCount <= ushort.MaxValue)
            {
                var bytes = new byte[byteCount + 3];
                bytes[0] = MessagePackCode.Str16;
                bytes[1] = unchecked((byte)(byteCount >> 8));
                bytes[2] = unchecked((byte)byteCount);
                StringEncoding.UTF8.GetBytes(value, 0, value.Length, bytes, 3);
                return bytes;
            }
            else
            {
                var bytes = new byte[byteCount + 5];
                bytes[0] = MessagePackCode.Str32;
                bytes[1] = unchecked((byte)(byteCount >> 24));
                bytes[2] = unchecked((byte)(byteCount >> 16));
                bytes[3] = unchecked((byte)(byteCount >> 8));
                bytes[4] = unchecked((byte)byteCount);
                StringEncoding.UTF8.GetBytes(value, 0, value.Length, bytes, 5);
                return bytes;
            }
        }

        /// <summary>
        /// Gets a single <see cref="ReadOnlySpan{T}"/> containing all bytes in a given <see cref="ReadOnlySequence{T}"/>.
        /// An array may be allocated if the bytes are not already contiguous in memory.
        /// </summary>
        /// <param name="sequence">The sequence to get a span for.</param>
        /// <returns>The span.</returns>
        public static ReadOnlySpan<byte> GetSpanFromSequence(in ReadOnlySequence<byte> sequence)
        {
            if (sequence.IsSingleSegment)
            {
                return sequence.First.Span;
            }

            return sequence.ToArray();
        }

        /// <summary>
        /// Reads a string as a contiguous span of UTF-8 encoded characters.
        /// An array may be allocated if the string is not already contiguous in memory.
        /// </summary>
        /// <param name="reader">The reader to use.</param>
        /// <returns>The span of UTF-8 encoded characters.</returns>
        public static ReadOnlySpan<byte> ReadStringSpan(ref MessagePackReader reader)
        {
            if (!reader.TryReadStringSpan(out ReadOnlySpan<byte> result))
            {
                return GetSpanFromSequence(reader.ReadStringSequence());
            }

            return result;
        }

        /// <summary>
        /// Creates a <see cref="byte"/> array for a given sequence, or <see langword="null" /> if the optional sequence is itself <see langword="null" />.
        /// </summary>
        /// <param name="sequence">The sequence.</param>
        /// <returns>The byte array or <see langword="null" /> .</returns>
        public static byte[] GetArrayFromNullableSequence(in ReadOnlySequence<byte>? sequence) => sequence?.ToArray();

        private static ReadOnlySpan<byte> GetSpanFromSequence(in ReadOnlySequence<byte>? sequence)
        {
            return sequence.HasValue ? GetSpanFromSequence(sequence.Value) : default;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/CodeGenHelpers.cs.meta
================================================
fileFormatVersion: 2
guid: e733605ab88010a4686b39fea27fe38b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/DateTimeConstants.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

namespace MessagePack.Internal
{
    internal static class DateTimeConstants
    {
        internal const long BclSecondsAtUnixEpoch = 62135596800;
        internal const int NanosecondsPerTick = 100;
        internal static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/DateTimeConstants.cs.meta
================================================
fileFormatVersion: 2
guid: 4b25d1986c9838643ac125bc06eac98c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/DynamicAssembly.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !(UNITY_2018_3_OR_NEWER && NET_STANDARD_2_0)

using System;
using System.Reflection;
using System.Reflection.Emit;

namespace MessagePack.Internal
{
    internal class DynamicAssembly
    {
#if NETFRAMEWORK // We don't ship a net472 target, but we might add one for debugging purposes
        private readonly string moduleName;
#endif
        private readonly AssemblyBuilder assemblyBuilder;
        private readonly ModuleBuilder moduleBuilder;

        // don't expose ModuleBuilder
        //// public ModuleBuilder ModuleBuilder { get { return moduleBuilder; } }

        public DynamicAssembly(string moduleName)
        {
#if NETFRAMEWORK // We don't ship a net472 target, but we might add one for debugging purposes
            AssemblyBuilderAccess builderAccess = AssemblyBuilderAccess.RunAndSave;
            this.moduleName = moduleName;
#else
            AssemblyBuilderAccess builderAccess = AssemblyBuilderAccess.Run;
#endif
            this.assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(moduleName), builderAccess);
            this.moduleBuilder = this.assemblyBuilder.DefineDynamicModule(moduleName + ".dll");
        }

        /* requires lock on mono environment. see: https://github.com/neuecc/MessagePack-CSharp/issues/161 */

        public TypeBuilder DefineType(string name, TypeAttributes attr) => this.moduleBuilder.DefineType(name, attr);

        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent) => this.moduleBuilder.DefineType(name, attr, parent);

        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces) => this.moduleBuilder.DefineType(name, attr, parent, interfaces);

#if NETFRAMEWORK

        public AssemblyBuilder Save()
        {
            this.assemblyBuilder.Save(this.moduleName + ".dll");
            return this.assemblyBuilder;
        }

#endif
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/DynamicAssembly.cs.meta
================================================
fileFormatVersion: 2
guid: 9c3c62d8dc2404b43b89833c076e73ef
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ExpressionUtility.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Linq.Expressions;
using System.Reflection;

namespace MessagePack.Internal
{
    internal static class ExpressionUtility
    {
        private static MethodInfo GetMethodInfoCore(LambdaExpression expression)
        {
            if (expression == null)
            {
                throw new ArgumentNullException("expression");
            }

            return (expression.Body as MethodCallExpression).Method;
        }

        /// <summary>
        /// Get MethodInfo from Expression for Static(with result) method.
        /// </summary>
        public static MethodInfo GetMethodInfo<T>(Expression<Func<T>> expression)
        {
            return GetMethodInfoCore(expression);
        }

        /// <summary>
        /// Get MethodInfo from Expression for Static(void) method.
        /// </summary>
        public static MethodInfo GetMethodInfo(Expression<Action> expression)
        {
            return GetMethodInfoCore(expression);
        }

        /// <summary>
        /// Get MethodInfo from Expression for Instance(with result) method.
        /// </summary>
        public static MethodInfo GetMethodInfo<T, TR>(Expression<Func<T, TR>> expression)
        {
            return GetMethodInfoCore(expression);
        }

        /// <summary>
        /// Get MethodInfo from Expression for Instance(void) method.
        /// </summary>
        public static MethodInfo GetMethodInfo<T>(Expression<Action<T>> expression)
        {
            return GetMethodInfoCore(expression);
        }

        // WithArgument(for ref, out) helper

        /// <summary>
        /// Get MethodInfo from Expression for Instance(with result) method.
        /// </summary>
        public static MethodInfo GetMethodInfo<T, TArg1, TR>(Expression<Func<T, TArg1, TR>> expression)
        {
            return GetMethodInfoCore(expression);
        }

        private static MemberInfo GetMemberInfoCore<T>(Expression<T> source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            var memberExpression = source.Body as MemberExpression;
            return memberExpression.Member;
        }

        public static PropertyInfo GetPropertyInfo<T, TR>(Expression<Func<T, TR>> expression)
        {
            return GetMemberInfoCore(expression) as PropertyInfo;
        }

        public static FieldInfo GetFieldInfo<T, TR>(Expression<Func<T, TR>> expression)
        {
            return GetMemberInfoCore(expression) as FieldInfo;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ExpressionUtility.cs.meta
================================================
fileFormatVersion: 2
guid: 79cc2e793fd7f1047b6c6e9718b59912
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/FarmHash.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.CompilerServices;

#pragma warning disable SA1300 // Element should begin with uppercase letter
#pragma warning disable SA1303 // Const field names should begin with uppercase letter
#pragma warning disable SA1307 // (public) field names should begin with uppercase letter

namespace MessagePack.Internal
{
    internal static class FarmHash
    {
        #region Hash32

        // entry point of 32bit
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe uint Hash32(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length <= 4)
            {
                return Hash32Len0to4(bytes);
            }

            fixed (byte* p = bytes)
            {
                return Hash32(p, (uint)bytes.Length);
            }
        }

        // port of farmhash.cc, 32bit only

        // Magic numbers for 32-bit hashing.  Copied from Murmur3.
        private const uint c1 = 0xcc9e2d51;
        private const uint c2 = 0x1b873593;

        private static unsafe uint Fetch32(byte* p)
        {
            return *(uint*)p;
        }

        private static uint Rotate32(uint val, int shift)
        {
            return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
        }

        // A 32-bit to 32-bit integer hash copied from Murmur3.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint fmix(uint h)
        {
            unchecked
            {
                h ^= h >> 16;
                h *= 0x85ebca6b;
                h ^= h >> 13;
                h *= 0xc2b2ae35;
                h ^= h >> 16;
                return h;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static uint Mur(uint a, uint h)
        {
            unchecked
            {
                // Helper from Murmur3 for combining two 32-bit values.
                a *= c1;
                a = Rotate32(a, 17);
                a *= c2;
                h ^= a;
                h = Rotate32(h, 19);
                return (h * 5) + 0xe6546b64;
            }
        }

        // 0-4
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint Hash32Len0to4(ReadOnlySpan<byte> s)
        {
            unchecked
            {
                uint b = 0;
                uint c = 9;
                for (int i = 0; i < s.Length; i++)
                {
                    b = (b * c1) + s[i];
                    c ^= b;
                }

                return fmix(Mur(b, Mur((uint)s.Length, c)));
            }
        }

        // 5-12
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint Hash32Len5to12(byte* s, uint len)
        {
            unchecked
            {
                uint a = len, b = len * 5, c = 9, d = b;
                a += Fetch32(s);
                b += Fetch32(s + len - 4);
                c += Fetch32(s + ((len >> 1) & 4));
                return fmix(Mur(c, Mur(b, Mur(a, d))));
            }
        }

        // 13-24
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint Hash32Len13to24(byte* s, uint len)
        {
            unchecked
            {
                uint a = Fetch32(s - 4 + (len >> 1));
                uint b = Fetch32(s + 4);
                uint c = Fetch32(s + len - 8);
                uint d = Fetch32(s + (len >> 1));
                uint e = Fetch32(s);
                uint f = Fetch32(s + len - 4);
                uint h = (d * c1) + len;
                a = Rotate32(a, 12) + f;
                h = Mur(c, h) + a;
                a = Rotate32(a, 3) + c;
                h = Mur(e, h) + a;
                a = Rotate32(a + f, 12) + d;
                h = Mur(b, h) + a;
                return fmix(h);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint Hash32(byte* s, uint len)
        {
            if (len <= 24)
            {
                return len <= 12 ? Hash32Len5to12(s, len) : Hash32Len13to24(s, len);
            }

            unchecked
            {
                // len > 24
                uint h = len, g = c1 * len, f = g;
                uint a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
                uint a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
                uint a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
                uint a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
                uint a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
                h ^= a0;
                h = Rotate32(h, 19);
                h = (h * 5) + 0xe6546b64;
                h ^= a2;
                h = Rotate32(h, 19);
                h = (h * 5) + 0xe6546b64;
                g ^= a1;
                g = Rotate32(g, 19);
                g = (g * 5) + 0xe6546b64;
                g ^= a3;
                g = Rotate32(g, 19);
                g = (g * 5) + 0xe6546b64;
                f += a4;
                f = Rotate32(f, 19) + 113;
                uint iters = (len - 1) / 20;
                do
                {
                    uint a = Fetch32(s);
                    uint b = Fetch32(s + 4);
                    uint c = Fetch32(s + 8);
                    uint d = Fetch32(s + 12);
                    uint e = Fetch32(s + 16);
                    h += a;
                    g += b;
                    f += c;
                    h = Mur(d, h) + e;
                    g = Mur(c, g) + a;
                    f = Mur(b + (e * c1), f) + d;
                    f += g;
                    g += f;
                    s += 20;
                }
                while (--iters != 0);
                g = Rotate32(g, 11) * c1;
                g = Rotate32(g, 17) * c1;
                f = Rotate32(f, 11) * c1;
                f = Rotate32(f, 17) * c1;
                h = Rotate32(h + g, 19);
                h = (h * 5) + 0xe6546b64;
                h = Rotate32(h, 17) * c1;
                h = Rotate32(h + f, 19);
                h = (h * 5) + 0xe6546b64;
                h = Rotate32(h, 17) * c1;
                return h;
            }
        }

        #endregion

        #region hash64

        // entry point
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe ulong Hash64(ReadOnlySpan<byte> bytes)
        {
            fixed (byte* p = bytes)
            {
                return Hash64(p, (uint)bytes.Length);
            }
        }

        /* port from farmhash.cc */

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void swap(ref ulong x, ref ulong z)
        {
            var temp = z;
            z = x;
            x = temp;
        }

        // Some primes between 2^63 and 2^64 for various uses.
        private const ulong k0 = 0xc3a5c85c97cb3127UL;
        private const ulong k1 = 0xb492b66fbe98f273UL;
        private const ulong k2 = 0x9ae16a3b2f90404fUL;

        private static unsafe ulong Fetch64(byte* p)
        {
            return *(ulong*)p;
        }

        private static ulong Rotate64(ulong val, int shift)
        {
            return shift == 0 ? val : (val >> shift) | (val << (64 - shift));
        }

        // farmhashna.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong ShiftMix(ulong val)
        {
            return val ^ (val >> 47);
        }

        // farmhashna.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong HashLen16(ulong u, ulong v, ulong mul)
        {
            unchecked
            {
                // Murmur-inspired hashing.
                ulong a = (u ^ v) * mul;
                a ^= a >> 47;
                ulong b = (v ^ a) * mul;
                b ^= b >> 47;
                b *= mul;
                return b;
            }
        }

        // farmhashxo.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong Hash64(byte* s, uint len)
        {
            if (len <= 16)
            {
                // farmhashna::
                return HashLen0to16(s, len);
            }

            if (len <= 32)
            {
                // farmhashna::
                return HashLen17to32(s, len);
            }

            if (len <= 64)
            {
                return HashLen33to64(s, len);
            }

            if (len <= 96)
            {
                return HashLen65to96(s, len);
            }

            if (len <= 256)
            {
                // farmhashna::
                return Hash64NA(s, len);
            }

            // farmhashuo::
            return Hash64UO(s, len);
        }

        // 0-16 farmhashna.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong HashLen0to16(byte* s, uint len)
        {
            unchecked
            {
                if (len >= 8)
                {
                    ulong mul = k2 + (len * 2);
                    ulong a = Fetch64(s) + k2;
                    ulong b = Fetch64(s + len - 8);
                    ulong c = (Rotate64(b, 37) * mul) + a;
                    ulong d = (Rotate64(a, 25) + b) * mul;
                    return HashLen16(c, d, mul);
                }

                if (len >= 4)
                {
                    ulong mul = k2 + (len * 2);
                    ulong a = Fetch32(s);
                    return HashLen16(len + (a << 3), Fetch32(s + len - 4), mul);
                }

                if (len > 0)
                {
                    ushort a = s[0];
                    ushort b = s[len >> 1];
                    ushort c = s[len - 1];
                    uint y = a + ((uint)b << 8);
                    uint z = len + ((uint)c << 2);
                    return ShiftMix(y * k2 ^ z * k0) * k2;
                }

                return k2;
            }
        }

        // 17-32 farmhashna.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong HashLen17to32(byte* s, uint len)
        {
            unchecked
            {
                ulong mul = k2 + (len * 2);
                ulong a = Fetch64(s) * k1;
                ulong b = Fetch64(s + 8);
                ulong c = Fetch64(s + len - 8) * mul;
                ulong d = Fetch64(s + len - 16) * k2;
                return HashLen16(
                    Rotate64(a + b, 43) + Rotate64(c, 30) + d,
                    a + Rotate64(b + k2, 18) + c,
                    mul);
            }
        }

        // farmhashxo.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong H32(byte* s, uint len, ulong mul, ulong seed0 = 0, ulong seed1 = 0)
        {
            unchecked
            {
                ulong a = Fetch64(s) * k1;
                ulong b = Fetch64(s + 8);
                ulong c = Fetch64(s + len - 8) * mul;
                ulong d = Fetch64(s + len - 16) * k2;
                ulong u = Rotate64(a + b, 43) + Rotate64(c, 30) + d + seed0;
                ulong v = a + Rotate64(b + k2, 18) + c + seed1;
                a = ShiftMix((u ^ v) * mul);
                b = ShiftMix((v ^ a) * mul);
                return b;
            }
        }

        // 33-64 farmhashxo.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong HashLen33to64(byte* s, uint len)
        {
            const ulong mul0 = k2 - 30;

            unchecked
            {
                ulong mul1 = k2 - 30 + (2 * len);
                ulong h0 = H32(s, 32, mul0);
                ulong h1 = H32(s + len - 32, 32, mul1);
                return ((h1 * mul1) + h0) * mul1;
            }
        }

        // 65-96 farmhashxo.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong HashLen65to96(byte* s, uint len)
        {
            const ulong mul0 = k2 - 114;

            unchecked
            {
                ulong mul1 = k2 - 114 + (2 * len);
                ulong h0 = H32(s, 32, mul0);
                ulong h1 = H32(s + 32, 32, mul1);
                ulong h2 = H32(s + len - 32, 32, mul1, h0, h1);
                return ((h2 * 9) + (h0 >> 17) + (h1 >> 21)) * mul1;
            }
        }

        // farmhashna.cc
        // Return a 16-byte hash for 48 bytes.  Quick and dirty.
        // Callers do best to use "random-looking" values for a and b.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void WeakHashLen32WithSeeds(ulong w, ulong x, ulong y, ulong z, ulong a, ulong b, out ulong first, out ulong second)
        {
            unchecked
            {
                a += w;
                b = Rotate64(b + a + z, 21);
                ulong c = a;
                a += x;
                a += y;
                b += Rotate64(a, 44);
                first = a + z;
                second = b + c;
            }
        }

        // farmhashna.cc
        // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void WeakHashLen32WithSeeds(byte* s, ulong a, ulong b, out ulong first, out ulong second)
        {
            WeakHashLen32WithSeeds(
                Fetch64(s),
                Fetch64(s + 8),
                Fetch64(s + 16),
                Fetch64(s + 24),
                a,
                b,
                out first,
                out second);
        }

        // na(97-256) farmhashna.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong Hash64NA(byte* s, uint len)
        {
            const ulong seed = 81;

            unchecked
            {
                // For strings over 64 bytes we loop.  Internal state consists of
                // 56 bytes: v, w, x, y, and z.
                ulong x = seed;
                ulong y = (seed * k1) + 113;
                ulong z = ShiftMix((y * k2) + 113) * k2;
                ulong v_first = 0;
                ulong v_second = 0;
                ulong w_first = 0;
                ulong w_second = 0;
                x = (x * k2) + Fetch64(s);

                // Set end so that after the loop we have 1 to 64 bytes left to process.
                byte* end = s + ((len - 1) / 64 * 64);
                byte* last64 = end + ((len - 1) & 63) - 63;

                do
                {
                    x = Rotate64(x + y + v_first + Fetch64(s + 8), 37) * k1;
                    y = Rotate64(y + v_second + Fetch64(s + 48), 42) * k1;
                    x ^= w_second;
                    y += v_first + Fetch64(s + 40);
                    z = Rotate64(z + w_first, 33) * k1;
                    WeakHashLen32WithSeeds(s, v_second * k1, x + w_first, out v_first, out v_second);
                    WeakHashLen32WithSeeds(s + 32, z + w_second, y + Fetch64(s + 16), out w_first, out w_second);
                    swap(ref z, ref x);
                    s += 64;
                }
                while (s != end);
                ulong mul = k1 + ((z & 0xff) << 1);

                // Make s point to the last 64 bytes of input.
                s = last64;
                w_first += (len - 1) & 63;
                v_first += w_first;
                w_first += v_first;
                x = Rotate64(x + y + v_first + Fetch64(s + 8), 37) * mul;
                y = Rotate64(y + v_second + Fetch64(s + 48), 42) * mul;
                x ^= w_second * 9;
                y += (v_first * 9) + Fetch64(s + 40);
                z = Rotate64(z + w_first, 33) * mul;
                WeakHashLen32WithSeeds(s, v_second * mul, x + w_first, out v_first, out v_second);
                WeakHashLen32WithSeeds(s + 32, z + w_second, y + Fetch64(s + 16), out w_first, out w_second);
                swap(ref z, ref x);
                return HashLen16(HashLen16(v_first, w_first, mul) + (ShiftMix(y) * k0) + z, HashLen16(v_second, w_second, mul) + x, mul);
            }
        }

        // farmhashuo.cc
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong H(ulong x, ulong y, ulong mul, int r)
        {
            unchecked
            {
                ulong a = (x ^ y) * mul;
                a ^= a >> 47;
                ulong b = (y ^ a) * mul;
                return Rotate64(b, r) * mul;
            }
        }

        // uo(257-) farmhashuo.cc, Hash64WithSeeds
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe ulong Hash64UO(byte* s, uint len)
        {
            const ulong seed0 = 81;
            const ulong seed1 = 0;

            unchecked
            {
                // For strings over 64 bytes we loop.  Internal state consists of
                // 64 bytes: u, v, w, x, y, and z.
                ulong x = seed0;
                ulong y = (seed1 * k2) + 113;
                ulong z = ShiftMix(y * k2) * k2;
                ulong v_first = seed0;
                ulong v_second = seed1;
                ulong w_first = 0;
                ulong w_second = 0;
                ulong u = x - z;
                x *= k2;
                ulong mul = k2 + (u & 0x82);

                // Set end so that after the loop we have 1 to 64 bytes left to process.
                byte* end = s + ((len - 1) / 64 * 64);
                byte* last64 = end + ((len - 1) & 63) - 63;

                do
                {
                    ulong a0 = Fetch64(s);
                    ulong a1 = Fetch64(s + 8);
                    ulong a2 = Fetch64(s + 16);
                    ulong a3 = Fetch64(s + 24);
                    ulong a4 = Fetch64(s + 32);
                    ulong a5 = Fetch64(s + 40);
                    ulong a6 = Fetch64(s + 48);
                    ulong a7 = Fetch64(s + 56);
                    x += a0 + a1;
                    y += a2;
                    z += a3;
                    v_first += a4;
                    v_second += a5 + a1;
                    w_first += a6;
                    w_second += a7;

                    x = Rotate64(x, 26);
                    x *= 9;
                    y = Rotate64(y, 29);
                    z *= mul;
                    v_first = Rotate64(v_first, 33);
                    v_second = Rotate64(v_second, 30);
                    w_first ^= x;
                    w_first *= 9;
                    z = Rotate64(z, 32);
                    z += w_second;
                    w_second += z;
                    z *= 9;
                    swap(ref u, ref y);

                    z += a0 + a6;
                    v_first += a2;
                    v_second += a3;
                    w_first += a4;
                    w_second += a5 + a6;
                    x += a1;
                    y += a7;

                    y += v_first;
                    v_first += x - y;
                    v_second += w_first;
                    w_first += v_second;
                    w_second += x - y;
                    x += w_second;
                    w_second = Rotate64(w_second, 34);
                    swap(ref u, ref z);
                    s += 64;
                }
                while (s != end);

                // Make s point to the last 64 bytes of input.
                s = last64;
                u *= 9;
                v_second = Rotate64(v_second, 28);
                v_first = Rotate64(v_first, 20);
                w_first += (len - 1) & 63;
                u += y;
                y += u;
                x = Rotate64(y - x + v_first + Fetch64(s + 8), 37) * mul;
                y = Rotate64(y ^ v_second ^ Fetch64(s + 48), 42) * mul;
                x ^= w_second * 9;
                y += v_first + Fetch64(s + 40);
                z = Rotate64(z + w_first, 33) * mul;
                WeakHashLen32WithSeeds(s, v_second * mul, x + w_first, out v_first, out v_second);
                WeakHashLen32WithSeeds(s + 32, z + w_second, y + Fetch64(s + 16), out w_first, out w_second);
                return H(HashLen16(v_first + x, w_first ^ y, mul) + z - u, H(v_second + y, w_second + z, k2, 30) ^ x, k2, 31);
            }
        }

        #endregion
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/FarmHash.cs.meta
================================================
fileFormatVersion: 2
guid: 97eed140914d52943ad6955224ce4577
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/GuidBits.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.InteropServices;

namespace MessagePack.Internal
{
    [StructLayout(LayoutKind.Explicit, Pack = 1)]
    internal struct GuidBits
    {
        [FieldOffset(0)]
        public readonly Guid Value;

        [FieldOffset(0)]
        public readonly byte Byte0;
        [FieldOffset(1)]
        public readonly byte Byte1;
        [FieldOffset(2)]
        public readonly byte Byte2;
        [FieldOffset(3)]
        public readonly byte Byte3;
        [FieldOffset(4)]
        public readonly byte Byte4;
        [FieldOffset(5)]
        public readonly byte Byte5;
        [FieldOffset(6)]
        public readonly byte Byte6;
        [FieldOffset(7)]
        public readonly byte Byte7;
        [FieldOffset(8)]
        public readonly byte Byte8;
        [FieldOffset(9)]
        public readonly byte Byte9;
        [FieldOffset(10)]
        public readonly byte Byte10;
        [FieldOffset(11)]
        public readonly byte Byte11;
        [FieldOffset(12)]
        public readonly byte Byte12;
        [FieldOffset(13)]
        public readonly byte Byte13;
        [FieldOffset(14)]
        public readonly byte Byte14;
        [FieldOffset(15)]
        public readonly byte Byte15;

        // string.Join(", ", Enumerable.Range(0, 256).Select(x => (int)BitConverter.ToString(new byte[] { (byte)x }).ToLower()[0]))
        private static ReadOnlySpan<byte> GetByteToHexStringHigh() => new byte[256] { 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102 };

        // string.Join(", ", Enumerable.Range(0, 256).Select(x => (int)BitConverter.ToString(new byte[] { (byte)x }).ToLower()[1]))
        private static ReadOnlySpan<byte> GetByteToHexStringLow() => new byte[256] { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102 };

        public GuidBits(ref Guid value)
        {
            this = default(GuidBits);
            this.Value = value;
        }

        // 4-pattern, lower/upper and '-' or no
        public GuidBits(ReadOnlySpan<byte> utf8string)
        {
            this = default(GuidBits);

            // 32
            if (utf8string.Length == 32)
            {
                if (BitConverter.IsLittleEndian)
                {
                    this.Byte0 = Parse(utf8string, 6);
                    this.Byte1 = Parse(utf8string, 4);
                    this.Byte2 = Parse(utf8string, 2);
                    this.Byte3 = Parse(utf8string, 0);

                    this.Byte4 = Parse(utf8string, 10);
                    this.Byte5 = Parse(utf8string, 8);

                    this.Byte6 = Parse(utf8string, 14);
                    this.Byte7 = Parse(utf8string, 12);
                }
                else
                {
                    this.Byte0 = Parse(utf8string, 0);
                    this.Byte1 = Parse(utf8string, 2);
                    this.Byte2 = Parse(utf8string, 4);
                    this.Byte3 = Parse(utf8string, 6);

                    this.Byte4 = Parse(utf8string, 8);
                    this.Byte5 = Parse(utf8string, 10);

                    this.Byte6 = Parse(utf8string, 12);
                    this.Byte7 = Parse(utf8string, 14);
                }

                this.Byte8 = Parse(utf8string, 16);
                this.Byte9 = Parse(utf8string, 18);

                this.Byte10 = Parse(utf8string, 20);
                this.Byte11 = Parse(utf8string, 22);
                this.Byte12 = Parse(utf8string, 24);
                this.Byte13 = Parse(utf8string, 26);
                this.Byte14 = Parse(utf8string, 28);
                this.Byte15 = Parse(utf8string, 30);
                return;
            }
            else if (utf8string.Length == 36)
            {
                // '-' => 45
                if (BitConverter.IsLittleEndian)
                {
                    this.Byte0 = Parse(utf8string, 6);
                    this.Byte1 = Parse(utf8string, 4);
                    this.Byte2 = Parse(utf8string, 2);
                    this.Byte3 = Parse(utf8string, 0);

                    if (utf8string[8] != '-')
                    {
                        goto ERROR;
                    }

                    this.Byte4 = Parse(utf8string, 11);
                    this.Byte5 = Parse(utf8string, 9);

                    if (utf8string[13] != '-')
                    {
                        goto ERROR;
                    }

                    this.Byte6 = Parse(utf8string, 16);
                    this.Byte7 = Parse(utf8string, 14);
                }
                else
                {
                    this.Byte0 = Parse(utf8string, 0);
                    this.Byte1 = Parse(utf8string, 2);
                    this.Byte2 = Parse(utf8string, 4);
                    this.Byte3 = Parse(utf8string, 6);

                    if (utf8string[8] != '-')
                    {
                        goto ERROR;
                    }

                    this.Byte4 = Parse(utf8string, 9);
                    this.Byte5 = Parse(utf8string, 11);

                    if (utf8string[13] != '-')
                    {
                        goto ERROR;
                    }

                    this.Byte6 = Parse(utf8string, 14);
                    this.Byte7 = Parse(utf8string, 16);
                }

                if (utf8string[18] != '-')
                {
                    goto ERROR;
                }

                this.Byte8 = Parse(utf8string, 19);
                this.Byte9 = Parse(utf8string, 21);

                if (utf8string[23] != '-')
                {
                    goto ERROR;
                }

                this.Byte10 = Parse(utf8string, 24);
                this.Byte11 = Parse(utf8string, 26);
                this.Byte12 = Parse(utf8string, 28);
                this.Byte13 = Parse(utf8string, 30);
                this.Byte14 = Parse(utf8string, 32);
                this.Byte15 = Parse(utf8string, 34);
                return;
            }

ERROR:
            throw new MessagePackSerializationException("Invalid Guid Pattern.");
        }

#if !UNITY_2018_3_OR_NEWER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
#endif
        private static byte Parse(ReadOnlySpan<byte> bytes, int highOffset)
        {
            return unchecked((byte)((SwitchParse(bytes[highOffset]) * 16) + SwitchParse(bytes[highOffset + 1])));
        }

#if !UNITY_2018_3_OR_NEWER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
#endif
        private static byte SwitchParse(byte b)
        {
            // '0'(48) ~ '9'(57) => -48
            // 'A'(65) ~ 'F'(70) => -55
            // 'a'(97) ~ 'f'(102) => -87
            switch (b)
            {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return unchecked((byte)(b - 48));
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                    return unchecked((byte)(b - 55));
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                    return unchecked((byte)(b - 87));
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                default:
                    throw new MessagePackSerializationException("Invalid Guid Pattern.");
            }
        }

        // 4(x2) - 2(x2) - 2(x2) - 2(x2) - 6(x2)
        public void Write(Span<byte> buffer)
        {
            var high = GetByteToHexStringHigh();
            var low = GetByteToHexStringLow();

            if (BitConverter.IsLittleEndian)
            {
                // int(_a)
                buffer[6] = high[this.Byte0];
                buffer[7] = low[this.Byte0];
                buffer[4] = high[this.Byte1];
                buffer[5] = low[this.Byte1];
                buffer[2] = high[this.Byte2];
                buffer[3] = low[this.Byte2];
                buffer[0] = high[this.Byte3];
                buffer[1] = low[this.Byte3];

                buffer[8] = (byte)'-';

                // short(_b)
                buffer[11] = high[this.Byte4];
                buffer[12] = low[this.Byte4];
                buffer[9] = high[this.Byte5];
                buffer[10] = low[this.Byte5];

                buffer[13] = (byte)'-';

                // short(_c)
                buffer[16] = high[this.Byte6];
                buffer[17] = low[this.Byte6];
                buffer[14] = high[this.Byte7];
                buffer[15] = low[this.Byte7];
            }
            else
            {
                buffer[0] = high[this.Byte0];
                buffer[1] = low[this.Byte0];
                buffer[2] = high[this.Byte1];
                buffer[3] = low[this.Byte1];
                buffer[4] = high[this.Byte2];
                buffer[5] = low[this.Byte2];
                buffer[6] = high[this.Byte3];
                buffer[7] = low[this.Byte3];

                buffer[8] = (byte)'-';

                buffer[9] = high[this.Byte4];
                buffer[10] = low[this.Byte4];
                buffer[11] = high[this.Byte5];
                buffer[12] = low[this.Byte5];

                buffer[13] = (byte)'-';

                buffer[14] = high[this.Byte6];
                buffer[15] = low[this.Byte6];
                buffer[16] = high[this.Byte7];
                buffer[17] = low[this.Byte7];
            }

            buffer[18] = (byte)'-';

            buffer[19] = high[this.Byte8];
            buffer[20] = low[this.Byte8];
            buffer[21] = high[this.Byte9];
            buffer[22] = low[this.Byte9];

            buffer[23] = (byte)'-';

            buffer[24] = high[this.Byte10];
            buffer[25] = low[this.Byte10];
            buffer[26] = high[this.Byte11];
            buffer[27] = low[this.Byte11];
            buffer[28] = high[this.Byte12];
            buffer[29] = low[this.Byte12];
            buffer[30] = high[this.Byte13];
            buffer[31] = low[this.Byte13];
            buffer[32] = high[this.Byte14];
            buffer[33] = low[this.Byte14];
            buffer[34] = high[this.Byte15];
            buffer[35] = low[this.Byte15];
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/GuidBits.cs.meta
================================================
fileFormatVersion: 2
guid: d68edf2bf3e742a4393af6f3e17345db
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ILGeneratorExtensions.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !(UNITY_2018_3_OR_NEWER && NET_STANDARD_2_0)

using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Internal
{
    internal struct ArgumentField
    {
        private readonly int i;
        private readonly bool @ref;
        private readonly ILGenerator il;

        public ArgumentField(ILGenerator il, int i, bool @ref = false)
        {
            this.il = il;
            this.i = i;
            this.@ref = @ref;
        }

        public ArgumentField(ILGenerator il, int i, Type type)
        {
            this.il = il;
            this.i = i;
            TypeInfo ti = type.GetTypeInfo();
            this.@ref = (ti.IsClass || ti.IsInterface || ti.IsAbstract) ? false : true;
        }

        public void EmitLoad()
        {
            if (this.@ref)
            {
                this.il.EmitLdarga(this.i);
            }
            else
            {
                this.il.EmitLdarg(this.i);
            }
        }

        public void EmitLdarg()
        {
            this.il.EmitLdarg(this.i);
        }

        public void EmitLdarga()
        {
            this.il.EmitLdarga(this.i);
        }

        public void EmitStore()
        {
            this.il.EmitStarg(this.i);
        }
    }

    /// <summary>
    /// Provides optimized generation code and helpers.
    /// </summary>
    internal static class ILGeneratorExtensions
    {
        /// <summary>
        /// Loads the local variable at a specific index onto the evaluation stack.
        /// </summary>
        public static void EmitLdloc(this ILGenerator il, int index)
        {
            switch (index)
            {
                case 0:
                    il.Emit(OpCodes.Ldloc_0);
                    break;
                case 1:
                    il.Emit(OpCodes.Ldloc_1);
                    break;
                case 2:
                    il.Emit(OpCodes.Ldloc_2);
                    break;
                case 3:
                    il.Emit(OpCodes.Ldloc_3);
                    break;
                default:
                    if (index <= 255)
                    {
                        il.Emit(OpCodes.Ldloc_S, (byte)index);
                    }
                    else
                    {
                        il.Emit(OpCodes.Ldloc, (short)index);
                    }

                    break;
            }
        }

        public static void EmitLdloc(this ILGenerator il, LocalBuilder local)
        {
            EmitLdloc(il, local.LocalIndex);
        }

        /// <summary>
        /// Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.
        /// </summary>
        public static void EmitStloc(this ILGenerator il, int index)
        {
            switch (index)
            {
                case 0:
                    il.Emit(OpCodes.Stloc_0);
                    break;
                case 1:
                    il.Emit(OpCodes.Stloc_1);
                    break;
                case 2:
                    il.Emit(OpCodes.Stloc_2);
                    break;
                case 3:
                    il.Emit(OpCodes.Stloc_3);
                    break;
                default:
                    if (index <= 255)
                    {
                        il.Emit(OpCodes.Stloc_S, (byte)index);
                    }
                    else
                    {
                        il.Emit(OpCodes.Stloc, (short)index);
                    }

                    break;
            }
        }

        public static void EmitStloc(this ILGenerator il, LocalBuilder local)
        {
            EmitStloc(il, local.LocalIndex);
        }

        /// <summary>
        /// Loads the address of the local variable at a specific index onto the evaluation statck.
        /// </summary>
        public static void EmitLdloca(this ILGenerator il, int index)
        {
            if (index <= 255)
            {
                il.Emit(OpCodes.Ldloca_S, (byte)index);
            }
            else
            {
                il.Emit(OpCodes.Ldloca, (short)index);
            }
        }

        public static void EmitLdloca(this ILGenerator il, LocalBuilder local)
        {
            EmitLdloca(il, local.LocalIndex);
        }

        public static void EmitTrue(this ILGenerator il)
        {
            EmitBoolean(il, true);
        }

        public static void EmitFalse(this ILGenerator il)
        {
            EmitBoolean(il, false);
        }

        public static void EmitBoolean(this ILGenerator il, bool value)
        {
            EmitLdc_I4(il, value ? 1 : 0);
        }

        /// <summary>
        /// Pushes a supplied value of type int32 onto the evaluation stack as an int32.
        /// </summary>
        public static void EmitLdc_I4(this ILGenerator il, int value)
        {
            switch (value)
            {
                case -1:
                    il.Emit(OpCodes.Ldc_I4_M1);
                    break;
                case 0:
                    il.Emit(OpCodes.Ldc_I4_0);
                    break;
                case 1:
                    il.Emit(OpCodes.Ldc_I4_1);
                    break;
                case 2:
                    il.Emit(OpCodes.Ldc_I4_2);
                    break;
                case 3:
                    il.Emit(OpCodes.Ldc_I4_3);
                    break;
                case 4:
                    il.Emit(OpCodes.Ldc_I4_4);
                    break;
                case 5:
                    il.Emit(OpCodes.Ldc_I4_5);
                    break;
                case 6:
                    il.Emit(OpCodes.Ldc_I4_6);
                    break;
                case 7:
                    il.Emit(OpCodes.Ldc_I4_7);
                    break;
                case 8:
                    il.Emit(OpCodes.Ldc_I4_8);
                    break;
                default:
                    if (value >= -128 && value <= 127)
                    {
                        il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
                    }
                    else
                    {
                        il.Emit(OpCodes.Ldc_I4, value);
                    }

                    break;
            }
        }

        public static void EmitUnboxOrCast(this ILGenerator il, Type type)
        {
            if (type.GetTypeInfo().IsValueType)
            {
                il.Emit(OpCodes.Unbox_Any, type);
            }
            else
            {
                il.Emit(OpCodes.Castclass, type);
            }
        }

        public static void EmitBoxOrDoNothing(this ILGenerator il, Type type)
        {
            if (type.GetTypeInfo().IsValueType)
            {
                il.Emit(OpCodes.Box, type);
            }
        }

        public static void EmitLdarg(this ILGenerator il, int index)
        {
            switch (index)
            {
                case 0:
                    il.Emit(OpCodes.Ldarg_0);
                    break;
                case 1:
                    il.Emit(OpCodes.Ldarg_1);
                    break;
                case 2:
                    il.Emit(OpCodes.Ldarg_2);
                    break;
                case 3:
                    il.Emit(OpCodes.Ldarg_3);
                    break;
                default:
                    if (index <= 255)
                    {
                        il.Emit(OpCodes.Ldarg_S, (byte)index);
                    }
                    else
                    {
                        il.Emit(OpCodes.Ldarg, index);
                    }

                    break;
            }
        }

        public static void EmitLoadThis(this ILGenerator il)
        {
            EmitLdarg(il, 0);
        }

        public static void EmitLdarga(this ILGenerator il, int index)
        {
            if (index <= 255)
            {
                il.Emit(OpCodes.Ldarga_S, (byte)index);
            }
            else
            {
                il.Emit(OpCodes.Ldarga, index);
            }
        }

        public static void EmitStarg(this ILGenerator il, int index)
        {
            if (index <= 255)
            {
                il.Emit(OpCodes.Starg_S, (byte)index);
            }
            else
            {
                il.Emit(OpCodes.Starg, index);
            }
        }

        /// <summary>
        /// Helper for Pop op.
        /// </summary>
        public static void EmitPop(this ILGenerator il, int count)
        {
            for (int i = 0; i < count; i++)
            {
                il.Emit(OpCodes.Pop);
            }
        }

        public static void EmitCall(this ILGenerator il, MethodInfo methodInfo)
        {
            if (methodInfo.IsFinal || !methodInfo.IsVirtual)
            {
                il.Emit(OpCodes.Call, methodInfo);
            }
            else
            {
                il.Emit(OpCodes.Callvirt, methodInfo);
            }
        }

        public static void EmitLdfld(this ILGenerator il, FieldInfo fieldInfo)
        {
            il.Emit(OpCodes.Ldfld, fieldInfo);
        }

        public static void EmitLdsfld(this ILGenerator il, FieldInfo fieldInfo)
        {
            il.Emit(OpCodes.Ldsfld, fieldInfo);
        }

        public static void EmitRet(this ILGenerator il)
        {
            il.Emit(OpCodes.Ret);
        }

        public static void EmitIntZeroReturn(this ILGenerator il)
        {
            il.EmitLdc_I4(0);
            il.Emit(OpCodes.Ret);
        }

        public static void EmitNullReturn(this ILGenerator il)
        {
            il.Emit(OpCodes.Ldnull);
            il.Emit(OpCodes.Ret);
        }

        public static void EmitULong(this ILGenerator il, ulong value)
        {
            il.Emit(OpCodes.Ldc_I8, unchecked((long)value));
        }

        public static void EmitThrowNotimplemented(this ILGenerator il)
        {
            il.Emit(OpCodes.Newobj, typeof(System.NotImplementedException).GetTypeInfo().DeclaredConstructors.First(x => x.GetParameters().Length == 0));
            il.Emit(OpCodes.Throw);
        }

        /// <summary>for  var i = 0, i ..., i++. </summary>
        public static void EmitIncrementFor(this ILGenerator il, LocalBuilder conditionGreater, Action<LocalBuilder> emitBody)
        {
            Label loopBegin = il.DefineLabel();
            Label condtionLabel = il.DefineLabel();

            // var i = 0
            LocalBuilder forI = il.DeclareLocal(typeof(int));
            il.EmitLdc_I4(0);
            il.EmitStloc(forI);
            il.Emit(OpCodes.Br, condtionLabel);

            il.MarkLabel(loopBegin);
            emitBody(forI);

            // i++
            il.EmitLdloc(forI);
            il.EmitLdc_I4(1);
            il.Emit(OpCodes.Add);
            il.EmitStloc(forI);

            //// i < ***
            il.MarkLabel(condtionLabel);
            il.EmitLdloc(forI);
            il.EmitLdloc(conditionGreater);
            il.Emit(OpCodes.Blt, loopBegin);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ILGeneratorExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 581e7074a007a6548a5e8408a4dad6dc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ReflectionExtensions.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace MessagePack.Internal
{
    internal static class ReflectionExtensions
    {
        public static bool IsNullable(this System.Reflection.TypeInfo type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(System.Nullable<>);
        }

        public static bool IsPublic(this System.Reflection.TypeInfo type)
        {
            return type.IsPublic;
        }

        public static bool IsAnonymous(this System.Reflection.TypeInfo type)
        {
            return type.Namespace == null
                   && type.IsSealed
                   && (type.Name.StartsWith("<>f__AnonymousType", StringComparison.Ordinal)
                       || type.Name.StartsWith("<>__AnonType", StringComparison.Ordinal)
                       || type.Name.StartsWith("VB$AnonymousType_", StringComparison.Ordinal))
                   && type.IsDefined(typeof(CompilerGeneratedAttribute), false);
        }

        public static bool IsIndexer(this System.Reflection.PropertyInfo propertyInfo)
        {
            return propertyInfo.GetIndexParameters().Length > 0;
        }

        public static bool IsConstructedGenericType(this System.Reflection.TypeInfo type)
        {
            return type.AsType().IsConstructedGenericType;
        }

        public static MethodInfo GetGetMethod(this PropertyInfo propInfo)
        {
            return propInfo.GetMethod;
        }

        public static MethodInfo GetSetMethod(this PropertyInfo propInfo)
        {
            return propInfo.SetMethod;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ReflectionExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: a6682a58039cc664c9e66b2d4b02d4d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/RuntimeTypeHandleEqualityComparer.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;

namespace MessagePack.Internal
{
    // This code is used in generated code so must be public.

    // RuntimeTypeHandle can embed directly by OpCodes.Ldtoken
    // It does not implements IEquatable<T>(but GetHashCode and Equals is implemented) so needs this to avoid boxing.
    public class RuntimeTypeHandleEqualityComparer : IEqualityComparer<RuntimeTypeHandle>
    {
        public static readonly IEqualityComparer<RuntimeTypeHandle> Default = new RuntimeTypeHandleEqualityComparer();

        private RuntimeTypeHandleEqualityComparer()
        {
        }

        public bool Equals(RuntimeTypeHandle x, RuntimeTypeHandle y)
        {
            return x.Equals(y);
        }

        public int GetHashCode(RuntimeTypeHandle obj)
        {
            return obj.GetHashCode();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/RuntimeTypeHandleEqualityComparer.cs.meta
================================================
fileFormatVersion: 2
guid: bceda592765280b4f8cb470f1ed9c532
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/Sequence`1.cs
================================================
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* Original license and copyright from file copied from https://github.com/AArnott/Nerdbank.Streams/blob/d656899be26d4d7c72c11c9232b4952c64a89bcb/src/Nerdbank.Streams/Sequence%601.cs
 * Copyright (c) Andrew Arnott. All rights reserved.
 * Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
*/

using System;
using System.Buffers;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Nerdbank.Streams
{
    /// <summary>
    /// Manages a sequence of elements, readily castable as a <see cref="ReadOnlySequence{T}"/>.
    /// </summary>
    /// <typeparam name="T">The type of element stored by the sequence.</typeparam>
    /// <remarks>
    /// Instance members are not thread-safe.
    /// </remarks>
    [DebuggerDisplay("{" + nameof(DebuggerDisplay) + ",nq}")]
    internal class Sequence<T> : IBufferWriter<T>, IDisposable
    {
        private static readonly int DefaultLengthFromArrayPool = 1 + (4095 / Marshal.SizeOf<T>());

        private readonly Stack<SequenceSegment> segmentPool = new Stack<SequenceSegment>();

        private readonly MemoryPool<T> memoryPool;

        private readonly ArrayPool<T> arrayPool;

        private SequenceSegment first;

        private SequenceSegment last;

        /// <summary>
        /// Initializes a new instance of the <see cref="Sequence{T}"/> class
        /// that uses a private <see cref="ArrayPool{T}"/> for recycling arrays.
        /// </summary>
        public Sequence()
            : this(ArrayPool<T>.Create())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Sequence{T}"/> class.
        /// </summary>
        /// <param name="memoryPool">The pool to use for recycling backing arrays.</param>
        public Sequence(MemoryPool<T> memoryPool)
        {
            Requires.NotNull(memoryPool, nameof(memoryPool));
            this.memoryPool = memoryPool;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Sequence{T}"/> class.
        /// </summary>
        /// <param name="arrayPool">The pool to use for recycling backing arrays.</param>
        public Sequence(ArrayPool<T> arrayPool)
        {
            Requires.NotNull(arrayPool, nameof(arrayPool));
            this.arrayPool = arrayPool;
        }

        /// <summary>
        /// Gets or sets the minimum length for any array allocated as a segment in the sequence.
        /// Any non-positive value allows the pool to determine the length of the array.
        /// </summary>
        /// <value>The default value is 0.</value>
        /// <remarks>
        /// <para>
        /// Each time <see cref="GetSpan(int)"/> or <see cref="GetMemory(int)"/> is called,
        /// previously allocated memory is used if it is large enough to satisfy the length demand.
        /// If new memory must be allocated, the argument to one of these methods typically dictate
        /// the length of array to allocate. When the caller uses very small values (just enough for its immediate need)
        /// but the high level scenario can predict that a large amount of memory will be ultimately required,
        /// it can be advisable to set this property to a value such that just a few larger arrays are allocated
        /// instead of many small ones.
        /// </para>
        /// <para>
        /// The <see cref="MemoryPool{T}"/> in use may itself have a minimum array length as well,
        /// in which case the higher of the two minimums dictate the minimum array size that will be allocated.
        /// </para>
        /// </remarks>
        public int MinimumSpanLength { get; set; } = 0;

        /// <summary>
        /// Gets this sequence expressed as a <see cref="ReadOnlySequence{T}"/>.
        /// </summary>
        /// <returns>A read only sequence representing the data in this object.</returns>
        public ReadOnlySequence<T> AsReadOnlySequence => this;

        /// <summary>
        /// Gets the length of the sequence.
        /// </summary>
        public long Length => this.AsReadOnlySequence.Length;

        /// <summary>
        /// Gets the value to display in a debugger datatip.
        /// </summary>
        private string DebuggerDisplay => $"Length: {this.AsReadOnlySequence.Length}";

        /// <summary>
        /// Expresses this sequence as a <see cref="ReadOnlySequence{T}"/>.
        /// </summary>
        /// <param name="sequence">The sequence to convert.</param>
        public static implicit operator ReadOnlySequence<T>(Sequence<T> sequence)
        {
            return sequence.first != null
                ? new ReadOnlySequence<T>(sequence.first, sequence.first.Start, sequence.last, sequence.last.End)
                : ReadOnlySequence<T>.Empty;
        }

        /// <summary>
        /// Removes all elements from the sequence from its beginning to the specified position,
        /// considering that data to have been fully processed.
        /// </summary>
        /// <param name="position">
        /// The position of the first element that has not yet been processed.
        /// This is typically <see cref="ReadOnlySequence{T}.End"/> after reading all elements from that instance.
        /// </param>
        public void AdvanceTo(SequencePosition position)
        {
            var firstSegment = (SequenceSegment)position.GetObject();
            int firstIndex = position.GetInteger();

            // Before making any mutations, confirm that the block specified belongs to this sequence.
            var current = this.first;
            while (current != firstSegment && current != null)
            {
                current = current.Next;
            }

            Requires.Argument(current != null, nameof(position), "Position does not represent a valid position in this sequence.");

            // Also confirm that the position is not a prior position in the block.
            Requires.Argument(firstIndex >= current.Start, nameof(position), "Position must not be earlier than current position.");

            // Now repeat the loop, performing the mutations.
            current = this.first;
            while (current != firstSegment)
            {
                current = this.RecycleAndGetNext(current);
            }

            firstSegment.AdvanceTo(firstIndex);

            if (firstSegment.Length == 0)
            {
                firstSegment = this.RecycleAndGetNext(firstSegment);
            }

            this.first = firstSegment;

            if (this.first == null)
            {
                this.last = null;
            }
        }

        /// <summary>
        /// Advances the sequence to include the specified number of elements initialized into memory
        /// returned by a prior call to <see cref="GetMemory(int)"/>.
        /// </summary>
        /// <param name="count">The number of elements written into memory.</param>
        public void Advance(int count)
        {
            SequenceSegment last = this.last;
            Verify.Operation(last != null, "Cannot advance before acquiring memory.");
            last.Advance(count);
        }

        /// <summary>
        /// Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="Advance(int)"/>.
        /// </summary>
        /// <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
        /// <returns>The requested memory.</returns>
        public Memory<T> GetMemory(int sizeHint) => this.GetSegment(sizeHint).RemainingMemory;

        /// <summary>
        /// Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="Advance(int)"/>.
        /// </summary>
        /// <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
        /// <returns>The requested memory.</returns>
        public Span<T> GetSpan(int sizeHint) => this.GetSegment(sizeHint).RemainingSpan;

        /// <summary>
        /// Clears the entire sequence, recycles associated memory into pools,
        /// and resets this instance for reuse.
        /// This invalidates any <see cref="ReadOnlySequence{T}"/> previously produced by this instance.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void Dispose() => this.Reset();

        /// <summary>
        /// Clears the entire sequence and recycles associated memory into pools.
        /// This invalidates any <see cref="ReadOnlySequence{T}"/> previously produced by this instance.
        /// </summary>
        public void Reset()
        {
            var current = this.first;
            while (current != null)
            {
                current = this.RecycleAndGetNext(current);
            }

            this.first = this.last = null;
        }

        private SequenceSegment GetSegment(int sizeHint)
        {
            Requires.Range(sizeHint >= 0, nameof(sizeHint));
            int? minBufferSize = null;
            if (sizeHint == 0)
            {
                if (this.last == null || this.last.WritableBytes == 0)
                {
                    // We're going to need more memory. Take whatever size the pool wants to give us.
                    minBufferSize = -1;
                }
            }
            else
            {
                sizeHint = Math.Max(this.MinimumSpanLength, sizeHint);
                if (this.last == null || this.last.WritableBytes < sizeHint)
                {
                    minBufferSize = sizeHint;
                }
            }

            if (minBufferSize.HasValue)
            {
                var segment = this.segmentPool.Count > 0 ? this.segmentPool.Pop() : new SequenceSegment();
                if (this.arrayPool != null)
                {
                    segment.Assign(this.arrayPool.Rent(minBufferSize.Value == -1 ? DefaultLengthFromArrayPool : minBufferSize.Value));
                }
                else
                {
                    segment.Assign(this.memoryPool.Rent(minBufferSize.Value));
                }

                this.Append(segment);
            }

            return this.last;
        }

        private void Append(SequenceSegment segment)
        {
            if (this.last == null)
            {
                this.first = this.last = segment;
            }
            else
            {
                if (this.last.Length > 0)
                {
                    // Add a new block.
                    this.last.SetNext(segment);
                }
                else
                {
                    // The last block is completely unused. Replace it instead of appending to it.
                    var current = this.first;
                    if (this.first != this.last)
                    {
                        while (current.Next != this.last)
                        {
                            current = current.Next;
                        }
                    }
                    else
                    {
                        this.first = segment;
                    }

                    current.SetNext(segment);
                    this.RecycleAndGetNext(this.last);
                }

                this.last = segment;
            }
        }

        private SequenceSegment RecycleAndGetNext(SequenceSegment segment)
        {
            var recycledSegment = segment;
            segment = segment.Next;
            recycledSegment.ResetMemory(this.arrayPool);
            this.segmentPool.Push(recycledSegment);
            return segment;
        }

        private class SequenceSegment : ReadOnlySequenceSegment<T>
        {
            /// <summary>
            /// A value indicating whether the element may contain references (and thus must be cleared).
            /// </summary>
            private static readonly bool MayContainReferences = !typeof(T).GetTypeInfo().IsPrimitive;

            /// <summary>
            /// Gets the backing array, when using an <see cref="ArrayPool{T}"/> instead of a <see cref="MemoryPool{T}"/>.
            /// </summary>
            private T[] array;

            /// <summary>
            /// Gets the position within <see cref="ReadOnlySequenceSegment{T}.Memory"/> where the data starts.
            /// </summary>
            /// <remarks>This may be nonzero as a result of calling <see cref="Sequence{T}.AdvanceTo(SequencePosition)"/>.</remarks>
            internal int Start { get; private set; }

            /// <summary>
            /// Gets the position within <see cref="ReadOnlySequenceSegment{T}.Memory"/> where the data ends.
            /// </summary>
            internal int End { get; private set; }

            /// <summary>
            /// Gets the tail of memory that has not yet been committed.
            /// </summary>
            internal Memory<T> RemainingMemory => this.AvailableMemory.Slice(this.End);

            /// <summary>
            /// Gets the tail of memory that has not yet been committed.
            /// </summary>
            internal Span<T> RemainingSpan => this.AvailableMemory.Span.Slice(this.End);

            /// <summary>
            /// Gets the tracker for the underlying array for this segment, which can be used to recycle the array when we're disposed of.
            /// Will be <c>null</c> if using an array pool, in which case the memory is held by <see cref="array"/>.
            /// </summary>
            internal IMemoryOwner<T> MemoryOwner { get; private set; }

            /// <summary>
            /// Gets the full memory owned by the <see cref="MemoryOwner"/>.
            /// </summary>
            internal Memory<T> AvailableMemory => this.array ?? this.MemoryOwner?.Memory ?? default;

            /// <summary>
            /// Gets the number of elements that are committed in this segment.
            /// </summary>
            internal int Length => this.End - this.Start;

            /// <summary>
            /// Gets the amount of writable bytes in this segment.
            /// It is the amount of bytes between <see cref="Length"/> and <see cref="End"/>.
            /// </summary>
            internal int WritableBytes => this.AvailableMemory.Length - this.End;

            /// <summary>
            /// Gets or sets the next segment in the singly linked list of segments.
            /// </summary>
            internal new SequenceSegment Next
            {
                get => (SequenceSegment)base.Next;
                set => base.Next = value;
            }

            /// <summary>
            /// Assigns this (recyclable) segment a new area in memory.
            /// </summary>
            /// <param name="memoryOwner">The memory and a means to recycle it.</param>
            internal void Assign(IMemoryOwner<T> memoryOwner)
            {
                this.MemoryOwner = memoryOwner;
                this.Memory = memoryOwner.Memory;
            }

            /// <summary>
            /// Assigns this (recyclable) segment a new area in memory.
            /// </summary>
            /// <param name="array">An array drawn from an <see cref="ArrayPool{T}"/>.</param>
            internal void Assign(T[] array)
            {
                this.array = array;
                this.Memory = array;
            }

            /// <summary>
            /// Clears all fields in preparation to recycle this instance.
            /// </summary>
            internal void ResetMemory(ArrayPool<T> arrayPool)
            {
                this.ClearReferences(this.Start, this.End);
                this.Memory = default;
                this.Next = null;
                this.RunningIndex = 0;
                this.Start = 0;
                this.End = 0;
                if (this.array != null)
                {
                    arrayPool.Return(this.array);
                    this.array = null;
                }
                else
                {
                    this.MemoryOwner?.Dispose();
                    this.MemoryOwner = null;
                }
            }

            /// <summary>
            /// Adds a new segment after this one.
            /// </summary>
            /// <param name="segment">The next segment in the linked list.</param>
            internal void SetNext(SequenceSegment segment)
            {
                Debug.Assert(segment != null, "Null not allowed.");
                this.Next = segment;
                segment.RunningIndex = this.RunningIndex + this.Start + this.Length;

                // When setting Memory, we start with index 0 instead of this.Start because
                // the first segment has an explicit index set anyway,
                // and we don't want to double-count it here.
                this.Memory = this.AvailableMemory.Slice(0, this.Start + this.Length);
            }

            /// <summary>
            /// Commits more elements as written in this segment.
            /// </summary>
            /// <param name="count">The number of elements written.</param>
            internal void Advance(int count)
            {
                Requires.Range(count >= 0 && this.End + count <= this.Memory.Length, nameof(count));
                this.End += count;
            }

            /// <summary>
            /// Removes some elements from the start of this segment.
            /// </summary>
            /// <param name="offset">The number of elements to ignore from the start of the underlying array.</param>
            internal void AdvanceTo(int offset)
            {
                Debug.Assert(offset >= this.Start, "Trying to rewind.");
                this.ClearReferences(this.Start, offset - this.Start);
                this.Start = offset;
            }

            private void ClearReferences(int startIndex, int length)
            {
                // Clear the array to allow the objects to be GC'd.
                // Reference types need to be cleared. Value types can be structs with reference type members too, so clear everything.
                if (MayContainReferences)
                {
                    this.AvailableMemory.Span.Slice(startIndex, length).Clear();
                }
            }
        }
    }

    internal static class Requires
    {
        /// <summary>
        /// Throws an <see cref="ArgumentOutOfRangeException"/> if a condition does not evaluate to true.
        /// </summary>
        [DebuggerStepThrough]
        public static void Range(bool condition, string parameterName, string message = null)
        {
            if (!condition)
            {
                FailRange(parameterName, message);
            }
        }

        /// <summary>
        /// Throws an <see cref="ArgumentOutOfRangeException"/> if a condition does not evaluate to true.
        /// </summary>
        /// <returns>Nothing.  This method always throws.</returns>
        [DebuggerStepThrough]
        public static Exception FailRange(string parameterName, string message = null)
        {
            if (string.IsNullOrEmpty(message))
            {
                throw new ArgumentOutOfRangeException(parameterName);
            }
            else
            {
                throw new ArgumentOutOfRangeException(parameterName, message);
            }
        }

        /// <summary>
        /// Throws an exception if the specified parameter's value is null.
        /// </summary>
        /// <typeparam name="T">The type of the parameter.</typeparam>
        /// <param name="value">The value of the argument.</param>
        /// <param name="parameterName">The name of the parameter to include in any thrown exception.</param>
        /// <returns>The value of the parameter.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="value"/> is <c>null</c>.</exception>
        [DebuggerStepThrough]
        public static T NotNull<T>(T value, string parameterName)
            where T : class // ensures value-types aren't passed to a null checking method
        {
            if (value == null)
            {
                throw new ArgumentNullException(parameterName);
            }

            return value;
        }

        /// <summary>
        /// Throws an ArgumentException if a condition does not evaluate to true.
        /// </summary>
        [DebuggerStepThrough]
        public static void Argument(bool condition, string parameterName, string message)
        {
            if (!condition)
            {
                throw new ArgumentException(message, parameterName);
            }
        }

        /// <summary>
        /// Throws an ArgumentException if a condition does not evaluate to true.
        /// </summary>
        [DebuggerStepThrough]
        public static void Argument(bool condition, string parameterName, string message, object arg1)
        {
            if (!condition)
            {
                throw new ArgumentException(String.Format(message, arg1), parameterName);
            }
        }

        /// <summary>
        /// Throws an ArgumentException if a condition does not evaluate to true.
        /// </summary>
        [DebuggerStepThrough]
        public static void Argument(bool condition, string parameterName, string message, object arg1, object arg2)
        {
            if (!condition)
            {
                throw new ArgumentException(String.Format(message, arg1, arg2), parameterName);
            }
        }

        /// <summary>
        /// Throws an ArgumentException if a condition does not evaluate to true.
        /// </summary>
        [DebuggerStepThrough]
        public static void Argument(bool condition, string parameterName, string message, params object[] args)
        {
            if (!condition)
            {
                throw new ArgumentException(String.Format(message, args), parameterName);
            }
        }
    }

    /// <summary>
    /// Common runtime checks that throw exceptions upon failure.
    /// </summary>
    internal static partial class Verify
    {
        /// <summary>
        /// Throws an <see cref="InvalidOperationException"/> if a condition is false.
        /// </summary>
        [DebuggerStepThrough]
        internal static void Operation(bool condition, string message)
        {
            if (!condition)
            {
                throw new InvalidOperationException(message);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/Sequence`1.cs.meta
================================================
fileFormatVersion: 2
guid: 46a3d0af338351d4b897b1323a92233a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ThreadsafeTypeKeyHashTable.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.CompilerServices;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Internal
{
    /// <summary>
    /// A dictionary where <see cref="Type"/> is the key, and a configurable <typeparamref name="TValue"/> type
    /// that is thread-safe to read and write, allowing concurrent reads and exclusive writes.
    /// </summary>
    /// <typeparam name="TValue">The type of value stored in the dictionary.</typeparam>
    internal class ThreadsafeTypeKeyHashTable<TValue>
    {
        private Entry[] buckets;
        private int size; // only use in writer lock

        private readonly object writerLock = new object();
        private readonly float loadFactor;

        // IEqualityComparer.Equals is overhead if key only Type, don't use it.
        //// readonly IEqualityComparer<TKey> comparer;

        public ThreadsafeTypeKeyHashTable(int capacity = 4, float loadFactor = 0.75f)
        {
            var tableSize = CalculateCapacity(capacity, loadFactor);
            this.buckets = new Entry[tableSize];
            this.loadFactor = loadFactor;
        }

        public bool TryAdd(Type key, TValue value)
        {
            return this.TryAdd(key, _ => value); // create lambda capture
        }

        public bool TryAdd(Type key, Func<Type, TValue> valueFactory)
        {
            return this.TryAddInternal(key, valueFactory, out TValue _);
        }

        private bool TryAddInternal(Type key, Func<Type, TValue> valueFactory, out TValue resultingValue)
        {
            lock (this.writerLock)
            {
                var nextCapacity = CalculateCapacity(this.size + 1, this.loadFactor);

                if (this.buckets.Length < nextCapacity)
                {
                    // rehash
                    var nextBucket = new Entry[nextCapacity];
                    for (int i = 0; i < this.buckets.Length; i++)
                    {
                        Entry e = this.buckets[i];
                        while (e != null)
                        {
                            var newEntry = new Entry { Key = e.Key, Value = e.Value, Hash = e.Hash };
                            this.AddToBuckets(nextBucket, key, newEntry, null, out resultingValue);
                            e = e.Next;
                        }
                    }

                    // add entry(if failed to add, only do resize)
                    var successAdd = this.AddToBuckets(nextBucket, key, null, valueFactory, out resultingValue);

                    // replace field(threadsafe for read)
                    VolatileWrite(ref this.buckets, nextBucket);

                    if (successAdd)
                    {
                        this.size++;
                    }

                    return successAdd;
                }
                else
                {
                    // add entry(insert last is thread safe for read)
                    var successAdd = this.AddToBuckets(this.buckets, key, null, valueFactory, out resultingValue);
                    if (successAdd)
                    {
                        this.size++;
                    }

                    return successAdd;
                }
            }
        }

        private bool AddToBuckets(Entry[] buckets, Type newKey, Entry newEntryOrNull, Func<Type, TValue> valueFactory, out TValue resultingValue)
        {
            var h = (newEntryOrNull != null) ? newEntryOrNull.Hash : newKey.GetHashCode();
            if (buckets[h & (buckets.Length - 1)] == null)
            {
                if (newEntryOrNull != null)
                {
                    resultingValue = newEntryOrNull.Value;
                    VolatileWrite(ref buckets[h & (buckets.Length - 1)], newEntryOrNull);
                }
                else
                {
                    resultingValue = valueFactory(newKey);
                    VolatileWrite(ref buckets[h & (buckets.Length - 1)], new Entry { Key = newKey, Value = resultingValue, Hash = h });
                }
            }
            else
            {
                Entry searchLastEntry = buckets[h & (buckets.Length - 1)];
                while (true)
                {
                    if (searchLastEntry.Key == newKey)
                    {
                        resultingValue = searchLastEntry.Value;
                        return false;
                    }

                    if (searchLastEntry.Next == null)
                    {
                        if (newEntryOrNull != null)
                        {
                            resultingValue = newEntryOrNull.Value;
                            VolatileWrite(ref searchLastEntry.Next, newEntryOrNull);
                        }
                        else
                        {
                            resultingValue = valueFactory(newKey);
                            VolatileWrite(ref searchLastEntry.Next, new Entry { Key = newKey, Value = resultingValue, Hash = h });
                        }

                        break;
                    }

                    searchLastEntry = searchLastEntry.Next;
                }
            }

            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetValue(Type key, out TValue value)
        {
            Entry[] table = this.buckets;
            var hash = key.GetHashCode();
            Entry entry = table[hash & table.Length - 1];

            while (entry != null)
            {
                if (entry.Key == key)
                {
                    value = entry.Value;
                    return true;
                }

                entry = entry.Next;
            }

            value = default(TValue);
            return false;
        }

        public TValue GetOrAdd(Type key, Func<Type, TValue> valueFactory)
        {
            TValue v;
            if (this.TryGetValue(key, out v))
            {
                return v;
            }

            this.TryAddInternal(key, valueFactory, out v);
            return v;
        }

        private static int CalculateCapacity(int collectionSize, float loadFactor)
        {
            var initialCapacity = (int)(((float)collectionSize) / loadFactor);
            var capacity = 1;
            while (capacity < initialCapacity)
            {
                capacity <<= 1;
            }

            if (capacity < 8)
            {
                return 8;
            }

            return capacity;
        }

        private static void VolatileWrite(ref Entry location, Entry value)
        {
#if !UNITY_2018_3_OR_NEWER
            System.Threading.Volatile.Write(ref location, value);
#elif UNITY_2018_3_OR_NEWER || NET_4_6
            System.Threading.Volatile.Write(ref location, value);
#else
            System.Threading.Thread.MemoryBarrier();
            location = value;
#endif
        }

        private static void VolatileWrite(ref Entry[] location, Entry[] value)
        {
#if !UNITY_2018_3_OR_NEWER
            System.Threading.Volatile.Write(ref location, value);
#elif UNITY_2018_3_OR_NEWER || NET_4_6
            System.Threading.Volatile.Write(ref location, value);
#else
            System.Threading.Thread.MemoryBarrier();
            location = value;
#endif
        }

        private class Entry
        {
#pragma warning disable SA1401 // Fields should be private
            internal Type Key;
            internal TValue Value;
            internal int Hash;
            internal Entry Next;
#pragma warning restore SA1401 // Fields should be private

            // debug only
            public override string ToString()
            {
                return this.Key + "(" + this.Count() + ")";
            }

            private int Count()
            {
                var count = 1;
                Entry n = this;
                while (n.Next != null)
                {
                    count++;
                    n = n.Next;
                }

                return count;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/ThreadsafeTypeKeyHashTable.cs.meta
================================================
fileFormatVersion: 2
guid: 324a59f0b14af2544807199e055a1ac4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/TinyJsonReader.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Globalization;
using System.IO;
using System.Text;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack
{
    /* simple, tiny JSON reader for MessagePackSerializer.FromJson.
     * this is simple, compact and enough fast but not optimized extremely. */

    internal enum TinyJsonToken
    {
        None,
        StartObject,  // {
        EndObject,    // }
        StartArray,   // [
        EndArray,     // ]
        Number,       // -0~9
        String,       // "___"
        True,         // true
        False,        // false
        Null,         // null
    }

    internal enum ValueType : byte
    {
        Null,
        True,
        False,
        Double,
        Long,
        ULong,
        Decimal,
        String,
    }

    public class TinyJsonException : MessagePackSerializationException
    {
        public TinyJsonException(string message)
            : base(message)
        {
        }
    }

    internal class TinyJsonReader : IDisposable
    {
        private readonly TextReader reader;
        private readonly bool disposeInnerReader;
        private StringBuilder reusableBuilder;

        public TinyJsonToken TokenType { get; private set; }

        public ValueType ValueType { get; private set; }

        public double DoubleValue { get; private set; }

        public long LongValue { get; private set; }

        public ulong ULongValue { get; private set; }

        public decimal DecimalValue { get; private set; }

        public string StringValue { get; private set; }

        public TinyJsonReader(TextReader reader, bool disposeInnerReader = true)
        {
            this.reader = reader;
            this.disposeInnerReader = disposeInnerReader;
        }

        public bool Read()
        {
            this.ReadNextToken();
            this.ReadValue();
            return this.TokenType != TinyJsonToken.None;
        }

        public void Dispose()
        {
            if (this.reader != null && this.disposeInnerReader)
            {
                this.reader.Dispose();
            }

            this.TokenType = TinyJsonToken.None;
            this.ValueType = ValueType.Null;
        }

        private void SkipWhiteSpace()
        {
            var c = this.reader.Peek();
            while (c != -1 && Char.IsWhiteSpace((char)c))
            {
                this.reader.Read();
                c = this.reader.Peek();
            }
        }

        private char ReadChar()
        {
            return (char)this.reader.Read();
        }

        private static bool IsWordBreak(char c)
        {
            switch (c)
            {
                case ' ':
                case '{':
                case '}':
                case '[':
                case ']':
                case ',':
                case ':':
                case '\"':
                    return true;
                default:
                    return false;
            }
        }

        private void ReadNextToken()
        {
            this.SkipWhiteSpace();

            var intChar = this.reader.Peek();
            if (intChar == -1)
            {
                this.TokenType = TinyJsonToken.None;
                return;
            }

            var c = (char)intChar;
            switch (c)
            {
                case '{':
                    this.TokenType = TinyJsonToken.StartObject;
                    return;
                case '}':
                    this.TokenType = TinyJsonToken.EndObject;
                    return;
                case '[':
                    this.TokenType = TinyJsonToken.StartArray;
                    return;
                case ']':
                    this.TokenType = TinyJsonToken.EndArray;
                    return;
                case '"':
                    this.TokenType = TinyJsonToken.String;
                    return;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '-':
                    this.TokenType = TinyJsonToken.Number;
                    return;
                case 't':
                    this.TokenType = TinyJsonToken.True;
                    return;
                case 'f':
                    this.TokenType = TinyJsonToken.False;
                    return;
                case 'n':
                    this.TokenType = TinyJsonToken.Null;
                    return;
                case ',':
                case ':':
                    this.reader.Read();
                    this.ReadNextToken();
                    return;
                default:
                    throw new TinyJsonException("Invalid String:" + c);
            }
        }

        private void ReadValue()
        {
            this.ValueType = ValueType.Null;

            switch (this.TokenType)
            {
                case TinyJsonToken.None:
                    break;
                case TinyJsonToken.StartObject:
                case TinyJsonToken.EndObject:
                case TinyJsonToken.StartArray:
                case TinyJsonToken.EndArray:
                    this.reader.Read();
                    break;
                case TinyJsonToken.Number:
                    this.ReadNumber();
                    break;
                case TinyJsonToken.String:
                    this.ReadString();
                    break;
                case TinyJsonToken.True:
                    if (this.ReadChar() != 't')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'r')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'u')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'e')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    this.ValueType = ValueType.True;
                    break;
                case TinyJsonToken.False:
                    if (this.ReadChar() != 'f')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'a')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'l')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 's')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'e')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    this.ValueType = ValueType.False;
                    break;
                case TinyJsonToken.Null:
                    if (this.ReadChar() != 'n')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'u')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'l')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    if (this.ReadChar() != 'l')
                    {
                        throw new TinyJsonException("Invalid Token");
                    }

                    this.ValueType = ValueType.Null;
                    break;
                default:
                    throw new MessagePackSerializationException("InvalidTokenState:" + this.TokenType);
            }
        }

        private void ReadNumber()
        {
            StringBuilder numberWord;
            if (this.reusableBuilder == null)
            {
                this.reusableBuilder = new StringBuilder();
                numberWord = this.reusableBuilder;
            }
            else
            {
                numberWord = this.reusableBuilder;
                numberWord.Length = 0; // Clear
            }

            var isDouble = false;
            var intChar = this.reader.Peek();
            while (intChar != -1 && !IsWordBreak((char)intChar))
            {
                var c = this.ReadChar();
                numberWord.Append(c);
                if (c == '.' || c == 'e' || c == 'E')
                {
                    isDouble = true;
                }

                intChar = this.reader.Peek();
            }

            var number = numberWord.ToString();
            if (isDouble)
            {
                double parsedDouble;
                Double.TryParse(number, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite | NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowThousands | NumberStyles.AllowExponent, System.Globalization.CultureInfo.InvariantCulture, out parsedDouble);
                this.ValueType = ValueType.Double;
                this.DoubleValue = parsedDouble;
            }
            else
            {
                long parsedInt;
                if (Int64.TryParse(number, NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out parsedInt))
                {
                    this.ValueType = ValueType.Long;
                    this.LongValue = parsedInt;
                    return;
                }

                ulong parsedULong;
                if (ulong.TryParse(number, NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out parsedULong))
                {
                    this.ValueType = ValueType.ULong;
                    this.ULongValue = parsedULong;
                    return;
                }

                Decimal parsedDecimal;
                if (decimal.TryParse(number, NumberStyles.Number, System.Globalization.CultureInfo.InvariantCulture, out parsedDecimal))
                {
                    this.ValueType = ValueType.Decimal;
                    this.DecimalValue = parsedDecimal;
                    return;
                }
            }
        }

        private void ReadString()
        {
            this.reader.Read(); // skip ["]

            StringBuilder sb;
            if (this.reusableBuilder == null)
            {
                this.reusableBuilder = new StringBuilder();
                sb = this.reusableBuilder;
            }
            else
            {
                sb = this.reusableBuilder;
                sb.Length = 0; // Clear
            }

            while (true)
            {
                if (this.reader.Peek() == -1)
                {
                    throw new TinyJsonException("Invalid Json String");
                }

                var c = this.ReadChar();
                switch (c)
                {
                    case '"': // endtoken
                        goto END;
                    case '\\': // escape character
                        if (this.reader.Peek() == -1)
                        {
                            throw new TinyJsonException("Invalid Json String");
                        }

                        c = this.ReadChar();
                        switch (c)
                        {
                            case '"':
                            case '\\':
                            case '/':
                                sb.Append(c);
                                break;
                            case 'b':
                                sb.Append('\b');
                                break;
                            case 'f':
                                sb.Append('\f');
                                break;
                            case 'n':
                                sb.Append('\n');
                                break;
                            case 'r':
                                sb.Append('\r');
                                break;
                            case 't':
                                sb.Append('\t');
                                break;
                            case 'u':
                                var hex = new char[4];
                                hex[0] = this.ReadChar();
                                hex[1] = this.ReadChar();
                                hex[2] = this.ReadChar();
                                hex[3] = this.ReadChar();
                                sb.Append((char)Convert.ToInt32(new string(hex), 16));
                                break;
                        }

                        break;
                    default: // string
                        sb.Append(c);
                        break;
                }
            }

END:
            this.ValueType = ValueType.String;
            this.StringValue = sb.ToString();
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/TinyJsonReader.cs.meta
================================================
fileFormatVersion: 2
guid: bd9d3de59693d9f49be777193cd4e846
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/UnsafeMemory.Low.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !UNITY_2018_3_OR_NEWER

using System;
using System.Runtime.CompilerServices;

namespace MessagePack.Internal
{
    /* for string key property name write optimization. */

    public static class UnsafeMemory
    {
        public static readonly bool Is32Bit = IntPtr.Size == 4;
    }

    public static partial class UnsafeMemory32
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw1(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(byte*)pDst = *(byte*)pSrc;
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw2(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(short*)pDst = *(short*)pSrc;
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw3(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(byte*)pDst = *(byte*)pSrc;
                *(short*)(pDst + 1) = *(short*)(pSrc + 1);
            }

            writer.Advance(src.Length);
        }
    }

    public static partial class UnsafeMemory64
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw1(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(byte*)pDst = *(byte*)pSrc;
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw2(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(short*)pDst = *(short*)pSrc;
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw3(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(byte*)pDst = *(byte*)pSrc;
                *(short*)(pDst + 1) = *(short*)(pSrc + 1);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw4(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw5(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 1) = *(int*)(pSrc + 1);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw6(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 2) = *(int*)(pSrc + 2);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw7(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 3) = *(int*)(pSrc + 3);
            }

            writer.Advance(src.Length);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Internal/UnsafeMemory.Low.cs.meta
================================================
fileFormatVersion: 2
guid: ea00cefaa2f44ee408f3975719c372cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#region license

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

using System;

#pragma warning disable SA1310 // Field names should not contain underscore

namespace MessagePack.LZ4
{
    internal static partial class LZ4Codec
    {
        #region configuration

        /// <summary>
        /// Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
        /// Increasing memory usage improves compression ratio
        /// Reduced memory usage can improve speed, due to cache effect
        /// Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache.
        /// </summary>
        private const int MEMORY_USAGE = 12; // modified use 12.

        /// <summary>
        /// Decreasing this value will make the algorithm skip faster data segments considered "incompressible"
        /// This may decrease compression ratio dramatically, but will be faster on incompressible data
        /// Increasing this value will make the algorithm search more before declaring a segment "incompressible"
        /// This could improve compression a bit, but will be slower on incompressible data
        /// The default value (6) is recommended.
        /// </summary>
        private const int NOTCOMPRESSIBLE_DETECTIONLEVEL = 6;

        #endregion

        #region consts

        private const int MINMATCH = 4;

#pragma warning disable 162, 429

        private const int SKIPSTRENGTH = NOTCOMPRESSIBLE_DETECTIONLEVEL > 2 ? NOTCOMPRESSIBLE_DETECTIONLEVEL : 2;
#pragma warning restore 162, 429

        private const int COPYLENGTH = 8;
        private const int LASTLITERALS = 5;
        private const int MFLIMIT = COPYLENGTH + MINMATCH;
        private const int MINLENGTH = MFLIMIT + 1;
        private const int MAXD_LOG = 16;
        private const int MAXD = 1 << MAXD_LOG;
        private const int MAXD_MASK = MAXD - 1;
        private const int MAX_DISTANCE = (1 << MAXD_LOG) - 1;
        private const int ML_BITS = 4;
        private const int ML_MASK = (1 << ML_BITS) - 1;
        private const int RUN_BITS = 8 - ML_BITS;
        private const int RUN_MASK = (1 << RUN_BITS) - 1;
        private const int STEPSIZE_64 = 8;
        private const int STEPSIZE_32 = 4;

        private const int LZ4_64KLIMIT = (1 << 16) + (MFLIMIT - 1);

        private const int HASH_LOG = MEMORY_USAGE - 2;
        private const int HASH_TABLESIZE = 1 << HASH_LOG;
        private const int HASH_ADJUST = (MINMATCH * 8) - HASH_LOG;

        private const int HASH64K_LOG = HASH_LOG + 1;
        private const int HASH64K_TABLESIZE = 1 << HASH64K_LOG;
        private const int HASH64K_ADJUST = (MINMATCH * 8) - HASH64K_LOG;

        private const int HASHHC_LOG = MAXD_LOG - 1;
        private const int HASHHC_TABLESIZE = 1 << HASHHC_LOG;
        private const int HASHHC_ADJUST = (MINMATCH * 8) - HASHHC_LOG;
        ////private const int HASHHC_MASK = HASHHC_TABLESIZE - 1;

        private const int MAX_NB_ATTEMPTS = 256;
        private const int OPTIMAL_ML = ML_MASK - 1 + MINMATCH;

        private const int BLOCK_COPY_LIMIT = 16;

        private static readonly int[] DECODER_TABLE_32 = { 0, 3, 2, 3, 0, 0, 0, 0 };
        private static readonly int[] DECODER_TABLE_64 = { 0, 0, 0, -1, 0, 1, 2, 3 };

        private static readonly int[] DEBRUIJN_TABLE_32 =
        {
            0, 0, 3, 0, 3, 1, 3, 0, 3, 2, 2, 1, 3, 2, 0, 1,
            3, 3, 1, 2, 2, 2, 2, 0, 3, 1, 2, 0, 1, 0, 1, 1,
        };

        private static readonly int[] DEBRUIJN_TABLE_64 =
        {
            0, 0, 0, 0, 0, 1, 1, 2, 0, 3, 1, 3, 1, 4, 2, 7,
            0, 2, 3, 6, 1, 5, 3, 5, 1, 3, 4, 4, 2, 5, 6, 7,
            7, 0, 1, 2, 3, 3, 4, 6, 2, 6, 5, 5, 3, 4, 5, 6,
            7, 1, 2, 4, 6, 4, 4, 5, 7, 2, 6, 5, 7, 6, 7, 7,
        };

        #endregion

        #region public interface (common)

        /// <summary>Gets maximum the length of the output.</summary>
        /// <param name="inputLength">Length of the input.</param>
        /// <returns>Maximum number of bytes needed for compressed buffer.</returns>
        public static int MaximumOutputLength(int inputLength)
        {
            return inputLength + (inputLength / 255) + 16;
        }

        #endregion

        #region internal interface (common)

        internal static void CheckArguments(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int outputLength)
        {
            if (inputLength == 0)
            {
                outputLength = 0;
                return;
            }

            if (input == null)
            {
                throw new ArgumentNullException("input");
            }

            if ((uint)inputOffset > (uint)input.Length)
            {
                throw new ArgumentOutOfRangeException("inputOffset");
            }

            if ((uint)inputLength > (uint)input.Length - (uint)inputOffset)
            {
                throw new ArgumentOutOfRangeException("inputLength");
            }

            if (output == null)
            {
                throw new ArgumentNullException("output");
            }

            if ((uint)outputOffset > (uint)output.Length)
            {
                throw new ArgumentOutOfRangeException("outputOffset");
            }

            if ((uint)outputLength > (uint)output.Length - (uint)outputOffset)
            {
                throw new ArgumentOutOfRangeException("outputLength");
            }
        }

        #endregion
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.cs.meta
================================================
fileFormatVersion: 2
guid: 467a42ca49e959542b69efdf5b046249
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Helper.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

namespace MessagePack.LZ4
{
    internal partial class LZ4Codec
    {
#if UNITY_2018_3_OR_NEWER

        // use 'Safe' code for Unity because in IL2CPP gots strange behaviour.

        public static int Encode(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int outputLength)
        {
            if (IntPtr.Size == 4)
            {
                return LZ4Codec.Encode32Safe(input, inputOffset, inputLength, output, outputOffset, outputLength);
            }
            else
            {
                return LZ4Codec.Encode64Safe(input, inputOffset, inputLength, output, outputOffset, outputLength);
            }
        }

        public static int Decode(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int outputLength)
        {
            if (IntPtr.Size == 4)
            {
                return LZ4Codec.Decode32Safe(input, inputOffset, inputLength, output, outputOffset, outputLength);
            }
            else
            {
                return LZ4Codec.Decode64Safe(input, inputOffset, inputLength, output, outputOffset, outputLength);
            }
        }

#endif

        internal static class HashTablePool
        {
            [ThreadStatic]
            private static ushort[] ushortPool;

            [ThreadStatic]
            private static uint[] uintPool;

            [ThreadStatic]
            private static int[] intPool;

            public static ushort[] GetUShortHashTablePool()
            {
                if (ushortPool == null)
                {
                    ushortPool = new ushort[HASH64K_TABLESIZE];
                }
                else
                {
                    Array.Clear(ushortPool, 0, ushortPool.Length);
                }

                return ushortPool;
            }

            public static uint[] GetUIntHashTablePool()
            {
                if (uintPool == null)
                {
                    uintPool = new uint[HASH_TABLESIZE];
                }
                else
                {
                    Array.Clear(uintPool, 0, uintPool.Length);
                }

                return uintPool;
            }

            public static int[] GetIntHashTablePool()
            {
                if (intPool == null)
                {
                    intPool = new int[HASH_TABLESIZE];
                }
                else
                {
                    Array.Clear(intPool, 0, intPool.Length);
                }

                return intPool;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Helper.cs.meta
================================================
fileFormatVersion: 2
guid: 135c503530b89854282de4c339084d74
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if UNITY_2018_3_OR_NEWER

#region license

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

using System;
using System.Diagnostics;

namespace MessagePack.LZ4
{
    /// <summary>Safe LZ4 codec.</summary>
    internal partial class LZ4Codec
    {
#region Helper

        [Conditional("DEBUG")]
        private static void Assert(bool condition, string errorMessage)
        {
            if (!condition)
            {
                throw new ArgumentException(errorMessage);
            }

            Debug.Assert(condition, errorMessage);
        }

#endregion

#region Byte manipulation

        internal static void Poke2(byte[] buffer, int offset, ushort value)
        {
            buffer[offset] = (byte)value;
            buffer[offset + 1] = (byte)(value >> 8);
        }

        internal static ushort Peek2(byte[] buffer, int offset)
        {
            // NOTE: It's faster than BitConverter.ToUInt16 (suprised? me too)
            return (ushort)(((uint)buffer[offset]) | ((uint)buffer[offset + 1] << 8));
        }

        internal static uint Peek4(byte[] buffer, int offset)
        {
            // NOTE: It's faster than BitConverter.ToUInt32 (suprised? me too)
            return
                ((uint)buffer[offset]) |
                ((uint)buffer[offset + 1] << 8) |
                ((uint)buffer[offset + 2] << 16) |
                ((uint)buffer[offset + 3] << 24);
        }

        private static uint Xor4(byte[] buffer, int offset1, int offset2)
        {
            // return Peek4(buffer, offset1) ^ Peek4(buffer, offset2);
            var value1 =
                ((uint)buffer[offset1]) |
                ((uint)buffer[offset1 + 1] << 8) |
                ((uint)buffer[offset1 + 2] << 16) |
                ((uint)buffer[offset1 + 3] << 24);
            var value2 =
                ((uint)buffer[offset2]) |
                ((uint)buffer[offset2 + 1] << 8) |
                ((uint)buffer[offset2 + 2] << 16) |
                ((uint)buffer[offset2 + 3] << 24);
            return value1 ^ value2;
        }

        private static ulong Xor8(byte[] buffer, int offset1, int offset2)
        {
            // return Peek8(buffer, offset1) ^ Peek8(buffer, offset2);
            var value1 =
                ((ulong)buffer[offset1]) |
                ((ulong)buffer[offset1 + 1] << 8) |
                ((ulong)buffer[offset1 + 2] << 16) |
                ((ulong)buffer[offset1 + 3] << 24) |
                ((ulong)buffer[offset1 + 4] << 32) |
                ((ulong)buffer[offset1 + 5] << 40) |
                ((ulong)buffer[offset1 + 6] << 48) |
                ((ulong)buffer[offset1 + 7] << 56);
            var value2 =
                ((ulong)buffer[offset2]) |
                ((ulong)buffer[offset2 + 1] << 8) |
                ((ulong)buffer[offset2 + 2] << 16) |
                ((ulong)buffer[offset2 + 3] << 24) |
                ((ulong)buffer[offset2 + 4] << 32) |
                ((ulong)buffer[offset2 + 5] << 40) |
                ((ulong)buffer[offset2 + 6] << 48) |
                ((ulong)buffer[offset2 + 7] << 56);
            return value1 ^ value2;
        }

        private static bool Equal2(byte[] buffer, int offset1, int offset2)
        {
            // return Peek2(buffer, offset1) == Peek2(buffer, offset2);
            if (buffer[offset1] != buffer[offset2])
            {
                return false;
            }

            return buffer[offset1 + 1] == buffer[offset2 + 1];
        }

        private static bool Equal4(byte[] buffer, int offset1, int offset2)
        {
            // return Peek4(buffer, offset1) == Peek4(buffer, offset2);
            if (buffer[offset1] != buffer[offset2])
            {
                return false;
            }

            if (buffer[offset1 + 1] != buffer[offset2 + 1])
            {
                return false;
            }

            if (buffer[offset1 + 2] != buffer[offset2 + 2])
            {
                return false;
            }

            return buffer[offset1 + 3] == buffer[offset2 + 3];
        }

#endregion

#region Byte block copy

        private static void Copy4(byte[] buf, int src, int dst)
        {
            Assert(dst > src, "Copying backwards is not implemented");
            buf[dst + 3] = buf[src + 3];
            buf[dst + 2] = buf[src + 2];
            buf[dst + 1] = buf[src + 1];
            buf[dst] = buf[src];
        }

        private static void Copy8(byte[] buf, int src, int dst)
        {
            Assert(dst > src, "Copying backwards is not implemented");
            buf[dst + 7] = buf[src + 7];
            buf[dst + 6] = buf[src + 6];
            buf[dst + 5] = buf[src + 5];
            buf[dst + 4] = buf[src + 4];
            buf[dst + 3] = buf[src + 3];
            buf[dst + 2] = buf[src + 2];
            buf[dst + 1] = buf[src + 1];
            buf[dst] = buf[src];
        }

        private static void BlockCopy(byte[] src, int src_0, byte[] dst, int dst_0, int len)
        {
            Assert(src != dst, "BlockCopy does not handle copying to the same buffer");

            if (len >= BLOCK_COPY_LIMIT)
            {
                Buffer.BlockCopy(src, src_0, dst, dst_0, len);
            }
            else
            {
                while (len >= 8)
                {
                    dst[dst_0] = src[src_0];
                    dst[dst_0 + 1] = src[src_0 + 1];
                    dst[dst_0 + 2] = src[src_0 + 2];
                    dst[dst_0 + 3] = src[src_0 + 3];
                    dst[dst_0 + 4] = src[src_0 + 4];
                    dst[dst_0 + 5] = src[src_0 + 5];
                    dst[dst_0 + 6] = src[src_0 + 6];
                    dst[dst_0 + 7] = src[src_0 + 7];
                    len -= 8;
                    src_0 += 8;
                    dst_0 += 8;
                }

                while (len >= 4)
                {
                    dst[dst_0] = src[src_0];
                    dst[dst_0 + 1] = src[src_0 + 1];
                    dst[dst_0 + 2] = src[src_0 + 2];
                    dst[dst_0 + 3] = src[src_0 + 3];
                    len -= 4;
                    src_0 += 4;
                    dst_0 += 4;
                }

                while (len-- > 0)
                {
                    dst[dst_0++] = src[src_0++];
                }
            }
        }

        private static int WildCopy(byte[] src, int src_0, byte[] dst, int dst_0, int dst_end)
        {
            var len = dst_end - dst_0;

            Assert(src != dst, "BlockCopy does not handle copying to the same buffer");
            Assert(len > 0, "Length have to be greater than 0");

            if (len >= BLOCK_COPY_LIMIT)
            {
                Buffer.BlockCopy(src, src_0, dst, dst_0, len);
            }
            else
            {
                // apparently (tested) this is an overkill
                // it seems to be faster without this 8-byte loop
                ////while (len >= 8)
                ////{
                ////	dst[dst_0] = src[src_0];
                ////	dst[dst_0 + 1] = src[src_0 + 1];
                ////	dst[dst_0 + 2] = src[src_0 + 2];
                ////	dst[dst_0 + 3] = src[src_0 + 3];
                ////	dst[dst_0 + 4] = src[src_0 + 4];
                ////	dst[dst_0 + 5] = src[src_0 + 5];
                ////	dst[dst_0 + 6] = src[src_0 + 6];
                ////	dst[dst_0 + 7] = src[src_0 + 7];
                ////	len -= 8; src_0 += 8; dst_0 += 8;
                ////}

                while (len >= 4)
                {
                    dst[dst_0] = src[src_0];
                    dst[dst_0 + 1] = src[src_0 + 1];
                    dst[dst_0 + 2] = src[src_0 + 2];
                    dst[dst_0 + 3] = src[src_0 + 3];
                    len -= 4;
                    src_0 += 4;
                    dst_0 += 4;
                }

                while (len-- > 0)
                {
                    dst[dst_0++] = src[src_0++];
                }
            }

            return len;
        }

        private static int SecureCopy(byte[] buffer, int src, int dst, int dst_end)
        {
            var diff = dst - src;
            var length = dst_end - dst;
            var len = length;

            Assert(diff >= 4, "Target must be at least 4 bytes further than source");
            Assert(BLOCK_COPY_LIMIT > 4, "This method requires BLOCK_COPY_LIMIT > 4");
            Assert(len > 0, "Length have to be greater than 0");

            if (diff >= BLOCK_COPY_LIMIT)
            {
                if (diff >= length)
                {
                    Buffer.BlockCopy(buffer, src, buffer, dst, length);
                    return length; // done
                }

                do
                {
                    Buffer.BlockCopy(buffer, src, buffer, dst, diff);
                    src += diff;
                    dst += diff;
                    len -= diff;
                }
                while (len >= diff);
            }

            // apparently (tested) this is an overkill
            // it seems to be faster without this 8-byte loop
            ////while (len >= 8)
            ////{
            ////	buffer[dst] = buffer[src];
            ////	buffer[dst + 1] = buffer[src + 1];
            ////	buffer[dst + 2] = buffer[src + 2];
            ////	buffer[dst + 3] = buffer[src + 3];
            ////	buffer[dst + 4] = buffer[src + 4];
            ////	buffer[dst + 5] = buffer[src + 5];
            ////	buffer[dst + 6] = buffer[src + 6];
            ////	buffer[dst + 7] = buffer[src + 7];
            ////	dst += 8; src += 8; len -= 8;
            ////}

            while (len >= 4)
            {
                buffer[dst] = buffer[src];
                buffer[dst + 1] = buffer[src + 1];
                buffer[dst + 2] = buffer[src + 2];
                buffer[dst + 3] = buffer[src + 3];
                dst += 4;
                src += 4;
                len -= 4;
            }

            while (len-- > 0)
            {
                buffer[dst++] = buffer[src++];
            }

            return length; // done
        }

#endregion

        /// <summary>Encodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="inputOffset">The input offset.</param>
        /// <param name="inputLength">Length of the input.</param>
        /// <param name="output">The output.</param>
        /// <param name="outputOffset">The output offset.</param>
        /// <param name="outputLength">Length of the output.</param>
        /// <returns>Number of bytes written.</returns>
        public static int Encode32Safe(
            byte[] input,
            int inputOffset,
            int inputLength,
            byte[] output,
            int outputOffset,
            int outputLength)
        {
            CheckArguments(input, inputOffset, inputLength, output, outputOffset, outputLength);
            if (outputLength == 0)
            {
                return 0;
            }

            if (inputLength < LZ4_64KLIMIT)
            {
                var hashTable = HashTablePool.GetUShortHashTablePool();
                return LZ4_compress64kCtx_safe32(hashTable, input, output, inputOffset, outputOffset, inputLength, outputLength);
            }
            else
            {
                var hashTable = HashTablePool.GetIntHashTablePool();
                return LZ4_compressCtx_safe32(hashTable, input, output, inputOffset, outputOffset, inputLength, outputLength);
            }
        }

        /// <summary>Encodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="inputOffset">The input offset.</param>
        /// <param name="inputLength">Length of the input.</param>
        /// <param name="output">The output.</param>
        /// <param name="outputOffset">The output offset.</param>
        /// <param name="outputLength">Length of the output.</param>
        /// <returns>Number of bytes written.</returns>
        public static int Encode64Safe(
            byte[] input,
            int inputOffset,
            int inputLength,
            byte[] output,
            int outputOffset,
            int outputLength)
        {
            CheckArguments(input, inputOffset, inputLength, output, outputOffset, outputLength);
            if (outputLength == 0)
            {
                return 0;
            }

            if (inputLength < LZ4_64KLIMIT)
            {
                var hashTable = HashTablePool.GetUShortHashTablePool();
                return LZ4_compress64kCtx_safe64(hashTable, input, output, inputOffset, outputOffset, inputLength, outputLength);
            }
            else
            {
                var hashTable = HashTablePool.GetIntHashTablePool();
                return LZ4_compressCtx_safe64(hashTable, input, output, inputOffset, outputOffset, inputLength, outputLength);
            }
        }

        /// <summary>Decodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="inputOffset">The input offset.</param>
        /// <param name="inputLength">Length of the input.</param>
        /// <param name="output">The output.</param>
        /// <param name="outputOffset">The output offset.</param>
        /// <param name="outputLength">Length of the output.</param>
        /// <returns>Number of bytes written.</returns>
        public static int Decode32Safe(
            byte[] input,
            int inputOffset,
            int inputLength,
            byte[] output,
            int outputOffset,
            int outputLength)
        {
            CheckArguments(input, inputOffset, inputLength, output, outputOffset, outputLength);

            if (outputLength == 0)
            {
                return 0;
            }

            var length = LZ4_uncompress_safe32(input, output, inputOffset, outputOffset, outputLength);
            if (length != inputLength)
            {
                throw new MessagePackSerializationException("LZ4 block is corrupted, or invalid length has been given.");
            }

            return outputLength;
        }

        /// <summary>Decodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="inputOffset">The input offset.</param>
        /// <param name="inputLength">Length of the input.</param>
        /// <param name="output">The output.</param>
        /// <param name="outputOffset">The output offset.</param>
        /// <param name="outputLength">Length of the output.</param>
        /// <returns>Number of bytes written.</returns>
        public static int Decode64Safe(
            byte[] input,
            int inputOffset,
            int inputLength,
            byte[] output,
            int outputOffset,
            int outputLength)
        {
            CheckArguments(input, inputOffset, inputLength, output, outputOffset, outputLength);

            if (outputLength == 0)
            {
                return 0;
            }

            var length = LZ4_uncompress_safe64(input, output, inputOffset, outputOffset, outputLength);
            if (length != inputLength)
            {
                throw new MessagePackSerializationException("LZ4 block is corrupted, or invalid length has been given.");
            }

            return outputLength;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe.cs.meta
================================================
fileFormatVersion: 2
guid: bfa77bfa8e74a914cada4663d406de46
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe32.Dirty.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if UNITY_2018_3_OR_NEWER

#region LZ4 original

/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-2012, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/

#endregion

#region LZ4 port

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

#pragma warning disable SA1312 // Variable names should begin with lower-case letter

namespace MessagePack.LZ4
{
    internal partial class LZ4Codec
    {
#region LZ4_compressCtx

        private static int LZ4_compressCtx_safe32(
            int[] hash_table,
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                var debruijn32 = DEBRUIJN_TABLE_32;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                var src_base = src_0;
                var src_anchor = src_p;
                var src_end = src_p + src_len;
                var src_mflimit = src_end - MFLIMIT;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_maxlen;

                var src_LASTLITERALS = src_end - LASTLITERALS;
                var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_32 - 1);
                var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                int length;

                uint h, h_fwd;

                // Init
                if (src_len < MINLENGTH)
                {
                    goto _last_literals;
                }

                // First Byte
                hash_table[(Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST] = src_p - src_base;
                src_p++;
                h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;

                // Main Loop
                while (true)
                {
                    var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                    var src_p_fwd = src_p;
                    int src_ref;
                    int dst_token;

                    // Find a match
                    do
                    {
                        h = h_fwd;
                        var step = findMatchAttempts++ >> SKIPSTRENGTH;
                        src_p = src_p_fwd;
                        src_p_fwd = src_p + step;

                        if (src_p_fwd > src_mflimit)
                        {
                            goto _last_literals;
                        }

                        h_fwd = (Peek4(src, src_p_fwd) * 2654435761u) >> HASH_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = src_p - src_base;
                    }
                    while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src, src_ref, src_p)));

                    // Catch up
                    while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))
                    {
                        src_p--;
                        src_ref--;
                    }

                    // Encode Literal length
                    length = src_p - src_anchor;
                    dst_token = dst_p++;

                    if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= RUN_MASK)
                    {
                        var len = length - RUN_MASK;
                        dst[dst_token] = RUN_MASK << ML_BITS;
                        if (len > 254)
                        {
                            do
                            {
                                dst[dst_p++] = 255;
                                len -= 255;
                            }
                            while (len > 254);
                            dst[dst_p++] = (byte)len;
                            BlockCopy(src, src_anchor, dst, dst_p, length);
                            dst_p += length;
                            goto _next_match;
                        }
                        else
                        {
                            dst[dst_p++] = (byte)len;
                        }
                    }
                    else
                    {
                        dst[dst_token] = (byte)(length << ML_BITS);
                    }

                    // Copy Literals
                    if (length > 0)
                    {
                        _i = dst_p + length;
                        WildCopy(src, src_anchor, dst, dst_p, _i);
                        dst_p = _i;
                    }

_next_match:

// Encode Offset
                    Poke2(dst, dst_p, (ushort)(src_p - src_ref));
                    dst_p += 2;

                    // Start Counting
                    src_p += MINMATCH;
                    src_ref += MINMATCH; // MinMatch already verified
                    src_anchor = src_p;

                    while (src_p < src_LASTLITERALS_STEPSIZE_1)
                    {
                        var diff = (int)Xor4(src, src_ref, src_p);
                        if (diff == 0)
                        {
                            src_p += STEPSIZE_32;
                            src_ref += STEPSIZE_32;
                            continue;
                        }

                        src_p += debruijn32[((uint)(diff & -diff) * 0x077CB531u) >> 27];
                        goto _endCount;
                    }

                    if ((src_p < src_LASTLITERALS_1) && Equal2(src, src_ref, src_p))
                    {
                        src_p += 2;
                        src_ref += 2;
                    }

                    if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p]))
                    {
                        src_p++;
                    }

_endCount:

// Encode MatchLength
                    length = src_p - src_anchor;

                    if (dst_p + (length >> 8) > dst_LASTLITERALS_1)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= ML_MASK)
                    {
                        dst[dst_token] += ML_MASK;
                        length -= ML_MASK;
                        for (; length > 509; length -= 510)
                        {
                            dst[dst_p++] = 255;
                            dst[dst_p++] = 255;
                        }

                        if (length > 254)
                        {
                            length -= 255;
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)length;
                    }
                    else
                    {
                        dst[dst_token] += (byte)length;
                    }

                    // Test end of chunk
                    if (src_p > src_mflimit)
                    {
                        src_anchor = src_p;
                        break;
                    }

                    // Fill table
                    hash_table[(Peek4(src, src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;

                    // Test next position
                    h = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;
                    src_ref = src_base + hash_table[h];
                    hash_table[h] = src_p - src_base;

                    if ((src_ref > src_p - (MAX_DISTANCE + 1)) && Equal4(src, src_ref, src_p))
                    {
                        dst_token = dst_p++;
                        dst[dst_token] = 0;
                        goto _next_match;
                    }

                    // Prepare next loop
                    src_anchor = src_p++;
                    h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;
                }

_last_literals:

// Encode Last Literals
                {
                    var lastRun = src_end - src_anchor;

                    if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end)
                    {
                        return 0;
                    }

                    if (lastRun >= RUN_MASK)
                    {
                        dst[dst_p++] = RUN_MASK << ML_BITS;
                        lastRun -= RUN_MASK;
                        for (; lastRun > 254; lastRun -= 255)
                        {
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)lastRun;
                    }
                    else
                    {
                        dst[dst_p++] = (byte)(lastRun << ML_BITS);
                    }

                    BlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor);
                    dst_p += src_end - src_anchor;
                }

                // End
                return dst_p - dst_0;
            }
        }

#endregion

#region LZ4_compress64kCtx

        private static int LZ4_compress64kCtx_safe32(
            ushort[] hash_table,
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                var debruijn32 = DEBRUIJN_TABLE_32;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                var src_anchor = src_p;
                var src_base = src_p;
                var src_end = src_p + src_len;
                var src_mflimit = src_end - MFLIMIT;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_maxlen;

                var src_LASTLITERALS = src_end - LASTLITERALS;
                var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_32 - 1);
                var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                int len, length;

                uint h, h_fwd;

                // Init
                if (src_len < MINLENGTH)
                {
                    goto _last_literals;
                }

                // First Byte
                src_p++;
                h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;

                // Main Loop
                while (true)
                {
                    var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                    var src_p_fwd = src_p;
                    int src_ref;
                    int dst_token;

                    // Find a match
                    do
                    {
                        h = h_fwd;
                        var step = findMatchAttempts++ >> SKIPSTRENGTH;
                        src_p = src_p_fwd;
                        src_p_fwd = src_p + step;

                        if (src_p_fwd > src_mflimit)
                        {
                            goto _last_literals;
                        }

                        h_fwd = (Peek4(src, src_p_fwd) * 2654435761u) >> HASH64K_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = (ushort)(src_p - src_base);
                    }
                    while (!Equal4(src, src_ref, src_p));

                    // Catch up
                    while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))
                    {
                        src_p--;
                        src_ref--;
                    }

                    // Encode Literal length
                    length = src_p - src_anchor;
                    dst_token = dst_p++;

                    if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= RUN_MASK)
                    {
                        len = length - RUN_MASK;
                        dst[dst_token] = RUN_MASK << ML_BITS;
                        if (len > 254)
                        {
                            do
                            {
                                dst[dst_p++] = 255;
                                len -= 255;
                            }
                            while (len > 254);
                            dst[dst_p++] = (byte)len;
                            BlockCopy(src, src_anchor, dst, dst_p, length);
                            dst_p += length;
                            goto _next_match;
                        }
                        else
                        {
                            dst[dst_p++] = (byte)len;
                        }
                    }
                    else
                    {
                        dst[dst_token] = (byte)(length << ML_BITS);
                    }

                    // Copy Literals
                    if (length > 0)
                    {
                        _i = dst_p + length;
                        WildCopy(src, src_anchor, dst, dst_p, _i);
                        dst_p = _i;
                    }

_next_match:

// Encode Offset
                    Poke2(dst, dst_p, (ushort)(src_p - src_ref));
                    dst_p += 2;

                    // Start Counting
                    src_p += MINMATCH;
                    src_ref += MINMATCH; // MinMatch verified
                    src_anchor = src_p;

                    while (src_p < src_LASTLITERALS_STEPSIZE_1)
                    {
                        var diff = (int)Xor4(src, src_ref, src_p);
                        if (diff == 0)
                        {
                            src_p += STEPSIZE_32;
                            src_ref += STEPSIZE_32;
                            continue;
                        }

                        src_p += debruijn32[((uint)(diff & -diff) * 0x077CB531u) >> 27];
                        goto _endCount;
                    }

                    if ((src_p < src_LASTLITERALS_1) && Equal2(src, src_ref, src_p))
                    {
                        src_p += 2;
                        src_ref += 2;
                    }

                    if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p]))
                    {
                        src_p++;
                    }

_endCount:

// Encode MatchLength
                    len = src_p - src_anchor;

                    if (dst_p + (len >> 8) > dst_LASTLITERALS_1)
                    {
                        return 0; // Check output limit
                    }

                    if (len >= ML_MASK)
                    {
                        dst[dst_token] += ML_MASK;
                        len -= ML_MASK;
                        for (; len > 509; len -= 510)
                        {
                            dst[dst_p++] = 255;
                            dst[dst_p++] = 255;
                        }

                        if (len > 254)
                        {
                            len -= 255;
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)len;
                    }
                    else
                    {
                        dst[dst_token] += (byte)len;
                    }

                    // Test end of chunk
                    if (src_p > src_mflimit)
                    {
                        src_anchor = src_p;
                        break;
                    }

                    // Fill table
                    hash_table[(Peek4(src, src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);

                    // Test next position
                    h = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;
                    src_ref = src_base + hash_table[h];
                    hash_table[h] = (ushort)(src_p - src_base);

                    if (Equal4(src, src_ref, src_p))
                    {
                        dst_token = dst_p++;
                        dst[dst_token] = 0;
                        goto _next_match;
                    }

                    // Prepare next loop
                    src_anchor = src_p++;
                    h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;
                }

_last_literals:

// Encode Last Literals
                var lastRun = src_end - src_anchor;
                if (dst_p + lastRun + 1 + ((lastRun - RUN_MASK + 255) / 255) > dst_end)
                {
                    return 0;
                }

                if (lastRun >= RUN_MASK)
                {
                    dst[dst_p++] = RUN_MASK << ML_BITS;
                    lastRun -= RUN_MASK;
                    for (; lastRun > 254; lastRun -= 255)
                    {
                        dst[dst_p++] = 255;
                    }

                    dst[dst_p++] = (byte)lastRun;
                }
                else
                {
                    dst[dst_p++] = (byte)(lastRun << ML_BITS);
                }

                BlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor);
                dst_p += src_end - src_anchor;

                // End
                return dst_p - dst_0;
            }
        }

#endregion

#region LZ4_uncompress

        private static int LZ4_uncompress_safe32(
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int dst_len)
        {
            unchecked
            {
                var dec32table = DECODER_TABLE_32;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                int dst_ref;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_len;
                int dst_cpy;

                var dst_LASTLITERALS = dst_end - LASTLITERALS;
                var dst_COPYLENGTH = dst_end - COPYLENGTH;
                var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_32 - 4);

                byte token;

                // Main Loop
                while (true)
                {
                    int length;

                    // get runlength
                    token = src[src_p++];
                    if ((length = token >> ML_BITS) == RUN_MASK)
                    {
                        int len;
                        for (; (len = src[src_p++]) == 255; length += 255)
                        {
                            /* do nothing */
                        }

                        length += len;
                    }

                    // copy literals
                    dst_cpy = dst_p + length;

                    if (dst_cpy > dst_COPYLENGTH)
                    {
                        if (dst_cpy != dst_end)
                        {
                            goto _output_error; // Error : not enough place for another match (min 4) + 5 literals
                        }

                        BlockCopy(src, src_p, dst, dst_p, length);
                        src_p += length;
                        break; // EOF
                    }

                    if (dst_p < dst_cpy)
                    {
                        _i = WildCopy(src, src_p, dst, dst_p, dst_cpy);
                        src_p += _i;
                        dst_p += _i;
                    }

                    src_p -= dst_p - dst_cpy;
                    dst_p = dst_cpy;

                    // get offset
                    dst_ref = dst_cpy - Peek2(src, src_p);
                    src_p += 2;
                    if (dst_ref < dst_0)
                    {
                        goto _output_error; // Error : offset outside destination buffer
                    }

                    // get matchlength
                    if ((length = token & ML_MASK) == ML_MASK)
                    {
                        for (; src[src_p] == 255; length += 255)
                        {
                            src_p++;
                        }

                        length += src[src_p++];
                    }

                    // copy repeated sequence
                    if ((dst_p - dst_ref) < STEPSIZE_32)
                    {
                        const int dec64 = 0;
                        dst[dst_p + 0] = dst[dst_ref + 0];
                        dst[dst_p + 1] = dst[dst_ref + 1];
                        dst[dst_p + 2] = dst[dst_ref + 2];
                        dst[dst_p + 3] = dst[dst_ref + 3];
                        dst_p += 4;
                        dst_ref += 4;
                        dst_ref -= dec32table[dst_p - dst_ref];
                        Copy4(dst, dst_ref, dst_p);
                        dst_p += STEPSIZE_32 - 4;
                        dst_ref -= dec64;
                    }
                    else
                    {
                        Copy4(dst, dst_ref, dst_p);
                        dst_p += 4;
                        dst_ref += 4;
                    }

                    dst_cpy = dst_p + length - (STEPSIZE_32 - 4);

                    if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)
                    {
                        if (dst_cpy > dst_LASTLITERALS)
                        {
                            goto _output_error; // Error : last 5 bytes must be literals
                        }

                        if (dst_p < dst_COPYLENGTH)
                        {
                            _i = SecureCopy(dst, dst_ref, dst_p, dst_COPYLENGTH);
                            dst_ref += _i;
                            dst_p += _i;
                        }

                        while (dst_p < dst_cpy)
                        {
                            dst[dst_p++] = dst[dst_ref++];
                        }

                        dst_p = dst_cpy;
                        continue;
                    }

                    if (dst_p < dst_cpy)
                    {
                        SecureCopy(dst, dst_ref, dst_p, dst_cpy);
                    }

                    dst_p = dst_cpy; // correction
                }

                // end of decoding
                return src_p - src_0;

// write overflow error detected
_output_error:
                return -(src_p - src_0);
            }
        }

#endregion
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe32.Dirty.cs.meta
================================================
fileFormatVersion: 2
guid: e3af434f443715345a95c309036329e2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe64.Dirty.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if UNITY_2018_3_OR_NEWER

#region LZ4 original

/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-2012, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/

#endregion

#region LZ4 port

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

#pragma warning disable SA1312 // Variable names should begin with lower-case letter

namespace MessagePack.LZ4
{
    internal partial class LZ4Codec
    {
#region LZ4_compressCtx

        private static int LZ4_compressCtx_safe64(
            int[] hash_table,
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                var debruijn64 = DEBRUIJN_TABLE_64;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                var src_base = src_0;
                var src_anchor = src_p;
                var src_end = src_p + src_len;
                var src_mflimit = src_end - MFLIMIT;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_maxlen;

                var src_LASTLITERALS = src_end - LASTLITERALS;
                var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                var src_LASTLITERALS_3 = src_LASTLITERALS - 3;

                var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);
                var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                int length;

                uint h, h_fwd;

                // Init
                if (src_len < MINLENGTH)
                {
                    goto _last_literals;
                }

                // First Byte
                hash_table[(Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST] = src_p - src_base;
                src_p++;
                h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;

                // Main Loop
                while (true)
                {
                    var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                    var src_p_fwd = src_p;
                    int src_ref;
                    int dst_token;

                    // Find a match
                    do
                    {
                        h = h_fwd;
                        var step = findMatchAttempts++ >> SKIPSTRENGTH;
                        src_p = src_p_fwd;
                        src_p_fwd = src_p + step;

                        if (src_p_fwd > src_mflimit)
                        {
                            goto _last_literals;
                        }

                        h_fwd = (Peek4(src, src_p_fwd) * 2654435761u) >> HASH_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = src_p - src_base;
                    }
                    while ((src_ref < src_p - MAX_DISTANCE) || (!Equal4(src, src_ref, src_p)));

                    // Catch up
                    while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))
                    {
                        src_p--;
                        src_ref--;
                    }

                    // Encode Literal length
                    length = src_p - src_anchor;
                    dst_token = dst_p++;

                    if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= RUN_MASK)
                    {
                        var len = length - RUN_MASK;
                        dst[dst_token] = RUN_MASK << ML_BITS;
                        if (len > 254)
                        {
                            do
                            {
                                dst[dst_p++] = 255;
                                len -= 255;
                            }
                            while (len > 254);
                            dst[dst_p++] = (byte)len;
                            BlockCopy(src, src_anchor, dst, dst_p, length);
                            dst_p += length;
                            goto _next_match;
                        }
                        else
                        {
                            dst[dst_p++] = (byte)len;
                        }
                    }
                    else
                    {
                        dst[dst_token] = (byte)(length << ML_BITS);
                    }

                    // Copy Literals
                    if (length > 0)
                    {
                        _i = dst_p + length;
                        WildCopy(src, src_anchor, dst, dst_p, _i);
                        dst_p = _i;
                    }

_next_match:

// Encode Offset
                    Poke2(dst, dst_p, (ushort)(src_p - src_ref));
                    dst_p += 2;

                    // Start Counting
                    src_p += MINMATCH;
                    src_ref += MINMATCH; // MinMatch already verified
                    src_anchor = src_p;

                    while (src_p < src_LASTLITERALS_STEPSIZE_1)
                    {
                        var diff = (long)Xor8(src, src_ref, src_p);
                        if (diff == 0)
                        {
                            src_p += STEPSIZE_64;
                            src_ref += STEPSIZE_64;
                            continue;
                        }

                        src_p += debruijn64[((ulong)(diff & -diff) * 0x0218A392CDABBD3FL) >> 58];
                        goto _endCount;
                    }

                    if ((src_p < src_LASTLITERALS_3) && Equal4(src, src_ref, src_p))
                    {
                        src_p += 4;
                        src_ref += 4;
                    }

                    if ((src_p < src_LASTLITERALS_1) && Equal2(src, src_ref, src_p))
                    {
                        src_p += 2;
                        src_ref += 2;
                    }

                    if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p]))
                    {
                        src_p++;
                    }

_endCount:

// Encode MatchLength
                    length = src_p - src_anchor;

                    if (dst_p + (length >> 8) > dst_LASTLITERALS_1)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= ML_MASK)
                    {
                        dst[dst_token] += ML_MASK;
                        length -= ML_MASK;
                        for (; length > 509; length -= 510)
                        {
                            dst[dst_p++] = 255;
                            dst[dst_p++] = 255;
                        }

                        if (length > 254)
                        {
                            length -= 255;
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)length;
                    }
                    else
                    {
                        dst[dst_token] += (byte)length;
                    }

                    // Test end of chunk
                    if (src_p > src_mflimit)
                    {
                        src_anchor = src_p;
                        break;
                    }

                    // Fill table
                    hash_table[(Peek4(src, src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;

                    // Test next position
                    h = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;
                    src_ref = src_base + hash_table[h];
                    hash_table[h] = src_p - src_base;

                    if ((src_ref > src_p - (MAX_DISTANCE + 1)) && Equal4(src, src_ref, src_p))
                    {
                        dst_token = dst_p++;
                        dst[dst_token] = 0;
                        goto _next_match;
                    }

                    // Prepare next loop
                    src_anchor = src_p++;
                    h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH_ADJUST;
                }

_last_literals:

// Encode Last Literals
                {
                    var lastRun = src_end - src_anchor;

                    if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end)
                    {
                        return 0;
                    }

                    if (lastRun >= RUN_MASK)
                    {
                        dst[dst_p++] = RUN_MASK << ML_BITS;
                        lastRun -= RUN_MASK;
                        for (; lastRun > 254; lastRun -= 255)
                        {
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)lastRun;
                    }
                    else
                    {
                        dst[dst_p++] = (byte)(lastRun << ML_BITS);
                    }

                    BlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor);
                    dst_p += src_end - src_anchor;
                }

                // End
                return dst_p - dst_0;
            }
        }

#endregion

#region LZ4_compress64kCtx

        private static int LZ4_compress64kCtx_safe64(
            ushort[] hash_table,
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                var debruijn64 = DEBRUIJN_TABLE_64;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                var src_anchor = src_p;
                var src_base = src_p;
                var src_end = src_p + src_len;
                var src_mflimit = src_end - MFLIMIT;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_maxlen;

                var src_LASTLITERALS = src_end - LASTLITERALS;
                var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                var src_LASTLITERALS_3 = src_LASTLITERALS - 3;

                var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);
                var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                int len, length;

                uint h, h_fwd;

                // Init
                if (src_len < MINLENGTH)
                {
                    goto _last_literals;
                }

                // First Byte
                src_p++;
                h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;

                // Main Loop
                while (true)
                {
                    var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                    var src_p_fwd = src_p;
                    int src_ref;
                    int dst_token;

                    // Find a match
                    do
                    {
                        h = h_fwd;
                        var step = findMatchAttempts++ >> SKIPSTRENGTH;
                        src_p = src_p_fwd;
                        src_p_fwd = src_p + step;

                        if (src_p_fwd > src_mflimit)
                        {
                            goto _last_literals;
                        }

                        h_fwd = (Peek4(src, src_p_fwd) * 2654435761u) >> HASH64K_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = (ushort)(src_p - src_base);
                    }
                    while (!Equal4(src, src_ref, src_p));

                    // Catch up
                    while ((src_p > src_anchor) && (src_ref > src_0) && (src[src_p - 1] == src[src_ref - 1]))
                    {
                        src_p--;
                        src_ref--;
                    }

                    // Encode Literal length
                    length = src_p - src_anchor;
                    dst_token = dst_p++;

                    if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                    {
                        return 0; // Check output limit
                    }

                    if (length >= RUN_MASK)
                    {
                        len = length - RUN_MASK;
                        dst[dst_token] = RUN_MASK << ML_BITS;
                        if (len > 254)
                        {
                            do
                            {
                                dst[dst_p++] = 255;
                                len -= 255;
                            }
                            while (len > 254);
                            dst[dst_p++] = (byte)len;
                            BlockCopy(src, src_anchor, dst, dst_p, length);
                            dst_p += length;
                            goto _next_match;
                        }
                        else
                        {
                            dst[dst_p++] = (byte)len;
                        }
                    }
                    else
                    {
                        dst[dst_token] = (byte)(length << ML_BITS);
                    }

                    // Copy Literals
                    if (length > 0)
                    {
                        _i = dst_p + length;
                        WildCopy(src, src_anchor, dst, dst_p, _i);
                        dst_p = _i;
                    }

_next_match:

// Encode Offset
                    Poke2(dst, dst_p, (ushort)(src_p - src_ref));
                    dst_p += 2;

                    // Start Counting
                    src_p += MINMATCH;
                    src_ref += MINMATCH; // MinMatch verified
                    src_anchor = src_p;

                    while (src_p < src_LASTLITERALS_STEPSIZE_1)
                    {
                        var diff = (long)Xor8(src, src_ref, src_p);
                        if (diff == 0)
                        {
                            src_p += STEPSIZE_64;
                            src_ref += STEPSIZE_64;
                            continue;
                        }

                        src_p += debruijn64[((ulong)(diff & -diff) * 0x0218A392CDABBD3FL) >> 58];
                        goto _endCount;
                    }

                    if ((src_p < src_LASTLITERALS_3) && Equal4(src, src_ref, src_p))
                    {
                        src_p += 4;
                        src_ref += 4;
                    }

                    if ((src_p < src_LASTLITERALS_1) && Equal2(src, src_ref, src_p))
                    {
                        src_p += 2;
                        src_ref += 2;
                    }

                    if ((src_p < src_LASTLITERALS) && (src[src_ref] == src[src_p]))
                    {
                        src_p++;
                    }

_endCount:

// Encode MatchLength
                    len = src_p - src_anchor;

                    if (dst_p + (len >> 8) > dst_LASTLITERALS_1)
                    {
                        return 0; // Check output limit
                    }

                    if (len >= ML_MASK)
                    {
                        dst[dst_token] += ML_MASK;
                        len -= ML_MASK;
                        for (; len > 509; len -= 510)
                        {
                            dst[dst_p++] = 255;
                            dst[dst_p++] = 255;
                        }

                        if (len > 254)
                        {
                            len -= 255;
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)len;
                    }
                    else
                    {
                        dst[dst_token] += (byte)len;
                    }

                    // Test end of chunk
                    if (src_p > src_mflimit)
                    {
                        src_anchor = src_p;
                        break;
                    }

                    // Fill table
                    hash_table[(Peek4(src, src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);

                    // Test next position
                    h = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;
                    src_ref = src_base + hash_table[h];
                    hash_table[h] = (ushort)(src_p - src_base);

                    if (Equal4(src, src_ref, src_p))
                    {
                        dst_token = dst_p++;
                        dst[dst_token] = 0;
                        goto _next_match;
                    }

                    // Prepare next loop
                    src_anchor = src_p++;
                    h_fwd = (Peek4(src, src_p) * 2654435761u) >> HASH64K_ADJUST;
                }

_last_literals:

// Encode Last Literals
                {
                    var lastRun = src_end - src_anchor;
                    if (dst_p + lastRun + 1 + ((lastRun - RUN_MASK + 255) / 255) > dst_end)
                    {
                        return 0;
                    }

                    if (lastRun >= RUN_MASK)
                    {
                        dst[dst_p++] = RUN_MASK << ML_BITS;
                        lastRun -= RUN_MASK;
                        for (; lastRun > 254; lastRun -= 255)
                        {
                            dst[dst_p++] = 255;
                        }

                        dst[dst_p++] = (byte)lastRun;
                    }
                    else
                    {
                        dst[dst_p++] = (byte)(lastRun << ML_BITS);
                    }

                    BlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor);
                    dst_p += src_end - src_anchor;
                }

                // End
                return dst_p - dst_0;
            }
        }

#endregion

#region LZ4_uncompress

        private static int LZ4_uncompress_safe64(
            byte[] src,
            byte[] dst,
            int src_0,
            int dst_0,
            int dst_len)
        {
            unchecked
            {
                var dec32table = DECODER_TABLE_32;
                var dec64table = DECODER_TABLE_64;
                int _i;

                // ---- preprocessed source start here ----
                // r93
                var src_p = src_0;
                int dst_ref;

                var dst_p = dst_0;
                var dst_end = dst_p + dst_len;
                int dst_cpy;

                var dst_LASTLITERALS = dst_end - LASTLITERALS;
                var dst_COPYLENGTH = dst_end - COPYLENGTH;
                var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);

                uint token;

                // Main Loop
                while (true)
                {
                    int length;

                    // get runlength
                    token = src[src_p++];
                    if ((length = (byte)(token >> ML_BITS)) == RUN_MASK)
                    {
                        int len;
                        for (; (len = src[src_p++]) == 255; length += 255)
                        {
                            /* do nothing */
                        }

                        length += len;
                    }

                    // copy literals
                    dst_cpy = dst_p + length;

                    if (dst_cpy > dst_COPYLENGTH)
                    {
                        if (dst_cpy != dst_end)
                        {
                            goto _output_error; // Error : not enough place for another match (min 4) + 5 literals
                        }

                        BlockCopy(src, src_p, dst, dst_p, length);
                        src_p += length;
                        break; // EOF
                    }

                    if (dst_p < dst_cpy)
                    {
                        _i = WildCopy(src, src_p, dst, dst_p, dst_cpy);
                        src_p += _i;
                        dst_p += _i;
                    }

                    src_p -= dst_p - dst_cpy;
                    dst_p = dst_cpy;

                    // get offset
                    dst_ref = dst_cpy - Peek2(src, src_p);
                    src_p += 2;
                    if (dst_ref < dst_0)
                    {
                        goto _output_error; // Error : offset outside destination buffer
                    }

                    // get matchlength
                    if ((length = (byte)(token & ML_MASK)) == ML_MASK)
                    {
                        for (; src[src_p] == 255; length += 255)
                        {
                            src_p++;
                        }

                        length += src[src_p++];
                    }

                    // copy repeated sequence
                    if ((dst_p - dst_ref) < STEPSIZE_64)
                    {
                        var dec64 = dec64table[dst_p - dst_ref];

                        dst[dst_p + 0] = dst[dst_ref + 0];
                        dst[dst_p + 1] = dst[dst_ref + 1];
                        dst[dst_p + 2] = dst[dst_ref + 2];
                        dst[dst_p + 3] = dst[dst_ref + 3];
                        dst_p += 4;
                        dst_ref += 4;
                        dst_ref -= dec32table[dst_p - dst_ref];
                        Copy4(dst, dst_ref, dst_p);
                        dst_p += STEPSIZE_64 - 4;
                        dst_ref -= dec64;
                    }
                    else
                    {
                        Copy8(dst, dst_ref, dst_p);
                        dst_p += 8;
                        dst_ref += 8;
                    }

                    dst_cpy = dst_p + length - (STEPSIZE_64 - 4);

                    if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)
                    {
                        if (dst_cpy > dst_LASTLITERALS)
                        {
                            goto _output_error; // Error : last 5 bytes must be literals
                        }

                        if (dst_p < dst_COPYLENGTH)
                        {
                            _i = SecureCopy(dst, dst_ref, dst_p, dst_COPYLENGTH);
                            dst_ref += _i;
                            dst_p += _i;
                        }

                        while (dst_p < dst_cpy)
                        {
                            dst[dst_p++] = dst[dst_ref++];
                        }

                        dst_p = dst_cpy;
                        continue;
                    }

                    if (dst_p < dst_cpy)
                    {
                        SecureCopy(dst, dst_ref, dst_p, dst_cpy);
                    }

                    dst_p = dst_cpy; // correction
                }

                // end of decoding
                return src_p - src_0;

_output_error:

// write overflow error detected
                return -(src_p - src_0);
            }
        }

#endregion
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Safe64.Dirty.cs.meta
================================================
fileFormatVersion: 2
guid: 2af5a6e86034ed44e91f32d31686d882
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#region license

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

using System;

namespace MessagePack.LZ4
{
    /// <summary>Unsafe LZ4 codec.</summary>
    internal partial class LZ4Codec
    {
        /// <summary>Encodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <returns>Number of bytes written.</returns>
        public static unsafe int Encode(ReadOnlySpan<byte> input, Span<byte> output)
        {
            if (output.Length == 0)
            {
                throw new MessagePackSerializationException("Output is empty.");
            }

            fixed (byte* inputPtr = input)
            fixed (byte* outputPtr = output)
            {
                if (input.Length < LZ4_64KLIMIT)
                {
                    var uHashTable = HashTablePool.GetUShortHashTablePool();
                    fixed (ushort* hash1 = &uHashTable[0])
                    {
                        if (IntPtr.Size == 4)
                        {
                            return LZ4_compress64kCtx_32(hash1, inputPtr, outputPtr, input.Length, output.Length);
                        }
                        else
                        {
                            return LZ4_compress64kCtx_64(hash1, inputPtr, outputPtr, input.Length, output.Length);
                        }
                    }
                }
                else
                {
                    var bHashTable = HashTablePool.GetUIntHashTablePool();
                    fixed (uint* hash2 = &bHashTable[0])
                    {
                        if (IntPtr.Size == 4)
                        {
                            return LZ4_compressCtx_32(hash2, inputPtr, outputPtr, input.Length, output.Length);
                        }
                        else
                        {
                            return LZ4_compressCtx_64(hash2, inputPtr, outputPtr, input.Length, output.Length);
                        }
                    }
                }
            }
        }

        /// <summary>Decodes the specified input.</summary>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <returns>Number of bytes written.</returns>
        public static unsafe int Decode(ReadOnlySpan<byte> input, Span<byte> output)
        {
            if (output.Length == 0)
            {
                throw new MessagePackSerializationException("Output is empty.");
            }

            fixed (byte* inputPtr = input)
            fixed (byte* outputPtr = output)
            {
                int length;
                if (IntPtr.Size == 4)
                {
                    length = LZ4_uncompress_32(inputPtr, outputPtr, output.Length);
                }
                else
                {
                    length = LZ4_uncompress_64(inputPtr, outputPtr, output.Length);
                }

                if (length != input.Length)
                {
                    throw new MessagePackSerializationException("LZ4 block is corrupted, or invalid length has been given.");
                }

                return output.Length;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe.cs.meta
================================================
fileFormatVersion: 2
guid: 3a48aac02d4c19049822a88ea40df7f5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe32.Dirty.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#region LZ4 original

/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-2012, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/

#endregion

#region LZ4 port

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

#pragma warning disable SA1312 // Variable names should begin with lower-case letter

namespace MessagePack.LZ4
{
    internal partial class LZ4Codec
    {
        #region LZ4_compressCtx_32

        private static unsafe int LZ4_compressCtx_32(
            uint* hash_table,
            byte* src,
            byte* dst,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                byte* _p;

                fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])
                {
                    // r93
                    var src_p = src;
                    var src_base = src_p;
                    var src_anchor = src_p;
                    var src_end = src_p + src_len;
                    var src_mflimit = src_end - MFLIMIT;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_maxlen;

                    var src_LASTLITERALS = src_end - LASTLITERALS;
                    var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                    var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_32 - 1);
                    var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                    var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                    int length;

                    uint h, h_fwd;

                    // Init
                    if (src_len < MINLENGTH)
                    {
                        goto _last_literals;
                    }

                    // First Byte
                    hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = (uint)(src_p - src_base);
                    src_p++;
                    h_fwd = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;

                    // Main Loop
                    while (true)
                    {
                        var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                        var src_p_fwd = src_p;
                        byte* xxx_ref;
                        byte* xxx_token;

                        // Find a match
                        do
                        {
                            h = h_fwd;
                            var step = findMatchAttempts++ >> SKIPSTRENGTH;
                            src_p = src_p_fwd;
                            src_p_fwd = src_p + step;

                            if (src_p_fwd > src_mflimit)
                            {
                                goto _last_literals;
                            }

                            h_fwd = (*(uint*)src_p_fwd * 2654435761u) >> HASH_ADJUST;
                            xxx_ref = src_base + hash_table[h];
                            hash_table[h] = (uint)(src_p - src_base);
                        }
                        while ((xxx_ref < src_p - MAX_DISTANCE) || ((*(uint*)xxx_ref) != (*(uint*)src_p)));

                        // Catch up
                        while ((src_p > src_anchor) && (xxx_ref > src) && (src_p[-1] == xxx_ref[-1]))
                        {
                            src_p--;
                            xxx_ref--;
                        }

                        // Encode Literal length
                        length = (int)(src_p - src_anchor);
                        xxx_token = dst_p++;

                        if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= RUN_MASK)
                        {
                            var len = length - RUN_MASK;
                            *xxx_token = RUN_MASK << ML_BITS;
                            if (len > 254)
                            {
                                do
                                {
                                    *dst_p++ = 255;
                                    len -= 255;
                                }
                                while (len > 254);
                                *dst_p++ = (byte)len;
                                BlockCopy32(src_anchor, dst_p, length);
                                dst_p += length;
                                goto _next_match;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *xxx_token = (byte)(length << ML_BITS);
                        }

                        // Copy Literals
                        _p = dst_p + length;
                        do
                        {
                            *(uint*)dst_p = *(uint*)src_anchor;
                            dst_p += 4;
                            src_anchor += 4;
                            *(uint*)dst_p = *(uint*)src_anchor;
                            dst_p += 4;
                            src_anchor += 4;
                        }
                        while (dst_p < _p);
                        dst_p = _p;

_next_match:

// Encode Offset
                        *(ushort*)dst_p = (ushort)(src_p - xxx_ref);
                        dst_p += 2;

                        // Start Counting
                        src_p += MINMATCH;
                        xxx_ref += MINMATCH; // MinMatch already verified
                        src_anchor = src_p;

                        while (src_p < src_LASTLITERALS_STEPSIZE_1)
                        {
                            var diff = (*(int*)xxx_ref) ^ (*(int*)src_p);
                            if (diff == 0)
                            {
                                src_p += STEPSIZE_32;
                                xxx_ref += STEPSIZE_32;
                                continue;
                            }

                            src_p += debruijn32[((uint)(diff & -diff) * 0x077CB531u) >> 27];
                            goto _endCount;
                        }

                        if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)xxx_ref) == (*(ushort*)src_p)))
                        {
                            src_p += 2;
                            xxx_ref += 2;
                        }

                        if ((src_p < src_LASTLITERALS) && (*xxx_ref == *src_p))
                        {
                            src_p++;
                        }

_endCount:

// Encode MatchLength
                        length = (int)(src_p - src_anchor);

                        if (dst_p + (length >> 8) > dst_LASTLITERALS_1)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= ML_MASK)
                        {
                            *xxx_token += ML_MASK;
                            length -= ML_MASK;
                            for (; length > 509; length -= 510)
                            {
                                *dst_p++ = 255;
                                *dst_p++ = 255;
                            }

                            if (length > 254)
                            {
                                length -= 255;
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)length;
                        }
                        else
                        {
                            *xxx_token += (byte)length;
                        }

                        // Test end of chunk
                        if (src_p > src_mflimit)
                        {
                            src_anchor = src_p;
                            break;
                        }

                        // Fill table
                        hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = (uint)(src_p - 2 - src_base);

                        // Test next position
                        h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;
                        xxx_ref = src_base + hash_table[h];
                        hash_table[h] = (uint)(src_p - src_base);

                        if ((xxx_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)xxx_ref) == (*(uint*)src_p)))
                        {
                            xxx_token = dst_p++;
                            *xxx_token = 0;
                            goto _next_match;
                        }

                        // Prepare next loop
                        src_anchor = src_p++;
                        h_fwd = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;
                    }

_last_literals:

// Encode Last Literals
                    {
                        var lastRun = (int)(src_end - src_anchor);

                        if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end)
                        {
                            return 0;
                        }

                        if (lastRun >= RUN_MASK)
                        {
                            *dst_p++ = RUN_MASK << ML_BITS;
                            lastRun -= RUN_MASK;
                            for (; lastRun > 254; lastRun -= 255)
                            {
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)lastRun;
                        }
                        else
                        {
                            *dst_p++ = (byte)(lastRun << ML_BITS);
                        }

                        BlockCopy32(src_anchor, dst_p, (int)(src_end - src_anchor));
                        dst_p += src_end - src_anchor;
                    }

                    // End
                    return (int)(dst_p - dst);
                }
            }
        }

        #endregion

        #region LZ4_compress64kCtx_32

        private static unsafe int LZ4_compress64kCtx_32(
            ushort* hash_table,
            byte* src,
            byte* dst,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                byte* _p;
                fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])
                {
                    // r93
                    var src_p = src;
                    var src_anchor = src_p;
                    var src_base = src_p;
                    var src_end = src_p + src_len;
                    var src_mflimit = src_end - MFLIMIT;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_maxlen;

                    var src_LASTLITERALS = src_end - LASTLITERALS;
                    var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                    var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_32 - 1);
                    var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                    var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                    int len, length;

                    uint h, h_fwd;

                    // Init
                    if (src_len < MINLENGTH)
                    {
                        goto _last_literals;
                    }

                    // First Byte
                    src_p++;
                    h_fwd = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;

                    // Main Loop
                    while (true)
                    {
                        var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                        var src_p_fwd = src_p;
                        byte* xxx_ref;
                        byte* xxx_token;

                        // Find a match
                        do
                        {
                            h = h_fwd;
                            var step = findMatchAttempts++ >> SKIPSTRENGTH;
                            src_p = src_p_fwd;
                            src_p_fwd = src_p + step;

                            if (src_p_fwd > src_mflimit)
                            {
                                goto _last_literals;
                            }

                            h_fwd = (*(uint*)src_p_fwd * 2654435761u) >> HASH64K_ADJUST;
                            xxx_ref = src_base + hash_table[h];
                            hash_table[h] = (ushort)(src_p - src_base);
                        }
                        while ((*(uint*)xxx_ref) != (*(uint*)src_p));

                        // Catch up
                        while ((src_p > src_anchor) && (xxx_ref > src) && (src_p[-1] == xxx_ref[-1]))
                        {
                            src_p--;
                            xxx_ref--;
                        }

                        // Encode Literal length
                        length = (int)(src_p - src_anchor);
                        xxx_token = dst_p++;

                        if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= RUN_MASK)
                        {
                            len = length - RUN_MASK;
                            *xxx_token = RUN_MASK << ML_BITS;
                            if (len > 254)
                            {
                                do
                                {
                                    *dst_p++ = 255;
                                    len -= 255;
                                }
                                while (len > 254);
                                *dst_p++ = (byte)len;
                                BlockCopy32(src_anchor, dst_p, length);
                                dst_p += length;
                                goto _next_match;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *xxx_token = (byte)(length << ML_BITS);
                        }

                        // Copy Literals
                        _p = dst_p + length;
                        do
                        {
                            *(uint*)dst_p = *(uint*)src_anchor;
                            dst_p += 4;
                            src_anchor += 4;
                            *(uint*)dst_p = *(uint*)src_anchor;
                            dst_p += 4;
                            src_anchor += 4;
                        }
                        while (dst_p < _p);
                        dst_p = _p;

_next_match:

// Encode Offset
                        *(ushort*)dst_p = (ushort)(src_p - xxx_ref);
                        dst_p += 2;

                        // Start Counting
                        src_p += MINMATCH;
                        xxx_ref += MINMATCH; // MinMatch verified
                        src_anchor = src_p;

                        while (src_p < src_LASTLITERALS_STEPSIZE_1)
                        {
                            var diff = (*(int*)xxx_ref) ^ (*(int*)src_p);
                            if (diff == 0)
                            {
                                src_p += STEPSIZE_32;
                                xxx_ref += STEPSIZE_32;
                                continue;
                            }

                            src_p += debruijn32[((uint)(diff & -diff) * 0x077CB531u) >> 27];
                            goto _endCount;
                        }

                        if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)xxx_ref) == (*(ushort*)src_p)))
                        {
                            src_p += 2;
                            xxx_ref += 2;
                        }

                        if ((src_p < src_LASTLITERALS) && (*xxx_ref == *src_p))
                        {
                            src_p++;
                        }

_endCount:

// Encode MatchLength
                        len = (int)(src_p - src_anchor);

                        if (dst_p + (len >> 8) > dst_LASTLITERALS_1)
                        {
                            return 0; // Check output limit
                        }

                        if (len >= ML_MASK)
                        {
                            *xxx_token += ML_MASK;
                            len -= ML_MASK;
                            for (; len > 509; len -= 510)
                            {
                                *dst_p++ = 255;
                                *dst_p++ = 255;
                            }

                            if (len > 254)
                            {
                                len -= 255;
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *xxx_token += (byte)len;
                        }

                        // Test end of chunk
                        if (src_p > src_mflimit)
                        {
                            src_anchor = src_p;
                            break;
                        }

                        // Fill table
                        hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);

                        // Test next position
                        h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;
                        xxx_ref = src_base + hash_table[h];
                        hash_table[h] = (ushort)(src_p - src_base);

                        if ((*(uint*)xxx_ref) == (*(uint*)src_p))
                        {
                            xxx_token = dst_p++;
                            *xxx_token = 0;
                            goto _next_match;
                        }

                        // Prepare next loop
                        src_anchor = src_p++;
                        h_fwd = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;
                    }

_last_literals:

// Encode Last Literals
                    {
                        var lastRun = (int)(src_end - src_anchor);
                        if (dst_p + lastRun + 1 + ((lastRun - RUN_MASK + 255) / 255) > dst_end)
                        {
                            return 0;
                        }

                        if (lastRun >= RUN_MASK)
                        {
                            *dst_p++ = RUN_MASK << ML_BITS;
                            lastRun -= RUN_MASK;
                            for (; lastRun > 254; lastRun -= 255)
                            {
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)lastRun;
                        }
                        else
                        {
                            *dst_p++ = (byte)(lastRun << ML_BITS);
                        }

                        BlockCopy32(src_anchor, dst_p, (int)(src_end - src_anchor));
                        dst_p += src_end - src_anchor;
                    }

                    // End
                    return (int)(dst_p - dst);
                }
            }
        }

        #endregion

        #region LZ4_uncompress_32

        private static unsafe int LZ4_uncompress_32(
            byte* src,
            byte* dst,
            int dst_len)
        {
            unchecked
            {
                fixed (int* dec32table = &DECODER_TABLE_32[0])
                {
                    // r93
                    var src_p = src;
                    byte* xxx_ref;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_len;
                    byte* dst_cpy;

                    var dst_LASTLITERALS = dst_end - LASTLITERALS;
                    var dst_COPYLENGTH = dst_end - COPYLENGTH;
                    var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_32 - 4);

                    uint xxx_token;

                    // Main Loop
                    while (true)
                    {
                        int length;

                        // get runlength
                        xxx_token = *src_p++;
                        if ((length = (int)(xxx_token >> ML_BITS)) == RUN_MASK)
                        {
                            int len;
                            for (; (len = *src_p++) == 255; length += 255)
                            {
                                /* do nothing */
                            }

                            length += len;
                        }

                        // copy literals
                        dst_cpy = dst_p + length;

                        if (dst_cpy > dst_COPYLENGTH)
                        {
                            if (dst_cpy != dst_end)
                            {
                                goto _output_error; // Error : not enough place for another match (min 4) + 5 literals
                            }

                            BlockCopy32(src_p, dst_p, length);
                            src_p += length;
                            break; // EOF
                        }

                        do
                        {
                            *(uint*)dst_p = *(uint*)src_p;
                            dst_p += 4;
                            src_p += 4;
                            *(uint*)dst_p = *(uint*)src_p;
                            dst_p += 4;
                            src_p += 4;
                        }
                        while (dst_p < dst_cpy);
                        src_p -= dst_p - dst_cpy;
                        dst_p = dst_cpy;

                        // get offset
                        xxx_ref = dst_cpy - (*(ushort*)src_p);
                        src_p += 2;
                        if (xxx_ref < dst)
                        {
                            goto _output_error; // Error : offset outside destination buffer
                        }

                        // get matchlength
                        if ((length = (int)(xxx_token & ML_MASK)) == ML_MASK)
                        {
                            for (; *src_p == 255; length += 255)
                            {
                                src_p++;
                            }

                            length += *src_p++;
                        }

                        // copy repeated sequence
                        if ((dst_p - xxx_ref) < STEPSIZE_32)
                        {
                            const int dec64 = 0;

                            dst_p[0] = xxx_ref[0];
                            dst_p[1] = xxx_ref[1];
                            dst_p[2] = xxx_ref[2];
                            dst_p[3] = xxx_ref[3];
                            dst_p += 4;
                            xxx_ref += 4;
                            xxx_ref -= dec32table[dst_p - xxx_ref];
                            *(uint*)dst_p = *(uint*)xxx_ref;
                            dst_p += STEPSIZE_32 - 4;
                            xxx_ref -= dec64;
                        }
                        else
                        {
                            *(uint*)dst_p = *(uint*)xxx_ref;
                            dst_p += 4;
                            xxx_ref += 4;
                        }

                        dst_cpy = dst_p + length - (STEPSIZE_32 - 4);

                        if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)
                        {
                            if (dst_cpy > dst_LASTLITERALS)
                            {
                                goto _output_error; // Error : last 5 bytes must be literals
                            }

                            {
                                do
                                {
                                    *(uint*)dst_p = *(uint*)xxx_ref;
                                    dst_p += 4;
                                    xxx_ref += 4;
                                    *(uint*)dst_p = *(uint*)xxx_ref;
                                    dst_p += 4;
                                    xxx_ref += 4;
                                }
                                while (dst_p < dst_COPYLENGTH);
                            }

                            while (dst_p < dst_cpy)
                            {
                                *dst_p++ = *xxx_ref++;
                            }

                            dst_p = dst_cpy;
                            continue;
                        }

                        do
                        {
                            *(uint*)dst_p = *(uint*)xxx_ref;
                            dst_p += 4;
                            xxx_ref += 4;
                            *(uint*)dst_p = *(uint*)xxx_ref;
                            dst_p += 4;
                            xxx_ref += 4;
                        }
                        while (dst_p < dst_cpy);
                        dst_p = dst_cpy; // correction
                    }

                    // end of decoding
                    return (int)(src_p - src);

// write overflow error detected
_output_error:
                    return (int)-(src_p - src);
                }
            }
        }

        #endregion

        /// <summary>Copies block of memory.</summary>
        /// <param name="src">The source.</param>
        /// <param name="dst">The destination.</param>
        /// <param name="len">The length (in bytes).</param>
        private static unsafe void BlockCopy32(byte* src, byte* dst, int len)
        {
            while (len >= 4)
            {
                *(uint*)dst = *(uint*)src;
                dst += 4;
                src += 4;
                len -= 4;
            }

            if (len >= 2)
            {
                *(ushort*)dst = *(ushort*)src;
                dst += 2;
                src += 2;
                len -= 2;
            }

            if (len >= 1)
            {
                *dst = *src; /* d++; s++; l--; */
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe32.Dirty.cs.meta
================================================
fileFormatVersion: 2
guid: 70d519bda46ea2048bcde764d4f7088c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe64.Dirty.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#region LZ4 original

/*
   LZ4 - Fast LZ compression algorithm
   Copyright (C) 2011-2012, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/

#endregion

#region LZ4 port

/*
Copyright (c) 2013, Milosz Krajewski
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided
that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions
  and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions
  and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#endregion

#pragma warning disable SA1312 // Variable names should begin with lower-case letter

namespace MessagePack.LZ4
{
    internal partial class LZ4Codec
    {
        #region LZ4_compressCtx_64

        private static unsafe int LZ4_compressCtx_64(
            uint* hash_table,
            byte* src,
            byte* dst,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                byte* _p;

                fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])
                {
                    // r93
                    var src_p = src;
                    var src_base = src_p;
                    var src_anchor = src_p;
                    var src_end = src_p + src_len;
                    var src_mflimit = src_end - MFLIMIT;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_maxlen;

                    var src_LASTLITERALS = src_end - LASTLITERALS;
                    var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                    var src_LASTLITERALS_3 = src_LASTLITERALS - 3;
                    var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);
                    var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                    var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                    int length;
                    uint h, h_fwd;

                    // Init
                    if (src_len < MINLENGTH)
                    {
                        goto _last_literals;
                    }

                    // First Byte
                    hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = (uint)(src_p - src_base);
                    src_p++;
                    h_fwd = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;

                    // Main Loop
                    while (true)
                    {
                        var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                        var src_p_fwd = src_p;
                        byte* src_ref;
                        byte* dst_token;

                        // Find a match
                        do
                        {
                            h = h_fwd;
                            var step = findMatchAttempts++ >> SKIPSTRENGTH;
                            src_p = src_p_fwd;
                            src_p_fwd = src_p + step;

                            if (src_p_fwd > src_mflimit)
                            {
                                goto _last_literals;
                            }

                            h_fwd = (*(uint*)src_p_fwd * 2654435761u) >> HASH_ADJUST;
                            src_ref = src_base + hash_table[h];
                            hash_table[h] = (uint)(src_p - src_base);
                        }
                        while ((src_ref < src_p - MAX_DISTANCE) || ((*(uint*)src_ref) != (*(uint*)src_p)));

                        // Catch up
                        while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))
                        {
                            src_p--;
                            src_ref--;
                        }

                        // Encode Literal length
                        length = (int)(src_p - src_anchor);
                        dst_token = dst_p++;

                        if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= RUN_MASK)
                        {
                            var len = length - RUN_MASK;
                            *dst_token = RUN_MASK << ML_BITS;
                            if (len > 254)
                            {
                                do
                                {
                                    *dst_p++ = 255;
                                    len -= 255;
                                }
                                while (len > 254);
                                *dst_p++ = (byte)len;
                                BlockCopy64(src_anchor, dst_p, length);
                                dst_p += length;
                                goto _next_match;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *dst_token = (byte)(length << ML_BITS);
                        }

                        // Copy Literals
                        _p = dst_p + length;
                        {
                            do
                            {
                                *(ulong*)dst_p = *(ulong*)src_anchor;
                                dst_p += 8;
                                src_anchor += 8;
                            }
                            while (dst_p < _p);
                        }

                        dst_p = _p;

_next_match:

// Encode Offset
                        *(ushort*)dst_p = (ushort)(src_p - src_ref);
                        dst_p += 2;

                        // Start Counting
                        src_p += MINMATCH;
                        src_ref += MINMATCH; // MinMatch already verified
                        src_anchor = src_p;

                        while (src_p < src_LASTLITERALS_STEPSIZE_1)
                        {
                            var diff = (*(long*)src_ref) ^ (*(long*)src_p);
                            if (diff == 0)
                            {
                                src_p += STEPSIZE_64;
                                src_ref += STEPSIZE_64;
                                continue;
                            }

                            src_p += debruijn64[((ulong)(diff & -diff) * 0x0218A392CDABBD3FL) >> 58];
                            goto _endCount;
                        }

                        if ((src_p < src_LASTLITERALS_3) && ((*(uint*)src_ref) == (*(uint*)src_p)))
                        {
                            src_p += 4;
                            src_ref += 4;
                        }

                        if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)src_ref) == (*(ushort*)src_p)))
                        {
                            src_p += 2;
                            src_ref += 2;
                        }

                        if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p))
                        {
                            src_p++;
                        }

_endCount:

// Encode MatchLength
                        length = (int)(src_p - src_anchor);

                        if (dst_p + (length >> 8) > dst_LASTLITERALS_1)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= ML_MASK)
                        {
                            *dst_token += ML_MASK;
                            length -= ML_MASK;
                            for (; length > 509; length -= 510)
                            {
                                *dst_p++ = 255;
                                *dst_p++ = 255;
                            }

                            if (length > 254)
                            {
                                length -= 255;
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)length;
                        }
                        else
                        {
                            *dst_token += (byte)length;
                        }

                        // Test end of chunk
                        if (src_p > src_mflimit)
                        {
                            src_anchor = src_p;
                            break;
                        }

                        // Fill table
                        hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = (uint)(src_p - 2 - src_base);

                        // Test next position
                        h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = (uint)(src_p - src_base);

                        if ((src_ref > src_p - (MAX_DISTANCE + 1)) && ((*(uint*)src_ref) == (*(uint*)src_p)))
                        {
                            dst_token = dst_p++;
                            *dst_token = 0;
                            goto _next_match;
                        }

                        // Prepare next loop
                        src_anchor = src_p++;
                        h_fwd = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;
                    }

_last_literals:

// Encode Last Literals
                    var lastRun = (int)(src_end - src_anchor);
                    if (dst_p + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > dst_end)
                    {
                        return 0;
                    }

                    if (lastRun >= RUN_MASK)
                    {
                        *dst_p++ = RUN_MASK << ML_BITS;
                        lastRun -= RUN_MASK;
                        for (; lastRun > 254; lastRun -= 255)
                        {
                            *dst_p++ = 255;
                        }

                        *dst_p++ = (byte)lastRun;
                    }
                    else
                    {
                        *dst_p++ = (byte)(lastRun << ML_BITS);
                    }

                    BlockCopy64(src_anchor, dst_p, (int)(src_end - src_anchor));
                    dst_p += src_end - src_anchor;

                    // End
                    return (int)(dst_p - dst);
                }
            }
        }

        #endregion

        #region LZ4_compress64kCtx_64

        private static unsafe int LZ4_compress64kCtx_64(
            ushort* hash_table,
            byte* src,
            byte* dst,
            int src_len,
            int dst_maxlen)
        {
            unchecked
            {
                byte* _p;

                fixed (int* debruijn64 = &DEBRUIJN_TABLE_64[0])
                {
                    // r93
                    var src_p = src;
                    var src_anchor = src_p;
                    var src_base = src_p;
                    var src_end = src_p + src_len;
                    var src_mflimit = src_end - MFLIMIT;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_maxlen;

                    var src_LASTLITERALS = src_end - LASTLITERALS;
                    var src_LASTLITERALS_1 = src_LASTLITERALS - 1;

                    var src_LASTLITERALS_3 = src_LASTLITERALS - 3;

                    var src_LASTLITERALS_STEPSIZE_1 = src_LASTLITERALS - (STEPSIZE_64 - 1);
                    var dst_LASTLITERALS_1 = dst_end - (1 + LASTLITERALS);
                    var dst_LASTLITERALS_3 = dst_end - (2 + 1 + LASTLITERALS);

                    int len, length;

                    uint h, h_fwd;

                    // Init
                    if (src_len < MINLENGTH)
                    {
                        goto _last_literals;
                    }

                    // First Byte
                    src_p++;
                    h_fwd = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;

                    // Main Loop
                    while (true)
                    {
                        var findMatchAttempts = (1 << SKIPSTRENGTH) + 3;
                        var src_p_fwd = src_p;
                        byte* src_ref;
                        byte* dst_token;

                        // Find a match
                        do
                        {
                            h = h_fwd;
                            var step = findMatchAttempts++ >> SKIPSTRENGTH;
                            src_p = src_p_fwd;
                            src_p_fwd = src_p + step;

                            if (src_p_fwd > src_mflimit)
                            {
                                goto _last_literals;
                            }

                            h_fwd = (*(uint*)src_p_fwd * 2654435761u) >> HASH64K_ADJUST;
                            src_ref = src_base + hash_table[h];
                            hash_table[h] = (ushort)(src_p - src_base);
                        }
                        while ((*(uint*)src_ref) != (*(uint*)src_p));

                        // Catch up
                        while ((src_p > src_anchor) && (src_ref > src) && (src_p[-1] == src_ref[-1]))
                        {
                            src_p--;
                            src_ref--;
                        }

                        // Encode Literal length
                        length = (int)(src_p - src_anchor);
                        dst_token = dst_p++;

                        if (dst_p + length + (length >> 8) > dst_LASTLITERALS_3)
                        {
                            return 0; // Check output limit
                        }

                        if (length >= RUN_MASK)
                        {
                            len = length - RUN_MASK;
                            *dst_token = RUN_MASK << ML_BITS;
                            if (len > 254)
                            {
                                do
                                {
                                    *dst_p++ = 255;
                                    len -= 255;
                                }
                                while (len > 254);
                                *dst_p++ = (byte)len;
                                BlockCopy64(src_anchor, dst_p, length);
                                dst_p += length;
                                goto _next_match;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *dst_token = (byte)(length << ML_BITS);
                        }

                        // Copy Literals
                        {
                            _p = dst_p + length;
                            {
                                do
                                {
                                    *(ulong*)dst_p = *(ulong*)src_anchor;
                                    dst_p += 8;
                                    src_anchor += 8;
                                }
                                while (dst_p < _p);
                            }

                            dst_p = _p;
                        }

_next_match:

// Encode Offset
                        *(ushort*)dst_p = (ushort)(src_p - src_ref);
                        dst_p += 2;

                        // Start Counting
                        src_p += MINMATCH;
                        src_ref += MINMATCH; // MinMatch verified
                        src_anchor = src_p;

                        while (src_p < src_LASTLITERALS_STEPSIZE_1)
                        {
                            var diff = (*(long*)src_ref) ^ (*(long*)src_p);
                            if (diff == 0)
                            {
                                src_p += STEPSIZE_64;
                                src_ref += STEPSIZE_64;
                                continue;
                            }

                            src_p += debruijn64[((ulong)(diff & -diff) * 0x0218A392CDABBD3FL) >> 58];
                            goto _endCount;
                        }

                        if ((src_p < src_LASTLITERALS_3) && ((*(uint*)src_ref) == (*(uint*)src_p)))
                        {
                            src_p += 4;
                            src_ref += 4;
                        }

                        if ((src_p < src_LASTLITERALS_1) && ((*(ushort*)src_ref) == (*(ushort*)src_p)))
                        {
                            src_p += 2;
                            src_ref += 2;
                        }

                        if ((src_p < src_LASTLITERALS) && (*src_ref == *src_p))
                        {
                            src_p++;
                        }

_endCount:

// Encode MatchLength
                        len = (int)(src_p - src_anchor);

                        if (dst_p + (len >> 8) > dst_LASTLITERALS_1)
                        {
                            return 0; // Check output limit
                        }

                        if (len >= ML_MASK)
                        {
                            *dst_token += ML_MASK;
                            len -= ML_MASK;
                            for (; len > 509; len -= 510)
                            {
                                *dst_p++ = 255;
                                *dst_p++ = 255;
                            }

                            if (len > 254)
                            {
                                len -= 255;
                                *dst_p++ = 255;
                            }

                            *dst_p++ = (byte)len;
                        }
                        else
                        {
                            *dst_token += (byte)len;
                        }

                        // Test end of chunk
                        if (src_p > src_mflimit)
                        {
                            src_anchor = src_p;
                            break;
                        }

                        // Fill table
                        hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);

                        // Test next position
                        h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;
                        src_ref = src_base + hash_table[h];
                        hash_table[h] = (ushort)(src_p - src_base);

                        if ((*(uint*)src_ref) == (*(uint*)src_p))
                        {
                            dst_token = dst_p++;
                            *dst_token = 0;
                            goto _next_match;
                        }

                        // Prepare next loop
                        src_anchor = src_p++;
                        h_fwd = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;
                    }

_last_literals:

// Encode Last Literals
                    var lastRun = (int)(src_end - src_anchor);
                    if (dst_p + lastRun + 1 + ((lastRun - RUN_MASK + 255) / 255) > dst_end)
                    {
                        return 0;
                    }

                    if (lastRun >= RUN_MASK)
                    {
                        *dst_p++ = RUN_MASK << ML_BITS;
                        lastRun -= RUN_MASK;
                        for (; lastRun > 254; lastRun -= 255)
                        {
                            *dst_p++ = 255;
                        }

                        *dst_p++ = (byte)lastRun;
                    }
                    else
                    {
                        *dst_p++ = (byte)(lastRun << ML_BITS);
                    }

                    BlockCopy64(src_anchor, dst_p, (int)(src_end - src_anchor));
                    dst_p += src_end - src_anchor;

                    // End
                    return (int)(dst_p - dst);
                }
            }
        }

        #endregion

        #region LZ4_uncompress_64

        private static unsafe int LZ4_uncompress_64(
            byte* src,
            byte* dst,
            int dst_len)
        {
            unchecked
            {
                fixed (int* dec32table = &DECODER_TABLE_32[0])
                fixed (int* dec64table = &DECODER_TABLE_64[0])
                {
                    // r93
                    var src_p = src;
                    byte* dst_ref;

                    var dst_p = dst;
                    var dst_end = dst_p + dst_len;
                    byte* dst_cpy;

                    var dst_LASTLITERALS = dst_end - LASTLITERALS;
                    var dst_COPYLENGTH = dst_end - COPYLENGTH;
                    var dst_COPYLENGTH_STEPSIZE_4 = dst_end - COPYLENGTH - (STEPSIZE_64 - 4);

                    byte token;

                    // Main Loop
                    while (true)
                    {
                        int length;

                        // get runlength
                        token = *src_p++;
                        if ((length = token >> ML_BITS) == RUN_MASK)
                        {
                            int len;
                            for (; (len = *src_p++) == 255; length += 255)
                            {
                                /* do nothing */
                            }

                            length += len;
                        }

                        // copy literals
                        dst_cpy = dst_p + length;

                        if (dst_cpy > dst_COPYLENGTH)
                        {
                            if (dst_cpy != dst_end)
                            {
                                goto _output_error; // Error : not enough place for another match (min 4) + 5 literals
                            }

                            BlockCopy64(src_p, dst_p, length);
                            src_p += length;
                            break; // EOF
                        }

                        do
                        {
                            *(ulong*)dst_p = *(ulong*)src_p;
                            dst_p += 8;
                            src_p += 8;
                        }
                        while (dst_p < dst_cpy);
                        src_p -= dst_p - dst_cpy;
                        dst_p = dst_cpy;

                        // get offset
                        dst_ref = dst_cpy - (*(ushort*)src_p);
                        src_p += 2;
                        if (dst_ref < dst)
                        {
                            goto _output_error; // Error : offset outside destination buffer
                        }

                        // get matchlength
                        if ((length = token & ML_MASK) == ML_MASK)
                        {
                            for (; *src_p == 255; length += 255)
                            {
                                src_p++;
                            }

                            length += *src_p++;
                        }

                        // copy repeated sequence
                        if ((dst_p - dst_ref) < STEPSIZE_64)
                        {
                            var dec64 = dec64table[dst_p - dst_ref];

                            dst_p[0] = dst_ref[0];
                            dst_p[1] = dst_ref[1];
                            dst_p[2] = dst_ref[2];
                            dst_p[3] = dst_ref[3];
                            dst_p += 4;
                            dst_ref += 4;
                            dst_ref -= dec32table[dst_p - dst_ref];
                            *(uint*)dst_p = *(uint*)dst_ref;
                            dst_p += STEPSIZE_64 - 4;
                            dst_ref -= dec64;
                        }
                        else
                        {
                            *(ulong*)dst_p = *(ulong*)dst_ref;
                            dst_p += 8;
                            dst_ref += 8;
                        }

                        dst_cpy = dst_p + length - (STEPSIZE_64 - 4);

                        if (dst_cpy > dst_COPYLENGTH_STEPSIZE_4)
                        {
                            if (dst_cpy > dst_LASTLITERALS)
                            {
                                goto _output_error; // Error : last 5 bytes must be literals
                            }

                            while (dst_p < dst_COPYLENGTH)
                            {
                                *(ulong*)dst_p = *(ulong*)dst_ref;
                                dst_p += 8;
                                dst_ref += 8;
                            }

                            while (dst_p < dst_cpy)
                            {
                                *dst_p++ = *dst_ref++;
                            }

                            dst_p = dst_cpy;
                            continue;
                        }

                        {
                            do
                            {
                                *(ulong*)dst_p = *(ulong*)dst_ref;
                                dst_p += 8;
                                dst_ref += 8;
                            }
                            while (dst_p < dst_cpy);
                        }

                        dst_p = dst_cpy; // correction
                    }

                    // end of decoding
                    return (int)(src_p - src);

// write overflow error detected
_output_error:
                    return (int)-(src_p - src);
                }
            }
        }

        #endregion

        /// <summary>Copies block of memory.</summary>
        /// <param name="src">The source.</param>
        /// <param name="dst">The destination.</param>
        /// <param name="len">The length (in bytes).</param>
        private static unsafe void BlockCopy64(byte* src, byte* dst, int len)
        {
            while (len >= 8)
            {
                *(ulong*)dst = *(ulong*)src;
                dst += 8;
                src += 8;
                len -= 8;
            }

            if (len >= 4)
            {
                *(uint*)dst = *(uint*)src;
                dst += 4;
                src += 4;
                len -= 4;
            }

            if (len >= 2)
            {
                *(ushort*)dst = *(ushort*)src;
                dst += 2;
                src += 2;
                len -= 2;
            }

            if (len >= 1)
            {
                *dst = *src; /* d++; s++; l--; */
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/LZ4/LZ4Codec.Unsafe64.Dirty.cs.meta
================================================
fileFormatVersion: 2
guid: 5dd9161b1f56b464a8db9b3d96dca169
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/AttributeFormatterResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Linq; // require UNITY_2018_3_OR_NEWER
using System.Reflection;
using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// Get formatter from <see cref="MessagePackFormatterAttribute"/>.
    /// </summary>
    public sealed class AttributeFormatterResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly AttributeFormatterResolver Instance = new AttributeFormatterResolver();

        private AttributeFormatterResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
#if UNITY_2018_3_OR_NEWER && !NETFX_CORE
                var attr = (MessagePackFormatterAttribute)typeof(T).GetCustomAttributes(typeof(MessagePackFormatterAttribute), true).FirstOrDefault();
#else
                MessagePackFormatterAttribute attr = typeof(T).GetTypeInfo().GetCustomAttribute<MessagePackFormatterAttribute>();
#endif
                if (attr == null)
                {
                    return;
                }

                var formatterType = attr.FormatterType;
                if (formatterType.IsGenericType && !formatterType.IsConstructedGenericType)
                {
                    formatterType = formatterType.MakeGenericType(typeof(T).GetGenericArguments());
                }

                if (attr.Arguments == null)
                {
                    Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(formatterType);
                }
                else
                {
                    Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(formatterType, attr.Arguments);
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/AttributeFormatterResolver.cs.meta
================================================
fileFormatVersion: 2
guid: c02a22f37aeb19147a0a91b233f75622
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/BuiltinResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using MessagePack.Formatters;
using MessagePack.Internal;
using MessagePack.Resolvers;

#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1509 // Opening braces should not be preceded by blank line

namespace MessagePack.Resolvers
{
    public sealed class BuiltinResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly BuiltinResolver Instance = new BuiltinResolver();

        private BuiltinResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                // Reduce IL2CPP code generate size(don't write long code in <T>)
                Formatter = (IMessagePackFormatter<T>)BuiltinResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }
}

namespace MessagePack.Internal
{
    internal static class BuiltinResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, object> FormatterMap = new Dictionary<Type, object>()
        {
            // Primitive
            { typeof(Int16), Int16Formatter.Instance },
            { typeof(Int32), Int32Formatter.Instance },
            { typeof(Int64), Int64Formatter.Instance },
            { typeof(UInt16), UInt16Formatter.Instance },
            { typeof(UInt32), UInt32Formatter.Instance },
            { typeof(UInt64), UInt64Formatter.Instance },
            { typeof(Single), SingleFormatter.Instance },
            { typeof(Double), DoubleFormatter.Instance },
            { typeof(bool), BooleanFormatter.Instance },
            { typeof(byte), ByteFormatter.Instance },
            { typeof(sbyte), SByteFormatter.Instance },
            { typeof(DateTime), DateTimeFormatter.Instance },
            { typeof(char), CharFormatter.Instance },

            // Nulllable Primitive
            { typeof(Int16?), NullableInt16Formatter.Instance },
            { typeof(Int32?), NullableInt32Formatter.Instance },
            { typeof(Int64?), NullableInt64Formatter.Instance },
            { typeof(UInt16?), NullableUInt16Formatter.Instance },
            { typeof(UInt32?), NullableUInt32Formatter.Instance },
            { typeof(UInt64?), NullableUInt64Formatter.Instance },
            { typeof(Single?), NullableSingleFormatter.Instance },
            { typeof(Double?), NullableDoubleFormatter.Instance },
            { typeof(bool?), NullableBooleanFormatter.Instance },
            { typeof(byte?), NullableByteFormatter.Instance },
            { typeof(sbyte?), NullableSByteFormatter.Instance },
            { typeof(DateTime?), NullableDateTimeFormatter.Instance },
            { typeof(char?), NullableCharFormatter.Instance },

            // StandardClassLibraryFormatter
            { typeof(string), NullableStringFormatter.Instance },
            { typeof(decimal), DecimalFormatter.Instance },
            { typeof(decimal?), new StaticNullableFormatter<decimal>(DecimalFormatter.Instance) },
            { typeof(TimeSpan), TimeSpanFormatter.Instance },
            { typeof(TimeSpan?), new StaticNullableFormatter<TimeSpan>(TimeSpanFormatter.Instance) },
            { typeof(DateTimeOffset), DateTimeOffsetFormatter.Instance },
            { typeof(DateTimeOffset?), new StaticNullableFormatter<DateTimeOffset>(DateTimeOffsetFormatter.Instance) },
            { typeof(Guid), GuidFormatter.Instance },
            { typeof(Guid?), new StaticNullableFormatter<Guid>(GuidFormatter.Instance) },
            { typeof(Uri), UriFormatter.Instance },
            { typeof(Version), VersionFormatter.Instance },
            { typeof(StringBuilder), StringBuilderFormatter.Instance },
            { typeof(BitArray), BitArrayFormatter.Instance },
            { typeof(Type), TypeFormatter<Type>.Instance },

            // special primitive
            { typeof(byte[]), ByteArrayFormatter.Instance },

            // Nil
            { typeof(Nil), NilFormatter.Instance },
            { typeof(Nil?), NullableNilFormatter.Instance },

            // optimized primitive array formatter
            { typeof(Int16[]), Int16ArrayFormatter.Instance },
            { typeof(Int32[]), Int32ArrayFormatter.Instance },
            { typeof(Int64[]), Int64ArrayFormatter.Instance },
            { typeof(UInt16[]), UInt16ArrayFormatter.Instance },
            { typeof(UInt32[]), UInt32ArrayFormatter.Instance },
            { typeof(UInt64[]), UInt64ArrayFormatter.Instance },
            { typeof(Single[]), SingleArrayFormatter.Instance },
            { typeof(Double[]), DoubleArrayFormatter.Instance },
            { typeof(Boolean[]), BooleanArrayFormatter.Instance },
            { typeof(SByte[]), SByteArrayFormatter.Instance },
            { typeof(DateTime[]), DateTimeArrayFormatter.Instance },
            { typeof(Char[]), CharArrayFormatter.Instance },
            { typeof(string[]), NullableStringArrayFormatter.Instance },

            // well known collections
            { typeof(List<Int16>), new ListFormatter<Int16>() },
            { typeof(List<Int32>), new ListFormatter<Int32>() },
            { typeof(List<Int64>), new ListFormatter<Int64>() },
            { typeof(List<UInt16>), new ListFormatter<UInt16>() },
            { typeof(List<UInt32>), new ListFormatter<UInt32>() },
            { typeof(List<UInt64>), new ListFormatter<UInt64>() },
            { typeof(List<Single>), new ListFormatter<Single>() },
            { typeof(List<Double>), new ListFormatter<Double>() },
            { typeof(List<Boolean>), new ListFormatter<Boolean>() },
            { typeof(List<byte>), new ListFormatter<byte>() },
            { typeof(List<SByte>), new ListFormatter<SByte>() },
            { typeof(List<DateTime>), new ListFormatter<DateTime>() },
            { typeof(List<Char>), new ListFormatter<Char>() },
            { typeof(List<string>), new ListFormatter<string>() },

            { typeof(object[]), new ArrayFormatter<object>() },
            { typeof(List<object>), new ListFormatter<object>() },

            { typeof(Memory<byte>), ByteMemoryFormatter.Instance },
            { typeof(Memory<byte>?), new StaticNullableFormatter<Memory<byte>>(ByteMemoryFormatter.Instance) },
            { typeof(ReadOnlyMemory<byte>), ByteReadOnlyMemoryFormatter.Instance },
            { typeof(ReadOnlyMemory<byte>?), new StaticNullableFormatter<ReadOnlyMemory<byte>>(ByteReadOnlyMemoryFormatter.Instance) },
            { typeof(ReadOnlySequence<byte>), ByteReadOnlySequenceFormatter.Instance },
            { typeof(ReadOnlySequence<byte>?), new StaticNullableFormatter<ReadOnlySequence<byte>>(ByteReadOnlySequenceFormatter.Instance) },
            { typeof(ArraySegment<byte>), ByteArraySegmentFormatter.Instance },
            { typeof(ArraySegment<byte>?), new StaticNullableFormatter<ArraySegment<byte>>(ByteArraySegmentFormatter.Instance) },

            { typeof(System.Numerics.BigInteger), BigIntegerFormatter.Instance },
            { typeof(System.Numerics.BigInteger?), new StaticNullableFormatter<System.Numerics.BigInteger>(BigIntegerFormatter.Instance) },
            { typeof(System.Numerics.Complex), ComplexFormatter.Instance },
            { typeof(System.Numerics.Complex?), new StaticNullableFormatter<System.Numerics.Complex>(ComplexFormatter.Instance) },
        };

        internal static object GetFormatter(Type t)
        {
            object formatter;
            if (FormatterMap.TryGetValue(t, out formatter))
            {
                return formatter;
            }

            if (typeof(Type).IsAssignableFrom(t))
            {
                return typeof(TypeFormatter<>).MakeGenericType(t).GetField(nameof(TypeFormatter<Type>.Instance)).GetValue(null);
            }

            return null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/BuiltinResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 8576a58290a3c2f4b856a090338fe4e3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/CachingFormatterResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// A base class for <see cref="IFormatterResolver"/> classes that want to cache their responses for perf reasons.
    /// </summary>
    internal abstract class CachingFormatterResolver : IFormatterResolver
    {
        /// <summary>
        /// The cache of types to their formatters.
        /// </summary>
        private readonly ThreadsafeTypeKeyHashTable<IMessagePackFormatter> formatters = new ThreadsafeTypeKeyHashTable<IMessagePackFormatter>();

        /// <inheritdoc />
        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            if (!this.formatters.TryGetValue(typeof(T), out IMessagePackFormatter formatter))
            {
                formatter = this.GetFormatterCore<T>();
                this.formatters.TryAdd(typeof(T), formatter);
            }

            return (IMessagePackFormatter<T>)formatter;
        }

        /// <summary>
        /// Looks up a formatter for a type that has not been previously cached.
        /// </summary>
        /// <typeparam name="T">The type to be formatted.</typeparam>
        /// <returns>The formatter to use, or <c>null</c> if none found.</returns>
        protected abstract IMessagePackFormatter<T> GetFormatterCore<T>();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/CachingFormatterResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 0b890291dfa50d64eb8a47edaeae5a2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/CompositeResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// Represents a collection of formatters and resolvers acting as one.
    /// </summary>
    /// <remarks>
    /// This class is not thread-safe for mutations. It is thread-safe when not being written to.
    /// </remarks>
    public static class CompositeResolver
    {
        private static readonly ReadOnlyDictionary<Type, IMessagePackFormatter> EmptyFormattersByType = new ReadOnlyDictionary<Type, IMessagePackFormatter>(new Dictionary<Type, IMessagePackFormatter>());

        /// <summary>
        /// Initializes a new instance of an <see cref="IFormatterResolver"/> with the specified formatters and sub-resolvers.
        /// </summary>
        /// <param name="formatters">
        /// A list of instances of <see cref="IMessagePackFormatter{T}"/> to prefer (above the <paramref name="resolvers"/>).
        /// The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
        /// May not be null, but may be <see cref="Array.Empty{T}"/>.
        /// </param>
        /// <param name="resolvers">
        /// A list of resolvers to use for serializing types for which <paramref name="formatters"/> does not include a formatter.
        /// The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
        /// May not be null, but may be <see cref="Array.Empty{T}"/>.
        /// </param>
        /// <returns>
        /// An instance of <see cref="IFormatterResolver"/>.
        /// </returns>
        public static IFormatterResolver Create(IReadOnlyList<IMessagePackFormatter> formatters, IReadOnlyList<IFormatterResolver> resolvers)
        {
            if (formatters is null)
            {
                throw new ArgumentNullException(nameof(formatters));
            }

            if (resolvers is null)
            {
                throw new ArgumentNullException(nameof(resolvers));
            }

            // Make a copy of the resolvers list provided by the caller to guard against them changing it later.
            var immutableFormatters = formatters.ToArray();
            var immutableResolvers = resolvers.ToArray();

            return new CachingResolver(immutableFormatters, immutableResolvers);
        }

        public static IFormatterResolver Create(params IFormatterResolver[] resolvers) => Create(Array.Empty<IMessagePackFormatter>(), resolvers);

        public static IFormatterResolver Create(params IMessagePackFormatter[] formatters) => Create(formatters, Array.Empty<IFormatterResolver>());

        private class CachingResolver : IFormatterResolver
        {
            private readonly ThreadsafeTypeKeyHashTable<IMessagePackFormatter> formattersCache = new ThreadsafeTypeKeyHashTable<IMessagePackFormatter>();
            private readonly IMessagePackFormatter[] subFormatters;
            private readonly IFormatterResolver[] subResolvers;

            /// <summary>
            /// Initializes a new instance of the <see cref="CachingResolver"/> class.
            /// </summary>
            internal CachingResolver(IMessagePackFormatter[] subFormatters, IFormatterResolver[] subResolvers)
            {
                this.subFormatters = subFormatters ?? throw new ArgumentNullException(nameof(subFormatters));
                this.subResolvers = subResolvers ?? throw new ArgumentNullException(nameof(subResolvers));
            }

            public IMessagePackFormatter<T> GetFormatter<T>()
            {
                if (!this.formattersCache.TryGetValue(typeof(T), out IMessagePackFormatter formatter))
                {
                    foreach (var subFormatter in this.subFormatters)
                    {
                        if (subFormatter is IMessagePackFormatter<T>)
                        {
                            formatter = subFormatter;
                            goto CACHE;
                        }
                    }

                    foreach (IFormatterResolver resolver in this.subResolvers)
                    {
                        formatter = resolver.GetFormatter<T>();
                        if (formatter != null)
                        {
                            goto CACHE;
                        }
                    }

// when not found, cache null.
CACHE:
                    this.formattersCache.TryAdd(typeof(T), formatter);
                }

                return (IMessagePackFormatter<T>)formatter;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/CompositeResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 855ae905af3dec6449d0ced09b158a43
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/ContractlessReflectionObjectResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Text;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    // MEMO: Not completely implemented.

    ////public static class ContractlessReflectionObjectResolver
    ////{
    ////    // TODO:CamelCase Option? AllowPrivate?
    ////    public static readonly IFormatterResolver Default = new DefaultResolver();
    ////    public static readonly IFormatterResolver Contractless = new ContractlessResolver();
    ////    public static readonly IFormatterResolver ContractlessForceStringKey = new ContractlessForceStringResolver();

    ////    class DefaultResolver : IFormatterResolver
    ////    {
    ////        const bool ForceStringKey = false;
    ////        const bool Contractless = false;
    ////        const bool AllowPrivate = false;

    ////        public IMessagePackFormatter<T> GetFormatter<T>()
    ////        {
    ////            return Cache<T>.formatter;
    ////        }

    ////        static class Cache<T>
    ////        {
    ////            public static readonly IMessagePackFormatter<T> formatter;

    ////            static Cache()
    ////            {
    ////                var metaInfo = ObjectSerializationInfo.CreateOrNull(typeof(T), ForceStringKey, Contractless, AllowPrivate);
    ////                if (metaInfo != null)
    ////                {
    ////                    formatter = new ReflectionObjectFormatter<T>(metaInfo);
    ////                }
    ////            }
    ////        }
    ////    }

    ////    class ContractlessResolver : IFormatterResolver
    ////    {
    ////        const bool ForceStringKey = false;
    ////        const bool Contractless = true;
    ////        const bool AllowPrivate = false;

    ////        public IMessagePackFormatter<T> GetFormatter<T>()
    ////        {
    ////            return Cache<T>.formatter;
    ////        }

    ////        static class Cache<T>
    ////        {
    ////            public static readonly IMessagePackFormatter<T> formatter;

    ////            static Cache()
    ////            {
    ////                var metaInfo = ObjectSerializationInfo.CreateOrNull(typeof(T), ForceStringKey, Contractless, AllowPrivate);
    ////                if (metaInfo != null)
    ////                {
    ////                    formatter = new ReflectionObjectFormatter<T>(metaInfo);
    ////                }
    ////            }
    ////        }
    ////    }

    ////    class ContractlessForceStringResolver : IFormatterResolver
    ////    {
    ////        const bool ForceStringKey = true;
    ////        const bool Contractless = true;
    ////        const bool AllowPrivate = false;

    ////        public IMessagePackFormatter<T> GetFormatter<T>()
    ////        {
    ////            return Cache<T>.formatter;
    ////        }

    ////        static class Cache<T>
    ////        {
    ////            public static readonly IMessagePackFormatter<T> formatter;

    ////            static Cache()
    ////            {
    ////                var metaInfo = ObjectSerializationInfo.CreateOrNull(typeof(T), ForceStringKey, Contractless, AllowPrivate);
    ////                if (metaInfo != null)
    ////                {
    ////                    formatter = new ReflectionObjectFormatter<T>(metaInfo);
    ////                }
    ////            }
    ////        }
    ////    }

    ////}

    ////public class ReflectionObjectFormatter<T> : IMessagePackFormatter<T>
    ////{
    ////    readonly ObjectSerializationInfo metaInfo;

    ////    // for write
    ////    readonly byte[][] writeMemberNames;
    ////    readonly ObjectSerializationInfo.EmittableMember[] writeMembers;

    ////    // for read
    ////    readonly int[] constructorParameterIndexes;
    ////    readonly AutomataDictionary mapMemberDictionary;
    ////    readonly ObjectSerializationInfo.EmittableMember[] readMembers;

    ////    internal ReflectionObjectFormatter(ObjectSerializationInfo metaInfo)
    ////    {
    ////        this.metaInfo = metaInfo;

    ////        // for write
    ////        {
    ////            var memberNameList = new List<byte[]>(metaInfo.Members.Length);
    ////            var emmitableMemberList = new List<ObjectSerializationInfo.EmittableMember>(metaInfo.Members.Length);
    ////            foreach (var item in metaInfo.Members)
    ////            {
    ////                if (item.IsWritable)
    ////                {
    ////                    emmitableMemberList.Add(item);
    ////                    memberNameList.Add(Encoding.UTF8.GetBytes(item.Name));
    ////                }
    ////            }
    ////            this.writeMemberNames = memberNameList.ToArray();
    ////            this.writeMembers = emmitableMemberList.ToArray();
    ////        }
    ////        // for read
    ////        {
    ////            var automata = new AutomataDictionary();
    ////            var emmitableMemberList = new List<ObjectSerializationInfo.EmittableMember>(metaInfo.Members.Length);
    ////            int index = 0;
    ////            foreach (var item in metaInfo.Members)
    ////            {
    ////                if (item.IsReadable)
    ////                {
    ////                    emmitableMemberList.Add(item);
    ////                    automata.Add(item.Name, index++);
    ////                }
    ////            }
    ////            this.readMembers = emmitableMemberList.ToArray();
    ////            this.mapMemberDictionary = automata;
    ////        }
    ////    }

    ////    public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
    ////    {
    ////        // reduce generic method size, avoid write code in <T> type.
    ////        if (metaInfo.IsIntKey)
    ////        {
    ////            return ReflectionObjectFormatterHelper.WriteArraySerialize(metaInfo, writeMembers, ref bytes, offset, value, formatterResolver);
    ////        }
    ////        else
    ////        {
    ////            return ReflectionObjectFormatterHelper.WriteMapSerialize(metaInfo, writeMembers, writeMemberNames, ref bytes, offset, value, formatterResolver);
    ////        }
    ////    }

    ////    public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    ////    {
    ////        return (T)ReflectionObjectFormatterHelper.Deserialize(metaInfo, readMembers, constructorParameterIndexes, mapMemberDictionary, bytes, offset, formatterResolver, out readSize);
    ////    }
    ////}

    ////internal static class ReflectionObjectFormatterHelper
    ////{
    ////    internal static int WriteArraySerialize(ObjectSerializationInfo metaInfo, ObjectSerializationInfo.EmittableMember[] writeMembers, ref byte[] bytes, int offset, object value, IFormatterResolver formatterResolver)
    ////    {
    ////        var startOffset = offset;

    ////        offset += MessagePackBinary.WriteArrayHeader(ref bytes, offset, writeMembers.Length);
    ////        foreach (var item in metaInfo.Members)
    ////        {
    ////            if (item == null)
    ////            {
    ////                offset += MessagePackBinary.WriteNil(ref bytes, offset);
    ////            }
    ////            else
    ////            {
    ////                var memberValue = item.ReflectionLoadValue(value);
    ////                offset += MessagePackSerializer.NonGeneric.Serialize(item.Type, ref bytes, offset, memberValue, formatterResolver);
    ////            }
    ////        }

    ////        return offset - startOffset;
    ////    }

    ////    internal static int WriteMapSerialize(ObjectSerializationInfo metaInfo, ObjectSerializationInfo.EmittableMember[] writeMembers, byte[][] memberNames, ref byte[] bytes, int offset, object value, IFormatterResolver formatterResolver)
    ////    {
    ////        var startOffset = offset;

    ////        offset += MessagePackBinary.WriteMapHeader(ref bytes, offset, writeMembers.Length);

    ////        for (int i = 0; i < writeMembers.Length; i++)
    ////        {
    ////            offset += MessagePackBinary.WriteStringBytes(ref bytes, offset, memberNames[i]);
    ////            var memberValue = writeMembers[i].ReflectionLoadValue(value);
    ////            offset += MessagePackSerializer.NonGeneric.Serialize(writeMembers[i].Type, ref bytes, offset, memberValue, formatterResolver);
    ////        }

    ////        return offset - startOffset;
    ////    }

    ////    internal static object Deserialize(ObjectSerializationInfo metaInfo, ObjectSerializationInfo.EmittableMember[] readMembers, int[] constructorParameterIndexes, AutomataDictionary mapMemberDictionary, byte[] bytes, int offset, IFormatterResolver formatterResolver, out int readSize)
    ////    {
    ////        var startOffset = offset;
    ////        object[] parameters = null;

    ////        var headerType = MessagePackBinary.GetMessagePackType(bytes, offset);
    ////        if (headerType == MessagePackType.Nil)
    ////        {
    ////            readSize = 1;
    ////            return null;
    ////        }
    ////        else if (headerType == MessagePackType.Array)
    ////        {
    ////            var arraySize = MessagePackBinary.ReadArrayHeader(bytes, offset, out readSize);
    ////            offset += readSize;

    ////            // ReadValues
    ////            parameters = new object[arraySize];
    ////            for (int i = 0; i < arraySize; i++)
    ////            {
    ////                var info = readMembers[i];
    ////                if (info != null)
    ////                {
    ////                    parameters[i] = MessagePackSerializer.NonGeneric.Deserialize(info.Type, bytes, offset, formatterResolver, out readSize);
    ////                    offset += readSize;
    ////                }
    ////                else
    ////                {
    ////                    offset += MessagePackBinary.ReadNextBlock(bytes, offset);
    ////                }
    ////            }
    ////        }
    ////        else if (headerType == MessagePackType.Map)
    ////        {
    ////            var mapSize = MessagePackBinary.ReadMapHeader(bytes, offset, out readSize);
    ////            offset += readSize;

    ////            // ReadValues
    ////            parameters = new object[mapSize];
    ////            for (int i = 0; i < mapSize; i++)
    ////            {
    ////                var rawPropName = MessagePackBinary.ReadStringSegment(bytes, offset, out readSize);
    ////                offset += readSize;

    ////                int index;
    ////                if (mapMemberDictionary.TryGetValue(rawPropName.Array, rawPropName.Offset, rawPropName.Count, out index))
    ////                {
    ////                    var info = readMembers[index];
    ////                    parameters[index] = MessagePackSerializer.NonGeneric.Deserialize(info.Type, bytes, offset, formatterResolver, out readSize);
    ////                    offset += readSize;
    ////                }
    ////                else
    ////                {
    ////                    offset += MessagePackBinary.ReadNextBlock(bytes, offset);
    ////                }
    ////            }
    ////        }
    ////        else
    ////        {
    ////            throw new MessagePackSerializationException("Invalid MessagePackType:" + MessagePackCode.ToFormatName(bytes[offset]));
    ////        }

    ////        // CreateObject
    ////        object result = null;
    ////        if (constructorParameterIndexes.Length == 0)
    ////        {
    ////            result = Activator.CreateInstance(metaInfo.Type);
    ////        }
    ////        else
    ////        {
    ////            var args = new object[constructorParameterIndexes.Length];
    ////            for (int i = 0; i < constructorParameterIndexes.Length; i++)
    ////            {
    ////                args[i] = parameters[constructorParameterIndexes[i]];
    ////            }

    ////            result = Activator.CreateInstance(metaInfo.Type, args);
    ////        }

    ////        // SetMembers
    ////        for (int i = 0; i < readMembers.Length; i++)
    ////        {
    ////            var info = readMembers[i];
    ////            if (info != null)
    ////            {
    ////                info.ReflectionStoreValue(result, parameters[i]);
    ////            }
    ////        }

    ////        readSize = offset - startOffset;
    ////        return result;
    ////    }
    ////}
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/ContractlessReflectionObjectResolver.cs.meta
================================================
fileFormatVersion: 2
guid: e632f1a629022ed4daaff789f1209a31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicEnumAsStringResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Reflection;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    public sealed class DynamicEnumAsStringResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly DynamicEnumAsStringResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        static DynamicEnumAsStringResolver()
        {
            Instance = new DynamicEnumAsStringResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private DynamicEnumAsStringResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                TypeInfo ti = typeof(T).GetTypeInfo();

                if (ti.IsNullable())
                {
                    // build underlying type and use wrapped formatter.
                    ti = ti.GenericTypeArguments[0].GetTypeInfo();
                    if (!ti.IsEnum)
                    {
                        return;
                    }

                    var innerFormatter = DynamicEnumAsStringResolver.Instance.GetFormatterDynamic(ti.AsType());
                    if (innerFormatter == null)
                    {
                        return;
                    }

                    Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(typeof(StaticNullableFormatter<>).MakeGenericType(ti.AsType()), new object[] { innerFormatter });
                    return;
                }
                else if (!ti.IsEnum)
                {
                    return;
                }

                Formatter = (IMessagePackFormatter<T>)(object)new EnumAsStringFormatter<T>();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicEnumAsStringResolver.cs.meta
================================================
fileFormatVersion: 2
guid: ceb07c86c3c5d534195759fcd8983804
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicEnumResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !(UNITY_2018_3_OR_NEWER && NET_STANDARD_2_0)

using System;
using System.Buffers;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// EnumResolver by dynamic code generation, serialized underlying type.
    /// </summary>
    public sealed class DynamicEnumResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly DynamicEnumResolver Instance = new DynamicEnumResolver();

        private const string ModuleName = "MessagePack.Resolvers.DynamicEnumResolver";

        private static readonly Lazy<DynamicAssembly> DynamicAssembly;

        private static int nameSequence = 0;

        private DynamicEnumResolver()
        {
        }

        static DynamicEnumResolver()
        {
            DynamicAssembly = new Lazy<DynamicAssembly>(() => new DynamicAssembly(ModuleName));
        }

#if NETFRAMEWORK
        public AssemblyBuilder Save()
        {
            return DynamicAssembly.Value.Save();
        }
#endif

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                TypeInfo ti = typeof(T).GetTypeInfo();
                if (ti.IsNullable())
                {
                    // build underlying type and use wrapped formatter.
                    ti = ti.GenericTypeArguments[0].GetTypeInfo();
                    if (!ti.IsEnum)
                    {
                        return;
                    }

                    var innerFormatter = DynamicEnumResolver.Instance.GetFormatterDynamic(ti.AsType());
                    if (innerFormatter == null)
                    {
                        return;
                    }

                    Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(typeof(StaticNullableFormatter<>).MakeGenericType(ti.AsType()), new object[] { innerFormatter });
                    return;
                }
                else if (!ti.IsEnum)
                {
                    return;
                }

                TypeInfo formatterTypeInfo = BuildType(typeof(T));
                Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(formatterTypeInfo.AsType());
            }
        }

        private static TypeInfo BuildType(Type enumType)
        {
            Type underlyingType = Enum.GetUnderlyingType(enumType);
            Type formatterType = typeof(IMessagePackFormatter<>).MakeGenericType(enumType);

            using (MonoProtection.EnterRefEmitLock())
            {
                TypeBuilder typeBuilder = DynamicAssembly.Value.DefineType("MessagePack.Formatters." + enumType.FullName.Replace(".", "_") + "Formatter" + Interlocked.Increment(ref nameSequence), TypeAttributes.Public | TypeAttributes.Sealed, null, new[] { formatterType });

                // void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options);
                {
                    MethodBuilder method = typeBuilder.DefineMethod(
                        "Serialize",
                        MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                        null,
                        new Type[] { typeof(MessagePackWriter).MakeByRefType(), enumType, typeof(MessagePackSerializerOptions) });

                    ILGenerator il = method.GetILGenerator();
                    il.Emit(OpCodes.Ldarg_1);
                    il.Emit(OpCodes.Ldarg_2);
                    il.Emit(OpCodes.Call, typeof(MessagePackWriter).GetRuntimeMethod(nameof(MessagePackWriter.Write), new[] { underlyingType }));
                    il.Emit(OpCodes.Ret);
                }

                // T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);
                {
                    MethodBuilder method = typeBuilder.DefineMethod(
                        "Deserialize",
                        MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual,
                        enumType,
                        new Type[] { typeof(MessagePackReader).MakeByRefType(), typeof(MessagePackSerializerOptions) });

                    ILGenerator il = method.GetILGenerator();
                    il.Emit(OpCodes.Ldarg_1);
                    il.Emit(OpCodes.Call, typeof(MessagePackReader).GetRuntimeMethod("Read" + underlyingType.Name, Type.EmptyTypes));
                    il.Emit(OpCodes.Ret);
                }

                return typeBuilder.CreateTypeInfo();
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicEnumResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 4100353110cfb7040b2fa50beb2390ad
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicGenericResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using MessagePack.Formatters;
using MessagePack.Internal;

#pragma warning disable SA1403 // File may only contain a single namespace

namespace MessagePack.Resolvers
{
    public sealed class DynamicGenericResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly DynamicGenericResolver Instance = new DynamicGenericResolver();

        private DynamicGenericResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)DynamicGenericResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }
}

namespace MessagePack.Internal
{
    internal static class DynamicGenericResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, Type> FormatterMap = new Dictionary<Type, Type>()
        {
              { typeof(List<>), typeof(ListFormatter<>) },
              { typeof(LinkedList<>), typeof(LinkedListFormatter<>) },
              { typeof(Queue<>), typeof(QueueFormatter<>) },
              { typeof(Stack<>), typeof(StackFormatter<>) },
              { typeof(HashSet<>), typeof(HashSetFormatter<>) },
              { typeof(ReadOnlyCollection<>), typeof(ReadOnlyCollectionFormatter<>) },
              { typeof(IList<>), typeof(InterfaceListFormatter2<>) },
              { typeof(ICollection<>), typeof(InterfaceCollectionFormatter2<>) },
              { typeof(IEnumerable<>), typeof(InterfaceEnumerableFormatter<>) },
              { typeof(Dictionary<,>), typeof(DictionaryFormatter<,>) },
              { typeof(IDictionary<,>), typeof(InterfaceDictionaryFormatter<,>) },
              { typeof(SortedDictionary<,>), typeof(SortedDictionaryFormatter<,>) },
              { typeof(SortedList<,>), typeof(SortedListFormatter<,>) },
              { typeof(ILookup<,>), typeof(InterfaceLookupFormatter<,>) },
              { typeof(IGrouping<,>), typeof(InterfaceGroupingFormatter<,>) },
              { typeof(ObservableCollection<>), typeof(ObservableCollectionFormatter<>) },
              { typeof(ReadOnlyObservableCollection<>), typeof(ReadOnlyObservableCollectionFormatter<>) },
              { typeof(IReadOnlyList<>), typeof(InterfaceReadOnlyListFormatter<>) },
              { typeof(IReadOnlyCollection<>), typeof(InterfaceReadOnlyCollectionFormatter<>) },
              { typeof(ISet<>), typeof(InterfaceSetFormatter<>) },
              { typeof(System.Collections.Concurrent.ConcurrentBag<>), typeof(ConcurrentBagFormatter<>) },
              { typeof(System.Collections.Concurrent.ConcurrentQueue<>), typeof(ConcurrentQueueFormatter<>) },
              { typeof(System.Collections.Concurrent.ConcurrentStack<>), typeof(ConcurrentStackFormatter<>) },
              { typeof(ReadOnlyDictionary<,>), typeof(ReadOnlyDictionaryFormatter<,>) },
              { typeof(IReadOnlyDictionary<,>), typeof(InterfaceReadOnlyDictionaryFormatter<,>) },
              { typeof(System.Collections.Concurrent.ConcurrentDictionary<,>), typeof(ConcurrentDictionaryFormatter<,>) },
              { typeof(Lazy<>), typeof(LazyFormatter<>) },
        };

        // Reduce IL2CPP code generate size(don't write long code in <T>)
        internal static object GetFormatter(Type t)
        {
            TypeInfo ti = t.GetTypeInfo();

            if (t.IsArray)
            {
                var rank = t.GetArrayRank();
                if (rank == 1)
                {
                    if (t.GetElementType() == typeof(byte))
                    {
                        // byte[] is also supported in builtin formatter.
                        return ByteArrayFormatter.Instance;
                    }

                    return Activator.CreateInstance(typeof(ArrayFormatter<>).MakeGenericType(t.GetElementType()));
                }
                else if (rank == 2)
                {
                    return Activator.CreateInstance(typeof(TwoDimensionalArrayFormatter<>).MakeGenericType(t.GetElementType()));
                }
                else if (rank == 3)
                {
                    return Activator.CreateInstance(typeof(ThreeDimensionalArrayFormatter<>).MakeGenericType(t.GetElementType()));
                }
                else if (rank == 4)
                {
                    return Activator.CreateInstance(typeof(FourDimensionalArrayFormatter<>).MakeGenericType(t.GetElementType()));
                }
                else
                {
                    return null; // not supported built-in
                }
            }
            else if (ti.IsGenericType)
            {
                Type genericType = ti.GetGenericTypeDefinition();
                TypeInfo genericTypeInfo = genericType.GetTypeInfo();
                var isNullable = genericTypeInfo.IsNullable();
                Type nullableElementType = isNullable ? ti.GenericTypeArguments[0] : null;

                if (genericType == typeof(KeyValuePair<,>))
                {
                    return CreateInstance(typeof(KeyValuePairFormatter<,>), ti.GenericTypeArguments);
                }

                // Tuple
                else if (ti.FullName.StartsWith("System.Tuple"))
                {
                    Type tupleFormatterType = null;
                    switch (ti.GenericTypeArguments.Length)
                    {
                        case 1:
                            tupleFormatterType = typeof(TupleFormatter<>);
                            break;
                        case 2:
                            tupleFormatterType = typeof(TupleFormatter<,>);
                            break;
                        case 3:
                            tupleFormatterType = typeof(TupleFormatter<,,>);
                            break;
                        case 4:
                            tupleFormatterType = typeof(TupleFormatter<,,,>);
                            break;
                        case 5:
                            tupleFormatterType = typeof(TupleFormatter<,,,,>);
                            break;
                        case 6:
                            tupleFormatterType = typeof(TupleFormatter<,,,,,>);
                            break;
                        case 7:
                            tupleFormatterType = typeof(TupleFormatter<,,,,,,>);
                            break;
                        case 8:
                            tupleFormatterType = typeof(TupleFormatter<,,,,,,,>);
                            break;
                        default:
                            break;
                    }

                    return CreateInstance(tupleFormatterType, ti.GenericTypeArguments);
                }

                // ValueTuple
                else if (ti.FullName.StartsWith("System.ValueTuple"))
                {
                    Type tupleFormatterType = null;
                    switch (ti.GenericTypeArguments.Length)
                    {
                        case 1:
                            tupleFormatterType = typeof(ValueTupleFormatter<>);
                            break;
                        case 2:
                            tupleFormatterType = typeof(ValueTupleFormatter<,>);
                            break;
                        case 3:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,>);
                            break;
                        case 4:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,,>);
                            break;
                        case 5:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,,,>);
                            break;
                        case 6:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,,,,>);
                            break;
                        case 7:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,,,,,>);
                            break;
                        case 8:
                            tupleFormatterType = typeof(ValueTupleFormatter<,,,,,,,>);
                            break;
                        default:
                            break;
                    }

                    return CreateInstance(tupleFormatterType, ti.GenericTypeArguments);
                }

                // ArraySegment
                else if (genericType == typeof(ArraySegment<>))
                {
                    if (ti.GenericTypeArguments[0] == typeof(byte))
                    {
                        return ByteArraySegmentFormatter.Instance;
                    }
                    else
                    {
                        return CreateInstance(typeof(ArraySegmentFormatter<>), ti.GenericTypeArguments);
                    }
                }

                // Memory
                else if (genericType == typeof(Memory<>))
                {
                    if (ti.GenericTypeArguments[0] == typeof(byte))
                    {
                        return ByteMemoryFormatter.Instance;
                    }
                    else
                    {
                        return CreateInstance(typeof(MemoryFormatter<>), ti.GenericTypeArguments);
                    }
                }

                // ReadOnlyMemory
                else if (genericType == typeof(ReadOnlyMemory<>))
                {
                    if (ti.GenericTypeArguments[0] == typeof(byte))
                    {
                        return ByteReadOnlyMemoryFormatter.Instance;
                    }
                    else
                    {
                        return CreateInstance(typeof(ReadOnlyMemoryFormatter<>), ti.GenericTypeArguments);
                    }
                }

                // ReadOnlySequence
                else if (genericType == typeof(ReadOnlySequence<>))
                {
                    if (ti.GenericTypeArguments[0] == typeof(byte))
                    {
                        return ByteReadOnlySequenceFormatter.Instance;
                    }
                    else
                    {
                        return CreateInstance(typeof(ReadOnlySequenceFormatter<>), ti.GenericTypeArguments);
                    }
                }

                // Standard Nullable
                else if (isNullable)
                {
                    return CreateInstance(typeof(NullableFormatter<>), new[] { nullableElementType });
                }

                // Mapped formatter
                else
                {
                    Type formatterType;
                    if (FormatterMap.TryGetValue(genericType, out formatterType))
                    {
                        return CreateInstance(formatterType, ti.GenericTypeArguments);
                    }
                }
            }
            else if (ti.IsEnum)
            {
                return CreateInstance(typeof(GenericEnumFormatter<>), new[] { t });
            }
            else
            {
                // NonGeneric Collection
                if (t == typeof(IEnumerable))
                {
                    return NonGenericInterfaceEnumerableFormatter.Instance;
                }
                else if (t == typeof(ICollection))
                {
                    return NonGenericInterfaceCollectionFormatter.Instance;
                }
                else if (t == typeof(IList))
                {
                    return NonGenericInterfaceListFormatter.Instance;
                }
                else if (t == typeof(IDictionary))
                {
                    return NonGenericInterfaceDictionaryFormatter.Instance;
                }

                if (typeof(IList).GetTypeInfo().IsAssignableFrom(ti) && ti.DeclaredConstructors.Any(x => x.GetParameters().Length == 0))
                {
                    return Activator.CreateInstance(typeof(NonGenericListFormatter<>).MakeGenericType(t));
                }
                else if (typeof(IDictionary).GetTypeInfo().IsAssignableFrom(ti) && ti.DeclaredConstructors.Any(x => x.GetParameters().Length == 0))
                {
                    return Activator.CreateInstance(typeof(NonGenericDictionaryFormatter<>).MakeGenericType(t));
                }
            }

            // check inherited types(e.g. Foo : ICollection<>, Bar<T> : ICollection<T>)
            {
                // generic dictionary
                var dictionaryDef = ti.ImplementedInterfaces.FirstOrDefault(x => x.GetTypeInfo().IsConstructedGenericType() && x.GetGenericTypeDefinition() == typeof(IDictionary<,>));
                if (dictionaryDef != null && ti.DeclaredConstructors.Any(x => x.GetParameters().Length == 0))
                {
                    Type keyType = dictionaryDef.GenericTypeArguments[0];
                    Type valueType = dictionaryDef.GenericTypeArguments[1];
                    return CreateInstance(typeof(GenericDictionaryFormatter<,,>), new[] { keyType, valueType, t });
                }

                // generic collection
                var collectionDef = ti.ImplementedInterfaces.FirstOrDefault(x => x.GetTypeInfo().IsConstructedGenericType() && x.GetGenericTypeDefinition() == typeof(ICollection<>));
                if (collectionDef != null && ti.DeclaredConstructors.Any(x => x.GetParameters().Length == 0))
                {
                    Type elemType = collectionDef.GenericTypeArguments[0];
                    return CreateInstance(typeof(GenericCollectionFormatter<,>), new[] { elemType, t });
                }
            }

            return null;
        }

        private static object CreateInstance(Type genericType, Type[] genericTypeArguments, params object[] arguments)
        {
            return Activator.CreateInstance(genericType.MakeGenericType(genericTypeArguments), arguments);
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicGenericResolver.cs.meta
================================================
fileFormatVersion: 2
guid: a246239c22950a44bb5bffdb3b388dd2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicObjectResolver.cs.meta
================================================
fileFormatVersion: 2
guid: c701699b2f5475d448a963b344407181
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicUnionResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !(UNITY_2018_3_OR_NEWER && NET_STANDARD_2_0)

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text.RegularExpressions;
using System.Threading;
using MessagePack.Formatters;
using MessagePack.Internal;

#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1509 // Opening braces should not be preceded by blank line

namespace MessagePack.Resolvers
{
    /// <summary>
    /// UnionResolver by dynamic code generation.
    /// </summary>
    public sealed class DynamicUnionResolver : IFormatterResolver
    {
        private const string ModuleName = "MessagePack.Resolvers.DynamicUnionResolver";

        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly DynamicUnionResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        private static readonly Lazy<DynamicAssembly> DynamicAssembly;
#if !UNITY_2018_3_OR_NEWER
        private static readonly Regex SubtractFullNameRegex = new Regex(@", Version=\d+.\d+.\d+.\d+, Culture=\w+, PublicKeyToken=\w+", RegexOptions.Compiled);
#else
        private static readonly Regex SubtractFullNameRegex = new Regex(@", Version=\d+.\d+.\d+.\d+, Culture=\w+, PublicKeyToken=\w+");
#endif

        private static int nameSequence = 0;

        static DynamicUnionResolver()
        {
            Instance = new DynamicUnionResolver();
            Options = new MessagePackSerializerOptions(Instance);
            DynamicAssembly = new Lazy<DynamicAssembly>(() => new DynamicAssembly(ModuleName));
        }

        private DynamicUnionResolver()
        {
        }

#if NETFRAMEWORK
        public AssemblyBuilder Save()
        {
            return DynamicAssembly.Value.Save();
        }
#endif

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                TypeInfo ti = typeof(T).GetTypeInfo();
                if (ti.IsNullable())
                {
                    ti = ti.GenericTypeArguments[0].GetTypeInfo();

                    var innerFormatter = DynamicUnionResolver.Instance.GetFormatterDynamic(ti.AsType());
                    if (innerFormatter == null)
                    {
                        return;
                    }

                    Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(typeof(StaticNullableFormatter<>).MakeGenericType(ti.AsType()), new object[] { innerFormatter });
                    return;
                }

                TypeInfo formatterTypeInfo = BuildType(typeof(T));
                if (formatterTypeInfo == null)
                {
                    return;
                }

                Formatter = (IMessagePackFormatter<T>)Activator.CreateInstance(formatterTypeInfo.AsType());
            }
        }

        private static TypeInfo BuildType(Type type)
        {
            TypeInfo ti = type.GetTypeInfo();

            // order by key(important for use jump-table of switch)
            UnionAttribute[] unionAttrs = ti.GetCustomAttributes<UnionAttribute>().OrderBy(x => x.Key).ToArray();

            if (unionAttrs.Length == 0)
            {
                return null;
            }

            if (!ti.IsInterface && !ti.IsAbstract)
            {
                throw new MessagePackDynamicUnionResolverException("Union can only be interface or abstract class. Type:" + type.Name);
            }

            var checker1 = new HashSet<int>();
            var checker2 = new HashSet<Type>();
            foreach (UnionAttribute item in unionAttrs)
            {
                if (!checker1.Add(item.Key))
                {
                    throw new MessagePackDynamicUnionResolverException("Same union key has found. Type:" + type.Name + " Key:" + item.Key);
                }

                if (!checker2.Add(item.SubType))
                {
                    throw new MessagePackDynamicUnionResolverException("Same union subType has found. Type:" + type.Name + " SubType: " + item.SubType);
                }
            }

            Type formatterType = typeof(IMessagePackFormatter<>).MakeGenericType(type);
            using (MonoProtection.EnterRefEmitLock())
            {
                TypeBuilder typeBuilder = DynamicAssembly.Value.DefineType("MessagePack.Formatters." + SubtractFullNameRegex.Replace(type.FullName, string.Empty).Replace(".", "_") + "Formatter" + +Interlocked.Increment(ref nameSequence), TypeAttributes.Public | TypeAttributes.Sealed, null, new[] { formatterType });

                FieldBuilder typeToKeyAndJumpMap = null; // Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>
                FieldBuilder keyToJumpMap = null; // Dictionary<int, int>

                // create map dictionary
                {
                    ConstructorBuilder method = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, Type.EmptyTypes);
                    typeToKeyAndJumpMap = typeBuilder.DefineField("typeToKeyAndJumpMap", typeof(Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>), FieldAttributes.Private | FieldAttributes.InitOnly);
                    keyToJumpMap = typeBuilder.DefineField("keyToJumpMap", typeof(Dictionary<int, int>), FieldAttributes.Private | FieldAttributes.InitOnly);

                    ILGenerator il = method.GetILGenerator();
                    BuildConstructor(type, unionAttrs, method, typeToKeyAndJumpMap, keyToJumpMap, il);
                }

                {
                    MethodBuilder method = typeBuilder.DefineMethod(
                        "Serialize",
                        MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot,
                        null,
                        new Type[] { typeof(MessagePackWriter).MakeByRefType(), type, typeof(MessagePackSerializerOptions) });

                    ILGenerator il = method.GetILGenerator();
                    BuildSerialize(type, unionAttrs, method, typeToKeyAndJumpMap, il);
                }

                {
                    MethodBuilder method = typeBuilder.DefineMethod(
                        "Deserialize",
                        MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot,
                        type,
                        new Type[] { refMessagePackReader, typeof(MessagePackSerializerOptions) });

                    ILGenerator il = method.GetILGenerator();
                    BuildDeserialize(type, unionAttrs, method, keyToJumpMap, il);
                }

                return typeBuilder.CreateTypeInfo();
            }
        }

        private static void BuildConstructor(Type type, UnionAttribute[] infos, ConstructorInfo method, FieldBuilder typeToKeyAndJumpMap, FieldBuilder keyToJumpMap, ILGenerator il)
        {
            il.EmitLdarg(0);
            il.Emit(OpCodes.Call, objectCtor);

            {
                il.EmitLdarg(0);
                il.EmitLdc_I4(infos.Length);
                il.Emit(OpCodes.Ldsfld, runtimeTypeHandleEqualityComparer);
                il.Emit(OpCodes.Newobj, typeMapDictionaryConstructor);

                var index = 0;
                foreach (UnionAttribute item in infos)
                {
                    il.Emit(OpCodes.Dup);
                    il.Emit(OpCodes.Ldtoken, item.SubType);
                    il.EmitLdc_I4(item.Key);
                    il.EmitLdc_I4(index);
                    il.Emit(OpCodes.Newobj, intIntKeyValuePairConstructor);
                    il.EmitCall(typeMapDictionaryAdd);

                    index++;
                }

                il.Emit(OpCodes.Stfld, typeToKeyAndJumpMap);
            }

            {
                il.EmitLdarg(0);
                il.EmitLdc_I4(infos.Length);
                il.Emit(OpCodes.Newobj, keyMapDictionaryConstructor);

                var index = 0;
                foreach (UnionAttribute item in infos)
                {
                    il.Emit(OpCodes.Dup);
                    il.EmitLdc_I4(item.Key);
                    il.EmitLdc_I4(index);
                    il.EmitCall(keyMapDictionaryAdd);

                    index++;
                }

                il.Emit(OpCodes.Stfld, keyToJumpMap);
            }

            il.Emit(OpCodes.Ret);
        }

        // void Serialize([arg:1]MessagePackWriter writer, [arg:2]T value, [arg:3]MessagePackSerializerOptions options);
        private static void BuildSerialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder typeToKeyAndJumpMap, ILGenerator il)
        {
            // if(value == null) return WriteNil
            Label elseBody = il.DefineLabel();
            Label notFoundType = il.DefineLabel();

            il.EmitLdarg(2);
            il.Emit(OpCodes.Brtrue_S, elseBody);
            il.Emit(OpCodes.Br, notFoundType);
            il.MarkLabel(elseBody);

            // IFormatterResolver resolver = options.Resolver;
            LocalBuilder localResolver = il.DeclareLocal(typeof(IFormatterResolver));
            il.EmitLdarg(3);
            il.EmitCall(getResolverFromOptions);
            il.EmitStloc(localResolver);

            LocalBuilder keyPair = il.DeclareLocal(typeof(KeyValuePair<int, int>));

            il.EmitLoadThis();
            il.EmitLdfld(typeToKeyAndJumpMap);
            il.EmitLdarg(2);
            il.EmitCall(objectGetType);
            il.EmitCall(getTypeHandle);
            il.EmitLdloca(keyPair);
            il.EmitCall(typeMapDictionaryTryGetValue);
            il.Emit(OpCodes.Brfalse, notFoundType);

            // writer.WriteArrayHeader(2, false);
            il.EmitLdarg(1);
            il.EmitLdc_I4(2);
            il.EmitCall(MessagePackWriterTypeInfo.WriteArrayHeader);

            // writer.Write(keyPair.Key)
            il.EmitLdarg(1);
            il.EmitLdloca(keyPair);
            il.EmitCall(intIntKeyValuePairGetKey);
            il.EmitCall(MessagePackWriterTypeInfo.WriteInt32);

            Label loopEnd = il.DefineLabel();

            // switch-case (offset += resolver.GetFormatter.Serialize(with cast)
            var switchLabels = infos.Select(x => new { Label = il.DefineLabel(), Attr = x }).ToArray();
            il.EmitLdloca(keyPair);
            il.EmitCall(intIntKeyValuePairGetValue);
            il.Emit(OpCodes.Switch, switchLabels.Select(x => x.Label).ToArray());
            il.Emit(OpCodes.Br, loopEnd); // default

            foreach (var item in switchLabels)
            {
                il.MarkLabel(item.Label);
                il.EmitLdloc(localResolver);
                il.Emit(OpCodes.Call, getFormatterWithVerify.MakeGenericMethod(item.Attr.SubType));

                il.EmitLdarg(1);
                il.EmitLdarg(2);
                if (item.Attr.SubType.GetTypeInfo().IsValueType)
                {
                    il.Emit(OpCodes.Unbox_Any, item.Attr.SubType);
                }
                else
                {
                    il.Emit(OpCodes.Castclass, item.Attr.SubType);
                }

                il.EmitLdarg(3);
                il.Emit(OpCodes.Callvirt, getSerialize(item.Attr.SubType));

                il.Emit(OpCodes.Br, loopEnd);
            }

            // return;
            il.MarkLabel(loopEnd);
            il.Emit(OpCodes.Ret);

            // else, return WriteNil
            il.MarkLabel(notFoundType);
            il.EmitLdarg(1);
            il.EmitCall(MessagePackWriterTypeInfo.WriteNil);
            il.Emit(OpCodes.Ret);
        }

        // T Deserialize([arg:1]ref MessagePackReader reader, [arg:2]MessagePackSerializerOptions options);
        private static void BuildDeserialize(Type type, UnionAttribute[] infos, MethodBuilder method, FieldBuilder keyToJumpMap, ILGenerator il)
        {
            // if(MessagePackBinary.TryReadNil()) { return null; }
            Label falseLabel = il.DefineLabel();
            il.EmitLdarg(1);
            il.EmitCall(MessagePackReaderTypeInfo.TryReadNil);
            il.Emit(OpCodes.Brfalse_S, falseLabel);

            il.Emit(OpCodes.Ldnull);
            il.Emit(OpCodes.Ret);

            il.MarkLabel(falseLabel);

            // IFormatterResolver resolver = options.Resolver;
            LocalBuilder localResolver = il.DeclareLocal(typeof(IFormatterResolver));
            il.EmitLdarg(2);
            il.EmitCall(getResolverFromOptions);
            il.EmitStloc(localResolver);

            // read-array header and validate, reader.ReadArrayHeader() != 2) throw;
            Label rightLabel = il.DefineLabel();
            var reader = new ArgumentField(il, 1);
            reader.EmitLdarg();
            il.EmitCall(MessagePackReaderTypeInfo.ReadArrayHeader);
            il.EmitLdc_I4(2);
            il.Emit(OpCodes.Beq_S, rightLabel);
            il.Emit(OpCodes.Ldstr, "Invalid Union data was detected. Type:" + type.FullName);
            il.Emit(OpCodes.Newobj, invalidOperationExceptionConstructor);
            il.Emit(OpCodes.Throw);

            il.MarkLabel(rightLabel);

            // read key
            LocalBuilder key = il.DeclareLocal(typeof(int));
            reader.EmitLdarg();
            il.EmitCall(MessagePackReaderTypeInfo.ReadInt32);
            il.EmitStloc(key);

            // is-sequential don't need else convert key to jump-table value
            if (!IsZeroStartSequential(infos))
            {
                Label endKeyMapGet = il.DefineLabel();
                il.EmitLdarg(0);
                il.EmitLdfld(keyToJumpMap);
                il.EmitLdloc(key);
                il.EmitLdloca(key);
                il.EmitCall(keyMapDictionaryTryGetValue);
                il.Emit(OpCodes.Brtrue_S, endKeyMapGet);
                il.EmitLdc_I4(-1);
                il.EmitStloc(key);

                il.MarkLabel(endKeyMapGet);
            }

            // switch->read
            LocalBuilder result = il.DeclareLocal(type);
            Label loopEnd = il.DefineLabel();
            il.Emit(OpCodes.Ldnull);
            il.EmitStloc(result);
            il.Emit(OpCodes.Ldloc, key);

            var switchLabels = infos.Select(x => new { Label = il.DefineLabel(), Attr = x }).ToArray();
            il.Emit(OpCodes.Switch, switchLabels.Select(x => x.Label).ToArray());

            // default
            reader.EmitLdarg();
            il.EmitCall(MessagePackReaderTypeInfo.Skip);
            il.Emit(OpCodes.Br, loopEnd);

            foreach (var item in switchLabels)
            {
                il.MarkLabel(item.Label);
                il.EmitLdloc(localResolver);
                il.EmitCall(getFormatterWithVerify.MakeGenericMethod(item.Attr.SubType));
                il.EmitLdarg(1);
                il.EmitLdarg(2);
                il.EmitCall(getDeserialize(item.Attr.SubType));
                if (item.Attr.SubType.GetTypeInfo().IsValueType)
                {
                    il.Emit(OpCodes.Box, item.Attr.SubType);
                }

                il.Emit(OpCodes.Stloc, result);
                il.Emit(OpCodes.Br, loopEnd);
            }

            il.MarkLabel(loopEnd);

            il.Emit(OpCodes.Ldloc, result);
            il.Emit(OpCodes.Ret);
        }

        private static bool IsZeroStartSequential(UnionAttribute[] infos)
        {
            for (int i = 0; i < infos.Length; i++)
            {
                if (infos[i].Key != i)
                {
                    return false;
                }
            }

            return true;
        }

#pragma warning disable SA1311 // Static readonly fields should begin with upper-case letter

        // EmitInfos...
        private static readonly Type refMessagePackReader = typeof(MessagePackReader).MakeByRefType();
        private static readonly Type refKvp = typeof(KeyValuePair<int, int>).MakeByRefType();
        private static readonly MethodInfo getFormatterWithVerify = typeof(FormatterResolverExtensions).GetRuntimeMethods().First(x => x.Name == "GetFormatterWithVerify");
        private static readonly MethodInfo getResolverFromOptions = typeof(MessagePackSerializerOptions).GetRuntimeProperty(nameof(MessagePackSerializerOptions.Resolver)).GetMethod;

        private static readonly Func<Type, MethodInfo> getSerialize = t => typeof(IMessagePackFormatter<>).MakeGenericType(t).GetRuntimeMethod("Serialize", new[] { typeof(MessagePackWriter).MakeByRefType(), t, typeof(MessagePackSerializerOptions) });
        private static readonly Func<Type, MethodInfo> getDeserialize = t => typeof(IMessagePackFormatter<>).MakeGenericType(t).GetRuntimeMethod("Deserialize", new[] { typeof(MessagePackReader).MakeByRefType(), typeof(MessagePackSerializerOptions) });

        private static readonly FieldInfo runtimeTypeHandleEqualityComparer = typeof(RuntimeTypeHandleEqualityComparer).GetRuntimeField("Default");
        private static readonly ConstructorInfo intIntKeyValuePairConstructor = typeof(KeyValuePair<int, int>).GetTypeInfo().DeclaredConstructors.First(x => x.GetParameters().Length == 2);
        private static readonly ConstructorInfo typeMapDictionaryConstructor = typeof(Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>).GetTypeInfo().DeclaredConstructors.First(x =>
        {
            ParameterInfo[] p = x.GetParameters();
            return p.Length == 2 && p[0].ParameterType == typeof(int);
        });

        private static readonly MethodInfo typeMapDictionaryAdd = typeof(Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>).GetRuntimeMethod("Add", new[] { typeof(RuntimeTypeHandle), typeof(KeyValuePair<int, int>) });
        private static readonly MethodInfo typeMapDictionaryTryGetValue = typeof(Dictionary<RuntimeTypeHandle, KeyValuePair<int, int>>).GetRuntimeMethod("TryGetValue", new[] { typeof(RuntimeTypeHandle), refKvp });

        private static readonly ConstructorInfo keyMapDictionaryConstructor = typeof(Dictionary<int, int>).GetTypeInfo().DeclaredConstructors.First(x =>
        {
            ParameterInfo[] p = x.GetParameters();
            return p.Length == 1 && p[0].ParameterType == typeof(int);
        });

        private static readonly MethodInfo keyMapDictionaryAdd = typeof(Dictionary<int, int>).GetRuntimeMethod("Add", new[] { typeof(int), typeof(int) });
        private static readonly MethodInfo keyMapDictionaryTryGetValue = typeof(Dictionary<int, int>).GetRuntimeMethod("TryGetValue", new[] { typeof(int), typeof(int).MakeByRefType() });

        private static readonly MethodInfo objectGetType = typeof(object).GetRuntimeMethod("GetType", Type.EmptyTypes);
        private static readonly MethodInfo getTypeHandle = typeof(Type).GetRuntimeProperty("TypeHandle").GetGetMethod();

        private static readonly MethodInfo intIntKeyValuePairGetKey = typeof(KeyValuePair<int, int>).GetRuntimeProperty("Key").GetGetMethod();
        private static readonly MethodInfo intIntKeyValuePairGetValue = typeof(KeyValuePair<int, int>).GetRuntimeProperty("Value").GetGetMethod();

        private static readonly ConstructorInfo invalidOperationExceptionConstructor = typeof(System.InvalidOperationException).GetTypeInfo().DeclaredConstructors.First(
            x =>
            {
                ParameterInfo[] p = x.GetParameters();
                return p.Length == 1 && p[0].ParameterType == typeof(string);
            });

        private static readonly ConstructorInfo objectCtor = typeof(object).GetTypeInfo().DeclaredConstructors.First(x => x.GetParameters().Length == 0);

#pragma warning restore SA1311 // Static readonly fields should begin with upper-case letter

        private static class MessagePackReaderTypeInfo
        {
            internal static readonly TypeInfo ReaderTypeInfo = typeof(MessagePackReader).GetTypeInfo();

            internal static readonly MethodInfo ReadBytes = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.ReadBytes), Type.EmptyTypes);
            internal static readonly MethodInfo ReadInt32 = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.ReadInt32), Type.EmptyTypes);
            internal static readonly MethodInfo ReadString = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.ReadString), Type.EmptyTypes);
            internal static readonly MethodInfo TryReadNil = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.TryReadNil), Type.EmptyTypes);
            internal static readonly MethodInfo Skip = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.Skip), Type.EmptyTypes);
            internal static readonly MethodInfo ReadArrayHeader = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.ReadArrayHeader), Type.EmptyTypes);
            internal static readonly MethodInfo ReadMapHeader = typeof(MessagePackReader).GetRuntimeMethod(nameof(MessagePackReader.ReadMapHeader), Type.EmptyTypes);
        }

        private static class MessagePackWriterTypeInfo
        {
            internal static readonly TypeInfo WriterTypeInfo = typeof(MessagePackWriter).GetTypeInfo();

            internal static readonly MethodInfo WriteArrayHeader = typeof(MessagePackWriter).GetRuntimeMethod(nameof(MessagePackWriter.WriteArrayHeader), new[] { typeof(int) });
            internal static readonly MethodInfo WriteInt32 = typeof(MessagePackWriter).GetRuntimeMethod(nameof(MessagePackWriter.Write), new[] { typeof(int) });
            internal static readonly MethodInfo WriteNil = typeof(MessagePackWriter).GetRuntimeMethod(nameof(MessagePackWriter.WriteNil), Type.EmptyTypes);
        }
    }

    internal class MessagePackDynamicUnionResolverException : MessagePackSerializationException
    {
        public MessagePackDynamicUnionResolverException(string message)
            : base(message)
        {
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/DynamicUnionResolver.cs.meta
================================================
fileFormatVersion: 2
guid: bf9a25b7376eeda47ab1f62b045063bb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/ExpandoObjectResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Collections.Generic;
using System.Dynamic;
using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// A resolver for use when deserializing MessagePack data where the schema is not known at compile-time
    /// such that strong-types can be instantiated.
    /// Instead, <see cref="ExpandoObject"/> is used wherever a MessagePack <em>map</em> is encountered.
    /// </summary>
    public static class ExpandoObjectResolver
    {
        /// <summary>
        /// The resolver to use to deserialize into C#'s <c>dynamic</c> keyword.
        /// </summary>
        /// <remarks>
        /// This resolver includes more than just the <see cref="ExpandoObjectFormatter"/>.
        /// </remarks>
        public static readonly IFormatterResolver Instance = CompositeResolver.Create(
            new IMessagePackFormatter[]
            {
                ExpandoObjectFormatter.Instance,
                new PrimitiveObjectWithExpandoMaps(),
            },
            new IFormatterResolver[] { BuiltinResolver.Instance });

        /// <summary>
        /// A set of options that includes the <see cref="Instance"/>
        /// and puts the deserializer into <see cref="MessagePackSecurity.UntrustedData"/> mode.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options = MessagePackSerializerOptions.Standard
            .WithSecurity(MessagePackSecurity.UntrustedData) // when the schema isn't known beforehand, that generally suggests you don't know/trust the data.
            .WithResolver(Instance);

        private class PrimitiveObjectWithExpandoMaps : PrimitiveObjectFormatter
        {
            protected override object DeserializeMap(ref MessagePackReader reader, int length, MessagePackSerializerOptions options)
            {
                IMessagePackFormatter<string> keyFormatter = options.Resolver.GetFormatterWithVerify<string>();
                IMessagePackFormatter<object> objectFormatter = options.Resolver.GetFormatter<object>();
                IDictionary<string, object> dictionary = new ExpandoObject();
                for (int i = 0; i < length; i++)
                {
                    var key = keyFormatter.Deserialize(ref reader, options);
                    var value = objectFormatter.Deserialize(ref reader, options);
                    dictionary.Add(key, value);
                }

                return dictionary;
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/ExpandoObjectResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 96998b3cb6d6e044c95e399ea6d6da96
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeDateTimeResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using MessagePack.Formatters;
using MessagePack.Internal;

#pragma warning disable SA1403 // File may only contain a single namespace

namespace MessagePack.Resolvers
{
    public sealed class NativeDateTimeResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly NativeDateTimeResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        static NativeDateTimeResolver()
        {
            Instance = new NativeDateTimeResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private NativeDateTimeResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)NativeDateTimeResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }
}

namespace MessagePack.Internal
{
    internal static class NativeDateTimeResolverGetFormatterHelper
    {
        internal static object GetFormatter(Type t)
        {
            if (t == typeof(DateTime))
            {
                return NativeDateTimeFormatter.Instance;
            }
            else if (t == typeof(DateTime?))
            {
                return new StaticNullableFormatter<DateTime>(NativeDateTimeFormatter.Instance);
            }
            else if (t == typeof(DateTime[]))
            {
                return NativeDateTimeArrayFormatter.Instance;
            }

            return null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeDateTimeResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 8a20dfff612ed08419192bb868710915
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeDecimalResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    public sealed class NativeDecimalResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly NativeDecimalResolver Instance = new NativeDecimalResolver();

        private NativeDecimalResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static object GetFormatterHelper(Type t)
        {
            if (t == typeof(Decimal))
            {
                return NativeDecimalFormatter.Instance;
            }
            else if (t == typeof(Decimal?))
            {
                return new StaticNullableFormatter<Decimal>(NativeDecimalFormatter.Instance);
            }

            return null;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)GetFormatterHelper(typeof(T));
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeDecimalResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 0711ad34c9883f244a09757b2470ed67
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeGuidResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    public sealed class NativeGuidResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly NativeGuidResolver Instance = new NativeGuidResolver();

        private NativeGuidResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static object GetFormatterHelper(Type t)
        {
            if (t == typeof(Guid))
            {
                return NativeGuidFormatter.Instance;
            }
            else if (t == typeof(Guid?))
            {
                return new StaticNullableFormatter<Guid>(NativeGuidFormatter.Instance);
            }

            return null;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)GetFormatterHelper(typeof(T));
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/NativeGuidResolver.cs.meta
================================================
fileFormatVersion: 2
guid: a30757bd25ef7c44ba11a2ecbe64a8c1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/PrimitiveObjectResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    public sealed class PrimitiveObjectResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly PrimitiveObjectResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        static PrimitiveObjectResolver()
        {
            Instance = new PrimitiveObjectResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private PrimitiveObjectResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (typeof(T) == typeof(object))
                    ? (IMessagePackFormatter<T>)(object)PrimitiveObjectFormatter.Instance
                    : null;
            }
        }
    }

    ////#if !UNITY_2018_3_OR_NEWER

    ////    /// <summary>
    ////    /// In `object`, when serializing resolve by concrete type and when deserializing use primitive.
    ////    /// </summary>
    ////    public sealed class DynamicObjectTypeFallbackResolver : IFormatterResolver
    ////    {
    ////        public static readonly DynamicObjectTypeFallbackResolver Instance = new DynamicObjectTypeFallbackResolver();

    ////        DynamicObjectTypeFallbackResolver()
    ////        {

    ////        }

    ////        public IMessagePackFormatter<T> GetFormatter<T>()
    ////        {
    ////            return FormatterCache<T>.formatter;
    ////        }

    ////        static class FormatterCache<T>
    ////        {
    ////            public static readonly IMessagePackFormatter<T> formatter;

    ////            static FormatterCache()
    ////            {
    ////                formatter = (typeof(T) == typeof(object))
    ////                    ? (IMessagePackFormatter<T>)(object)DynamicObjectTypeFallbackFormatter.Instance
    ////                    : null;
    ////            }
    ////        }
    ////    }

    ////#endif
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/PrimitiveObjectResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 9e84d60bb85b40b458a001118316145d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/StandardResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Linq;
using MessagePack.Formatters;
using MessagePack.Internal;
using MessagePack.Resolvers;

#pragma warning disable SA1403 // File may only contain a single namespace

namespace MessagePack.Resolvers
{
    /// <summary>
    /// Default composited resolver, builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> primitive.
    /// </summary>
    public sealed class StandardResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly StandardResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        private static readonly IFormatterResolver[] Resolvers = StandardResolverHelper.DefaultResolvers.Concat(new IFormatterResolver[]
        {
#if !ENABLE_IL2CPP && !NET_STANDARD_2_0
            DynamicObjectResolver.Instance, // Try Object
#endif
        }).ToArray();

        static StandardResolver()
        {
            Instance = new StandardResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private StandardResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                if (typeof(T) == typeof(object))
                {
                    // final fallback
#if !ENABLE_IL2CPP
                    Formatter = (IMessagePackFormatter<T>)DynamicObjectTypeFallbackFormatter.Instance;
#else
                    Formatter = PrimitiveObjectResolver.Instance.GetFormatter<T>();
#endif
                }
                else
                {
                    foreach (IFormatterResolver item in Resolvers)
                    {
                        IMessagePackFormatter<T> f = item.GetFormatter<T>();
                        if (f != null)
                        {
                            Formatter = f;
                            return;
                        }
                    }
                }
            }
        }
    }

    public sealed class ContractlessStandardResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly ContractlessStandardResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        private static readonly IFormatterResolver[] Resolvers = StandardResolverHelper.DefaultResolvers.Concat(new IFormatterResolver[]
        {
#if !ENABLE_IL2CPP && !NET_STANDARD_2_0
            DynamicObjectResolver.Instance, // Try Object
            DynamicContractlessObjectResolver.Instance, // Serializes keys as strings
#endif
        }).ToArray();

        static ContractlessStandardResolver()
        {
            Instance = new ContractlessStandardResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private ContractlessStandardResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                if (typeof(T) == typeof(object))
                {
                    // final fallback
#if !ENABLE_IL2CPP
                    Formatter = (IMessagePackFormatter<T>)DynamicObjectTypeFallbackFormatter.Instance;
#else
                    Formatter = PrimitiveObjectResolver.Instance.GetFormatter<T>();
#endif
                }
                else
                {
                    foreach (IFormatterResolver item in Resolvers)
                    {
                        IMessagePackFormatter<T> f = item.GetFormatter<T>();
                        if (f != null)
                        {
                            Formatter = f;
                            return;
                        }
                    }
                }
            }
        }
    }

    public sealed class StandardResolverAllowPrivate : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly StandardResolverAllowPrivate Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        private static readonly IFormatterResolver[] Resolvers = StandardResolverHelper.DefaultResolvers.Concat(new IFormatterResolver[]
        {
#if !ENABLE_IL2CPP && !NET_STANDARD_2_0
            DynamicObjectResolverAllowPrivate.Instance, // Try Object
#endif
        }).ToArray();

        static StandardResolverAllowPrivate()
        {
            Instance = new StandardResolverAllowPrivate();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private StandardResolverAllowPrivate()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                if (typeof(T) == typeof(object))
                {
                    // final fallback
#if !ENABLE_IL2CPP
                    Formatter = (IMessagePackFormatter<T>)DynamicObjectTypeFallbackFormatter.Instance;
#else
                    Formatter = PrimitiveObjectResolver.Instance.GetFormatter<T>();
#endif
                }
                else
                {
                    foreach (IFormatterResolver item in Resolvers)
                    {
                        IMessagePackFormatter<T> f = item.GetFormatter<T>();
                        if (f != null)
                        {
                            Formatter = f;
                            return;
                        }
                    }
                }
            }
        }
    }

    public sealed class ContractlessStandardResolverAllowPrivate : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly ContractlessStandardResolverAllowPrivate Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        private static readonly IFormatterResolver[] Resolvers = StandardResolverHelper.DefaultResolvers.Concat(new IFormatterResolver[]
        {
#if !ENABLE_IL2CPP && !NET_STANDARD_2_0
            DynamicObjectResolverAllowPrivate.Instance, // Try Object
            DynamicContractlessObjectResolverAllowPrivate.Instance, // Serializes keys as strings
#endif
        }).ToArray();

        static ContractlessStandardResolverAllowPrivate()
        {
            Instance = new ContractlessStandardResolverAllowPrivate();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private ContractlessStandardResolverAllowPrivate()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                if (typeof(T) == typeof(object))
                {
                    // final fallback
#if !ENABLE_IL2CPP
                    Formatter = (IMessagePackFormatter<T>)DynamicObjectTypeFallbackFormatter.Instance;
#else
                    Formatter = PrimitiveObjectResolver.Instance.GetFormatter<T>();
#endif
                }
                else
                {
                    foreach (IFormatterResolver item in Resolvers)
                    {
                        IMessagePackFormatter<T> f = item.GetFormatter<T>();
                        if (f != null)
                        {
                            Formatter = f;
                            return;
                        }
                    }
                }
            }
        }
    }
}

namespace MessagePack.Internal
{
    internal static class StandardResolverHelper
    {
        public static readonly IFormatterResolver[] DefaultResolvers = new IFormatterResolver[]
        {
            BuiltinResolver.Instance, // Try Builtin
            AttributeFormatterResolver.Instance, // Try use [MessagePackFormatter]

#if UNITY_2018_3_OR_NEWER
            MessagePack.Unity.UnityResolver.Instance,
#else
            ImmutableCollection.ImmutableCollectionResolver.Instance,
            CompositeResolver.Create(ExpandoObjectFormatter.Instance),
#endif

#if !ENABLE_IL2CPP
            DynamicGenericResolver.Instance, // Try Array, Tuple, Collection, Enum(Generic Fallback)
#endif

#if !ENABLE_IL2CPP && !NET_STANDARD_2_0
            DynamicUnionResolver.Instance, // Try Union(Interface)
#endif
        };
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/StandardResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 99e7c1a56d89ab645b824dae6b57d67c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/StaticCompositeResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using MessagePack.Formatters;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// Singleton version of CompositeResolver, which be able to register a collection of formatters and resolvers to a single instance.
    /// </summary>
    public class StaticCompositeResolver : IFormatterResolver
    {
        public static readonly StaticCompositeResolver Instance = new StaticCompositeResolver();

        private bool freezed;
        private IReadOnlyList<IMessagePackFormatter> formatters;
        private IReadOnlyList<IFormatterResolver> resolvers;

        private StaticCompositeResolver()
        {
            formatters = Array.Empty<IMessagePackFormatter>();
            resolvers = Array.Empty<IFormatterResolver>();
        }

        /// <summary>
        /// Initializes a singleton instance with the specified formatters.
        /// This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
        /// If call twice in the Register methods, registered formatters and resolvers will be overridden.
        /// </summary>
        /// <param name="formatters">
        /// A list of instances of <see cref="IMessagePackFormatter{T}"/>.
        /// The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
        /// </param>
        public void Register(params IMessagePackFormatter[] formatters)
        {
            if (this.freezed)
            {
                throw new InvalidOperationException("Register must call on startup(before use GetFormatter<T>).");
            }

            if (this.formatters is null)
            {
                throw new ArgumentNullException(nameof(formatters));
            }

            this.formatters = formatters;
            this.resolvers = Array.Empty<IFormatterResolver>();
        }

        /// <summary>
        /// Initializes a singleton instance with the specified formatters and sub-resolvers.
        /// This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
        /// If call twice in the Register methods, registered formatters and resolvers will be overridden.
        /// </summary>
        /// <param name="resolvers">
        /// A list of resolvers to use for serializing types.
        /// The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
        /// </param>
        public void Register(params IFormatterResolver[] resolvers)
        {
            if (this.freezed)
            {
                throw new InvalidOperationException("Register must call on startup(before use GetFormatter<T>).");
            }

            if (resolvers is null)
            {
                throw new ArgumentNullException(nameof(resolvers));
            }

            this.formatters = Array.Empty<IMessagePackFormatter>();
            this.resolvers = resolvers;
        }

        /// <summary>
        /// Initializes a singleton instance with the specified formatters and sub-resolvers.
        /// This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
        /// If call twice in the Register methods, registered formatters and resolvers will be overridden.
        /// </summary>
        /// <param name="formatters">
        /// A list of instances of <see cref="IMessagePackFormatter{T}"/>.
        /// The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
        /// </param>
        /// <param name="resolvers">
        /// A list of resolvers to use for serializing types for which <paramref name="formatters"/> does not include a formatter.
        /// The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
        /// </param>
        public void Register(IReadOnlyList<IMessagePackFormatter> formatters, IReadOnlyList<IFormatterResolver> resolvers)
        {
            if (this.freezed)
            {
                throw new InvalidOperationException("Register must call on startup(before use GetFormatter<T>).");
            }

            if (formatters is null)
            {
                throw new ArgumentNullException(nameof(formatters));
            }

            if (resolvers is null)
            {
                throw new ArgumentNullException(nameof(resolvers));
            }

            this.formatters = formatters;
            this.resolvers = resolvers;
        }

        /// <summary>
        /// Gets an <see cref="IMessagePackFormatter{T}"/> instance that can serialize or deserialize some type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type of value to be serialized or deserialized.</typeparam>
        /// <returns>A formatter, if this resolver supplies one for type <typeparamref name="T"/>; otherwise <c>null</c>.</returns>
        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return Cache<T>.Formatter;
        }

        private static class Cache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static Cache()
            {
                Instance.freezed = true;
                foreach (var item in Instance.formatters)
                {
                    if (item is IMessagePackFormatter<T> f)
                    {
                        Formatter = f;
                        return;
                    }
                }

                foreach (var item in Instance.resolvers)
                {
                    var f = item.GetFormatter<T>();
                    if (f != null)
                    {
                        Formatter = f;
                        return;
                    }
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/StaticCompositeResolver.cs.meta
================================================
fileFormatVersion: 2
guid: d904ee272668ccb448b3159036454caf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/TypelessContractlessStandardResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !UNITY_2018_3_OR_NEWER
using System;
using System.Collections.Generic;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
    /// <summary>
    /// Embeds the full name of .NET types for <see cref="object"/> typed fields/collection items
    /// Preserves .NET <see cref="DateTime"/> timezone.
    /// </summary>
    public sealed class TypelessContractlessStandardResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly TypelessContractlessStandardResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        /// <summary>
        /// A *private* list of resolvers. If we ever want to expose any of these (so the user can adjust settings, etc.)
        /// then we must make this an instance collection instead of a static collection so that each consumer can have their own settings.
        /// </summary>
        private static readonly IReadOnlyList<IFormatterResolver> Resolvers = new IFormatterResolver[]
        {
            NativeDateTimeResolver.Instance, // Native c# DateTime format, preserving timezone
            ForceSizePrimitiveObjectResolver.Instance, // Preserve particular integer types
            BuiltinResolver.Instance, // Try Builtin
            AttributeFormatterResolver.Instance, // Try use [MessagePackFormatter]
#if !ENABLE_IL2CPP
            DynamicEnumResolver.Instance, // Try Enum
            DynamicGenericResolver.Instance, // Try Array, Tuple, Collection
            DynamicUnionResolver.Instance, // Try Union(Interface)
            DynamicObjectResolver.Instance, // Try Object
#endif
            DynamicContractlessObjectResolverAllowPrivate.Instance, // Serializes keys as strings
            TypelessObjectResolver.Instance,
        };

        static TypelessContractlessStandardResolver()
        {
            Instance = new TypelessContractlessStandardResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private readonly ResolverCache resolverCache = new ResolverCache(Resolvers);

        public IMessagePackFormatter<T> GetFormatter<T>() => this.resolverCache.GetFormatter<T>();

        private class ResolverCache : CachingFormatterResolver
        {
            private readonly IReadOnlyList<IFormatterResolver> resolvers;

            internal ResolverCache(IReadOnlyList<IFormatterResolver> resolvers)
            {
                this.resolvers = resolvers ?? throw new ArgumentNullException(nameof(resolvers));
            }

            protected override IMessagePackFormatter<T> GetFormatterCore<T>()
            {
                foreach (IFormatterResolver item in this.resolvers)
                {
                    IMessagePackFormatter<T> f = item.GetFormatter<T>();
                    if (f != null)
                    {
                        return f;
                    }
                }

                return null;
            }
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/TypelessContractlessStandardResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 6db1c844b382ce54680f6d0ba3476abb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/TypelessObjectResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using MessagePack.Formatters;
using MessagePack.Internal;

namespace MessagePack.Resolvers
{
#if !UNITY_2018_3_OR_NEWER

    /// <summary>
    /// Used for `object` fields/collections, ex: var arr = new object[] { 1, "a", new Model() };
    /// The runtime type of value in object field, should be covered by one of resolvers in complex/standard resolver.
    /// <see cref="TypelessObjectResolver"/> should be placed before DynamicObjectTypeFallbackResolver and <see cref="PrimitiveObjectFormatter"/> in resolvers list.
    /// Deserializer uses Namespace.TypeName, AssemblyName to get runtime type in destination app, so that combination must be present in destination app.
    /// Serialized binary is valid MessagePack binary used ext-format and custom typecode(100).
    /// Inside ext - assembly qualified type name, and serialized object.
    /// </summary>
    public sealed class TypelessObjectResolver : IFormatterResolver
    {
        public static readonly IFormatterResolver Instance = new TypelessObjectResolver();

        private static readonly IFormatterResolver[] Resolvers = new IFormatterResolver[]
        {
            ForceSizePrimitiveObjectResolver.Instance,
            ContractlessStandardResolverAllowPrivate.Instance,
        };

        private TypelessObjectResolver()
        {
        }

        /// <inheritdoc />
        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return Cache<T>.Formatter;
        }

        private static class Cache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static Cache()
            {
                if (typeof(T).IsAbstract || typeof(T).IsInterface)
                {
                    Formatter = new ForceTypelessFormatter<T>();
                }

                if (typeof(T) == typeof(object))
                {
                    Formatter = (IMessagePackFormatter<T>)TypelessFormatter.Instance;
                }
                else
                {
                    foreach (var item in Resolvers)
                    {
                        var f = item.GetFormatter<T>();
                        if (f != null)
                        {
                            Formatter = f;
                        }
                    }
                }
            }
        }
    }

    /* helpers for TypelessFormatter */

    internal sealed class ForceSizePrimitiveObjectResolver : IFormatterResolver
    {
        /// <summary>
        /// The singleton instance that can be used.
        /// </summary>
        public static readonly ForceSizePrimitiveObjectResolver Instance;

        /// <summary>
        /// A <see cref="MessagePackSerializerOptions"/> instance with this formatter pre-configured.
        /// </summary>
        public static readonly MessagePackSerializerOptions Options;

        static ForceSizePrimitiveObjectResolver()
        {
            Instance = new ForceSizePrimitiveObjectResolver();
            Options = new MessagePackSerializerOptions(Instance);
        }

        private ForceSizePrimitiveObjectResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)Helper.GetFormatter(typeof(T));
            }
        }

        private static class Helper
        {
            private static readonly Dictionary<Type, object> FormatterMap = new Dictionary<Type, object>()
            {
                // Primitive
                { typeof(Int16), ForceInt16BlockFormatter.Instance },
                { typeof(Int32), ForceInt32BlockFormatter.Instance },
                { typeof(Int64), ForceInt64BlockFormatter.Instance },
                { typeof(UInt16), ForceUInt16BlockFormatter.Instance },
                { typeof(UInt32), ForceUInt32BlockFormatter.Instance },
                { typeof(UInt64), ForceUInt64BlockFormatter.Instance },
                { typeof(byte), ForceByteBlockFormatter.Instance },
                { typeof(sbyte), ForceSByteBlockFormatter.Instance },

                // Nullable Primitive
                { typeof(Int16?), NullableForceInt16BlockFormatter.Instance },
                { typeof(Int32?), NullableForceInt32BlockFormatter.Instance },
                { typeof(Int64?), NullableForceInt64BlockFormatter.Instance },
                { typeof(UInt16?), NullableForceUInt16BlockFormatter.Instance },
                { typeof(UInt32?), NullableForceUInt32BlockFormatter.Instance },
                { typeof(UInt64?), NullableForceUInt64BlockFormatter.Instance },
                { typeof(byte?), NullableForceByteBlockFormatter.Instance },
                { typeof(sbyte?), NullableForceSByteBlockFormatter.Instance },

                // optimized primitive array formatter
                { typeof(Int16[]), ForceInt16BlockArrayFormatter.Instance },
                { typeof(Int32[]), ForceInt32BlockArrayFormatter.Instance },
                { typeof(Int64[]), ForceInt64BlockArrayFormatter.Instance },
                { typeof(UInt16[]), ForceUInt16BlockArrayFormatter.Instance },
                { typeof(UInt32[]), ForceUInt32BlockArrayFormatter.Instance },
                { typeof(UInt64[]), ForceUInt64BlockArrayFormatter.Instance },
                { typeof(SByte[]), ForceSByteBlockArrayFormatter.Instance },
            };

            public static object GetFormatter(Type type)
            {
                object formatter;
                return FormatterMap.TryGetValue(type, out formatter)
                    ? formatter
                    : null;
            }
        }
    }

#endif
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Resolvers/TypelessObjectResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 38df7384160fb4d478fcae83f15f45b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/ForceSizePrimitiveFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class ForceInt16BlockFormatter : IMessagePackFormatter<Int16>
    {
        public static readonly ForceInt16BlockFormatter Instance = new ForceInt16BlockFormatter();

        private ForceInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16 value, MessagePackSerializerOptions options)
        {
            writer.WriteInt16(value);
        }

        public Int16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt16();
        }
    }

    public sealed class NullableForceInt16BlockFormatter : IMessagePackFormatter<Int16?>
    {
        public static readonly NullableForceInt16BlockFormatter Instance = new NullableForceInt16BlockFormatter();

        private NullableForceInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteInt16(value.Value);
            }
        }

        public Int16? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt16();
            }
        }
    }

    public sealed class ForceInt16BlockArrayFormatter : IMessagePackFormatter<Int16[]>
    {
        public static readonly ForceInt16BlockArrayFormatter Instance = new ForceInt16BlockArrayFormatter();

        private ForceInt16BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteInt16(value[i]);
                }
            }
        }

        public Int16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int16>();
            }

            var array = new Int16[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadInt16();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceInt32BlockFormatter : IMessagePackFormatter<Int32>
    {
        public static readonly ForceInt32BlockFormatter Instance = new ForceInt32BlockFormatter();

        private ForceInt32BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32 value, MessagePackSerializerOptions options)
        {
            writer.WriteInt32(value);
        }

        public Int32 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt32();
        }
    }

    public sealed class NullableForceInt32BlockFormatter : IMessagePackFormatter<Int32?>
    {
        public static readonly NullableForceInt32BlockFormatter Instance = new NullableForceInt32BlockFormatter();

        private NullableForceInt32BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteInt32(value.Value);
            }
        }

        public Int32? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt32();
            }
        }
    }

    public sealed class ForceInt32BlockArrayFormatter : IMessagePackFormatter<Int32[]>
    {
        public static readonly ForceInt32BlockArrayFormatter Instance = new ForceInt32BlockArrayFormatter();

        private ForceInt32BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteInt32(value[i]);
                }
            }
        }

        public Int32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int32>();
            }

            var array = new Int32[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadInt32();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceInt64BlockFormatter : IMessagePackFormatter<Int64>
    {
        public static readonly ForceInt64BlockFormatter Instance = new ForceInt64BlockFormatter();

        private ForceInt64BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64 value, MessagePackSerializerOptions options)
        {
            writer.WriteInt64(value);
        }

        public Int64 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt64();
        }
    }

    public sealed class NullableForceInt64BlockFormatter : IMessagePackFormatter<Int64?>
    {
        public static readonly NullableForceInt64BlockFormatter Instance = new NullableForceInt64BlockFormatter();

        private NullableForceInt64BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteInt64(value.Value);
            }
        }

        public Int64? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt64();
            }
        }
    }

    public sealed class ForceInt64BlockArrayFormatter : IMessagePackFormatter<Int64[]>
    {
        public static readonly ForceInt64BlockArrayFormatter Instance = new ForceInt64BlockArrayFormatter();

        private ForceInt64BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteInt64(value[i]);
                }
            }
        }

        public Int64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int64>();
            }

            var array = new Int64[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadInt64();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceUInt16BlockFormatter : IMessagePackFormatter<UInt16>
    {
        public static readonly ForceUInt16BlockFormatter Instance = new ForceUInt16BlockFormatter();

        private ForceUInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16 value, MessagePackSerializerOptions options)
        {
            writer.WriteUInt16(value);
        }

        public UInt16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt16();
        }
    }

    public sealed class NullableForceUInt16BlockFormatter : IMessagePackFormatter<UInt16?>
    {
        public static readonly NullableForceUInt16BlockFormatter Instance = new NullableForceUInt16BlockFormatter();

        private NullableForceUInt16BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteUInt16(value.Value);
            }
        }

        public UInt16? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt16();
            }
        }
    }

    public sealed class ForceUInt16BlockArrayFormatter : IMessagePackFormatter<UInt16[]>
    {
        public static readonly ForceUInt16BlockArrayFormatter Instance = new ForceUInt16BlockArrayFormatter();

        private ForceUInt16BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteUInt16(value[i]);
                }
            }
        }

        public UInt16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt16>();
            }

            var array = new UInt16[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadUInt16();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceUInt32BlockFormatter : IMessagePackFormatter<UInt32>
    {
        public static readonly ForceUInt32BlockFormatter Instance = new ForceUInt32BlockFormatter();

        private ForceUInt32BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32 value, MessagePackSerializerOptions options)
        {
            writer.WriteUInt32(value);
        }

        public UInt32 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt32();
        }
    }

    public sealed class NullableForceUInt32BlockFormatter : IMessagePackFormatter<UInt32?>
    {
        public static readonly NullableForceUInt32BlockFormatter Instance = new NullableForceUInt32BlockFormatter();

        private NullableForceUInt32BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteUInt32(value.Value);
            }
        }

        public UInt32? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt32();
            }
        }
    }

    public sealed class ForceUInt32BlockArrayFormatter : IMessagePackFormatter<UInt32[]>
    {
        public static readonly ForceUInt32BlockArrayFormatter Instance = new ForceUInt32BlockArrayFormatter();

        private ForceUInt32BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteUInt32(value[i]);
                }
            }
        }

        public UInt32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt32>();
            }

            var array = new UInt32[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadUInt32();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceUInt64BlockFormatter : IMessagePackFormatter<UInt64>
    {
        public static readonly ForceUInt64BlockFormatter Instance = new ForceUInt64BlockFormatter();

        private ForceUInt64BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64 value, MessagePackSerializerOptions options)
        {
            writer.WriteUInt64(value);
        }

        public UInt64 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt64();
        }
    }

    public sealed class NullableForceUInt64BlockFormatter : IMessagePackFormatter<UInt64?>
    {
        public static readonly NullableForceUInt64BlockFormatter Instance = new NullableForceUInt64BlockFormatter();

        private NullableForceUInt64BlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteUInt64(value.Value);
            }
        }

        public UInt64? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt64();
            }
        }
    }

    public sealed class ForceUInt64BlockArrayFormatter : IMessagePackFormatter<UInt64[]>
    {
        public static readonly ForceUInt64BlockArrayFormatter Instance = new ForceUInt64BlockArrayFormatter();

        private ForceUInt64BlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteUInt64(value[i]);
                }
            }
        }

        public UInt64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt64>();
            }

            var array = new UInt64[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadUInt64();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }

    public sealed class ForceByteBlockFormatter : IMessagePackFormatter<Byte>
    {
        public static readonly ForceByteBlockFormatter Instance = new ForceByteBlockFormatter();

        private ForceByteBlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Byte value, MessagePackSerializerOptions options)
        {
            writer.WriteUInt8(value);
        }

        public Byte Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadByte();
        }
    }

    public sealed class NullableForceByteBlockFormatter : IMessagePackFormatter<Byte?>
    {
        public static readonly NullableForceByteBlockFormatter Instance = new NullableForceByteBlockFormatter();

        private NullableForceByteBlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Byte? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteUInt8(value.Value);
            }
        }

        public Byte? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadByte();
            }
        }
    }

    public sealed class ForceSByteBlockFormatter : IMessagePackFormatter<SByte>
    {
        public static readonly ForceSByteBlockFormatter Instance = new ForceSByteBlockFormatter();

        private ForceSByteBlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte value, MessagePackSerializerOptions options)
        {
            writer.WriteInt8(value);
        }

        public SByte Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadSByte();
        }
    }

    public sealed class NullableForceSByteBlockFormatter : IMessagePackFormatter<SByte?>
    {
        public static readonly NullableForceSByteBlockFormatter Instance = new NullableForceSByteBlockFormatter();

        private NullableForceSByteBlockFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteInt8(value.Value);
            }
        }

        public SByte? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadSByte();
            }
        }
    }

    public sealed class ForceSByteBlockArrayFormatter : IMessagePackFormatter<SByte[]>
    {
        public static readonly ForceSByteBlockArrayFormatter Instance = new ForceSByteBlockArrayFormatter();

        private ForceSByteBlockArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.WriteInt8(value[i]);
                }
            }
        }

        public SByte[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<SByte>();
            }

            var array = new SByte[len];
            options.Security.DepthStep(ref reader);
            try
            {
                for (int i = 0; i < array.Length; i++)
                {
                    array[i] = reader.ReadSByte();
                }
            }
            finally
            {
                reader.Depth--;
            }

            return array;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/ForceSizePrimitiveFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 1ad9a757f1a235248aace5bb771bb786
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/MessagePackReader.Integers.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

namespace MessagePack
{
#pragma warning disable SA1205 // Partial elements should declare access
    ref partial struct MessagePackReader
#pragma warning restore SA1205 // Partial elements should declare access
    {
        /// <summary>
        /// Reads an <see cref="Byte"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public Byte ReadByte()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((Byte)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((Byte)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((Byte)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((Byte)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((Byte)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((Byte)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((Byte)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((Byte)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((Byte)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (Byte)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="UInt16"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public UInt16 ReadUInt16()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((UInt16)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((UInt16)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((UInt16)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((UInt16)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((UInt16)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((UInt16)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((UInt16)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((UInt16)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((UInt16)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (UInt16)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="UInt32"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public UInt32 ReadUInt32()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((UInt32)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((UInt32)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((UInt32)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((UInt32)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((UInt32)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((UInt32)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((UInt32)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((UInt32)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((UInt32)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (UInt32)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="UInt64"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public UInt64 ReadUInt64()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((UInt64)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((UInt64)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((UInt64)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((UInt64)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((UInt64)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((UInt64)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((UInt64)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((UInt64)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((UInt64)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (UInt64)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="SByte"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public SByte ReadSByte()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((SByte)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((SByte)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((SByte)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((SByte)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((SByte)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((SByte)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((SByte)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((SByte)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((SByte)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (SByte)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="Int16"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public Int16 ReadInt16()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((Int16)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((Int16)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((Int16)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((Int16)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((Int16)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((Int16)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((Int16)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((Int16)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((Int16)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (Int16)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="Int32"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public Int32 ReadInt32()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((Int32)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((Int32)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((Int32)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((Int32)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((Int32)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((Int32)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((Int32)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((Int32)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((Int32)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (Int32)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }

        /// <summary>
        /// Reads an <see cref="Int64"/> value from:
        /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
        /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
        /// or any of the other MsgPack integer types.
        /// </summary>
        /// <returns>The value.</returns>
        /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        public Int64 ReadInt64()
        {
            ThrowInsufficientBufferUnless(this.reader.TryRead(out byte code));

            switch (code)
            {
                case MessagePackCode.UInt8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out byte byteResult));
                    return checked((Int64)byteResult);
                case MessagePackCode.Int8:
                    ThrowInsufficientBufferUnless(this.reader.TryRead(out sbyte sbyteResult));
                    return checked((Int64)sbyteResult);
                case MessagePackCode.UInt16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ushort ushortResult));
                    return checked((Int64)ushortResult);
                case MessagePackCode.Int16:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out short shortResult));
                    return checked((Int64)shortResult);
                case MessagePackCode.UInt32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out uint uintResult));
                    return checked((Int64)uintResult);
                case MessagePackCode.Int32:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out int intResult));
                    return checked((Int64)intResult);
                case MessagePackCode.UInt64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out ulong ulongResult));
                    return checked((Int64)ulongResult);
                case MessagePackCode.Int64:
                    ThrowInsufficientBufferUnless(this.reader.TryReadBigEndian(out long longResult));
                    return checked((Int64)longResult);
                default:
                    if (code >= MessagePackCode.MinNegativeFixInt && code <= MessagePackCode.MaxNegativeFixInt)
                    {
                        return checked((Int64)unchecked((sbyte)code));
                    }

                    if (code >= MessagePackCode.MinFixInt && code <= MessagePackCode.MaxFixInt)
                    {
                        return (Int64)code;
                    }

                    throw ThrowInvalidCode(code);
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/MessagePackReader.Integers.cs.meta
================================================
fileFormatVersion: 2
guid: d034a54b76ed3944da5cd3666462e89e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/PrimitiveFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class Int16Formatter : IMessagePackFormatter<Int16>
    {
        public static readonly Int16Formatter Instance = new Int16Formatter();

        private Int16Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Int16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt16();
        }
    }

    public sealed class NullableInt16Formatter : IMessagePackFormatter<Int16?>
    {
        public static readonly NullableInt16Formatter Instance = new NullableInt16Formatter();

        private NullableInt16Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Int16? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt16();
            }
        }
    }

    public sealed class Int16ArrayFormatter : IMessagePackFormatter<Int16[]>
    {
        public static readonly Int16ArrayFormatter Instance = new Int16ArrayFormatter();

        private Int16ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int16[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Int16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int16>();
            }

            var array = new Int16[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadInt16();
            }

            return array;
        }
    }

    public sealed class Int32Formatter : IMessagePackFormatter<Int32>
    {
        public static readonly Int32Formatter Instance = new Int32Formatter();

        private Int32Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Int32 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt32();
        }
    }

    public sealed class NullableInt32Formatter : IMessagePackFormatter<Int32?>
    {
        public static readonly NullableInt32Formatter Instance = new NullableInt32Formatter();

        private NullableInt32Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Int32? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt32();
            }
        }
    }

    public sealed class Int32ArrayFormatter : IMessagePackFormatter<Int32[]>
    {
        public static readonly Int32ArrayFormatter Instance = new Int32ArrayFormatter();

        private Int32ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int32[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Int32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int32>();
            }

            var array = new Int32[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadInt32();
            }

            return array;
        }
    }

    public sealed class Int64Formatter : IMessagePackFormatter<Int64>
    {
        public static readonly Int64Formatter Instance = new Int64Formatter();

        private Int64Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Int64 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadInt64();
        }
    }

    public sealed class NullableInt64Formatter : IMessagePackFormatter<Int64?>
    {
        public static readonly NullableInt64Formatter Instance = new NullableInt64Formatter();

        private NullableInt64Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Int64? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadInt64();
            }
        }
    }

    public sealed class Int64ArrayFormatter : IMessagePackFormatter<Int64[]>
    {
        public static readonly Int64ArrayFormatter Instance = new Int64ArrayFormatter();

        private Int64ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Int64[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Int64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Int64>();
            }

            var array = new Int64[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadInt64();
            }

            return array;
        }
    }

    public sealed class UInt16Formatter : IMessagePackFormatter<UInt16>
    {
        public static readonly UInt16Formatter Instance = new UInt16Formatter();

        private UInt16Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public UInt16 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt16();
        }
    }

    public sealed class NullableUInt16Formatter : IMessagePackFormatter<UInt16?>
    {
        public static readonly NullableUInt16Formatter Instance = new NullableUInt16Formatter();

        private NullableUInt16Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public UInt16? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt16();
            }
        }
    }

    public sealed class UInt16ArrayFormatter : IMessagePackFormatter<UInt16[]>
    {
        public static readonly UInt16ArrayFormatter Instance = new UInt16ArrayFormatter();

        private UInt16ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt16[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public UInt16[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt16>();
            }

            var array = new UInt16[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadUInt16();
            }

            return array;
        }
    }

    public sealed class UInt32Formatter : IMessagePackFormatter<UInt32>
    {
        public static readonly UInt32Formatter Instance = new UInt32Formatter();

        private UInt32Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public UInt32 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt32();
        }
    }

    public sealed class NullableUInt32Formatter : IMessagePackFormatter<UInt32?>
    {
        public static readonly NullableUInt32Formatter Instance = new NullableUInt32Formatter();

        private NullableUInt32Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public UInt32? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt32();
            }
        }
    }

    public sealed class UInt32ArrayFormatter : IMessagePackFormatter<UInt32[]>
    {
        public static readonly UInt32ArrayFormatter Instance = new UInt32ArrayFormatter();

        private UInt32ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt32[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public UInt32[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt32>();
            }

            var array = new UInt32[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadUInt32();
            }

            return array;
        }
    }

    public sealed class UInt64Formatter : IMessagePackFormatter<UInt64>
    {
        public static readonly UInt64Formatter Instance = new UInt64Formatter();

        private UInt64Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64 value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public UInt64 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadUInt64();
        }
    }

    public sealed class NullableUInt64Formatter : IMessagePackFormatter<UInt64?>
    {
        public static readonly NullableUInt64Formatter Instance = new NullableUInt64Formatter();

        private NullableUInt64Formatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public UInt64? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadUInt64();
            }
        }
    }

    public sealed class UInt64ArrayFormatter : IMessagePackFormatter<UInt64[]>
    {
        public static readonly UInt64ArrayFormatter Instance = new UInt64ArrayFormatter();

        private UInt64ArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, UInt64[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public UInt64[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<UInt64>();
            }

            var array = new UInt64[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadUInt64();
            }

            return array;
        }
    }

    public sealed class SingleFormatter : IMessagePackFormatter<Single>
    {
        public static readonly SingleFormatter Instance = new SingleFormatter();

        private SingleFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Single value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Single Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadSingle();
        }
    }

    public sealed class NullableSingleFormatter : IMessagePackFormatter<Single?>
    {
        public static readonly NullableSingleFormatter Instance = new NullableSingleFormatter();

        private NullableSingleFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Single? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Single? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadSingle();
            }
        }
    }

    public sealed class SingleArrayFormatter : IMessagePackFormatter<Single[]>
    {
        public static readonly SingleArrayFormatter Instance = new SingleArrayFormatter();

        private SingleArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Single[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Single[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Single>();
            }

            var array = new Single[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadSingle();
            }

            return array;
        }
    }

    public sealed class DoubleFormatter : IMessagePackFormatter<Double>
    {
        public static readonly DoubleFormatter Instance = new DoubleFormatter();

        private DoubleFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Double value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Double Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadDouble();
        }
    }

    public sealed class NullableDoubleFormatter : IMessagePackFormatter<Double?>
    {
        public static readonly NullableDoubleFormatter Instance = new NullableDoubleFormatter();

        private NullableDoubleFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Double? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Double? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadDouble();
            }
        }
    }

    public sealed class DoubleArrayFormatter : IMessagePackFormatter<Double[]>
    {
        public static readonly DoubleArrayFormatter Instance = new DoubleArrayFormatter();

        private DoubleArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Double[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Double[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Double>();
            }

            var array = new Double[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadDouble();
            }

            return array;
        }
    }

    public sealed class BooleanFormatter : IMessagePackFormatter<Boolean>
    {
        public static readonly BooleanFormatter Instance = new BooleanFormatter();

        private BooleanFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Boolean value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Boolean Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadBoolean();
        }
    }

    public sealed class NullableBooleanFormatter : IMessagePackFormatter<Boolean?>
    {
        public static readonly NullableBooleanFormatter Instance = new NullableBooleanFormatter();

        private NullableBooleanFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Boolean? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Boolean? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadBoolean();
            }
        }
    }

    public sealed class BooleanArrayFormatter : IMessagePackFormatter<Boolean[]>
    {
        public static readonly BooleanArrayFormatter Instance = new BooleanArrayFormatter();

        private BooleanArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Boolean[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Boolean[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Boolean>();
            }

            var array = new Boolean[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadBoolean();
            }

            return array;
        }
    }

    public sealed class ByteFormatter : IMessagePackFormatter<Byte>
    {
        public static readonly ByteFormatter Instance = new ByteFormatter();

        private ByteFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Byte value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Byte Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadByte();
        }
    }

    public sealed class NullableByteFormatter : IMessagePackFormatter<Byte?>
    {
        public static readonly NullableByteFormatter Instance = new NullableByteFormatter();

        private NullableByteFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Byte? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Byte? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadByte();
            }
        }
    }

    public sealed class SByteFormatter : IMessagePackFormatter<SByte>
    {
        public static readonly SByteFormatter Instance = new SByteFormatter();

        private SByteFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public SByte Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadSByte();
        }
    }

    public sealed class NullableSByteFormatter : IMessagePackFormatter<SByte?>
    {
        public static readonly NullableSByteFormatter Instance = new NullableSByteFormatter();

        private NullableSByteFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public SByte? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadSByte();
            }
        }
    }

    public sealed class SByteArrayFormatter : IMessagePackFormatter<SByte[]>
    {
        public static readonly SByteArrayFormatter Instance = new SByteArrayFormatter();

        private SByteArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, SByte[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public SByte[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<SByte>();
            }

            var array = new SByte[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadSByte();
            }

            return array;
        }
    }

    public sealed class CharFormatter : IMessagePackFormatter<Char>
    {
        public static readonly CharFormatter Instance = new CharFormatter();

        private CharFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Char value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public Char Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadChar();
        }
    }

    public sealed class NullableCharFormatter : IMessagePackFormatter<Char?>
    {
        public static readonly NullableCharFormatter Instance = new NullableCharFormatter();

        private NullableCharFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Char? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public Char? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadChar();
            }
        }
    }

    public sealed class CharArrayFormatter : IMessagePackFormatter<Char[]>
    {
        public static readonly CharArrayFormatter Instance = new CharArrayFormatter();

        private CharArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, Char[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public Char[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<Char>();
            }

            var array = new Char[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadChar();
            }

            return array;
        }
    }

    public sealed class DateTimeFormatter : IMessagePackFormatter<DateTime>
    {
        public static readonly DateTimeFormatter Instance = new DateTimeFormatter();

        private DateTimeFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, DateTime value, MessagePackSerializerOptions options)
        {
            writer.Write(value);
        }

        public DateTime Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            return reader.ReadDateTime();
        }
    }

    public sealed class NullableDateTimeFormatter : IMessagePackFormatter<DateTime?>
    {
        public static readonly NullableDateTimeFormatter Instance = new NullableDateTimeFormatter();

        private NullableDateTimeFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, DateTime? value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.Write(value.Value);
            }
        }

        public DateTime? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                return reader.ReadDateTime();
            }
        }
    }

    public sealed class DateTimeArrayFormatter : IMessagePackFormatter<DateTime[]>
    {
        public static readonly DateTimeArrayFormatter Instance = new DateTimeArrayFormatter();

        private DateTimeArrayFormatter()
        {
        }

        public void Serialize(ref MessagePackWriter writer, DateTime[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(value.Length);
                for (int i = 0; i < value.Length; i++)
                {
                    writer.Write(value[i]);
                }
            }
        }

        public DateTime[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }

            var len = reader.ReadArrayHeader();
            if (len == 0)
            {
                return Array.Empty<DateTime>();
            }

            var array = new DateTime[len];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = reader.ReadDateTime();
            }

            return array;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/PrimitiveFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: eb48ea027ca8fa84c8677fac8791b318
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/TupleFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class TupleFormatter<T1> : IMessagePackFormatter<Tuple<T1>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(1);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            }
        }

        public Tuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 1)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);

                    return new Tuple<T1>(item1);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2> : IMessagePackFormatter<Tuple<T1, T2>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(2);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            }
        }

        public Tuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 2)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2>(item1, item2);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3> : IMessagePackFormatter<Tuple<T1, T2, T3>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(3);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            }
        }

        public Tuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 3)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3>(item1, item2, item3);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3, T4> : IMessagePackFormatter<Tuple<T1, T2, T3, T4>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3, T4> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(4);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
                resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            }
        }

        public Tuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 4)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3, T4, T5> : IMessagePackFormatter<Tuple<T1, T2, T3, T4, T5>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(5);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
                resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
                resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            }
        }

        public Tuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 5)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6> : IMessagePackFormatter<Tuple<T1, T2, T3, T4, T5, T6>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(6);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
                resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
                resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
                resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            }
        }

        public Tuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 6)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6, T7> : IMessagePackFormatter<Tuple<T1, T2, T3, T4, T5, T6, T7>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(7);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
                resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
                resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
                resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
                resolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            }
        }

        public Tuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 7)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6, T7, TRest> : IMessagePackFormatter<Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>>
    {
        public void Serialize(ref MessagePackWriter writer, Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
            }
            else
            {
                writer.WriteArrayHeader(8);

                IFormatterResolver resolver = options.Resolver;
                resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
                resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
                resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
                resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
                resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
                resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
                resolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
                resolver.GetFormatterWithVerify<TRest>().Serialize(ref writer, value.Rest, options);
            }
        }

        public Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return default;
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 8)
                {
                    throw new MessagePackSerializationException("Invalid Tuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);

                    return new Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/TupleFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 6b14afc37320aee4daaa80c6b1e6529f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/UnsafeMemory.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

#if !UNITY_2018_3_OR_NEWER

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using MessagePack.Formatters;

namespace MessagePack.Internal
{
    public static partial class UnsafeMemory32
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw4(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw5(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 1) = *(int*)(pSrc + 1);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw6(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 2) = *(int*)(pSrc + 2);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw7(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 3) = *(int*)(pSrc + 3);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw8(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw9(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 5) = *(int*)(pSrc + 5);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw10(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 6) = *(int*)(pSrc + 6);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw11(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 7) = *(int*)(pSrc + 7);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw12(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw13(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 9) = *(int*)(pSrc + 9);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw14(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 10) = *(int*)(pSrc + 10);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw15(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 11) = *(int*)(pSrc + 11);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw16(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw17(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 13) = *(int*)(pSrc + 13);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw18(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 14) = *(int*)(pSrc + 14);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw19(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 15) = *(int*)(pSrc + 15);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw20(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw21(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 17) = *(int*)(pSrc + 17);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw22(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 18) = *(int*)(pSrc + 18);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw23(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 19) = *(int*)(pSrc + 19);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw24(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw25(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 21) = *(int*)(pSrc + 21);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw26(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 22) = *(int*)(pSrc + 22);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw27(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 23) = *(int*)(pSrc + 23);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw28(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 24) = *(int*)(pSrc + 24);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw29(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 24) = *(int*)(pSrc + 24);
                *(int*)(pDst + 25) = *(int*)(pSrc + 25);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw30(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 24) = *(int*)(pSrc + 24);
                *(int*)(pDst + 26) = *(int*)(pSrc + 26);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw31(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(int*)(pDst + 0) = *(int*)(pSrc + 0);
                *(int*)(pDst + 4) = *(int*)(pSrc + 4);
                *(int*)(pDst + 8) = *(int*)(pSrc + 8);
                *(int*)(pDst + 12) = *(int*)(pSrc + 12);
                *(int*)(pDst + 16) = *(int*)(pSrc + 16);
                *(int*)(pDst + 20) = *(int*)(pSrc + 20);
                *(int*)(pDst + 24) = *(int*)(pSrc + 24);
                *(int*)(pDst + 27) = *(int*)(pSrc + 27);
            }

            writer.Advance(src.Length);
        }
    }

    public static partial class UnsafeMemory64
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw8(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw9(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 1) = *(long*)(pSrc + 1);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw10(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 2) = *(long*)(pSrc + 2);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw11(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 3) = *(long*)(pSrc + 3);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw12(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 4) = *(long*)(pSrc + 4);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw13(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 5) = *(long*)(pSrc + 5);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw14(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 6) = *(long*)(pSrc + 6);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw15(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 7) = *(long*)(pSrc + 7);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw16(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw17(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 9) = *(long*)(pSrc + 9);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw18(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 10) = *(long*)(pSrc + 10);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw19(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 11) = *(long*)(pSrc + 11);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw20(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 12) = *(long*)(pSrc + 12);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw21(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 13) = *(long*)(pSrc + 13);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw22(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 14) = *(long*)(pSrc + 14);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw23(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 15) = *(long*)(pSrc + 15);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw24(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw25(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 17) = *(long*)(pSrc + 17);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw26(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 18) = *(long*)(pSrc + 18);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw27(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 19) = *(long*)(pSrc + 19);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw28(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 20) = *(long*)(pSrc + 20);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw29(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 21) = *(long*)(pSrc + 21);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw30(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 22) = *(long*)(pSrc + 22);
            }

            writer.Advance(src.Length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void WriteRaw31(ref MessagePackWriter writer, ReadOnlySpan<byte> src)
        {
            Span<byte> dst = writer.GetSpan(src.Length);

            fixed (byte* pSrc = &src[0])
            fixed (byte* pDst = &dst[0])
            {
                *(long*)(pDst + 0) = *(long*)(pSrc + 0);
                *(long*)(pDst + 8) = *(long*)(pSrc + 8);
                *(long*)(pDst + 16) = *(long*)(pSrc + 16);
                *(long*)(pDst + 23) = *(long*)(pSrc + 23);
            }

            writer.Advance(src.Length);
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/UnsafeMemory.cs.meta
================================================
fileFormatVersion: 2
guid: 50b6bcd206242f944833ba2d0548b028
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/ValueTupleFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class ValueTupleFormatter<T1> : IMessagePackFormatter<ValueTuple<T1>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
        }

        public ValueTuple<T1> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 1)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);

                    return new ValueTuple<T1>(item1);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2> : IMessagePackFormatter<ValueTuple<T1, T2>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
        }

        public ValueTuple<T1, T2> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 2)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2>(item1, item2);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3> : IMessagePackFormatter<ValueTuple<T1, T2, T3>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(3);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
        }

        public ValueTuple<T1, T2, T3> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 3)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3>(item1, item2, item3);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3, T4> : IMessagePackFormatter<ValueTuple<T1, T2, T3, T4>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3, T4> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
        }

        public ValueTuple<T1, T2, T3, T4> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 4)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5> : IMessagePackFormatter<ValueTuple<T1, T2, T3, T4, T5>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3, T4, T5> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(5);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
        }

        public ValueTuple<T1, T2, T3, T4, T5> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 5)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6> : IMessagePackFormatter<ValueTuple<T1, T2, T3, T4, T5, T6>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3, T4, T5, T6> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(6);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
        }

        public ValueTuple<T1, T2, T3, T4, T5, T6> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 6)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6, T7> : IMessagePackFormatter<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3, T4, T5, T6, T7> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(7);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            resolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
        }

        public ValueTuple<T1, T2, T3, T4, T5, T6, T7> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 7)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }

    public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6, T7, TRest> : IMessagePackFormatter<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>
        where TRest : struct
    {
        public void Serialize(ref MessagePackWriter writer, ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> value, MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(8);

            IFormatterResolver resolver = options.Resolver;
            resolver.GetFormatterWithVerify<T1>().Serialize(ref writer, value.Item1, options);
            resolver.GetFormatterWithVerify<T2>().Serialize(ref writer, value.Item2, options);
            resolver.GetFormatterWithVerify<T3>().Serialize(ref writer, value.Item3, options);
            resolver.GetFormatterWithVerify<T4>().Serialize(ref writer, value.Item4, options);
            resolver.GetFormatterWithVerify<T5>().Serialize(ref writer, value.Item5, options);
            resolver.GetFormatterWithVerify<T6>().Serialize(ref writer, value.Item6, options);
            resolver.GetFormatterWithVerify<T7>().Serialize(ref writer, value.Item7, options);
            resolver.GetFormatterWithVerify<TRest>().Serialize(ref writer, value.Rest, options);
        }

        public ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new MessagePackSerializationException("Data is Nil, ValueTuple can not be null.");
            }
            else
            {
                var count = reader.ReadArrayHeader();
                if (count != 8)
                {
                    throw new MessagePackSerializationException("Invalid ValueTuple count");
                }

                IFormatterResolver resolver = options.Resolver;
                options.Security.DepthStep(ref reader);
                try
                {
                    T1 item1 = resolver.GetFormatterWithVerify<T1>().Deserialize(ref reader, options);
                    T2 item2 = resolver.GetFormatterWithVerify<T2>().Deserialize(ref reader, options);
                    T3 item3 = resolver.GetFormatterWithVerify<T3>().Deserialize(ref reader, options);
                    T4 item4 = resolver.GetFormatterWithVerify<T4>().Deserialize(ref reader, options);
                    T5 item5 = resolver.GetFormatterWithVerify<T5>().Deserialize(ref reader, options);
                    T6 item6 = resolver.GetFormatterWithVerify<T6>().Deserialize(ref reader, options);
                    T7 item7 = resolver.GetFormatterWithVerify<T7>().Deserialize(ref reader, options);
                    TRest item8 = resolver.GetFormatterWithVerify<TRest>().Deserialize(ref reader, options);

                    return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>(item1, item2, item3, item4, item5, item6, item7, item8);
                }
                finally
                {
                    reader.Depth--;
                }
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/T4/ValueTupleFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 98e54c0165ce30446938aa828e753eb5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Extension.meta
================================================
fileFormatVersion: 2
guid: 6b8e54cb99976434688f7ea5f76c0026
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Formatters.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using MessagePack;
using MessagePack.Formatters;

#pragma warning disable SA1312 // variable naming
#pragma warning disable SA1402 // one type per file
#pragma warning disable SA1649 // file name matches type name

namespace MessagePack.Unity
{
    public sealed class Vector2Formatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Vector2>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Vector2 value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.x);
            writer.Write(value.y);
        }

        public global::UnityEngine.Vector2 Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var x = default(float);
            var y = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        x = reader.ReadSingle();
                        break;
                    case 1:
                        y = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Vector2(x, y);
            return result;
        }
    }

    public sealed class Vector3Formatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Vector3>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Vector3 value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(3);
            writer.Write(value.x);
            writer.Write(value.y);
            writer.Write(value.z);
        }

        public global::UnityEngine.Vector3 Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var x = default(float);
            var y = default(float);
            var z = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        x = reader.ReadSingle();
                        break;
                    case 1:
                        y = reader.ReadSingle();
                        break;
                    case 2:
                        z = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Vector3(x, y, z);
            return result;
        }
    }

    public sealed class Vector4Formatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Vector4>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Vector4 value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.x);
            writer.Write(value.y);
            writer.Write(value.z);
            writer.Write(value.w);
        }

        public global::UnityEngine.Vector4 Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var x = default(float);
            var y = default(float);
            var z = default(float);
            var w = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        x = reader.ReadSingle();
                        break;
                    case 1:
                        y = reader.ReadSingle();
                        break;
                    case 2:
                        z = reader.ReadSingle();
                        break;
                    case 3:
                        w = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Vector4(x, y, z, w);
            return result;
        }
    }

    public sealed class QuaternionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Quaternion>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Quaternion value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.x);
            writer.Write(value.y);
            writer.Write(value.z);
            writer.Write(value.w);
        }

        public global::UnityEngine.Quaternion Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var x = default(float);
            var y = default(float);
            var z = default(float);
            var w = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        x = reader.ReadSingle();
                        break;
                    case 1:
                        y = reader.ReadSingle();
                        break;
                    case 2:
                        z = reader.ReadSingle();
                        break;
                    case 3:
                        w = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Quaternion(x, y, z, w);
            return result;
        }
    }

    public sealed class ColorFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Color>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Color value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.r);
            writer.Write(value.g);
            writer.Write(value.b);
            writer.Write(value.a);
        }

        public global::UnityEngine.Color Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var r = default(float);
            var g = default(float);
            var b = default(float);
            var a = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        r = reader.ReadSingle();
                        break;
                    case 1:
                        g = reader.ReadSingle();
                        break;
                    case 2:
                        b = reader.ReadSingle();
                        break;
                    case 3:
                        a = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Color(r, g, b, a);
            return result;
        }
    }

    public sealed class BoundsFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Bounds>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Bounds value, global::MessagePack.MessagePackSerializerOptions options)
        {
            IFormatterResolver resolver = options.Resolver;
            writer.WriteArrayHeader(2);
            resolver.GetFormatterWithVerify<global::UnityEngine.Vector3>().Serialize(ref writer, value.center, options);
            resolver.GetFormatterWithVerify<global::UnityEngine.Vector3>().Serialize(ref writer, value.size, options);
        }

        public global::UnityEngine.Bounds Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            IFormatterResolver resolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var center = default(global::UnityEngine.Vector3);
            var size = default(global::UnityEngine.Vector3);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        center = resolver.GetFormatterWithVerify<global::UnityEngine.Vector3>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        size = resolver.GetFormatterWithVerify<global::UnityEngine.Vector3>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Bounds(center, size);
            return result;
        }
    }

    public sealed class RectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Rect>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Rect value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.x);
            writer.Write(value.y);
            writer.Write(value.width);
            writer.Write(value.height);
        }

        public global::UnityEngine.Rect Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var x = default(float);
            var y = default(float);
            var width = default(float);
            var height = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        x = reader.ReadSingle();
                        break;
                    case 1:
                        y = reader.ReadSingle();
                        break;
                    case 2:
                        width = reader.ReadSingle();
                        break;
                    case 3:
                        height = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var result = new global::UnityEngine.Rect(x, y, width, height);
            return result;
        }
    }

    // additional
    public sealed class WrapModeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.WrapMode>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.WrapMode value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((int)value);
        }

        public global::UnityEngine.WrapMode Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::UnityEngine.WrapMode)reader.ReadInt32();
        }
    }

    public sealed class GradientModeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.GradientMode>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.GradientMode value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((int)value);
        }

        public global::UnityEngine.GradientMode Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::UnityEngine.GradientMode)reader.ReadInt32();
        }
    }

    public sealed class KeyframeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Keyframe>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Keyframe value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.time);
            writer.Write(value.value);
            writer.Write(value.inTangent);
            writer.Write(value.outTangent);
        }

        public global::UnityEngine.Keyframe Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __time__ = default(float);
            var __value__ = default(float);
            var __inTangent__ = default(float);
            var __outTangent__ = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __time__ = reader.ReadSingle();
                        break;
                    case 1:
                        __value__ = reader.ReadSingle();
                        break;
                    case 2:
                        __inTangent__ = reader.ReadSingle();
                        break;
                    case 3:
                        __outTangent__ = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.Keyframe(__time__, __value__, __inTangent__, __outTangent__);
            ____result.time = __time__;
            ____result.value = __value__;
            ____result.inTangent = __inTangent__;
            ____result.outTangent = __outTangent__;
            return ____result;
        }
    }

    public sealed class AnimationCurveFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.AnimationCurve>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.AnimationCurve value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver resolver = options.Resolver;
            writer.WriteArrayHeader(3);
            resolver.GetFormatterWithVerify<global::UnityEngine.Keyframe[]>().Serialize(ref writer, value.keys, options);
            resolver.GetFormatterWithVerify<global::UnityEngine.WrapMode>().Serialize(ref writer, value.postWrapMode, options);
            resolver.GetFormatterWithVerify<global::UnityEngine.WrapMode>().Serialize(ref writer, value.preWrapMode, options);
        }

        public global::UnityEngine.AnimationCurve Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                return null;
            }

            IFormatterResolver resolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __keys__ = default(global::UnityEngine.Keyframe[]);
            var __postWrapMode__ = default(global::UnityEngine.WrapMode);
            var __preWrapMode__ = default(global::UnityEngine.WrapMode);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __keys__ = resolver.GetFormatterWithVerify<global::UnityEngine.Keyframe[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __postWrapMode__ = resolver.GetFormatterWithVerify<global::UnityEngine.WrapMode>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __preWrapMode__ = resolver.GetFormatterWithVerify<global::UnityEngine.WrapMode>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.AnimationCurve();
            ____result.keys = __keys__;
            ____result.postWrapMode = __postWrapMode__;
            ____result.preWrapMode = __preWrapMode__;
            return ____result;
        }
    }

    public sealed class Matrix4x4Formatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Matrix4x4>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Matrix4x4 value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(16);
            writer.Write(value.m00);
            writer.Write(value.m10);
            writer.Write(value.m20);
            writer.Write(value.m30);
            writer.Write(value.m01);
            writer.Write(value.m11);
            writer.Write(value.m21);
            writer.Write(value.m31);
            writer.Write(value.m02);
            writer.Write(value.m12);
            writer.Write(value.m22);
            writer.Write(value.m32);
            writer.Write(value.m03);
            writer.Write(value.m13);
            writer.Write(value.m23);
            writer.Write(value.m33);
        }

        public global::UnityEngine.Matrix4x4 Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __m00__ = default(float);
            var __m10__ = default(float);
            var __m20__ = default(float);
            var __m30__ = default(float);
            var __m01__ = default(float);
            var __m11__ = default(float);
            var __m21__ = default(float);
            var __m31__ = default(float);
            var __m02__ = default(float);
            var __m12__ = default(float);
            var __m22__ = default(float);
            var __m32__ = default(float);
            var __m03__ = default(float);
            var __m13__ = default(float);
            var __m23__ = default(float);
            var __m33__ = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __m00__ = reader.ReadSingle();
                        break;
                    case 1:
                        __m10__ = reader.ReadSingle();
                        break;
                    case 2:
                        __m20__ = reader.ReadSingle();
                        break;
                    case 3:
                        __m30__ = reader.ReadSingle();
                        break;
                    case 4:
                        __m01__ = reader.ReadSingle();
                        break;
                    case 5:
                        __m11__ = reader.ReadSingle();
                        break;
                    case 6:
                        __m21__ = reader.ReadSingle();
                        break;
                    case 7:
                        __m31__ = reader.ReadSingle();
                        break;
                    case 8:
                        __m02__ = reader.ReadSingle();
                        break;
                    case 9:
                        __m12__ = reader.ReadSingle();
                        break;
                    case 10:
                        __m22__ = reader.ReadSingle();
                        break;
                    case 11:
                        __m32__ = reader.ReadSingle();
                        break;
                    case 12:
                        __m03__ = reader.ReadSingle();
                        break;
                    case 13:
                        __m13__ = reader.ReadSingle();
                        break;
                    case 14:
                        __m23__ = reader.ReadSingle();
                        break;
                    case 15:
                        __m33__ = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = default(global::UnityEngine.Matrix4x4);
            ____result.m00 = __m00__;
            ____result.m10 = __m10__;
            ____result.m20 = __m20__;
            ____result.m30 = __m30__;
            ____result.m01 = __m01__;
            ____result.m11 = __m11__;
            ____result.m21 = __m21__;
            ____result.m31 = __m31__;
            ____result.m02 = __m02__;
            ____result.m12 = __m12__;
            ____result.m22 = __m22__;
            ____result.m32 = __m32__;
            ____result.m03 = __m03__;
            ____result.m13 = __m13__;
            ____result.m23 = __m23__;
            ____result.m33 = __m33__;
            return ____result;
        }
    }

    public sealed class GradientColorKeyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.GradientColorKey>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.GradientColorKey value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            options.Resolver.GetFormatterWithVerify<global::UnityEngine.Color>().Serialize(ref writer, value.color, options);
            writer.Write(value.time);
        }

        public global::UnityEngine.GradientColorKey Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __color__ = default(global::UnityEngine.Color);
            var __time__ = default(float);
            IFormatterResolver resolver = options.Resolver;
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __color__ = resolver.GetFormatterWithVerify<global::UnityEngine.Color>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __time__ = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.GradientColorKey(__color__, __time__);
            ____result.color = __color__;
            ____result.time = __time__;
            return ____result;
        }
    }

    public sealed class GradientAlphaKeyFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.GradientAlphaKey>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.GradientAlphaKey value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.Write(value.alpha);
            writer.Write(value.time);
        }

        public global::UnityEngine.GradientAlphaKey Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __alpha__ = default(float);
            var __time__ = default(float);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __alpha__ = reader.ReadSingle();
                        break;
                    case 1:
                        __time__ = reader.ReadSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.GradientAlphaKey(__alpha__, __time__);
            ____result.alpha = __alpha__;
            ____result.time = __time__;
            return ____result;
        }
    }

    public sealed class GradientFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Gradient>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Gradient value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver resolver = options.Resolver;
            writer.WriteArrayHeader(3);
            resolver.GetFormatterWithVerify<global::UnityEngine.GradientColorKey[]>().Serialize(ref writer, value.colorKeys, options);
            resolver.GetFormatterWithVerify<global::UnityEngine.GradientAlphaKey[]>().Serialize(ref writer, value.alphaKeys, options);
            resolver.GetFormatterWithVerify<global::UnityEngine.GradientMode>().Serialize(ref writer, value.mode, options);
        }

        public global::UnityEngine.Gradient Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                return null;
            }

            IFormatterResolver resolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __colorKeys__ = default(global::UnityEngine.GradientColorKey[]);
            var __alphaKeys__ = default(global::UnityEngine.GradientAlphaKey[]);
            var __mode__ = default(global::UnityEngine.GradientMode);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __colorKeys__ = resolver.GetFormatterWithVerify<global::UnityEngine.GradientColorKey[]>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __alphaKeys__ = resolver.GetFormatterWithVerify<global::UnityEngine.GradientAlphaKey[]>().Deserialize(ref reader, options);
                        break;
                    case 2:
                        __mode__ = resolver.GetFormatterWithVerify<global::UnityEngine.GradientMode>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.Gradient();
            ____result.colorKeys = __colorKeys__;
            ____result.alphaKeys = __alphaKeys__;
            ____result.mode = __mode__;
            return ____result;
        }
    }

    public sealed class Color32Formatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Color32>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Color32 value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.Write(value.r);
            writer.Write(value.g);
            writer.Write(value.b);
            writer.Write(value.a);
        }

        public global::UnityEngine.Color32 Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __r__ = default(byte);
            var __g__ = default(byte);
            var __b__ = default(byte);
            var __a__ = default(byte);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __r__ = reader.ReadByte();
                        break;
                    case 1:
                        __g__ = reader.ReadByte();
                        break;
                    case 2:
                        __b__ = reader.ReadByte();
                        break;
                    case 3:
                        __a__ = reader.ReadByte();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.Color32(__r__, __g__, __b__, __a__);
            ____result.r = __r__;
            ____result.g = __g__;
            ____result.b = __b__;
            ____result.a = __a__;
            return ____result;
        }
    }

    public sealed class RectOffsetFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.RectOffset>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.RectOffset value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(4);
            writer.Write(value.left);
            writer.Write(value.right);
            writer.Write(value.top);
            writer.Write(value.bottom);
        }

        public global::UnityEngine.RectOffset Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                return null;
            }

            var length = reader.ReadArrayHeader();
            var __left__ = default(int);
            var __right__ = default(int);
            var __top__ = default(int);
            var __bottom__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __left__ = reader.ReadInt32();
                        break;
                    case 1:
                        __right__ = reader.ReadInt32();
                        break;
                    case 2:
                        __top__ = reader.ReadInt32();
                        break;
                    case 3:
                        __bottom__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.RectOffset();
            ____result.left = __left__;
            ____result.right = __right__;
            ____result.top = __top__;
            ____result.bottom = __bottom__;
            return ____result;
        }
    }

    public sealed class LayerMaskFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.LayerMask>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.LayerMask value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(1);
            writer.Write(value.value);
        }

        public global::UnityEngine.LayerMask Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }

            var length = reader.ReadArrayHeader();
            var __value__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __value__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = default(global::UnityEngine.LayerMask);
            ____result.value = __value__;
            return ____result;
        }
    }
#if UNITY_2017_2_OR_NEWER
    public sealed class Vector2IntFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Vector2Int>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Vector2Int value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.WriteInt32(value.x);
            writer.WriteInt32(value.y);
        }
        public global::UnityEngine.Vector2Int Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }
            var length = reader.ReadArrayHeader();
            var __x__ = default(int);
            var __y__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __x__ = reader.ReadInt32();
                        break;
                    case 1:
                        __y__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.Vector2Int(__x__, __y__);
            ____result.x = __x__;
            ____result.y = __y__;
            return ____result;
        }
    }

    public sealed class Vector3IntFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.Vector3Int>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.Vector3Int value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(3);
            writer.WriteInt32(value.x);
            writer.WriteInt32(value.y);
            writer.WriteInt32(value.z);
        }
        public global::UnityEngine.Vector3Int Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }
            var length = reader.ReadArrayHeader();
            var __x__ = default(int);
            var __y__ = default(int);
            var __z__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __x__ = reader.ReadInt32();
                        break;
                    case 1:
                        __y__ = reader.ReadInt32();
                        break;
                    case 2:
                        __z__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.Vector3Int(__x__, __y__, __z__);
            ____result.x = __x__;
            ____result.y = __y__;
            ____result.z = __z__;
            return ____result;
        }
    }

    public sealed class RangeIntFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.RangeInt>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.RangeInt value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            writer.WriteInt32(value.start);
            writer.WriteInt32(value.length);
        }
        public global::UnityEngine.RangeInt Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }
            var length = reader.ReadArrayHeader();
            var __start__ = default(int);
            var __length__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __start__ = reader.ReadInt32();
                        break;
                    case 1:
                        __length__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.RangeInt(__start__, __length__);
            ____result.start = __start__;
            ____result.length = __length__;
            return ____result;
        }
    }

    public sealed class RectIntFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.RectInt>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.RectInt value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(4);
            writer.WriteInt32(value.x);
            writer.WriteInt32(value.y);
            writer.WriteInt32(value.width);
            writer.WriteInt32(value.height);
        }
        public global::UnityEngine.RectInt Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }
            var length = reader.ReadArrayHeader();
            var __x__ = default(int);
            var __y__ = default(int);
            var __width__ = default(int);
            var __height__ = default(int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __x__ = reader.ReadInt32();
                        break;
                    case 1:
                        __y__ = reader.ReadInt32();
                        break;
                    case 2:
                        __width__ = reader.ReadInt32();
                        break;
                    case 3:
                        __height__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.RectInt(__x__, __y__, __width__, __height__);
            ____result.x = __x__;
            ____result.y = __y__;
            ____result.width = __width__;
            ____result.height = __height__;
            return ____result;
        }
    }

    public sealed class BoundsIntFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::UnityEngine.BoundsInt>
    {
        public void Serialize(ref MessagePackWriter writer, global::UnityEngine.BoundsInt value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.WriteArrayHeader(2);
            options.Resolver.GetFormatterWithVerify<global::UnityEngine.Vector3Int>().Serialize(ref writer, value.position, options);
            options.Resolver.GetFormatterWithVerify<global::UnityEngine.Vector3Int>().Serialize(ref writer, value.size, options);
        }
        public global::UnityEngine.BoundsInt Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.IsNil)
            {
                throw new InvalidOperationException("typecode is null, struct not supported");
            }
            var length = reader.ReadArrayHeader();
            var __position__ = default(global::UnityEngine.Vector3Int);
            var __size__ = default(global::UnityEngine.Vector3Int);
            for (int i = 0; i < length; i++)
            {
                var key = i;
                switch (key)
                {
                    case 0:
                        __position__ = options.Resolver.GetFormatterWithVerify<global::UnityEngine.Vector3Int>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __size__ = options.Resolver.GetFormatterWithVerify<global::UnityEngine.Vector3Int>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::UnityEngine.BoundsInt(__position__, __size__);
            ____result.position = __position__;
            ____result.size = __size__;
            return ____result;
        }
    }
#endif
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Formatters.cs.meta
================================================
fileFormatVersion: 2
guid: 43031b10b3132bf438ca856926d4a8f8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/MessagePackWindow.cs
================================================
﻿#if UNITY_EDITOR

using System;
using System.Diagnostics;
using System.Text;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;

namespace MessagePack.Unity.Editor
{
    internal class MessagePackWindow : EditorWindow
    {
        static MessagePackWindow window;

        bool processInitialized;

        bool isDotnetInstalled;
        string dotnetVersion;

        bool isInstalledMpc;
        bool installingMpc;
        bool invokingMpc;

        MpcArgument mpcArgument;

        [MenuItem("Window/MessagePack/CodeGenerator")]
        public static void OpenWindow()
        {
            if (window != null)
            {
                window.Close();
            }

            // will called OnEnable(singleton instance will be set).
            GetWindow<MessagePackWindow>("MessagePack CodeGen").Show();
        }

        async void OnEnable()
        {
            window = this; // set singleton.
            try
            {
                var dotnet = await ProcessHelper.FindDotnetAsync();
                isDotnetInstalled = dotnet.found;
                dotnetVersion = dotnet.version;

                if (isDotnetInstalled)
                {
                    isInstalledMpc = await ProcessHelper.IsInstalledMpc();
                }
            }
            finally
            {
                mpcArgument = MpcArgument.Restore();
                processInitialized = true;
            }
        }

        async void OnGUI()
        {
            if (!processInitialized)
            {
                GUILayout.Label("Check .NET Core SDK/CodeGen install status.");
                return;
            }
            if (mpcArgument == null)
            {
                return;
            }

            if (!isDotnetInstalled)
            {
                GUILayout.Label(".NET Core SDK not found.");
                GUILayout.Label("MessagePack CodeGen requires .NET Core Runtime.");
                if (GUILayout.Button("Open .NET Core install page."))
                {
                    Application.OpenURL("https://dotnet.microsoft.com/download");
                }
                return;
            }

            if (!isInstalledMpc)
            {
                GUILayout.Label("MessagePack CodeGen does not instaled.");
                EditorGUI.BeginDisabledGroup(installingMpc);

                if (GUILayout.Button("Install MessagePack CodeGen."))
                {
                    installingMpc = true;
                    try
                    {
                        var log = await ProcessHelper.InstallMpc();
                        if (!string.IsNullOrWhiteSpace(log))
                        {
                            UnityEngine.Debug.Log(log);
                        }
                        if (log != null && log.Contains("error"))
                        {
                            isInstalledMpc = false;
                        }
                        else
                        {
                            isInstalledMpc = true;
                        }
                    }
                    finally
                    {
                        installingMpc = false;
                    }
                    return;
                }

                EditorGUI.EndDisabledGroup();
                return;
            }

            EditorGUILayout.LabelField("-i input path(csproj or directory):");
            TextField(mpcArgument, x => x.Input, (x, y) => x.Input = y);

            EditorGUILayout.LabelField("-o output filepath(.cs) or directory(multiple):");
            TextField(mpcArgument, x => x.Output, (x, y) => x.Output = y);

            EditorGUILayout.LabelField("-m(optional) use map mode:");
            var newToggle = EditorGUILayout.Toggle(mpcArgument.UseMapMode);
            if (mpcArgument.UseMapMode != newToggle)
            {
                mpcArgument.UseMapMode = newToggle;
                mpcArgument.Save();
            }

            EditorGUILayout.LabelField("-c(optional) conditional compiler symbols(split with ','):");
            TextField(mpcArgument, x => x.ConditionalSymbol, (x, y) => x.ConditionalSymbol = y);

            EditorGUILayout.LabelField("-r(optional) generated resolver name:");
            TextField(mpcArgument, x => x.ResolverName, (x, y) => x.ResolverName = y);

            EditorGUILayout.LabelField("-n(optional) namespace root name:");
            TextField(mpcArgument, x => x.Namespace, (x, y) => x.Namespace = y);

            EditorGUILayout.LabelField("-ms(optional) Generate #if-- files by symbols, split with ','");
            TextField(mpcArgument, x => x.MultipleIfDirectiveOutputSymbols, (x, y) => x.MultipleIfDirectiveOutputSymbols = y);

            EditorGUI.BeginDisabledGroup(invokingMpc);
            if (GUILayout.Button("Generate"))
            {
                var commnadLineArguments = mpcArgument.ToString();
                UnityEngine.Debug.Log("Generate MessagePack Files, command:" + commnadLineArguments);

                invokingMpc = true;
                try
                {
                    var log = await ProcessHelper.InvokeProcessStartAsync("mpc", commnadLineArguments);
                    UnityEngine.Debug.Log(log);
                }
                finally
                {
                    invokingMpc = false;
                }
            }
            EditorGUI.EndDisabledGroup();
        }

        void TextField(MpcArgument args, Func<MpcArgument, string> getter, Action<MpcArgument, string> setter)
        {
            var current = getter(args);
            var newValue = EditorGUILayout.TextField(current);
            if (newValue != current)
            {
                setter(args, newValue);
                args.Save();
            }
        }
    }

    internal class MpcArgument
    {
        public string Input;
        public string Output;
        public string ConditionalSymbol;
        public string ResolverName;
        public string Namespace;
        public bool UseMapMode;
        public string MultipleIfDirectiveOutputSymbols;

        static string Key => "MessagePackCodeGen." + Application.productName;

        public static MpcArgument Restore()
        {
            if (EditorPrefs.HasKey(Key))
            {
                var json = EditorPrefs.GetString(Key);
                return JsonUtility.FromJson<MpcArgument>(json);
            }
            else
            {
                return new MpcArgument();
            }
        }

        public void Save()
        {
            var json = JsonUtility.ToJson(this);
            EditorPrefs.SetString(Key, json);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("-i "); sb.Append(Input);
            sb.Append(" -o "); sb.Append(Output);
            if (!string.IsNullOrWhiteSpace(ConditionalSymbol))
            {
                sb.Append(" -c "); sb.Append(ConditionalSymbol);
            }
            if (!string.IsNullOrWhiteSpace(ResolverName))
            {
                sb.Append(" -r "); sb.Append(ResolverName);
            }
            if (UseMapMode)
            {
                sb.Append(" -m");
            }
            if (!string.IsNullOrWhiteSpace(Namespace))
            {
                sb.Append(" -n "); sb.Append(Namespace);
            }
            if (!string.IsNullOrWhiteSpace(MultipleIfDirectiveOutputSymbols))
            {
                sb.Append(" -ms "); sb.Append(MultipleIfDirectiveOutputSymbols);
            }

            return sb.ToString();
        }
    }

    internal static class ProcessHelper
    {
        const string InstallName = "messagepack.generator";

        public static async Task<bool> IsInstalledMpc()
        {
            var list = await InvokeProcessStartAsync("dotnet", "tool list -g");
            if (list.Contains(InstallName))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public static async Task<string> InstallMpc()
        {
            return await InvokeProcessStartAsync("dotnet", "tool install --global " + InstallName);
        }

        public static async Task<(bool found, string version)> FindDotnetAsync()
        {
            try
            {
                var version = await InvokeProcessStartAsync("dotnet", "--version");
                return (true, version);
            }
            catch
            {
                return (false, null);
            }
        }

        public static Task<string> InvokeProcessStartAsync(string fileName, string arguments)
        {
            var psi = new ProcessStartInfo()
            {
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden,
                StandardOutputEncoding = Encoding.UTF8,
                StandardErrorEncoding = Encoding.UTF8,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                FileName = fileName,
                Arguments = arguments,
                WorkingDirectory = Application.dataPath
            };

            Process p;
            try
            {
                p = Process.Start(psi);
            }
            catch (Exception ex)
            {
                return Task.FromException<string>(ex);
            }

            var tcs = new TaskCompletionSource<string>();
            p.EnableRaisingEvents = true;
            p.Exited += (object sender, System.EventArgs e) =>
            {
                var data = p.StandardOutput.ReadToEnd();
                p.Dispose();
                p = null;

                tcs.TrySetResult(data);
            };

            return tcs.Task;
        }
    }
}

#endif



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/MessagePackWindow.cs.meta
================================================
fileFormatVersion: 2
guid: c7b2124e98ab01345a59ac40b0979625
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/UnityResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using MessagePack.Formatters;
using UnityEngine;

namespace MessagePack.Unity
{
    public class UnityResolver : IFormatterResolver
    {
        public static readonly UnityResolver Instance = new UnityResolver();

        private UnityResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)UnityResolveryResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }

    internal static class UnityResolveryResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, object> FormatterMap = new Dictionary<Type, object>()
        {
            // standard
            { typeof(Vector2), new Vector2Formatter() },
            { typeof(Vector3), new Vector3Formatter() },
            { typeof(Vector4), new Vector4Formatter() },
            { typeof(Quaternion), new QuaternionFormatter() },
            { typeof(Color), new ColorFormatter() },
            { typeof(Bounds), new BoundsFormatter() },
            { typeof(Rect), new RectFormatter() },
            { typeof(Vector2?), new StaticNullableFormatter<Vector2>(new Vector2Formatter()) },
            { typeof(Vector3?), new StaticNullableFormatter<Vector3>(new Vector3Formatter()) },
            { typeof(Vector4?), new StaticNullableFormatter<Vector4>(new Vector4Formatter()) },
            { typeof(Quaternion?), new StaticNullableFormatter<Quaternion>(new QuaternionFormatter()) },
            { typeof(Color?), new StaticNullableFormatter<Color>(new ColorFormatter()) },
            { typeof(Bounds?), new StaticNullableFormatter<Bounds>(new BoundsFormatter()) },
            { typeof(Rect?), new StaticNullableFormatter<Rect>(new RectFormatter()) },

            // standard + array
            { typeof(Vector2[]), new ArrayFormatter<Vector2>() },
            { typeof(Vector3[]), new ArrayFormatter<Vector3>() },
            { typeof(Vector4[]), new ArrayFormatter<Vector4>() },
            { typeof(Quaternion[]), new ArrayFormatter<Quaternion>() },
            { typeof(Color[]), new ArrayFormatter<Color>() },
            { typeof(Bounds[]), new ArrayFormatter<Bounds>() },
            { typeof(Rect[]), new ArrayFormatter<Rect>() },
            { typeof(Vector2?[]), new ArrayFormatter<Vector2?>() },
            { typeof(Vector3?[]), new ArrayFormatter<Vector3?>() },
            { typeof(Vector4?[]), new ArrayFormatter<Vector4?>() },
            { typeof(Quaternion?[]), new ArrayFormatter<Quaternion?>() },
            { typeof(Color?[]), new ArrayFormatter<Color?>() },
            { typeof(Bounds?[]), new ArrayFormatter<Bounds?>() },
            { typeof(Rect?[]), new ArrayFormatter<Rect?>() },

            // standard + list
            { typeof(List<Vector2>), new ListFormatter<Vector2>() },
            { typeof(List<Vector3>), new ListFormatter<Vector3>() },
            { typeof(List<Vector4>), new ListFormatter<Vector4>() },
            { typeof(List<Quaternion>), new ListFormatter<Quaternion>() },
            { typeof(List<Color>), new ListFormatter<Color>() },
            { typeof(List<Bounds>), new ListFormatter<Bounds>() },
            { typeof(List<Rect>), new ListFormatter<Rect>() },
            { typeof(List<Vector2?>), new ListFormatter<Vector2?>() },
            { typeof(List<Vector3?>), new ListFormatter<Vector3?>() },
            { typeof(List<Vector4?>), new ListFormatter<Vector4?>() },
            { typeof(List<Quaternion?>), new ListFormatter<Quaternion?>() },
            { typeof(List<Color?>), new ListFormatter<Color?>() },
            { typeof(List<Bounds?>), new ListFormatter<Bounds?>() },
            { typeof(List<Rect?>), new ListFormatter<Rect?>() },

            // new
            { typeof(AnimationCurve),     new AnimationCurveFormatter() },
            { typeof(RectOffset),         new RectOffsetFormatter() },
            { typeof(Gradient),           new GradientFormatter() },
            { typeof(WrapMode),           new WrapModeFormatter() },
            { typeof(GradientMode),       new GradientModeFormatter() },
            { typeof(Keyframe),           new KeyframeFormatter() },
            { typeof(Matrix4x4),          new Matrix4x4Formatter() },
            { typeof(GradientColorKey),   new GradientColorKeyFormatter() },
            { typeof(GradientAlphaKey),   new GradientAlphaKeyFormatter() },
            { typeof(Color32),            new Color32Formatter() },
            { typeof(LayerMask),          new LayerMaskFormatter() },
            { typeof(WrapMode?),          new StaticNullableFormatter<WrapMode>(new WrapModeFormatter()) },
            { typeof(GradientMode?),      new StaticNullableFormatter<GradientMode>(new GradientModeFormatter()) },
            { typeof(Keyframe?),          new StaticNullableFormatter<Keyframe>(new KeyframeFormatter()) },
            { typeof(Matrix4x4?),         new StaticNullableFormatter<Matrix4x4>(new Matrix4x4Formatter()) },
            { typeof(GradientColorKey?),  new StaticNullableFormatter<GradientColorKey>(new GradientColorKeyFormatter()) },
            { typeof(GradientAlphaKey?),  new StaticNullableFormatter<GradientAlphaKey>(new GradientAlphaKeyFormatter()) },
            { typeof(Color32?),           new StaticNullableFormatter<Color32>(new Color32Formatter()) },
            { typeof(LayerMask?),         new StaticNullableFormatter<LayerMask>(new LayerMaskFormatter()) },

            // new + array
            { typeof(AnimationCurve[]),     new ArrayFormatter<AnimationCurve>() },
            { typeof(RectOffset[]),         new ArrayFormatter<RectOffset>() },
            { typeof(Gradient[]),           new ArrayFormatter<Gradient>() },
            { typeof(WrapMode[]),           new ArrayFormatter<WrapMode>() },
            { typeof(GradientMode[]),       new ArrayFormatter<GradientMode>() },
            { typeof(Keyframe[]),           new ArrayFormatter<Keyframe>() },
            { typeof(Matrix4x4[]),          new ArrayFormatter<Matrix4x4>() },
            { typeof(GradientColorKey[]),   new ArrayFormatter<GradientColorKey>() },
            { typeof(GradientAlphaKey[]),   new ArrayFormatter<GradientAlphaKey>() },
            { typeof(Color32[]),            new ArrayFormatter<Color32>() },
            { typeof(LayerMask[]),          new ArrayFormatter<LayerMask>() },
            { typeof(WrapMode?[]),          new ArrayFormatter<WrapMode?>() },
            { typeof(GradientMode?[]),      new ArrayFormatter<GradientMode?>() },
            { typeof(Keyframe?[]),          new ArrayFormatter<Keyframe?>() },
            { typeof(Matrix4x4?[]),         new ArrayFormatter<Matrix4x4?>() },
            { typeof(GradientColorKey?[]),  new ArrayFormatter<GradientColorKey?>() },
            { typeof(GradientAlphaKey?[]),  new ArrayFormatter<GradientAlphaKey?>() },
            { typeof(Color32?[]),           new ArrayFormatter<Color32?>() },
            { typeof(LayerMask?[]),         new ArrayFormatter<LayerMask?>() },

            // new + list
            { typeof(List<AnimationCurve>),     new ListFormatter<AnimationCurve>() },
            { typeof(List<RectOffset>),         new ListFormatter<RectOffset>() },
            { typeof(List<Gradient>),           new ListFormatter<Gradient>() },
            { typeof(List<WrapMode>),           new ListFormatter<WrapMode>() },
            { typeof(List<GradientMode>),       new ListFormatter<GradientMode>() },
            { typeof(List<Keyframe>),           new ListFormatter<Keyframe>() },
            { typeof(List<Matrix4x4>),          new ListFormatter<Matrix4x4>() },
            { typeof(List<GradientColorKey>),   new ListFormatter<GradientColorKey>() },
            { typeof(List<GradientAlphaKey>),   new ListFormatter<GradientAlphaKey>() },
            { typeof(List<Color32>),            new ListFormatter<Color32>() },
            { typeof(List<LayerMask>),          new ListFormatter<LayerMask>() },
            { typeof(List<WrapMode?>),          new ListFormatter<WrapMode?>() },
            { typeof(List<GradientMode?>),      new ListFormatter<GradientMode?>() },
            { typeof(List<Keyframe?>),          new ListFormatter<Keyframe?>() },
            { typeof(List<Matrix4x4?>),         new ListFormatter<Matrix4x4?>() },
            { typeof(List<GradientColorKey?>),  new ListFormatter<GradientColorKey?>() },
            { typeof(List<GradientAlphaKey?>),  new ListFormatter<GradientAlphaKey?>() },
            { typeof(List<Color32?>),           new ListFormatter<Color32?>() },
            { typeof(List<LayerMask?>),         new ListFormatter<LayerMask?>() },

            // unity 2017.2
#if UNITY_2017_2_OR_NEWER

            {typeof(Vector2Int),         new Vector2IntFormatter()},
            {typeof(Vector3Int),         new Vector3IntFormatter()},
            {typeof(RangeInt),           new RangeIntFormatter()},
            {typeof(RectInt),            new RectIntFormatter()},
            {typeof(BoundsInt),          new BoundsIntFormatter()},
            {typeof(Vector2Int?),        new StaticNullableFormatter<Vector2Int>(new Vector2IntFormatter())},
            {typeof(Vector3Int?),        new StaticNullableFormatter<Vector3Int>(new Vector3IntFormatter())},
            {typeof(RangeInt?),          new StaticNullableFormatter<RangeInt>(new RangeIntFormatter())},
            {typeof(RectInt?),           new StaticNullableFormatter<RectInt>(new RectIntFormatter())},
            {typeof(BoundsInt?),         new StaticNullableFormatter<BoundsInt>(new BoundsIntFormatter())},
            // unity 2017.2 + array
            {typeof(Vector2Int[]),       new ArrayFormatter<Vector2Int>()},
            {typeof(Vector3Int[]),       new ArrayFormatter<Vector3Int>()},
            {typeof(RangeInt[]),         new ArrayFormatter<RangeInt>()},
            {typeof(RectInt[]),          new ArrayFormatter<RectInt>()},
            {typeof(BoundsInt[]),        new ArrayFormatter<BoundsInt>()},
            {typeof(Vector2Int?[]),      new ArrayFormatter<Vector2Int?>()},
            {typeof(Vector3Int?[]),      new ArrayFormatter<Vector3Int?>()},
            {typeof(RangeInt?[]),        new ArrayFormatter<RangeInt?>()},
            {typeof(RectInt?[]),         new ArrayFormatter<RectInt?>()},
            {typeof(BoundsInt?[]),       new ArrayFormatter<BoundsInt?>()},
            // unity 2017.2 + list
            {typeof(List<Vector2Int>),       new ListFormatter<Vector2Int>()},
            {typeof(List<Vector3Int>),       new ListFormatter<Vector3Int>()},
            {typeof(List<RangeInt>),         new ListFormatter<RangeInt>()},
            {typeof(List<RectInt>),          new ListFormatter<RectInt>()},
            {typeof(List<BoundsInt>),        new ListFormatter<BoundsInt>()},
            {typeof(List<Vector2Int?>),      new ListFormatter<Vector2Int?>()},
            {typeof(List<Vector3Int?>),      new ListFormatter<Vector3Int?>()},
            {typeof(List<RangeInt?>),        new ListFormatter<RangeInt?>()},
            {typeof(List<RectInt?>),         new ListFormatter<RectInt?>()},
            {typeof(List<BoundsInt?>),       new ListFormatter<BoundsInt?>()},

#endif
        };

        internal static object GetFormatter(Type t)
        {
            object formatter;
            if (FormatterMap.TryGetValue(t, out formatter))
            {
                return formatter;
            }

            return null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/UnityResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 88a64133a719d3e40a7725f13b2f0191
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Extension/UnityBlitResolver.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using MessagePack.Formatters;
using UnityEngine;

namespace MessagePack.Unity.Extension
{
    /// <summary>
    /// Special Resolver for Vector2[], Vector3[], Vector4[], Quaternion[], Color[], Bounds[], Rect[].
    /// </summary>
    public class UnityBlitResolver : IFormatterResolver
    {
        public static readonly UnityBlitResolver Instance = new UnityBlitResolver();

        private UnityBlitResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            public static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)UnityBlitResolverGetFormatterHelper.GetFormatter(typeof(T));
            }
        }
    }

    /// <summary>
    /// Special Resolver for Vector2[], Vector3[], Vector4[], Quaternion[], Color[], Bounds[], Rect[] + int[], float[], double[].
    /// </summary>
    public class UnityBlitWithPrimitiveArrayResolver : IFormatterResolver
    {
        public static readonly UnityBlitWithPrimitiveArrayResolver Instance = new UnityBlitWithPrimitiveArrayResolver();

        private UnityBlitWithPrimitiveArrayResolver()
        {
        }

        public IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                Formatter = (IMessagePackFormatter<T>)UnityBlitWithPrimitiveResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (Formatter == null)
                {
                    Formatter = UnityBlitResolver.Instance.GetFormatter<T>();
                }
            }
        }
    }

    internal static class UnityBlitResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, Type> FormatterMap = new Dictionary<Type, Type>()
        {
              { typeof(Vector2[]), typeof(Vector2ArrayBlitFormatter) },
              { typeof(Vector3[]), typeof(Vector3ArrayBlitFormatter) },
              { typeof(Vector4[]), typeof(Vector4ArrayBlitFormatter) },
              { typeof(Quaternion[]), typeof(QuaternionArrayBlitFormatter) },
              { typeof(Color[]), typeof(ColorArrayBlitFormatter) },
              { typeof(Bounds[]), typeof(BoundsArrayBlitFormatter) },
              { typeof(Rect[]), typeof(RectArrayBlitFormatter) },
        };

        internal static object GetFormatter(Type t)
        {
            Type formatterType;
            if (FormatterMap.TryGetValue(t, out formatterType))
            {
                return Activator.CreateInstance(formatterType);
            }

            return null;
        }
    }

    internal static class UnityBlitWithPrimitiveResolverGetFormatterHelper
    {
        private static readonly Dictionary<Type, Type> FormatterMap = new Dictionary<Type, Type>()
        {
              { typeof(int[]), typeof(IntArrayBlitFormatter) },
              { typeof(float[]), typeof(FloatArrayBlitFormatter) },
              { typeof(double[]), typeof(DoubleArrayBlitFormatter) },
        };

        internal static object GetFormatter(Type t)
        {
            Type formatterType;
            if (FormatterMap.TryGetValue(t, out formatterType))
            {
                return Activator.CreateInstance(formatterType);
            }

            return null;
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Extension/UnityBlitResolver.cs.meta
================================================
fileFormatVersion: 2
guid: 2780e6c52e347c540a336113d4a61fd3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Extension/UnsafeBlitFormatter.cs
================================================
﻿// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using MessagePack.Formatters;
using UnityEngine;

#pragma warning disable SA1402 // multiple types in a file
#pragma warning disable SA1649 // file name matches type name

namespace MessagePack.Unity.Extension
{
    // use ext instead of ArrayFormatter to extremely boost up performance.
    // Layout: [extHeader, byteSize(integer), isLittleEndian(bool), bytes()]
    // Used Ext:30~36
    public abstract class UnsafeBlitFormatterBase<T> : IMessagePackFormatter<T[]>
        where T : struct
    {
        protected abstract sbyte TypeCode { get; }

        protected void CopyDeserializeUnsafe(ReadOnlySpan<byte> src, Span<T> dest) => src.CopyTo(MemoryMarshal.Cast<T, byte>(dest));

        public void Serialize(ref MessagePackWriter writer, T[] value, MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            var byteLen = value.Length * Marshal.SizeOf<T>();

            writer.WriteExtensionFormatHeader(new ExtensionHeader(this.TypeCode, byteLen));
            writer.Write(byteLen); // write original header(not array header)
            writer.Write(BitConverter.IsLittleEndian);
            writer.WriteRaw(MemoryMarshal.Cast<T, byte>(value));
        }

        public T[] Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            ExtensionHeader header = reader.ReadExtensionFormatHeader();
            if (header.TypeCode != this.TypeCode)
            {
                throw new InvalidOperationException("Invalid typeCode.");
            }

            var byteLength = reader.ReadInt32();
            var isLittleEndian = reader.ReadBoolean();

            // Allocate a T[] that we will return. We'll then cast the T[] as byte[] so we can copy the byte sequence directly into it.
            var result = new T[byteLength / Marshal.SizeOf<T>()];
            Span<byte> resultAsBytes = MemoryMarshal.Cast<T, byte>(result);
            reader.ReadRaw(byteLength).CopyTo(resultAsBytes);

            // Reverse the byte order if necessary.
            if (isLittleEndian != BitConverter.IsLittleEndian)
            {
                for (int i = 0, j = resultAsBytes.Length - 1; i < j; i++, j--)
                {
                    byte tmp = resultAsBytes[i];
                    resultAsBytes[i] = resultAsBytes[j];
                    resultAsBytes[j] = tmp;
                }
            }

            return result;
        }
    }

    public class Vector2ArrayBlitFormatter : UnsafeBlitFormatterBase<Vector2>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityVector2;
            }
        }
    }

    public class Vector3ArrayBlitFormatter : UnsafeBlitFormatterBase<Vector3>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityVector3;
            }
        }
    }

    public class Vector4ArrayBlitFormatter : UnsafeBlitFormatterBase<Vector4>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityVector4;
            }
        }
    }

    public class QuaternionArrayBlitFormatter : UnsafeBlitFormatterBase<Quaternion>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityQuaternion;
            }
        }
    }

    public class ColorArrayBlitFormatter : UnsafeBlitFormatterBase<Color>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityColor;
            }
        }
    }

    public class BoundsArrayBlitFormatter : UnsafeBlitFormatterBase<Bounds>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityBounds;
            }
        }
    }

    public class RectArrayBlitFormatter : UnsafeBlitFormatterBase<Rect>
    {
        protected override sbyte TypeCode
        {
            get
            {
                return ThisLibraryExtensionTypeCodes.UnityRect;
            }
        }
    }

    public class IntArrayBlitFormatter : UnsafeBlitFormatterBase<int>
    {
        protected override sbyte TypeCode
        {
            get { return ThisLibraryExtensionTypeCodes.UnityInt; }
        }
    }

    public class FloatArrayBlitFormatter : UnsafeBlitFormatterBase<float>
    {
        protected override sbyte TypeCode
        {
            get { return ThisLibraryExtensionTypeCodes.UnityFloat; }
        }
    }

    public class DoubleArrayBlitFormatter : UnsafeBlitFormatterBase<double>
    {
        protected override sbyte TypeCode
        {
            get { return ThisLibraryExtensionTypeCodes.UnityDouble; }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Scripts/MessagePack/Unity/Extension/UnsafeBlitFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 314e1d2058a6e9d4297aa329b34150d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/BuiltinTest.cs
================================================
﻿using Cysharp.Threading.Tasks;
using MessagePipe;
using NUnit.Framework;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.TestTools;

public class BuiltinTest
{
    [Test]
    public void SimpelePush()
    {
        var resolver = TestHelper.BuildBuiltin((builder) =>
        {
            builder.AddMessageBroker<int>();
        });
        GlobalMessagePipe.SetProvider(resolver);

        var pub = resolver.GetRequiredService<IPublisher<int>>();
        var sub1 = resolver.GetRequiredService<ISubscriber<int>>();
        var sub2 = resolver.GetRequiredService<ISubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(x => list.Add(x));
        var d2 = sub2.Subscribe(x => list.Add(x));

        pub.Publish(10);
        pub.Publish(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        pub.Publish(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    }

    [UnityTest]
    public IEnumerator SimpleAsyncPush() => UniTask.ToCoroutine(async () =>
    {
        var resolver = TestHelper.BuildBuiltin((builder) =>
        {
            builder.AddMessageBroker<int>();
        });

        var pub = resolver.GetRequiredService<IAsyncPublisher<int>>();
        var sub1 = resolver.GetRequiredService<IAsyncSubscriber<int>>();
        var sub2 = resolver.GetRequiredService<IAsyncSubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });
        var d2 = sub2.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });

        await pub.PublishAsync(10);
        await pub.PublishAsync(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        await pub.PublishAsync(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    });

    [Test]
    public void WithFilter()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildBuiltin(options =>
        {
            options.AddGlobalMessageHandlerFilter<MyFilter<int>>(1200);
        }, (builder) =>
        {
            builder.AddMessageBroker<int>();

            builder.AddMessageHandlerFilter<MyFilter<int>>();
            builder.AddSingleton(store);
        });

        var pub = resolver.GetRequiredService<IPublisher<int>>();
        var sub1 = resolver.GetRequiredService<ISubscriber<int>>();

        var d1 = sub1.Subscribe(new MyHandler(store), new MyFilter<int>(store) { Order = -10 });

        pub.Publish(9999);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-10",
            "Order:999",
            "Order:1099",
            "Order:1200",
            "Handle:9999",
        });
    }

    [Test]
    public void Request()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildBuiltin(options =>
        {
            options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
        }, (builder) =>
        {
            builder.AddSingleton(store);
            builder.AddRequestHandler<int, int, MyRequestHandler>();
        });

        var handler = resolver.GetRequiredService<IRequestHandler<int, int>>();

        var result = handler.Invoke(1999);
        Assert.AreEqual(result, 19990);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-1799",
            "Order:999",
            "Order:1099",
            "Invoke:1999",
        });
    }

    // not supported.
    //[Test]
    //public void RequestAll()
    //{
    //    var store = new DataStore();

    //    var resolver = TestHelper.BuildBuiltin(options =>
    //    {
    //        // options.InstanceLifetime = InstanceLifetime.Scoped;
    //        options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
    //    }, (builder) =>
    //    {
    //        builder.AddSingleton(store);
    //        builder.AddRequestHandler<int, int, MyRequestHandler>();
    //        builder.AddRequestHandler<int, int, MyRequestHandler2>();
    //    });

    //    var handler = resolver.GetRequiredService<IRequestAllHandler<int, int>>();

    //    var result = handler.InvokeAll(1999);
    //    CollectionAssert.AreEqual(result, new[] { 19990, 199900 });

    //    CollectionAssert.AreEqual(store.Logs, new[]
    //    {
    //        "Order:-1799",
    //        "Order:999",
    //        "Order:1099",
    //        "Invoke:1999",
    //        "Order:-1799",
    //        "Invoke2:1999",
    //    });
    //}

    [Test]
    public void Buffered()
    {
        var provider = TestHelper.BuildBuiltin((builder) =>
        {
            builder.AddMessageBroker<IntClass>();
        });

        var p = provider.GetRequiredService<IBufferedPublisher<IntClass>>();
        var s = provider.GetRequiredService<IBufferedSubscriber<IntClass>>();

        var l = new List<int>();
        using (var d1 = s.Subscribe(x => l.Add(x.Value)))
        {
            Assert.AreEqual(0, l.Count);
        }

        p.Publish(new IntClass { Value = 9999 }); // set initial value

        var d2 = s.Subscribe(x => l.Add(x.Value));

        CollectionAssert.AreEqual(new[] { 9999 }, l);
        p.Publish(new IntClass { Value = 333 });
        CollectionAssert.AreEqual(new[] { 9999, 333 }, l);

        var d3 = s.Subscribe(x => l.Add(x.Value));
        CollectionAssert.AreEqual(new[] { 9999, 333, 333 }, l);
        p.Publish(new IntClass { Value = 11 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11 }, l);
        d3.Dispose();
        p.Publish(new IntClass { Value = 4 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11, 4 }, l);
    }

    public class IntClass
    {
        public int Value { get; set; }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/BuiltinTest.cs.meta
================================================
fileFormatVersion: 2
guid: add625a9eb15c7c4ca54ea6b0cca1cc7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/InterprocessTest.cs
================================================
﻿#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously

using VContainer;
using Cysharp.Threading.Tasks;
using MessagePipe;
using NUnit.Framework;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.TestTools;
using System.Threading;
using System;

public class InterprocessTest
{
    [UnityTest]
    public IEnumerator SimpleUdp() => UniTask.ToCoroutine(async () =>
    {
        var rootProvider = TestHelper.BuildVContainer(x =>
        {
        }, (options, builder) =>
        {
            var messagePipeBuilder = builder.ToMessagePipeBuilder();
            var newOptions = messagePipeBuilder.AddUdpInterprocess("127.0.0.1", 1192, x =>
            {
                x.InstanceLifetime = InstanceLifetime.Scoped;
            });
            messagePipeBuilder.RegisterUpdInterprocessMessageBroker<int, int>(newOptions);
        });

        using (var provider = rootProvider)
        {
            var p1 = provider.Resolve<IDistributedPublisher<int, int>>();
            var s1 = provider.Resolve<IDistributedSubscriber<int, int>>();

            var list1 = new List<int>();
            var list2 = new List<int>();

            var t = s1.SubscribeAsync(10, async x => list1.Add(x));

            await t;

            await UniTask.Delay(100);
            await p1.PublishAsync(10, 9999);
            await p1.PublishAsync(10, 8888);
            await p1.PublishAsync(19, 7777);


            await UniTask.Delay(100);
            await p1.PublishAsync(10, 6666);
            await p1.PublishAsync(19, 5555);

            await UniTask.Delay(100);

            CollectionAssert.AreEqual(list1, new[] { 9999, 8888, 6666 });
        }
    });

    [UnityTest]
    public IEnumerator SimpleTcp() => UniTask.ToCoroutine(async () =>
    {
        var rootProvider = TestHelper.BuildVContainer(x =>
        {
        }, (options, builder) =>
        {
            var messagePipeBuilder = builder.ToMessagePipeBuilder();
            var newOptions = messagePipeBuilder.AddTcpInterprocess("127.0.0.1", 1211, x =>
             {
                 x.InstanceLifetime = InstanceLifetime.Scoped;
                 x.HostAsServer = true;
             });
            messagePipeBuilder.RegisterTcpInterprocessMessageBroker<int, int>(newOptions);
        });

        using (var provider = rootProvider)
        {
            var p1 = provider.Resolve<IDistributedPublisher<int, int>>();
            var s1 = provider.Resolve<IDistributedSubscriber<int, int>>();

            var list1 = new List<int>();
            var list2 = new List<int>();

            var t = s1.SubscribeAsync(10, async x => list1.Add(x));

            await t;

            await UniTask.Delay(100);
            await p1.PublishAsync(10, 9999);
            await p1.PublishAsync(10, 8888);
            await p1.PublishAsync(19, 7777);

            await UniTask.Delay(100);

            await p1.PublishAsync(10, 6666);
            await p1.PublishAsync(19, 5555);

            await UniTask.Delay(100);


            CollectionAssert.AreEqual(list1, new[] { 9999, 8888, 6666 });


        }
    });


    //[UnityTest]
    //public IEnumerator Request() => UniTask.ToCoroutine(async () =>
    //{
    //    var rootProvider = TestHelper.BuildVContainer(x =>
    //    {
    //    }, (options, builder) =>
    //    {
    //        var sc = builder.AsServiceCollection();
    //        var newOptions = sc.AddMessagePipeTcpInterprocess("127.0.0.1", 1211, x =>
    //        {
    //            x.InstanceLifetime = InstanceLifetime.Scoped;
    //            x.HostAsServer = true;
    //        });

    //        builder.RegisterAsyncRequestHandler<int, string, MyAsyncHandler>(options);
    //        sc.RegisterTcpRemoteRequestHandler<int, string>(newOptions);
    //    });

    //    using (var provider = rootProvider)
    //    {
    //        var remoteHandler = provider.Resolve<IRemoteRequestHandler<int, string>>();

    //        var v = await remoteHandler.InvokeAsync(9999);
    //        Assert.AreEqual("ECHO:9999", v);

    //        var v2 = await remoteHandler.InvokeAsync(4444);
    //        Assert.AreEqual("ECHO:4444", v2);

    //        try
    //        {
    //            var v3 = await remoteHandler.InvokeAsync(-1);
    //            Assert.Fail();
    //        }
    //        catch (RemoteRequestException ex)
    //        {
    //            Assert.AreEqual(true, ex.Message.Contains("NO -1"));
    //        }
    //    }
    //});


    public class MyAsyncHandler : IAsyncRequestHandler<int, string>
    {
        [Inject]
        public MyAsyncHandler()
        {

        }

        public async UniTask<string> InvokeAsync(int request, CancellationToken cancellationToken = default)
        {
            await UniTask.Delay(1);
            if (request == -1)
            {
                throw new Exception("NO -1");
            }
            else
            {
                return "ECHO:" + request.ToString();
            }
        }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/InterprocessTest.cs.meta
================================================
fileFormatVersion: 2
guid: d53e0ab681631444ebd864a8b1526cc4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/TestHelper.cs
================================================
﻿using MessagePipe;
using System;
using VContainer;
using Zenject;

public static class TestHelper
{
    public static IObjectResolver BuildVContainer()
    {
        var builder = new ContainerBuilder();
        builder.RegisterMessagePipe();
        return builder.Build();
    }
    
    public static IObjectResolver BuildVContainer(Action<MessagePipeOptions> configure, Action<MessagePipeOptions, ContainerBuilder> use)
    {
        var builder = new ContainerBuilder();
        var options = builder.RegisterMessagePipe(configure);
        use(options, builder);

        return builder.Build();
    }

    public static IObjectResolver BuildVContainer(Action<MessagePipeOptions, ContainerBuilder> use)
    {
        var builder = new ContainerBuilder();
        var options = builder.RegisterMessagePipe();
        use(options, builder);

        return builder.Build();
    }

    public static DiContainer BuildZenject(Action<MessagePipeOptions> configure, Action<MessagePipeOptions, DiContainer> use)
    {
        var builder = new DiContainer();
        var options = builder.BindMessagePipe(configure);
        use(options, builder);

        return builder;
    }

    public static DiContainer BuildZenject(Action<MessagePipeOptions, DiContainer> use)
    {
        var builder = new DiContainer();
        var options = builder.BindMessagePipe();
        use(options, builder);

        return builder;
    }

    public static IServiceProvider BuildBuiltin(Action<MessagePipeOptions> configure, Action<BuiltinContainerBuilder> use)
    {
        var builder = new BuiltinContainerBuilder();
        builder.AddMessagePipe(configure);
        use(builder);

        return builder.BuildServiceProvider();
    }

    public static IServiceProvider BuildBuiltin(Action<BuiltinContainerBuilder> use)
    {
        var builder = new BuiltinContainerBuilder();
        builder.AddMessagePipe();
        use(builder);

        return builder.BuildServiceProvider();
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/TestHelper.cs.meta
================================================
fileFormatVersion: 2
guid: 4be6fe3b2a60e5548ae64b96c0098da3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/Tests.asmdef
================================================
{
    "name": "Tests",
    "rootNamespace": "",
    "references": [
        "UnityEngine.TestRunner",
        "UnityEditor.TestRunner",
        "VContainer",
        "MessagePipe",
        "MessagePipe.VContainer",
        "MessagePipe.Interprocess",
        "UniTask",
        "UniTask.Linq",
        "RuntimeUnitTestToolkit",
        "Zenject",
        "MessagePipe.Zenject"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": true,
    "precompiledReferences": [
        "nunit.framework.dll"
    ],
    "autoReferenced": false,
    "defineConstraints": [
        "UNITY_INCLUDE_TESTS"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MessagePipe.Unity/Assets/Tests/Tests.asmdef.meta
================================================
fileFormatVersion: 2
guid: 8523c8951da01234897c3a4fd579a47d
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/TestType.cs
================================================
﻿using MessagePipe;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine.Scripting;

public class DataStore
{
    public List<string> Logs { get; set; }

    public DataStore()
    {
        Logs = new List<string>();
    }
}


public class MyFilter<T> : MessageHandlerFilter<T>
{
    readonly DataStore store;

    public MyFilter(DataStore store)
    {
        this.store = store;
    }

    public override void Handle(T message, Action<T> next)
    {
        store.Logs.Add($"Order:{Order}");
        next(message);
    }
}

[MessageHandlerFilter(typeof(MyFilter<int>), Order = 999)]
[MessageHandlerFilter(typeof(MyFilter<int>), Order = 1099)]
public class MyHandler : IMessageHandler<int>
{
    DataStore store;

    public MyHandler(DataStore store)
    {
        this.store = store;
    }

    public void Handle(int message)
    {
        store.Logs.Add("Handle:" + message);
    }
}

[RequestHandlerFilter(typeof(MyRequestHandlerFilter), Order = 999)]
[RequestHandlerFilter(typeof(MyRequestHandlerFilter), Order = 1099)]
[Preserve]
public class MyRequestHandler : IRequestHandler<int, int>
{
    readonly DataStore store;

    [Preserve]
    public MyRequestHandler(DataStore store)
    {
        this.store = store;
    }

    public int Invoke(int request)
    {
        store.Logs.Add("Invoke:" + request);
        return request * 10;
    }
}

[Preserve]
public class MyRequestHandler2 : IRequestHandler<int, int>
{
    readonly DataStore store;

    [Preserve]
    public MyRequestHandler2(DataStore store)
    {
        this.store = store;
    }

    public int Invoke(int request)
    {
        store.Logs.Add("Invoke2:" + request);
        return request * 100;
    }
}

[Preserve]
public class MyRequestHandlerFilter : RequestHandlerFilter<int, int>
{
    readonly DataStore store;

    [Preserve]
    public MyRequestHandlerFilter(DataStore store)
    {
        this.store = store;
    }

    public override int Invoke(int request, Func<int, int> next)
    {
        store.Logs.Add($"Order:{Order}");
        return next(request);
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/TestType.cs.meta
================================================
fileFormatVersion: 2
guid: 132188e9cbb7cc0469c77f04bf0cca13
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/VContainerTest.cs
================================================
using Cysharp.Threading.Tasks;
using MessagePipe;
using NUnit.Framework;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.TestTools;
using VContainer;

public class VContainerTest
{
    [Test]
    public void SimpelePush()
    {
        var resolver = TestHelper.BuildVContainer((options, builder) =>
        {
#if !UNITY_2022_1_OR_NEWER            
            builder.RegisterMessageBroker<int>(options);
#endif
        });            

        var pub = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();
        var sub2 = resolver.Resolve<ISubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(x => list.Add(x));
        var d2 = sub2.Subscribe(x => list.Add(x));

        pub.Publish(10);
        pub.Publish(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        pub.Publish(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    }

    [UnityTest]
    public IEnumerator SimpleAsyncPush() => UniTask.ToCoroutine(async () =>
    {
        var resolver = TestHelper.BuildVContainer((options, builder) =>
        {
#if !UNITY_2022_1_OR_NEWER            
            builder.RegisterMessageBroker<int>(options);
#endif
        });        

        var pub = resolver.Resolve<IAsyncPublisher<int>>();
        var sub1 = resolver.Resolve<IAsyncSubscriber<int>>();
        var sub2 = resolver.Resolve<IAsyncSubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });
        var d2 = sub2.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });

        await pub.PublishAsync(10);
        await pub.PublishAsync(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        await pub.PublishAsync(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    });

    [Test]
    public void WithFilter()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildVContainer(options =>
       {
           options.AddGlobalMessageHandlerFilter<MyFilter<int>>(1200);
       }, (options, builder) =>
       {
#if !UNITY_2022_1_OR_NEWER           
           builder.RegisterMessageBroker<int>(options);
#endif
           
           builder.RegisterMessageHandlerFilter<MyFilter<int>>();
           builder.RegisterInstance(store);
       });

        var pub = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();

        var d1 = sub1.Subscribe(new MyHandler(store), new MyFilter<int>(store) { Order = -10 });

        pub.Publish(9999);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-10",
            "Order:999",
            "Order:1099",
            "Order:1200",
            "Handle:9999",
        });
    }

    [Test]
    public void Request()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildVContainer(options =>
       {
           options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
       }, (options, builder) =>
       {
           builder.RegisterInstance(store);
           builder.RegisterRequestHandler<int, int, MyRequestHandler>(options);
       });

        var handler = resolver.Resolve<IRequestHandler<int, int>>();

        var result = handler.Invoke(1999);
        Assert.AreEqual(result, 19990);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-1799",
            "Order:999",
            "Order:1099",
            "Invoke:1999",
        });
    }

    [Test]
    public void RequestAll()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildVContainer(options =>
       {
           // options.InstanceLifetime = InstanceLifetime.Scoped;
           options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
       }, (options, builder) =>
       {
           builder.RegisterInstance(store);
           builder.RegisterRequestHandler<int, int, MyRequestHandler>(options);
           builder.RegisterRequestHandler<int, int, MyRequestHandler2>(options);
       });

        var handler = resolver.Resolve<IRequestAllHandler<int, int>>();

        var result = handler.InvokeAll(1999);
        CollectionAssert.AreEqual(result, new[] { 19990, 199900 });

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-1799",
            "Order:999",
            "Order:1099",
            "Invoke:1999",
            "Order:-1799",
            "Invoke2:1999",
        });
    }

    [Test]
    public void Buffered()
    {
        var provider = TestHelper.BuildVContainer((options, builder) =>
        {
#if !UNITY_2022_1_OR_NEWER            
            builder.RegisterMessageBroker<IntClass>(options);
#endif
        });        

        var p = provider.Resolve<IBufferedPublisher<IntClass>>();
        var s = provider.Resolve<IBufferedSubscriber<IntClass>>();

        var l = new List<int>();
        using (var d1 = s.Subscribe(x => l.Add(x.Value)))
        {
            Assert.AreEqual(0, l.Count);
        }

        p.Publish(new IntClass { Value = 9999 }); // set initial value

        var d2 = s.Subscribe(x => l.Add(x.Value));

        CollectionAssert.AreEqual(new[] { 9999 }, l);
        p.Publish(new IntClass { Value = 333 });
        CollectionAssert.AreEqual(new[] { 9999, 333 }, l);

        var d3 = s.Subscribe(x => l.Add(x.Value));
        CollectionAssert.AreEqual(new[] { 9999, 333, 333 }, l);
        p.Publish(new IntClass { Value = 11 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11 }, l);
        d3.Dispose();
        p.Publish(new IntClass { Value = 4 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11, 4 }, l);
    }

    public class IntClass
    {
        public int Value { get; set; }
    }
}


================================================
FILE: src/MessagePipe.Unity/Assets/Tests/VContainerTest.cs.meta
================================================
fileFormatVersion: 2
guid: da9954c218cdded45a99d2be734bdc0d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/ZenjectTest.cs
================================================
﻿using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using Zenject;
using MessagePipe;
using Cysharp.Threading.Tasks;
using UnityEngine.TestTools;
using System.Collections;

public class ZenjectTest
{
    [Test]
    public void SimplePush()
    {
        var resolver = TestHelper.BuildZenject((options, builder) =>
        {
            builder.BindMessageBroker<int>(options);
        });

        var pub = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();
        var sub2 = resolver.Resolve<ISubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(x => list.Add(x));
        var d2 = sub2.Subscribe(x => list.Add(x));

        pub.Publish(10);
        pub.Publish(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        pub.Publish(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    }


    [UnityTest]
    public IEnumerator SimpleAsyncPush() => UniTask.ToCoroutine(async () =>
    {
        var resolver = TestHelper.BuildZenject((options, builder) =>
        {
            builder.BindMessageBroker<int>(options);
        });

        var pub = resolver.Resolve<IAsyncPublisher<int>>();
        var sub1 = resolver.Resolve<IAsyncSubscriber<int>>();
        var sub2 = resolver.Resolve<IAsyncSubscriber<int>>();

        var list = new List<int>();
        var d1 = sub1.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });
        var d2 = sub2.Subscribe(async (x, c) => { await UniTask.Yield(); list.Add(x); });

        await pub.PublishAsync(10);
        await pub.PublishAsync(20);
        CollectionAssert.AreEqual(list, new[] { 10, 10, 20, 20 });

        list.Clear();
        d1.Dispose();

        await pub.PublishAsync(99);
        CollectionAssert.AreEqual(list, new[] { 99 });
    });


    [Test]
    public void WithFilter()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildZenject(options =>
       {
           options.AddGlobalMessageHandlerFilter<MyFilter<int>>(1200);
       }, (options, builder) =>
       {
           builder.BindMessageBroker<int>(options);
           builder.BindMessageHandlerFilter<MyFilter<int>>();
           builder.BindInstance(store);
       });

        var pub = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();

        var d1 = sub1.Subscribe(new MyHandler(store), new MyFilter<int>(store) { Order = -10 });

        pub.Publish(9999);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-10",
            "Order:999",
            "Order:1099",
            "Order:1200",
            "Handle:9999",
        });
    }

    [Test]
    public void Request()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildZenject(options =>
       {
           options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
       }, (options, builder) =>
       {
           builder.BindInstance(store);
           builder.BindRequestHandler<int, int, MyRequestHandler>(options);
       });

        var handler = resolver.Resolve<IRequestHandler<int, int>>();

        var result = handler.Invoke(1999);
        Assert.AreEqual(result, 19990);

        CollectionAssert.AreEqual(store.Logs, new[]
        {
            "Order:-1799",
            "Order:999",
            "Order:1099",
            "Invoke:1999",
        });
    }

    [Test]
    public void RequestAll()
    {
        var store = new DataStore();

        var resolver = TestHelper.BuildZenject(options =>
       {
           // options.InstanceLifetime = InstanceLifetime.Scoped;
           options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
       }, (options, builder) =>
       {
           builder.BindInstance(store);
           builder.BindRequestHandler<int, int, MyRequestHandler>(options);
           builder.BindRequestHandler<int, int, MyRequestHandler2>(options);
       });

        var handler = resolver.Resolve<IRequestAllHandler<int, int>>();

        var result = handler.InvokeAll(1999);
        CollectionAssert.AreEqual(new[] { 19990, 199900 }, result);

        CollectionAssert.AreEqual(new[]
        {
            "Order:-1799",
            "Order:999",
            "Order:1099",
            "Invoke:1999",
            "Order:-1799",
            "Invoke2:1999",
        }, store.Logs);
    }

    [Test]
    public void Buffered()
    {
        var provider = TestHelper.BuildZenject((options, builder) =>
        {
            builder.BindMessageBroker<IntClass>(options);
        });

        var p = provider.Resolve<IBufferedPublisher<IntClass>>();
        var s = provider.Resolve<IBufferedSubscriber<IntClass>>();

        var l = new List<int>();
        using (var d1 = s.Subscribe(x => l.Add(x.Value)))
        {
            Assert.AreEqual(0, l.Count);
        }

        p.Publish(new IntClass { Value = 9999 }); // set initial value

        var d2 = s.Subscribe(x => l.Add(x.Value));

        CollectionAssert.AreEqual(new[] { 9999 }, l);
        p.Publish(new IntClass { Value = 333 });
        CollectionAssert.AreEqual(new[] { 9999, 333 }, l);

        var d3 = s.Subscribe(x => l.Add(x.Value));
        CollectionAssert.AreEqual(new[] { 9999, 333, 333 }, l);
        p.Publish(new IntClass { Value = 11 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11 }, l);
        d3.Dispose();
        p.Publish(new IntClass { Value = 4 });
        CollectionAssert.AreEqual(new[] { 9999, 333, 333, 11, 11, 4 }, l);
    }

    [Test]
    public void InstanceLifetimeSingleToScopedInBindMessagePipe()
    {
        var builder = new DiContainer();
        var option = builder.BindMessagePipe(configure =>
        {
            configure.InstanceLifetime = InstanceLifetime.Singleton;
            configure.RequestHandlerLifetime = InstanceLifetime.Singleton;
        });

        Assert.AreEqual(InstanceLifetime.Scoped, option.InstanceLifetime);
        Assert.AreEqual(InstanceLifetime.Scoped, option.RequestHandlerLifetime);
    }

    [Test]
    public void InstanceLifetimeScopedToScopedInBindMessagePipe()
    {
        var builder = new DiContainer();
        var option = builder.BindMessagePipe(configure =>
        {
            configure.InstanceLifetime = InstanceLifetime.Scoped;
            configure.RequestHandlerLifetime = InstanceLifetime.Scoped;
        });

        Assert.AreEqual(InstanceLifetime.Scoped, option.InstanceLifetime);
        Assert.AreEqual(InstanceLifetime.Scoped, option.RequestHandlerLifetime);
    }

    [Test]
    public void InstanceLifetimeTransientToTransientInBindMessagePipe()
    {
        var builder = new DiContainer();
        var option = builder.BindMessagePipe(configure =>
        {
            configure.InstanceLifetime = InstanceLifetime.Transient;
            configure.RequestHandlerLifetime = InstanceLifetime.Transient;
        });

        Assert.AreEqual(InstanceLifetime.Transient, option.InstanceLifetime);
        Assert.AreEqual(InstanceLifetime.Transient, option.RequestHandlerLifetime);
    }

    [Test]
    public void BindMessageBrokerWithLifetimeScoped()
    {
        var resolver = TestHelper.BuildZenject((options, builder) =>
        {
            options.InstanceLifetime = InstanceLifetime.Scoped;
            builder.BindMessageBroker<int>(options);
        });

        var pub1 = resolver.Resolve<IPublisher<int>>();
        var pub2 = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();
        var sub2 = resolver.Resolve<ISubscriber<int>>();

        Assert.AreEqual(pub1, pub2);
        Assert.AreEqual(sub1, sub2);
    }

    [Test]
    public void BindMessageBrokerWithLifetimeTransient()
    {
        var resolver = TestHelper.BuildZenject((options, builder) =>
        {
            options.InstanceLifetime = InstanceLifetime.Transient;
            builder.BindMessageBroker<int>(options);
        });

        var pub1 = resolver.Resolve<IPublisher<int>>();
        var pub2 = resolver.Resolve<IPublisher<int>>();
        var sub1 = resolver.Resolve<ISubscriber<int>>();
        var sub2 = resolver.Resolve<ISubscriber<int>>();

        Assert.AreNotEqual(pub1, pub2);
        Assert.AreNotEqual(sub1, sub2);
    }

    public class IntClass
    {
        public int Value { get; set; }
    }
}



================================================
FILE: src/MessagePipe.Unity/Assets/Tests/ZenjectTest.cs.meta
================================================
fileFormatVersion: 2
guid: 3f2091436686f9d47be8fe20a270193a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MessagePipe.Unity/Packages/manifest.json
================================================
{
  "dependencies": {
    "com.cysharp.runtimeunittesttoolkit": "https://github.com/Cysharp/RuntimeUnitTestToolkit.git?path=RuntimeUnitTestToolkit/Assets/RuntimeUnitTestToolkit#2.6.0",
    "com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask",
    "jp.hadashikick.vcontainer": "https://github.com/hadashiA/VContainer.git?path=VContainer/Assets/VContainer#1.15.2",
    "com.unity.ide.rider": "3.0.31",
    "com.unity.ide.visualstudio": "2.0.22",
    "com.unity.ide.vscode": "1.2.5",
    "com.unity.test-framework": "1.1.33",
    "com.unity.toolchain.win-x86_64-linux-x86_64": "2.0.9",
    "com.unity.ugui": "1.0.0"
  }
}



================================================
FILE: src/MessagePipe.Unity/Packages/packages-lock.json
================================================
{
  "dependencies": {
    "com.cysharp.runtimeunittesttoolkit": {
      "version": "https://github.com/Cysharp/RuntimeUnitTestToolkit.git?path=RuntimeUnitTestToolkit/Assets/RuntimeUnitTestToolkit#2.6.0",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "4e3dbfaa9c40b5cfdcb71a1d4e8bca0d45ca1055"
    },
    "com.cysharp.unitask": {
      "version": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "958a8e11ab88d5eea69aea65397f8dbe74ef03ff"
    },
    "com.unity.ext.nunit": {
      "version": "1.0.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.rider": {
      "version": "3.0.31",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.visualstudio": {
      "version": "2.0.22",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.test-framework": "1.1.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.vscode": {
      "version": "1.2.5",
      "depth": 0,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.sysroot": {
      "version": "2.0.10",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.sysroot.linux-x86_64": {
      "version": "2.0.9",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.sysroot": "2.0.10"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.test-framework": {
      "version": "1.1.33",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.toolchain.win-x86_64-linux-x86_64": {
      "version": "2.0.9",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.sysroot": "2.0.10",
        "com.unity.sysroot.linux-x86_64": "2.0.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ugui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0"
      }
    },
    "jp.hadashikick.vcontainer": {
      "version": "https://github.com/hadashiA/VContainer.git?path=VContainer/Assets/VContainer#1.15.2",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "634d03aa8349e5698be39d487e2ef0f9d5c881d9"
    },
    "com.unity.modules.imgui": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.jsonserialize": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.ui": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    }
  }
}



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/AudioManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!11 &1
AudioManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Volume: 1
  Rolloff Scale: 1
  Doppler Factor: 1
  Default Speaker Mode: 2
  m_SampleRate: 0
  m_DSPBufferSize: 1024
  m_VirtualVoiceCount: 512
  m_RealVoiceCount: 32
  m_SpatializerPlugin: 
  m_AmbisonicDecoderPlugin: 
  m_DisableAudio: 0
  m_VirtualizeEffects: 1
  m_RequestedDSPBufferSize: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/ClusterInputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!236 &1
ClusterInputManager:
  m_ObjectHideFlags: 0
  m_Inputs: []



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/CsprojModifierSettings.json
================================================
{"AdditionalImports":[],"AdditionalImportsAdditionalProjects":[],"EnableAddAnalyzerReferences":true,"AddAnalyzerReferencesAdditionalProjects":[]}


================================================
FILE: src/MessagePipe.Unity/ProjectSettings/DynamicsManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!55 &1
PhysicsManager:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Gravity: {x: 0, y: -9.81, z: 0}
  m_DefaultMaterial: {fileID: 0}
  m_BounceThreshold: 2
  m_SleepThreshold: 0.005
  m_DefaultContactOffset: 0.01
  m_DefaultSolverIterations: 6
  m_DefaultSolverVelocityIterations: 1
  m_QueriesHitBackfaces: 0
  m_QueriesHitTriggers: 1
  m_EnableAdaptiveForce: 0
  m_ClothInterCollisionDistance: 0.1
  m_ClothInterCollisionStiffness: 0.2
  m_ContactsGeneration: 1
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  m_AutoSimulation: 1
  m_AutoSyncTransforms: 0
  m_ReuseCollisionCallbacks: 1
  m_ClothInterCollisionSettingsToggle: 0
  m_ClothGravity: {x: 0, y: -9.81, z: 0}
  m_ContactPairsMode: 0
  m_BroadphaseType: 0
  m_WorldBounds:
    m_Center: {x: 0, y: 0, z: 0}
    m_Extent: {x: 250, y: 250, z: 250}
  m_WorldSubdivisions: 8
  m_FrictionType: 0
  m_EnableEnhancedDeterminism: 0
  m_EnableUnifiedHeightmaps: 1
  m_SolverType: 0
  m_DefaultMaxAngularSpeed: 50



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/EditorBuildSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1045 &1
EditorBuildSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Scenes:
  - enabled: 1
    path: Assets/Scenes/SampleScene.unity
    guid: 2cda990e2423bbf4892e6590ba056729
  m_configObjects: {}



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/EditorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!159 &1
EditorSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 10
  m_ExternalVersionControlSupport: Visible Meta Files
  m_SerializationMode: 2
  m_LineEndingsForNewScripts: 0
  m_DefaultBehaviorMode: 1
  m_PrefabRegularEnvironment: {fileID: 0}
  m_PrefabUIEnvironment: {fileID: 0}
  m_SpritePackerMode: 4
  m_SpritePackerPaddingPower: 1
  m_EtcTextureCompressorBehavior: 1
  m_EtcTextureFastCompressor: 1
  m_EtcTextureNormalCompressor: 2
  m_EtcTextureBestCompressor: 4
  m_ProjectGenerationIncludedExtensions: txt;xml;fnt;cd;asmdef;asmref;rsp
  m_ProjectGenerationRootNamespace: 
  m_CollabEditorSettings:
    inProgressEnabled: 1
  m_EnableTextureStreamingInEditMode: 1
  m_EnableTextureStreamingInPlayMode: 1
  m_AsyncShaderCompilation: 1
  m_EnterPlayModeOptionsEnabled: 0
  m_EnterPlayModeOptions: 3
  m_ShowLightmapResolutionOverlay: 1
  m_UseLegacyProbeSampleCount: 0
  m_SerializeInlineMappingsOnOneLine: 1
  m_AssetPipelineMode: 1
  m_CacheServerMode: 0
  m_CacheServerEndpoint: 
  m_CacheServerNamespacePrefix: default
  m_CacheServerEnableDownload: 1
  m_CacheServerEnableUpload: 1



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/GraphicsSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!30 &1
GraphicsSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Deferred:
    m_Mode: 1
    m_Shader: {fileID: 69, guid: 0000000000000000f000000000000000, type: 0}
  m_DeferredReflections:
    m_Mode: 1
    m_Shader: {fileID: 74, guid: 0000000000000000f000000000000000, type: 0}
  m_ScreenSpaceShadows:
    m_Mode: 1
    m_Shader: {fileID: 64, guid: 0000000000000000f000000000000000, type: 0}
  m_LegacyDeferred:
    m_Mode: 1
    m_Shader: {fileID: 63, guid: 0000000000000000f000000000000000, type: 0}
  m_DepthNormals:
    m_Mode: 1
    m_Shader: {fileID: 62, guid: 0000000000000000f000000000000000, type: 0}
  m_MotionVectors:
    m_Mode: 1
    m_Shader: {fileID: 75, guid: 0000000000000000f000000000000000, type: 0}
  m_LightHalo:
    m_Mode: 1
    m_Shader: {fileID: 105, guid: 0000000000000000f000000000000000, type: 0}
  m_LensFlare:
    m_Mode: 1
    m_Shader: {fileID: 102, guid: 0000000000000000f000000000000000, type: 0}
  m_AlwaysIncludedShaders:
  - {fileID: 7, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15104, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15105, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15106, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10753, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10770, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10783, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 16000, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 16001, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 17000, guid: 0000000000000000f000000000000000, type: 0}
  m_PreloadedShaders: []
  m_SpritesDefaultMaterial: {fileID: 10754, guid: 0000000000000000f000000000000000,
    type: 0}
  m_CustomRenderPipeline: {fileID: 0}
  m_TransparencySortMode: 0
  m_TransparencySortAxis: {x: 0, y: 0, z: 1}
  m_DefaultRenderingPath: 1
  m_DefaultMobileRenderingPath: 1
  m_TierSettings: []
  m_LightmapStripping: 0
  m_FogStripping: 0
  m_InstancingStripping: 0
  m_LightmapKeepPlain: 1
  m_LightmapKeepDirCombined: 1
  m_LightmapKeepDynamicPlain: 1
  m_LightmapKeepDynamicDirCombined: 1
  m_LightmapKeepShadowMask: 1
  m_LightmapKeepSubtractive: 1
  m_FogKeepLinear: 1
  m_FogKeepExp: 1
  m_FogKeepExp2: 1
  m_AlbedoSwatchInfos: []
  m_LightsUseLinearIntensity: 0
  m_LightsUseColorTemperature: 0
  m_LogWhenShaderIsCompiled: 0
  m_AllowEnlightenSupportForUpgradedProject: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/InputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!13 &1
InputManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Axes:
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: a
    altPositiveButton: d
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: s
    altPositiveButton: w
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: mouse 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: mouse 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: mouse 2
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: space
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse X
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse Y
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse ScrollWheel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 2
    joyNum: 0
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 0
    type: 2
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 1
    type: 2
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 0
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 1
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 2
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 3
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: enter
    altNegativeButton: 
    altPositiveButton: space
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Cancel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: escape
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: joystick button 8
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: backspace
    altNegativeButton: 
    altPositiveButton: joystick button 9
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Reset
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Next
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page down
    altNegativeButton: 
    altPositiveButton: joystick button 5
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Previous
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page up
    altNegativeButton: 
    altPositiveButton: joystick button 4
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Validate
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Persistent
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: right shift
    altNegativeButton: 
    altPositiveButton: joystick button 2
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Multiplier
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: joystick button 3
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 6
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 5
    joyNum: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/MemorySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!387306366 &1
MemorySettings:
  m_ObjectHideFlags: 0
  m_EditorMemorySettings:
    m_MainAllocatorBlockSize: -1
    m_ThreadAllocatorBlockSize: -1
    m_MainGfxBlockSize: -1
    m_ThreadGfxBlockSize: -1
    m_CacheBlockSize: -1
    m_TypetreeBlockSize: -1
    m_ProfilerBlockSize: -1
    m_ProfilerEditorBlockSize: -1
    m_BucketAllocatorGranularity: -1
    m_BucketAllocatorBucketsCount: -1
    m_BucketAllocatorBlockSize: -1
    m_BucketAllocatorBlockCount: -1
    m_ProfilerBucketAllocatorGranularity: -1
    m_ProfilerBucketAllocatorBucketsCount: -1
    m_ProfilerBucketAllocatorBlockSize: -1
    m_ProfilerBucketAllocatorBlockCount: -1
    m_TempAllocatorSizeMain: -1
    m_JobTempAllocatorBlockSize: -1
    m_BackgroundJobTempAllocatorBlockSize: -1
    m_JobTempAllocatorReducedBlockSize: -1
    m_TempAllocatorSizeGIBakingWorker: -1
    m_TempAllocatorSizeNavMeshWorker: -1
    m_TempAllocatorSizeAudioWorker: -1
    m_TempAllocatorSizeCloudWorker: -1
    m_TempAllocatorSizeGfx: -1
    m_TempAllocatorSizeJobWorker: -1
    m_TempAllocatorSizeBackgroundWorker: -1
    m_TempAllocatorSizePreloadManager: -1
  m_PlatformMemorySettings: {}



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/NavMeshAreas.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!126 &1
NavMeshProjectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  areas:
  - name: Walkable
    cost: 1
  - name: Not Walkable
    cost: 1
  - name: Jump
    cost: 2
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  m_LastAgentTypeID: -887442657
  m_Settings:
  - serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.75
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_SettingNames:
  - Humanoid



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/NetworkManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!149 &1
NetworkManager:
  m_ObjectHideFlags: 0
  m_DebugLevel: 0
  m_Sendrate: 15
  m_AssetToPrefab: {}



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/PackageManagerSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 61
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 13964, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_EnablePreviewPackages: 0
  m_EnablePackageDependencies: 0
  m_AdvancedSettingsExpanded: 1
  m_ScopedRegistriesSettingsExpanded: 1
  oneTimeWarningShown: 0
  m_Registries:
  - m_Id: main
    m_Name: 
    m_Url: https://packages.unity.com
    m_Scopes: []
    m_IsDefault: 1
    m_Capabilities: 7
  m_UserSelectedRegistryName: 
  m_UserAddingNewScopedRegistry: 0
  m_RegistryInfoDraft:
    m_ErrorMessage: 
    m_Original:
      m_Id: 
      m_Name: 
      m_Url: 
      m_Scopes: []
      m_IsDefault: 0
      m_Capabilities: 0
    m_Modified: 0
    m_Name: 
    m_Url: 
    m_Scopes:
    - 
    m_SelectedScopeIndex: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/Physics2DSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!19 &1
Physics2DSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_Gravity: {x: 0, y: -9.81}
  m_DefaultMaterial: {fileID: 0}
  m_VelocityIterations: 8
  m_PositionIterations: 3
  m_VelocityThreshold: 1
  m_MaxLinearCorrection: 0.2
  m_MaxAngularCorrection: 8
  m_MaxTranslationSpeed: 100
  m_MaxRotationSpeed: 360
  m_BaumgarteScale: 0.2
  m_BaumgarteTimeOfImpactScale: 0.75
  m_TimeToSleep: 0.5
  m_LinearSleepTolerance: 0.01
  m_AngularSleepTolerance: 2
  m_DefaultContactOffset: 0.01
  m_JobOptions:
    serializedVersion: 2
    useMultithreading: 0
    useConsistencySorting: 0
    m_InterpolationPosesPerJob: 100
    m_NewContactsPerJob: 30
    m_CollideContactsPerJob: 100
    m_ClearFlagsPerJob: 200
    m_ClearBodyForcesPerJob: 200
    m_SyncDiscreteFixturesPerJob: 50
    m_SyncContinuousFixturesPerJob: 50
    m_FindNearestContactsPerJob: 100
    m_UpdateTriggerContactsPerJob: 100
    m_IslandSolverCostThreshold: 100
    m_IslandSolverBodyCostScale: 1
    m_IslandSolverContactCostScale: 10
    m_IslandSolverJointCostScale: 10
    m_IslandSolverBodiesPerJob: 50
    m_IslandSolverContactsPerJob: 50
  m_SimulationMode: 0
  m_QueriesHitTriggers: 1
  m_QueriesStartInColliders: 1
  m_CallbacksOnDisable: 1
  m_ReuseCollisionCallbacks: 1
  m_AutoSyncTransforms: 0
  m_AlwaysShowColliders: 0
  m_ShowColliderSleep: 1
  m_ShowColliderContacts: 0
  m_ShowColliderAABB: 0
  m_ContactArrowScale: 0.2
  m_ColliderAwakeColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.7529412}
  m_ColliderAsleepColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.36078432}
  m_ColliderContactColor: {r: 1, g: 0, b: 1, a: 0.6862745}
  m_ColliderAABBColor: {r: 1, g: 1, b: 0, a: 0.2509804}
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/PresetManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1386491679 &1
PresetManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_DefaultPresets: {}



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/ProjectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 26
  productGUID: 3f352abc33d40d44180b87a21e157ce3
  AndroidProfiler: 0
  AndroidFilterTouchesWhenObscured: 0
  AndroidEnableSustainedPerformanceMode: 0
  defaultScreenOrientation: 4
  targetDevice: 2
  useOnDemandResources: 0
  accelerometerFrequency: 60
  companyName: DefaultCompany
  productName: MessagePipe
  defaultCursor: {fileID: 0}
  cursorHotspot: {x: 0, y: 0}
  m_SplashScreenBackgroundColor: {r: 0.13725491, g: 0.12156863, b: 0.1254902, a: 1}
  m_ShowUnitySplashScreen: 1
  m_ShowUnitySplashLogo: 1
  m_SplashScreenOverlayOpacity: 1
  m_SplashScreenAnimation: 1
  m_SplashScreenLogoStyle: 1
  m_SplashScreenDrawMode: 0
  m_SplashScreenBackgroundAnimationZoom: 1
  m_SplashScreenLogoAnimationZoom: 1
  m_SplashScreenBackgroundLandscapeAspect: 1
  m_SplashScreenBackgroundPortraitAspect: 1
  m_SplashScreenBackgroundLandscapeUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenBackgroundPortraitUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenLogos: []
  m_VirtualRealitySplashScreen: {fileID: 0}
  m_HolographicTrackingLossScreen: {fileID: 0}
  defaultScreenWidth: 1920
  defaultScreenHeight: 1080
  defaultScreenWidthWeb: 960
  defaultScreenHeightWeb: 600
  m_StereoRenderingPath: 0
  m_ActiveColorSpace: 0
  unsupportedMSAAFallback: 0
  m_SpriteBatchVertexThreshold: 300
  m_MTRendering: 1
  mipStripping: 0
  numberOfMipsStripped: 0
  numberOfMipsStrippedPerMipmapLimitGroup: {}
  m_StackTraceTypes: 010000000100000001000000010000000100000001000000
  iosShowActivityIndicatorOnLoading: -1
  androidShowActivityIndicatorOnLoading: -1
  iosUseCustomAppBackgroundBehavior: 0
  allowedAutorotateToPortrait: 1
  allowedAutorotateToPortraitUpsideDown: 1
  allowedAutorotateToLandscapeRight: 1
  allowedAutorotateToLandscapeLeft: 1
  useOSAutorotation: 1
  use32BitDisplayBuffer: 1
  preserveFramebufferAlpha: 0
  disableDepthAndStencilBuffers: 0
  androidStartInFullscreen: 1
  androidRenderOutsideSafeArea: 1
  androidUseSwappy: 1
  androidBlitType: 0
  androidResizableWindow: 0
  androidDefaultWindowWidth: 1920
  androidDefaultWindowHeight: 1080
  androidMinimumWindowWidth: 400
  androidMinimumWindowHeight: 300
  androidFullscreenMode: 1
  androidAutoRotationBehavior: 1
  defaultIsNativeResolution: 1
  macRetinaSupport: 1
  runInBackground: 1
  captureSingleScreen: 0
  muteOtherAudioSources: 0
  Prepare IOS For Recording: 0
  Force IOS Speakers When Recording: 0
  deferSystemGesturesMode: 0
  hideHomeButton: 0
  submitAnalytics: 1
  usePlayerLog: 1
  dedicatedServerOptimizations: 0
  bakeCollisionMeshes: 0
  forceSingleInstance: 0
  useFlipModelSwapchain: 1
  resizableWindow: 0
  useMacAppStoreValidation: 0
  macAppStoreCategory: public.app-category.games
  gpuSkinning: 0
  xboxPIXTextureCapture: 0
  xboxEnableAvatar: 0
  xboxEnableKinect: 0
  xboxEnableKinectAutoTracking: 0
  xboxEnableFitness: 0
  visibleInBackground: 1
  allowFullscreenSwitch: 1
  fullscreenMode: 1
  xboxSpeechDB: 0
  xboxEnableHeadOrientation: 0
  xboxEnableGuest: 0
  xboxEnablePIXSampling: 0
  metalFramebufferOnly: 0
  xboxOneResolution: 0
  xboxOneSResolution: 0
  xboxOneXResolution: 3
  xboxOneMonoLoggingLevel: 0
  xboxOneLoggingLevel: 1
  xboxOneDisableEsram: 0
  xboxOneEnableTypeOptimization: 0
  xboxOnePresentImmediateThreshold: 0
  switchQueueCommandMemory: 1048576
  switchQueueControlMemory: 16384
  switchQueueComputeMemory: 262144
  switchNVNShaderPoolsGranularity: 33554432
  switchNVNDefaultPoolsGranularity: 16777216
  switchNVNOtherPoolsGranularity: 16777216
  switchGpuScratchPoolGranularity: 2097152
  switchAllowGpuScratchShrinking: 0
  switchNVNMaxPublicTextureIDCount: 0
  switchNVNMaxPublicSamplerIDCount: 0
  switchNVNGraphicsFirmwareMemory: 32
  switchMaxWorkerMultiple: 8
  stadiaPresentMode: 0
  stadiaTargetFramerate: 0
  vulkanNumSwapchainBuffers: 3
  vulkanEnableSetSRGBWrite: 0
  vulkanEnablePreTransform: 0
  vulkanEnableLateAcquireNextImage: 0
  vulkanEnableCommandBufferRecycling: 1
  loadStoreDebugModeEnabled: 0
  visionOSBundleVersion: 1.0
  tvOSBundleVersion: 1.0
  bundleVersion: 1.0
  preloadedAssets: []
  metroInputSource: 0
  wsaTransparentSwapchain: 0
  m_HolographicPauseOnTrackingLoss: 1
  xboxOneDisableKinectGpuReservation: 1
  xboxOneEnable7thCore: 1
  vrSettings:
    enable360StereoCapture: 0
  isWsaHolographicRemotingEnabled: 0
  enableFrameTimingStats: 0
  enableOpenGLProfilerGPURecorders: 1
  allowHDRDisplaySupport: 0
  useHDRDisplay: 0
  hdrBitDepth: 0
  m_ColorGamuts: 00000000
  targetPixelDensity: 30
  resolutionScalingMode: 0
  resetResolutionOnWindowResize: 0
  androidSupportedAspectRatio: 1
  androidMaxAspectRatio: 2.1
  applicationIdentifier:
    Standalone: com.DefaultCompany.MessagePipe
  buildNumber:
    Standalone: 0
    VisionOS: 0
    iPhone: 0
    tvOS: 0
  overrideDefaultApplicationIdentifier: 0
  AndroidBundleVersionCode: 1
  AndroidMinSdkVersion: 22
  AndroidTargetSdkVersion: 0
  AndroidPreferredInstallLocation: 1
  aotOptions: 
  stripEngineCode: 1
  iPhoneStrippingLevel: 0
  iPhoneScriptCallOptimization: 0
  ForceInternetPermission: 0
  ForceSDCardPermission: 0
  CreateWallpaper: 0
  APKExpansionFiles: 0
  keepLoadedShadersAlive: 0
  StripUnusedMeshComponents: 0
  strictShaderVariantMatching: 0
  VertexChannelCompressionMask: 4054
  iPhoneSdkVersion: 988
  iOSTargetOSVersionString: 12.0
  tvOSSdkVersion: 0
  tvOSRequireExtendedGameController: 0
  tvOSTargetOSVersionString: 12.0
  VisionOSSdkVersion: 0
  VisionOSTargetOSVersionString: 1.0
  uIPrerenderedIcon: 0
  uIRequiresPersistentWiFi: 0
  uIRequiresFullScreen: 1
  uIStatusBarHidden: 1
  uIExitOnSuspend: 0
  uIStatusBarStyle: 0
  appleTVSplashScreen: {fileID: 0}
  appleTVSplashScreen2x: {fileID: 0}
  tvOSSmallIconLayers: []
  tvOSSmallIconLayers2x: []
  tvOSLargeIconLayers: []
  tvOSLargeIconLayers2x: []
  tvOSTopShelfImageLayers: []
  tvOSTopShelfImageLayers2x: []
  tvOSTopShelfImageWideLayers: []
  tvOSTopShelfImageWideLayers2x: []
  iOSLaunchScreenType: 0
  iOSLaunchScreenPortrait: {fileID: 0}
  iOSLaunchScreenLandscape: {fileID: 0}
  iOSLaunchScreenBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreenFillPct: 100
  iOSLaunchScreenSize: 100
  iOSLaunchScreenCustomXibPath: 
  iOSLaunchScreeniPadType: 0
  iOSLaunchScreeniPadImage: {fileID: 0}
  iOSLaunchScreeniPadBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreeniPadFillPct: 100
  iOSLaunchScreeniPadSize: 100
  iOSLaunchScreeniPadCustomXibPath: 
  iOSLaunchScreenCustomStoryboardPath: 
  iOSLaunchScreeniPadCustomStoryboardPath: 
  iOSDeviceRequirements: []
  iOSURLSchemes: []
  macOSURLSchemes: []
  iOSBackgroundModes: 0
  iOSMetalForceHardShadows: 0
  metalEditorSupport: 1
  metalAPIValidation: 1
  metalCompileShaderBinary: 0
  iOSRenderExtraFrameOnPause: 0
  iosCopyPluginsCodeInsteadOfSymlink: 0
  appleDeveloperTeamID: 
  iOSManualSigningProvisioningProfileID: 
  tvOSManualSigningProvisioningProfileID: 
  VisionOSManualSigningProvisioningProfileID: 
  iOSManualSigningProvisioningProfileType: 0
  tvOSManualSigningProvisioningProfileType: 0
  VisionOSManualSigningProvisioningProfileType: 0
  appleEnableAutomaticSigning: 0
  iOSRequireARKit: 0
  iOSAutomaticallyDetectAndAddCapabilities: 1
  appleEnableProMotion: 0
  shaderPrecisionModel: 0
  clonedFromGUID: 10ad67313f4034357812315f3c407484
  templatePackageId: com.unity.template.2d@5.0.0
  templateDefaultScene: Assets/Scenes/SampleScene.unity
  useCustomMainManifest: 0
  useCustomLauncherManifest: 0
  useCustomMainGradleTemplate: 0
  useCustomLauncherGradleManifest: 0
  useCustomBaseGradleTemplate: 0
  useCustomGradlePropertiesTemplate: 0
  useCustomGradleSettingsTemplate: 0
  useCustomProguardFile: 0
  AndroidTargetArchitectures: 1
  AndroidTargetDevices: 0
  AndroidSplashScreenScale: 0
  androidSplashScreen: {fileID: 0}
  AndroidKeystoreName: 
  AndroidKeyaliasName: 
  AndroidEnableArmv9SecurityFeatures: 0
  AndroidBuildApkPerCpuArchitecture: 0
  AndroidTVCompatibility: 0
  AndroidIsGame: 1
  AndroidEnableTango: 0
  androidEnableBanner: 1
  androidUseLowAccuracyLocation: 0
  androidUseCustomKeystore: 0
  m_AndroidBanners:
  - width: 320
    height: 180
    banner: {fileID: 0}
  androidGamepadSupportLevel: 0
  chromeosInputEmulation: 1
  AndroidMinifyRelease: 0
  AndroidMinifyDebug: 0
  AndroidValidateAppBundleSize: 1
  AndroidAppBundleSizeToValidate: 150
  m_BuildTargetIcons: []
  m_BuildTargetPlatformIcons: []
  m_BuildTargetBatching: []
  m_BuildTargetShaderSettings: []
  m_BuildTargetGraphicsJobs:
  - m_BuildTarget: MacStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: Switch
    m_GraphicsJobs: 0
  - m_BuildTarget: MetroSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AppleTVSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: BJMSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: LinuxStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: PS4Player
    m_GraphicsJobs: 0
  - m_BuildTarget: iOSSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: WindowsStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: XboxOnePlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: LuminSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AndroidPlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: WebGLSupport
    m_GraphicsJobs: 0
  m_BuildTargetGraphicsJobMode: []
  m_BuildTargetGraphicsAPIs:
  - m_BuildTarget: AndroidPlayer
    m_APIs: 150000000b000000
    m_Automatic: 1
  - m_BuildTarget: iOSSupport
    m_APIs: 10000000
    m_Automatic: 1
  m_BuildTargetVRSettings: []
  m_DefaultShaderChunkSizeInMB: 16
  m_DefaultShaderChunkCount: 0
  openGLRequireES31: 0
  openGLRequireES31AEP: 0
  openGLRequireES32: 0
  m_TemplateCustomTags: {}
  mobileMTRendering:
    Android: 1
    iPhone: 1
    tvOS: 1
  m_BuildTargetGroupLightmapEncodingQuality: []
  m_BuildTargetGroupHDRCubemapEncodingQuality: []
  m_BuildTargetGroupLightmapSettings: []
  m_BuildTargetGroupLoadStoreDebugModeSettings: []
  m_BuildTargetNormalMapEncoding: []
  m_BuildTargetDefaultTextureCompressionFormat: []
  playModeTestRunnerEnabled: 0
  runPlayModeTestAsEditModeTest: 0
  actionOnDotNetUnhandledException: 1
  enableInternalProfiler: 0
  logObjCUncaughtExceptions: 1
  enableCrashReportAPI: 0
  cameraUsageDescription: 
  locationUsageDescription: 
  microphoneUsageDescription: 
  bluetoothUsageDescription: 
  macOSTargetOSVersion: 10.13.0
  switchNMETAOverride: 
  switchNetLibKey: 
  switchSocketMemoryPoolSize: 6144
  switchSocketAllocatorPoolSize: 128
  switchSocketConcurrencyLimit: 14
  switchScreenResolutionBehavior: 2
  switchUseCPUProfiler: 0
  switchEnableFileSystemTrace: 0
  switchLTOSetting: 0
  switchApplicationID: 0x01004b9000490000
  switchNSODependencies: 
  switchCompilerFlags: 
  switchTitleNames_0: 
  switchTitleNames_1: 
  switchTitleNames_2: 
  switchTitleNames_3: 
  switchTitleNames_4: 
  switchTitleNames_5: 
  switchTitleNames_6: 
  switchTitleNames_7: 
  switchTitleNames_8: 
  switchTitleNames_9: 
  switchTitleNames_10: 
  switchTitleNames_11: 
  switchTitleNames_12: 
  switchTitleNames_13: 
  switchTitleNames_14: 
  switchTitleNames_15: 
  switchPublisherNames_0: 
  switchPublisherNames_1: 
  switchPublisherNames_2: 
  switchPublisherNames_3: 
  switchPublisherNames_4: 
  switchPublisherNames_5: 
  switchPublisherNames_6: 
  switchPublisherNames_7: 
  switchPublisherNames_8: 
  switchPublisherNames_9: 
  switchPublisherNames_10: 
  switchPublisherNames_11: 
  switchPublisherNames_12: 
  switchPublisherNames_13: 
  switchPublisherNames_14: 
  switchPublisherNames_15: 
  switchIcons_0: {fileID: 0}
  switchIcons_1: {fileID: 0}
  switchIcons_2: {fileID: 0}
  switchIcons_3: {fileID: 0}
  switchIcons_4: {fileID: 0}
  switchIcons_5: {fileID: 0}
  switchIcons_6: {fileID: 0}
  switchIcons_7: {fileID: 0}
  switchIcons_8: {fileID: 0}
  switchIcons_9: {fileID: 0}
  switchIcons_10: {fileID: 0}
  switchIcons_11: {fileID: 0}
  switchIcons_12: {fileID: 0}
  switchIcons_13: {fileID: 0}
  switchIcons_14: {fileID: 0}
  switchIcons_15: {fileID: 0}
  switchSmallIcons_0: {fileID: 0}
  switchSmallIcons_1: {fileID: 0}
  switchSmallIcons_2: {fileID: 0}
  switchSmallIcons_3: {fileID: 0}
  switchSmallIcons_4: {fileID: 0}
  switchSmallIcons_5: {fileID: 0}
  switchSmallIcons_6: {fileID: 0}
  switchSmallIcons_7: {fileID: 0}
  switchSmallIcons_8: {fileID: 0}
  switchSmallIcons_9: {fileID: 0}
  switchSmallIcons_10: {fileID: 0}
  switchSmallIcons_11: {fileID: 0}
  switchSmallIcons_12: {fileID: 0}
  switchSmallIcons_13: {fileID: 0}
  switchSmallIcons_14: {fileID: 0}
  switchSmallIcons_15: {fileID: 0}
  switchManualHTML: 
  switchAccessibleURLs: 
  switchLegalInformation: 
  switchMainThreadStackSize: 1048576
  switchPresenceGroupId: 
  switchLogoHandling: 0
  switchReleaseVersion: 0
  switchDisplayVersion: 1.0.0
  switchStartupUserAccount: 0
  switchSupportedLanguagesMask: 0
  switchLogoType: 0
  switchApplicationErrorCodeCategory: 
  switchUserAccountSaveDataSize: 0
  switchUserAccountSaveDataJournalSize: 0
  switchApplicationAttribute: 0
  switchCardSpecSize: -1
  switchCardSpecClock: -1
  switchRatingsMask: 0
  switchRatingsInt_0: 0
  switchRatingsInt_1: 0
  switchRatingsInt_2: 0
  switchRatingsInt_3: 0
  switchRatingsInt_4: 0
  switchRatingsInt_5: 0
  switchRatingsInt_6: 0
  switchRatingsInt_7: 0
  switchRatingsInt_8: 0
  switchRatingsInt_9: 0
  switchRatingsInt_10: 0
  switchRatingsInt_11: 0
  switchRatingsInt_12: 0
  switchLocalCommunicationIds_0: 
  switchLocalCommunicationIds_1: 
  switchLocalCommunicationIds_2: 
  switchLocalCommunicationIds_3: 
  switchLocalCommunicationIds_4: 
  switchLocalCommunicationIds_5: 
  switchLocalCommunicationIds_6: 
  switchLocalCommunicationIds_7: 
  switchParentalControl: 0
  switchAllowsScreenshot: 1
  switchAllowsVideoCapturing: 1
  switchAllowsRuntimeAddOnContentInstall: 0
  switchDataLossConfirmation: 0
  switchUserAccountLockEnabled: 0
  switchSystemResourceMemory: 16777216
  switchSupportedNpadStyles: 22
  switchNativeFsCacheSize: 32
  switchIsHoldTypeHorizontal: 0
  switchSupportedNpadCount: 8
  switchEnableTouchScreen: 1
  switchSocketConfigEnabled: 0
  switchTcpInitialSendBufferSize: 32
  switchTcpInitialReceiveBufferSize: 64
  switchTcpAutoSendBufferSizeMax: 256
  switchTcpAutoReceiveBufferSizeMax: 256
  switchUdpSendBufferSize: 9
  switchUdpReceiveBufferSize: 42
  switchSocketBufferEfficiency: 4
  switchSocketInitializeEnabled: 1
  switchNetworkInterfaceManagerInitializeEnabled: 1
  switchUseNewStyleFilepaths: 1
  switchUseLegacyFmodPriorities: 0
  switchUseMicroSleepForYield: 1
  switchEnableRamDiskSupport: 0
  switchMicroSleepForYieldTime: 25
  switchRamDiskSpaceSize: 12
  ps4NPAgeRating: 12
  ps4NPTitleSecret: 
  ps4NPTrophyPackPath: 
  ps4ParentalLevel: 11
  ps4ContentID: ED1633-NPXX51362_00-0000000000000000
  ps4Category: 0
  ps4MasterVersion: 01.00
  ps4AppVersion: 01.00
  ps4AppType: 0
  ps4ParamSfxPath: 
  ps4VideoOutPixelFormat: 0
  ps4VideoOutInitialWidth: 1920
  ps4VideoOutBaseModeInitialWidth: 1920
  ps4VideoOutReprojectionRate: 60
  ps4PronunciationXMLPath: 
  ps4PronunciationSIGPath: 
  ps4BackgroundImagePath: 
  ps4StartupImagePath: 
  ps4StartupImagesFolder: 
  ps4IconImagesFolder: 
  ps4SaveDataImagePath: 
  ps4SdkOverride: 
  ps4BGMPath: 
  ps4ShareFilePath: 
  ps4ShareOverlayImagePath: 
  ps4PrivacyGuardImagePath: 
  ps4ExtraSceSysFile: 
  ps4NPtitleDatPath: 
  ps4RemotePlayKeyAssignment: -1
  ps4RemotePlayKeyMappingDir: 
  ps4PlayTogetherPlayerCount: 0
  ps4EnterButtonAssignment: 2
  ps4ApplicationParam1: 0
  ps4ApplicationParam2: 0
  ps4ApplicationParam3: 0
  ps4ApplicationParam4: 0
  ps4DownloadDataSize: 0
  ps4GarlicHeapSize: 2048
  ps4ProGarlicHeapSize: 2560
  playerPrefsMaxSize: 32768
  ps4Passcode: bi9UOuSpM2Tlh01vOzwvSikHFswuzleh
  ps4pnSessions: 1
  ps4pnPresence: 1
  ps4pnFriends: 1
  ps4pnGameCustomData: 1
  playerPrefsSupport: 0
  enableApplicationExit: 0
  resetTempFolder: 1
  restrictedAudioUsageRights: 0
  ps4UseResolutionFallback: 0
  ps4ReprojectionSupport: 0
  ps4UseAudio3dBackend: 0
  ps4UseLowGarlicFragmentationMode: 1
  ps4SocialScreenEnabled: 0
  ps4ScriptOptimizationLevel: 2
  ps4Audio3dVirtualSpeakerCount: 14
  ps4attribCpuUsage: 0
  ps4PatchPkgPath: 
  ps4PatchLatestPkgPath: 
  ps4PatchChangeinfoPath: 
  ps4PatchDayOne: 0
  ps4attribUserManagement: 0
  ps4attribMoveSupport: 0
  ps4attrib3DSupport: 0
  ps4attribShareSupport: 0
  ps4attribExclusiveVR: 0
  ps4disableAutoHideSplash: 0
  ps4videoRecordingFeaturesUsed: 0
  ps4contentSearchFeaturesUsed: 0
  ps4CompatibilityPS5: 0
  ps4AllowPS5Detection: 0
  ps4GPU800MHz: 1
  ps4attribEyeToEyeDistanceSettingVR: 0
  ps4IncludedModules: []
  ps4attribVROutputEnabled: 0
  monoEnv: 
  splashScreenBackgroundSourceLandscape: {fileID: 0}
  splashScreenBackgroundSourcePortrait: {fileID: 0}
  blurSplashScreenBackground: 1
  spritePackerPolicy: 
  webGLMemorySize: 32
  webGLExceptionSupport: 1
  webGLNameFilesAsHashes: 0
  webGLShowDiagnostics: 0
  webGLDataCaching: 1
  webGLDebugSymbols: 0
  webGLEmscriptenArgs: 
  webGLModulesDirectory: 
  webGLTemplate: APPLICATION:Default
  webGLAnalyzeBuildSize: 0
  webGLUseEmbeddedResources: 0
  webGLCompressionFormat: 0
  webGLWasmArithmeticExceptions: 0
  webGLLinkerTarget: 1
  webGLThreadsSupport: 0
  webGLDecompressionFallback: 0
  webGLInitialMemorySize: 32
  webGLMaximumMemorySize: 2048
  webGLMemoryGrowthMode: 2
  webGLMemoryLinearGrowthStep: 16
  webGLMemoryGeometricGrowthStep: 0.2
  webGLMemoryGeometricGrowthCap: 96
  webGLPowerPreference: 2
  scriptingDefineSymbols: {}
  additionalCompilerArguments: {}
  platformArchitecture: {}
  scriptingBackend:
    Server: 1
    Standalone: 1
  il2cppCompilerConfiguration: {}
  il2cppCodeGeneration:
    Server: 1
  managedStrippingLevel:
    EmbeddedLinux: 1
    GameCoreScarlett: 1
    GameCoreXboxOne: 1
    Nintendo Switch: 1
    PS4: 1
    PS5: 1
    QNX: 1
    Stadia: 1
    Standalone: 3
    VisionOS: 1
    WebGL: 1
    Windows Store Apps: 1
    XboxOne: 1
    iPhone: 1
    tvOS: 1
  incrementalIl2cppBuild: {}
  suppressCommonWarnings: 1
  allowUnsafeCode: 0
  useDeterministicCompilation: 1
  additionalIl2CppArgs: 
  scriptingRuntimeVersion: 1
  gcIncremental: 1
  gcWBarrierValidation: 0
  apiCompatibilityLevelPerPlatform: {}
  m_RenderingPath: 1
  m_MobileRenderingPath: 1
  metroPackageName: 2D_BuiltInRenderer
  metroPackageVersion: 
  metroCertificatePath: 
  metroCertificatePassword: 
  metroCertificateSubject: 
  metroCertificateIssuer: 
  metroCertificateNotAfter: 0000000000000000
  metroApplicationDescription: 2D_BuiltInRenderer
  wsaImages: {}
  metroTileShortName: 
  metroTileShowName: 0
  metroMediumTileShowName: 0
  metroLargeTileShowName: 0
  metroWideTileShowName: 0
  metroSupportStreamingInstall: 0
  metroLastRequiredScene: 0
  metroDefaultTileSize: 1
  metroTileForegroundText: 2
  metroTileBackgroundColor: {r: 0.13333334, g: 0.17254902, b: 0.21568628, a: 0}
  metroSplashScreenBackgroundColor: {r: 0.12941177, g: 0.17254902, b: 0.21568628, a: 1}
  metroSplashScreenUseBackgroundColor: 0
  syncCapabilities: 0
  platformCapabilities: {}
  metroTargetDeviceFamilies: {}
  metroFTAName: 
  metroFTAFileTypes: []
  metroProtocolName: 
  vcxProjDefaultLanguage: 
  XboxOneProductId: 
  XboxOneUpdateKey: 
  XboxOneSandboxId: 
  XboxOneContentId: 
  XboxOneTitleId: 
  XboxOneSCId: 
  XboxOneGameOsOverridePath: 
  XboxOnePackagingOverridePath: 
  XboxOneAppManifestOverridePath: 
  XboxOneVersion: 1.0.0.0
  XboxOnePackageEncryption: 0
  XboxOnePackageUpdateGranularity: 2
  XboxOneDescription: 
  XboxOneLanguage:
  - enus
  XboxOneCapability: []
  XboxOneGameRating: {}
  XboxOneIsContentPackage: 0
  XboxOneEnhancedXboxCompatibilityMode: 0
  XboxOneEnableGPUVariability: 1
  XboxOneSockets: {}
  XboxOneSplashScreen: {fileID: 0}
  XboxOneAllowedProductIds: []
  XboxOnePersistentLocalStorageSize: 0
  XboxOneXTitleMemory: 8
  XboxOneOverrideIdentityName: 
  XboxOneOverrideIdentityPublisher: 
  vrEditorSettings: {}
  cloudServicesEnabled: {}
  luminIcon:
    m_Name: 
    m_ModelFolderPath: 
    m_PortalFolderPath: 
  luminCert:
    m_CertPath: 
    m_SignPackage: 1
  luminIsChannelApp: 0
  luminVersion:
    m_VersionCode: 1
    m_VersionName: 
  hmiPlayerDataPath: 
  hmiForceSRGBBlit: 1
  embeddedLinuxEnableGamepadInput: 1
  hmiLogStartupTiming: 0
  hmiCpuConfiguration: 
  apiCompatibilityLevel: 6
  activeInputHandler: 0
  windowsGamepadBackendHint: 0
  cloudProjectId: 
  framebufferDepthMemorylessMode: 0
  qualitySettingsNames: []
  projectName: 
  organizationId: 
  cloudEnabled: 0
  legacyClampBlendShapeWeights: 0
  hmiLoadingImage: {fileID: 0}
  platformRequiresReadableAssets: 0
  virtualTexturingSupportEnabled: 0
  insecureHttpOption: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/ProjectVersion.txt
================================================
m_EditorVersion: 2022.3.39f1
m_EditorVersionWithRevision: 2022.3.39f1 (4e1b0f82c39a)



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/QualitySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!47 &1
QualitySettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_CurrentQuality: 5
  m_QualitySettings:
  - serializedVersion: 2
    name: Very Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 15
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 1
    textureQuality: 1
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.3
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.4
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 16
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Medium
    pixelLightCount: 1
    shadows: 1
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 0.7
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 64
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: High
    pixelLightCount: 2
    shadows: 2
    shadowResolution: 1
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 40
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 256
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Very High
    pixelLightCount: 3
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 70
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 4
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1.5
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 1024
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Ultra
    pixelLightCount: 4
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 4
    shadowDistance: 150
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 255
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 2
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  m_PerPlatformDefaultQuality:
    Android: 2
    Lumin: 5
    Nintendo Switch: 5
    PS4: 5
    Stadia: 5
    Standalone: 5
    WebGL: 3
    Windows Store Apps: 5
    XboxOne: 5
    iPhone: 2
    tvOS: 2



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/SceneTemplateSettings.json
================================================
{
    "templatePinStates": [],
    "dependencyTypeInfos": [
        {
            "userAdded": false,
            "type": "UnityEngine.AnimationClip",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Animations.AnimatorController",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.AnimatorOverrideController",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Audio.AudioMixerController",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ComputeShader",
            "defaultInstantiationMode": 1
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Cubemap",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.GameObject",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEditor.LightingDataAsset",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.LightingSettings",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Material",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEditor.MonoScript",
            "defaultInstantiationMode": 1
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicMaterial",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicsMaterial2D",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessProfile",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessResources",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.VolumeProfile",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEditor.SceneAsset",
            "defaultInstantiationMode": 1
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Shader",
            "defaultInstantiationMode": 1
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ShaderVariantCollection",
            "defaultInstantiationMode": 1
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture2D",
            "defaultInstantiationMode": 0
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Timeline.TimelineAsset",
            "defaultInstantiationMode": 0
        }
    ],
    "defaultDependencyTypeInfo": {
        "userAdded": false,
        "type": "<default_scene_template_dependencies>",
        "defaultInstantiationMode": 1
    },
    "newSceneOverride": 0
}


================================================
FILE: src/MessagePipe.Unity/ProjectSettings/TagManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!78 &1
TagManager:
  serializedVersion: 2
  tags: []
  layers:
  - Default
  - TransparentFX
  - Ignore Raycast
  - 
  - Water
  - UI
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  m_SortingLayers:
  - name: Default
    uniqueID: 0
    locked: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/TimeManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!5 &1
TimeManager:
  m_ObjectHideFlags: 0
  Fixed Timestep: 0.02
  Maximum Allowed Timestep: 0.33333334
  m_TimeScale: 1
  Maximum Particle Timestep: 0.03



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/UnityConnectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!310 &1
UnityConnectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 1
  m_Enabled: 0
  m_TestMode: 0
  m_EventOldUrl: https://api.uca.cloud.unity3d.com/v1/events
  m_EventUrl: https://cdp.cloud.unity3d.com/v1/events
  m_ConfigUrl: https://config.uca.cloud.unity3d.com
  m_DashboardUrl: https://dashboard.unity3d.com
  m_TestInitMode: 0
  CrashReportingSettings:
    m_EventUrl: https://perf-events.cloud.unity3d.com
    m_Enabled: 0
    m_LogBufferSize: 10
    m_CaptureEditorExceptions: 1
  UnityPurchasingSettings:
    m_Enabled: 0
    m_TestMode: 0
  UnityAnalyticsSettings:
    m_Enabled: 0
    m_TestMode: 0
    m_InitializeOnStartup: 1
    m_PackageRequiringCoreStatsPresent: 0
  UnityAdsSettings:
    m_Enabled: 0
    m_InitializeOnStartup: 1
    m_TestMode: 0
    m_IosGameId: 
    m_AndroidGameId: 
    m_GameIds: {}
    m_GameId: 
  PerformanceReportingSettings:
    m_Enabled: 0



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/VersionControlSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!890905787 &1
VersionControlSettings:
  m_ObjectHideFlags: 0
  m_Mode: Visible Meta Files
  m_CollabEditorSettings:
    inProgressEnabled: 1



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/VFXManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!937362698 &1
VFXManager:
  m_ObjectHideFlags: 0
  m_IndirectShader: {fileID: 0}
  m_CopyBufferShader: {fileID: 0}
  m_SortShader: {fileID: 0}
  m_StripUpdateShader: {fileID: 0}
  m_RenderPipeSettingsPath: 
  m_FixedTimeStep: 0.016666668
  m_MaxDeltaTime: 0.05



================================================
FILE: src/MessagePipe.Unity/ProjectSettings/XRSettings.asset
================================================
{
    "m_SettingKeys": [
        "VR Device Disabled",
        "VR Device User Alert"
    ],
    "m_SettingValues": [
        "False",
        "False"
    ]
}


================================================
FILE: tests/MessagePipe.Analyzer.Tests/AnalyzerTest.cs
================================================
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Analyzer.Tests
{
    public class AnalyzerTest
    {
        static async Task VerifyAsync(string testCode, int startLine, int startColumn, int endLine, int endColumn)
        {

            await new CSharpAnalyzerTest<MessagePipeAnalyzer, XUnitVerifier>
            {
                ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity("MessagePipe", "1.4.0"))),
                ExpectedDiagnostics = { new DiagnosticResult("MPA001", DiagnosticSeverity.Error).WithSpan(startLine, startColumn, endLine, endColumn) },
                TestCode = testCode
            }.RunAsync();
        }

        static async Task VerifyAsync(string testCode)
        {

            await new CSharpAnalyzerTest<MessagePipeAnalyzer, XUnitVerifier>
            {
                ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity("MessagePipe", "1.4.0"))),
                ExpectedDiagnostics = { new DiagnosticResult("MPA001", DiagnosticSeverity.Error) },
                TestCode = testCode
            }.RunAsync();
        }

        static async Task VerifyNoErrorAsync(string testCode)
        {

            await new CSharpAnalyzerTest<MessagePipeAnalyzer, XUnitVerifier>
            {
                ReferenceAssemblies = ReferenceAssemblies.Default.WithPackages(ImmutableArray.Create(new PackageIdentity("MessagePipe", "1.4.0"))),
                ExpectedDiagnostics = { },
                TestCode = testCode
            }.RunAsync();
        }

        [Fact]
        public async Task SimpleTest()
        {
            var testCode = @"using MessagePipe;

class C
{
    public void M(ISubscriber<int> subscriber)
    {
        subscriber.Subscribe(x => { });
    }
}";

            await VerifyAsync(testCode, 7, 9, 7, 39);
        }

//        [Fact]
//        public async Task SimpleTest2()
//        {
//            var testCode = @"using MessagePipe;

//class C
//{
//    public void M(ISubscriber<int> subscriber)
//    {
//        [|subscriber.Subscribe(x => { })|];
//    }
//}";

//            await VerifyAsync(testCode);
//        }

        [Fact]
        public async Task NoErrorReport()
        {
            var testCode = @"using MessagePipe;

class C
{
    public void M(ISubscriber<int> subscriber)
    {
        var d = subscriber.Subscribe(x => { });
    }
}";

            await VerifyNoErrorAsync(testCode);
        }
    }

}



================================================
FILE: tests/MessagePipe.Analyzer.Tests/MessagePipe.Analyzer.Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net6.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.3">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.1.0" />
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" Version="4.1.0" />
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp.Analyzer.Testing.XUnit" Version="1.1.1" />

        <PackageReference Include="FluentAssertions" Version="6.6.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
        <PackageReference Include="xunit" Version="2.4.1" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>

        <ProjectReference Include="..\..\src\MessagePipe.Analyzer\MessagePipe.Analyzer.csproj" />

        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Benchmark/BenchmarkDotNetRun.cs
================================================
﻿#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

using BenchmarkDotNet.Attributes;
using Easy.MessageHub;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Prism.Events;
using PubSub;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Subjects;
using System.Text;
using System.Threading.Tasks;
using Zenject;

namespace MessagePipe.Benchmark
{
    [Config(typeof(BenchmarkConfig))]
    public class BenchmarkDotNetRun
    {
        IPublisher<Message> p;
        Message m;
        Subject<Message> subject;
        PubSubEvent<Message> prism;
        PubSubEvent<Message> prismStrong;
        IMediator medi;
        public event Action<Message> ev;
        Hub hub;
        SignalBus signalBus;

        IPublisher<Guid, Message> keyed;
        Guid key = Guid.NewGuid();

        MessageHub easyMsgHub;

        public BenchmarkDotNetRun()
        {
            var provider = new ServiceCollection().AddMessagePipe().Services.BuildServiceProvider();

            prism = new Prism.Events.EventAggregator().GetEvent<Message>();
            prismStrong = new Prism.Events.EventAggregator().GetEvent<Message>();

            var mdiatr = new ServiceCollection().AddMediatR(typeof(PublishOps).Assembly).BuildServiceProvider();
            medi = mdiatr.GetRequiredService<IMediator>();


            p = provider.GetRequiredService<IPublisher<Message>>();
            var s = provider.GetRequiredService<ISubscriber<Message>>();

            keyed = provider.GetRequiredService<IPublisher<Guid, Message>>();
            var keyedS = provider.GetRequiredService<ISubscriber<Guid, Message>>();

            hub = Hub.Default;

            m = new Message();
            subject = new Subject<Message>();

            signalBus = SetupZenject();
            easyMsgHub = new MessageHub();

            for (int i = 0; i < 8; i++)
            {
                s.Subscribe(new EmptyMessageHandler());
                prism.Subscribe(_ => { });
                prismStrong.Subscribe(_ => { }, true);
                ev += _ => { };
                subject.Subscribe(_ => { });
                hub.Subscribe<Message>(_ => { });



                keyedS.Subscribe(key, _ => { });


                easyMsgHub.Subscribe<Message>(_ => { });


            }

            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });

        }

        SignalBus SetupZenject()
        {
            var container = new DiContainer();
            SignalBusInstaller.Install(container);
            container.DeclareSignal<Message>();
            return container.Resolve<SignalBus>();
        }

        [Benchmark]
        public void MessagePipe()
        {
            p.Publish(m);
        }

        [Benchmark]
        public void Event()
        {
            ev(m);
        }

        [Benchmark]
        public void RxSubject()
        {
            subject.OnNext(m);
        }

        [Benchmark]
        public void Prism()
        {
            prism.Publish(m);
        }

        [Benchmark]
        public void Prism_KeepRef()
        {
            prismStrong.Publish(m);
        }

        [Benchmark]
        public void MediatR()
        {
            medi.Publish(m).Wait();
        }

        [Benchmark]
        public void UptaPubSub()
        {
            hub.Publish(m);
        }

        [Benchmark]
        public void ZenjectSignals()
        {
            signalBus.Fire<Message>(m);
        }

        public void EasyMessageHub()
        {
            easyMsgHub.Publish(m);
        }
    }
}



================================================
FILE: tests/MessagePipe.Benchmark/MessagePipe.Benchmark.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Configuration)' == 'WinBenchmark'">
        <DefineConstants>RELEASE;WinBenchmark</DefineConstants>
        <DebugSymbols>false</DebugSymbols>
        <DebugType>portable</DebugType>
        <Optimize>true</Optimize>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BenchmarkDotNet" Version="0.13.1" />
        <PackageReference Include="Easy.MessageHub" Version="5.0.0" />
        <PackageReference Include="MediatR" Version="10.0.1" />
        <PackageReference Include="MediatR.Extensions.Microsoft.DependencyInjection" Version="10.0.1" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
        <PackageReference Include="Microsoft.Toolkit.Mvvm" Version="7.1.2" />
        <PackageReference Include="Prism.Core" Version="8.1.97" />
        <PackageReference Include="PubSub" Version="4.0.2" />
        <PackageReference Include="System.Reactive" Version="5.0.0" />
    </ItemGroup>
    <ItemGroup Condition="$(Configuration) == 'WinBenchmark'">
        <PackageReference Include="MvvmLightLibs" Version="5.4.1.1" />
        <PackageReference Include="UniRx" Version="5.4.1" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Reference Include="ZenjectCore">
            <HintPath>ZenjectCore.dll</HintPath>
        </Reference>
    </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Benchmark/Program.cs
================================================
﻿using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using System.Threading.Tasks;

namespace MessagePipe.Benchmark
{
    class Program
    {
        static async Task Main()
        {
            await new PublishOps().MeasureAllAsync();

            //BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()).Run(args);
            await Task.Yield();
        }
    }

    internal class BenchmarkConfig : ManualConfig
    {
        public BenchmarkConfig()
        {
            AddDiagnoser(MemoryDiagnoser.Default);
            AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1).WithRuntime(CoreRuntime.Core50));

            // Add Targetframeworks net47 to csproj(removed for CI)
            //AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1).WithRuntime(ClrRuntime.Net47));
        }
    }
}



================================================
FILE: tests/MessagePipe.Benchmark/PublishOps.cs
================================================
﻿#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

using Easy.MessageHub;

using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Prism.Events;
using PubSub;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reactive.Subjects;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Zenject;
using Microsoft.Toolkit.Mvvm.Messaging;

#if WinBenchmark
using GalaSoft.MvvmLight.Messaging;
#endif

namespace MessagePipe.Benchmark
{
    public class LambdaRef
    {
        public Action<Message> Delegate;

        public LambdaRef()
        {
            Delegate = Empty;
        }

        public void Empty(Message _)
        {
        }

    }

    public class LambdaRef2
    {
        public MessageHandler<object, Message> Delegate;

        public LambdaRef2()
        {
            Delegate = Empty;
        }

        public void Empty(object __, Message _)
        {
        }

    }

    public class PublishOps
    {
        LambdaRef lambdaRef = new LambdaRef();
        LambdaRef2 lambdaRef2 = new LambdaRef2();

        IPublisher<Message> p;
        Message m;
        Subject<Message> subject;
        PubSubEvent<Message> prism;
        PubSubEvent<Message> prismStrong;
        IMediator medi;
        public event Action<Message> ev;
        Hub hub;
        SignalBus signalBus;

        IPublisher<Message> filter1;
        IPublisher<Message> filter2;
        IPublisher<Guid, Message> keyed;
        IAsyncPublisher<Message> asyncP;
        IAsyncSubscriber<Message> asyncS;
        Guid key = Guid.NewGuid();

        MessageHub easyMsgHub;

        PlainAction[] simpleArray;
        IInvoke[] interfaceArray;
        Action[] actionDelegate;

        Microsoft.Toolkit.Mvvm.Messaging.StrongReferenceMessenger toolkitStrong;
        Microsoft.Toolkit.Mvvm.Messaging.WeakReferenceMessenger toolkitWeak;

#if WinBenchmark
        Messenger mvvmLight;
        Messenger mvvmLightStrong;
#endif

        public unsafe PublishOps()
        {
            var provider = new ServiceCollection().AddMessagePipe().Services.BuildServiceProvider();

            prism = new Prism.Events.EventAggregator().GetEvent<Message>();
            prismStrong = new Prism.Events.EventAggregator().GetEvent<Message>();

            var mdiatr = new ServiceCollection().AddMediatR(typeof(PublishOps).Assembly).BuildServiceProvider();
            medi = mdiatr.GetRequiredService<IMediator>();


            p = provider.GetRequiredService<IPublisher<Message>>();
            var s = provider.GetRequiredService<ISubscriber<Message>>();

            keyed = provider.GetRequiredService<IPublisher<Guid, Message>>();
            var keyedS = provider.GetRequiredService<ISubscriber<Guid, Message>>();

            hub = Hub.Default;



            var px = new ServiceCollection().AddMessagePipe().Services.BuildServiceProvider();
            filter1 = px.GetRequiredService<IPublisher<Message>>();
            var filter1Sub = px.GetRequiredService<ISubscriber<Message>>();

            var px2 = new ServiceCollection().AddMessagePipe().Services.BuildServiceProvider();
            filter2 = px2.GetRequiredService<IPublisher<Message>>();
            var filter2Sub = px2.GetRequiredService<ISubscriber<Message>>();

            m = new Message();
            subject = new Subject<Message>();

            signalBus = SetupZenject();
            easyMsgHub = new MessageHub();

            asyncP = provider.GetRequiredService<IAsyncPublisher<Message>>();
            asyncS = provider.GetRequiredService<IAsyncSubscriber<Message>>();


#if WinBenchmark
            mvvmLight = new Messenger();
            mvvmLightStrong = new Messenger();
#endif

            toolkitStrong = new Microsoft.Toolkit.Mvvm.Messaging.StrongReferenceMessenger();
            toolkitWeak = new Microsoft.Toolkit.Mvvm.Messaging.WeakReferenceMessenger();



            simpleArray = new PlainAction[8];
            actionDelegate = new Action[8];
            interfaceArray = new IInvoke[8];


            for (int i = 0; i < 8; i++)
            {
                s.Subscribe(new EmptyMessageHandler());
                prism.Subscribe(lambdaRef.Delegate);
                prismStrong.Subscribe(_ => { }, true);
                ev += _ => { };
                subject.Subscribe(_ => { });
                hub.Subscribe<Message>(_ => { });

#if WinBenchmark
                UniRx.MessageBroker.Default.Receive<Message>().Subscribe(new NopObserver());
                mvvmLight.Register<Message>(this, _ => { }, false);
                // mvvmLightStrong.Register<Message>(this, _ => { }, true);
#endif

                keyedS.Subscribe(key, _ => { });

                filter1Sub.Subscribe(new EmptyMessageHandler(), new EmptyMessageHandlerFilter());
                filter2Sub.Subscribe(new EmptyMessageHandler(), new EmptyMessageHandlerFilter(), new EmptyMessageHandlerFilter());

                easyMsgHub.Subscribe<Message>(_ => { });

                simpleArray[i] = new PlainAction();
                actionDelegate[i] = new PlainAction().DelegateAction;
                interfaceArray[i] = new PlainAction();

                asyncS.Subscribe((_, _) => default(ValueTask));

                toolkitStrong.Register<Message>(new object(), lambdaRef2.Delegate);
                toolkitWeak.Register<Message>(new object(), lambdaRef2.Delegate);
            }

            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });
            signalBus.Subscribe<Message>(_ => { });

        }

        SignalBus SetupZenject()
        {
            var container = new DiContainer();
            SignalBusInstaller.Install(container);
            container.DeclareSignal<Message>();
            return container.Resolve<SignalBus>();
        }

        public async Task MeasureAllAsync()
        {
            (string, int)[] result = new (string, int)[0];
            for (int i = 0; i < 2; i++)
            {
                if (i == 0) Console.WriteLine("WARM:");
                if (i == 1) Console.WriteLine("RUN:");

                result = new[]
                {
                    Measure("MessagePipe", () => p.Publish(m)),
                    Measure("event", () => ev(m)),
                    Measure("Rx.Subject", () => subject.OnNext(m)),
                    Measure("Prism", () => prism.Publish(m)),
                    Measure("Prism(keepRef)", () => prismStrong.Publish(m)),
                    await MeasureAsync("MediatR", () => medi.Publish(m)),
                    Measure("upta/PubSub", () => hub.Publish(m)),
                    Measure("Zenject.Signals", () => signalBus.Fire<Message>(m)),

                    #if WinBenchmark
                    Measure("UniRx.MessageBroker", () => UniRx.MessageBroker.Default.Publish(m)),
                    Measure("MvvmLight", () => mvvmLight.Send(m)),
                    // Measure("MvvmLight(keepRef)", () => mvvmLightStrong.Send(m))
                    #endif
                            
                    Measure("Easy.MessageHub", () => easyMsgHub.Publish(m)),
                    Measure("MS.Toolkit.Strong", () => toolkitStrong.Send(m)),
                    Measure("MS.Toolkit.Weak", () => toolkitWeak.Send(m)),

                    //Measure("Array", () =>
                    //{
                    //    var xs = simpleArray;
                    //    for (int i = 0; i < xs.Length; i++)
                    //    {
                    //     xs[i].Invoke();
                    //    }
                    //}),
                    //Measure("Action[]", () =>
                    //{
                    //    var xs = actionDelegate;
                    //    for (int i = 0; i < xs.Length; i++)
                    //    {
                    //     xs[i].Invoke();
                    //    }
                    //}),
                    //Measure("Interface[]", () =>
                    //{
                    //    var xs = interfaceArray;
                    //    for (int i = 0; i < xs.Length; i++)
                    //    {
                    //     xs[i].Invoke();
                    //    }
                    //}),
                    //Measure("MessagePipe(f1)", () => filter1.Publish(m)),
                    //Measure("MessagePipe(f2)", () => filter2.Publish(m)),
                    //Measure("MessagePipe(key)", () => keyed.Publish(key, m)),
                    //await MeasureAsync("MessagePipe(async-s)",  () =>  asyncP.PublishAsync(m, AsyncPublishStrategy.Sequential)),
                    //await MeasureAsync("MessagePipe(async-p)",  () => asyncP.PublishAsync(m, AsyncPublishStrategy.Parallel)),
                    //Measure("MessagePipe(async-f)", () => asyncP.Publish(m)),
            };
            }

            Console.WriteLine("----");
            Console.WriteLine();

            foreach (var item in result.OrderByDescending(x => x.Item2))
            {
                Console.WriteLine(string.Format("  {0,-20} {1,10} op/sec", item.Item1, item.Item2));
            }

            Console.WriteLine();
        }

        static (string, int) Measure(string label, Action action)
        {
            Console.WriteLine("Start:" + label);
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            GC.TryStartNoGCRegion(1000 * 1000 * 100, true);

            var count = 0;
            var sw = Stopwatch.StartNew();
            while (sw.ElapsedMilliseconds <= 1000)
            {
                action();
                count++;
            }

            try
            {
                GC.EndNoGCRegion();
            }
            catch
            {
                Console.WriteLine("Faile NoGC:" + label);
            }

            return (label, count);
        }

        static async Task<(string, int)> MeasureAsync(string label, Func<Task> action)
        {
            Console.WriteLine("Start:" + label);
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            GC.TryStartNoGCRegion(1000 * 1000, true);

            var count = 0;
            var sw = Stopwatch.StartNew();
            while (sw.ElapsedMilliseconds <= 1000)
            {
                await action().ConfigureAwait(false);
                count++;
            }

            try
            {
                GC.EndNoGCRegion();
            }
            catch
            {
                Console.WriteLine("Faile NoGC:" + label);
            }

            return (label, count);
        }

        static async Task<(string, int)> MeasureAsync(string label, Func<ValueTask> action)
        {
            Console.WriteLine("Start:" + label);
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            GC.TryStartNoGCRegion(1000 * 1000, true);

            var count = 0;
            var sw = Stopwatch.StartNew();
            while (sw.ElapsedMilliseconds <= 1000)
            {
                await action().ConfigureAwait(false);
                count++;
            }

            try
            {
                GC.EndNoGCRegion();
            }
            catch
            {
                Console.WriteLine("Faile NoGC:" + label);
            }

            return (label, count);
        }


    }

    public interface IInvoke
    {
        void Invoke();
    }


    public sealed class PlainAction : IInvoke
    {
        public readonly Action DelegateAction;

        public PlainAction()
        {
            this.DelegateAction = this.Invoke;
        }

        public void Invoke()
        {
        }
    }

    public class Message : PubSubEvent<Message>, INotification
    {
    }
#if WinBenchmark
    public class NopObserver : UniRx.IObserver<Message>
    {
        public void OnCompleted()
        {
        }

        public void OnError(Exception error)
        {
        }

        public void OnNext(Message value)
        {
        }
    }
#endif

    public class Pong0 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong1 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong2 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong3 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong4 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong5 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong6 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }
    public class Pong7 : INotificationHandler<Message>
    {
        public Task Handle(Message notification, CancellationToken cancellationToken) => Task.CompletedTask;
    }

    public class EmptyMessageHandler : IMessageHandler<Message>
    {
        public void Handle(Message message)
        {
        }
    }

    public class EmptyMessageHandlerFilter : MessageHandlerFilter<Message>
    {
        public override void Handle(Message message, Action<Message> next)
        {
            next(message);
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Benchmark/MessagePipe.Interprocess.Benchmark.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BenchmarkDotNet" Version="0.13.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\MessagePipe.Interprocess\MessagePipe.Interprocess.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Interprocess.Benchmark/MyAsyncRequestHandler.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;

namespace MessagePipe.Interprocess.Benchmark
{
    public class MyAsyncMessageHandler : IAsyncMessageHandler<byte[]>
    {
        public ValueTask HandleAsync(byte[] message, CancellationToken cancellationToken)
        {
            return default(ValueTask);
        }
    }
    public class MyAsyncHandler : IAsyncRequestHandler<int, byte[]>
    {
        public ValueTask<byte[]> InvokeAsync(int request, CancellationToken cancellationToken = default)
        {
            if (request == -1)
            {
                throw new Exception("NO -1");
            }
            else
            {
                return new ValueTask<byte[]>(new byte[request]);
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Benchmark/Program.cs
================================================
﻿using System;
using BenchmarkDotNet.Running;

namespace MessagePipe.Interprocess.Benchmark
{
    class Program
    {
        static void Main(string[] args)
        {
            new BenchmarkSwitcher(typeof(Program).Assembly).Run();
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Benchmark/TcpBenchmark.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using BenchmarkDotNet;
using BenchmarkDotNet.Attributes;
using MessagePipe;
using Microsoft.Extensions.DependencyInjection;

namespace MessagePipe.Interprocess.Benchmark
{
    [ShortRunJob]
    public class TcpBenchmark
    {
        IServiceProvider? _TcpIpProvider = null;
        IServiceProvider? _TcpUdsProvider = null;
        string? _TcpUdsSocketPath = null;
        [Params(1, 1000000)]
        public int DataSize { get; set; }
        IServiceProvider CreateTcpIpServiceProvider()
        {
            var services = new ServiceCollection();
            services.AddMessagePipe()
                .AddTcpInterprocess("127.0.0.1", 10000, opts =>
                {
                    opts.HostAsServer = true;
                });
            return services.BuildServiceProvider();
        }
        IServiceProvider CreateTcpUdsServiceProvider()
        {
            _TcpUdsSocketPath = System.IO.Path.GetTempFileName();
            if (System.IO.File.Exists(_TcpUdsSocketPath))
            {
                System.IO.File.Delete(_TcpUdsSocketPath);
            }
            var services = new ServiceCollection();
            services.AddMessagePipe()
                .AddTcpInterprocessUds(_TcpUdsSocketPath, opt =>
                {
                    opt.HostAsServer = true;
                    opt.SendBufferSize = Math.Min(DataSize, 0x1000);
                    opt.ReceiveBufferSize = Math.Min(DataSize, 0x1000);
                });
            return services.BuildServiceProvider();
        }
        [GlobalSetup]
        public void Setup()
        {
            _TcpIpProvider = CreateTcpIpServiceProvider();
            _TcpUdsProvider = CreateTcpUdsServiceProvider();
        }
        [GlobalCleanup]
        public void Cleanup()
        {
            if (_TcpUdsSocketPath != null)
            {
                if (System.IO.File.Exists(_TcpUdsSocketPath))
                {
                    System.IO.File.Delete(_TcpUdsSocketPath);
                }
            }
        }
        async ValueTask RemoteRequest(IRemoteRequestHandler<int, byte[]>? handler)
        {
            if(handler == null)
            {
                throw new ArgumentNullException("handler");
            }
            await handler.InvokeAsync(DataSize);
        }
        async ValueTask PubSub(IServiceProvider provider)
        {
            var publisher = provider.GetService<IDistributedPublisher<int, byte[]>>() ?? throw new ArgumentNullException("publisher");
            var subscriber = provider.GetService<IDistributedSubscriber<int, byte[]>>() ?? throw new ArgumentNullException("subscriber");
            await using (await subscriber.SubscribeAsync(1, new MyAsyncMessageHandler()))
            {
                await publisher.PublishAsync(1, new byte[DataSize]);
            }
        }
        [Benchmark]
        public async ValueTask TcpIpRemoteRequest()
        {
            var provider = _TcpIpProvider ?? throw new ArgumentNullException("_TcpIpProvider");
            var handler = provider.GetService<IRemoteRequestHandler<int, byte[]>>();
            await RemoteRequest(handler);
        }
        [Benchmark]
        public async ValueTask TcpUdsRemoteRequest()
        {
            var provider = _TcpUdsProvider ?? throw new ArgumentNullException("_TcpUdsProvider");
            var handler = provider.GetService<IRemoteRequestHandler<int, byte[]>>();
            await RemoteRequest(handler);
        }
        [Benchmark]
        public async ValueTask TcpIpPubSub()
        {
            var provider = _TcpIpProvider ?? throw new ArgumentNullException("_TcpUdsProvider");
            await PubSub(provider);
        }
        [Benchmark]
        public async ValueTask TcpUdsPubSub()
        {
            var provider = _TcpUdsProvider ?? throw new ArgumentNullException("_TcpUdsProvider");
            await PubSub(provider);
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Benchmark/TcpParallelBenchmark.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using BenchmarkDotNet.Attributes;
using Microsoft.Extensions.DependencyInjection;
using System.Threading;

namespace MessagePipe.Interprocess.Benchmark
{
    [ShortRunJob]
    public class TcpParallelBenchmark
    {
        [Params(100)]
        public int DataSize { get; set; }
        [Params(1, 10)]
        public int TaskNum { get; set; }
        const int TotalRequestNum = 10;
        IServiceProvider CreateTcpIpServiceProvider(string ip, int port)
        {
            var services = new ServiceCollection();
            services.AddMessagePipe()
                .AddTcpInterprocess(ip, port, opts =>
                {
                    opts.HostAsServer = true;
                });
            return services.BuildServiceProvider();
        }
        IServiceProvider CreateTcpUdsServiceProvider(string socketPath)
        {
            if (System.IO.File.Exists(socketPath))
            {
                System.IO.File.Delete(socketPath);
            }
            var services = new ServiceCollection();
            services.AddMessagePipe()
                .AddTcpInterprocessUds(socketPath, opt =>
                {
                    opt.HostAsServer = true;
                    opt.SendBufferSize = Math.Min(DataSize, 0x1000);
                    opt.ReceiveBufferSize = Math.Min(DataSize, 0x1000);
                });
            return services.BuildServiceProvider();
        }
        IServiceProvider? _TcpIpProvider = null;
        IServiceProvider? _TcpUdsProvider = null;
        string _TcpSocketPath = "";
        [GlobalSetup]
        public void Setup()
        {
            _TcpIpProvider = CreateTcpIpServiceProvider("127.0.0.1", 20000);
            _TcpSocketPath = Path.GetTempFileName();
            _TcpUdsProvider = CreateTcpUdsServiceProvider(_TcpSocketPath);
        }
        [GlobalCleanup]
        public void Cleanup()
        {
            if (File.Exists(_TcpSocketPath))
            {
                File.Delete(_TcpSocketPath);
            }
        }
        async Task ClientTask(IServiceProvider provider, int num)
        {
            await Task.WhenAll(Enumerable.Range(0, num).Select(async idx =>
            {
                var handler = provider.GetService<IRemoteRequestHandler<int, byte[]>>() ?? throw new ArgumentNullException("handler");
                for (int i = 0; i < TotalRequestNum / num; i++)
                {
                    await handler.InvokeAsync(DataSize);
                }
            }));
        }
        async Task SubscriberTask(IServiceProvider provider, CancellationToken token)
        {
            var subscriber = provider.GetService<IDistributedSubscriber<int, byte[]>>() ?? throw new ArgumentNullException("subscriber");
            await using (await subscriber.SubscribeAsync(1, new MyAsyncMessageHandler(), token))
            {

            }
        }
        async Task PublisherAsync(IServiceProvider provider, int taskNum, CancellationTokenSource cts)
        {
            await Task.WhenAll(Enumerable.Range(0, taskNum).Select(async _ =>
            {
                var publisher = provider.GetService<IDistributedPublisher<int, byte[]>>() ?? throw new ArgumentNullException("provider");
                await publisher.PublishAsync(1, new byte[DataSize]);
            }));
            cts.Cancel();
        }
        [Benchmark]
        public async Task TcpIpRemoteRequest()
        {
            if(_TcpIpProvider == null)
            {
                throw new ArgumentNullException(nameof(_TcpIpProvider));
            }
            await ClientTask(_TcpIpProvider, TaskNum);
        }
        [Benchmark]
        public async Task TcpUdsRemoteRequest()
        {
            if(_TcpUdsProvider == null)
            {
                throw new ArgumentNullException(nameof(_TcpUdsProvider));
            }
            await ClientTask(_TcpUdsProvider, TaskNum);
        }
        [Benchmark]
        public async Task TcpIpPubSub()
        {
            if (_TcpIpProvider == null)
            {
                throw new ArgumentNullException(nameof(_TcpIpProvider));
            }
            using var cts = new CancellationTokenSource();
            await Task.WhenAll(PublisherAsync(_TcpIpProvider, TaskNum, cts), SubscriberTask(_TcpIpProvider, cts.Token));
        }
        [Benchmark]
        public async Task TcpUdsPubSub()
        {
            if(_TcpUdsProvider == null)
            {
                throw new ArgumentNullException(nameof(_TcpUdsProvider));
            }
            using var cts = new CancellationTokenSource();
            await Task.WhenAll(PublisherAsync(_TcpUdsProvider, TaskNum, cts), SubscriberTask(_TcpUdsProvider, cts.Token));
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Tests/_TestHelper.cs
================================================
using Microsoft.Extensions.DependencyInjection;
using System;
using Xunit.Abstractions;

namespace MessagePipe.Interprocess.Tests
{
    public static class TestHelper
    {
        public static IServiceProvider BuildServiceProviderUdp(string host, int port, ITestOutputHelper helper)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
                .AddUdpInterprocess(host, port, x =>
                {
                    x.UnhandledErrorHandler = (msg, e) => helper.WriteLine(msg + e);
                });
            return sc.BuildServiceProvider();
        }
        public static IServiceProvider BuildServiceProviderUdpWithUds(string domainSocketPath, ITestOutputHelper helper)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
                .AddUdpInterprocessUds(domainSocketPath, x =>
                {
                    x.UnhandledErrorHandler = (msg, e) => helper.WriteLine(msg + e);
                });
            return sc.BuildServiceProvider();
        }
        public static IServiceProvider BuildServiceProviderTcp(string host, int port, ITestOutputHelper helper, bool asServer = true)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
                .AddTcpInterprocess(host, port, x =>
                {
                    x.HostAsServer = asServer;
                    x.UnhandledErrorHandler = (msg, e) => helper.WriteLine(msg + e);
                });
            return sc.BuildServiceProvider();
        }
        public static IServiceProvider BuildServiceProviderTcpWithUds(string domainSocketPath, ITestOutputHelper helper, bool asServer = true)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
                .AddTcpInterprocessUds(domainSocketPath, x =>
                {
                    x.HostAsServer = asServer;
                    x.UnhandledErrorHandler = (msg, e) => helper.WriteLine(msg + e);
                });
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildServiceProviderNamedPipe(string pipeName, ITestOutputHelper helper, bool asServer = true)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
                .AddNamedPipeInterprocess(pipeName, x =>
                {
                    x.HostAsServer = asServer;
                    x.UnhandledErrorHandler = (msg, e) => helper.WriteLine(msg + e);
                });
            return sc.BuildServiceProvider();
        }
    }
}


================================================
FILE: tests/MessagePipe.Interprocess.Tests/MessagePipe.Interprocess.Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="FluentAssertions" Version="6.6.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
        <PackageReference Include="xunit" Version="2.4.1" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe.Interprocess\MessagePipe.Interprocess.csproj" />
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Interprocess.Tests/NamedPipeTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace MessagePipe.Interprocess.Tests
{
    public class NamedPipeTest
    {
        readonly ITestOutputHelper helper;

        public NamedPipeTest(ITestOutputHelper testOutputHelper)
        {
            this.helper = testOutputHelper;
        }

        [Fact]
        public async Task SimpleIntInt()
        {
            var provider = TestHelper.BuildServiceProviderNamedPipe("foobar", helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<int, int>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<int, int>>();

                var result = new List<int>();
                await s1.SubscribeAsync(1, x =>
                {
                    result.Add(x);
                });

                var result2 = new List<int>();
                await s1.SubscribeAsync(4, x =>
                {
                    result2.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 9999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(4, 888);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 4999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(9999, 4999);
                result2.Should().Equal(888);
            }
        }

        [Fact]
        public async Task ConnectTwice()
        {
            var providerServer = TestHelper.BuildServiceProviderNamedPipe("zb", helper, asServer: false);
            var providerClient = TestHelper.BuildServiceProviderNamedPipe("zb", helper, asServer: false);
            var p1 = providerClient.GetRequiredService<IDistributedPublisher<int, int>>();
            var s1 = providerServer.GetRequiredService<IDistributedSubscriber<int, int>>();

            var result = new List<int>();
            await s1.SubscribeAsync(1, x =>
            {
                result.Add(x);
            });

            await p1.PublishAsync(1, 9999);
            var scope = (providerClient as IDisposable);

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

            scope?.Dispose();

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...


            var providerClient2 = TestHelper.BuildServiceProviderNamedPipe("zb", helper, asServer: false);
            var p2 = providerClient2.GetRequiredService<IDistributedPublisher<int, int>>();

            await p2.PublishAsync(1, 4999);

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
            result.Should().Equal(9999, 4999);

            (providerServer as IDisposable)?.Dispose();
            (providerClient2 as IDisposable)?.Dispose();
        }


        [Fact]
        public async Task SimpleStringString()
        {
            var provider = TestHelper.BuildServiceProviderNamedPipe("barbaz", helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", "abidatoxurusika");

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal("abidatoxurusika");
            }
        }

        [Fact]
        public async Task HugeSizeTest()
        {
            var provider = TestHelper.BuildServiceProviderNamedPipe("z42fds", helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                var ldata = new string('a', 99999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", ldata);

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(ldata);
            }
        }

        [Fact]
        public async Task MoreHugeSizeTest()
        {
            var provider = TestHelper.BuildServiceProviderNamedPipe("fdsew", helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                var ldata1 = new string('a', 99999);
                var ldata2 = new string('b', 99999);
                var ldata3 = new string('c', 99999);
                var ldata = string.Concat(ldata1, ldata2, ldata3);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", ldata);

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(ldata);
            }
        }

        // remote request

        [Fact]
        public async Task RemoteRequestTest()
        {
            var provider = TestHelper.BuildServiceProviderNamedPipe("aewrw", helper);
            using (provider as IDisposable)
            {
                var remoteHandler = provider.GetRequiredService<IRemoteRequestHandler<int, string>>();

                var v = await remoteHandler.InvokeAsync(9999);
                v.Should().Be("ECHO:9999");

                var v2 = await remoteHandler.InvokeAsync(4444);
                v2.Should().Be("ECHO:4444");

                var ex = await Assert.ThrowsAsync<RemoteRequestException>(async () =>
                {
                    var v3 = await remoteHandler.InvokeAsync(-1);
                });
                ex.Message.Should().Contain("NO -1");
            }
        }
    }

    public class MyAsyncHandler : IAsyncRequestHandler<int, string>
    {
        public async ValueTask<string> InvokeAsync(int request, CancellationToken cancellationToken = default)
        {
            await Task.Delay(1);
            if (request == -1)
            {
                throw new Exception("NO -1");
            }
            else
            {
                return "ECHO:" + request.ToString();
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Tests/TcpTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace MessagePipe.Interprocess.Tests
{
    public class TcpTest
    {
        readonly ITestOutputHelper helper;

        public TcpTest(ITestOutputHelper testOutputHelper)
        {
            this.helper = testOutputHelper;
        }

        [Fact]
        public async Task SimpleIntInt()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1784, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<int, int>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<int, int>>();

                var result = new List<int>();
                await s1.SubscribeAsync(1, x =>
                {
                    result.Add(x);
                });

                var result2 = new List<int>();
                await s1.SubscribeAsync(4, x =>
                {
                    result2.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 9999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(4, 888);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 4999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(9999, 4999);
                result2.Should().Equal(888);
            }
        }

        [Fact]
        public async Task TwoPublisher()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1992, helper, asServer: false);
            var provider2 = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1992, helper, asServer: false);
            using (provider as IDisposable)
            using (provider2 as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<int, int>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<int, int>>();
                var p2 = provider2.GetRequiredService<IDistributedPublisher<int, int>>();

                var result = new List<int>();
                await s1.SubscribeAsync(1, x =>
                {
                    result.Add(x);
                });

                var result2 = new List<int>();
                await s1.SubscribeAsync(4, x =>
                {
                    result2.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 9999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p2.PublishAsync(4, 888);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p2.PublishAsync(1, 4999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(9999, 4999);
                result2.Should().Equal(888);
            }
        }

        [Fact]
        public async Task ConnectTwice()
        {
            var providerServer = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1184, helper);
            var providerClient = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1184, helper, asServer: false);
            var p1 = providerClient.GetRequiredService<IDistributedPublisher<int, int>>();
            var s1 = providerServer.GetRequiredService<IDistributedSubscriber<int, int>>();

            var result = new List<int>();
            await s1.SubscribeAsync(1, x =>
            {
                result.Add(x);
            });

            await p1.PublishAsync(1, 9999);
            var scope = (providerClient as IDisposable);

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

            scope?.Dispose();

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...


            var providerClient2 = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1184, helper, asServer: false);
            var p2 = providerClient2.GetRequiredService<IDistributedPublisher<int, int>>();

            await p2.PublishAsync(1, 4999);

            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
            result.Should().Equal(9999, 4999);

            (providerServer as IDisposable)?.Dispose();
            (providerClient2 as IDisposable)?.Dispose();
        }


        [Fact]
        public async Task SimpleStringString()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1436, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", "abidatoxurusika");

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal("abidatoxurusika");
            }
        }

        [Fact]
        public async Task HugeSizeTest()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1436, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                var ldata = new string('a', 99999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", ldata);

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(ldata);
            }
        }

        [Fact]
        public async Task MoreHugeSizeTest()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1436, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                var ldata1 = new string('a', 99999);
                var ldata2 = new string('b', 99999);
                var ldata3 = new string('c', 99999);
                var ldata = string.Concat(ldata1, ldata2, ldata3);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", ldata);

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(ldata);
            }
        }


        [Fact]
        public async Task RemoteRequestTest()
        {
            var provider = TestHelper.BuildServiceProviderTcp("127.0.0.1", 1355, helper, asServer: true);
            using (provider as IDisposable)
            {
                var remoteHandler = provider.GetRequiredService<IRemoteRequestHandler<int, string>>();

                var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));

                var v = await remoteHandler.InvokeAsync(9999, cts.Token);
                v.Should().Be("ECHO:9999");

                var v2 = await remoteHandler.InvokeAsync(4444);
                v2.Should().Be("ECHO:4444");

                var ex = await Assert.ThrowsAsync<RemoteRequestException>(async () =>
                {
                    var v3 = await remoteHandler.InvokeAsync(-1);
                });
                ex.Message.Should().Contain("NO -1");
            }
        }

        [Fact]
        public async Task MoreHugeSizeUdsTest()
        {
            var filePath = System.IO.Path.GetTempFileName();
            if (System.IO.File.Exists(filePath))
            {
                System.IO.File.Delete(filePath);
            }
            try
            {
                var provider = TestHelper.BuildServiceProviderTcpWithUds(filePath, helper);
                using (provider as IDisposable)
                {
                    var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                    var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                    var result = new List<string>();
                    await s1.SubscribeAsync("hogemogeman", x =>
                    {
                        result.Add(x);
                    });

                    var ldata1 = new string('a', 99999);
                    var ldata2 = new string('b', 99999);
                    var ldata3 = new string('c', 99999);
                    var ldata = string.Concat(ldata1, ldata2, ldata3);
                    await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                    await p1.PublishAsync("hogemogeman", ldata);

                    await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                    result.Should().Equal(ldata);
                }
            }
            finally
            {
                if (System.IO.File.Exists(filePath))
                {
                    System.IO.File.Delete(filePath);
                }
            }
        }
        [Fact]
        public async Task RemoteRequestWithUdsTest()
        {
            var filePath = System.IO.Path.GetTempFileName();
            if(System.IO.File.Exists(filePath))
            {
                System.IO.File.Delete(filePath);
            }
            try
            {
                var provider = TestHelper.BuildServiceProviderTcpWithUds(filePath, helper);
                using (provider as IDisposable)
                {
                    var remoteHandler = provider.GetRequiredService<IRemoteRequestHandler<int, string>>();

                    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));

                    var v = await remoteHandler.InvokeAsync(9999, cts.Token);
                    v.Should().Be("ECHO:9999");

                    var v2 = await remoteHandler.InvokeAsync(4444);
                    v2.Should().Be("ECHO:4444");

                    var ex = await Assert.ThrowsAsync<RemoteRequestException>(async () =>
                    {
                        var v3 = await remoteHandler.InvokeAsync(-1);
                    });
                    ex.Message.Should().Contain("NO -1");
                }
            }
            finally
            {
                if(System.IO.File.Exists(filePath))
                {
                    System.IO.File.Delete(filePath);
                }
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Interprocess.Tests/UdpTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace MessagePipe.Interprocess.Tests
{
    public class UdpTest
    {
        readonly ITestOutputHelper helper;

        public UdpTest(ITestOutputHelper testOutputHelper)
        {
            this.helper = testOutputHelper;
        }

        [Fact]
        public async Task SimpleIntInt()
        {
            var provider = TestHelper.BuildServiceProviderUdp("127.0.0.1", 1784, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<int, int>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<int, int>>();

                var result = new List<int>();
                await s1.SubscribeAsync(1, x =>
                {
                    result.Add(x);
                });

                var result2 = new List<int>();
                await s1.SubscribeAsync(4, x =>
                {
                    result2.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 9999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(4, 888);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync(1, 4999);
                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal(9999, 4999);
                result2.Should().Equal(888);
            }
        }

        [Fact]
        public async Task SimpleStringString()
        {
            var provider = TestHelper.BuildServiceProviderUdp("127.0.0.1", 1436, helper);
            using (provider as IDisposable)
            {
                var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                var result = new List<string>();
                await s1.SubscribeAsync("hogemogeman", x =>
                {
                    result.Add(x);
                });

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                await p1.PublishAsync("hogemogeman", "abidatoxurusika");

                await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                result.Should().Equal("abidatoxurusika");
            }
        }
        [Fact]
        public async Task SimpleStringStringUds()
        {
            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
            {
                helper.WriteLine("Currently, windows's unix domain socket does not support UDP, so skipped");
                return;
            }
            var filePath = System.IO.Path.GetTempFileName();
            if(System.IO.File.Exists(filePath))
            {
                System.IO.File.Delete(filePath);
            }
            try
            {
                var provider = TestHelper.BuildServiceProviderUdpWithUds(filePath, helper);
                using (provider as IDisposable)
                {
                    var p1 = provider.GetRequiredService<IDistributedPublisher<string, string>>();
                    var s1 = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

                    var result = new List<string>();
                    await s1.SubscribeAsync("hogemogeman", x =>
                    {
                        result.Add(x);
                    });

                    await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
                    await p1.PublishAsync("hogemogeman", "abidatoxurusika");

                    await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

                    result.Should().Equal("abidatoxurusika");
                }
            }
            finally
            {
                if(System.IO.File.Exists(filePath))
                {
                    System.IO.File.Delete(filePath);
                }
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Nats.Tests/ReadMe.md
================================================
﻿MessagePipe.Nats.Tests
===
This test uses local nats-server.
You should up `docker-compose up`(on sln directory) before test run.


================================================
FILE: tests/MessagePipe.Nats.Tests/MessagePipe.Nats.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AlterNats" Version="1.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
    <PackageReference Include="xunit" Version="2.4.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="3.1.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\MessagePipe.Nats\MessagePipe.Nats.csproj" />
    <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Nats.Tests/NatsPubSub.cs
================================================
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using AlterNats;
using Microsoft.Extensions.DependencyInjection;
using Xunit;

namespace MessagePipe.Nats.Tests;

public class NatsPubSub
{
    [Theory]
    [MemberData(nameof(BasicTestData))]
    public async Task Basic<T>(IEnumerable<T> items)
    {
        var provider = TestHelper.BuildNatsServiceProvider();
        var p = provider.GetRequiredService<IDistributedPublisher<NatsKey, T>>();
        var s = provider.GetRequiredService<IDistributedSubscriber<NatsKey, T>>();

        AutoResetEvent autoResetEvent = new AutoResetEvent(false);
        autoResetEvent.Reset();
        List<T> results = new();
        var natsKey = new NatsKey(Guid.NewGuid().ToString("N"));

        await using var d = await s.SubscribeAsync(natsKey, x =>
        {
            results.Add(x);

            if (results.Count == items.Count())
                autoResetEvent.Set();
        });

        foreach (var item in items)
        {
            await p.PublishAsync(natsKey, item);
        }

        var waitResult = autoResetEvent.WaitOne(5000);

        Assert.True(waitResult, "Timeout");
        Assert.Equal(items.ToArray(), results.ToArray());
    }

    static readonly int[] seed1 = { 24, 45, 99, 41, 98, 7, 81, 8, 26, 56 };

    static object[][] BasicTestData()
    {
        return new[]
        {
            new object[] { seed1 },
            new object[] { seed1.Select(x => $"Test:{x}") },
            new object[] { seed1.Select(x => new SampleClass(x, $"Name{x}")) }
        };
    }
}

public class SampleClass : IEquatable<SampleClass>
{
    public int Id { get; set; }
    public string Name { get; set; }

    public SampleClass(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public bool Equals(SampleClass? other)
    {
        if (ReferenceEquals(null, other))
        {
            return false;
        }

        if (ReferenceEquals(this, other))
        {
            return true;
        }

        return Id == other.Id && Name == other.Name;
    }

    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj))
        {
            return false;
        }

        if (ReferenceEquals(this, obj))
        {
            return true;
        }

        if (obj.GetType() != GetType())
        {
            return false;
        }

        return Equals((SampleClass)obj);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(Id, Name);
    }

    public override string ToString()
    {
        return $"{Id}-{Name}";
    }
}

public static class TestHelper
{
    public static IServiceProvider BuildNatsServiceProvider(INatsSerializer? serializer = default)
    {
        var sc = new ServiceCollection();
        var builder = sc.AddMessagePipe();

        if (serializer == default)
        {
            builder.AddNats(new NatsConnectionFactory());
        }
        else
        {
            builder.AddNats(new NatsConnectionFactory(NatsOptions.Default with
            {
                Serializer = serializer
            }));
        }

        return sc.BuildServiceProvider();
    }
}


================================================
FILE: tests/MessagePipe.Redis.Tests/ReadMe.md
================================================
﻿MessagePipe.Redis.Tests
===
This test uses local redis.
You should up `docker-compose up`(on sln directory) before test run.


================================================
FILE: tests/MessagePipe.Redis.Tests/_TestHelper.cs
================================================
﻿using MessagePipe.Redis;
using Microsoft.Extensions.DependencyInjection;
using StackExchange.Redis;
using System;

namespace MessagePipe.Tests
{
    public static class TestHelper
    {
        public static IServiceProvider BuildServiceProvider()
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe();
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildServiceProvider(Action<MessagePipeOptions> configure)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe(configure);
            return sc.BuildServiceProvider();
        }

        public static ConnectionMultiplexer GetLocalConnectionMultiplexer()
        {
            var c = ConfigurationOptions.Parse("localhost");
            c.ConnectTimeout = 1000;
            try
            {
                return StackExchange.Redis.ConnectionMultiplexer.Connect(c);
            }
            catch (RedisConnectionException ex)
            {
                throw new TimeoutException("Can not connect to redis, if you don't up redis in local, call 'docker-compose up' on project root.", ex);
            }
        }

        public static IServiceProvider BuildRedisServiceProvider(IConnectionMultiplexer connection)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe()
              .AddRedis(connection);
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildRedisServiceProvider(IConnectionMultiplexer connection, Action<MessagePipeOptions> configure)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe(configure)
              .AddRedis(connection);
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildRedisServiceProvider(IConnectionMultiplexer connection, Action<MessagePipeOptions> configure, Action<MessagePipeRedisOptions> redisConfigure)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe(configure)
              .AddRedis(connection, redisConfigure);
            return sc.BuildServiceProvider();
        }
    }
}


================================================
FILE: tests/MessagePipe.Redis.Tests/ConnectionMultiplexerFactoryTest.cs
================================================
﻿using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using StackExchange.Redis;
using Xunit;

namespace MessagePipe.Redis.Tests;

public class ConnectionMultiplexerFactoryTest
{
    [Fact]
    public async Task CreateFromInstance()
    {
        var connection = TestHelper.GetLocalConnectionMultiplexer();
        var services = new ServiceCollection();
        services.AddMessagePipe()
                .AddRedis(connection);
        var sp = services.BuildServiceProvider();

        var publisher = sp.GetRequiredService<IDistributedPublisher<string, string>>();
        var subscriber = sp.GetRequiredService<IDistributedSubscriber<string, string>>();
     
        var results = new List<string>();
        await using var _ = await subscriber.SubscribeAsync("Foo", x => results.Add(x));

        await publisher.PublishAsync("Foo", "Bar");
        await Task.Delay(250);
        results.FirstOrDefault().Should().Be("Bar");
    }

    [Fact]
    public async Task CreateFromGenericType()
    {
        var connection = TestHelper.GetLocalConnectionMultiplexer();
        var services = new ServiceCollection();
        services.AddSingleton<IConnectionMultiplexer>(connection);
        services.AddMessagePipe()
                .AddRedis<TestConnectionMultiplexerFactory>();
        var sp = services.BuildServiceProvider();

        var publisher = sp.GetRequiredService<IDistributedPublisher<string, string>>();
        var subscriber = sp.GetRequiredService<IDistributedSubscriber<string, string>>();
     
        var results = new List<string>();
        await using var _ = await subscriber.SubscribeAsync("Foo", x => results.Add(x));

        await publisher.PublishAsync("Foo", "Bar");
        await Task.Delay(250);
        results.FirstOrDefault().Should().Be("Bar");
    }

    public class TestConnectionMultiplexerFactory : IConnectionMultiplexerFactory
    {
        readonly IConnectionMultiplexer connectionMultiplexer;

        public TestConnectionMultiplexerFactory(IConnectionMultiplexer connectionMultiplexer)
        {
            this.connectionMultiplexer = connectionMultiplexer;
        }

        public IConnectionMultiplexer GetConnectionMultiplexer<TKey>(TKey key)
        {
            return connectionMultiplexer;
        }
    }
}


================================================
FILE: tests/MessagePipe.Redis.Tests/MessagePipe.Redis.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="FluentAssertions" Version="6.6.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
        <PackageReference Include="System.Linq.Async" Version="6.0.1" />
        <PackageReference Include="StackExchange.Redis" Version="2.5.61" />
        <PackageReference Include="xunit" Version="2.4.1" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="coverlet.collector" Version="3.1.2">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe.Redis\MessagePipe.Redis.csproj" />
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Redis.Tests/RedisPubSubKeyedASync.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{
    public class RedisPubSubKeyedASync
    {
        [Fact]
        public async Task SimplePush()
        {
            const string Key1 = "foo";
            const string Key2 = "bar";

            var conection = TestHelper.GetLocalConnectionMultiplexer();
            var provider = TestHelper.BuildRedisServiceProvider(conection);

            var p = provider.GetRequiredService<IDistributedPublisher<string, string>>();
            var s = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

            var result = new List<string>();
            var d1 = await s.SubscribeAsync(Key1, (x) =>
            {
                result.Add("1:" + x);
            });
            var d2 = await s.SubscribeAsync(Key2, (x) => result.Add("2:" + x));
            var d3 = await s.SubscribeAsync(Key1, (x) => result.Add("3:" + x));

            // use BeEquivalentTo, allow different order

            await p.PublishAsync(Key1, "one");
            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

            result.Should().BeEquivalentTo("1:one", "3:one");
            result.Clear();

            await p.PublishAsync(Key2, "one");
            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

            result.Should().BeEquivalentTo("2:one");
            result.Clear();

            await d3.DisposeAsync();

            await p.PublishAsync(Key1, "two");
            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...
            result.Should().BeEquivalentTo("1:two");
            result.Clear();

            await d1.DisposeAsync();
            await d2.DisposeAsync();

            await p.PublishAsync(Key1, "zero");
            await p.PublishAsync(Key2, "zero");
            await Task.Delay(TimeSpan.FromSeconds(1)); // wait for receive data...

            result.Should().Equal();
            result.Clear();
        }

    }
}



================================================
FILE: tests/MessagePipe.Tests/_TestHelper.cs
================================================
﻿using Microsoft.Extensions.DependencyInjection;
using System;

namespace MessagePipe.Tests
{
    public static class TestHelper
    {
        public static IServiceProvider BuildServiceProvider()
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe();
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildServiceProvider(Action<MessagePipeOptions> configure)
        {
            var sc = new ServiceCollection();
            sc.AddMessagePipe(configure);
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildServiceProvider2(Action<IMessagePipeBuilder> configureService)
        {
            var sc = new ServiceCollection();
            var builder = sc.AddMessagePipe();
            configureService(builder);
            return sc.BuildServiceProvider();
        }

        public static IServiceProvider BuildServiceProvider3(Action<MessagePipeOptions> configure, Action<IMessagePipeBuilder> configureService)
        {
            var sc = new ServiceCollection();
            var builder = sc.AddMessagePipe(configure);
            configureService(builder);
            return sc.BuildServiceProvider();
        }
    }
}


================================================
FILE: tests/MessagePipe.Tests/ArrayUtilTest.cs
================================================
﻿#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.

using FluentAssertions;
using MessagePipe.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class ArrayUtilTest
    {
        [Fact]
        public void Add()
        {
            var xs = new int[0];
            for (int i = 0; i < 10; i++)
            {
                var ys = ArrayUtil.ImmutableAdd(xs, 10 * i);

                xs.Length.Should().Be(i);
                ys.Length.Should().Be(i + 1);
                ys.Length.Should().Be(xs.Length + 1);
                for (int j = 0; j < xs.Length; j++)
                {
                    xs[j].Should().Be(10 * j);
                }
                for (int j = 0; j < xs.Length; j++)
                {
                    ys[j].Should().Be(10 * j);
                }

                xs = ys;
            }
        }

        [Fact]
        public void Remove()
        {
            // empty, no match
            {
                var xs = new int[0] { };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 999, (object)null);

                ys.Length.Should().Be(0);
            }
            // one
            {
                var xs = new[] { 10 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 999, (object)null);

                ys.Length.Should().Be(1);

                ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 10, (object)null);
                ys.Length.Should().Be(0);
            }

            // two, fisrt remove
            {
                var xs = new[] { 10, 20 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 10, (object)null);
                ys.Should().Equal(20);
            }
            // two, last remove
            {
                var xs = new[] { 10, 20 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 20, (object)null);
                ys.Should().Equal(10);
            }

            // three, first remove
            {
                var xs = new[] { 10, 20, 30 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 10, (object)null);
                ys.Should().Equal(20, 30);
            }

            // three, middle remove
            {
                var xs = new[] { 10, 20, 30 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 20, (object)null);
                ys.Should().Equal(10, 30);
            }

            // three, last remove
            {
                var xs = new[] { 10, 20, 30 };
                var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == 30, (object)null);
                ys.Should().Equal(10, 20);
            }

            // many patterns
            {
                var sequence = Enumerable.Range(1, 100).Select(x => Enumerable.Range(1, x).Select(y => y * 10).ToArray()).ToArray();

                foreach (var xs in sequence)
                {
                    for (int i = 1; i <= xs.Length; i++)
                    {
                        var ys = ArrayUtil.ImmutableRemove(xs, (x, _) => x == i * 10, (object)null);
                        ys.Should().Equal(Enumerable.Range(1, xs.Length).Select(x => x * 10).Where(x => x != i * 10));
                    }
                }
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/AsAsyncEnumerableTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class AsAsyncEnumerableTest
    {
        [Fact]
        public async Task Standard()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IAsyncPublisher<int>>();
            var subscriber = p.GetRequiredService<IAsyncSubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();


            var l = new List<int>();
            var cts = new CancellationTokenSource();

            _ = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                for (int i = 0; i < 3; i++)
                {
                    publisher.Publish(i);
                    await Task.Yield();
                }
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                cts.Cancel();
            });

            try
            {
                await foreach (var item in subscriber.AsAsyncEnumerable().WithCancellation(cts.Token))
                {
                    l.Add(item);
                }
            }
            catch (OperationCanceledException) { }

            l.Should().Equal(0, 1, 2);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task Keyed()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IAsyncPublisher<string, int>>();
            var subscriber = p.GetRequiredService<IAsyncSubscriber<string, int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();


            var l = new List<int>();
            var cts = new CancellationTokenSource();

            _ = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                for (int i = 0; i < 3; i++)
                {
                    publisher.Publish("foo", i);
                    await Task.Yield();
                }
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                cts.Cancel();
            });

            try
            {
                await foreach (var item in subscriber.AsAsyncEnumerable("foo").WithCancellation(cts.Token))
                {
                    l.Add(item);
                }
            }
            catch (OperationCanceledException) { }

            l.Should().Equal(0, 1, 2);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task Buffered()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IBufferedAsyncPublisher<int>>();
            var subscriber = p.GetRequiredService<IBufferedAsyncSubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            await publisher.PublishAsync(99);

            var l = new List<int>();
            var cts = new CancellationTokenSource();

            _ = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                for (int i = 0; i < 3; i++)
                {
                    publisher.Publish(i);
                    await Task.Yield();
                }
                await Task.Delay(TimeSpan.FromSeconds(0.5));
                cts.Cancel();
            });

            try
            {
                await foreach (var item in subscriber.AsAsyncEnumerable().WithCancellation(cts.Token))
                {
                    l.Add(item);
                }
            }
            catch (OperationCanceledException) { }

            l.Should().Equal(99, 0, 1, 2);

            monitor.SubscribeCount.Should().Be(0);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/BufferedTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class BufferedTest
    {
        [Fact]
        public void Sync()
        {
            var provider = TestHelper.BuildServiceProvider();

            var p = provider.GetRequiredService<IBufferedPublisher<IntClass>>();
            var s = provider.GetRequiredService<IBufferedSubscriber<IntClass>>();

            var l = new List<int>();
            using (s.Subscribe(x => l.Add(x.Value)))
            {
                l.Count.Should().Be(0);
            }

            p.Publish(new IntClass { Value = 9999 }); // set initial value

            using var d2 = s.Subscribe(x => l.Add(x.Value));

            l.Should().Equal(9999);
            p.Publish(new IntClass { Value = 333 });
            l.Should().Equal(9999, 333);

            using var d3 = s.Subscribe(x => l.Add(x.Value));
            l.Should().Equal(9999, 333, 333);
            p.Publish(new IntClass { Value = 11 });
            l.Should().Equal(9999, 333, 333, 11, 11);
            d3.Dispose();
            p.Publish(new IntClass { Value = 4 });
            l.Should().Equal(9999, 333, 333, 11, 11, 4);
        }

        [Fact]
        public async Task ASync()
        {
            var provider = TestHelper.BuildServiceProvider();

            var p = provider.GetRequiredService<IBufferedAsyncPublisher<IntClass>>();
            var s = provider.GetRequiredService<IBufferedAsyncSubscriber<IntClass>>();

            var l = new List<int>();
            using (await s.SubscribeAsync(async (x, _) => { await Task.Yield(); lock (l) { l.Add(x.Value); } }))
            {
                l.Count.Should().Be(0);
            }

            await p.PublishAsync(new IntClass { Value = 9999 }); // set initial value

            using var d2 = await s.SubscribeAsync(async (x, _) => { await Task.Yield(); lock (l) { l.Add(x.Value); } });

            l.Should().Equal(9999);
            await p.PublishAsync(new IntClass { Value = 333 });
            l.Should().Equal(9999, 333);

            using var d3 = await s.SubscribeAsync(async (x, _) => { await Task.Yield(); lock (l) { l.Add(x.Value); } });
            l.Should().Equal(9999, 333, 333);
            await p.PublishAsync(new IntClass { Value = 11 });
            l.Should().Equal(9999, 333, 333, 11, 11);
            d3.Dispose();
            await p.PublishAsync(new IntClass { Value = 4 });
            l.Should().Equal(9999, 333, 333, 11, 11, 4);
        }

        [Fact]
        public async Task WithFilter()
        {
            {
                var provider = TestHelper.BuildServiceProvider();

                var p = provider.GetRequiredService<IBufferedPublisher<IntClass>>();
                var s = provider.GetRequiredService<IBufferedSubscriber<IntClass>>();
                var filter = new IntHandlerFilterr();

                p.Publish(new IntClass { Value = 100 });

                using var d = s.Subscribe(_ => { }, filter);

                p.Publish(new IntClass { Value = 9999 });


                filter.Capture.Should().Equal(100, 9999);
            }
            {
                var provider = TestHelper.BuildServiceProvider();

                var p = provider.GetRequiredService<IBufferedAsyncPublisher<IntClass>>();
                var s = provider.GetRequiredService<IBufferedAsyncSubscriber<IntClass>>();
                var filter = new AsyncIntHandlerFilterr();

                p.Publish(new IntClass { Value = 100 });

#pragma warning disable CS1998
                using var d = await s.SubscribeAsync(async (x, y) => { }, new[] { filter });
#pragma warning restore CS1998

                p.Publish(new IntClass { Value = 9999 });


                filter.Capture.Should().Equal(100, 9999);
            }
        }

        [Fact]
        public void EventFactory()
        {
            var provider = TestHelper.BuildServiceProvider();
            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateBufferedEvent(9999);

            var l = new List<int>();
            var d1 = subscriber.Subscribe(x => l.Add(x));
            var d2 = subscriber.Subscribe(x => l.Add(x * 10));

            l.Should().Equal(9999, 99990);

            publisher.Publish(10);
            publisher.Publish(20);

            var d3 = subscriber.Subscribe(x => l.Add(x * 100));

            publisher.Dispose();

            publisher.Publish(30);
            publisher.Publish(40);

            l.Should().Equal(9999, 99990, 10, 100, 20, 200, 2000);

            d1.Dispose();
            d2.Dispose();
        }

#pragma warning disable CS1998

        [Fact]
        public async Task AsyncEventFactory()
        {
            var provider = TestHelper.BuildServiceProvider();
            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateBufferedAsyncEvent(9999);

            var l = new List<int>();
            var d1 = await subscriber.SubscribeAsync(async (x, _) => l.Add(x));
            var d2 = await subscriber.SubscribeAsync(async (x, _) => l.Add(x * 10));

            l.Should().Equal(9999, 99990);

            await publisher.PublishAsync(10);
            await publisher.PublishAsync(20);

            var d3 = await subscriber.SubscribeAsync(async (x, _) => l.Add(x * 100));

            publisher.Dispose();

            await publisher.PublishAsync(30);
            await publisher.PublishAsync(40);

            l.Should().Equal(9999, 99990, 10, 100, 20, 200, 2000);

            d1.Dispose();
            d2.Dispose();
        }

#pragma warning restore CS1998
    }

    public class IntClass
    {
        public int Value { get; set; }
    }

    public class IntHandlerFilterr : MessageHandlerFilter<IntClass>
    {
        public List<int> Capture { get; set; } = new List<int>();

        public override void Handle(IntClass message, Action<IntClass> next)
        {
            Capture.Add(message.Value);
            next(message);
        }
    }
    public class AsyncIntHandlerFilterr : AsyncMessageHandlerFilter<IntClass>
    {
        public List<int> Capture { get; set; } = new List<int>();

        public override ValueTask HandleAsync(IntClass message, CancellationToken cancellationToken, Func<IntClass, CancellationToken, ValueTask> next)
        {
            Capture.Add(message.Value);
            return next(message, cancellationToken);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/DisaposableBagTest.cs
================================================
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using Xunit;

namespace MessagePipe.Tests
{
    public class DisaposableBagTest
    {
        [Fact]
        public void Static()
        {
            var d1 = new Disposable(1);
            var d2 = new Disposable(2);
            var d3 = new Disposable(3);
            var d4 = new Disposable(4);

            var bag = DisposableBag.Create(d1, d2, d3, d4);

            d1.DisposeCalled.Should().Be(0);
            d2.DisposeCalled.Should().Be(0);
            d3.DisposeCalled.Should().Be(0);
            d4.DisposeCalled.Should().Be(0);

            bag.Dispose();

            d1.DisposeCalled.Should().Be(1);
            d2.DisposeCalled.Should().Be(1);
            d3.DisposeCalled.Should().Be(1);
            d4.DisposeCalled.Should().Be(1);

            bag.Dispose();

            d1.DisposeCalled.Should().Be(1);
            d2.DisposeCalled.Should().Be(1);
            d3.DisposeCalled.Should().Be(1);
            d4.DisposeCalled.Should().Be(1);
        }

        [Fact]
        public void Nth()
        {
            var d = Enumerable.Range(1, 100).Select(x => new Disposable(x)).ToArray();

            var bag = DisposableBag.Create(d); // params IDisposable[]

            foreach (var item in d)
            {
                item.DisposeCalled.Should().Be(0);
            }

            bag.Dispose();

            foreach (var item in d)
            {
                item.DisposeCalled.Should().Be(1);
            }

            bag.Dispose();

            foreach (var item in d)
            {
                item.DisposeCalled.Should().Be(1);
            }
        }

        [Fact]
        public void Builder()
        {
            var builder = DisposableBag.CreateBuilder();
            builder.Build().Dispose(); // OK empty


            var d1 = new Disposable(1);
            var d2 = new Disposable(2);
            var d3 = new Disposable(3);
            var d4 = new Disposable(4);

            builder = DisposableBag.CreateBuilder();

            builder.Add(d1);
            builder.Add(d2);
            builder.Add(d3);
            builder.Add(d4);

            builder.Build().Dispose();

            d1.DisposeCalled.Should().Be(1);
            d2.DisposeCalled.Should().Be(1);
            d3.DisposeCalled.Should().Be(1);
            d4.DisposeCalled.Should().Be(1);

            var d = Enumerable.Range(1, 100).Select(x => new Disposable(x)).ToArray();

            builder = DisposableBag.CreateBuilder();
            foreach (var item in d)
            {
                builder.Add(item);
            }

            builder.Build().Dispose();
            foreach (var item in d)
            {
                item.DisposeCalled.Should().Be(1);
            }
        }

        [Fact]
        public void SingleAssignment()
        {
            {
                var si = DisposableBag.CreateSingleAssignment();
                var d = new Disposable(100);
                si.Disposable = d;
                d.DisposeCalled.Should().Be(0);
                si.Dispose();
                d.DisposeCalled.Should().Be(1);
            }
            {
                var si = DisposableBag.CreateSingleAssignment();
                var d = new Disposable(100);
                si.Disposable = d;
                Assert.Throws<InvalidOperationException>(() => si.Disposable = d);
            }
            {
                var si = DisposableBag.CreateSingleAssignment();
                si.Dispose();
                var d = new Disposable(100);
                si.Disposable = d;
                d.DisposeCalled.Should().Be(1);
            }

            {
                var bag = DisposableBag.CreateBuilder();
                var si = DisposableBag.CreateSingleAssignment();
                var d = new Disposable(100);
                d.SetTo(si).AddTo(bag);
                d.DisposeCalled.Should().Be(0);
                bag.Build().Dispose();
                d.DisposeCalled.Should().Be(1);
            }
        }

        [Fact]
        public void CallOnce()
        {
            var provider = TestHelper.BuildServiceProvider();

            var p = provider.GetRequiredService<IPublisher<int>>();
            var s = provider.GetRequiredService<ISubscriber<int>>();

            var d = DisposableBag.CreateSingleAssignment();

            var list = new List<int>();
            d.Disposable = s.Subscribe(x =>
            {
                list.Add(x);
                d.Dispose();
            });

            p.Publish(100);
            p.Publish(200);
            p.Publish(300);

            list.Should().Equal(100);
        }

        public class Disposable : IDisposable
        {
            public int Number { get; }
            public int DisposeCalled { get; private set; }

            public Disposable(int number)
            {
                this.Number = number;
            }

            public void Dispose()
            {
                DisposeCalled++;
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/EventFactoryTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class EventFactoryTest
    {
        [Fact]
        public void SimplePubSub()
        {
            var provider = TestHelper.BuildServiceProvider();

            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateEvent<int>();

            var l = new List<int>();
            var d1 = subscriber.Subscribe(x => l.Add(x));
            var d2 = subscriber.Subscribe(x => l.Add(x * 10));

            publisher.Publish(10);
            publisher.Publish(20);

            d1.Dispose();

            publisher.Publish(30);

            d2.Dispose();
            
            publisher.Publish(40);

            l.Should().Equal(10, 100, 20, 200, 300);
        }

        [Fact]
        public void UnsubscribeFromPublisher()
        {
            var provider = TestHelper.BuildServiceProvider();

            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateEvent<int>();

            var l = new List<int>();
            var d1 = subscriber.Subscribe(x => l.Add(x));
            var d2 = subscriber.Subscribe(x => l.Add(x * 10));

            publisher.Publish(10);
            publisher.Publish(20);

            publisher.Dispose();

            publisher.Publish(30);
            publisher.Publish(40);

            l.Should().Equal(10, 100, 20, 200);

            d1.Dispose();
            d2.Dispose();
        }

        [Fact]
        public async Task AsyncSimplePubSub()
        {
            var provider = TestHelper.BuildServiceProvider();

            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateAsyncEvent<int>();

            var l = new List<int>();
            var d1 = subscriber.Subscribe(async (x, _) => { await Task.Delay(500); lock (l) { l.Add(x); } });
            var d2 = subscriber.Subscribe(async (x, _) => { await Task.Delay(300); lock (l) { l.Add(x * 10); } });

            await publisher.PublishAsync(10);
            await publisher.PublishAsync(20);

            d1.Dispose();

            await publisher.PublishAsync(30);

            d2.Dispose();

            await publisher.PublishAsync(40);

            l.Should().Equal(100, 10, 200, 20, 300);
        }

        [Fact]
        public async Task AsyncUnsubscribeFromPublisher()
        {
            var provider = TestHelper.BuildServiceProvider();

            var evFactory = provider.GetRequiredService<EventFactory>();

            var (publisher, subscriber) = evFactory.CreateAsyncEvent<int>();

            var l = new List<int>();
            var d1 = subscriber.Subscribe(async (x, _) => { await Task.Delay(500); lock (l) { l.Add(x); } });
            var d2 = subscriber.Subscribe(async (x, _) => { await Task.Delay(300); lock (l) { l.Add(x * 10); } });

            await publisher.PublishAsync(10);
            await publisher.PublishAsync(20);

            publisher.Dispose();

            await publisher.PublishAsync(30);
            await publisher.PublishAsync(40);

            l.Should().Equal(100, 10, 200, 20);

            d1.Dispose();
            d2.Dispose();
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/FirstAsyncTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class FirstAsyncTest
    {
        [Fact]
        public async Task NonCancellationStandard()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IPublisher<int>>();
            var subscriber = p.GetRequiredService<ISubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            var task = subscriber.FirstAsync(CancellationToken.None);

            monitor.SubscribeCount.Should().Be(1);

            publisher.Publish(100);

            var r = await task;

            r.Should().Be(100);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task CancellationStandard()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IPublisher<int>>();
            var subscriber = p.GetRequiredService<ISubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            var cts = new CancellationTokenSource();

            var task = subscriber.FirstAsync(cts.Token);

            monitor.SubscribeCount.Should().Be(1);

            cts.Cancel();

            (await Assert.ThrowsAsync<OperationCanceledException>(async () => await task)).CancellationToken.Should().Be(cts.Token);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task CancellationBeforeSubscribe()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IPublisher<int>>();
            var subscriber = p.GetRequiredService<ISubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            var cts = new CancellationTokenSource();
            cts.Cancel();
            var task = subscriber.FirstAsync(cts.Token);

            monitor.SubscribeCount.Should().Be(0);

            cts.Cancel();

            (await Assert.ThrowsAsync<OperationCanceledException>(async () => await task)).CancellationToken.Should().Be(cts.Token);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task BufferedNonCancellationStandard()
        {
            {
                var p = TestHelper.BuildServiceProvider();
                var publisher = p.GetRequiredService<IBufferedPublisher<IntValue>>();
                var subscriber = p.GetRequiredService<IBufferedSubscriber<IntValue>>();
                var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

                var task = subscriber.FirstAsync(CancellationToken.None);

                monitor.SubscribeCount.Should().Be(1);

                publisher.Publish(new IntValue(100));

                var r = await task;

                r.Value.Should().Be(100);

                monitor.SubscribeCount.Should().Be(0);
            }
            {
                var p = TestHelper.BuildServiceProvider();
                var publisher = p.GetRequiredService<IBufferedPublisher<IntValue>>();
                var subscriber = p.GetRequiredService<IBufferedSubscriber<IntValue>>();
                var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

                publisher.Publish(new IntValue(9999));

                var task = subscriber.FirstAsync(CancellationToken.None);

                monitor.SubscribeCount.Should().Be(0);

                publisher.Publish(new IntValue(100));

                var r = await task;

                r.Value.Should().Be(9999);

                monitor.SubscribeCount.Should().Be(0);
            }
        }

        [Fact]
        public async Task NonCancellationKeyedStandard()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IPublisher<int, int>>();
            var subscriber = p.GetRequiredService<ISubscriber<int, int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            var task = subscriber.FirstAsync(9, CancellationToken.None);

            monitor.SubscribeCount.Should().Be(1);

            publisher.Publish(4, 55);
            monitor.SubscribeCount.Should().Be(1);
            publisher.Publish(9, 100);

            var r = await task;

            r.Should().Be(100);

            monitor.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task NonCancellationAsyncStandard()
        {
            var p = TestHelper.BuildServiceProvider();
            var publisher = p.GetRequiredService<IAsyncPublisher<int>>();
            var subscriber = p.GetRequiredService<IAsyncSubscriber<int>>();
            var monitor = p.GetRequiredService<MessagePipeDiagnosticsInfo>();

            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));

            var task = subscriber.FirstAsync(cts.Token);

            monitor.SubscribeCount.Should().Be(1);

            await publisher.PublishAsync(100);

            var r = await task;

            r.Should().Be(100);

            monitor.SubscribeCount.Should().Be(0);
        }

        class IntValue
        {
            public int Value { get; set; }

            public IntValue(int value)
            {
                this.Value = value;
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/FreeListTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe.Internal;
using System.Linq;
using Xunit;

namespace MessagePipe.Tests
{
    public class FreeListTest
    {
        [Fact]
        public void AddRemoveTrim()
        {
            var list = new FreeList<string>();

            var a = list.Add("a");
            var b = list.Add("b");
            var c = list.Add("c");
            var d = list.Add("d");
            var e = list.Add("e");

            list.GetCount().Should().Be(5);

            var items = list.GetValues();
            items.Count().Should().Be(8);

            items.Where(x => x != null).Should().BeEquivalentTo("a", "b", "c", "d", "e");

            list.Remove(c, true);
            list.Remove(e, true);

            list.GetCount().Should().Be(3);

            list.GetValues().Where(x => x != null).Should().BeEquivalentTo("a", "b", "d");

            foreach (var i in Enumerable.Range(0, 30)) list.Add(i.ToString()); // 30
            list.Remove(a, true);
            list.Remove(b, true);
            list.Remove(d, true);

            list.Add("30");

            list.GetValues().Where(x => x != null).Should().BeEquivalentTo(Enumerable.Range(0, 31).Select(x => x.ToString()));


        }


        [Fact]
        public void ExpandAndShrink()
        {
            var freeList = new FreeList<string>();
            freeList.GetValues().Length.Should().Be(4);

            var a = freeList.Add("a");
            var b = freeList.Add("b");
            var c = freeList.Add("c");
            var d = freeList.Add("d");

            freeList.GetValues().Length.Should().Be(4);

            var e = freeList.Add("e");
            var f = freeList.Add("f");
            var g = freeList.Add("g");
            var h = freeList.Add("h");

            freeList.GetValues().Length.Should().Be(8);

            foreach (var subscription in new[] { a, b, c, d, e, f, g, h }) { freeList.Remove(subscription, true); }
            freeList.GetCount().Should().Be(0);
            freeList.GetValues().Length.Should().Be(8);

            var subscriptions = Enumerable.Range(100, 9).Select(x => freeList.Add(x.ToString())).ToArray();
            freeList.GetCount().Should().Be(9);
            freeList.GetValues().Length.Should().Be(16);

            foreach (var subscription in subscriptions) { freeList.Remove(subscription, true); }
            freeList.GetCount().Should().Be(0);
            freeList.GetValues().Length.Should().Be(4);
        }


        /*
         * 
         * Old implementation

        [Fact]
        public void AddRemoveTrim()
        {
            //var list = new FreeList<int, string>();

            //list.Add(100, "a");
            //list.Add(200, "b");
            //list.Add(300, "c");
            //list.Add(400, "d");
            //list.Add(500, "e");

            //list.Count.Should().Be(5);

            //var items = list.GetUnsafeRawItems();
            //items.Count().Should().Be(8); // inital count

            //items.Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "c", "d", "e" });

            //list.Remove(300);
            //list.Remove(500);

            //list.Count.Should().Be(3);

            //items = list.GetUnsafeRawItems();
            //items.Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "d" });

            //list.Add(600, "f");
            //list.Add(700, "g");
            //list.Add(800, "h");
            //list.Add(900, "i");
            //list.Add(999, "j");

            //list.Count.Should().Be(list.GetUnsafeRawItems().Length);

            //// grow

            //list.Add(1000, "a2");
            //list.Count.Should().Be(9);
            //list.GetUnsafeRawItems().Length.Should().Be(16);
            //list.GetUnsafeRawItems().Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "d", "f", "g", "h", "i", "j", "a2" });

            //list.Add(1001, "b2");
            //list.Add(1002, "c2");
            //list.GetUnsafeRawItems().Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "d", "f", "g", "h", "i", "j", "a2", "b2", "c2" });

            //list.Remove(600);
            //list.Remove(800);
            //list.Remove(900);
            //list.Remove(1002);

            //list.GetUnsafeRawItems().Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "d", "g", "j", "a2", "b2" }); // 7

            //foreach (var i in Enumerable.Range(0, 30)) list.Add(i, i.ToString()); // +30 = 37

            //list.GetUnsafeRawItems().Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "b", "d", "g", "j", "a2", "b2" }.Concat(Enumerable.Range(0, 30).Select(x => x.ToString())));


            //list.Remove(200); // 36

            //foreach (var i in Enumerable.Range(0, 24)) list.Remove(i);

            //list.GetUnsafeRawItems().Where(x => x != null).Should().BeEquivalentTo(new[] { "a", "d", "g", "j", "a2", "b2" }.Concat(Enumerable.Range(24, 6).Select(x => x.ToString())));
        }


        [Fact]
        public void TrimExcess()
        {
            //var freeList = new FreeList<int, string>();

            //// initial 8
            //foreach (var i in Enumerable.Range(10, 8)) freeList.Add(i, i.ToString());

            //// next 16
            //foreach (var i in Enumerable.Range(100, 8)) freeList.Add(i, i.ToString());

            //// morenext 32
            //foreach (var i in Enumerable.Range(1000, 16)) freeList.Add(i, i.ToString());

            //freeList.GetUnsafeRawItems().Length.Should().Be(32);

            //// first shrink = 8
            //foreach (var i in Enumerable.Range(1000, 16)) freeList.Remove(i);
            //foreach (var i in Enumerable.Range(100, 8)) freeList.Remove(i);

            //freeList.GetUnsafeRawItems().Length.Should().Be(16);
            //freeList.GetUnsafeRawItems().Where(x => x != null).Count().Should().Be(8);
        }

        */
    }
}



================================================
FILE: tests/MessagePipe.Tests/GlobalMixFilterTest.cs
================================================
﻿using System;
using Microsoft.Extensions.DependencyInjection;
using System.Collections.Generic;
using Xunit;
using FluentAssertions;

namespace MessagePipe.Tests
{
    public class GlobalMixFilterTest
    {


        [Fact]
        public void WithFilter()
        {
            var store = new DataStore();

            var provider = TestHelper.BuildServiceProvider3(options =>
            {
                options.EnableAutoRegistration = false;
                //options.AddGlobalMessageHandlerFilter<MyFilter<int>>(1200);
                options.AddGlobalMessageHandlerFilter(typeof(MyFilter<>), 1200);
            }, builder =>
            {
                builder.AddMessageHandlerFilter<MyFilter<int>>();
                builder.Services.AddSingleton(store);
            });

            var pub = provider.GetRequiredService<IPublisher<int>>();
            var sub1 = provider.GetRequiredService<ISubscriber<int>>();

            var d1 = sub1.Subscribe(new MyHandler(store), new MyFilter<int>(store) { Order = -10 });

            pub.Publish(9999);

            store.Logs.Should().Equal(
                "Order:-10",
                "Order:999",
                "Order:1099",
                "Order:1200",
                "Handle:9999");
        }


        [Fact]
        public void Request()
        {
            var store = new DataStore();

            var provider = TestHelper.BuildServiceProvider3(options =>
            {
                options.EnableAutoRegistration = false;
                options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
            }, builder =>
            {
                builder.AddRequestHandler<MyRequestHandler>();
                builder.Services.AddSingleton(store);
            });

            var handler = provider.GetRequiredService<IRequestHandler<int, int>>();

            var result = handler.Invoke(1999);
            result.Should().Be(19990);

            store.Logs.Should().Equal(
                "Order:-1799",
                "Order:999",
                "Order:1099",
                "Invoke:1999");
        }

        [Fact]
        public void RequestAll()
        {
            var store = new DataStore();

            var provider = TestHelper.BuildServiceProvider3(options =>
            {
                options.EnableAutoRegistration = false;
                options.AddGlobalRequestHandlerFilter<MyRequestHandlerFilter>(-1799);
            }, builder =>
            {
                builder.AddRequestHandler<MyRequestHandler>();
                builder.AddRequestHandler<MyRequestHandler2>();
                builder.Services.AddSingleton(store);
            });

            var handler = provider.GetRequiredService<IRequestAllHandler<int, int>>();

            var result = handler.InvokeAll(1999);
            result.Should().Equal(19990, 199900);

            store.Logs.Should().Equal(
                "Order:-1799",
                "Order:999",
                "Order:1099",
                "Invoke:1999",
                "Order:-1799",
                "Invoke2:1999");
        }
    }


    public class DataStore
    {
        public List<string> Logs { get; set; }

        public DataStore()
        {
            Logs = new List<string>();
        }
    }


    public class MyFilter<T> : MessageHandlerFilter<T>
    {
        readonly DataStore store;

        public MyFilter(DataStore store)
        {
            this.store = store;
        }

        public override void Handle(T message, Action<T> next)
        {
            store.Logs.Add($"Order:{Order}");
            next(message);
        }
    }

    [MessageHandlerFilter(typeof(MyFilter<int>), Order = 999)]
    [MessageHandlerFilter(typeof(MyFilter<int>), Order = 1099)]
    public class MyHandler : IMessageHandler<int>
    {
        DataStore store;

        public MyHandler(DataStore store)
        {
            this.store = store;
        }

        public void Handle(int message)
        {
            store.Logs.Add("Handle:" + message);
        }
    }

    [RequestHandlerFilter(typeof(MyRequestHandlerFilter), Order = 999)]
    [RequestHandlerFilter(typeof(MyRequestHandlerFilter), Order = 1099)]
    public class MyRequestHandler : IRequestHandler<int, int>
    {
        readonly DataStore store;

        public MyRequestHandler(DataStore store)
        {
            this.store = store;
        }

        public int Invoke(int request)
        {
            store.Logs.Add("Invoke:" + request);
            return request * 10;
        }
    }

    public class MyRequestHandler2 : IRequestHandler<int, int>
    {
        readonly DataStore store;

        public MyRequestHandler2(DataStore store)
        {
            this.store = store;
        }

        public int Invoke(int request)
        {
            store.Logs.Add("Invoke2:" + request);
            return request * 100;
        }
    }

    public class MyRequestHandlerFilter : RequestHandlerFilter<int, int>
    {
        readonly DataStore store;

        public MyRequestHandlerFilter(DataStore store)
        {
            this.store = store;
        }

        public override int Invoke(int request, Func<int, int> next)
        {
            store.Logs.Add($"Order:{Order}");
            return next(request);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/InMemoryDistributedTest.cs
================================================
﻿using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class InMemoryDistributedTest
    {
        [Fact]
        public async Task SimplePush()
        {
            const string Key1 = "foo";
            const string Key2 = "bar";


            var provider = TestHelper.BuildServiceProvider2(x =>
            {
                x.AddInMemoryDistributedMessageBroker();
            });

            var p = provider.GetRequiredService<IDistributedPublisher<string, string>>();
            var s = provider.GetRequiredService<IDistributedSubscriber<string, string>>();

            var result = new List<string>();

            var d1 = await s.SubscribeAsync(Key1, (x) =>
            {
                result.Add("1:" + x);
            });
            var d2 = await s.SubscribeAsync(Key2, (x) => result.Add("2:" + x));
            var d3 = await s.SubscribeAsync(Key1, (x) => result.Add("3:" + x));

            // use BeEquivalentTo, allow different order

            await p.PublishAsync(Key1, "one");

            result.Should().BeEquivalentTo("1:one", "3:one");
            result.Clear();

            await p.PublishAsync(Key2, "one");

            result.Should().BeEquivalentTo("2:one");
            result.Clear();

            await d3.DisposeAsync();

            await p.PublishAsync(Key1, "two");
            result.Should().BeEquivalentTo("1:two");
            result.Clear();

            await d1.DisposeAsync();
            await d2.DisposeAsync();

            await p.PublishAsync(Key1, "zero");
            await p.PublishAsync(Key2, "zero");

            result.Should().Equal();
            result.Clear();
        }

    }
}



================================================
FILE: tests/MessagePipe.Tests/MessagePipe.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
        <SignAssembly>true</SignAssembly>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="FluentAssertions" Version="6.6.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
        <PackageReference Include="System.Linq.Async" Version="6.0.1" />
        <PackageReference Include="xunit" Version="2.4.1" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="coverlet.collector" Version="3.1.2">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MessagePipe\MessagePipe.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: tests/MessagePipe.Tests/MultiRequestHandlerTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{

    public class MultiRequestHandlerTest
    {
        [Fact]
        public void SyncRegister()
        {
            var provider = TestHelper.BuildServiceProvider3(x =>
            {
                x.EnableAutoRegistration = false;
            }, x =>
            {
                x.AddRequestHandler<MultiHandler>();
            });

            var handler1 = provider.GetRequiredService<IRequestHandler<Request1, Response1>>();
            var handler2 = provider.GetRequiredService<IRequestHandler<Request2, Response2>>();

            var req1 = new Request1();
            handler1.Invoke(req1).Request.Should().Be(req1);

            var req2 = new Request2();
            handler2.Invoke(req2).Request.Should().Be(req2);
        }

        [Fact]
        public async Task AsyncRegister()
        {
            var provider = TestHelper.BuildServiceProvider3(x =>
            {
                x.EnableAutoRegistration = false;
            }, x =>
            {
                x.AddAsyncRequestHandler<MultiHandler>();
            });

            var handler1 = provider.GetRequiredService<IAsyncRequestHandler<Request1, Response1>>();
            var handler2 = provider.GetRequiredService<IAsyncRequestHandler<Request2, Response2>>();

            var req1 = new Request1();
            (await handler1.InvokeAsync(req1)).Request.Should().Be(req1);

            var req2 = new Request2();
            (await handler2.InvokeAsync(req2)).Request.Should().Be(req2);
        }

        class MultiHandler :
            IRequestHandler<Request1, Response1>,
            IRequestHandler<Request2, Response2>,
            IAsyncRequestHandler<Request1, Response1>,
            IAsyncRequestHandler<Request2, Response2>
        {
            public Response1 Invoke(Request1 request)
            {
                return new Response1(request);
            }

            public Response2 Invoke(Request2 request)
            {
                return new Response2(request);
            }

            public ValueTask<Response1> InvokeAsync(Request1 request, CancellationToken cancellationToken = default)
            {
                return ValueTask.FromResult(new Response1(request));
            }

            public ValueTask<Response2> InvokeAsync(Request2 request, CancellationToken cancellationToken = default)
            {
                return ValueTask.FromResult(new Response2(request));
            }
        }

        class Request1 { }
        class Request2 { }
        class Response1
        {
            public Request1 Request { get; set; }

            public Response1(Request1 request)
            {
                this.Request = request;
            }
        }

        class Response2
        {
            public Request2 Request { get; set; }

            public Response2(Request2 request)
            {
                Request = request;
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/PubSubKeyedASync.cs
================================================
﻿#pragma warning disable CS1998

using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System.Collections.Generic;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{
    public class PubsubKeyedASync
    {
        [Fact]
        public void SimplePush()
        {
            const string Key1 = "foo";
            const string Key2 = "bar";

            var provider = TestHelper.BuildServiceProvider();

            var info = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
            var p = provider.GetRequiredService<IAsyncPublisher<string, string>>();
            var s = provider.GetRequiredService<IAsyncSubscriber<string, string>>();

            var result = new List<string>();
            var d1 = s.Subscribe(Key1, async (x, _) => result.Add("1:" + x));
            var d2 = s.Subscribe(Key2, async (x, _) => result.Add("2:" + x));
            var d3 = s.Subscribe(Key1, async (x, _) => result.Add("3:" + x));

            info.SubscribeCount.Should().Be(3);

            // use BeEquivalentTo, allow different order

            p.Publish(Key1, "one");
            result.Should().BeEquivalentTo("1:one", "3:one");
            result.Clear();

            p.Publish(Key2, "one");
            result.Should().BeEquivalentTo("2:one");
            result.Clear();

            d3.Dispose();

            p.Publish(Key1, "two");
            result.Should().BeEquivalentTo("1:two");
            result.Clear();

            d1.Dispose();
            d2.Dispose();

            p.Publish(Key1, "zero");
            p.Publish(Key2, "zero");

            result.Should().Equal();
            result.Clear();

            info.SubscribeCount.Should().Be(0);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/PubSubKeyedSync.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System.Collections.Generic;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{
    public class PubSubKeyedSync
    {
        [Fact]
        public void SimplePush()
        {
            const string Key1 = "foo";
            const string Key2 = "bar";

            var provider = TestHelper.BuildServiceProvider();

            var info = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
            var p = provider.GetRequiredService<IPublisher<string, string>>();
            var s = provider.GetRequiredService<ISubscriber<string, string>>();

            var result = new List<string>();
            var d1 = s.Subscribe(Key1, x => result.Add("1:" + x));
            var d2 = s.Subscribe(Key2, x => result.Add("2:" + x));
            var d3 = s.Subscribe(Key1, x => result.Add("3:" + x));

            info.SubscribeCount.Should().Be(3);

            // use BeEquivalentTo, allow different order

            p.Publish(Key1, "one");
            result.Should().BeEquivalentTo("1:one", "3:one");
            result.Clear();

            p.Publish(Key2, "one");
            result.Should().BeEquivalentTo("2:one");
            result.Clear();

            d3.Dispose();

            p.Publish(Key1, "two");
            result.Should().BeEquivalentTo("1:two");
            result.Clear();

            d1.Dispose();
            d2.Dispose();

            p.Publish(Key1, "zero");
            p.Publish(Key2, "zero");

            result.Should().Equal();
            result.Clear();

            info.SubscribeCount.Should().Be(0);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/PubSubKeylessASsync.cs
================================================
﻿#pragma warning disable CS1998

using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{
    public class PubsubKeylessAsync
    {
        [Fact]
        public async Task SameAsSync()
        {
            var provider = TestHelper.BuildServiceProvider();

            var info = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
            var p = provider.GetRequiredService<IAsyncPublisher<string>>();
            var s = provider.GetRequiredService<IAsyncSubscriber<string>>();

            var result = new List<string>();
            var d1 = s.Subscribe(async (x, _) => result.Add("1:" + x));
            var d2 = s.Subscribe(async (x, _) => result.Add("2:" + x));
            var d3 = s.Subscribe(async (x, _) => result.Add("3:" + x));

            info.SubscribeCount.Should().Be(3);

            // use BeEquivalentTo, allow different order

            p.Publish("one");
            result.Should().BeEquivalentTo("1:one", "2:one", "3:one");
            result.Clear();

            p.Publish("one");
            result.Should().BeEquivalentTo("1:one", "2:one", "3:one");
            result.Clear();

            d2.Dispose();

            p.Publish("two");
            result.Should().BeEquivalentTo("1:two", "3:two");
            result.Clear();

            d3.Dispose();
            p.Publish("three");
            result.Should().BeEquivalentTo("1:three");
            result.Clear();

            d1.Dispose();
            result.Should().Equal();
            result.Clear();

            info.SubscribeCount.Should().Be(0);
        }

        [Fact]
        public async Task Async()
        {
            var provider = TestHelper.BuildServiceProvider();

            var p = provider.GetRequiredService<IAsyncPublisher<string>>();
            var s = provider.GetRequiredService<IAsyncSubscriber<string>>();

            s.Subscribe(async (_, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), ct);
                Console.WriteLine("OK?");
            });

            s.Subscribe(async (_, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(5), ct);
                Console.WriteLine("OK2?");
            });

            // require to calc time for testing...
            var cts = new CancellationTokenSource();
            await p.PublishAsync("takoyaki", AsyncPublishStrategy.Sequential, cts.Token);


        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/PubSubKeylessSync.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System.Collections.Generic;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{
    public class PubsubKeylessSync
    {
        [Fact]
        public void SimplePush()
        {
            var provider = TestHelper.BuildServiceProvider();

            var info = provider.GetRequiredService<MessagePipeDiagnosticsInfo>();
            var p = provider.GetRequiredService<IPublisher<string>>();
            var s = provider.GetRequiredService<ISubscriber<string>>();

            var result = new List<string>();
            var d1 = s.Subscribe(x => result.Add("1:" + x));
            var d2 = s.Subscribe(x => result.Add("2:" + x));
            var d3 = s.Subscribe(x => result.Add("3:" + x));

            info.SubscribeCount.Should().Be(3);

            // use BeEquivalentTo, allow different order

            p.Publish("one");
            result.Should().BeEquivalentTo("1:one", "2:one", "3:one");
            result.Clear();

            p.Publish("one");
            result.Should().BeEquivalentTo("1:one", "2:one", "3:one");
            result.Clear();

            d2.Dispose();

            p.Publish("two");
            result.Should().BeEquivalentTo("1:two", "3:two");
            result.Clear();

            d3.Dispose();
            p.Publish("three");
            result.Should().BeEquivalentTo("1:three");
            result.Clear();

            d1.Dispose();
            result.Should().Equal();
            result.Clear();

            info.SubscribeCount.Should().Be(0);
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestAllHandlerAsyncFilterTest.cs
================================================
﻿#pragma warning disable CS1998

using System;
using System.Linq;
using System.Threading.Tasks;
using Xunit;
using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System.Threading;

namespace __MessagePipe.Tests
{
    public class RequestAllHandlerAsyncFilterTest
    {
        [Fact]
        public async Task AsyncFilterTest()
        {
            var provider = TestHelper.BuildServiceProvider();
            var handler = provider.GetRequiredService<IAsyncRequestAllHandler<Ping, Pong>>();

            var nullPongs = await handler.InvokeAllAsync(new Ping(null));

            nullPongs.Should().ContainEquivalentOf(new Pong("ping was null."));
            nullPongs.Should().ContainEquivalentOf(new Pong("ping was null!"));
        }

        [Fact]
        public async Task AsyncFilterLazyTest()
        {
            var provider = TestHelper.BuildServiceProvider();
            var handler = provider.GetRequiredService<IAsyncRequestAllHandler<Ping, Pong>>();

            var nullPongs = await handler.InvokeAllLazyAsync(new Ping(null)).ToArrayAsync();

            nullPongs.Should().ContainEquivalentOf(new Pong("ping was null."));
            nullPongs.Should().ContainEquivalentOf(new Pong("ping was null!"));
        }

        public class PingPongHandlerAsyncFilter : AsyncRequestHandlerFilter<Ping, Pong>
        {
            public override async ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken, Func<Ping, CancellationToken, ValueTask<Pong>> next)
            {
                if (request.AnyValue == null)
                {
                    var ret = new Pong("ping was null.");
                    return ret;
                }
                return new Pong(request.AnyValue);
            }
        }
        public class PingPongHandlerAsyncFilter2 : AsyncRequestHandlerFilter<Ping, Pong>
        {
            public override async ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken, Func<Ping, CancellationToken, ValueTask<Pong>> next)
            {
                if (request.AnyValue == null)
                {
                    var ret = new Pong("ping was null!");
                    return ret;
                }
                return new Pong(request.AnyValue);
            }
        }

        public class Ping
        {
            public string? AnyValue;
            public Ping(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        public class Pong
        {
            public string? AnyValue;
            public Pong(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }

        [AsyncRequestHandlerFilter(typeof(PingPongHandlerAsyncFilter))]
        class AsyncPingPongHandler : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                cancellationToken.ThrowIfCancellationRequested();
                return ValueTask.FromResult(new Pong(request.AnyValue));
            }
        }

        [AsyncRequestHandlerFilter(typeof(PingPongHandlerAsyncFilter2))]
        class AsyncPingPongHandler2 : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                cancellationToken.ThrowIfCancellationRequested();
                return ValueTask.FromResult(new Pong(request.AnyValue + request.AnyValue));
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestAllHandlerAsyncTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{

    public class RequestAllHandlerASyncTest
    {
        [Fact]
        public async Task TestAsyncHandling()
        {

            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IAsyncRequestAllHandler<Ping, Pong>>();

            var pongs = await pingHandler.InvokeAllAsync(new Ping("myon!"));

            pongs.Should().ContainEquivalentOf(new Pong("myon!myon!"));
            pongs.Should().ContainEquivalentOf(new Pong("myon!"));
        }
        [Fact]
        public async Task TestLazyAsyncHandling()
        {

            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IAsyncRequestAllHandler<Ping, Pong>>();

            var pongs = await pingHandler.InvokeAllLazyAsync(new Ping("myon!")).ToArrayAsync();

            pongs.Should().ContainEquivalentOf(new Pong("myon!myon!"));
            pongs.Should().ContainEquivalentOf(new Pong("myon!"));
        }
        [Fact]
        public void TestCancellation()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IAsyncRequestAllHandler<Ping, Pong>>();

            var source = new CancellationTokenSource();
            var token = source.Token;

            source.Cancel();
            var pongs = pingHandler.Awaiting(x => x.InvokeAllAsync(new Ping("hoge"), token)).Should()
                .ThrowAsync<OperationCanceledException>();

        }

        class Ping
        {
            public string AnyValue;
            public Ping(string anyValue)
            {
                AnyValue = anyValue;
            }
        }
        class Pong
        {
            public string AnyValue;
            public Pong(string anyValue)
            {
                AnyValue = anyValue;
            }
        }


        class AsyncPingPongHandler : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                cancellationToken.ThrowIfCancellationRequested();
                return ValueTask.FromResult(new Pong(request.AnyValue));
            }
        }

        class AsyncPingPongTwiceHandler : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                cancellationToken.ThrowIfCancellationRequested();
                return ValueTask.FromResult(new Pong(request.AnyValue + request.AnyValue));
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestAllHandlerFilterTest.cs
================================================
﻿using System;
using Xunit;
using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;

namespace __MessagePipe.Tests
{
    public class RequestAllHandlerFilterTest
    {
        [Fact]
        public void FilterTest()
        {
            var provider = TestHelper.BuildServiceProvider();
            var handler = provider.GetRequiredService<IRequestAllHandler<Ping, Pong>>();

            var nullPing = new Ping(null);

            var validPong = handler.InvokeAll(nullPing);
            var nullPong = handler.InvokeAll(nullPing);

            validPong.Should().ContainEquivalentOf(new Pong("ping was null."));
            nullPong.Should().ContainEquivalentOf(new Pong("ping was null!"));
        }

        public class PingPongHandlerFilter : RequestHandlerFilter<Ping, Pong>
        {
            public override Pong Invoke(Ping request, Func<Ping, Pong> next)
            {
                if (request.AnyValue == null)
                {
                    var ret = new Pong("ping was null.");
                    return ret;
                }
                return new Pong(request.AnyValue);
            }
        }
        public class PingPongHandlerFilter2 : RequestHandlerFilter<Ping, Pong>
        {
            public override Pong Invoke(Ping request, Func<Ping, Pong> next)
            {
                if (request.AnyValue == null)
                {
                    var ret = new Pong("ping was null!");
                    return ret;
                }
                return new Pong(request.AnyValue);
            }
        }

        public class Ping
        {
            public string? AnyValue;

            public Ping(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        public class Pong
        {
            public string? AnyValue;

            public Pong(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        [RequestHandlerFilter(typeof(PingPongHandlerFilter))]
        class PingPongHandler : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.AnyValue);
            }
        }
        [RequestHandlerFilter(typeof(PingPongHandlerFilter2))]
        class PingPongHandler2 : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.AnyValue);
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestAllHandlerTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{

    public class RequestAllHandlerTest
    {
        [Fact]
        public void TestHandling()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IRequestAllHandler<Ping, Pong>>();

            var pongs = pingHandler.InvokeAll(new Ping("myon!"));

            pongs.Should().BeEquivalentTo(new[] { new Pong("myon!"), new Pong("myon!myon!")});

        }
        [Fact]
        public void TestLazyHandling()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IRequestAllHandler<Ping, Pong>>();

            var pongs = pingHandler.InvokeAllLazy(new Ping("myon!"));

            pongs.Should().BeEquivalentTo(new[] { new Pong("myon!"), new Pong("myon!myon!")});

        }
        [Fact]
        public void TestCancellation()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IRequestAllHandler<NotImplementedPing, NotImplementedPong>>();

            pingHandler.Invoking(x => x.InvokeAll(new NotImplementedPing())).Should().Throw<NotImplementedException>();
        }

        class Ping
        {
            public string AnyValue;

            public Ping(string anyValue)
            {
                AnyValue = anyValue;
            }
        }
        class Pong
        {
            public string AnyValue;

            public Pong(string anyValue)
            {
                AnyValue = anyValue;
            }
        }
        class PingPongHandler : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.AnyValue);
            }
        }
        class PingPongTwiceHandler : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.AnyValue + request.AnyValue);
            }
        }
        class NotImplementedPing { }
        class NotImplementedPong { }
        class NotImplementedPingPongHandler : IRequestHandler<NotImplementedPing, NotImplementedPong>
        {
            public NotImplementedPong Invoke(NotImplementedPing request)
            {
                throw new NotImplementedException();
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestHandlerAsyncFilterTest.cs
================================================
﻿
#pragma warning disable CS1998

using System;
using System.Threading.Tasks;
using Xunit;
using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System.Threading;

namespace __MessagePipe.Tests
{
    public class RequestHandlerAsyncFilterTest
    {
        [Fact]
        public async Task AsyncFilterTest()
        {
            var provider = TestHelper.BuildServiceProvider();
            var handler = provider.GetRequiredService<IAsyncRequestHandler<Ping, Pong>>();

            var validPing = new Ping("ping");
            var nullPing = new Ping(null);

            var validPong = await handler.InvokeAsync(validPing);
            var nullPong = await handler.InvokeAsync(nullPing);

            validPong.AnyValue.Should().Be("ping");
            nullPong.AnyValue.Should().Be("ping was null.");
        }

        class AsyncPingPongHandlerFilter : AsyncRequestHandlerFilter<Ping, Pong>
        {

            public override async ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken, Func<Ping, CancellationToken, ValueTask<Pong>> next)
            {
                if (request.Value == null)
                {
                    var ret = new Pong("ping was null.");
                    return ret;
                }
                return new Pong(request.Value);
            }
        }

        public class Ping
        {
            public string? Value;

            public Ping(string? anyValue)
            {
                Value = anyValue;
            }
        }
        public class Pong
        {
            public string? AnyValue;

            public Pong(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        [AsyncRequestHandlerFilter(typeof(AsyncPingPongHandlerFilter))]
        class AsyncPingPongHandler : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                return ValueTask.FromResult(new Pong(request.Value));
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestHandlerAsyncTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{

    public class RequestHandlerAsyncTest
    {

        [Fact]
        public async Task TestAsyncHandling()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IAsyncRequestHandler<Ping, Pong>>();

            var pong = await pingHandler.InvokeAsync(new Ping("myon!"));

        }

        [Fact]
        public void TestCancellation()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IAsyncRequestHandler<Ping, Pong>>();

            CancellationTokenSource source = new();
            var token = source.Token;

            source.Cancel();
            pingHandler.Awaiting(x => x.InvokeAsync(new Ping("hoge"), token)).Should().ThrowAsync<OperationCanceledException>();

        }


        class Ping
        {
            public string AnyValue;
            public Ping(string anyValue)
            {
                AnyValue = anyValue;
            }
        }
        class Pong
        {
            public string AnyValue;
            public Pong(string anyValue)
            {
                AnyValue = anyValue;
            }
        }


        class AsyncPingPongHandler : IAsyncRequestHandler<Ping, Pong>
        {
            public ValueTask<Pong> InvokeAsync(Ping request, CancellationToken cancellationToken = default)
            {
                cancellationToken.ThrowIfCancellationRequested();
                return ValueTask.FromResult(new Pong(request.AnyValue + request.AnyValue));
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestHandlerFilterTest.cs
================================================
﻿using System;
using Xunit;
using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;

namespace __MessagePipe.Tests
{
    public class RequestHandlerFilterTest
    {
        [Fact]
        public void FilterTest()
        {
            var provider = TestHelper.BuildServiceProvider();
            var handler = provider.GetRequiredService<IRequestHandler<Ping, Pong>>();

            var validPing = new Ping("ping");
            var nullPing = new Ping(null);

            var validPong = handler.Invoke(validPing);
            var nullPong = handler.Invoke(nullPing);

            validPong.AnyValue.Should().Be("ping");
            nullPong.AnyValue.Should().Be("ping was null.");
        }

        public class PingPongHandlerFilter : RequestHandlerFilter<Ping, Pong>
        {
            public override Pong Invoke(Ping request, Func<Ping, Pong> next)
            {
                if (request.AnyValue == null)
                {
                    var ret = new Pong("ping was null.");
                    return ret;
                }
                return new Pong(request.AnyValue);
            }
        }

        public class Ping
        {
            public string? AnyValue;

            public Ping(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        public class Pong
        {
            public string? AnyValue;

            public Pong(string? anyValue)
            {
                AnyValue = anyValue;
            }
        }
        [RequestHandlerFilter(typeof(PingPongHandlerFilter))]
        class PingPongHandler : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.AnyValue);
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/RequestHandlerTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe;
using MessagePipe.Tests;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using Xunit;

// for check diagnostics, modify namespace.
namespace __MessagePipe.Tests
{

    public class RequestHandlerTest
    {
        [Fact]
        public void TestHandling()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IRequestHandler<Ping, Pong>>();

            var pong = pingHandler.Invoke(new Ping("myon!"));

            pong.Value.Should().Be("myon!");
        }
        [Fact]
        public void TestCancellation()
        {
            var provider = TestHelper.BuildServiceProvider();
            var pingHandler = provider.GetRequiredService<IRequestHandler<NotImplementedPing, NotImplementedPong>>();

            pingHandler.Invoking(x => x.Invoke(new NotImplementedPing())).Should().Throw<NotImplementedException>();
        }

        class Ping
        {
            public string Value;

            public Ping(string anyValue)
            {
                Value = anyValue;
            }
        }
        class Pong
        {
            public string Value;

            public Pong(string anyValue)
            {
                Value = anyValue;
            }
        }

        class PingPongHandler : IRequestHandler<Ping, Pong>
        {
            public Pong Invoke(Ping request)
            {
                return new Pong(request.Value);
            }
        }

        class NotImplementedPing { }
        class NotImplementedPong { }
        class NotImplementedPingPongHandler : IRequestHandler<NotImplementedPing, NotImplementedPong>
        {
            public NotImplementedPong Invoke(NotImplementedPing request)
            {
                throw new NotImplementedException();
            }
        }
    }
}



================================================
FILE: tests/MessagePipe.Tests/WhenAllTest.cs
================================================
﻿using FluentAssertions;
using MessagePipe.Internal;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace MessagePipe.Tests
{
    public class WhenAllTest
    {
        [Fact]
        public async Task OkWhenAll()
        {
            var handlers = Enumerable.Range(1, 10)
                .Select((x, i) => (i % 2 == 0) ? null : new AsyncHandler { DelaySpan = (TimeSpan.FromMilliseconds(1000 - (i * 100))) })
                .Select((x, i) => (i == 3) ? (IAsyncMessageHandler<int>)new CompletedHandler() : x)
                .ToArray();

            await new AsyncHandlerWhenAll<int>(handlers, 999, CancellationToken.None);

            handlers.OfType<ICheck>().Select(x => x.ReceivedMessage).Should().Equal(999, 999, 999, 999, 999);

            // again(use pool?)
            handlers = Enumerable.Range(1, 10)
              .Select((x, i) => (i % 2 == 0) ? null : new AsyncHandler { DelaySpan = TimeSpan.FromSeconds(1) })
              .Select((x, i) => (i == 3) ? (IAsyncMessageHandler<int>)new CompletedHandler() : x)
              .ToArray();

            await new AsyncHandlerWhenAll<int>(handlers, 999, CancellationToken.None);

            handlers.OfType<ICheck>().Select(x => x.ReceivedMessage).Should().Equal(999, 999, 999, 999, 999);
        }

        [Fact]
        public async Task WithExceptionWhenAll()
        {
            var handlers = Enumerable.Range(1, 10)
                .Select(i => (i % 2 == 0) ? null : new AsyncHandler { DelaySpan = TimeSpan.FromSeconds(1) })
                .Select((x, i) => (i == 3) ? (IAsyncMessageHandler<int>)new CompletedHandler() : x)
                .Select((x, i) => (i == 4) ? new ExceptionHandler() : x)
                .ToArray();

            await Assert.ThrowsAsync<WhenAllTestException>(async () =>
               await new AsyncHandlerWhenAll<int>(handlers, 999, CancellationToken.None));
        }

        [Fact]
        public async Task RequestWhenAll()
        {
            var handlers = Enumerable.Range(1, 10)
                .Select(i => new AsyncHandler2 { DelaySpan = (TimeSpan.FromMilliseconds(1000 - (i * 100))) })
                .Select((x, i) => (i == 3) ? (IAsyncRequestHandler<int, int>)new CompletedHandler2() : x)
                .ToArray();

            var xs = await new AsyncRequestHandlerWhenAll<int, int>(handlers, 10, CancellationToken.None);

            xs.Should().Equal(100, 100, 100, 100, 100, 100, 100, 100, 100, 100);

            // again(use pool?)
            handlers = Enumerable.Range(1, 10)
               .Select(i => new AsyncHandler2 { DelaySpan = (TimeSpan.FromMilliseconds(1000 - (i * 100))) })
               .Select((x, i) => (i == 3) ? (IAsyncRequestHandler<int, int>)new CompletedHandler2() : x)
               .ToArray();


            xs = await new AsyncRequestHandlerWhenAll<int, int>(handlers, 10, CancellationToken.None);

            xs.Should().Equal(100, 100, 100, 100, 100, 100, 100, 100, 100, 100);
        }

        [Fact]
        public async Task RequestWhenAllWithException()
        {
            var handlers = Enumerable.Range(1, 10)
                .Select(i => new AsyncHandler2 { DelaySpan = (TimeSpan.FromMilliseconds(1000 - (i * 100))) })
                .Select((x, i) => (i == 3) ? (IAsyncRequestHandler<int, int>)new CompletedHandler2() : x)
                .Select((x, i) => (i == 4) ? new ExceptionHandler2() : x)
                .ToArray();

            await Assert.ThrowsAsync<WhenAllTestException>(async () =>
               await new AsyncRequestHandlerWhenAll<int, int>(handlers, 999, CancellationToken.None));
        }
    }

    public interface ICheck
    {
        int ReceivedMessage { get; }
    }

    class WhenAllTestException : Exception
    {

    }

    class AsyncHandler : IAsyncMessageHandler<int>, ICheck
    {
        public TimeSpan DelaySpan { get; set; }
        public int ReceivedMessage { get; private set; }

        public async ValueTask HandleAsync(int message, CancellationToken cancellationToken)
        {
            await Task.Delay(DelaySpan);
            ReceivedMessage = message;
        }
    }

    class ExceptionHandler : IAsyncMessageHandler<int>, ICheck
    {
        public int ReceivedMessage { get; private set; }

        public async ValueTask HandleAsync(int message, CancellationToken cancellationToken)
        {
            await Task.Delay(TimeSpan.FromMilliseconds(400));
            throw new WhenAllTestException();
        }
    }

    class CompletedHandler : IAsyncMessageHandler<int>, ICheck
    {
        public int ReceivedMessage { get; private set; }

        public ValueTask HandleAsync(int message, CancellationToken cancellationToken)
        {
            ReceivedMessage = message;
            return default;
        }
    }


    class AsyncHandler2 : IAsyncRequestHandler<int, int>
    {
        public TimeSpan DelaySpan { get; set; }

        public async ValueTask<int> InvokeAsync(int message, CancellationToken cancellationToken)
        {
            await Task.Delay(DelaySpan);
            return message * message;
        }
    }

    class ExceptionHandler2 : IAsyncRequestHandler<int, int>
    {
        public async ValueTask<int> InvokeAsync(int message, CancellationToken cancellationToken)
        {
            await Task.Delay(TimeSpan.FromMilliseconds(400));
            throw new WhenAllTestException();
        }
    }

    class CompletedHandler2 : IAsyncRequestHandler<int, int>
    {
        public ValueTask<int> InvokeAsync(int message, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(message * message);
        }
    }
}



================================================
FILE: tools/PostBuildUtility/PostBuildUtility.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Configurations>Debug;Release;WinBenchmark</Configurations>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="ConsoleAppFramework" Version="4.0.6" />
    </ItemGroup>

</Project>



================================================
FILE: tools/PostBuildUtility/Program.cs
================================================
﻿using ConsoleAppFramework;
using Microsoft.Extensions.Hosting;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace PostBuildUtility
{
    class Program : ConsoleAppBase
    {
        static async Task Main(string[] args)
        {
            await Host.CreateDefaultBuilder().RunConsoleAppFrameworkAsync<Program>(args);
        }

        [Command("replace-to-unity")]
        public void ReplaceToUnity([Option(0)] string directory)
        {
            var mutex = new Mutex(false, "MessagePipe." + nameof(ReplaceToUnity));
            if (!mutex.WaitOne(0, false))
            {
                System.Console.WriteLine("running in another process, quit.");
                return; // mutex will release after quit.
            }

            var replaceSet = new Dictionary<string, string>
            {
                // to UniTask
                {", ValueTaskSourceOnCompletedFlags flags", "" },
                {"ValueTaskAwaiter<TResponse>", "Cysharp.Threading.Tasks.UniTask<TResponse>.Awaiter" },
                {"ValueTaskAwaiter", "Cysharp.Threading.Tasks.UniTask.Awaiter" },
                {"ValueTaskSourceStatus", "UniTaskStatus" },
                {"IValueTaskSource", "IUniTaskSource" },
                {"TaskCompletionSource", "UniTaskCompletionSource" },
                {"ManualResetValueTaskSourceCore", "UniTaskCompletionSourceCore" },
                {"ValueTask", "UniTask" },
                {"IAsyncDisposable", "IUniTaskAsyncDisposable" },
                {"using System.Threading.Tasks.Sources;", "" },
                {"System.Threading.Tasks", "Cysharp.Threading.Tasks" },
                {"IAsyncEnumerable", "IUniTaskAsyncEnumerable" },
                {"IAsyncEnumerator", "IUniTaskAsyncEnumerator" },
                {"[EnumeratorCancellation]", "" },
                {" core.OnCompleted(continuation, state, token, flags);", " core.OnCompleted(continuation, state, token);" },
                {"core.SetException", "core.TrySetException" },
                {"core.SetResult", "core.TrySetResult" },
                {"public UniTaskStatus GetStatus(short token)", @"void IUniTaskSource.GetResult(short token) => GetResult(token);
        public UniTaskStatus UnsafeGetStatus() => core.UnsafeGetStatus();
        public /*replaced*/ UniTaskStatus GetStatus(short token)" },

                // Remove nullable
                {"T?", "T" },
                {"T[]?", "T[]" },
                {"Assembly[]?", "Assembly[]" },
                {"Type[]?", "Type[]" },
                {"ExceptionDispatchInfo?", "ExceptionDispatchInfo" },
                {"Type?", "Type" },
                {"AsyncRequestHandlerFilter[]?", "AsyncRequestHandlerFilter[]" },
                {"RequestHandlerFilter[]?", "RequestHandlerFilter[]" },
                {"AsyncMessageHandlerFilter[]?", "AsyncMessageHandlerFilter[]" },
                {"MessageHandlerFilter[]?", "MessageHandlerFilter[]" },
                {"IAsyncMessageHandler<T>?", "IAsyncMessageHandler<T>" },
                {"IAsyncMessageHandler<TMessage>?", "IAsyncMessageHandler<TMessage>" },
                {"IMessageHandler<TMessage>?", "IMessageHandler<TMessage>" },
                {"AwaiterNode?", "AwaiterNode" },
                {"default!", "default" },
                {"null!", "null" },
                {"result!", "result" },
                {"where TKey : notnull", ""},
                {"IServiceProvider?", "IServiceProvider"},
                {"EventFactory?", "EventFactory"},
                {"MessagePipeDiagnosticsInfo?", "MessagePipeDiagnosticsInfo"},
                {"IDisposable?", "IDisposable"},
                {"TMessage?", "TMessage"},
                {"string?", "string"},
                {"lastMessage!", "lastMessage"},
                {"state!", "state"},
                {"object?", "object"},
                {"IInterprocessKey?", "IInterprocessKey"},
                {"Func<CancellationToken, Task>?", "Func<CancellationToken, System.Threading.Tasks.Task>" },
                {"(genArgs[0].FullName!, genArgs[1].FullName)!", "(genArgs[0].FullName, genArgs[1].FullName)" },
                {"FullName!", "FullName" },

                {"task!", "task" },
                {"!.Invoke", ".Invoke" },
                {"!.GetValue", ".GetValue" },

                // final transform
                {"Cysharp.Threading.Tasks.Task", "System.Threading.Tasks.Task" },
                {"UniUniTaskCompletionSource", "UniTaskCompletionSource" }
            };

            System.Console.WriteLine("Start to replace code, remove nullability and use UniTask.");
            var noBomUtf8 = new UTF8Encoding(false);

            foreach (var path in Directory.EnumerateFiles(directory, "*.cs", SearchOption.AllDirectories))
            {
                var text = File.ReadAllText(path, Encoding.UTF8);

                foreach (var item in replaceSet)
                {
                    text = text.Replace(item.Key, item.Value);
                }

                File.WriteAllText(path, text, noBomUtf8);
            }

            System.Console.WriteLine("Replace complete.");
        }
    }
}



================================================
FILE: .github/dependabot.yaml
================================================
# ref: https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly" # Check for updates to GitHub Actions every week
    cooldown:
      default-days: 14 # Wait 14 days before creating another PR for the same dependency. This will prevent vulnerability on the package impact.
    ignore:
      # I just want update action when major/minor version is updated. patch updates are too noisy.
      - dependency-name: "*"
        update-types:
          - version-update:semver-patch



================================================
FILE: .github/workflows/build-debug.yaml
================================================
name: Build-Debug

on:
  push:
    branches:
      - "master"
  pull_request:
    branches:
      - master

jobs:
  build-dotnet:
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    services:
      redis:
        image: redis
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      nats:
        image: nats
        ports:
          - 4222:4222
    steps:
      - uses: Cysharp/Actions/.github/actions/checkout@main
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
        with:
          dotnet-version: |
            6.0.x
      - run: dotnet build ./tools/PostBuildUtility/ -c Release
      - run: dotnet build -c Release
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release --no-build  -p:IncludeSymbols=true -o $GITHUB_WORKSPACE/artifacts
      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: MessagePipe.Analyzer
          path: ./src/MessagePipe.Analyzer/bin/Release/netstandard2.0/MessagePipe.Analyzer.dll
          retention-days: 1

  build-unity:
    if: ${{ ((github.event_name == 'push' && github.repository_owner == 'Cysharp') || startsWith(github.event.pull_request.head.label, 'Cysharp:')) && github.triggering_actor != 'dependabot[bot]' }}
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        unity: ["2021.3.41f1", "2022.3.39f1", "6000.0.12f1"] # Test with LTS
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 20
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - uses: Cysharp/Actions/.github/actions/checkout@main

      # Execute scripts: Export Package
      #  /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
      - name: Build Unity (.unitypacakge)
        if: ${{ startsWith(matrix.unity, '2021') }} # only execute once
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/MessagePipe.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: PackageExporter.Export

      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/MessagePipe.Unity

      # Execute Unittest
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend IL2CPP /BuildTarget StandaloneLinux64
      - name: Build UnitTest (IL2CPP)
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/MessagePipe.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: UnitTestBuilder.BuildUnitTest
          customParameters: "/headless /ScriptBackend IL2CPP"
      - name: Check UnitTest file is generated
        run: ls -lR ./src/MessagePipe.Unity/bin/UnitTest
      - name: Execute UnitTest
        run: ./src/MessagePipe.Unity/bin/UnitTest/StandaloneLinux64_IL2CPP/test

      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        if: ${{ startsWith(matrix.unity, '2021') }} # only execute once
        with:
          name: MessagePipe.${{ matrix.unity }}.unitypackage.zip
          path: ./src/MessagePipe.Unity/*.unitypackage
          retention-days: 1



================================================
FILE: .github/workflows/build-release.yaml
================================================
name: build-release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "tag: git tag you want create. (sample 1.0.0)"
        required: true
      dry-run:
        description: "dry-run: true will never create relase/nuget."
        required: true
        default: false
        type: boolean

jobs:
  update-packagejson:
    permissions:
      actions: read
      contents: write
    uses: Cysharp/Actions/.github/workflows/update-packagejson.yaml@main
    with:
      file-path: |
        ./src/MessagePipe.Unity/Assets/Plugins/MessagePipe/package.json
        ./src/MessagePipe.Unity/Assets/Plugins/MessagePipe.VContainer/package.json
        ./src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Zenject/package.json
        ./src/MessagePipe.Unity/Assets/Plugins/MessagePipe.Interprocess/package.json
      tag: ${{ inputs.tag }}
      dry-run: ${{ inputs.dry-run }}

  build-dotnet:
    needs: [update-packagejson]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    services:
      redis:
        image: redis
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      nats:
        image: nats
        ports:
          - 4222:4222
    steps:
      - run: echo ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
        with:
          dotnet-version: |
            6.0.x
      # build and pack
      - run: dotnet build ./tools/PostBuildUtility/ -c Release
      - run: dotnet build -c Release -p:Version=${{ inputs.tag }}
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release --no-build -p:Version=${{ inputs.tag }} -o ./publish
      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: nuget
          path: ./publish/
          if-no-files-found: error
          retention-days: 1
      # Upload analyzer.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: MessagePipe.Analyzer
          path: ./src/MessagePipe.Analyzer/bin/Release/netstandard2.0/MessagePipe.Analyzer.dll
          retention-days: 1

  build-unity:
    needs: [update-packagejson]
    strategy:
      matrix:
        unity: ["2021.3.41f1"]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - run: echo ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}
      # Execute scripts: Export Package
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
      - name: Build Unity (.unitypacakge)
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/MessagePipe.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: PackageExporter.Export

      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/MessagePipe.Unity

      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: MessagePipe.Unity.${{ inputs.tag }}.unitypackage
          path: ./src/MessagePipe.Unity/MessagePipe*.${{ inputs.tag }}.unitypackage
          if-no-files-found: error
          retention-days: 1

  # release
  create-release:
    needs: [update-packagejson, build-dotnet, build-unity]
    permissions:
      contents: write
      id-token: write # required for NuGet Trusted Publish
    uses: Cysharp/Actions/.github/workflows/create-release.yaml@main
    with:
      commit-id: ${{ needs.update-packagejson.outputs.sha }}
      dry-run: ${{ inputs.dry-run }}
      tag: ${{ inputs.tag }}
      nuget-push: true
      release-upload: true
      release-asset-path: |
        ./MessagePipe.Analyzer/MessagePipe.Analyzer.dll
        ./MessagePipe.Unity.${{ inputs.tag }}.unitypackage/MessagePipe.${{ inputs.tag }}.unitypackage
        ./MessagePipe.Unity.${{ inputs.tag }}.unitypackage/MessagePipe.VContainer.${{ inputs.tag }}.unitypackage
        ./MessagePipe.Unity.${{ inputs.tag }}.unitypackage/MessagePipe.Zenject.${{ inputs.tag }}.unitypackage
        ./MessagePipe.Unity.${{ inputs.tag }}.unitypackage/MessagePipe.Interprocess.${{ inputs.tag }}.unitypackage
    secrets: inherit

  cleanup:
    if: ${{ needs.update-packagejson.outputs.is-branch-created == 'true' }}
    needs: [update-packagejson, build-unity]
    permissions:
      contents: write
    uses: Cysharp/Actions/.github/workflows/clean-packagejson-branch.yaml@main
    with:
      branch: ${{ needs.update-packagejson.outputs.branch-name }}



================================================
FILE: .github/workflows/prevent-github-change.yaml
================================================
name: Prevent github change
on:
  pull_request:
    paths:
      - ".github/**/*.yaml"
      - ".github/**/*.yml"

jobs:
  detect:
    permissions:
      contents: read
    uses: Cysharp/Actions/.github/workflows/prevent-github-change.yaml@main



================================================
FILE: .github/workflows/stale.yaml
================================================
name: "Close stale issues"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

jobs:
  stale:
    permissions:
      contents: read
      pull-requests: write
      issues: write
    uses: Cysharp/Actions/.github/workflows/stale-issue.yaml@main


