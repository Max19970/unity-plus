Directory structure:
└── cysharp-memorypack/
    ├── Directory.Build.props
    ├── LICENSE
    ├── MemoryPack.sln
    ├── opensource.snk
    ├── .editorconfig
    ├── docs/
    │   └── graph.xlsx
    ├── sandbox/
    │   ├── Benchmark/
    │   │   ├── Benchmark.csproj
    │   │   ├── Program.cs
    │   │   ├── BenchmarkNetUtilities/
    │   │   │   ├── Categories.cs
    │   │   │   └── PayloadColumn.cs
    │   │   ├── Benchmarks/
    │   │   │   ├── Compression.cs
    │   │   │   ├── DeserializeTest.cs
    │   │   │   ├── JilBenchmark.cs
    │   │   │   ├── ListFormatterVsDirect.cs
    │   │   │   ├── SerializerTestBase.cs
    │   │   │   ├── SerializeTest.cs
    │   │   │   ├── StaticDictionaryFormatter.cs
    │   │   │   ├── Utf16VsUtf8.cs
    │   │   │   └── VersionTolerant.cs
    │   │   ├── Micro/
    │   │   │   ├── BlockCopy.cs
    │   │   │   ├── ConcurrentQueueVsStack.cs
    │   │   │   ├── GetLocalVsStaticField.cs
    │   │   │   ├── Hyper.cs
    │   │   │   ├── RawSerialize.cs
    │   │   │   ├── SerializeInt.cs
    │   │   │   ├── SpanSliceTest.cs
    │   │   │   ├── StaticAbstractVsFormatter.cs
    │   │   │   └── Utf8Decoding.cs
    │   │   └── Models/
    │   │       ├── HyperTest.cs
    │   │       ├── JilExtensionMethods.cs
    │   │       ├── MyClass.cs
    │   │       ├── Vector3.cs
    │   │       ├── BinaryPackModels/
    │   │       │   ├── JsonResponseModel.cs
    │   │       │   ├── NeuralNetworkLayerModel.cs
    │   │       │   ├── Helpers/
    │   │       │   │   ├── EqualityComparer.cs
    │   │       │   │   ├── RandomProvider.cs
    │   │       │   │   └── StructuralComparer.cs
    │   │       │   └── Interfaces/
    │   │       │       └── IInitializable.cs
    │   │       └── JilModels/
    │   │           ├── AccessToken.cs
    │   │           ├── AccountMerge.cs
    │   │           ├── Answer.cs
    │   │           ├── Badge.cs
    │   │           ├── Comment.cs
    │   │           ├── Error.cs
    │   │           ├── Event.cs
    │   │           ├── Feed.cs
    │   │           ├── FlagOption.cs
    │   │           ├── InboxItem.cs
    │   │           ├── Info.cs
    │   │           ├── NetworkUser.cs
    │   │           ├── Notification.cs
    │   │           ├── Post.cs
    │   │           ├── Privilege.cs
    │   │           ├── Question.cs
    │   │           ├── QuestionTimeline.cs
    │   │           ├── Reputation.cs
    │   │           ├── ReputationHistory.cs
    │   │           ├── Revision.cs
    │   │           ├── SearchExcerpt.cs
    │   │           ├── ShallowUser.cs
    │   │           ├── SuggestedEdit.cs
    │   │           ├── Tag.cs
    │   │           ├── TagScore.cs
    │   │           ├── TagSynonym.cs
    │   │           ├── TagWiki.cs
    │   │           ├── TopTag.cs
    │   │           ├── User.cs
    │   │           ├── UserTimeline.cs
    │   │           └── WritePermission.cs
    │   ├── ClassLibrary/
    │   │   ├── Class1.cs
    │   │   └── ClassLibrary.csproj
    │   ├── NativeAot/
    │   │   ├── NativeAot.csproj
    │   │   └── Program.cs
    │   ├── Net6VsNet7/
    │   │   ├── Net6VsNet7.csproj
    │   │   └── Program.cs
    │   ├── SandboxConsoleApp/
    │   │   ├── ForReadMe.cs
    │   │   ├── Models.cs
    │   │   ├── Program.cs
    │   │   ├── SandboxConsoleApp.csproj
    │   │   └── SystemTextJsonChecker.cs
    │   ├── SandboxNet6/
    │   │   ├── NamespaceTest.cs
    │   │   ├── Program.cs
    │   │   └── SandboxNet6.csproj
    │   └── SandboxWebApp/
    │       ├── appsettings.Development.json
    │       ├── appsettings.json
    │       ├── Models.cs
    │       ├── Program.cs
    │       ├── SandboxWebApp.csproj
    │       ├── tsconfig.json
    │       ├── Controllers/
    │       │   └── MemoryPackController.cs
    │       ├── Pages/
    │       │   ├── _ViewImports.cshtml
    │       │   ├── _ViewStart.cshtml
    │       │   ├── Error.cshtml
    │       │   ├── Error.cshtml.cs
    │       │   ├── Index.cshtml
    │       │   ├── Index.cshtml.cs
    │       │   ├── Privacy.cshtml
    │       │   ├── Privacy.cshtml.cs
    │       │   └── Shared/
    │       │       ├── _Layout.cshtml
    │       │       ├── _Layout.cshtml.css
    │       │       └── _ValidationScriptsPartial.cshtml
    │       ├── Properties/
    │       │   └── launchSettings.json
    │       ├── tests/
    │       │   └── test.ts
    │       └── wwwroot/
    │           ├── css/
    │           │   └── site.css
    │           ├── js/
    │           │   ├── file.js
    │           │   ├── file.ts
    │           │   ├── site.js
    │           │   └── memorypack/
    │           │       ├── AllConvertableType.js
    │           │       ├── AllConvertableType.ts
    │           │       ├── ArrayGenericsCheck.js
    │           │       ├── ArrayGenericsCheck.ts
    │           │       ├── FooBarBazDayonDattayon.js
    │           │       ├── FooBarBazDayonDattayon.ts
    │           │       ├── Gender.js
    │           │       ├── Gender.ts
    │           │       ├── IMogeUnion.js
    │           │       ├── IMogeUnion.ts
    │           │       ├── MemoryPackReader.js
    │           │       ├── MemoryPackReader.ts
    │           │       ├── MemoryPackWriter.js
    │           │       ├── MemoryPackWriter.ts
    │           │       ├── NestedObject.js
    │           │       ├── NestedObject.ts
    │           │       ├── NoMarkByteEnum.js
    │           │       ├── NoMarkByteEnum.ts
    │           │       ├── NullableFloatTest.js
    │           │       ├── NullableFloatTest.ts
    │           │       ├── NumberedUShortEnum.js
    │           │       ├── NumberedUShortEnum.ts
    │           │       ├── Person.js
    │           │       ├── Person.ts
    │           │       ├── R.js
    │           │       ├── R.ts
    │           │       ├── Re.js
    │           │       ├── Re.ts
    │           │       ├── Rec.js
    │           │       ├── Rec.ts
    │           │       ├── SampleLarge.js
    │           │       ├── SampleLarge.ts
    │           │       ├── SampleUnion1.js
    │           │       ├── SampleUnion1.ts
    │           │       ├── SampleUnion2.js
    │           │       ├── SampleUnion2.ts
    │           │       ├── Subset.js
    │           │       └── Subset.ts
    │           └── lib/
    │               ├── bootstrap/
    │               │   └── LICENSE
    │               ├── jquery/
    │               │   └── LICENSE.txt
    │               ├── jquery-validation/
    │               │   └── LICENSE.md
    │               └── jquery-validation-unobtrusive/
    │                   ├── jquery.validate.unobtrusive.js
    │                   └── LICENSE.txt
    ├── src/
    │   ├── MemoryPack/
    │   │   └── MemoryPack.csproj
    │   ├── MemoryPack.AspNetCoreMvcFormatter/
    │   │   ├── MediaTypeHeaderValues.cs
    │   │   ├── MemoryPack.AspNetCoreMvcFormatter.csproj
    │   │   ├── MemoryPackInputFormatter.cs
    │   │   ├── MemoryPackOutputFormatter.cs
    │   │   └── Properties/
    │   │       └── launchSettings.json
    │   ├── MemoryPack.Core/
    │   │   ├── Attributes.cs
    │   │   ├── CustomFormatterAttributes.cs
    │   │   ├── IMemoryPackable.cs
    │   │   ├── IMemoryPackFormatter.cs
    │   │   ├── MemoryPack.Core.csproj
    │   │   ├── MemoryPackCode.cs
    │   │   ├── MemoryPackFormatterProvider.cs
    │   │   ├── MemoryPackFormatterProvider.WellknownTypes.cs
    │   │   ├── MemoryPackFormatterProvider.WellknownTypes.tt
    │   │   ├── MemoryPackReader.cs
    │   │   ├── MemoryPackReader.Unmanaged.tt
    │   │   ├── MemoryPackReaderOptionalState.cs
    │   │   ├── MemoryPackReaderWriter.VarInt.cs
    │   │   ├── MemoryPackSerializationException.cs
    │   │   ├── MemoryPackSerializer.Deserialize.cs
    │   │   ├── MemoryPackSerializer.NonGenerics.cs
    │   │   ├── MemoryPackSerializer.Serialize.cs
    │   │   ├── MemoryPackSerializer.StateBackup.cs
    │   │   ├── MemoryPackSerializerOptions.cs
    │   │   ├── MemoryPackWriter.cs
    │   │   ├── MemoryPackWriter.Unmanaged.tt
    │   │   ├── MemoryPackWriterOptionalState.cs
    │   │   ├── Compression/
    │   │   │   ├── BitPackFormatter.cs
    │   │   │   ├── BrotliCompressor.cs
    │   │   │   ├── BrotliDecompressor.cs
    │   │   │   └── BrotliFormatter.cs
    │   │   ├── Formatters/
    │   │   │   ├── ArrayFormatters.cs
    │   │   │   ├── BigIntegerFormatter.cs
    │   │   │   ├── BitArrayFormatter.cs
    │   │   │   ├── CollectionFormatters.cs
    │   │   │   ├── CultureInfoFormatter.cs
    │   │   │   ├── DynamicUnionFormatter.cs
    │   │   │   ├── FrozenCollectionFormatter.cs
    │   │   │   ├── GenericCollectionFormatters.cs
    │   │   │   ├── ImmutableCollectionFormatters.cs
    │   │   │   ├── InterfaceCollectionFormatters.cs
    │   │   │   ├── KeyValuePairFormatter.cs
    │   │   │   ├── LazyFormatter.cs
    │   │   │   ├── MemoryPackableFormatter.cs
    │   │   │   ├── MultiDimensionalArrayFormatters.cs
    │   │   │   ├── NullableFormatter.cs
    │   │   │   ├── StringBuilderFormatter.cs
    │   │   │   ├── StringFormatter.cs
    │   │   │   ├── TimeZoneInfoFormatter.cs
    │   │   │   ├── TupleFormatter.cs
    │   │   │   ├── TupleFormatter.tt
    │   │   │   ├── TypeFormatter.cs
    │   │   │   ├── UnmanagedFormatter.cs
    │   │   │   ├── UriFormatter.cs
    │   │   │   └── VersionFormatter.cs
    │   │   └── Internal/
    │   │       ├── CollectionsMarshalEx.cs
    │   │       ├── EnumerableExtensions.cs
    │   │       ├── FixedArrayBufferWriter.cs
    │   │       ├── MathEx.cs
    │   │       ├── MemoryMarshalEx.cs
    │   │       ├── PreserveAttribute.cs
    │   │       ├── ReusableLinkedArrayBufferWriter.cs
    │   │       ├── ReusableReadOnlySequenceBuilder.cs
    │   │       └── TypeHelpers.cs
    │   ├── MemoryPack.Generator/
    │   │   ├── CoreEnums.cs
    │   │   ├── DiagnosticDescriptors.cs
    │   │   ├── EquatableArray.cs
    │   │   ├── EquatableTypeSymbol.cs
    │   │   ├── Extensions.cs
    │   │   ├── IGeneratorContext.cs
    │   │   ├── MemoryPack.Generator.csproj
    │   │   ├── MemoryPackGenerator.cs
    │   │   ├── MemoryPackGenerator.Emitter.cs
    │   │   ├── MemoryPackGenerator.Parser.cs
    │   │   ├── MemoryPackGenerator.TypeScript.cs
    │   │   ├── ReferenceSymbols.cs
    │   │   ├── TypeCollector.cs
    │   │   ├── TypeScriptMember.cs
    │   │   ├── TypeScriptRuntime.cs
    │   │   └── Properties/
    │   │       └── launchSettings.json
    │   ├── MemoryPack.Streaming/
    │   │   ├── MemoryPack.Streaming.csproj
    │   │   └── MemoryPackStreamingSerializer.cs
    │   ├── MemoryPack.Unity/
    │   │   ├── Assets/
    │   │   │   ├── Editor.meta
    │   │   │   ├── MemoryPack.Unity.meta
    │   │   │   ├── NuGet.config
    │   │   │   ├── NuGet.config.meta
    │   │   │   ├── packages.config
    │   │   │   ├── packages.config.meta
    │   │   │   ├── Packages.meta
    │   │   │   ├── Resources.meta
    │   │   │   ├── Scenes.meta
    │   │   │   ├── Tests.meta
    │   │   │   ├── Editor/
    │   │   │   │   ├── PackageExporter.cs
    │   │   │   │   └── PackageExporter.cs.meta
    │   │   │   ├── MemoryPack.Unity/
    │   │   │   │   ├── package.json
    │   │   │   │   ├── package.json.meta
    │   │   │   │   ├── Runtime.meta
    │   │   │   │   └── Runtime/
    │   │   │   │       ├── MemoryPack.Unity.asmdef
    │   │   │   │       ├── MemoryPack.Unity.asmdef.meta
    │   │   │   │       ├── ProviderInitializer.cs
    │   │   │   │       ├── ProviderInitializer.cs.meta
    │   │   │   │       ├── UnityFormatters.cs
    │   │   │   │       └── UnityFormatters.cs.meta
    │   │   │   ├── Packages/
    │   │   │   │   ├── System.Collections.Immutable.6.0.0.meta
    │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.6.0.0.meta
    │   │   │   │   ├── System.Collections.Immutable.6.0.0/
    │   │   │   │   │   ├── buildTransitive.meta
    │   │   │   │   │   ├── Icon.png.meta
    │   │   │   │   │   ├── lib.meta
    │   │   │   │   │   ├── LICENSE.TXT
    │   │   │   │   │   ├── LICENSE.TXT.meta
    │   │   │   │   │   ├── System.Collections.Immutable.nuspec
    │   │   │   │   │   ├── System.Collections.Immutable.nuspec.meta
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │   │   ├── useSharedDesignerContext.txt
    │   │   │   │   │   ├── useSharedDesignerContext.txt.meta
    │   │   │   │   │   ├── .signature.p7s
    │   │   │   │   │   ├── buildTransitive/
    │   │   │   │   │   │   ├── netcoreapp2.0.meta
    │   │   │   │   │   │   ├── netcoreapp3.1.meta
    │   │   │   │   │   │   ├── netcoreapp2.0/
    │   │   │   │   │   │   │   ├── System.Collections.Immutable.targets
    │   │   │   │   │   │   │   └── System.Collections.Immutable.targets.meta
    │   │   │   │   │   │   └── netcoreapp3.1/
    │   │   │   │   │   │       ├── _._
    │   │   │   │   │   │       └── _._.meta
    │   │   │   │   │   └── lib/
    │   │   │   │   │       ├── netstandard2.0.meta
    │   │   │   │   │       └── netstandard2.0/
    │   │   │   │   │           ├── System.Collections.Immutable.dll.meta
    │   │   │   │   │           └── System.Collections.Immutable.xml.meta
    │   │   │   │   └── System.Runtime.CompilerServices.Unsafe.6.0.0/
    │   │   │   │       ├── buildTransitive.meta
    │   │   │   │       ├── Icon.png.meta
    │   │   │   │       ├── lib.meta
    │   │   │   │       ├── LICENSE.TXT
    │   │   │   │       ├── LICENSE.TXT.meta
    │   │   │   │       ├── System.Runtime.CompilerServices.Unsafe.nuspec
    │   │   │   │       ├── System.Runtime.CompilerServices.Unsafe.nuspec.meta
    │   │   │   │       ├── THIRD-PARTY-NOTICES.TXT
    │   │   │   │       ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │       ├── useSharedDesignerContext.txt
    │   │   │   │       ├── useSharedDesignerContext.txt.meta
    │   │   │   │       ├── .signature.p7s
    │   │   │   │       ├── buildTransitive/
    │   │   │   │       │   ├── netcoreapp2.0.meta
    │   │   │   │       │   ├── netcoreapp3.1.meta
    │   │   │   │       │   ├── netcoreapp2.0/
    │   │   │   │       │   │   ├── System.Runtime.CompilerServices.Unsafe.targets
    │   │   │   │       │   │   └── System.Runtime.CompilerServices.Unsafe.targets.meta
    │   │   │   │       │   └── netcoreapp3.1/
    │   │   │   │       │       ├── _._
    │   │   │   │       │       └── _._.meta
    │   │   │   │       └── lib/
    │   │   │   │           ├── netstandard2.0.meta
    │   │   │   │           └── netstandard2.0/
    │   │   │   │               ├── System.Runtime.CompilerServices.Unsafe.dll.meta
    │   │   │   │               ├── System.Runtime.CompilerServices.Unsafe.xml
    │   │   │   │               └── System.Runtime.CompilerServices.Unsafe.xml.meta
    │   │   │   ├── Scenes/
    │   │   │   │   ├── RuntimeUnitTestScene.unity
    │   │   │   │   ├── RuntimeUnitTestScene.unity.meta
    │   │   │   │   ├── SampleScene.unity
    │   │   │   │   └── SampleScene.unity.meta
    │   │   │   └── Tests/
    │   │   │       ├── AotTest.cs
    │   │   │       ├── AotTest.cs.meta
    │   │   │       ├── BuiltinTest.cs
    │   │   │       ├── BuiltinTest.cs.meta
    │   │   │       ├── MemoryPackObjects.meta
    │   │   │       ├── PerfTest.cs
    │   │   │       ├── PerfTest.cs.meta
    │   │   │       ├── SampleOne.cs
    │   │   │       ├── SampleOne.cs.meta
    │   │   │       ├── Tests.asmdef
    │   │   │       ├── Tests.asmdef.meta
    │   │   │       ├── UnityPrimitivesTest.cs
    │   │   │       ├── UnityPrimitivesTest.cs.meta
    │   │   │       └── MemoryPackObjects/
    │   │   │           ├── Containers.cs
    │   │   │           ├── Containers.cs.meta
    │   │   │           ├── Ctors.cs
    │   │   │           ├── Ctors.cs.meta
    │   │   │           ├── GenericsType.cs
    │   │   │           ├── GenericsType.cs.meta
    │   │   │           ├── Include.cs
    │   │   │           ├── Include.cs.meta
    │   │   │           ├── Issues.cs
    │   │   │           ├── Issues.cs.meta
    │   │   │           ├── ManyMembers.cs
    │   │   │           ├── ManyMembers.cs.meta
    │   │   │           ├── MemberKinds.cs
    │   │   │           ├── MemberKinds.cs.meta
    │   │   │           ├── MemoryPackObjects.asmdef
    │   │   │           ├── MemoryPackObjects.asmdef.meta
    │   │   │           ├── MethodCall.cs
    │   │   │           ├── MethodCall.cs.meta
    │   │   │           ├── Overwrite.cs
    │   │   │           ├── Overwrite.cs.meta
    │   │   │           ├── Perf.cs
    │   │   │           ├── Perf.cs.meta
    │   │   │           ├── PrimitiveArrays.cs
    │   │   │           ├── PrimitiveArrays.cs.meta
    │   │   │           ├── Records.cs
    │   │   │           ├── Records.cs.meta
    │   │   │           ├── Recursive.cs
    │   │   │           ├── Recursive.cs.meta
    │   │   │           ├── StandardType.cs
    │   │   │           ├── StandardType.cs.meta
    │   │   │           ├── Takoyaki.cs
    │   │   │           ├── Takoyaki.cs.meta
    │   │   │           ├── Union.cs
    │   │   │           ├── Union.cs.meta
    │   │   │           ├── Versioned.cs
    │   │   │           ├── Versioned.cs.meta
    │   │   │           ├── Versioning.cs
    │   │   │           ├── Versioning.cs.meta
    │   │   │           ├── WellknownTypes.cs
    │   │   │           └── WellknownTypes.cs.meta
    │   │   ├── Packages/
    │   │   │   ├── manifest.json
    │   │   │   └── packages-lock.json
    │   │   └── ProjectSettings/
    │   │       ├── AudioManager.asset
    │   │       ├── BurstAotSettings_StandaloneWindows.json
    │   │       ├── ClusterInputManager.asset
    │   │       ├── CommonBurstAotSettings.json
    │   │       ├── DynamicsManager.asset
    │   │       ├── EditorBuildSettings.asset
    │   │       ├── EditorSettings.asset
    │   │       ├── GraphicsSettings.asset
    │   │       ├── InputManager.asset
    │   │       ├── MemorySettings.asset
    │   │       ├── NavMeshAreas.asset
    │   │       ├── NetworkManager.asset
    │   │       ├── PackageManagerSettings.asset
    │   │       ├── Physics2DSettings.asset
    │   │       ├── PresetManager.asset
    │   │       ├── ProjectSettings.asset
    │   │       ├── ProjectVersion.txt
    │   │       ├── QualitySettings.asset
    │   │       ├── SceneTemplateSettings.json
    │   │       ├── TagManager.asset
    │   │       ├── TimeManager.asset
    │   │       ├── UnityConnectSettings.asset
    │   │       ├── VersionControlSettings.asset
    │   │       ├── VFXManager.asset
    │   │       └── XRSettings.asset
    │   └── MemoryPack.UnityShims/
    │       ├── MemoryPack.UnityShims.csproj
    │       └── Shims.cs
    ├── tests/
    │   └── MemoryPack.Tests/
    │       ├── ArrayFormatterTest.cs
    │       ├── ArrayTest.cs
    │       ├── BrotliTest.cs
    │       ├── CircularReferenceTest.cs
    │       ├── CollectionFormatterTest.cs
    │       ├── CompressionTest.cs
    │       ├── ConstructorTest.cs
    │       ├── CustomCollectionTest.cs
    │       ├── CustomFormatterTest.cs
    │       ├── DefaultValueTest.cs
    │       ├── DeserializeTest.cs
    │       ├── EnumTest.cs
    │       ├── FrozenCollectionFormatterTest.cs
    │       ├── Fuzz.cs
    │       ├── GeneratorTest.cs
    │       ├── ImmutableCollectionFormatterTest.cs
    │       ├── InterfaceFormatterTest.cs
    │       ├── MemoryLayoutTest.cs
    │       ├── MemoryPack.Tests.csproj
    │       ├── MethodRefTest.cs
    │       ├── NonGenerics.cs
    │       ├── OverwriteTest.cs
    │       ├── PrimitiveTest.cs
    │       ├── ProviderTest.cs
    │       ├── ReaderTest.cs
    │       ├── ReflectionTest.cs
    │       ├── SerializerStructBufferWriterTest.cs
    │       ├── StreamOptimizeTest.cs
    │       ├── StringTest.cs
    │       ├── TupleTest.cs
    │       ├── UnionTest.cs
    │       ├── VarIntTest.cs
    │       ├── VersionTest.cs
    │       ├── VersionTolerantTest.cs
    │       ├── WellknownFormattersTest.cs
    │       ├── WriterOptionalStateTest.cs
    │       ├── WriterTest.cs
    │       ├── Models/
    │       │   ├── Arrays.cs
    │       │   ├── CircularReference.cs
    │       │   ├── Ctors.cs
    │       │   ├── CustomAttribute.cs
    │       │   ├── DefaultValues.cs
    │       │   ├── GenericsType.cs
    │       │   ├── Include.cs
    │       │   ├── KeywordIdentifier.cs
    │       │   ├── ManyMembers.cs
    │       │   ├── MemberKinds.cs
    │       │   ├── MethodCall.cs
    │       │   ├── NamespaceMempack.cs
    │       │   ├── Overwrite.cs
    │       │   ├── Records.cs
    │       │   ├── Recursive.cs
    │       │   ├── StandardType.cs
    │       │   ├── Union.cs
    │       │   ├── Versioning.cs
    │       │   ├── VersionTolerant.cs
    │       │   └── WellknownTypes.cs
    │       ├── SourceGeneratorTests/
    │       │   ├── GeneratorDiagnosticsTest.cs
    │       │   ├── GeneratorDiagnosticsTest.ManyMembers.cs
    │       │   ├── GeneratorDiagnosticsTest.TypeScript.cs
    │       │   └── IncrementalGeneratorTest.cs
    │       ├── Streaming/
    │       │   └── StreamingSerializer.cs
    │       └── Utils/
    │           ├── CSharpGeneratorRunner.cs
    │           └── ReadOnlySequenceBuilder.cs
    └── .github/
        ├── dependabot.yaml
        ├── FUNDING.yml
        └── workflows/
            ├── build-debug.yaml
            ├── build-release.yaml
            └── stale.yaml

================================================
FILE: Directory.Build.props
================================================
<Project>
  <PropertyGroup>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);CS1591</NoWarn>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)opensource.snk</AssemblyOriginatorKeyFile>

    <!-- NuGet Packaging -->
    <IsPackable>false</IsPackable>
    <PackageVersion>$(Version)</PackageVersion>
    <Company>Cysharp</Company>
    <Authors>Cysharp</Authors>
    <Copyright>© Cysharp, Inc.</Copyright>
    <PackageProjectUrl>https://github.com/Cysharp/MemoryPack</PackageProjectUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageIcon>Icon.png</PackageIcon>
  </PropertyGroup>

  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)Icon.png" Pack="true" PackagePath="\" />
    <None Include="$(MSBuildThisFileDirectory)README.md" Pack="true" PackagePath="\" />
    <EmbeddedResource Include="$(MSBuildThisFileDirectory)LICENSE" />
  </ItemGroup>
</Project>



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2022 Cysharp, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: MemoryPack.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32210.238
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.Core", "src\MemoryPack.Core\MemoryPack.Core.csproj", "{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{204004F9-9B91-4DD1-812C-80D629169ED5}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "sandbox", "sandbox", "{796FB992-A35C-405B-82A7-4C90C5673174}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SandboxConsoleApp", "sandbox\SandboxConsoleApp\SandboxConsoleApp.csproj", "{668B187F-726A-4558-90DB-019C332E51F0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.Tests", "tests\MemoryPack.Tests\MemoryPack.Tests.csproj", "{1C22BB73-56D7-4C13-99BA-D7C25C45510F}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.Generator", "src\MemoryPack.Generator\MemoryPack.Generator.csproj", "{92BFD932-2627-496D-BECA-4160C895C397}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack", "src\MemoryPack\MemoryPack.csproj", "{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.Streaming", "src\MemoryPack.Streaming\MemoryPack.Streaming.csproj", "{71898098-EA11-4839-AAD2-D4CB974D98E7}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Benchmark", "sandbox\Benchmark\Benchmark.csproj", "{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SandboxWebApp", "sandbox\SandboxWebApp\SandboxWebApp.csproj", "{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.AspNetCoreMvcFormatter", "src\MemoryPack.AspNetCoreMvcFormatter\MemoryPack.AspNetCoreMvcFormatter.csproj", "{64B20612-4990-40C7-8191-E2A033CD1EF5}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SandboxNet6", "sandbox\SandboxNet6\SandboxNet6.csproj", "{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ClassLibrary", "sandbox\ClassLibrary\ClassLibrary.csproj", "{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "NativeAot", "sandbox\NativeAot\NativeAot.csproj", "{6E18AECF-34B2-48F9-9694-54150FB156EB}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Net6VsNet7", "sandbox\Net6VsNet7\Net6VsNet7.csproj", "{5612B811-586A-4EB3-9AE7-60CAD4969A1B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MemoryPack.UnityShims", "src\MemoryPack.UnityShims\MemoryPack.UnityShims.csproj", "{9339C66C-25E5-4130-A213-9BA1804AD562}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
		WinBenchmark|Any CPU = WinBenchmark|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.Release|Any CPU.Build.0 = Release|Any CPU
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.Release|Any CPU.Build.0 = Release|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{668B187F-726A-4558-90DB-019C332E51F0}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.Release|Any CPU.Build.0 = Release|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.Release|Any CPU.Build.0 = Release|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{92BFD932-2627-496D-BECA-4160C895C397}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.Release|Any CPU.Build.0 = Release|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.Release|Any CPU.Build.0 = Release|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{71898098-EA11-4839-AAD2-D4CB974D98E7}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.Release|Any CPU.Build.0 = Release|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.Release|Any CPU.Build.0 = Release|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.Release|Any CPU.Build.0 = Release|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{64B20612-4990-40C7-8191-E2A033CD1EF5}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.Release|Any CPU.Build.0 = Release|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.WinBenchmark|Any CPU.ActiveCfg = Release|Any CPU
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2}.WinBenchmark|Any CPU.Build.0 = Release|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.Release|Any CPU.Build.0 = Release|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.Release|Any CPU.Build.0 = Release|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{6E18AECF-34B2-48F9-9694-54150FB156EB}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.Release|Any CPU.Build.0 = Release|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.Release|Any CPU.Build.0 = Release|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.WinBenchmark|Any CPU.ActiveCfg = Debug|Any CPU
		{9339C66C-25E5-4130-A213-9BA1804AD562}.WinBenchmark|Any CPU.Build.0 = Debug|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{03BF8319-91FB-4ABA-8FA2-E7D088C94E5D} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
		{668B187F-726A-4558-90DB-019C332E51F0} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{1C22BB73-56D7-4C13-99BA-D7C25C45510F} = {204004F9-9B91-4DD1-812C-80D629169ED5}
		{92BFD932-2627-496D-BECA-4160C895C397} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
		{4118975E-9AA8-4CB1-9C49-BD3DE1B45581} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
		{71898098-EA11-4839-AAD2-D4CB974D98E7} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
		{31F067EA-3E16-47DD-A6E6-9AFDDD82E22F} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{F9D66CB1-8D28-426B-BB12-C9F5D30EC6A0} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{64B20612-4990-40C7-8191-E2A033CD1EF5} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
		{87C0CEAA-E511-46AA-93AB-AF742A1F8EE2} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{0ADCE3AF-C900-4FCB-938B-654211EDD6BE} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{6E18AECF-34B2-48F9-9694-54150FB156EB} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{5612B811-586A-4EB3-9AE7-60CAD4969A1B} = {796FB992-A35C-405B-82A7-4C90C5673174}
		{9339C66C-25E5-4130-A213-9BA1804AD562} = {81B295E0-EEDE-4D5B-B4AC-1202D5E6B3CF}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {01ADF7A3-0758-4A3C-9A18-AEF0F30B6E1B}
	EndGlobalSection
EndGlobal



================================================
FILE: opensource.snk
================================================
[Binary file]


================================================
FILE: .editorconfig
================================================
﻿# top-most EditorConfig file
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

# Visual Studio Spell checker configs (https://learn.microsoft.com/en-us/visualstudio/ide/text-spell-checker?view=vs-2022#how-to-customize-the-spell-checker)
spelling_exclusion_path  = ./exclusion.dic

[*.cs]
indent_size = 4
charset = utf-8-bom
end_of_line = unset

# Solution files
[*.{sln,slnx}]
end_of_line = unset

# MSBuild project files
[*.{csproj,props,targets}]
end_of_line = unset

# Xml config files
[*.{ruleset,config,nuspec,resx,runsettings,DotSettings}]
end_of_line = unset

[*{_AssemblyInfo.cs,.notsupported.cs}]
generated_code = true

# C# code style settings
[*.{cs}]
csharp_style_namespace_declarations = file_scoped
dotnet_style_require_accessibility_modifiers = never

# VSTHRD101: Avoid async void
# VSTHRD101: Avoid unsupported async delegates
dotnet_diagnostic.VSTHRD100.severity = none
dotnet_diagnostic.VSTHRD101.severity = none

# VSTHRD003: Avoid awaiting foreign Tasks
dotnet_diagnostic.VSTHRD003.severity = none

# VSTHRD111: Use ConfigureAwait(bool)
dotnet_diagnostic.VSTHRD111.severity = error



================================================
FILE: docs/graph.xlsx
================================================
[Binary file]


================================================
FILE: sandbox/Benchmark/Benchmark.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
        <Nullable>enable</Nullable>
        <TieredPGO>true</TieredPGO>
    </PropertyGroup>

    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
        <WarningsAsErrors>$(WarningsAsErrors);NU1605;</WarningsAsErrors>
        <NoWarn>$(NoWarn);CS1591;CS8604;CS8032;CS8002;CS8600</NoWarn>
    </PropertyGroup>

    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
        <WarningsAsErrors>$(WarningsAsErrors);NU1605;</WarningsAsErrors>
        <NoWarn>$(NoWarn);CS1591;CS8604;CS8032;CS8002;CS8600</NoWarn>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BenchmarkDotNet" Version="0.13.2" />
        <PackageReference Include="BinaryPack" Version="1.0.3" />
        <PackageReference Include="K4os.Compression.LZ4" Version="1.2.16" />
        <PackageReference Include="K4os.Compression.LZ4.Streams" Version="1.2.16" />
        <PackageReference Include="MessagePack" Version="2.4.35" />
        <PackageReference Include="MessagePackAnalyzer" Version="2.4.35">
          <PrivateAssets>all</PrivateAssets>
          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
        <PackageReference Include="Microsoft.Orleans.CodeGenerator" Version="7.0.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
        <PackageReference Include="Microsoft.Orleans.Serialization" Version="7.0.0" />
        <PackageReference Include="protobuf-net" Version="3.1.25" />
        <PackageReference Include="System.IO.Pipelines" Version="6.0.3" />
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.3.1" PrivateAssets="all" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>


    <ItemGroup>
        <Using Include="BenchmarkDotNet.Attributes" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/Benchmark/Program.cs
================================================
﻿using Benchmark.Benchmarks;
using Benchmark.Micro;
using Benchmark.Models;
using BenchmarkDotNet.Columns;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using BinaryPack.Models;
using BinaryPack.Models.Helpers;
using BinaryPack.Models.Interfaces;
using Iced.Intel;
using MemoryPack;
using MemoryPack.Compression;
using MemoryPack.Formatters;
using System.Reflection;

#if !DEBUG

var config = ManualConfig.CreateMinimumViable()
    .AddDiagnoser(MemoryDiagnoser.Default)
    // .AddColumn(StatisticColumn.OperationsPerSecond)
    //.AddExporter(DefaultExporters.Plain)
    .AddExporter(MarkdownExporter.Default)
    .AddJob(Job.Default.WithWarmupCount(1).WithIterationCount(1)); // .AddJob(Job.ShortRun);

//BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()!).Run(args, config);


//BenchmarkRunner.Run<Hyper>(config, args);

//BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()!).RunAllJoined(config);


// BenchmarkRunner.Run(Assembly.GetEntryAssembly()!, config, args);



//BenchmarkRunner.Run<SerializeInt>(config, args);
//BenchmarkRunner.Run<SerializeTest<MyClass>>(config, args);


//BenchmarkRunner.Run<RawSerialize>(config, args);

// BenchmarkRunner.Run<ConcurrentQueueVsStack>(config, args);

//BenchmarkRunner.Run<ListFormatterVsDirect>(config, args);


//BenchmarkRunner.Run<Utf16VsUtf8>(config, args);

//BenchmarkRunner.Run<SerializeTest<NeuralNetworkLayerModel>>(config, args);

// BenchmarkRunner.Run<DeserializeTest<NeuralNetworkLayerModel>>(config, args);


//BenchmarkRunner.Run<StaticDictionaryFormatterCheck>(config, args);
//BenchmarkRunner.Run<SerializeTest<JsonResponseModel>>(config, args);
//BenchmarkRunner.Run<DeserializeTest<JsonResponseModel>>(config, args);
//BenchmarkRunner.Run<SerializeTest<Vector3[]>>(config, args);
//BenchmarkRunner.Run<DeserializeTest<Vector3[]>>(config, args);

//BenchmarkRunner.Run<StaticAbstractVsFormatter>(config, args);

//BenchmarkRunner.Run<Compression<JsonResponseModel>>(config, args);
//BenchmarkRunner.Run<Compression<Vector3[]>>(config, args);
//BenchmarkRunner.Run<Compression<NeuralNetworkLayerModel>>(config, args);


//BenchmarkRunner.Run<GetLocalVsStaticField>(config, args);

//BenchmarkRunner.Run<VersionTolerant>(config, args);

BenchmarkRunner.Run(typeof(JilBenchmark<>), config, args);

//BenchmarkSwitcher.FromTypes(new[]{
//    typeof(SerializeTest<>),
//    typeof(DeserializeTest<>),
//})
//    .RunAllJoined(config);

#endif

#if DEBUG

//MessagePack.MessagePackSerializerOptions
//MemoryPack.MemoryPackSerializerOptions
//System.Text.Json.JsonSerializerOptions

//new JilBenchmark<Question>().OrleansDeserializeStream();
var jil = new JilBenchmark<Question>();
var bin = jil.MemoryPackSerializeUtf16();
var q2 = MemoryPackSerializer.Deserialize<Question>(bin);


new Hyper().Serialize();

var c = new StaticDictionaryFormatterCheck();
c.DeserializeCurrent();
c.DeserializeImprovement();

c.DeserializeCurrent();
c.DeserializeImprovement();


var model = new JsonResponseModel(true);
var model2 = Enumerable.Repeat(new Vector3 { X = 10.3f, Y = 40.5f, Z = 13411.3f }, 1000).ToArray();

using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, model2);
var foo = compressor.ToArray();

using var decompressor = new BrotliDecompressor();

var foo2 = decompressor.Decompress(foo);

Check<JsonResponseModel>();
Check<NeuralNetworkLayerModel>();

void Check<T>()
    where T : IInitializable, IEquatable<T>, new()
{
    var model = new T();
    model.Initialize();
    var bin = MemoryPackSerializer.Serialize(model);
    var model2 = MemoryPackSerializer.Deserialize<T>(bin);
    var ok = model.Equals(model2);
    Console.WriteLine(typeof(T) + " is " + (ok ? "ok" : "ng"));
}

[MemoryPackable]
public partial class Test
{
    public float[] F = default!;

    public Test()
    {
        // _ = new TestFormatter();
    }
}

#endif



================================================
FILE: sandbox/Benchmark/BenchmarkNetUtilities/Categories.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.BenchmarkNetUtilities;

public static class Categories
{
    public const string Bytes = " byte[]";
    public const string BufferWriter = "BufferWriter";
    public const string Stream = "Stream";
    public const string Serialize = "Serialize";
    public const string Deserialize = "Deserialize";
}



================================================
FILE: sandbox/Benchmark/BenchmarkNetUtilities/PayloadColumn.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Columns;
using BenchmarkDotNet.Reports;
using BenchmarkDotNet.Running;

namespace Benchmark.BenchmarkNetUtilities;

public class PayloadColumnAttribute : ColumnConfigBaseAttribute
{
    public PayloadColumnAttribute()
        : base(new PayloadColumn())
    {
    }
}

public class PayloadColumn : IColumn
{
    public string Id => nameof(PayloadColumn);

    public string ColumnName => "Payload";

    public bool AlwaysShow => true;

    public ColumnCategory Category => ColumnCategory.Custom;

    public int PriorityInCategory => 0;

    public bool IsNumeric => true;

    public UnitType UnitType => UnitType.Size;

    public string Legend => "Payload size";

    public string GetValue(Summary summary, BenchmarkCase benchmarkCase)
    {
        var methodInfo = benchmarkCase.Descriptor.WorkloadMethod;

        if (methodInfo.ReturnType == typeof(byte[]))
        {
            var instance = Activator.CreateInstance(benchmarkCase.Descriptor.Type);
            var result = (byte[])methodInfo.Invoke(instance, null)!;
            return new SizeValue(result.LongLength).ToString(null);
        }
        else
        {
            return "-";
        }
    }

    public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style)
    {
        return GetValue(summary, benchmarkCase);
    }

    public bool IsAvailable(Summary summary)
    {
        return true;
    }

    public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase)
    {
        return false;
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/Compression.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using BenchmarkDotNet.Configs;
using K4os.Compression.LZ4.Encoders;
using K4os.Compression.LZ4.Streams;
using MemoryPack;
using MemoryPack.Compression;
using System.IO.Compression;

namespace Benchmark.Benchmarks;

[CategoriesColumn]
[PayloadColumn]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
public class Compression<T> : SerializerTestBase<T>
{
    MemoryStream ms;
    LZ4EncoderSettings Fast;
    LZ4EncoderSettings L10Opt;
    LZ4EncoderSettings L04HC;
    byte[] normal;
    byte[] brotliFast;
    byte[] lz4Fast;

    public Compression()
        : base()
    {
        ms = new MemoryStream();
        Fast = new LZ4EncoderSettings { CompressionLevel = K4os.Compression.LZ4.LZ4Level.L00_FAST };
        L10Opt = new LZ4EncoderSettings { CompressionLevel = K4os.Compression.LZ4.LZ4Level.L10_OPT };
        L04HC = new LZ4EncoderSettings { CompressionLevel = K4os.Compression.LZ4.LZ4Level.L04_HC };

        normal = SerializeMemoryPack();
        brotliFast = BrotliCompressQ1();
        lz4Fast = LZ4CompressStreamFast();
    }

    [Benchmark(Baseline = true), BenchmarkCategory(Categories.Serialize)]
    public byte[] SerializeMemoryPack()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf8);
    }

    [Benchmark]
    public byte[] SerializeMemoryPackUtf16()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf16);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressQ1()
    {
        using var compressor = new BrotliCompressor(quality: 1);
        MemoryPackSerializer.Serialize(compressor, value, MemoryPackSerializerOptions.Utf8);
        return compressor.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressQ2()
    {
        using var compressor = new BrotliCompressor(quality: 2);
        MemoryPackSerializer.Serialize(compressor, value, MemoryPackSerializerOptions.Utf8);
        return compressor.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressQ3()
    {
        using var compressor = new BrotliCompressor(quality: 3);
        MemoryPackSerializer.Serialize(compressor, value, MemoryPackSerializerOptions.Utf8);
        return compressor.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressQ4()
    {
        using var compressor = new BrotliCompressor(quality: 4);
        MemoryPackSerializer.Serialize(compressor, value, MemoryPackSerializerOptions.Utf8);
        return compressor.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressStreamFastest()
    {
        ms.Position = 0;
        using (var brotli = new BrotliStream(ms, CompressionLevel.Fastest, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(brotli, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressStreamOptimial()
    {
        ms.Position = 0;
        using (var brotli = new BrotliStream(ms, CompressionLevel.Optimal, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(brotli, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressStreamSmallestSize()
    {
        ms.Position = 0;
        using (var brotli = new BrotliStream(ms, CompressionLevel.SmallestSize, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(brotli, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] BrotliCompressStreamNoCompression()
    {
        ms.Position = 0;
        using (var brotli = new BrotliStream(ms, CompressionLevel.NoCompression, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(brotli, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] LZ4CompressStreamFast()
    {


        ms.Position = 0;
        using (var lz4 = LZ4Stream.Encode(ms, Fast, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(lz4, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] LZ4CompressStreamHc04()
    {


        ms.Position = 0;
        using (var lz4 = LZ4Stream.Encode(ms, L04HC, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(lz4, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] LZ4CompressStreamL10Opt()
    {
        ms.Position = 0;
        using (var lz4 = LZ4Stream.Encode(ms, L10Opt, leaveOpen: true))
        {
            MemoryPackSerializer.SerializeAsync(lz4, value, MemoryPackSerializerOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
        }
        ms.Flush();
        return ms.ToArray();
    }

    //Decompress

    [Benchmark(Baseline = true), BenchmarkCategory(Categories.Deserialize)]
    public T? DeserializeMemoryPack()
    {
        return MemoryPackSerializer.Deserialize<T>(normal);
    }

    [Benchmark(), BenchmarkCategory(Categories.Deserialize)]
    public T? DecompressBrotli()
    {
        using var decompressor = new BrotliDecompressor();
        return MemoryPackSerializer.Deserialize<T>(decompressor.Decompress(brotliFast));
    }

    [Benchmark(), BenchmarkCategory(Categories.Deserialize)]
    public T? DecompressBrotliStream()
    {
        using (var ms2 = new MemoryStream(brotliFast))
        using (var brotli = new BrotliStream(ms2, CompressionMode.Decompress))
        {
            return MemoryPackSerializer.DeserializeAsync<T>(brotli).GetAwaiter().GetResult();
        }
    }

    [Benchmark(), BenchmarkCategory(Categories.Deserialize)]
    public T? LZ4Decompress()
    {
        using (var ms2 = new MemoryStream(lz4Fast))
        using (var lz4 = LZ4Stream.Decode(ms2, leaveOpen: true))
        {
            return MemoryPackSerializer.DeserializeAsync<T>(lz4).GetAwaiter().GetResult();
        }
    }

    // GZip



    //[Benchmark]
    //public byte[] GZipCompressStreamFastest()
    //{
    //    ms.Position = 0;
    //    using (var GZip = new GZipStream(ms, CompressionLevel.Fastest, leaveOpen: true))
    //    {
    //        MemoryPackSerializer.SerializeAsync(GZip, value, MemoryPackSerializeOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
    //    }
    //    ms.Flush();
    //    return ms.ToArray();
    //}

    //[Benchmark]
    //public byte[] GZipCompressStreamOptimial()
    //{
    //    ms.Position = 0;
    //    using (var GZip = new GZipStream(ms, CompressionLevel.Optimal, leaveOpen: true))
    //    {
    //        MemoryPackSerializer.SerializeAsync(GZip, value, MemoryPackSerializeOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
    //    }
    //    ms.Flush();
    //    return ms.ToArray();
    //}

    //[Benchmark]
    //public byte[] GZipCompressStreamSmallestSize()
    //{
    //    ms.Position = 0;
    //    using (var GZip = new GZipStream(ms, CompressionLevel.SmallestSize, leaveOpen: true))
    //    {
    //        MemoryPackSerializer.SerializeAsync(GZip, value, MemoryPackSerializeOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
    //    }
    //    ms.Flush();
    //    return ms.ToArray();
    //}

    //[Benchmark]
    //public byte[] GZipCompressStreamNoCompression()
    //{
    //    ms.Position = 0;
    //    using (var GZip = new GZipStream(ms, CompressionLevel.NoCompression, leaveOpen: true))
    //    {
    //        MemoryPackSerializer.SerializeAsync(GZip, value, MemoryPackSerializeOptions.Utf8).ConfigureAwait(false).GetAwaiter().GetResult();
    //    }
    //    ms.Flush();
    //    return ms.ToArray();
    //}

}



================================================
FILE: sandbox/Benchmark/Benchmarks/DeserializeTest.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using Benchmark.Models;
using BinaryPack.Models;
using MemoryPack;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Orleans.Serialization;
using Orleans.Serialization.Buffers;
using Orleans.Serialization.Session;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Formats.Asn1;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace Benchmark.Benchmarks;

//[GenericTypeArguments(typeof(int))]
//[GenericTypeArguments(typeof(Vector3[]))]
//[GenericTypeArguments(typeof(JsonResponseModel))]
//[GenericTypeArguments(typeof(NeuralNetworkLayerModel))]
public class DeserializeTest<T> : SerializerTestBase<T>
{
    Serializer<T> orleansSerializer;

    SerializerSession session;
    byte[] payloadMessagePack;
    byte[] payloadMemoryPack;
    byte[] payloadProtobuf;
    byte[] payloadJson;
    byte[] payloadOrleans;

    public DeserializeTest()
        : base()
    {
        // Orleans
        var serviceProvider = new ServiceCollection()
            .AddSerializer(builder => builder.AddAssembly(typeof(SerializeTest<>).Assembly))
            .BuildServiceProvider();
        session = serviceProvider.GetRequiredService<SerializerSessionPool>().GetSession();
        orleansSerializer = serviceProvider.GetRequiredService<Serializer<T>>();

        payloadOrleans = orleansSerializer.SerializeToArray(value);
        payloadMessagePack = MessagePackSerializer.Serialize(value);
        payloadMemoryPack = MemoryPackSerializer.Serialize(value);
        using var stream = new MemoryStream();
        ProtoBuf.Serializer.Serialize(stream, value);
        payloadProtobuf = stream.ToArray();
        payloadJson = JsonSerializer.SerializeToUtf8Bytes(value);
    }

    [Benchmark]
    public T MessagePackDeserialize()
    {
        return MessagePackSerializer.Deserialize<T>(payloadMessagePack);
    }

    [Benchmark(Baseline = true)]
    public T? MemoryPackDeserialize()
    {
        return MemoryPackSerializer.Deserialize<T>(payloadMemoryPack);
    }

    [Benchmark]
    public T ProtobufNetDeserialize()
    {
        return ProtoBuf.Serializer.Deserialize<T>(payloadProtobuf.AsSpan());
    }

    [Benchmark]
    public T? SystemTextJsonDeserialize()
    {
        return System.Text.Json.JsonSerializer.Deserialize<T>(payloadJson);
    }

    [Benchmark]
    public T OrleansDeserialize()
    {
        session.PartialReset();
        var reader = Reader.Create(payloadOrleans, session);
        return orleansSerializer.Deserialize(ref reader);
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/JilBenchmark.cs
================================================
﻿#nullable disable

using Benchmark.BenchmarkNetUtilities;
using Benchmark.Models;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Order;
using MemoryPack;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Orleans.Serialization;
using Orleans.Serialization.Buffers;
using Orleans.Serialization.Session;
using System.Buffers;
using System.Text;
using System.Text.Json;

namespace Benchmark.Benchmarks;

[GenericTypeArguments(typeof(Question))]
[GenericTypeArguments(typeof(Answer))]
[GenericTypeArguments(typeof(User))]
[GenericTypeArguments(typeof(List<Question>))]
[GenericTypeArguments(typeof(List<Answer>))]
[GenericTypeArguments(typeof(List<User>))]
[GenericTypeArguments(typeof(Dictionary<string, Question>))]
[GenericTypeArguments(typeof(Dictionary<string, Answer>))]
[GenericTypeArguments(typeof(Dictionary<string, User>))]
[CategoriesColumn]
[PayloadColumn]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
public class JilBenchmark<T>
{
    static Random Rand;

    static object MakeSingleObject(Type t)
    {
        var ret = Activator.CreateInstance(t);
        foreach (var p in t.GetProperties())
        {
            var propType = p.PropertyType;
            var val = propType.RandomValue(Rand);

            p.SetValue(ret, val);
        }

        return ret;
    }

    static object MakeListObject(Type t)
    {
        var asList = typeof(List<>).MakeGenericType(t);

        var ret = asList.RandomValue(Rand);

        // top level can't be null
        if (ret == null)
        {
            return MakeListObject(t);
        }

        return ret;
    }

    static object MakeDictionaryObject(Type t)
    {
        var asDictionary = typeof(Dictionary<,>).MakeGenericType(typeof(string), t);
        var ret = Activator.CreateInstance(asDictionary);
        var add = asDictionary.GetMethod("Add");

        var len = Rand.Next(30) + 20;
        for (var i = 0; i < len; i++)
        {
            var key = (string)typeof(string).RandomValue(Rand);
            if (key == null)
            {
                i--;
                continue;
            }

            var val = t.RandomValue(Rand);

            add.Invoke(ret, new object[] { key, val });
        }

        return ret;
    }


    static void ResetRand()
    {
        Rand = new Random(314159265);
    }

    T value;
    ArrayBufferWriter<byte> writer;
    MemoryStream stream;
    Utf8JsonWriter jsonWriter;
    SerializerSession session;
    Serializer<T> orleansSerializer;
    byte[] payloadMessagePack;
    byte[] payloadMemoryPack;
    byte[] payloadMemoryPackUtf16;
    byte[] payloadProtobuf;
    byte[] payloadJson;
    byte[] payloadOrleans;
    Stream payloadStreamMessagePack;
    Stream payloadStreamMemoryPack;
    Stream payloadStreamMemoryPackUtf16;
    Stream payloadStreamProtobuf;
    Stream payloadStreamJson;
    Stream payloadStreamOrleans;

    public JilBenchmark()
    {
        ResetRand();
        if (!typeof(T).IsGenericType)
        {
            value = (T)MakeSingleObject(typeof(T));
        }
        else
        {
            if (typeof(T).GetGenericTypeDefinition() == typeof(Dictionary<,>))
            {
                value = (T)MakeDictionaryObject(typeof(T).GetGenericArguments()[1]);
            }
            else if (typeof(T).GetGenericTypeDefinition() == typeof(List<>))
            {
                value = (T)MakeListObject(typeof(T).GetGenericArguments()[0]);
            }
        }

        // Orleans
        var serviceProvider = new ServiceCollection()
            .AddSerializer(builder => builder.AddAssembly(typeof(SerializeTest<>).Assembly))
            .BuildServiceProvider();
        session = serviceProvider.GetRequiredService<SerializerSessionPool>().GetSession();
        orleansSerializer = serviceProvider.GetRequiredService<Serializer<T>>();

        // create buffers
        stream = new MemoryStream();

        payloadOrleans = orleansSerializer.SerializeToArray(value);
        payloadMessagePack = MessagePackSerializer.Serialize(value);
        ProtoBuf.Serializer.Serialize(stream, value);
        payloadProtobuf = stream.ToArray();
        stream.Position = 0;
        payloadJson = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(value));
        payloadMemoryPack = MemoryPackSerializer.Serialize(value);
        payloadMemoryPackUtf16 = MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf16);

        writer = new ArrayBufferWriter<byte>(payloadJson.Length);
        jsonWriter = new Utf8JsonWriter(writer);

        payloadStreamMessagePack = new MemoryStream(payloadMessagePack, 0, payloadMessagePack.Length, writable: false, publiclyVisible: false);
        payloadStreamMemoryPack = new MemoryStream(payloadMemoryPack, 0, payloadMemoryPack.Length, writable: false, publiclyVisible: false);
        payloadStreamMemoryPackUtf16 = new MemoryStream(payloadMemoryPackUtf16, 0, payloadMemoryPackUtf16.Length, writable: false, publiclyVisible: false);
        payloadStreamProtobuf = new MemoryStream(payloadProtobuf, 0, payloadProtobuf.Length, writable: false, publiclyVisible: false);
        payloadStreamJson = new MemoryStream(payloadJson, 0, payloadJson.Length, writable: false, publiclyVisible: false);
        payloadStreamOrleans = new MemoryStream(payloadOrleans, 0, payloadOrleans.Length, writable: false, publiclyVisible: false);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] MessagePackSerialize()
    {
        return MessagePackSerializer.Serialize(value);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] MemoryPackSerialize()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Default);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] MemoryPackSerializeUtf16()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf16);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] ProtobufNetSerialize()
    {
        ProtoBuf.Serializer.Serialize(stream, value);
        var array = stream.ToArray();
        stream.Position = 0;
        return array;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] SystemTextJsonSerialize()
    {
        System.Text.Json.JsonSerializer.Serialize(stream, value);
        var array = stream.ToArray();
        stream.Position = 0;
        return array;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Bytes)]
    public byte[] OrleansSerialize()
    {
        return orleansSerializer.SerializeToArray(value);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void MessagePackBufferWriter()
    {
        MessagePackSerializer.Serialize(writer, value);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void MemoryPackBufferWriter()
    {
        MemoryPackSerializer.Serialize(writer, value);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void MemoryPackBufferWriterUtf16()
    {
        MemoryPackSerializer.Serialize(writer, value, MemoryPackSerializerOptions.Utf16);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void ProtobufNetBufferWriter()
    {
        ProtoBuf.Serializer.Serialize(writer, value);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void SystemTextJsonBufferWriter()
    {
        System.Text.Json.JsonSerializer.Serialize(jsonWriter, value);
        jsonWriter.Flush();
        writer.Clear();
        jsonWriter.Reset(writer);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void OrleansWriterPooledArrayBufferWriter()
    {
        var writer = Writer.CreatePooled(session);
        try
        {
            orleansSerializer.Serialize(value, ref writer);
        }
        finally
        {
            writer.Dispose();
            session.PartialReset();
        }
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.BufferWriter)]
    public void OrleansWriterArrayBufferWriter()
    {
        var writer = this.writer.CreateWriter(session);
        try
        {
            orleansSerializer.Serialize(value, ref writer);
        }
        finally
        {
            writer.Dispose();
            session.PartialReset();
        }

        this.writer.Clear(); // clear ArrayBufferWriter<byte>
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void MessagePackStream()
    {
        MessagePackSerializer.Serialize(stream, value);
        stream.Position = 0;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void MemoryPackStream()
    {
        MemoryPackSerializer.SerializeAsync(stream, value, MemoryPackSerializerOptions.Default).GetAwaiter().GetResult();
        stream.Position = 0;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void MemoryPackStreamUtf16()
    {
        MemoryPackSerializer.SerializeAsync(stream, value, MemoryPackSerializerOptions.Utf16).GetAwaiter().GetResult();
        stream.Position = 0;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void ProtobufNetStram()
    {
        ProtoBuf.Serializer.Serialize(stream, value);
        stream.Position = 0;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void SystemTextJsonStream()
    {
        System.Text.Json.JsonSerializer.Serialize(stream, value);
        stream.Position = 0;
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize, Categories.Stream)]
    public void OrleansWriterStream()
    {
        var writer = Writer.Create(stream, session);
        try
        {
            orleansSerializer.Serialize(value, ref writer);
        }
        finally
        {
            writer.Dispose();
            session.PartialReset();
        }
        stream.Position = 0;
    }

    // deserialize

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T MessagePackDeserialize()
    {
        return MessagePackSerializer.Deserialize<T>(payloadMessagePack);
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T MemoryPackDeserialize()
    {
        return MemoryPackSerializer.Deserialize<T>(payloadMemoryPack);
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T MemoryPackDeserializeUtf16()
    {
        return MemoryPackSerializer.Deserialize<T>(payloadMemoryPackUtf16);
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T ProtobufNetDeserialize()
    {
        return ProtoBuf.Serializer.Deserialize<T>(payloadProtobuf.AsSpan());
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T SystemTextJsonDeserialize()
    {
        return System.Text.Json.JsonSerializer.Deserialize<T>(payloadJson);
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Bytes)]
    public T OrleansDeserialize()
    {
        try
        {
            var reader = Reader.Create(payloadOrleans, session);
            return orleansSerializer.Deserialize(ref reader);
        }
        finally
        {
            session.PartialReset();
        }
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T MessagePackDeserializeStream()
    {
        payloadStreamMessagePack.Position = 0;
        return MessagePackSerializer.DeserializeAsync<T>(payloadStreamMessagePack).GetAwaiter().GetResult();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T MemoryPackDeserializeStream()
    {
        payloadStreamMemoryPack.Position = 0;
        return MemoryPackSerializer.DeserializeAsync<T>(payloadStreamMemoryPack).GetAwaiter().GetResult();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T MemoryPackDeserializeStreamUtf16()
    {
        payloadStreamMemoryPackUtf16.Position = 0;
        return MemoryPackSerializer.DeserializeAsync<T>(payloadStreamMemoryPackUtf16).GetAwaiter().GetResult();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T ProtobufNetDeserializeStream()
    {
        payloadStreamProtobuf.Position = 0;
        return ProtoBuf.Serializer.Deserialize<T>(payloadStreamProtobuf);
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T SystemTextJsonDeserializeStream()
    {
        payloadStreamJson.Position = 0;
        return System.Text.Json.JsonSerializer.DeserializeAsync<T>(payloadStreamJson).GetAwaiter().GetResult();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize, Categories.Stream)]
    public T OrleansDeserializeStream()
    {
        try
        {
            payloadStreamOrleans.Position = 0;
            var reader = Reader.Create(payloadStreamOrleans, session);
            return orleansSerializer.Deserialize(ref reader);
        }
        finally
        {
            session.PartialReset();
        }
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/ListFormatterVsDirect.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using Benchmark.Models;
using MemoryPack;
using MemoryPack.Formatters;
using Orleans.Serialization.Buffers;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Benchmarks;

public class ListFormatterVsDirect
{
    List<MyClass> value;
    byte[] bytes;
    IMemoryPackFormatter<List<MyClass?>> formatter;
    ArrayBufferWriter<byte> buffer;
    MemoryPackWriterOptionalState state;
    MemoryPackReaderOptionalState state2;

    public ListFormatterVsDirect()
    {
        value = Enumerable.Range(0, 100)
            .Select(_ => new MyClass { X = 100, Y = 99999999, Z = 4444, FirstName = "Hoge Huga Tako", LastName = "あいうえおかきくけこ" })
            .ToList();
        bytes = MemoryPackSerializer.Serialize(value);
        formatter = new ListFormatter<MyClass>();
        buffer = new ArrayBufferWriter<byte>(bytes.Length);

        state = MemoryPackWriterOptionalStatePool.Rent(null);
        state2 = MemoryPackReaderOptionalStatePool.Rent(null);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public void SerializeFormatter()
    {
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
        formatter.Serialize(ref writer, ref value!);
        writer.Flush();
        buffer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public void SerializePackable()
    {
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
        MemoryPack.Formatters.ListFormatter.SerializePackable(ref writer, value!);
        writer.Flush();
        buffer.Clear();
    }


    [Benchmark, BenchmarkCategory(Categories.Deserialize)]
    public void DeserializeFormatter()
    {
        List<MyClass?>? list = null;
        var reader = new MemoryPackReader(bytes, state2);
        //reader.ReadPackableArray
        // var a = MemoryPack.Formatters.ListFormatter.DeserializePackable<(ref reader);
        formatter.Deserialize(ref reader, ref list);
        reader.Dispose();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize)]
    public void DeserializePackable()
    {
        List<MyClass?>? list = null;
        var reader = new MemoryPackReader(bytes, state2);
        ListFormatter.DeserializePackable(ref reader, ref list!);
        reader.Dispose();
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/SerializerTestBase.cs
================================================
﻿using Benchmark.Models;
using BinaryPack.Models;
using MemoryPack.Formatters;

namespace Benchmark.Benchmarks;

// Value common setup.

public abstract class SerializerTestBase<T>
{
    protected T value { get; set; }


    public SerializerTestBase()
    {
        if (typeof(T) == typeof(int))
        {
            value = (T)(object)999999;
        }
        else if (typeof(T) == typeof(Vector3[]))
        {
            value = (T)(object)Enumerable.Repeat(new Vector3 { X = 10.3f, Y = 40.5f, Z = 13411.3f }, 1000).ToArray();
        }
        else if (typeof(T) == typeof(MyClass))
        {
            value = (T)(object)new MyClass { X = 100, Y = 99999999, Z = 4444, FirstName = "Hoge Huga Tako", LastName = "あいうえおかきくけこ" };
        }
        else if (typeof(T) == typeof(JsonResponseModel))
        {
            var model = new JsonResponseModel();
            model.Initialize();
            value = (T)(object)model;
        }
        else if (typeof(T) == typeof(NeuralNetworkLayerModel))
        {
            var model = new NeuralNetworkLayerModel();
            model.Initialize();
            value = (T)(object)model;
        }
        else
        {
            throw new InvalidOperationException($"Type {typeof(T)} is not registered create value.");
        }
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/SerializeTest.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using Benchmark.Micro;
using Benchmark.Models;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Order;
using BenchmarkDotNet.Running;
using BinaryPack.Models;
using MemoryPack;
using MemoryPack.Formatters;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Orleans;
using Orleans.Serialization;
using Orleans.Serialization.Buffers;
using Orleans.Serialization.Session;
using ProtoBuf;
using System;
using System.Buffers;
using System.IO.Pipelines;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;

namespace Benchmark.Benchmarks;

//[GenericTypeArguments(typeof(int))]
//[GenericTypeArguments(typeof(Vector3[]))]
//[GenericTypeArguments(typeof(JsonResponseModel))]
//[GenericTypeArguments(typeof(NeuralNetworkLayerModel))]
[CategoriesColumn]
[PayloadColumn]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
public class SerializeTest<T> : SerializerTestBase<T>
{
    ArrayBufferWriter<byte> writer;
    MemoryStream stream;
    Utf8JsonWriter jsonWriter;
    SerializerSession session;
    Serializer<T> orleansSerializer;

    public SerializeTest()
        : base()
    {
        // Orleans
        var serviceProvider = new ServiceCollection()
            .AddSerializer(builder => builder.AddAssembly(typeof(SerializeTest<>).Assembly))
            .BuildServiceProvider();
        session = serviceProvider.GetRequiredService<SerializerSessionPool>().GetSession();
        orleansSerializer = serviceProvider.GetRequiredService<Serializer<T>>();

        // create buffers
        stream = new MemoryStream();

        var serialize1 = orleansSerializer.SerializeToArray(value);
        var serialize2 = MessagePackSerializer.Serialize(value);
        ProtoBuf.Serializer.Serialize(stream, value);
        var serialize3 = stream.ToArray();
        stream.Position = 0;
        var serialize4 = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(value));
        var serialize5 = MemoryPackSerializer.Serialize(value);

        writer = new ArrayBufferWriter<byte>(new[] { /* serialize1, */ serialize2, serialize3, serialize4, serialize5 }.Max(x => x.Length));
        jsonWriter = new Utf8JsonWriter(writer);
    }

    [Benchmark, BenchmarkCategory(Categories.Bytes)]
    public byte[] MessagePackSerialize()
    {
        return MessagePackSerializer.Serialize(value);
    }

    [Benchmark(Baseline = true), BenchmarkCategory(Categories.Bytes)]
    public byte[] MemoryPackSerialize()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Default);
    }

    [Benchmark, BenchmarkCategory(Categories.Bytes)]
    public byte[] MemoryPackSerializeUtf16()
    {
        return MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf16);
    }

    // requires T:new(), can't test it.
    //[Benchmark]
    //public byte[] BinaryPackSerialize()
    //{
    //    return BinaryPack.BinaryConverter.Serialize(value);
    //}

    [Benchmark, BenchmarkCategory(Categories.Bytes)]
    public byte[] ProtobufNetSerialize()
    {
        ProtoBuf.Serializer.Serialize(stream, value);
        var array = stream.ToArray();
        stream.Position = 0;
        return array;
    }

    [Benchmark, BenchmarkCategory(Categories.Bytes)]
    public byte[] SystemTextJsonSerialize()
    {
        System.Text.Json.JsonSerializer.Serialize(stream, value);
        var array = stream.ToArray();
        stream.Position = 0;
        return array;
    }

    [Benchmark, BenchmarkCategory(Categories.Bytes)]
    public byte[] OrleansSerialize()
    {
        return orleansSerializer.SerializeToArray(value);
    }

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void MessagePackBufferWriter()
    {
        MessagePackSerializer.Serialize(writer, value);
        writer.Clear();
    }

    [Benchmark(Baseline = true), BenchmarkCategory(Categories.BufferWriter)]
    public void MemoryPackBufferWriter()
    {
        MemoryPackSerializer.Serialize(writer, value, MemoryPackSerializerOptions.Default);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void MemoryPackBufferWriterUtf16()
    {
        MemoryPackSerializer.Serialize(writer, value, MemoryPackSerializerOptions.Utf16);
        writer.Clear();
    }

    //[Benchmark]
    //public void BinaryPackStream()
    //{
    //    BinaryPack.BinaryConverter.Serialize(value, stream);
    //    stream.Position = 0;
    //}

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void ProtobufNetBufferWriter()
    {
        ProtoBuf.Serializer.Serialize(writer, value);
        writer.Clear();
    }

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void SystemTextJsonBufferWriter()
    {
        System.Text.Json.JsonSerializer.Serialize(jsonWriter, value);
        jsonWriter.Flush();
        writer.Clear();
        jsonWriter.Reset(writer);
    }

    // benchmark code is used orleans one. https://github.com/dotnet/orleans/pull/7984/

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void OrleansWriterPooledArrayBufferWriter()
    {
        var writer = Writer.CreatePooled(session);
        try
        {
            orleansSerializer.Serialize(value, ref writer);
        }
        finally
        {
            writer.Dispose();
            session.PartialReset();
        }
    }

    [Benchmark, BenchmarkCategory(Categories.BufferWriter)]
    public void OrleansWriterArrayBufferWriter()
    {
        var writer = this.writer.CreateWriter(session);
        try
        {
            orleansSerializer.Serialize(value, ref writer);
        }
        finally
        {
            writer.Dispose();
            session.PartialReset();
        }

        this.writer.Clear(); // clear ArrayBufferWriter<byte>
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/StaticDictionaryFormatter.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using BenchmarkDotNet.Configs;
using MemoryPack;
using MemoryPack.Formatters;
using MemoryPack.Internal;
using Microsoft.Diagnostics.Tracing;
using Orleans.Serialization.Buffers;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Formats.Asn1;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace Benchmark.Benchmarks;

[CategoriesColumn]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
public class StaticDictionaryFormatterCheck
{
    Dictionary<string, int> target;
    IMemoryPackFormatter<Dictionary<string, int>> current;
    IMemoryPackFormatter<Dictionary<string, int>> improvement;

    Dictionary<string, int> dict;
    ArrayBufferWriter<byte> buffer;
    MemoryPackWriterOptionalState state;
    MemoryPackReaderOptionalState state2;
    byte[] bytes;

    public StaticDictionaryFormatterCheck()
    {
        target = Enumerable.Range(1, 100)
            .ToDictionary(x => x.ToString(), x => x);

        current = new DictionaryFormatter<string, int>();
        improvement = new DictionaryFormatter2<string, int>();

        dict = new Dictionary<string, int>(100);

        bytes = MemoryPackSerializer.Serialize(target);

        buffer = new ArrayBufferWriter<byte>(bytes.Length);

        state = MemoryPackWriterOptionalStatePool.Rent(null);
        state2 = MemoryPackReaderOptionalStatePool.Rent(null);
    }

    //[Benchmark, BenchmarkCategory(Categories.Serialize)]
    //public void SerializeCurrent()
    //{
    //    var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
    //    current.Serialize(ref writer, ref target!);
    //    writer.Flush();
    //    buffer.Clear();
    //}

    //[Benchmark, BenchmarkCategory(Categories.Serialize)]
    //public void SerializeImprovement()
    //{
    //    var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
    //    improvement.Serialize(ref writer, ref target!);
    //    writer.Flush();
    //    buffer.Clear();
    //}

    [Benchmark, BenchmarkCategory(Categories.Deserialize)]
    public void DeserializeCurrent()
    {
        var reader = new MemoryPackReader(bytes, state2);
        current.Deserialize(ref reader, ref dict!);
        reader.Dispose();
    }

    [Benchmark, BenchmarkCategory(Categories.Deserialize)]
    public void DeserializeImprovement()
    {
        var reader = new MemoryPackReader(bytes, state2);

        improvement.Deserialize(ref reader, ref dict!);
        reader.Dispose();
    }
}


[Preserve]
sealed class DictionaryFormatter<TKey, TValue> : MemoryPackFormatter<Dictionary<TKey, TValue?>>
    where TKey : notnull
{
    static DictionaryFormatter()
    {
        if (!MemoryPackFormatterProvider.IsRegistered<KeyValuePair<TKey, TValue?>>())
        {
            MemoryPackFormatterProvider.Register(new KeyValuePairFormatter<TKey, TValue?>());
        }
    }

    readonly IEqualityComparer<TKey>? equalityComparer;

    public DictionaryFormatter()
        : this(null)
    {

    }

    public DictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
    {
        this.equalityComparer = equalityComparer;
    }

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Dictionary<TKey, TValue?>? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        var formatter = writer.GetFormatter<KeyValuePair<TKey, TValue?>>();

        writer.WriteCollectionHeader(value.Count);
        foreach (var item in value)
        {
            var v = item;
            formatter.Serialize(ref writer, ref v);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Dictionary<TKey, TValue?>? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (value == null)
        {
            value = new Dictionary<TKey, TValue?>(length, equalityComparer);
        }
        else
        {
            value.Clear();
        }

        var formatter = reader.GetFormatter<KeyValuePair<TKey, TValue?>>();
        for (int i = 0; i < length; i++)
        {
            KeyValuePair<TKey, TValue?> v = default;
            formatter.Deserialize(ref reader, ref v);
            value.Add(v.Key, v.Value);
        }
    }
}

[Preserve]
sealed class DictionaryFormatter2<TKey, TValue> : MemoryPackFormatter<Dictionary<TKey, TValue?>>
    where TKey : notnull
{
    readonly IEqualityComparer<TKey>? equalityComparer;

    public DictionaryFormatter2()
        : this(null)
    {

    }

    public DictionaryFormatter2(IEqualityComparer<TKey>? equalityComparer)
    {
        this.equalityComparer = equalityComparer;
    }

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Dictionary<TKey, TValue?>? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }
        
        var keyFormatter = writer.GetFormatter<TKey>();
        var valueFormatter = writer.GetFormatter<TValue>();

        writer.WriteCollectionHeader(value.Count);
        foreach (var item in value)
        {
            KeyValuePairFormatter.Serialize(keyFormatter!, valueFormatter!, ref writer, item!);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Dictionary<TKey, TValue?>? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }
        
        if (value == null)
        {
            value = new Dictionary<TKey, TValue?>(length, equalityComparer);
        }
        else
        {
            value.Clear();
        }

        var keyFormatter = reader.GetFormatter<TKey>();
        var valueFormatter = reader.GetFormatter<TValue>();
        for (int i = 0; i < length; i++)
        {
            KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
            value.Add(k!, v);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/Utf16VsUtf8.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using BinaryPack.Models.Helpers;
using MemoryPack;
using System.Net.Http;

namespace Benchmark.Benchmarks;

[PayloadColumn]
public class Utf16VsUtf8
{
    readonly string ascii;
    readonly string japanese;
    readonly string largeAscii;

    readonly byte[] utf16Jpn;
    readonly byte[] utf8Jpn;
    readonly byte[] utf16Ascii;
    readonly byte[] utf8Ascii;
    readonly byte[] utf16LargeAscii;
    readonly byte[] utf8LargeAscii;

    public Utf16VsUtf8()
    {
        this.japanese = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん";
        this.ascii = "abcedfghijklmnopqrstuvwxyz0123456789";
        this.utf16Jpn = MemoryPackSerializer.Serialize(japanese, MemoryPackSerializerOptions.Utf16);
        this.utf8Jpn = MemoryPackSerializer.Serialize(japanese, MemoryPackSerializerOptions.Utf8);
        this.utf16Ascii = MemoryPackSerializer.Serialize(ascii, MemoryPackSerializerOptions.Utf16);
        this.utf8Ascii = MemoryPackSerializer.Serialize(ascii, MemoryPackSerializerOptions.Utf8);

        this.largeAscii = RandomProvider.NextString(600);
        this.utf16LargeAscii = MemoryPackSerializer.Serialize(largeAscii, MemoryPackSerializerOptions.Utf16);
        this.utf8LargeAscii = MemoryPackSerializer.Serialize(largeAscii, MemoryPackSerializerOptions.Utf8);
    }

    [Benchmark]
    public byte[] SerializeUtf16Ascii()
    {
        return MemoryPackSerializer.Serialize(ascii, MemoryPackSerializerOptions.Utf16);
    }

    [Benchmark]
    public byte[] SerializeUtf16Japanese()
    {
        return MemoryPackSerializer.Serialize(japanese, MemoryPackSerializerOptions.Utf16);
    }

    [Benchmark]
    public byte[] SerializeUtf8Ascii()
    {
        return MemoryPackSerializer.Serialize(ascii, MemoryPackSerializerOptions.Utf8);
    }

    [Benchmark]
    public byte[] SerializeUtf8Japanese()
    {
        return MemoryPackSerializer.Serialize(japanese, MemoryPackSerializerOptions.Utf8);
    }

    [Benchmark]
    public byte[] SerializeUtf16LargeAscii()
    {
        return MemoryPackSerializer.Serialize(largeAscii, MemoryPackSerializerOptions.Utf16);
    }

    [Benchmark]
    public byte[] SerializeUtf8LargeAscii()
    {
        return MemoryPackSerializer.Serialize(largeAscii, MemoryPackSerializerOptions.Utf8);
    }

    [Benchmark]
    public void DeserializeUtf16Ascii()
    {
        MemoryPackSerializer.Deserialize<string>(utf16Ascii);
    }

    [Benchmark]
    public void DeserializeUtf16Japanese()
    {
        MemoryPackSerializer.Deserialize<string>(utf16Jpn);
    }

    [Benchmark]
    public void DeserializeUtf8Ascii()
    {
        MemoryPackSerializer.Deserialize<string>(utf8Ascii);
    }

    [Benchmark]
    public void DeserializeUtf8Japanese()
    {
        MemoryPackSerializer.Deserialize<string>(utf8Jpn);
    }

    [Benchmark]
    public void DeserializeUtf16LargeAscii()
    {
        MemoryPackSerializer.Deserialize<string>(utf16LargeAscii);
    }

    [Benchmark]
    public void DeserializeUtf8LargeAscii()
    {
        MemoryPackSerializer.Deserialize<string>(utf8LargeAscii);
    }
}



================================================
FILE: sandbox/Benchmark/Benchmarks/VersionTolerant.cs
================================================
﻿using Benchmark.BenchmarkNetUtilities;
using Benchmark.Models;
using BenchmarkDotNet.Configs;
using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Benchmarks;

[PayloadColumn]
[CategoriesColumn]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
public class VersionTolerant
{
    MyClass value1;
    VersionTolerantMyClass value2;
    byte[] serializedNormal;
    byte[] serializedVT;

    public VersionTolerant()
    {
        value1 = new MyClass
        {
            X = 100,
            Y = 332,
            Z = 942524,
            FirstName = "hogehoge",
            LastName = "ふがふが"
        };

        value2 = new VersionTolerantMyClass
        {
            X = 100,
            Y = 332,
            Z = 942524,
            FirstName = "hogehoge",
            LastName = "ふがふが"
        };

        serializedNormal = MemoryPackSerializer.Serialize(value1);
        serializedVT = MemoryPackSerializer.Serialize(value2);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] DefaultSerialzie()
    {
        return MemoryPackSerializer.Serialize(value1);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public byte[] VersionTolerantSerialize()
    {
        return MemoryPackSerializer.Serialize(value2);
    }


    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public MyClass? DefaultDeserialize()
    {
        return MemoryPackSerializer.Deserialize<MyClass>(serializedNormal);
    }

    [Benchmark, BenchmarkCategory(Categories.Serialize)]
    public VersionTolerantMyClass? VersionTolerantDeserialzie()
    {
        return MemoryPackSerializer.Deserialize<VersionTolerantMyClass>(serializedVT);
    }
}





================================================
FILE: sandbox/Benchmark/Micro/BlockCopy.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Micro;

public class BlockCopy
{
    byte[] buffer = default!;
    byte[] dest = default!;

    [Params(10, 100, 1000, 10000, 65536, 100000, 1000000)]
    public int BufferCount { get; set; }

    [GlobalSetup]
    public void Init()
    {
        buffer = new byte[BufferCount];
        buffer.AsSpan().Fill(99);
        dest = new byte[buffer.Length];
    }

    [Benchmark]
    public void MemoryCopy()
    {
        // Span CopyTo using Buffer.MemoryCopy
        buffer.AsSpan().CopyTo(dest);
    }

    [Benchmark]
    public void CopyBlockUnaligned()
    {
        Unsafe.CopyBlockUnaligned(ref MemoryMarshal.GetArrayDataReference(dest), ref MemoryMarshal.GetArrayDataReference(buffer), (uint)buffer.Length);
    }
}



================================================
FILE: sandbox/Benchmark/Micro/ConcurrentQueueVsStack.cs
================================================
﻿using System.Collections.Concurrent;

namespace Benchmark.Micro;

public class ConcurrentQueueVsStack
{
    ConcurrentQueue<MyClass> q;
    ConcurrentStack<MyClass> stack;

    public ConcurrentQueueVsStack()
    {
        q = new ConcurrentQueue<MyClass>();
        stack = new ConcurrentStack<MyClass>();

        for (int i = 0; i < 100; i++)
        {
            q.Enqueue(new MyClass());
            stack.Push(new MyClass());
        }
    }


    [Benchmark(Baseline = true)]
    public void Queue()
    {
        if (q.TryDequeue(out var v))
        {
            q.Enqueue(v);
        }
    }

    [Benchmark]
    public void Stack()
    {
        if (stack.TryPop(out var v))
        {
            stack.Push(v);
        }
    }

    public class MyClass
    {

    }
}



================================================
FILE: sandbox/Benchmark/Micro/GetLocalVsStaticField.cs
================================================
﻿using MemoryPack;
using MessagePack.Formatters;
using Microsoft.Diagnostics.Tracing.Parsers.ClrPrivate;
using Orleans.Serialization.Buffers;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Micro;

public class GetLocalVsStaticField
{
    ArrayBufferWriter<byte> bufferWriter;

    public GetLocalVsStaticField()
    {
        bufferWriter = new ArrayBufferWriter<byte>();
        GetFromProvider();
    }

    [Benchmark(Baseline = true)]
    public void GetFromProvider()
    {
        using var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        for (int i = 0; i < 100; i++)
        {
            writer.GetFormatter<int>().Serialize(ref writer, ref i);
        }
        bufferWriter.Clear();
    }

    [Benchmark]
    public void GetFromLocal()
    {
        using var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        var provider = writer.GetFormatter<int>();
        for (int i = 0; i < 100; i++)
        {
            provider.Serialize(ref writer, ref i);
        }
        bufferWriter.Clear();
    }
}



================================================
FILE: sandbox/Benchmark/Micro/Hyper.cs
================================================
﻿using Benchmark.Models;
using BenchmarkDotNet.Order;
using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Micro;

// [Orderer(SummaryOrderPolicy.FastestToSlowest)]
public class Hyper
{
    HyperTest test;
    byte[] bin;

    public Hyper()
    {
        var i = 0;
        test = new HyperTest()
        {
            // Gn
            A = i,
            B = i,
            C = DateTime.Now.Date,
            D = (uint)i,
            E = i,
            F = DateTime.Now - DateTime.Now.AddDays(-1),
            G = Guid.NewGuid(),
            H = TestEnum.three,
            //  I = i.ToString()
        };

        bin = MemoryPackSerializer.Serialize(test);
    }

    [Benchmark]
    public byte[] Serialize()
    {
        return MemoryPackSerializer.Serialize(test);
    }

    [Benchmark]
    public HyperTest? Deserialize()
    {
        return MemoryPackSerializer.Deserialize<HyperTest>(bin);
    }
}

public struct Foo
{
    public int X;
    public string Y;
}



================================================
FILE: sandbox/Benchmark/Micro/RawSerialize.cs
================================================
﻿using Benchmark.Models;
using MemoryPack;
using MessagePack;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Benchmark.Micro;

public class RawSerialize
{
    MyClass value;
    [ThreadStatic]
    static byte[]? bufferCache;

    [ThreadStatic]
    static ReusableLinkedArrayBufferWriter? staticWriter;

    public RawSerialize()
    {
        value = new MyClass { X = 100, Y = 99999999, Z = 4444, FirstName = "Hoge Huga Tako", LastName = "あいうえおかきくけこ" };
    }

    [Benchmark]
    public byte[] Raw()
    {
        var dest = bufferCache;
        if (dest == null)
        {
            dest = bufferCache = GC.AllocateUninitializedArray<byte>(60000, true);
        }

        ref var p = ref MemoryMarshal.GetArrayDataReference(dest);

        Unsafe.WriteUnaligned(ref p, value.X);
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, 4), value.Y);
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, 8), value.Z);


        var f = value.FirstName!;
        var len1 = f.Length * 2;
        ref readonly var p2 = ref f.GetPinnableReference();
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, 12), f.Length);
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref p, 16), ref Unsafe.As<char, byte>(ref Unsafe.AsRef(p2)), (uint)len1);

        var l = value.LastName!;
        var len2 = l.Length * 2;
        ref readonly var p3 = ref l.GetPinnableReference();
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref p, 16 + len1), l.Length); ;
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref p, 20 + len1), ref Unsafe.As<char, byte>(ref Unsafe.AsRef(p3)), (uint)len2);

        var result = GC.AllocateUninitializedArray<byte>(20 + len1 + len2);

        dest.AsSpan(0, result.Length).CopyTo(result);

        return result;
    }

    [Benchmark]
    public byte[] MessagePackSerialize()
    {
        return MessagePackSerializer.Serialize(value);
    }

    [Benchmark]
    public byte[] HandMemoryPackWriterEmpty()
    {
        var bufWriter = staticWriter;
        if (bufWriter == null)
        {
            bufWriter = staticWriter = new ReusableLinkedArrayBufferWriter(true, true);
        }

        var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufWriter, bufWriter.DangerousGetFirstBuffer(), state);
        try
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                goto END;
            }

        //writer.WriteObjectHeader(5);
        //writer.WriteUnmanaged(value.X, value.Y, value.Z);
        //writer.WriteString(value.FirstName);
        //writer.WriteString(value.LastName);



        END:
            writer.Flush();
            return bufWriter.ToArrayAndReset();
        }
        finally
        {
            bufWriter.Reset();
            state.Reset();
        }
    }

    [Benchmark]
    public byte[] HandMemoryPackWriterHeaderOnly()
    {
        var bufWriter = staticWriter;
        if (bufWriter == null)
        {
            bufWriter = staticWriter = new ReusableLinkedArrayBufferWriter(true, true);
        }

        var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufWriter, bufWriter.DangerousGetFirstBuffer(), state);
        try
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                goto END;
            }

            writer.WriteObjectHeader(5);
        //writer.WriteUnmanaged(value.X, value.Y, value.Z);
        //writer.WriteString(value.FirstName);
        //writer.WriteString(value.LastName);


        END:
            writer.Flush();
            return bufWriter.ToArrayAndReset();
        }
        finally
        {
            bufWriter.Reset();
            state.Reset();
        }
    }

    [Benchmark]
    public byte[] HandMemoryPackWriterHeaderInt3()
    {
        var bufWriter = staticWriter;
        if (bufWriter == null)
        {
            bufWriter = staticWriter = new ReusableLinkedArrayBufferWriter(true, true);
        }

        var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufWriter, bufWriter.DangerousGetFirstBuffer(), state);
        try
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                goto END;
            }

            writer.WriteObjectHeader(5);
            writer.WriteUnmanaged(value.X, value.Y, value.Z);
        //writer.WriteString(value.FirstName);
        //writer.WriteString(value.LastName);


        END:
            writer.Flush();
            return bufWriter.ToArrayAndReset();
        }
        finally
        {
            bufWriter.Reset();
            state.Reset();
        }
    }

    [Benchmark]
    public byte[] HandMemoryPackWriterHeaderInt3String1()
    {
        var bufWriter = staticWriter;
        if (bufWriter == null)
        {
            bufWriter = staticWriter = new ReusableLinkedArrayBufferWriter(true, true);
        }

        var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufWriter, bufWriter.DangerousGetFirstBuffer(), state);
        try
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                goto END;
            }

            writer.WriteObjectHeader(5);
            writer.WriteUnmanaged(value.X, value.Y, value.Z);
            writer.WriteString(value.FirstName);
        //writer.WriteString(value.LastName);


        END:
            writer.Flush();
            return bufWriter.ToArrayAndReset();
        }
        finally
        {
            bufWriter.Reset();
            state.Reset();
        }
    }

    [Benchmark]
    public byte[] HandMemoryPackFull()
    {
        var bufWriter = staticWriter;
        if (bufWriter == null)
        {
            bufWriter = staticWriter = new ReusableLinkedArrayBufferWriter(true, true);
        }

        var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufWriter, bufWriter.DangerousGetFirstBuffer(), state);
        try
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                goto END;
            }

            writer.WriteObjectHeader(5);
            writer.WriteUnmanaged(value.X, value.Y, value.Z);
            writer.WriteString(value.FirstName);
            writer.WriteString(value.LastName);


        END:
            writer.Flush();
            return bufWriter.ToArrayAndReset();
        }
        finally
        {
            bufWriter.Reset();
            state.Reset();
        }
    }

    [Benchmark]
    public byte[] MemoryPackSerialize()
    {
        return MemoryPackSerializer.Serialize(value);
    }
}


internal sealed class ReusableLinkedArrayBufferWriter : IBufferWriter<byte>
{
    const int InitialBufferSize = 262144; // 256K(32768, 65536, 131072, 262144)
    static readonly byte[] noUseFirstBufferSentinel = new byte[0];

    List<BufferSegment> buffers; // add freezed buffer.

    byte[] firstBuffer; // cache firstBuffer to avoid call ArrayPoo.Rent/Return
    int firstBufferWritten;

    BufferSegment current;
    int nextBufferSize;

    int totalWritten;

    public int TotalWritten => totalWritten;
    bool UseFirstBuffer => firstBuffer != noUseFirstBufferSentinel;

    public ReusableLinkedArrayBufferWriter(bool useFirstBuffer, bool pinned)
    {
        this.buffers = new List<BufferSegment>();
        this.firstBuffer = useFirstBuffer
            ? GC.AllocateUninitializedArray<byte>(InitialBufferSize, pinned)
            : noUseFirstBufferSentinel;
        this.firstBufferWritten = 0;
        this.current = default;
        this.nextBufferSize = InitialBufferSize;
        this.totalWritten = 0;
    }

    public byte[] DangerousGetFirstBuffer() => firstBuffer;

    public Memory<byte> GetMemory(int sizeHint = 0)
    {
        // MemoryPack don't use GetMemory.
        throw new NotSupportedException();
    }

    public Span<byte> GetSpan(int sizeHint = 0)
    {
        if (current.IsNull)
        {
            // use firstBuffer
            var free = firstBuffer.Length - firstBufferWritten;
            if (free != 0 && sizeHint <= free)
            {
                return firstBuffer.AsSpan(firstBufferWritten);
            }
        }
        else
        {
            var buffer = current.FreeBuffer;
            if (buffer.Length > sizeHint)
            {
                return buffer;
            }
        }

        BufferSegment next;
        if (sizeHint <= nextBufferSize)
        {
            next = new BufferSegment(nextBufferSize);
            nextBufferSize *= 2;
        }
        else
        {
            next = new BufferSegment(sizeHint);
        }

        if (current.WrittenCount != 0)
        {
            buffers.Add(current);
        }
        current = next;
        return next.FreeBuffer;
    }

    public void Advance(int count)
    {
        if (current.IsNull)
        {
            firstBufferWritten += count;
        }
        else
        {
            current.Advance(count);
        }
        totalWritten += count;
    }

    public byte[] ToArrayAndReset()
    {
        if (totalWritten == 0) return Array.Empty<byte>();

        var result = GC.AllocateUninitializedArray<byte>(totalWritten);
        var dest = result.AsSpan();

        if (UseFirstBuffer)
        {
            firstBuffer.AsSpan(0, firstBufferWritten).CopyTo(dest);
            dest = dest.Slice(firstBufferWritten);
        }

        if (buffers.Count > 0)
        {
            foreach (var item in CollectionsMarshal.AsSpan(buffers))
            {
                item.WrittenBuffer.CopyTo(dest);
                dest = dest.Slice(item.WrittenCount);
                item.Clear(); // reset buffer-segment in this loop to avoid iterate twice for Reset
            }
        }

        if (!current.IsNull)
        {
            current.WrittenBuffer.CopyTo(dest);
            current.Clear();
        }

        ResetCore();
        return result;
    }

    public void WriteToAndReset<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer)
        where TBufferWriter : IBufferWriter<byte>
    {
        if (totalWritten == 0) return;

        if (UseFirstBuffer)
        {
            ref var spanRef = ref writer.GetSpanReference(firstBufferWritten);
            firstBuffer.AsSpan(0, firstBufferWritten).CopyTo(MemoryMarshal.CreateSpan(ref spanRef, firstBufferWritten));
            writer.Advance(firstBufferWritten);
        }

        if (buffers.Count > 0)
        {
            foreach (var item in CollectionsMarshal.AsSpan(buffers))
            {
                ref var spanRef = ref writer.GetSpanReference(item.WrittenCount);
                item.WrittenBuffer.CopyTo(MemoryMarshal.CreateSpan(ref spanRef, item.WrittenCount));
                writer.Advance(item.WrittenCount);
                item.Clear(); // reset
            }
        }

        if (!current.IsNull)
        {
            ref var spanRef = ref writer.GetSpanReference(current.WrittenCount);
            current.WrittenBuffer.CopyTo(MemoryMarshal.CreateSpan(ref spanRef, current.WrittenCount));
            writer.Advance(current.WrittenCount);
            current.Clear();
        }

        writer.Flush();

        ResetCore();
    }

    public async ValueTask WriteToAndResetAsync(Stream stream, CancellationToken cancellationToken)
    {
        if (totalWritten == 0) return;

        if (UseFirstBuffer)
        {
            await stream.WriteAsync(firstBuffer.AsMemory(0, firstBufferWritten), cancellationToken).ConfigureAwait(false);
        }

        if (buffers.Count > 0)
        {
            foreach (var item in buffers)
            {
                await stream.WriteAsync(item.WrittenMemory, cancellationToken).ConfigureAwait(false);
                item.Clear(); // reset
            }
        }

        if (!current.IsNull)
        {
            await stream.WriteAsync(current.WrittenMemory, cancellationToken).ConfigureAwait(false);
            current.Clear();
        }

        ResetCore();
    }

    // reset without list's BufferSegment element
    void ResetCore()
    {
        firstBufferWritten = 0;
        buffers.Clear();
        totalWritten = 0;
        current = default;
        nextBufferSize = InitialBufferSize;
    }

    public void Reset()
    {
        if (totalWritten == 0) return;
        foreach (var item in CollectionsMarshal.AsSpan(buffers))
        {
            item.Clear();
        }
        ResetCore();
    }
}

internal struct BufferSegment
{
    byte[] buffer;
    int written;

    public bool IsNull => buffer == null;

    public int WrittenCount => written;
    public Span<byte> WrittenBuffer => buffer.AsSpan(0, written);
    public Memory<byte> WrittenMemory => buffer.AsMemory(0, written);
    public Span<byte> FreeBuffer => buffer.AsSpan(written);

    public BufferSegment(int size)
    {
        buffer = ArrayPool<byte>.Shared.Rent(size);
        written = 0;
    }

    public void Advance(int count)
    {
        written += count;
    }

    public void Clear()
    {
        if (buffer != null)
        {
            ArrayPool<byte>.Shared.Return(buffer);
        }
        buffer = null!;
        written = 0;
    }
}



================================================
FILE: sandbox/Benchmark/Micro/SerializeInt.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Benchmark.Micro;

public class SerializeInt
{
    int value;

    public SerializeInt()
    {
        value = int.Parse("9999");
    }

    [Benchmark]
    [SkipLocalsInit]
    public byte[] UseSpan()
    {
        Span<byte> buffer = stackalloc byte[sizeof(int)];
        Unsafe.WriteUnaligned(ref MemoryMarshal.GetReference(buffer), value);
        return buffer.ToArray();
    }

    [Benchmark]
    public unsafe byte[] NoCopy()
    {
        var array = GC.AllocateUninitializedArray<byte>(sizeof(int));
        Unsafe.WriteUnaligned(ref MemoryMarshal.GetArrayDataReference(array), value);
        return array;
    }
}



================================================
FILE: sandbox/Benchmark/Micro/SpanSliceTest.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using MemoryPack;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Micro;

public class SpanSliceTest
{
    byte[] raw = new byte[1000];
    const int SliceCount = 100;

    [Benchmark]
    public void SpanSlice()
    {
        var writer = new SpanWriter(raw);
        for (int i = 0; i < SliceCount; i++)
        {
            writer.Advance(10);
        }
    }

    [Benchmark]
    public void RefReferenceAdd()
    {
        var writer = new SpanRefWriter(raw);
        for (int i = 0; i < SliceCount; i++)
        {
            writer.Advance(10);
        }
    }

    [Benchmark]
    public void ReadOnlySequenceSlice()
    {
        var seq = new ReadOnlySequence<byte>(raw);
        for (int i = 0; i < SliceCount; i++)
        {
            seq = seq.Slice(10);
        }
    }
}

public ref struct SpanWriter
{
    Span<byte> raw;

    public SpanWriter(byte[] buffer)
    {
        raw = buffer;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        raw = raw.Slice(count);
    }
}

public ref struct SpanRefWriter
{
    ref byte bufferReference;
    int bufferLength;

    public SpanRefWriter(byte[] buffer)
    {
        bufferReference = ref MemoryMarshal.GetArrayDataReference(buffer);
        bufferLength = buffer.Length;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        var rest = bufferLength - count;
        if (rest < 0)
        {
            Throw();
        }

        bufferLength = rest;
        bufferReference = ref Unsafe.Add(ref bufferReference, count);
    }

    [DoesNotReturn]
    void Throw()
    {
        throw new InvalidOperationException();
    }
}



================================================
FILE: sandbox/Benchmark/Micro/StaticAbstractVsFormatter.cs
================================================
﻿using MemoryPack;
using System.Buffers;

namespace Benchmark.Micro;

public class StaticAbstractVsFormatter
{
    IntClass value;
    ArrayBufferWriter<byte> bufferWriter;
    IMemoryPackFormatter<IntClass> formatter;

    public StaticAbstractVsFormatter()
    {
        this.value = new IntClass { Value = 999999 };
        this.bufferWriter = new ArrayBufferWriter<byte>(99999);

        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        this.formatter = writer.GetFormatter<IntClass>();
    }

    [Benchmark]
    public void WriteValue()
    {
        bufferWriter.Clear();
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        
        writer.WriteValue(value); // GetFormatter<T>.Serialize(ref writer, ref value);
    }

    [Benchmark]
    public void FormatterSerialize()
    {
        bufferWriter.Clear();
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        formatter.Serialize(ref writer, ref value!); // IMemoryPackFormatter<T>.Serialize(ref writer, rf value)
    }

    [Benchmark(Baseline = true)]
    public void WritePackable()
    {
        bufferWriter.Clear();
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        writer.WritePackable(value); // T.Serialize(ref writer, ref value);
    }

    [Benchmark]
    public void Direct()
    {
        bufferWriter.Clear();
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref bufferWriter, state);
        writer.WriteUnmanagedWithObjectHeader(1, value.Value);
    }















}

[MemoryPackable]
public partial class IntClass
{
    public int Value { get; set; }
}


[MemoryPackable]
public partial class IntClass2
{
    public int Value { get; set; }
}




================================================
FILE: sandbox/Benchmark/Micro/Utf8Decoding.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Unicode;
using System.Threading.Tasks;

namespace Benchmark.Micro;

public class Utf8Decoding
{
    byte[] utf8bytes;
    int utf8length;
    int utf16length;

    public Utf8Decoding()
    {
        // Japanese Hiragana
        var text = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん";
        utf8bytes = Encoding.UTF8.GetBytes(text);
        utf8length = utf8bytes.Length;
        utf16length = text.Length;
    }

    [Benchmark]
    public string UTF8GetString()
    {
        return Encoding.UTF8.GetString(utf8bytes);
    }

    [Benchmark]
    public string Utf16LengthUtf8ToUtf16()
    {
        return string.Create(utf16length, utf8bytes, static (dest, source) =>
        {
            Utf8.ToUtf16(source, dest, out var read, out var written);
        });
    }
}



================================================
FILE: sandbox/Benchmark/Models/HyperTest.cs
================================================
﻿using MemoryPack;

namespace Benchmark.Models;

public enum TestEnum
{
    one, two, three
}

[MemoryPackable]
public partial class HyperTest
{
    public Guid? Gn { get; set; }
    public int A { get; set; }
    public long B { get; set; }
    public DateTime C { get; set; }
    public uint D { get; set; }
    public decimal E { get; set; }
    public TimeSpan F { get; set; }
    public Guid G { get; set; }
    public TestEnum H { get; set; }
}



================================================
FILE: sandbox/Benchmark/Models/JilExtensionMethods.cs
================================================
﻿#nullable disable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark
{
    public interface IGenericEquality<T>
    {
        bool Equals(T obj);
        bool EqualsDynamic(dynamic obj);
    }

    static class JilExtensionMethods
    {
        static readonly char[] ASCII;

        static JilExtensionMethods()
        {
            // mod 32~122
            var cs = new List<char>();

            //for (var i = 0; i <= byte.MaxValue; i++)
            for (var i = 32; i <= 122; i++)
            {
                var c = (char)i;
                if (char.IsControl(c)) continue;

                cs.Add(c);
            }

            ASCII = cs.ToArray();
        }

        public static bool TrueEqualsDictionary<K, V>(this Dictionary<K, V> a, Dictionary<K, V> b)
            where V : class, IGenericEquality<V>
        {
            if (object.ReferenceEquals(a, null) && object.ReferenceEquals(b, null)) return true;
            if (object.ReferenceEquals(a, null)) return false;
            if (object.ReferenceEquals(b, null)) return false;

            if (a.Count != b.Count) return false;

            foreach (var kv in a)
            {
                V bv;
                if (!b.TryGetValue(kv.Key, out bv)) return false;
                if (!kv.Value.TrueEquals(bv)) return false;
            }

            return true;
        }

        public static bool TrueEqualsString(this string a, string b)
        {
            return a == b;
        }

        public static bool TrueEqualsString(this IEnumerable<string> a, IEnumerable<string> b)
        {
            if (object.ReferenceEquals(a, null) && object.ReferenceEquals(b, null)) return true;
            if (object.ReferenceEquals(a, null)) return false;
            if (object.ReferenceEquals(b, null)) return false;

            if (a.Count() != b.Count()) return false;

            using (var e1 = a.GetEnumerator())
            using (var e2 = b.GetEnumerator())
            {
                while (e1.MoveNext() && e2.MoveNext())
                {
                    if (!e1.Current.TrueEqualsString(e2.Current)) return false;
                }
            }

            return true;
        }

        public static bool TrueEqualsList<T>(this IEnumerable<T> a, IEnumerable<T> b)
            where T : class, IGenericEquality<T>
        {
            if (object.ReferenceEquals(a, null) && object.ReferenceEquals(b, null)) return true;
            if (object.ReferenceEquals(a, null)) return false;
            if (object.ReferenceEquals(b, null)) return false;

            if (a.Count() != b.Count()) return false;

            using (var e1 = a.GetEnumerator())
            using (var e2 = b.GetEnumerator())
            {
                while (e1.MoveNext() && e2.MoveNext())
                {
                    if (!e1.Current.TrueEquals(e2.Current)) return false;
                }
            }

            return true;
        }

        public static bool TrueEqualsListDynamic<T>(this IEnumerable<T> a, IEnumerable<dynamic> b)
        where T : class, IGenericEquality<T>
        {
            if (object.ReferenceEquals(a, null) && object.ReferenceEquals(b, null)) return true;
            if (object.ReferenceEquals(a, null)) return false;
            if (object.ReferenceEquals(b, null)) return false;

            if (a.Count() != b.Count()) return false;

            using (var e1 = a.GetEnumerator())
            using (var e2 = b.GetEnumerator())
            {
                while (e1.MoveNext() && e2.MoveNext())
                {
                    var c1 = e1.Current;
                    var c2 = e2.Current;

                    if (c1 == null && c2 != null) return false;
                    if (c2 == null && c1 != null) return false;
                    if (!c1.EqualsDynamic(c2)) return false;
                }
            }

            return true;
        }

        public static bool TrueEqualsList<T>(this IEnumerable<T> a, dynamic dynB)
            where T : class, IGenericEquality<T>
        {
            var b = (IEnumerable<T>)dynB;
            return TrueEqualsList(a, b);
        }

        public static bool TrueEquals<T>(this T? a, T? b)
            where T : struct
        {
            if (!a.HasValue && !b.HasValue) return true;
            if (!a.HasValue) return false;
            if (!b.HasValue) return false;

            return a.Value.Equals(b.Value);
        }

        public static bool TrueEquals<T>(this T a, T b)
            where T : class, IGenericEquality<T>
        {
            if (object.ReferenceEquals(a, null) && object.ReferenceEquals(b, null)) return true;
            if (object.ReferenceEquals(a, null)) return false;
            if (object.ReferenceEquals(b, null)) return false;

            return a.Equals(b);
        }

        public static void ForEach<T>(this IEnumerable<T> enumerable, Action<T> a)
        {
            foreach (var e in enumerable)
            {
                a(e);
            }
        }

        public static IEnumerable<T> Random<T>(this IEnumerable<T> enumerable, Random rand)
        {
            return
                enumerable
                    .Select(i => new { i, _ = rand.Next() })
                    .OrderBy(o => o._)
                    .Select(o => o.i)
                    .ToList();
        }

        public static bool IsNullable(this Type t)
        {
            return Nullable.GetUnderlyingType(t) != null;
        }

        public static bool IsList(this Type t)
        {
            return
                (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IList<>)) ||
                t.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IList<>));
        }

        public static Type GetListInterface(this Type t)
        {
            return
                (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IList<>)) ?
                t :
                t.GetInterfaces().First(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IList<>));
        }

        public static bool IsDictionary(this Type t)
        {
            return
                (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IDictionary<,>)) ||
                t.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IDictionary<,>));
        }

        public static Type GetDictionaryInterface(this Type t)
        {
            return
                (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IDictionary<,>)) ?
                t :
                t.GetInterfaces().First(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IDictionary<,>));
        }

        public static object RandomValue(this Type t, Random rand, int depth = 0)
        {
            if (t.IsPrimitive)
            {
                if (t == typeof(byte))
                {
                    return (byte)(rand.Next(byte.MaxValue - byte.MinValue + 1) + byte.MinValue);
                }

                if (t == typeof(sbyte))
                {
                    return (sbyte)(rand.Next(sbyte.MaxValue - sbyte.MinValue + 1) + sbyte.MinValue);
                }

                if (t == typeof(short))
                {
                    return (short)(rand.Next(short.MaxValue - short.MinValue + 1) + short.MinValue);
                }

                if (t == typeof(ushort))
                {
                    return (ushort)(rand.Next(ushort.MaxValue - ushort.MinValue + 1) + ushort.MinValue);
                }

                if (t == typeof(int))
                {
                    var bytes = new byte[4];
                    rand.NextBytes(bytes);

                    return BitConverter.ToInt32(bytes, 0);
                }

                if (t == typeof(uint))
                {
                    var bytes = new byte[4];
                    rand.NextBytes(bytes);

                    return BitConverter.ToUInt32(bytes, 0);
                }

                if (t == typeof(long))
                {
                    var bytes = new byte[8];
                    rand.NextBytes(bytes);

                    return BitConverter.ToInt64(bytes, 0);
                }

                if (t == typeof(ulong))
                {
                    var bytes = new byte[8];
                    rand.NextBytes(bytes);

                    return BitConverter.ToUInt64(bytes, 0);
                }

                if (t == typeof(float))
                {
                    var bytes = new byte[4];
                    rand.NextBytes(bytes);

                    return BitConverter.ToSingle(bytes, 0);
                }

                if (t == typeof(double))
                {
                    var bytes = new byte[8];
                    rand.NextBytes(bytes);

                    return BitConverter.ToDouble(bytes, 0);
                }

                if (t == typeof(char))
                {
                    var roll = rand.Next(ASCII.Length);

                    return ASCII[roll];
                }

                if (t == typeof(bool))
                {
                    return (rand.Next(2) == 1);
                }

                throw new InvalidOperationException();
            }

            if (t == typeof(string))
            {
                var len = rand.Next(500);
                var c = new char[len];
                for (var i = 0; i < c.Length; i++)
                {
                    c[i] = (char)typeof(char).RandomValue(rand, depth + 1);
                }

                return new string(c);
            }

            if (t == typeof(DateTime))
            {
                var epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

                var bytes = new byte[4];
                rand.NextBytes(bytes);

                var secsOffset = BitConverter.ToInt32(bytes, 0);

                var retDate = epoch.AddSeconds(secsOffset);

                return retDate;
            }

            if (t.IsNullable())
            {
                // leave it unset
                if (rand.Next(2) == 0)
                {
                    // null!
                    return Activator.CreateInstance(t);
                }

                var underlying = Nullable.GetUnderlyingType(t);
                var val = underlying.RandomValue(rand, depth + 1);

                var cons = t.GetConstructor(new[] { underlying });

                return cons.Invoke(new object[] { val });
            }

            if (t.IsEnum)
            {
                var allValues = Enum.GetValues(t);
                var ix = rand.Next(allValues.Length);

                return allValues.GetValue(ix);
            }

            if (t.IsList())
            {
                if (rand.Next(2) == 0 || depth >= 10)
                {
                    return null;
                }

                var listI = t.GetListInterface();

                var valType = listI.GetGenericArguments()[0];

                var retT = typeof(List<>).MakeGenericType(valType);
                var ret = Activator.CreateInstance(retT);
                var add = retT.GetMethod("Add");

                var len = rand.Next(20);
                for (var i = 0; i < len; i++)
                {
                    var elem = valType.RandomValue(rand, depth + 1);
                    add.Invoke(ret, new object[] { elem });
                }

                return ret;
            }

            var retObj = Activator.CreateInstance(t);
            foreach (var p in t.GetProperties())
            {
                if (rand.Next(2) == 0) continue;

                var propType = p.PropertyType;

                p.SetValue(retObj, propType.RandomValue(rand, depth + 1));
            }

            return retObj;
        }

        public static double Median(this IEnumerable<double> e)
        {
            var inOrder = e.OrderBy(_ => _).ToList();

            if (inOrder.Count == 0) return 0;
            if (inOrder.Count == 1) return inOrder[0];

            if (inOrder.Count % 2 == 1)
            {
                return inOrder[inOrder.Count / 2 + 1];
            }

            var a = inOrder[inOrder.Count / 2];
            var b = inOrder[inOrder.Count / 2 + 1];

            return (a + b) / 2.0;
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/MyClass.cs
================================================
﻿using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models;

/// <summary>
/// My serialize class.
/// </summary>
[MessagePackObject]
[ProtoContract]
[MemoryPackable]
public partial class MyClass
{
    [Key(0)]
    [ProtoBuf.ProtoMember(1)]
    [Id(0)]
    public int X { get; set; }
    [Key(1)]
    [ProtoBuf.ProtoMember(2)]
    [Id(1)]
    public int Y { get; set; }
    [Key(2)]
    [ProtoBuf.ProtoMember(3)]
    [Id(2)]
    public int Z { get; set; }
    [Key(3)]
    [ProtoBuf.ProtoMember(4)]
    [Id(3)]
    public string? FirstName { get; set; }
    [Key(4)]
    [ProtoBuf.ProtoMember(5)]
    [Id(4)]
    public string? LastName { get; set; }
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantMyClass
{
    [MemoryPackOrder(0)]
    public int X { get; set; }
    [MemoryPackOrder(1)]
    public int Y { get; set; }
    [MemoryPackOrder(2)]
    public int Z { get; set; }
    [MemoryPackOrder(3)]
    public string? FirstName { get; set; }
    [MemoryPackOrder(4)]
    public string? LastName { get; set; }
}



================================================
FILE: sandbox/Benchmark/Models/Vector3.cs
================================================
﻿using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models;

[MessagePackObject]
[ProtoContract]
[GenerateSerializer]
public struct Vector3
{
    [Key(0)]
    [ProtoBuf.ProtoMember(1)]
    [Id(0)]
    public float X;
    [Key(1)]
    [ProtoBuf.ProtoMember(2)]
    [Id(1)]
    public float Y;
    [Key(2)]
    [ProtoBuf.ProtoMember(3)]
    [Id(2)]
    public float Z;
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/JsonResponseModel.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using BinaryPack.Models.Helpers;
using BinaryPack.Models.Interfaces;
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;

#nullable enable

namespace BinaryPack.Models
{
    /// <summary>
    /// A model that represents a container for a fake REST API response in JSON format
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class JsonResponseModel : IInitializable, IEquatable<JsonResponseModel>
    {
        [MemoryPackConstructor]
        public JsonResponseModel() { }

        public JsonResponseModel(bool initialize)
        {
            if (initialize) Initialize();
        }

        [Key(0), Id(0), ProtoMember(1)]
        public string? Id { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public string? Type { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public int Count { get; set; }

        [Key(3), Id(3), ProtoMember(4)]
        public DateTime CreationTime { get; set; }

        [Key(4), Id(4), ProtoMember(5)]
        public DateTime UpdateTime { get; set; }

        [Key(5), Id(5), ProtoMember(6)]
        public DateTime ExpirationTime { get; set; }

        [Key(6), Id(6), ProtoMember(7)]
        public string? PreviousPageId { get; set; }

        [Key(7), Id(7), ProtoMember(8)]
        public string? FollowingPageId { get; set; }

        [Key(8), Id(8), ProtoMember(9)]
        public List<ApiModelContainer>? ModelContainers { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Id = RandomProvider.NextString(6);
            Type = nameof(JsonResponseModel);
            Count = RandomProvider.NextInt();
            CreationTime = RandomProvider.NextDateTime();
            UpdateTime = RandomProvider.NextDateTime();
            ExpirationTime = RandomProvider.NextDateTime();
            PreviousPageId = RandomProvider.NextString(6);
            FollowingPageId = RandomProvider.NextString(6);
            ModelContainers = new List<ApiModelContainer>();
            for (int i = 0; i < 50; i++)
            {
                var model = new ApiModelContainer();
                model.Initialize();
                ModelContainers.Add(model);
            }
        }

        /// <inheritdoc/>
        public bool Equals(JsonResponseModel? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return
                Id == other.Id &&
                Type == other.Type &&
                Count == other.Count &&
                CreationTime.Equals(other.CreationTime) &&
                UpdateTime.Equals(other.UpdateTime) &&
                ExpirationTime.Equals(other.ExpirationTime) &&
                PreviousPageId == other.PreviousPageId &&
                FollowingPageId == other.FollowingPageId &&
                ModelContainers?.Count == other.ModelContainers?.Count &&
                ModelContainers.Zip(other.ModelContainers).All(p => p.First.Equals(p.Second));
        }
    }

    /// <summary>
    /// A model that represents a container for a fake API response
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class ApiModelContainer : IInitializable, IEquatable<ApiModelContainer>
    {
        [Key(0), Id(0), ProtoMember(1)]
        public string? Id { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public string? Type { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public RestApiModel? Model { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Id = RandomProvider.NextString(6);
            Type = nameof(JsonResponseModel);
            Model = new RestApiModel();
            Model.Initialize();
        }

        /// <inheritdoc/>
        public bool Equals(ApiModelContainer? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) throw new InvalidOperationException();
            return
                Id?.Equals(other.Id) == true &&
                Type?.Equals(other.Type) == true &&
                Model?.Equals(other.Model) == true;
        }
    }

    /// <summary>
    /// A model that represents a REST API response for a single item
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class RestApiModel : IInitializable, IEquatable<RestApiModel>
    {
        [Key(0), Id(0), ProtoMember(1)]
        public string? Id { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public string? Type { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public string? Parent { get; set; }

        [Key(3), Id(3), ProtoMember(4)]
        public string? Author { get; set; }

        [Key(4), Id(4), ProtoMember(5)]
        public string? Title { get; set; }

        [Key(5), Id(5), ProtoMember(6)]
        public string? Text { get; set; }

        [Key(6), Id(6), ProtoMember(7)]
        public string? Url { get; set; }

        [Key(7), Id(7), ProtoMember(8)]
        public string? HtmlContent { get; set; }

        [Key(8), Id(8), ProtoMember(9)]
        public int Upvotes { get; set; }

        [Key(9), Id(9), ProtoMember(10)]
        public int Downvotes { get; set; }

        [Key(10), Id(10), ProtoMember(11)]
        public float VotesRatio { get; set; }

        [Key(11), Id(11), ProtoMember(12)]
        public int Views { get; set; }

        [Key(12), Id(12), ProtoMember(13)]
        public int Clicks { get; set; }

        [Key(13), Id(13), ProtoMember(14)]
        public float ClicksRatio { get; set; }

        [Key(14), Id(14), ProtoMember(15)]
        public int NumberOfComments { get; set; }

        [Key(15), Id(15), ProtoMember(16)]
        public DateTime CreationTime { get; set; }

        [Key(16), Id(16), ProtoMember(17)]
        public DateTime UpdateTime { get; set; }

        [Key(17), Id(17), ProtoMember(18)]
        public DateTime ExpirationTime { get; set; }

        [Key(18), Id(18), ProtoMember(19)]
        public bool Flag1 { get; set; }

        [Key(19), Id(19), ProtoMember(20)]
        public bool Flag2 { get; set; }

        [Key(20), Id(20), ProtoMember(21)]
        public bool Flag3 { get; set; }

        [Key(21), Id(21), ProtoMember(22)]
        public bool Flag4 { get; set; }

        [Key(22), Id(22), ProtoMember(23)]
        public bool Flag5 { get; set; }

        [Key(23), Id(23), ProtoMember(24)]
        public string? Optional1 { get; set; }

        [Key(24), Id(24), ProtoMember(25)]
        public string? Optional2 { get; set; }

        [Key(25), Id(25), ProtoMember(26)]
        public string? Optional3 { get; set; }

        [Key(26), Id(26), ProtoMember(27)]
        public MediaInfoModel? Info { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Id = RandomProvider.NextString(6);
            Type = nameof(RestApiModel);
            Parent = RandomProvider.NextString(6);
            Author = RandomProvider.NextString(6);
            Title = RandomProvider.NextString(RandomProvider.NextInt(40, 120));
            if (RandomProvider.NextBool())
            {

                Text = RandomProvider.NextString(RandomProvider.NextInt(80, 400));
                Url = null;
                HtmlContent = RandomProvider.NextString(RandomProvider.NextInt(100, 600));
            }
            else
            {
                Text = null;
                Url = RandomProvider.NextString(RandomProvider.NextInt(80, 120));
                HtmlContent = null;
            }
            Upvotes = RandomProvider.NextInt();
            Downvotes = RandomProvider.NextInt();
            VotesRatio = Upvotes / (float)Downvotes;
            Views = RandomProvider.NextInt();
            Clicks = RandomProvider.NextInt();
            ClicksRatio = Views / (float)Clicks;
            NumberOfComments = RandomProvider.NextInt();
            CreationTime = RandomProvider.NextDateTime();
            UpdateTime = RandomProvider.NextDateTime();
            ExpirationTime = RandomProvider.NextDateTime();
            Flag1 = RandomProvider.NextBool();
            Flag2 = RandomProvider.NextBool();
            Flag3 = RandomProvider.NextBool();
            Flag4 = RandomProvider.NextBool();
            Flag5 = RandomProvider.NextBool();
            if (RandomProvider.NextBool()) Optional1 = RandomProvider.NextString(RandomProvider.NextInt(6, 20));
            if (RandomProvider.NextBool()) Optional2 = RandomProvider.NextString(RandomProvider.NextInt(6, 20));
            if (RandomProvider.NextBool()) Optional3 = RandomProvider.NextString(RandomProvider.NextInt(6, 20));
            if (RandomProvider.NextBool())
            {
                Info = new MediaInfoModel();
                Info.Initialize();
            }
        }

        /// <inheritdoc/>
        public bool Equals(RestApiModel? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return
                Id == other.Id &&
                Type == other.Type &&
                Parent == other.Parent &&
                Author == other.Author &&
                Title == other.Title &&
                Text == other.Text &&
                Url == other.Url &&
                HtmlContent == other.HtmlContent &&
                Upvotes == other.Upvotes &&
                Downvotes == other.Downvotes &&
                MathF.Abs(VotesRatio - other.VotesRatio) < 0.001f &&
                Views == other.Views &&
                Clicks == other.Clicks &&
                MathF.Abs(ClicksRatio - other.ClicksRatio) < 0.001f &&
                NumberOfComments == other.NumberOfComments &&
                CreationTime.Equals(other.CreationTime) &&
                UpdateTime.Equals(other.UpdateTime) &&
                ExpirationTime.Equals(other.ExpirationTime) &&
                Flag1 == other.Flag1 &&
                Flag2 == other.Flag2 &&
                Flag3 == other.Flag3 &&
                Flag4 == other.Flag4 &&
                Flag5 == other.Flag5 &&
                Optional1 == other.Optional1 &&
                Optional2 == other.Optional2 &&
                Optional3 == other.Optional3 &&
                (Info == null && other.Info == null ||
                 Info?.Equals(other.Info) == true);
        }
    }

    /// <summary>
    /// A model that represents a collection of fake images
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class MediaInfoModel : IInitializable, IEquatable<MediaInfoModel>
    {
        [Key(0), Id(0), ProtoMember(1)]
        public string? Id { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public string? AlbumUrl { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public bool Property { get; set; }

        [Key(3), Id(3), ProtoMember(4)]
        public List<ImageModel>? Images { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Id = RandomProvider.NextString(6);
            AlbumUrl = RandomProvider.NextString(100);
            Property = RandomProvider.NextBool();
            Images = new List<ImageModel>();
            int count = RandomProvider.NextInt() % 4 + 1;
            for (int i = 0; i < count; i++)
            {
                var model = new ImageModel();
                model.Initialize();
                Images.Add(model);
            }
        }

        /// <inheritdoc/>
        public bool Equals(MediaInfoModel? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return
                Id?.Equals(other.Id) == true &&
                AlbumUrl?.Equals(other.AlbumUrl) == true &&
                Property == other.Property &&
                Images?.Count == other.Images?.Count &&
                Images.Zip(other.Images).All(p => p.First.Equals(p.Second));
        }
    }

    /// <summary>
    /// A simple model that contains a fake URL to an image and some metadata
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class ImageModel : IInitializable, IEquatable<ImageModel>
    {
        [Key(0), Id(0), ProtoMember(1)]
        public string? Url { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public int Width { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public int Height { get; set; }

        [Key(3), Id(3), ProtoMember(4)]
        public float AspectRatio { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Url = RandomProvider.NextString(RandomProvider.NextInt(140, 200));
            Width = RandomProvider.NextInt();
            Height = RandomProvider.NextInt();
            AspectRatio = Width / (float)Height;
        }

        /// <inheritdoc/>
        public bool Equals(ImageModel? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) throw new InvalidOperationException();
            return
                Url?.Equals(other.Url) == true &&
                Width == other.Width &&
                Height == other.Height &&
                MathF.Abs(AspectRatio - other.AspectRatio) < 0.001f;
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/NeuralNetworkLayerModel.cs
================================================
﻿using System;
using System.Linq;
using BinaryPack.Models.Helpers;
using BinaryPack.Models.Interfaces;
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;

#nullable enable

namespace BinaryPack.Models
{
    /// <summary>
    /// A model that represents an example of a neural network model
    /// </summary>
    [Serializable]
    [MemoryPackable]
    [MessagePackObject]
    [ProtoContract]
    [Orleans.GenerateSerializer]
    public sealed partial class NeuralNetworkLayerModel : IInitializable, IEquatable<NeuralNetworkLayerModel>
    {
        [Key(0), Id(0), ProtoMember(1)]
        public string? Id { get; set; }

        [Key(1), Id(1), ProtoMember(2)]
        public int Index { get; set; }

        [Key(2), Id(2), ProtoMember(3)]
        public int Inputs { get; set; }

        [Key(3), Id(3), ProtoMember(4)]
        public int Outputs { get; set; }

        [Key(4), Id(4), ProtoMember(5)]
        public float[]? Weights { get; set; }

        [Key(5), Id(5), ProtoMember(6)]
        public float[]? Biases { get; set; }

        [Key(6), Id(6), ProtoMember(7)]
        public ActivationType Activation { get; set; }

        [Key(7), Id(7), ProtoMember(8)]
        public DateTime LastUpdateTime { get; set; }

        /// <inheritdoc/>
        public void Initialize()
        {
            Id = RandomProvider.NextString(16);
            Index = RandomProvider.NextInt();
            Inputs = RandomProvider.NextInt();
            Outputs = RandomProvider.NextInt();
            Weights = new float[65536];
            for (int i = 0; i < Weights.Length; i++)
            {
                Weights[i] = (float)RandomProvider.NextDouble();
            }
            Biases = new float[256];
            for (int i = 0; i < Biases.Length; i++)
            {
                Biases[i] = (float)RandomProvider.NextDouble();
            }
            Activation = ActivationType.Sigmoid;
            LastUpdateTime = DateTime.Now;
        }

        /// <inheritdoc/>
        public bool Equals(NeuralNetworkLayerModel? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return
                (Id == null && other.Id == null ||
                 Id?.Equals(other.Id) == true) &&
                Index == other.Index &&
                Inputs == other.Inputs &&
                Outputs == other.Outputs &&
                (Weights == null && other.Weights == null ||
                 Weights?.Length == other.Weights?.Length &&
                 Weights?.Zip(other.Weights).All(t => MathF.Abs(t.First - t.Second) < 0.001f) == true) &&
                (Biases == null && other.Biases == null ||
                 Biases?.Length == other.Biases?.Length &&
                 Biases?.Zip(other.Biases).All(t => MathF.Abs(t.First - t.Second) < 0.001f) == true) &&
                Activation == other.Activation &&
                LastUpdateTime.Equals(other.LastUpdateTime);
        }
    }

    /// <summary>
    /// A sample <see langword="enum"/> representing an activation function type for a neural network layer
    /// </summary>
    public enum ActivationType
    {
        Sigmoid
    }
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/Helpers/EqualityComparer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;

namespace BinaryPack.Models.Helpers
{
    /// <summary>
    /// A helper <see langword="class"/> with methods to match instances of specific types
    /// </summary>
    internal static class EqualityComparer
    {
        /// <summary>
        /// Checks whether or not two input <typeparamref name="T"/> values match
        /// </summary>
        /// <typeparam name="T">The type of items to compare</typeparam>
        /// <param name="a">The first <typeparamref name="T"/> value to compare</param>
        /// <param name="b">The second <typeparamref name="T"/> value to compare</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<T>(T a, T b) where T : IEquatable<T>
        {
            if (a != null && b != null) return a.Equals(b);
            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not two input <see cref="IEnumerable{T}"/> instances represent a structural match
        /// </summary>
        /// <typeparam name="T">The type of items in the input <see cref="IEnumerable{T}"/> instances</typeparam>
        /// <param name="a">The first <see cref="IEnumerable{T}"/> instance</param>
        /// <param name="b">The second <see cref="IEnumerable{T}"/> instance</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<T>(IEnumerable<T>? a, IEnumerable<T>? b) where T : IEquatable<T>
        {
            if (a != null && b != null)
            {
                if (a.Count() != b.Count()) return false;
                foreach ((T first, T second) in a.Zip(b))
                {
                    if (first != null && second != null && !first.Equals(second) ||
                        !(first == null && second == null)) return false;
                }

                return true;
            }

            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not the two input <see cref="IDictionary{TKey,TValue}"/> instances represent a structural match
        /// </summary>
        /// <typeparam name="TKey">The type of keys in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <typeparam name="TValue">The type of values in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <param name="a">The first <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <param name="b">The second <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<TKey, TValue>(IDictionary<TKey, TValue>? a, IDictionary<TKey, TValue>? b)
            where TKey : IEquatable<TKey>
            where TValue : IEquatable<TValue>
        {
            if (a != null && b != null)
            {
                if (a.Count != b.Count) return false;
                foreach ((TKey k, TValue aValue) in a)
                {
                    if (!b.TryGetValue(k, out TValue bValue)) return false;
                    if (aValue != null && bValue != null && !aValue.Equals(bValue) ||
                        !(aValue == null && bValue == null)) return false;
                }

                return true;
            }

            return a == null && b == null;
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/Helpers/RandomProvider.cs
================================================
﻿using System;
using System.Diagnostics.Contracts;
using System.Linq;

namespace BinaryPack.Models.Helpers
{
    /// <summary>
    /// A helper <see langword="class"/> with helper methods to create random values
    /// </summary>
    internal static class RandomProvider
    {
        /// <summary>
        /// Singleton <see cref="System.Random"/> instance (not thread safe)
        /// </summary>
        private static readonly Random Random = new Random();

        /// <summary>
        /// Creates a new random <see cref="bool"/> value
        /// </summary>
        [Pure]
        public static bool NextBool() => Random.Next() % 2 == 1;

        /// <summary>
        /// Creates a new random <see cref="int"/> value
        /// </summary>
        [Pure]
        public static int NextInt() => Random.Next();

        /// <summary>
        /// Creates a new random <see cref="int"/> value in a given interval
        /// </summary>
        /// <param name="min">The minim value in the interval</param>
        /// <param name="max">The maximum value in the interval</param>
        [Pure]
        public static int NextInt(int min, int max) => Random.Next(min, max);

        /// <summary>
        /// Creates a new random <see cref="double"/> value
        /// </summary>
        [Pure]
        public static double NextDouble() => Random.NextDouble();

        /// <summary>
        /// Creates a new random <see cref="DateTime"/> value
        /// </summary>
        [Pure]
        public static DateTime NextDateTime() => DateTime.Today.AddSeconds(Random.Next(0, 31536000)).ToUniversalTime();

        private const string Characters = "!?\"'#$&()*+,-.0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz{}";

        /// <summary>
        /// Creates a new random <see langword="string"/> with a specified length
        /// </summary>
        /// <param name="length">The length of the new <see langword="string"/> to create</param>
        [Pure]
        public static string NextString(int length) => new string((
            from _ in Enumerable.Range(0, length)
            let i = Random.Next(0, Characters.Length)
            select Characters[i]).ToArray());
    }
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/Helpers/StructuralComparer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;

#nullable enable

namespace BinaryPack.Models.Helpers
{
    /// <summary>
    /// A helper <see langword="class"/> with methods to match instances of specific types
    /// </summary>
    internal static class StructuralComparer
    {
        /// <summary>
        /// Checks whether or not two input <typeparamref name="T"/> values match
        /// </summary>
        /// <typeparam name="T">The type of items to compare</typeparam>
        /// <param name="a">The first <typeparamref name="T"/> value to compare</param>
        /// <param name="b">The second <typeparamref name="T"/> value to compare</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<T>(T? a, T? b) where T : class, IEquatable<T>
        {
            if (a != null && b != null) return a.Equals(b);
            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not two input <see cref="Nullable{T}"/> values match
        /// </summary>
        /// <typeparam name="T">The type of items to compare</typeparam>
        /// <param name="a">The first <see cref="Nullable{T}"/> value to compare</param>
        /// <param name="b">The second <see cref="Nullable{T}"/> value to compare</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<T>(T? a, T? b) where T : struct, IEquatable<T>
        {
            if (a != null && b != null) return a.Equals(b);
            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not two input <see cref="IEnumerable{T}"/> instances represent a structural match
        /// </summary>
        /// <typeparam name="T">The type of items in the input <see cref="IEnumerable{T}"/> instances</typeparam>
        /// <param name="a">The first <see cref="IEnumerable{T}"/> instance</param>
        /// <param name="b">The second <see cref="IEnumerable{T}"/> instance</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<T>(IEnumerable<T>? a, IEnumerable<T>? b) where T : IEquatable<T>
        {
            if (a != null && b != null)
            {
                if (a.Count() != b.Count()) return false;
                foreach ((T first, T second) in a.Zip(b))
                {
                    if (!(first != null && second != null && first.Equals(second) ||
                          first == null && second == null)) return false;
                }

                return true;
            }

            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not the two input <see cref="IDictionary{TKey,TValue}"/> instances represent a structural match
        /// </summary>
        /// <typeparam name="TKey">The type of keys in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <typeparam name="TValue">The type of values in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <param name="a">The first <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <param name="b">The second <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<TKey, TValue>(IDictionary<TKey, TValue?>? a, IDictionary<TKey, TValue?>? b)
            where TKey : IEquatable<TKey>
            where TValue : class, IEquatable<TValue>
        {
            if (a != null && b != null)
            {
                if (a.Count != b.Count) return false;
                foreach ((TKey k, TValue? aValue) in a)
                {
                    if (!b.TryGetValue(k, out TValue? bValue)) return false;
                    if (!(aValue != null && bValue != null && aValue.Equals(bValue) ||
                          aValue == null && bValue == null)) return false;
                }

                return true;
            }

            return a == null && b == null;
        }

        /// <summary>
        /// Checks whether or not the two input <see cref="IDictionary{TKey,TValue}"/> instances represent a structural match
        /// </summary>
        /// <typeparam name="TKey">The type of keys in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <typeparam name="TValue">The type of <see cref="Nullable{T}"/> values in the input <see cref="IDictionary{TKey,TValue}"/> instances</typeparam>
        /// <param name="a">The first <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <param name="b">The second <see cref="IDictionary{TKey,TValue}"/> instance</param>
        /// <returns><see langword="true"/> if both instances are either <see langword="null"/> or matching, <see langword="false"/> otherwise</returns>
        [Pure]
        public static bool IsMatch<TKey, TValue>(IDictionary<TKey, TValue?>? a, IDictionary<TKey, TValue?>? b)
            where TKey : IEquatable<TKey>
            where TValue : struct, IEquatable<TValue>
        {
            if (a != null && b != null)
            {
                if (a.Count != b.Count) return false;
                foreach ((TKey k, TValue? aValue) in a)
                {
                    if (!b.TryGetValue(k, out TValue? bValue)) return false;
                    if (!(aValue != null && bValue != null && aValue.Value.Equals(bValue.Value) ||
                          aValue == null && bValue == null)) return false;
                }

                return true;
            }

            return a == null && b == null;
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/BinaryPackModels/Interfaces/IInitializable.cs
================================================
﻿namespace BinaryPack.Models.Interfaces
{
    /// <summary>
    /// An <see langword="interface"/> for models that support a default initialization
    /// </summary>
    public interface IInitializable
    {
        /// <summary>
        /// Loads the custom default values for a given model
        /// </summary>
        void Initialize();
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/AccessToken.cs
================================================
﻿#nullable disable

using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class AccessToken : IGenericEquality<AccessToken>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string access_token { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public DateTime? expires_on_date { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? account_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public List<string> scope { get; set; }

        public bool Equals(AccessToken obj)
        {
            return
                access_token.TrueEqualsString(obj.access_token) ||
                expires_on_date.TrueEquals(obj.expires_on_date) ||
                account_id.TrueEquals(obj.account_id) ||
                scope.TrueEqualsString(obj.scope);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                access_token.TrueEqualsString((string)obj.access_token) ||
                expires_on_date.TrueEquals((DateTime?)obj.expires_on_date) ||
                account_id.TrueEquals((int?)obj.account_id) ||
                scope.TrueEqualsString((IEnumerable<string>)obj.scope);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/AccountMerge.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class AccountMerge : IGenericEquality<AccountMerge>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? old_account_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? new_account_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? merge_date { get; set; }

        public bool Equals(AccountMerge obj)
        {
            return
                old_account_id.TrueEquals(obj.old_account_id) &&
                new_account_id.TrueEquals(obj.new_account_id) &&
                merge_date.TrueEquals(obj.merge_date);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                old_account_id.TrueEquals((int?)obj.old_account_id) &&
                new_account_id.TrueEquals((int?)obj.new_account_id) &&
                merge_date.TrueEquals((DateTime?)obj.merge_date);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Answer.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Answer : IGenericEquality<Answer>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? question_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? answer_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? locked_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? last_edit_date { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public DateTime? last_activity_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? score { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public DateTime? community_owned_date { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public bool? is_accepted { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string body { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public ShallowUser owner { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public string title { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public int? up_vote_count { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public int? down_vote_count { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public List<Comment> comments { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public string link { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public List<string> tags { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public bool? upvoted { get; set; }
        [ProtoMember(19)]
        [Key(18), Id(18)]
        public bool? downvoted { get; set; }
        [ProtoMember(20)]
        [Key(19), Id(19)]
        public bool? accepted { get; set; }
        [ProtoMember(21)]
        [Key(20), Id(20)]
        public ShallowUser last_editor { get; set; }
        [ProtoMember(22)]
        [Key(21), Id(21)]
        public int? comment_count { get; set; }
        [ProtoMember(23)]
        [Key(22), Id(22)]
        public string body_markdown { get; set; }
        [ProtoMember(24)]
        [Key(23), Id(23)]
        public string share_link { get; set; }

        public bool Equals(Answer obj)
        {
            return
                this.accepted.TrueEquals(obj.accepted) &&
                this.answer_id.TrueEquals(obj.answer_id) &&
                this.body.TrueEqualsString(obj.body) &&
                this.body_markdown.TrueEqualsString(obj.body_markdown) &&
                this.comment_count.TrueEquals(obj.comment_count) &&
                this.comments.TrueEqualsList(obj.comments) &&
                this.community_owned_date.TrueEquals(obj.community_owned_date) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.down_vote_count.TrueEquals(obj.down_vote_count) &&
                this.downvoted.TrueEquals(obj.downvoted) &&
                this.is_accepted.TrueEquals(obj.is_accepted) &&
                this.last_activity_date.TrueEquals(obj.last_activity_date) &&
                this.last_edit_date.TrueEquals(obj.last_edit_date) &&
                this.last_editor.TrueEquals(obj.last_editor) &&
                this.link.TrueEqualsString(obj.link) &&
                this.locked_date.TrueEquals(obj.locked_date) &&
                this.owner.TrueEquals(obj.owner) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.score.TrueEquals(obj.score) &&
                this.share_link.TrueEqualsString(obj.share_link) &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title.TrueEqualsString(obj.title) &&
                this.up_vote_count.TrueEquals(obj.up_vote_count) &&
                this.upvoted.TrueEquals(obj.upvoted);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.accepted.TrueEquals((bool?)obj.accepted) &&
                this.answer_id.TrueEquals((int?)obj.answer_id) &&
                this.body.TrueEqualsString((string)obj.body) &&
                this.body_markdown.TrueEqualsString((string)obj.body_markdown) &&
                this.comment_count.TrueEquals((int?)obj.comment_count) &&
                this.comments.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.comments) &&
                this.community_owned_date.TrueEquals((DateTime?)obj.community_owned_date) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.down_vote_count.TrueEquals((int?)obj.down_vote_count) &&
                this.downvoted.TrueEquals((bool?)obj.downvoted) &&
                this.is_accepted.TrueEquals((bool?)obj.is_accepted) &&
                this.last_activity_date.TrueEquals((DateTime?)obj.last_activity_date) &&
                this.last_edit_date.TrueEquals((DateTime?)obj.last_edit_date) &&
                (this.last_editor == null && obj.last_editor == null || this.last_editor.EqualsDynamic(obj.last_editor)) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.locked_date.TrueEquals((DateTime?)obj.locked_date) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                this.score.TrueEquals((int?)obj.score) &&
                this.share_link.TrueEqualsString((string)obj.share_link) &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title.TrueEqualsString((string)obj.title) &&
                this.up_vote_count.TrueEquals((int?)obj.up_vote_count) &&
                this.upvoted.TrueEquals((bool?)obj.upvoted);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Badge.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum BadgeRank : byte
    {
        bronze = 3,
        silver = 2,
        gold = 1
    }

    public enum BadgeType
    {
        named = 1,
        tag_based = 2
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Badge : IGenericEquality<Badge>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? badge_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public BadgeRank? rank { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string name { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string description { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? award_count { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public BadgeType? badge_type { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public ShallowUser user { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public string link { get; set; }

        public bool Equals(Badge obj)
        {
            return
                this.award_count.TrueEquals(obj.award_count) &&
                this.badge_id.TrueEquals(obj.badge_id) &&
                this.badge_type.TrueEquals(obj.badge_type) &&
                this.description.TrueEqualsString(obj.description) &&
                this.link.TrueEqualsString(obj.link) &&
                this.name.TrueEqualsString(obj.name) &&
                this.rank.TrueEquals(obj.rank) &&
                this.user.TrueEquals(obj.user);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.award_count.TrueEquals((int?)obj.award_count) &&
                this.badge_id.TrueEquals((int?)obj.badge_id) &&
                this.badge_type.TrueEquals((BadgeType?)obj.badge_type) &&
                this.description.TrueEqualsString((string)obj.description) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.name.TrueEqualsString((string)obj.name) &&
                this.rank.TrueEquals((BadgeRank?)obj.rank) &&
                (this.user == null && obj.user == null || this.user.EqualsDynamic(obj.user));
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Comment.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum PostType : byte
    {
        question = 1,
        answer = 2
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Comment : IGenericEquality<Comment>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? comment_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? post_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public PostType? post_type { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? score { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public bool? edited { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public string body { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public ShallowUser owner { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public ShallowUser reply_to_user { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string link { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public string body_markdown { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public bool? upvoted { get; set; }

        public bool Equals(Comment obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.body_markdown.TrueEqualsString(obj.body_markdown) &&
                this.comment_id.TrueEquals(obj.comment_id) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.edited.TrueEquals(obj.edited) &&
                this.link.TrueEqualsString(obj.link) &&
                this.owner.TrueEquals(obj.owner) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.reply_to_user.TrueEquals(obj.reply_to_user) &&
                this.score.TrueEquals(obj.score) &&
                this.upvoted.TrueEquals(obj.upvoted);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                this.body_markdown.TrueEqualsString((string)obj.body_markdown) &&
                this.comment_id.TrueEquals((int?)obj.comment_id) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.edited.TrueEquals((bool?)obj.edited) &&
                this.link.TrueEqualsString((string)obj.link) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                (this.reply_to_user == null && obj.reply_to_user == null || this.reply_to_user.EqualsDynamic(obj.reply_to_user)) &&
                this.score.TrueEquals((int?)obj.score) &&
                this.upvoted.TrueEquals((bool?)obj.upvoted);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Error.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Error : IGenericEquality<Error>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? error_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string error_name { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string description { get; set; }

        public bool Equals(Error obj)
        {
            return
                this.error_id.TrueEquals(obj.error_id) &&
                this.error_name.TrueEqualsString(obj.error_name) &&
                this.description.TrueEqualsString(obj.description);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.error_id.TrueEquals((int?)obj.error_id) &&
                this.error_name.TrueEqualsString((string)obj.error_name) &&
                this.description.TrueEqualsString((string)obj.description);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Event.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum EventType : byte
    {
        question_posted = 1,
        answer_posted = 2,
        comment_posted = 3,
        post_edited = 4,
        user_created = 5
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Event : IGenericEquality<Event>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public EventType? event_type { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? event_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string link { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string excerpt { get; set; }

        public bool Equals(Event obj)
        {
            return
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.event_id.TrueEquals(obj.event_id) &&
                this.event_type.TrueEquals(obj.event_type) &&
                this.excerpt.TrueEqualsString(obj.excerpt) &&
                this.link.TrueEqualsString(obj.link);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.event_id.TrueEquals((int?)obj.event_id) &&
                this.event_type.TrueEquals((EventType?)obj.event_type) &&
                this.excerpt.TrueEqualsString((string)obj.excerpt) &&
                this.link.TrueEqualsString((string)obj.link);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Feed.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class MobileFeed : IGenericEquality<MobileFeed>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public List<MobileQuestion> hot_questions { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public List<MobileInboxItem> inbox_items { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public List<MobileQuestion> likely_to_answer_questions { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public List<MobileRepChange> reputation_events { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public List<MobileQuestion> cross_site_interesting_questions { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public List<MobileBadgeAward> badges { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public List<MobilePrivilege> earned_privileges { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public List<MobilePrivilege> upcoming_privileges { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public List<MobileCommunityBulletin> community_bulletins { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public List<MobileAssociationBonus> association_bonuses { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public List<MobileCareersJobAd> careers_job_ads { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public List<MobileBannerAd> banner_ads { get; set; }

        [ProtoMember(13)]
        [Key(12), Id(12)]
        public long? before { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public long? since { get; set; }

        [ProtoMember(15)]
        [Key(14), Id(14)]
        public int? account_id { get; set; }

        [ProtoMember(16)]
        [Key(15), Id(15)]
        public MobileUpdateNotice update_notice { get; set; }

        public bool Equals(MobileFeed obj)
        {
            return
                this.account_id == obj.account_id &&
                this.association_bonuses.TrueEqualsList(obj.association_bonuses) &&
                this.badges.TrueEqualsList(obj.badges) &&
                this.banner_ads.TrueEqualsList(obj.banner_ads) &&
                this.before == obj.before &&
                this.careers_job_ads.TrueEqualsList(obj.careers_job_ads) &&
                this.community_bulletins.TrueEqualsList(obj.community_bulletins) &&
                this.cross_site_interesting_questions.TrueEqualsList(obj.cross_site_interesting_questions) &&
                this.earned_privileges.TrueEqualsList(obj.earned_privileges) &&
                this.hot_questions.TrueEqualsList(obj.hot_questions) &&
                this.inbox_items.TrueEqualsList(obj.inbox_items) &&
                this.likely_to_answer_questions.TrueEqualsList(obj.likely_to_answer_questions) &&
                this.reputation_events.TrueEqualsList(obj.reputation_events) &&
                this.since == obj.since &&
                this.upcoming_privileges.TrueEqualsList(obj.upcoming_privileges) &&
                this.update_notice.TrueEquals(obj.update_notice);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.account_id == (int?)obj.account_id &&
                this.association_bonuses.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.association_bonuses) &&
                this.badges.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.badges) &&
                this.banner_ads.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.banner_ads) &&
                this.before == (long?)obj.before &&
                this.careers_job_ads.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.careers_job_ads) &&
                this.community_bulletins.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.community_bulletins) &&
                this.cross_site_interesting_questions.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.cross_site_interesting_questions) &&
                this.earned_privileges.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.earned_privileges) &&
                this.hot_questions.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.hot_questions) &&
                this.inbox_items.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.inbox_items) &&
                this.likely_to_answer_questions.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.likely_to_answer_questions) &&
                this.reputation_events.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.reputation_events) &&
                this.since == (long?)obj.since &&
                this.upcoming_privileges.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.upcoming_privileges) &&
                (this.update_notice == null && obj.update_notice == null || this.update_notice.EqualsDynamic(obj.update_notice));
        }
    }

    interface IMobileFeedBase<T> : IGenericEquality<T>
    {
        int? group_id { get; set; }
        long? added_date { get; set; }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileQuestion : IMobileFeedBase<MobileQuestion>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? question_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public long? question_creation_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string title { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public long? last_activity_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public List<string> tags { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public string site { get; set; }

        [ProtoMember(9)]
        [Key(8), Id(8)]
        public bool? is_deleted { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public bool? has_accepted_answer { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public int? answer_count { get; set; }

        public bool Equals(MobileQuestion obj)
        {
            return
                this.added_date == obj.added_date &&
                this.answer_count == obj.answer_count &&
                this.group_id == obj.group_id &&
                this.has_accepted_answer == obj.has_accepted_answer &&
                this.is_deleted == obj.is_deleted &&
                this.last_activity_date == obj.last_activity_date &&
                this.question_creation_date == obj.question_creation_date &&
                this.question_id == obj.question_id &&
                this.site == obj.site &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title == obj.title;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.answer_count == (int?)obj.answer_count &&
                this.group_id == (int?)obj.group_id &&
                this.has_accepted_answer == (bool?)obj.has_accepted_answer &&
                this.is_deleted == (bool?)obj.is_deleted &&
                this.last_activity_date == (long?)obj.last_activity_date &&
                this.question_creation_date == (long?)obj.question_creation_date &&
                this.question_id == (int?)obj.question_id &&
                this.site == (string)obj.site &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title == (string)obj.title;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileRepChange : IMobileFeedBase<MobileRepChange>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string site { get; set; }

        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string title { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string link { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? rep_change { get; set; }

        public bool Equals(MobileRepChange obj)
        {
            return
                this.added_date == obj.added_date &&
                this.group_id == obj.group_id &&
                this.link == obj.link &&
                this.rep_change == obj.rep_change &&
                this.site == obj.site &&
                this.title == obj.title;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.group_id == (int?)obj.group_id &&
                this.link == (string)obj.link &&
                this.rep_change == (int?)obj.rep_change &&
                this.site == (string)obj.site &&
                this.title == (string)obj.title;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileInboxItem : IMobileFeedBase<MobileInboxItem>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? answer_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string body { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? comment_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public long? creation_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public string item_type { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public string link { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? question_id { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string title { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public string site { get; set; }

        public bool Equals(MobileInboxItem obj)
        {
            return
                this.added_date == obj.added_date &&
                this.answer_id == obj.answer_id &&
                this.body == obj.body &&
                this.comment_id == obj.comment_id &&
                this.creation_date == obj.creation_date &&
                this.group_id == obj.group_id &&
                this.item_type == obj.item_type &&
                this.link == obj.link &&
                this.question_id == obj.question_id &&
                this.site == obj.site &&
                this.title == obj.title;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.answer_id == (int?)obj.answer_id &&
                this.body == (string)obj.body &&
                this.comment_id == (int?)obj.comment_id &&
                this.creation_date == (long?)obj.creation_date &&
                this.group_id == (int?)obj.group_id &&
                this.item_type == (string)obj.item_type &&
                this.link == (string)obj.link &&
                this.question_id == (int?)obj.question_id &&
                this.site == (string)obj.site &&
                this.title == (string)obj.title;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileBadgeAward : IMobileFeedBase<MobileBadgeAward>
    {
        public enum BadgeRank : byte
        {
            bronze = 1,
            silver = 2,
            gold = 3
        }

        public enum BadgeType
        {
            named = 1,
            tag_based = 2
        }

        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string site { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string badge_name { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string badge_description { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? badge_id { get; set; }

        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? post_id { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public string link { get; set; }

        [ProtoMember(9)]
        [Key(8), Id(8)]
        public BadgeRank? rank { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public BadgeType? badge_type { get; set; }

        public bool Equals(MobileBadgeAward obj)
        {
            return
                this.added_date == obj.added_date &&
                this.badge_description == obj.badge_description &&
                this.badge_id == obj.badge_id &&
                this.badge_name == obj.badge_name &&
                this.badge_type == obj.badge_type &&
                this.group_id == obj.group_id &&
                this.link == obj.link &&
                this.post_id == obj.post_id &&
                this.rank == obj.rank &&
                this.site == obj.site;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.badge_description == (string)obj.badge_description &&
                this.badge_id == (int?)obj.badge_id &&
                this.badge_name == (string)obj.badge_name &&
                this.badge_type == (BadgeType?)obj.badge_type &&
                this.group_id == (int?)obj.group_id &&
                this.link == (string)obj.link &&
                this.post_id == (int?)obj.post_id &&
                this.rank == (BadgeRank?)obj.rank &&
                this.site == (string)obj.site;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobilePrivilege : IMobileFeedBase<MobilePrivilege>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string site { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string privilege_short_description { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string privilege_long_description { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? privilege_id { get; set; }

        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? reputation_required { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public string link { get; set; }

        public bool Equals(MobilePrivilege obj)
        {
            return
                this.added_date == obj.added_date &&
                this.group_id == obj.group_id &&
                this.link == obj.link &&
                this.privilege_id == obj.privilege_id &&
                this.privilege_long_description == obj.privilege_long_description &&
                this.privilege_short_description == obj.privilege_short_description &&
                this.reputation_required == obj.reputation_required &&
                this.site == obj.site;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.group_id == (int?)obj.group_id &&
                this.link == (string)obj.link &&
                this.privilege_id == (int?)obj.privilege_id &&
                this.privilege_long_description == (string)obj.privilege_long_description &&
                this.privilege_short_description == (string)obj.privilege_short_description &&
                this.reputation_required == (int?)obj.reputation_required &&
                this.site == (string)obj.site;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileCommunityBulletin : IMobileFeedBase<MobileCommunityBulletin>
    {
        public enum CommunityBulletinType : byte
        {
            blog_post = 1,
            featured_meta_question = 2,
            upcoming_event = 3
        }

        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string site { get; set; }

        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string title { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string link { get; set; }

        [ProtoMember(6)]
        [Key(5), Id(5)]
        public CommunityBulletinType? bulletin_type { get; set; }

        [ProtoMember(7)]
        [Key(6), Id(6)]
        public long? begin_date { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public long? end_date { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public string custom_date_string { get; set; }

        [ProtoMember(10)]
        [Key(9), Id(9)]
        public List<string> tags { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public bool? is_deleted { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public bool? has_accepted_answer { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public int? answer_count { get; set; }

        [ProtoMember(14)]
        [Key(13), Id(13)]
        public bool? is_promoted { get; set; }

        public bool Equals(MobileCommunityBulletin obj)
        {
            return
                this.added_date == obj.added_date &&
                this.answer_count == obj.answer_count &&
                this.begin_date == obj.begin_date &&
                this.bulletin_type == obj.bulletin_type &&
                this.custom_date_string == obj.custom_date_string &&
                this.end_date == obj.end_date &&
                this.group_id == obj.group_id &&
                this.has_accepted_answer == obj.has_accepted_answer &&
                this.is_deleted == obj.is_deleted &&
                this.is_promoted == obj.is_promoted &&
                this.link == obj.link &&
                this.site == obj.site &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title == obj.title;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.answer_count == (int?)obj.answer_count &&
                this.begin_date == (long?)obj.begin_date &&
                this.bulletin_type == (CommunityBulletinType?)obj.bulletin_type &&
                this.custom_date_string == (string)obj.custom_date_string &&
                this.end_date == (long?)obj.end_date &&
                this.group_id == (int?)obj.group_id &&
                this.has_accepted_answer == (bool?)obj.has_accepted_answer &&
                this.is_deleted == (bool?)obj.is_deleted &&
                this.is_promoted == (bool?)obj.is_promoted &&
                this.link == (string)obj.link &&
                this.site == (string)obj.site &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title == (string)obj.title;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileAssociationBonus : IMobileFeedBase<MobileAssociationBonus>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string site { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? amount { get; set; }

        public bool Equals(MobileAssociationBonus obj)
        {
            return
                this.added_date == obj.added_date &&
                this.amount == obj.amount &&
                this.group_id == obj.group_id &&
                this.site == obj.site;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.amount == (int?)obj.amount &&
                this.group_id == (int?)obj.group_id &&
                this.site == (string)obj.site;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileCareersJobAd : IMobileFeedBase<MobileCareersJobAd>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? job_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string link { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string company_name { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string location { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public string title { get; set; }

        public bool Equals(MobileCareersJobAd obj)
        {
            return
                this.added_date == obj.added_date &&
                this.company_name == obj.company_name &&
                this.group_id == obj.group_id &&
                this.job_id == obj.job_id &&
                this.link == obj.link &&
                this.location == obj.location &&
                this.title == obj.title;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.company_name == (string)obj.company_name &&
                this.group_id == (int?)obj.group_id &&
                this.job_id == (int?)obj.job_id &&
                this.link == (string)obj.link &&
                this.location == (string)obj.location &&
                this.title == (string)obj.title;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileBannerAd : IMobileFeedBase<MobileBannerAd>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? group_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public long? added_date { get; set; }

        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string link { get; set; }

        [ProtoMember(4)]
        [Key(3), Id(3)]
        public List<MobileBannerAdImage> images { get; set; }

        public bool Equals(MobileBannerAd obj)
        {
            return
                this.added_date == obj.added_date &&
                this.group_id == obj.group_id &&
                this.images.TrueEqualsList(obj.images) &&
                this.link == obj.link;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.added_date == (long?)obj.added_date &&
                this.group_id == (int?)obj.group_id &&
                this.images.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.images) &&
                this.link == (string)obj.link;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileBannerAdImage : IGenericEquality<MobileBannerAdImage>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string image_url { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? width { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? height { get; set; }

        public bool Equals(MobileBannerAdImage obj)
        {
            return
                this.height == obj.height &&
                this.image_url == obj.image_url &&
                this.width == obj.width;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.height == (int?)obj.height &&
                this.image_url == (string)obj.image_url &&
                this.width == (int?)obj.width;
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public sealed partial class MobileUpdateNotice : IGenericEquality<MobileUpdateNotice>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public bool? should_update { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string message { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string minimum_supported_version { get; set; }

        public bool Equals(MobileUpdateNotice obj)
        {
            return
                this.message == obj.message &&
                this.minimum_supported_version == obj.minimum_supported_version &&
                this.should_update == obj.should_update;
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.message == (string)obj.message &&
                this.minimum_supported_version == (string)obj.minimum_supported_version &&
                this.should_update == (bool?)obj.should_update;
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/FlagOption.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class FlagOption : IGenericEquality<FlagOption>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? option_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public bool? requires_comment { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public bool? requires_site { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public bool? requires_question_id { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string title { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string description { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public List<FlagOption> sub_options { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public bool? has_flagged { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? count { get; set; }

        public bool Equals(FlagOption obj)
        {
            return
                this.count.TrueEquals(obj.count) &&
                this.description.TrueEqualsString(obj.description) &&
                this.has_flagged.TrueEquals(obj.has_flagged) &&
                this.option_id.TrueEquals(obj.option_id) &&
                this.requires_comment.TrueEquals(obj.requires_comment) &&
                this.requires_question_id.TrueEquals(obj.requires_question_id) &&
                this.requires_site.TrueEquals(obj.requires_site) &&
                this.sub_options.TrueEqualsList(obj.sub_options) &&
                this.title.TrueEqualsString(obj.title);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.count.TrueEquals((int?)obj.count) &&
                this.description.TrueEqualsString((string)obj.description) &&
                this.has_flagged.TrueEquals((bool?)obj.has_flagged) &&
                this.option_id.TrueEquals((int?)obj.option_id) &&
                this.requires_comment.TrueEquals((bool?)obj.requires_comment) &&
                this.requires_question_id.TrueEquals((bool?)obj.requires_question_id) &&
                this.requires_site.TrueEquals((bool?)obj.requires_site) &&
                this.sub_options.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.sub_options) &&
                this.title.TrueEqualsString((string)obj.title);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/InboxItem.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum InboxItemType
    {
        comment = 1,
        chat_message = 2,
        new_answer = 3,
        careers_message = 4,
        careers_invitations = 5,
        meta_question = 6,
        post_notice = 7,
        moderator_message = 8
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class InboxItem : IGenericEquality<InboxItem>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public InboxItemType? item_type { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? question_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? answer_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? comment_id { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string title { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public bool? is_unread { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public Site site { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public string body { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string link { get; set; }

        public bool Equals(InboxItem obj)
        {
            return
                this.answer_id.TrueEquals(obj.answer_id) &&
                this.body.TrueEqualsString(obj.body) &&
                this.comment_id.TrueEquals(obj.comment_id) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.is_unread.TrueEquals(obj.is_unread) &&
                this.item_type.TrueEquals(obj.item_type) &&
                this.link.TrueEqualsString(obj.link) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.site.TrueEquals(obj.site) &&
                this.title.TrueEqualsString(obj.title);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.answer_id.TrueEquals((int?)obj.answer_id) &&
                this.body.TrueEqualsString((string)obj.body) &&
                this.comment_id.TrueEquals((int?)obj.comment_id) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.is_unread.TrueEquals((bool?)obj.is_unread) &&
                this.item_type.TrueEquals((InboxItemType?)obj.item_type) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                (this.site == null && obj.site == null || this.site.EqualsDynamic(obj.site)) &&
                this.title.TrueEqualsString((string)obj.title);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Info.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum SiteState
    {
        normal,
        closed_beta,
        open_beta,
        linked_meta
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Styling : IGenericEquality<Styling>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string link_color { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string tag_foreground_color { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string tag_background_color { get; set; }

        public bool Equals(Styling obj)
        {
            return
                this.link_color.TrueEqualsString(obj.link_color) &&
                this.tag_background_color.TrueEqualsString(obj.tag_background_color) &&
                this.tag_foreground_color.TrueEqualsString(obj.tag_foreground_color);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.link_color.TrueEqualsString((string)obj.link_color) &&
                this.tag_background_color.TrueEqualsString((string)obj.tag_background_color) &&
                this.tag_foreground_color.TrueEqualsString((string)obj.tag_foreground_color);
        }
    }


    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Site : IGenericEquality<Site>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string site_type { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string name { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string logo_url { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string api_site_parameter { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string site_url { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string audience { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public string icon_url { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public List<string> aliases { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public SiteState? site_state { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public Styling styling { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public DateTime? closed_beta_date { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public DateTime? open_beta_date { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public DateTime? launch_date { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public string favicon_url { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public List<RelatedSite> related_sites { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public string twitter_account { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public List<string> markdown_extensions { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public string high_resolution_icon_url { get; set; }

        public bool Equals(Site obj)
        {
            return
                this.aliases.TrueEqualsString(obj.aliases) &&
                this.api_site_parameter.TrueEqualsString(obj.api_site_parameter) &&
                this.audience.TrueEqualsString(obj.audience) &&
                this.closed_beta_date.TrueEquals(obj.closed_beta_date) &&
                this.favicon_url.TrueEqualsString(obj.favicon_url) &&
                this.high_resolution_icon_url.TrueEqualsString(obj.high_resolution_icon_url) &&
                this.icon_url.TrueEqualsString(obj.icon_url) &&
                this.launch_date.TrueEquals(obj.launch_date) &&
                this.logo_url.TrueEqualsString(obj.logo_url) &&
                this.markdown_extensions.TrueEqualsString(obj.markdown_extensions) &&
                this.name.TrueEqualsString(obj.name) &&
                this.open_beta_date.TrueEquals(obj.open_beta_date) &&
                this.related_sites.TrueEqualsList(obj.related_sites) &&
                this.site_state.TrueEquals(obj.site_state) &&
                this.site_type.TrueEqualsString(obj.site_type) &&
                this.site_url.TrueEqualsString(obj.site_url) &&
                this.styling.TrueEquals(obj.styling) &&
                this.twitter_account.TrueEqualsString(obj.twitter_account);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.aliases.TrueEqualsString((IEnumerable<string>)obj.aliases) &&
                this.api_site_parameter.TrueEqualsString((string)obj.api_site_parameter) &&
                this.audience.TrueEqualsString((string)obj.audience) &&
                this.closed_beta_date.TrueEquals((DateTime?)obj.closed_beta_date) &&
                this.favicon_url.TrueEqualsString((string)obj.favicon_url) &&
                this.high_resolution_icon_url.TrueEqualsString((string)obj.high_resolution_icon_url) &&
                this.icon_url.TrueEqualsString((string)obj.icon_url) &&
                this.launch_date.TrueEquals((DateTime?)obj.launch_date) &&
                this.logo_url.TrueEqualsString((string)obj.logo_url) &&
                this.markdown_extensions.TrueEqualsString((IEnumerable<string>)obj.markdown_extensions) &&
                this.name.TrueEqualsString((string)obj.name) &&
                this.open_beta_date.TrueEquals((DateTime?)obj.open_beta_date) &&
                this.related_sites.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.related_sites) &&
                this.site_state.TrueEquals((SiteState?)obj.site_state) &&
                this.site_type.TrueEqualsString((string)obj.site_type) &&
                this.site_url.TrueEqualsString((string)obj.site_url) &&
                (this.styling == null && obj.styling == null || this.styling.EqualsDynamic(obj.styling)) &&
                this.twitter_account.TrueEqualsString((string)obj.twitter_account);
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Info : IGenericEquality<Info>
    {


        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? total_questions { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? total_unanswered { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? total_accepted { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? total_answers { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public decimal? questions_per_minute { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public decimal? answers_per_minute { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? total_comments { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public int? total_votes { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? total_badges { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public decimal? badges_per_minute { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public int? total_users { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public int? new_active_users { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public string api_revision { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public Site site { get; set; }

        public bool Equals(Info obj)
        {
            return
                this.answers_per_minute.TrueEquals(obj.answers_per_minute) &&
                this.api_revision.TrueEqualsString(obj.api_revision) &&
                this.badges_per_minute.TrueEquals(obj.badges_per_minute) &&
                this.new_active_users.TrueEquals(obj.new_active_users) &&
                this.questions_per_minute.TrueEquals(obj.questions_per_minute) &&
                this.site.TrueEquals(obj.site) &&
                this.total_accepted.TrueEquals(obj.total_accepted) &&
                this.total_answers.TrueEquals(obj.total_answers) &&
                this.total_badges.TrueEquals(obj.total_badges) &&
                this.total_comments.TrueEquals(obj.total_comments) &&
                this.total_questions.TrueEquals(obj.total_questions) &&
                this.total_unanswered.TrueEquals(obj.total_unanswered) &&
                this.total_users.TrueEquals(obj.total_users) &&
                this.total_votes.TrueEquals(obj.total_votes);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.answers_per_minute.TrueEquals((decimal?)obj.answers_per_minute) &&
                this.api_revision.TrueEqualsString((string)obj.api_revision) &&
                this.badges_per_minute.TrueEquals((decimal?)obj.badges_per_minute) &&
                this.new_active_users.TrueEquals((int?)obj.new_active_users) &&
                this.questions_per_minute.TrueEquals((decimal?)obj.questions_per_minute) &&
                (this.site == null && obj.site == null || this.site.EqualsDynamic(obj.site)) &&
                this.total_accepted.TrueEquals((int?)obj.total_accepted) &&
                this.total_answers.TrueEquals((int?)obj.total_answers) &&
                this.total_badges.TrueEquals((int?)obj.total_badges) &&
                this.total_comments.TrueEquals((int?)obj.total_comments) &&
                this.total_questions.TrueEquals((int?)obj.total_questions) &&
                this.total_unanswered.TrueEquals((int?)obj.total_unanswered) &&
                this.total_users.TrueEquals((int?)obj.total_users) &&
                this.total_votes.TrueEquals((int?)obj.total_votes);
        }
    }

    public enum SiteRelation
    {
        parent,
        meta,
        chat
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class RelatedSite : IGenericEquality<RelatedSite>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string name { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string site_url { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public SiteRelation? relation { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string api_site_parameter { get; set; }

        public bool Equals(RelatedSite obj)
        {
            return
                this.name.TrueEqualsString(obj.name) &&
                this.relation.TrueEquals(obj.relation) &&
                this.api_site_parameter.TrueEqualsString(obj.api_site_parameter);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.name.TrueEqualsString((string)obj.name) &&
                this.relation.TrueEquals((SiteRelation?)obj.relation) &&
                this.api_site_parameter.TrueEqualsString((string)obj.api_site_parameter);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/NetworkUser.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class NetworkUser : IGenericEquality<NetworkUser>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string site_name { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string site_url { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? user_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? reputation { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? account_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public UserType? user_type { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public BadgeCount badge_counts { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public DateTime? last_access_date { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public int? answer_count { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public int? question_count { get; set; }

        public bool Equals(NetworkUser obj)
        {
            return
                this.account_id.TrueEquals(obj.account_id) &&
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.badge_counts.TrueEquals(obj.badge_counts) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.last_access_date.TrueEquals(obj.last_access_date) &&
                this.question_count.TrueEquals(obj.question_count) &&
                this.reputation.TrueEquals(obj.reputation) &&
                this.site_name.TrueEqualsString(obj.site_name) &&
                this.site_url.TrueEqualsString(obj.site_url) &&
                this.user_id.TrueEquals(obj.user_id) &&
                this.user_type.TrueEquals(obj.user_type);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.account_id.TrueEquals((int?)obj.account_id) &&
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                (this.badge_counts == null && obj.badge_counts == null || this.badge_counts.EqualsDynamic(obj.badge_counts)) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.last_access_date.TrueEquals((DateTime?)obj.last_access_date) &&
                this.question_count.TrueEquals((int?)obj.question_count) &&
                this.reputation.TrueEquals((int?)obj.reputation) &&
                this.site_name.TrueEqualsString((string)obj.site_name) &&
                this.site_url.TrueEqualsString((string)obj.site_url) &&
                this.user_id.TrueEquals((int?)obj.user_id) &&
                this.user_type.TrueEquals((UserType?)obj.user_type);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Notification.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum NotificationType : byte
    {
        generic = 1,
        accounts_associated = 8,
        badge_earned = 5,
        profile_activity = 2,
        bounty_expired = 3,
        bounty_expires_in_one_day = 4,
        bounty_expires_in_three_days = 6,
        edit_suggested = 22,
        new_privilege = 9,
        post_migrated = 10,
        moderator_message = 11,
        registration_reminder = 12,
        substantive_edit = 23,
        reputation_bonus = 7,
        bounty_grace_period_started = 24
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Notification : IGenericEquality<Notification>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public NotificationType? notification_type { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public Site site { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string body { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? post_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public bool? is_unread { get; set; }

        public bool Equals(Notification obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.site.TrueEquals(obj.site) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.is_unread.TrueEquals(obj.is_unread);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                (this.site == null && obj.site == null || this.site.EqualsDynamic(obj.site)) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.is_unread.TrueEquals((bool?)obj.is_unread);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Post.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Post : IGenericEquality<Post>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? post_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public PostType? post_type { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string body { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public ShallowUser owner { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public DateTime? last_activity_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public DateTime? last_edit_date { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public int? score { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? up_vote_count { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public int? down_vote_count { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public List<Comment> comments { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public string link { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public bool? upvoted { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public bool? downvoted { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public ShallowUser last_editor { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public int? comment_count { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public string body_markdown { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public string share_link { get; set; }

        public bool Equals(Post obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.body_markdown.TrueEqualsString(obj.body_markdown) &&
                this.comment_count.TrueEquals(obj.comment_count) &&
                this.comments.TrueEqualsList(obj.comments) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.down_vote_count.TrueEquals(obj.down_vote_count) &&
                this.downvoted.TrueEquals(obj.downvoted) &&
                this.last_activity_date.TrueEquals(obj.last_activity_date) &&
                this.last_edit_date.TrueEquals(obj.last_edit_date) &&
                this.last_editor.TrueEquals(obj.last_editor) &&
                this.link.TrueEqualsString(obj.link) &&
                this.owner.TrueEquals(obj.owner) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.score.TrueEquals(obj.score) &&
                this.share_link.TrueEqualsString(obj.share_link) &&
                this.up_vote_count.TrueEquals(obj.up_vote_count) &&
                this.upvoted.TrueEquals(obj.upvoted);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                this.body_markdown.TrueEqualsString((string)obj.body_markdown) &&
                this.comment_count.TrueEquals((int?)obj.comment_count) &&
                this.comments.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.comments) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.down_vote_count.TrueEquals((int?)obj.down_vote_count) &&
                this.downvoted.TrueEquals((bool?)obj.downvoted) &&
                this.last_activity_date.TrueEquals((DateTime?)obj.last_activity_date) &&
                this.last_edit_date.TrueEquals((DateTime?)obj.last_edit_date) &&
                (this.last_editor == null && obj.last_editor == null || this.last_editor.EqualsDynamic(obj.last_editor)) &&
                this.link.TrueEqualsString((string)obj.link) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                this.score.TrueEquals((int?)obj.score) &&
                this.share_link.TrueEqualsString((string)obj.share_link) &&
                this.up_vote_count.TrueEquals((int?)obj.up_vote_count) &&
                this.upvoted.TrueEquals((bool?)obj.upvoted);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Privilege.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Privilege : IGenericEquality<Privilege>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string short_description { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string description { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? reputation { get; set; }

        public bool Equals(Privilege obj)
        {
            return
                this.description.TrueEqualsString(obj.description) &&
                this.reputation.TrueEquals(obj.reputation) &&
                this.short_description.TrueEqualsString(obj.short_description);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.description.TrueEqualsString((string)obj.description) &&
                this.reputation.TrueEquals((int?)obj.reputation) &&
                this.short_description.TrueEqualsString((string)obj.short_description);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Question.cs
================================================
﻿#nullable disable
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MemoryPack;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class OriginalQuestion : IGenericEquality<OriginalQuestion>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? question_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string title { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? answer_count { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? accepted_answer_id { get; set; }

        public bool Equals(OriginalQuestion obj)
        {
            return
                this.accepted_answer_id.TrueEquals(obj.accepted_answer_id) &&
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.title.TrueEqualsString(obj.title);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.accepted_answer_id.TrueEquals((int?)obj.accepted_answer_id) &&
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                this.title.TrueEqualsString((string)obj.title);
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class ClosedDetails : IGenericEquality<ClosedDetails>
    {
        

        [ProtoMember(1)]
        [Key(0), Id(0)]
        public bool? on_hold { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string reason { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string description { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public List<ShallowUser> by_users { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public List<OriginalQuestion> original_questions { get; set; }

        public bool Equals(ClosedDetails obj)
        {
            return
                this.by_users.TrueEqualsList(obj.by_users) &&
                this.description.TrueEqualsString(obj.description) &&
                this.on_hold.TrueEquals(obj.on_hold) &&
                this.original_questions.TrueEqualsList(obj.original_questions) &&
                this.reason.TrueEqualsString(obj.reason);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            var oq = obj.original_questions;
            var oqI = (IEnumerable<dynamic>)oq;

            return
                this.by_users.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.by_users) &&
                this.description.TrueEqualsString((string)obj.description) &&
                this.on_hold.TrueEquals((bool?)obj.on_hold) &&
                //this.original_questions.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.original_questions) &&
                this.original_questions.TrueEqualsListDynamic(oqI) &&
                this.reason.TrueEqualsString((string)obj.reason);
        }
    }


    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Notice : IGenericEquality<Notice>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string body { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? owner_user_id { get; set; }

        public bool Equals(Notice obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.owner_user_id.TrueEquals(obj.owner_user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.owner_user_id.TrueEquals((int?)obj.owner_user_id);
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class MigrationInfo : IGenericEquality<MigrationInfo>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? question_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public Site other_site { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? on_date { get; set; }

        public bool Equals(MigrationInfo obj)
        {
            return
                this.on_date.TrueEquals(obj.on_date) &&
                this.other_site.TrueEquals(obj.other_site) &&
                this.question_id.TrueEquals(obj.question_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.on_date.TrueEquals((DateTime?)obj.on_date) &&
                (this.other_site == null && obj.other_site == null || this.other_site.EqualsDynamic(obj.other_site)) &&
                this.question_id.TrueEquals((int?)obj.question_id);
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Question : IGenericEquality<Question>
    {



        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? question_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public DateTime? last_edit_date { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public DateTime? last_activity_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? locked_date { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? score { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public DateTime? community_owned_date { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public int? answer_count { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? accepted_answer_id { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public MigrationInfo migrated_to { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public MigrationInfo migrated_from { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public DateTime? bounty_closes_date { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public int? bounty_amount { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public DateTime? closed_date { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public DateTime? protected_date { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public string body { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public string title { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public List<string> tags { get; set; }
        [ProtoMember(19)]
        [Key(18), Id(18)]
        public string closed_reason { get; set; }
        [ProtoMember(20)]
        [Key(19), Id(19)]
        public int? up_vote_count { get; set; }
        [ProtoMember(21)]
        [Key(20), Id(20)]
        public int? down_vote_count { get; set; }
        [ProtoMember(22)]
        [Key(21), Id(21)]
        public int? favorite_count { get; set; }
        [ProtoMember(23)]
        [Key(22), Id(22)]
        public int? view_count { get; set; }
        [ProtoMember(24)]
        [Key(23), Id(23)]
        public ShallowUser owner { get; set; }
        [ProtoMember(25)]
        [Key(24), Id(24)]
        public List<Comment> comments { get; set; }
        [ProtoMember(26)]
        [Key(25), Id(25)]
        public List<Answer> answers { get; set; }
        [ProtoMember(27)]
        [Key(26), Id(26)]
        public string link { get; set; }
        [ProtoMember(28)]
        [Key(27), Id(27)]
        public bool? is_answered { get; set; }
        [ProtoMember(29)]
        [Key(28), Id(28)]
        public int? close_vote_count { get; set; }
        [ProtoMember(30)]
        [Key(29), Id(29)]
        public int? reopen_vote_count { get; set; }
        [ProtoMember(31)]
        [Key(30), Id(30)]
        public int? delete_vote_count { get; set; }
        [ProtoMember(32)]
        [Key(31), Id(31)]
        public Notice notice { get; set; }
        [ProtoMember(33)]
        [Key(32), Id(32)]
        public bool? upvoted { get; set; }
        [ProtoMember(34)]
        [Key(33), Id(33)]
        public bool? downvoted { get; set; }
        [ProtoMember(35)]
        [Key(34), Id(34)]
        public bool? favorited { get; set; }
        [ProtoMember(36)]
        [Key(35), Id(35)]
        public ShallowUser last_editor { get; set; }
        [ProtoMember(37)]
        [Key(36), Id(36)]
        public int? comment_count { get; set; }
        [ProtoMember(38)]
        [Key(37), Id(37)]
        public string body_markdown { get; set; }
        [ProtoMember(39)]
        [Key(38), Id(38)]
        public ClosedDetails closed_details { get; set; }
        [ProtoMember(40)]
        [Key(39), Id(39)]
        public string share_link { get; set; }

        public bool Equals(Question obj)
        {
            return
                this.accepted_answer_id.TrueEquals(obj.accepted_answer_id) &&
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.answers.TrueEqualsList(obj.answers) &&
                this.body.TrueEqualsString(obj.body) &&
                this.body_markdown.TrueEqualsString(obj.body_markdown) &&
                this.bounty_amount.TrueEquals(obj.bounty_amount) &&
                this.bounty_closes_date.TrueEquals(obj.bounty_closes_date) &&
                this.close_vote_count.TrueEquals(obj.close_vote_count) &&
                this.closed_date.TrueEquals(obj.closed_date) &&
                this.closed_details.TrueEquals(obj.closed_details) &&
                this.closed_reason.TrueEqualsString(obj.closed_reason) &&
                this.comment_count.TrueEquals(obj.comment_count) &&
                this.comments.TrueEqualsList(obj.comments) &&
                this.community_owned_date.TrueEquals(obj.community_owned_date) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.delete_vote_count.TrueEquals(obj.delete_vote_count) &&
                this.down_vote_count.TrueEquals(obj.down_vote_count) &&
                this.downvoted.TrueEquals(obj.downvoted) &&
                this.favorite_count.TrueEquals(obj.favorite_count) &&
                this.favorited.TrueEquals(obj.favorited) &&
                this.is_answered.TrueEquals(obj.is_answered) &&
                this.last_activity_date.TrueEquals(obj.last_activity_date) &&
                this.last_edit_date.TrueEquals(obj.last_edit_date) &&
                this.last_editor.TrueEquals(obj.last_editor) &&
                this.link.TrueEqualsString(obj.link) &&
                this.locked_date.TrueEquals(obj.locked_date) &&
                this.migrated_from.TrueEquals(obj.migrated_from) &&
                this.migrated_to.TrueEquals(obj.migrated_to) &&
                this.notice.TrueEquals(obj.notice) &&
                this.owner.TrueEquals(obj.owner) &&
                this.protected_date.TrueEquals(obj.protected_date) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.reopen_vote_count.TrueEquals(obj.reopen_vote_count) &&
                this.score.TrueEquals(obj.score) &&
                this.share_link.TrueEqualsString(obj.share_link) &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title.TrueEqualsString(obj.title) &&
                this.up_vote_count.TrueEquals(obj.up_vote_count) &&
                this.upvoted.TrueEquals(obj.upvoted) &&
                this.view_count.TrueEquals(obj.view_count);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.accepted_answer_id.TrueEquals((int?)obj.accepted_answer_id) &&
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                this.answers.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.answers) &&
                this.body.TrueEqualsString((string)obj.body) &&
                this.body_markdown.TrueEqualsString((string)obj.body_markdown) &&
                this.bounty_amount.TrueEquals((int?)obj.bounty_amount) &&
                this.bounty_closes_date.TrueEquals((DateTime?)obj.bounty_closes_date) &&
                this.close_vote_count.TrueEquals((int?)obj.close_vote_count) &&
                this.closed_date.TrueEquals((DateTime?)obj.closed_date) &&
                (this.closed_details == null && obj.closed_details == null || this.closed_details.EqualsDynamic(obj.closed_details)) &&
                this.closed_reason.TrueEqualsString((string)obj.closed_reason) &&
                this.comment_count.TrueEquals((int?)obj.comment_count) &&
                this.comments.TrueEqualsListDynamic((IEnumerable<dynamic>)obj.comments) &&
                this.community_owned_date.TrueEquals((DateTime?)obj.community_owned_date) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.delete_vote_count.TrueEquals((int?)obj.delete_vote_count) &&
                this.down_vote_count.TrueEquals((int?)obj.down_vote_count) &&
                this.downvoted.TrueEquals((bool?)obj.downvoted) &&
                this.favorite_count.TrueEquals((int?)obj.favorite_count) &&
                this.favorited.TrueEquals((bool?)obj.favorited) &&
                this.is_answered.TrueEquals((bool?)obj.is_answered) &&
                this.last_activity_date.TrueEquals((DateTime?)obj.last_activity_date) &&
                this.last_edit_date.TrueEquals((DateTime?)obj.last_edit_date) &&
                (this.last_editor == null && obj.last_editor == null || this.last_editor.EqualsDynamic(obj.last_editor)) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.locked_date.TrueEquals((DateTime?)obj.locked_date) &&
                (this.migrated_from == null && obj.migrated_from == null || this.migrated_from.EqualsDynamic(obj.migrated_from)) &&
                (this.migrated_to == null && obj.migrated_to == null || this.migrated_to.EqualsDynamic(obj.migrated_to)) &&
                (this.notice == null && obj.notice == null || this.notice.EqualsDynamic(obj.notice)) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.protected_date.TrueEquals((DateTime?)obj.protected_date) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                this.reopen_vote_count.TrueEquals((int?)obj.reopen_vote_count) &&
                this.score.TrueEquals((int?)obj.score) &&
                this.share_link.TrueEqualsString((string)obj.share_link) &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title.TrueEqualsString((string)obj.title) &&
                this.up_vote_count.TrueEquals((int?)obj.up_vote_count) &&
                this.upvoted.TrueEquals((bool?)obj.upvoted) &&
                this.view_count.TrueEquals((int?)obj.view_count);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/QuestionTimeline.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum QuestionTimelineAction : byte
    {
        question = 1,
        answer = 2,
        comment = 3,
        unaccepted_answer = 4,
        accepted_answer = 5,
        vote_aggregate = 6,
        revision = 7,
        post_state_changed = 8
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class QuestionTimeline : IGenericEquality<QuestionTimeline>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public QuestionTimelineAction? timeline_type { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? question_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? post_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? comment_id { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string revision_guid { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? up_vote_count { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? down_vote_count { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public ShallowUser user { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public ShallowUser owner { get; set; }

        public bool Equals(QuestionTimeline obj)
        {
            return
                this.comment_id.TrueEquals(obj.comment_id) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.down_vote_count.TrueEquals(obj.down_vote_count) &&
                this.owner.TrueEquals(obj.owner) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.revision_guid.TrueEqualsString(obj.revision_guid) &&
                this.timeline_type.TrueEquals(obj.timeline_type) &&
                this.up_vote_count.TrueEquals(obj.up_vote_count) &&
                this.user.TrueEquals(obj.user);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.comment_id.TrueEquals((int?)obj.comment_id) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.down_vote_count.TrueEquals((int?)obj.down_vote_count) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                this.revision_guid.TrueEqualsString((string)obj.revision_guid) &&
                this.timeline_type.TrueEquals((QuestionTimelineAction?)obj.timeline_type) &&
                this.up_vote_count.TrueEquals((int?)obj.up_vote_count) &&
                (this.user == null && obj.user == null || this.user.EqualsDynamic(obj.user));
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Reputation.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum VoteType : byte
    {
        up_votes = 2,
        down_votes = 3,
        spam = 12,
        accepts = 1,
        bounties_won = 9,
        bounties_offered = 8,
        suggested_edits = 16
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Reputation : IGenericEquality<Reputation>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? user_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? post_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public PostType? post_type { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public VoteType? vote_type { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string title { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string link { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? reputation_change { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public DateTime? on_date { get; set; }

        public bool Equals(Reputation obj)
        {
            return
                this.link.TrueEqualsString(obj.link) &&
                this.on_date.TrueEquals(obj.on_date) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.reputation_change.TrueEquals(obj.reputation_change) &&
                this.title.TrueEqualsString(obj.title) &&
                this.user_id.TrueEquals(obj.user_id) &&
                this.vote_type.TrueEquals(obj.vote_type);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.link.TrueEqualsString((string)obj.link) &&
                this.on_date.TrueEquals((DateTime?)obj.on_date) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                this.reputation_change.TrueEquals((int?)obj.reputation_change) &&
                this.title.TrueEqualsString((string)obj.title) &&
                this.user_id.TrueEquals((int?)obj.user_id) &&
                this.vote_type.TrueEquals((VoteType?)obj.vote_type);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/ReputationHistory.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum ReputationHistoryType : byte
    {
        asker_accepts_answer = 1,
        asker_unaccept_answer = 2,
        answer_accepted = 3,
        answer_unaccepted = 4,

        voter_downvotes = 5,
        voter_undownvotes = 6,
        post_downvoted = 7,
        post_undownvoted = 8,

        post_upvoted = 9,
        post_unupvoted = 10,

        suggested_edit_approval_received = 11,

        post_flagged_as_spam = 12,
        post_flagged_as_offensive = 13,

        bounty_given = 14,
        bounty_earned = 15,
        bounty_cancelled = 16,

        post_deleted = 17,
        post_undeleted = 18,

        association_bonus = 19,
        arbitrary_reputation_change = 20,

        vote_fraud_reversal = 21,

        post_migrated = 22,

        user_deleted = 23
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class ReputationHistory : IGenericEquality<ReputationHistory>
    {
        

        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? user_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? post_id { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? reputation_change { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public ReputationHistoryType? reputation_history_type { get; set; }

        public bool Equals(ReputationHistory obj)
        {
            return
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.reputation_change.TrueEquals(obj.reputation_change) &&
                this.reputation_history_type.TrueEquals(obj.reputation_history_type) &&
                this.user_id.TrueEquals(obj.user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.reputation_change.TrueEquals((int?)obj.reputation_change) &&
                this.reputation_history_type.TrueEquals((ReputationHistoryType?)obj.reputation_history_type) &&
                this.user_id.TrueEquals((int?)obj.user_id);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Revision.cs
================================================
﻿#nullable disable
using MessagePack;
using MemoryPack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum RevisionType : byte
    {
        single_user = 1,
        vote_based = 2
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Revision : IGenericEquality<Revision>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string revision_guid { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? revision_number { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public RevisionType? revision_type { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public PostType? post_type { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? post_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string comment { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public bool? is_rollback { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public string last_body { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string last_title { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public List<string> last_tags { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public string body { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public string title { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public List<string> tags { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public bool? set_community_wiki { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public ShallowUser user { get; set; }

        public bool Equals(Revision obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.comment.TrueEqualsString(obj.comment) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.is_rollback.TrueEquals(obj.is_rollback) &&
                this.last_body.TrueEqualsString(obj.last_body) &&
                this.last_tags.TrueEqualsString(obj.last_tags) &&
                this.last_title.TrueEqualsString(obj.last_title) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.revision_guid.TrueEqualsString(obj.revision_guid) &&
                this.revision_number.TrueEquals(obj.revision_number) &&
                this.revision_type.TrueEquals(obj.revision_type) &&
                this.set_community_wiki.TrueEquals(obj.set_community_wiki) &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title.TrueEqualsString(obj.title) &&
                this.user.TrueEquals(obj.user);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                this.comment.TrueEqualsString((string)obj.comment) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.is_rollback.TrueEquals((bool?)obj.is_rollback) &&
                this.last_body.TrueEqualsString((string)obj.last_body) &&
                this.last_tags.TrueEqualsString((IEnumerable<string>)obj.last_tags) &&
                this.last_title.TrueEqualsString((string)obj.last_title) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                this.revision_guid.TrueEqualsString((string)obj.revision_guid) &&
                this.revision_number.TrueEquals((int?)obj.revision_number) &&
                this.revision_type.TrueEquals((RevisionType?)obj.revision_type) &&
                this.set_community_wiki.TrueEquals((bool?)obj.set_community_wiki) &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title.TrueEqualsString((string)obj.title) &&
                (this.user == null && obj.user == null || this.user.EqualsDynamic(obj.user));
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/SearchExcerpt.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum SearchExcerptItemType : byte
    {
        question = 1,
        answer = 2
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class SearchExcerpt : IGenericEquality<SearchExcerpt>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string title { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string excerpt { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? community_owned_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public DateTime? locked_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public DateTime? last_activity_date { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public ShallowUser owner { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public ShallowUser last_activity_user { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? score { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public SearchExcerptItemType? item_type { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public string body { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public int? question_id { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public bool? is_answered { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public int? answer_count { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public List<string> tags { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public DateTime? closed_date { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public int? answer_id { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public bool? is_accepted { get; set; }

        public bool Equals(SearchExcerpt obj)
        {
            return
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.answer_id.TrueEquals(obj.answer_id) &&
                this.body.TrueEqualsString(obj.body) &&
                this.closed_date.TrueEquals(obj.closed_date) &&
                this.community_owned_date.TrueEquals(obj.community_owned_date) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.excerpt.TrueEqualsString(obj.excerpt) &&
                this.is_accepted.TrueEquals(obj.is_accepted) &&
                this.is_answered.TrueEquals(obj.is_answered) &&
                this.item_type.TrueEquals(obj.item_type) &&
                this.last_activity_date.TrueEquals(obj.last_activity_date) &&
                this.last_activity_user.TrueEquals(obj.last_activity_user) &&
                this.locked_date.TrueEquals(obj.locked_date) &&
                this.owner.TrueEquals(obj.owner) &&
                this.question_id.TrueEquals(obj.question_id) &&
                this.score.TrueEquals(obj.score) &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title.TrueEqualsString(obj.title);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                this.answer_id.TrueEquals((int?)obj.answer_id) &&
                this.body.TrueEqualsString((string)obj.body) &&
                this.closed_date.TrueEquals((DateTime?)obj.closed_date) &&
                this.community_owned_date.TrueEquals((DateTime?)obj.community_owned_date) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.excerpt.TrueEqualsString((string)obj.excerpt) &&
                this.is_accepted.TrueEquals((bool?)obj.is_accepted) &&
                this.is_answered.TrueEquals((bool?)obj.is_answered) &&
                this.item_type.TrueEquals((SearchExcerptItemType?)obj.item_type) &&
                this.last_activity_date.TrueEquals((DateTime?)obj.last_activity_date) &&
                (this.last_activity_user == null && obj.last_activity_user == null || this.last_activity_user.EqualsDynamic(obj.last_activity_user)) &&
                this.locked_date.TrueEquals((DateTime?)obj.locked_date) &&
                (this.owner == null && obj.owner == null || this.owner.EqualsDynamic(obj.owner)) &&
                this.question_id.TrueEquals((int?)obj.question_id) &&
                this.score.TrueEquals((int?)obj.score) &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title.TrueEqualsString((string)obj.title);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/ShallowUser.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum UserType : byte
    {
        unregistered = 2,
        registered = 3,
        moderator = 4,
        does_not_exist = 255
    }
    
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class ShallowUser : IGenericEquality<ShallowUser>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? user_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string display_name { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? reputation { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public UserType? user_type { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string profile_image { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public string link { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? accept_rate { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public BadgeCount badge_counts { get; set; }

        public bool Equals(ShallowUser obj)
        {
            return
                this.accept_rate.TrueEquals(obj.accept_rate) &&
                this.badge_counts.TrueEquals(obj.badge_counts) &&
                this.display_name.TrueEqualsString(obj.display_name) &&
                this.link.TrueEqualsString(obj.link) &&
                this.profile_image.TrueEqualsString(obj.profile_image) &&
                this.reputation.TrueEquals(obj.reputation) &&
                this.user_id.TrueEquals(obj.user_id) &&
                this.user_type.TrueEquals(obj.user_type);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.accept_rate.TrueEquals((int?)obj.accept_rate) &&
                (this.badge_counts == null && obj.badge_counts == null || this.badge_counts.EqualsDynamic(obj.badge_counts)) &&
                this.display_name.TrueEqualsString((string)obj.display_name) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.profile_image.TrueEqualsString((string)obj.profile_image) &&
                this.reputation.TrueEquals((int?)obj.reputation) &&
                this.user_id.TrueEquals((int?)obj.user_id) &&
                this.user_type.TrueEquals((UserType?)obj.user_type);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/SuggestedEdit.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class SuggestedEdit : IGenericEquality<SuggestedEdit>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? suggested_edit_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? post_id { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public PostType? post_type { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string body { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string title { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public List<string> tags { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public string comment { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public DateTime? approval_date { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public DateTime? rejection_date { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public ShallowUser proposing_user { get; set; }

        public bool Equals(SuggestedEdit obj)
        {
            return
                this.approval_date.TrueEquals(obj.approval_date) &&
                this.body.TrueEqualsString(obj.body) &&
                this.comment.TrueEqualsString(obj.comment) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.proposing_user.TrueEquals(obj.proposing_user) &&
                this.rejection_date.TrueEquals(obj.rejection_date) &&
                this.suggested_edit_id.TrueEquals(obj.suggested_edit_id) &&
                this.tags.TrueEqualsString(obj.tags) &&
                this.title.TrueEqualsString(obj.title);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.approval_date.TrueEquals((DateTime?)obj.approval_date) &&
                this.body.TrueEqualsString((string)obj.body) &&
                this.comment.TrueEqualsString((string)obj.comment) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                (this.proposing_user == null && obj.proposing_user == null || this.proposing_user.EqualsDynamic(obj.proposing_user)) &&
                this.rejection_date.TrueEquals((DateTime?)obj.rejection_date) &&
                this.suggested_edit_id.TrueEquals((int?)obj.suggested_edit_id) &&
                this.tags.TrueEqualsString((IEnumerable<string>)obj.tags) &&
                this.title.TrueEqualsString((string)obj.title);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/Tag.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class Tag : IGenericEquality<Tag>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string name { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? count { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public bool? is_required { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public bool? is_moderator_only { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? user_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public bool? has_synonyms { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public DateTime? last_activity_date { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public List<string> synonyms { get; set; }

        public bool Equals(Tag obj)
        {
            return
                this.count.TrueEquals(obj.count) &&
                this.has_synonyms.TrueEquals(obj.has_synonyms) &&
                this.is_moderator_only.TrueEquals(obj.is_moderator_only) &&
                this.is_required.TrueEquals(obj.is_required) &&
                this.last_activity_date.TrueEquals(obj.last_activity_date) &&
                this.name.TrueEqualsString(obj.name) &&
                this.synonyms.TrueEqualsString(obj.synonyms) &&
                this.user_id.TrueEquals(obj.user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.count.TrueEquals((int?)obj.count) &&
                this.has_synonyms.TrueEquals((bool?)obj.has_synonyms) &&
                this.is_moderator_only.TrueEquals((bool?)obj.is_moderator_only) &&
                this.is_required.TrueEquals((bool?)obj.is_required) &&
                this.last_activity_date.TrueEquals((DateTime?)obj.last_activity_date) &&
                this.name.TrueEqualsString((string)obj.name) &&
                this.synonyms.TrueEqualsString((IEnumerable<string>)obj.synonyms) &&
                this.user_id.TrueEquals((int?)obj.user_id);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/TagScore.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class TagScore : IGenericEquality<TagScore>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public ShallowUser user { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? score { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? post_count { get; set; }

        public bool Equals(TagScore obj)
        {
            return
                this.post_count.TrueEquals(obj.post_count) &&
                this.score.TrueEquals(obj.score) &&
                this.user.TrueEquals(obj.user);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.post_count.TrueEquals((int?)obj.post_count) &&
                this.score.TrueEquals((int?)obj.score) &&
                (this.user == null && obj.user == null || this.user.EqualsDynamic(obj.user));
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/TagSynonym.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class TagSynonym : IGenericEquality<TagSynonym>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string from_tag { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string to_tag { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? applied_count { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public DateTime? last_applied_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? creation_date { get; set; }

        public bool Equals(TagSynonym obj)
        {
            return
                this.applied_count.TrueEquals(obj.applied_count) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.from_tag.TrueEqualsString(obj.from_tag) &&
                this.last_applied_date.TrueEquals(obj.last_applied_date) &&
                this.to_tag.TrueEqualsString(obj.to_tag);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.applied_count.TrueEquals((int?)obj.applied_count) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.from_tag.TrueEqualsString((string)obj.from_tag) &&
                this.last_applied_date.TrueEquals((DateTime?)obj.last_applied_date) &&
                this.to_tag.TrueEqualsString((string)obj.to_tag);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/TagWiki.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class TagWiki : IGenericEquality<TagWiki>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string tag_name { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string body { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public string excerpt { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public DateTime? body_last_edit_date { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public DateTime? excerpt_last_edit_date { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public ShallowUser last_body_editor { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public ShallowUser last_excerpt_editor { get; set; }

        public bool Equals(TagWiki obj)
        {
            return
                this.body.TrueEqualsString(obj.body) &&
                this.body_last_edit_date.TrueEquals(obj.body_last_edit_date) &&
                this.excerpt.TrueEqualsString(obj.excerpt) &&
                this.excerpt_last_edit_date.TrueEquals(obj.excerpt_last_edit_date) &&
                this.last_body_editor.TrueEquals(obj.last_body_editor) &&
                this.last_excerpt_editor.TrueEquals(obj.last_excerpt_editor) &&
                this.tag_name.TrueEqualsString(obj.tag_name);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.body.TrueEqualsString((string)obj.body) &&
                this.body_last_edit_date.TrueEquals((DateTime?)obj.body_last_edit_date) &&
                this.excerpt.TrueEqualsString((string)obj.excerpt) &&
                this.excerpt_last_edit_date.TrueEquals((DateTime?)obj.excerpt_last_edit_date) &&
                (this.last_body_editor == null && obj.last_body_editor == null || this.last_body_editor.EqualsDynamic(obj.last_body_editor)) &&
                (this.last_excerpt_editor == null && obj.last_excerpt_editor == null || this.last_excerpt_editor.EqualsDynamic(obj.last_excerpt_editor)) &&
                this.tag_name.TrueEqualsString((string)obj.tag_name);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/TopTag.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class TopTag : IGenericEquality<TopTag>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public string tag_name { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? question_score { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? question_count { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? answer_score { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? answer_count { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? user_id { get; set; }

        public bool Equals(TopTag obj)
        {
            return
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.answer_score.TrueEquals(obj.answer_score) &&
                this.question_count.TrueEquals(obj.question_count) &&
                this.question_score.TrueEquals(obj.question_score) &&
                this.tag_name.TrueEqualsString(obj.tag_name) &&
                this.user_id.TrueEquals(obj.user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                this.answer_score.TrueEquals((int?)obj.answer_score) &&
                this.question_count.TrueEquals((int?)obj.question_count) &&
                this.question_score.TrueEquals((int?)obj.question_score) &&
                this.tag_name.TrueEqualsString((string)obj.tag_name) &&
                this.user_id.TrueEquals((int?)obj.user_id);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/User.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class BadgeCount : IGenericEquality<BadgeCount>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? gold { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public int? silver { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public int? bronze { get; set; }

        public bool Equals(BadgeCount obj)
        {
            return
                this.bronze.TrueEquals(obj.bronze) &&
                this.silver.TrueEquals(obj.silver) &&
                this.gold.TrueEquals(obj.gold);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.bronze.TrueEquals((int?)obj.bronze) &&
                this.silver.TrueEquals((int?)obj.silver) &&
                this.gold.TrueEquals((int?)obj.gold);
        }
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class User : IGenericEquality<User>
    {
      

        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? user_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public UserType? user_type { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public string display_name { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public string profile_image { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? reputation { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? reputation_change_day { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public int? reputation_change_week { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public int? reputation_change_month { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public int? reputation_change_quarter { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public int? reputation_change_year { get; set; }
        [ProtoMember(12)]
        [Key(11), Id(11)]
        public int? age { get; set; }
        [ProtoMember(13)]
        [Key(12), Id(12)]
        public DateTime? last_access_date { get; set; }
        [ProtoMember(14)]
        [Key(13), Id(13)]
        public DateTime? last_modified_date { get; set; }
        [ProtoMember(15)]
        [Key(14), Id(14)]
        public bool? is_employee { get; set; }
        [ProtoMember(16)]
        [Key(15), Id(15)]
        public string link { get; set; }
        [ProtoMember(17)]
        [Key(16), Id(16)]
        public string website_url { get; set; }
        [ProtoMember(18)]
        [Key(17), Id(17)]
        public string location { get; set; }
        [ProtoMember(19)]
        [Key(18), Id(18)]
        public int? account_id { get; set; }
        [ProtoMember(20)]
        [Key(19), Id(19)]
        public DateTime? timed_penalty_date { get; set; }
        [ProtoMember(21)]
        [Key(20), Id(20)]
        public BadgeCount badge_counts { get; set; }
        [ProtoMember(22)]
        [Key(21), Id(21)]
        public int? question_count { get; set; }
        [ProtoMember(23)]
        [Key(22), Id(22)]
        public int? answer_count { get; set; }
        [ProtoMember(24)]
        [Key(23), Id(23)]
        public int? up_vote_count { get; set; }
        [ProtoMember(25)]
        [Key(24), Id(24)]
        public int? down_vote_count { get; set; }
        [ProtoMember(26)]
        [Key(25), Id(25)]
        public string about_me { get; set; }
        [ProtoMember(27)]
        [Key(26), Id(26)]
        public int? view_count { get; set; }
        [ProtoMember(28)]
        [Key(27), Id(27)]
        public int? accept_rate { get; set; }

        public bool Equals(User obj)
        {
            return
                this.about_me.TrueEqualsString(obj.about_me) &&
                this.accept_rate.TrueEquals(obj.accept_rate) &&
                this.account_id.TrueEquals(obj.account_id) &&
                this.age.TrueEquals(obj.age) &&
                this.answer_count.TrueEquals(obj.answer_count) &&
                this.badge_counts.TrueEquals(obj.badge_counts) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.display_name.TrueEqualsString(obj.display_name) &&
                this.down_vote_count.TrueEquals(obj.down_vote_count) &&
                this.is_employee.TrueEquals(obj.is_employee) &&
                this.last_access_date.TrueEquals(obj.last_access_date) &&
                this.last_modified_date.TrueEquals(obj.last_modified_date) &&
                this.link.TrueEqualsString(obj.link) &&
                this.location.TrueEqualsString(obj.location) &&
                this.profile_image.TrueEqualsString(obj.profile_image) &&
                this.question_count.TrueEquals(obj.question_count) &&
                this.reputation.TrueEquals(obj.reputation) &&
                this.reputation_change_day.TrueEquals(obj.reputation_change_day) &&
                this.reputation_change_month.TrueEquals(obj.reputation_change_month) &&
                this.reputation_change_quarter.TrueEquals(obj.reputation_change_quarter) &&
                this.reputation_change_week.TrueEquals(obj.reputation_change_week) &&
                this.reputation_change_year.TrueEquals(obj.reputation_change_year) &&
                this.timed_penalty_date.TrueEquals(obj.timed_penalty_date) &&
                this.up_vote_count.TrueEquals(obj.up_vote_count) &&
                this.user_id.TrueEquals(obj.user_id) &&
                this.user_type.TrueEquals(obj.user_type) &&
                this.view_count.TrueEquals(obj.view_count) &&
                this.website_url.TrueEqualsString(obj.website_url);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.about_me.TrueEqualsString((string)obj.about_me) &&
                this.accept_rate.TrueEquals((int?)obj.accept_rate) &&
                this.account_id.TrueEquals((int?)obj.account_id) &&
                this.age.TrueEquals((int?)obj.age) &&
                this.answer_count.TrueEquals((int?)obj.answer_count) &&
                (this.badge_counts == null && obj.badge_counts == null || this.badge_counts.EqualsDynamic(obj.badge_counts)) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.display_name.TrueEqualsString((string)obj.display_name) &&
                this.down_vote_count.TrueEquals((int?)obj.down_vote_count) &&
                this.is_employee.TrueEquals((bool?)obj.is_employee) &&
                this.last_access_date.TrueEquals((DateTime?)obj.last_access_date) &&
                this.last_modified_date.TrueEquals((DateTime?)obj.last_modified_date) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.location.TrueEqualsString((string)obj.location) &&
                this.profile_image.TrueEqualsString((string)obj.profile_image) &&
                this.question_count.TrueEquals((int?)obj.question_count) &&
                this.reputation.TrueEquals((int?)obj.reputation) &&
                this.reputation_change_day.TrueEquals((int?)obj.reputation_change_day) &&
                this.reputation_change_month.TrueEquals((int?)obj.reputation_change_month) &&
                this.reputation_change_quarter.TrueEquals((int?)obj.reputation_change_quarter) &&
                this.reputation_change_week.TrueEquals((int?)obj.reputation_change_week) &&
                this.reputation_change_year.TrueEquals((int?)obj.reputation_change_year) &&
                this.timed_penalty_date.TrueEquals((DateTime?)obj.timed_penalty_date) &&
                this.up_vote_count.TrueEquals((int?)obj.up_vote_count) &&
                this.user_id.TrueEquals((int?)obj.user_id) &&
                this.user_type.TrueEquals((UserType?)obj.user_type) &&
                this.view_count.TrueEquals((int?)obj.view_count) &&
                this.website_url.TrueEqualsString((string)obj.website_url);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/UserTimeline.cs
================================================
﻿#nullable disable
using MessagePack;
using MemoryPack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    public enum UserTimelineType : byte
    {
        commented = 1,
        asked = 2,
        answered = 3,
        badge = 4,
        revision = 5,
        accepted = 6,
        reviewed = 7,
        suggested = 8
    }

    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class UserTimeline : IGenericEquality<UserTimeline>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public DateTime? creation_date { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public PostType? post_type { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public UserTimelineType? timeline_type { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public int? user_id { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public int? post_id { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? comment_id { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? suggested_edit_id { get; set; }
        [ProtoMember(8)]
        [Key(7), Id(7)]
        public int? badge_id { get; set; }
        [ProtoMember(9)]
        [Key(8), Id(8)]
        public string title { get; set; }
        [ProtoMember(10)]
        [Key(9), Id(9)]
        public string detail { get; set; }
        [ProtoMember(11)]
        [Key(10), Id(10)]
        public string link { get; set; }

        public bool Equals(UserTimeline obj)
        {
            return
                this.badge_id.TrueEquals(obj.badge_id) &&
                this.comment_id.TrueEquals(obj.comment_id) &&
                this.creation_date.TrueEquals(obj.creation_date) &&
                this.detail.TrueEqualsString(obj.detail) &&
                this.link.TrueEqualsString(obj.link) &&
                this.post_id.TrueEquals(obj.post_id) &&
                this.post_type.TrueEquals(obj.post_type) &&
                this.suggested_edit_id.TrueEquals(obj.suggested_edit_id) &&
                this.timeline_type.TrueEquals(obj.timeline_type) &&
                this.title.TrueEqualsString(obj.title) &&
                this.user_id.TrueEquals(obj.user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.badge_id.TrueEquals((int?)obj.badge_id) &&
                this.comment_id.TrueEquals((int?)obj.comment_id) &&
                this.creation_date.TrueEquals((DateTime?)obj.creation_date) &&
                this.detail.TrueEqualsString((string)obj.detail) &&
                this.link.TrueEqualsString((string)obj.link) &&
                this.post_id.TrueEquals((int?)obj.post_id) &&
                this.post_type.TrueEquals((PostType?)obj.post_type) &&
                this.suggested_edit_id.TrueEquals((int?)obj.suggested_edit_id) &&
                this.timeline_type.TrueEquals((UserTimelineType?)obj.timeline_type) &&
                this.title.TrueEqualsString((string)obj.title) &&
                this.user_id.TrueEquals((int?)obj.user_id);
        }
    }
}



================================================
FILE: sandbox/Benchmark/Models/JilModels/WritePermission.cs
================================================
﻿#nullable disable
using MemoryPack;
using MessagePack;
using Orleans;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Benchmark.Models
{
    [ProtoContract]
    [MemoryPackable, MessagePackObject, GenerateSerializer]
    public partial class WritePermission : IGenericEquality<WritePermission>
    {
        [ProtoMember(1)]
        [Key(0), Id(0)]
        public int? user_id { get; set; }
        [ProtoMember(2)]
        [Key(1), Id(1)]
        public string object_type { get; set; }
        [ProtoMember(3)]
        [Key(2), Id(2)]
        public bool? can_add { get; set; }
        [ProtoMember(4)]
        [Key(3), Id(3)]
        public bool? can_edit { get; set; }
        [ProtoMember(5)]
        [Key(4), Id(4)]
        public bool? can_delete { get; set; }
        [ProtoMember(6)]
        [Key(5), Id(5)]
        public int? max_daily_actions { get; set; }
        [ProtoMember(7)]
        [Key(6), Id(6)]
        public int? min_seconds_between_actions { get; set; }

        public bool Equals(WritePermission obj)
        {
            return
                this.can_add.TrueEquals(obj.can_add) &&
                this.can_delete.TrueEquals(obj.can_delete) &&
                this.can_edit.TrueEquals(obj.can_edit) &&
                this.max_daily_actions.TrueEquals(obj.max_daily_actions) &&
                this.min_seconds_between_actions.TrueEquals(obj.min_seconds_between_actions) &&
                this.object_type.TrueEqualsString(obj.object_type) &&
                this.user_id.TrueEquals(obj.user_id);
        }

        public bool EqualsDynamic(dynamic obj)
        {
            return
                this.can_add.TrueEquals((bool?)obj.can_add) &&
                this.can_delete.TrueEquals((bool?)obj.can_delete) &&
                this.can_edit.TrueEquals((bool?)obj.can_edit) &&
                this.max_daily_actions.TrueEquals((int?)obj.max_daily_actions) &&
                this.min_seconds_between_actions.TrueEquals((int?)obj.min_seconds_between_actions) &&
                this.object_type.TrueEqualsString((string)obj.object_type) &&
                this.user_id.TrueEquals((int?)obj.user_id);
        }
    }
}



================================================
FILE: sandbox/ClassLibrary/Class1.cs
================================================
﻿
using MemoryPack;

[MemoryPackable]
public partial class Stat
{
    
}



================================================
FILE: sandbox/ClassLibrary/ClassLibrary.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net8.0;netstandard2.1</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <LangVersion>11.0</LangVersion>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>

</Project>



================================================
FILE: sandbox/NativeAot/NativeAot.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <!-- AOT Options -->
        <!-- https://learn.microsoft.com/ja-jp/dotnet/core/deploying/native-aot/ -->
        <PublishAot>true</PublishAot>
        <SelfContained>true</SelfContained>
        <IlcOptimizationPreference>Speed</IlcOptimizationPreference>
        <IlcOptimizationPreference>Size</IlcOptimizationPreference>
        <IlcFoldIdenticalMethodBodies>true</IlcFoldIdenticalMethodBodies>
    </PropertyGroup>

</Project>



================================================
FILE: sandbox/NativeAot/Program.cs
================================================
﻿using System.Buffers;

// require this unused line for reproduce error?
var bufferWriter = new ArrayBufferWriter<byte>();

var mc = new MemPackObject();

var formatter = new MemoryPackableFormatter2<MemPackObject>();
formatter.Serialize<ArrayBufferWriter<byte>>(ref mc);


public interface IMemoryPackable2<T>
{
    static abstract void Serialize<TBufferWriter>(scoped ref T? value)
        where TBufferWriter : IBufferWriter<byte>;
}

public interface IMemoryPackFormatter2<T>
{
    void Serialize<TBufferWriter>(scoped ref T? value)
        where TBufferWriter : IBufferWriter<byte>;
}

public abstract class MemoryPackFormatter2<T> : IMemoryPackFormatter2<T>
{
    public abstract void Serialize<TBufferWriter>(scoped ref T? value)
        where TBufferWriter : IBufferWriter<byte>;
}

public sealed class MemoryPackableFormatter2<T> : MemoryPackFormatter2<T>
    where T : IMemoryPackable2<T>
{
    public override void Serialize<TBufferWriter>(scoped ref T? value)
    {
        Console.WriteLine("Before");
        T.Serialize<TBufferWriter>(ref value);
        Console.WriteLine("After");
    }
}

public class MemPackObject : IMemoryPackable2<MemPackObject>
{
    public static void Serialize<TBufferWriter>(scoped ref MemPackObject? value)
          where TBufferWriter : IBufferWriter<byte>
    {
        Console.WriteLine("OK");
    }
}



================================================
FILE: sandbox/Net6VsNet7/Net6VsNet7.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFrameworks>net7.0;net6.0</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BenchmarkDotNet" Version="0.13.2" />
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.3.1" PrivateAssets="all" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>

    <ItemGroup>
        <Using Include="BenchmarkDotNet.Attributes" />
    </ItemGroup>
</Project>



================================================
FILE: sandbox/Net6VsNet7/Program.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using MemoryPack;
using System.Buffers;
using System.Reflection;

var config = ManualConfig.CreateMinimumViable()
    .AddDiagnoser(MemoryDiagnoser.Default)
    // .AddColumn(StatisticColumn.OperationsPerSecond)
    //.AddExporter(DefaultExporters.Plain)
    .AddExporter(MarkdownExporter.Default)
    .AddJob(Job.Default.WithWarmupCount(1).WithIterationCount(1).WithRuntime(CoreRuntime.Core60))
    .AddJob(Job.Default.WithWarmupCount(1).WithIterationCount(1).WithRuntime(CoreRuntime.Core70));

#if DEBUG

#else
BenchmarkSwitcher.FromTypes(new[] { typeof(Net6Net7<>) }).RunAllJoined(config);
#endif

[GenericTypeArguments(typeof(Sample))]
// [GenericTypeArguments(typeof(Sample2))]
[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByMethod)]
public class Net6Net7<T>
    where T : class, new()
{
    private T s;
    byte[] bin;

    public Net6Net7()
    {
        s = new();
        bin = MemoryPackSerializer.Serialize(s);
    }

    //[Benchmark]
    //public void SerializeDeserialize()
    //{
    //    MemoryPackSerializer.Deserialize<Sample>(MemoryPackSerializer.Serialize(s));
    //}

    [Benchmark]
    public byte[] Serialize()
    {
        return MemoryPackSerializer.Serialize(s);
    }

    [Benchmark]
    public T? Deserialize()
    {
        return MemoryPackSerializer.Deserialize<T>(bin);
    }
}

[MemoryPackable]
public partial class Sample
{
    public int PublicField;
    // public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }

    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;

    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}

[MemoryPackable]
public partial class Sample2
{
    public int PublicField;
    // public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }

    public int[]? ArrayProp { get; set; }

    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;

    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}



================================================
FILE: sandbox/SandboxConsoleApp/ForReadMe.cs
================================================
﻿using MemoryPack;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace Samples;


[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }


}

public class NotSerializableType
{

}


[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;

    // You can use parametarized constructor
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}

// also supports record primary constructor
[MemoryPackable]
public partial record Person2(int Age, string Name);

public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }

    public Person3()
    {
        this.Age = 0;
        this.Name = "";
    }

    // If exists multiple constructors, must use [MemoryPackConstructor]
    [MemoryPackConstructor]
    public Person3(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}


[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{

}

// Annotate inheritance types
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(249, typeof(BarClass))]
// [MemoryPackUnion(250, typeof(BarClass), useWideTag: true)]
public partial interface IUnionSample
{
}

[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}

[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}




public class Skelton : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        // use writer method.
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        // use reader method.
    }
}



[MemoryPackable]
public partial class Version1
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}

// Add is OK.
[MemoryPackable]
public partial class Version2
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}


[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}

[MemoryPackable]
public partial class MyDictContainer
{
    public Dictionary<int, string>? MD { get; set; }


}


[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }

    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }

    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }

    bool usePool;

    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }

    public void Dispose()
    {
        if (!usePool) return;

        Return(Payload); Payload = default;
    }

    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);

    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}



================================================
FILE: sandbox/SandboxConsoleApp/Models.cs
================================================
﻿using MemoryPack;
using MemoryPack.Formatters;
using MemoryPack.Internal;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json.Linq;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace SandboxConsoleApp;

public interface IMore
{
    public Version Description { get; set; }
}

public class NewBase
{
    public long Description { get; set; }
}

[MemoryPackable]
public partial struct FooUnman
{
    public float MyProperty { get; set; }
    public float MyProperty2 { get; set; }
}

[MemoryPackable]
public partial class NewProp : NewBase, IMore
{
    Version IMore.Description { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
    public new string? Description { get; set; }

    public NewProp()
    {

    }
}


[MemoryPackable]
public partial class NotNotOmu
{
    public Guid? GUIDNULLABLE { get; set; }
}


[MemoryPackable]
public partial class Mop
{
    public NoGen? MyProperty { get; set; }
    public LisList? MyLisList { get; set; }
    public List<Suage>? SuageMan { get; set; }
}


[MemoryPackable]
public partial class NotSample
{
    [Utf8StringFormatter]
    public string? Custom1 { get; set; }

}

[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class TakoyakiY
{
    [MemoryPackOrder(1)]
    public string? Bar { get; set; }
    [MemoryPackOrder(10)]
    public int Foo { get; set; }
}

[MemoryPackable(GenerateType.CircularReference)]
public partial class Suage
{
    [MemoryPackOrder(0)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(2)]
    public int Prop2 { get; set; }

    //public Suage(int prop1, int prop2)
    //{
    //    this.Prop1 = prop1;
    //    this.Prop2 = prop2;
    //}
}



[MemoryPackable(GenerateType.NoGenerate)]
public partial class NoGen
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class LisList : List<int>
{

}




[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    public int MyProperty { get; private set; }

    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}





================================================
FILE: sandbox/SandboxConsoleApp/Program.cs
================================================
﻿#pragma warning disable CS8600
#pragma warning disable CS0169
#pragma warning disable CS8602
#pragma warning disable CS8618

using MemoryPack;
using MemoryPack.Compression;
using MemoryPack.Formatters;
using MemoryPack.Streaming;
using Microsoft.Extensions.DependencyInjection;
using Samples;
using SandboxConsoleApp;
using System;
using System.Buffers;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.IO;
using System.IO.Compression;
using System.IO.Pipelines;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml.Linq;

using MemoryPack;
using System.Runtime.InteropServices;
using System.Diagnostics;

CollectionTest sourceCollection = new CollectionTest();
sourceCollection.Collection.Add("1234");
sourceCollection.Collection.Add("5678");

Pipe bufferPipe = new Pipe();
MemoryPackSerializer.Serialize(bufferPipe.Writer, sourceCollection);
_ = await bufferPipe.Writer.FlushAsync().ConfigureAwait(false);
ReadResult resultBuffer = await bufferPipe.Reader.ReadAsync().ConfigureAwait(false);


//var newSource = new CollectionTest();
var newSource = MemoryPackSerializer.Deserialize<CollectionTest>(resultBuffer.Buffer);
Console.WriteLine(newSource.Collection.Count);




[MemoryPackable]
public partial class Region
{
    public int positionX;
    public int positionY;
    public int positionZ;
    public Dictionary<Vector3, Chunk> chunks;
}
[MemoryPackable]
public partial class Chunk
{
    public bool hasGeneratedBorders;
    public int positionX;
    public int positionY;
    public int positionZ;
    public List<Brush> brushes;
    public Dictionary<ByteVector3, int> brushBBPositions;
}
[MemoryPackable]
public partial class ByteVector3
{
    public byte x, y, z;

    public override bool Equals(object obj)
    {
        // If the object is null, return false.
        if (obj == null || GetType() != obj.GetType())
        {
            return false;
        }

        // Cast the object to ByteVector3 to compare values.
        ByteVector3 other = (ByteVector3)obj;

        // Check if all components are equal.
        return x == other.x && y == other.y && z == other.z;
    }
    public override int GetHashCode()
    {
        return System.HashCode.Combine(x, y, z);
    }
}
[MemoryPackable]
public partial class Brush
{
    public byte[] vertices;
    public uint[] textures = new uint[] { 0, 0, 0, 0, 0, 0 };
    public bool hiddenFlag;
    public bool borderFlag;
}


[MemoryPackable]
public partial class CollectionTest
{
    public Collection<string> Collection { get; } = new Collection<string>();

    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }
}

[MemoryPackable]
public partial record MemPackTestObj
{
    public string[] Strings { get; set; }
    public DateTime Date { get; set; }
    public string Name { get; set; }
}


[MemoryPackable]
public partial class CctorSample
{
    //static partial void StaticConstructor()
    //{
    //}
}

[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }

    //static partial void StaticConstructor()
    //{
    //    Console.WriteLine("foo");
    //    // throw new NotImplementedException();
    //}
}

[MemoryPackable]
public partial class IntClass2
{
    public int Value { get; set; }
}



[MemoryPackable]
public partial struct BrotliValue<T>
{
    public long Value { get; set; }
}





//var arrayBufferWriter = new ArrayBufferWriter<byte>();




//var writer = new ArrayBufferWriter<byte>();
//var seq = new ReadOnlySequence<byte>(Encoding.UTF8.GetBytes("hogehogehugahugahage"));



// PipeWriter.Create(
//PipeWriter.Create().AsStream();
//Write(seq, writer);





//var compressed = writer.WrittenMemory;

//var stream = new BrotliStream(new MemoryStream(compressed.ToArray()), CompressionMode.Decompress, false);





//var dest = new byte[1024];


//var len = stream.Read(dest);


//var len2 = stream.Read(dest);

//var ok = BrotliDecoder.TryDecompress(compressed.Span, dest, out var written);


//var seq2 = new ReadOnlySequence<byte>(compressed);

//var writer2 = new ArrayBufferWriter<byte>();
//Read(seq2, writer2);




//MemoryPackSerializer.Serialize(brotli, "hogehogehugahuga", MemoryPackSerializeOptions.Default);


//var foobarbaz = brotli.ToArray();


//var dest2 = new byte[10];

//var decoder = new BrotliDecoder();
//var status = OperationStatus.DestinationTooSmall;
//while (status == OperationStatus.DestinationTooSmall)
//{
//    status = decoder.Decompress(tako, dest2, out var consumed, out var written);
//}


//Console.WriteLine(status);
//var status = BrotliDecoder.TryDecompress(tako, dest2, out var written2);
//Console.WriteLine(status + ":" + written2);

//var hogehoge = dest2.AsMemory(0, written2);


//var tako2 = MemoryPackSerializer.Deserialize<string>(hogehoge.Span);

//Console.WriteLine(foobarbaz.SequenceEqual(tako));


//BrotliCompression.






//var decoder = new BrotliDecoder();

//decoder.Decompress(


//public class DecompressReadOnlySequence
//{
//    ReadOnlySequence<byte> buffer;
//    BrotliDecoder decoder;


//    public DecompressReadOnlySequence()
//    {
//        // buffer.FirstSpan.


//        BrotliEncoder.GetMaxCompressedLength

//        //decoder.Decompress(


//    }

//}



//brotli.Dispose();

//var written = arrayBufferWriter.WrittenMemory;



//new BrotliStream(





//BrotliDecoder.TryDecompress(written,




//// new BrotliDecoder().Decompress(


////encoder.Compress(, , , , true);




//encoder.Dispose();


[MemoryPackable]
[GenerateTypeScript]
public partial class FooBarBaz
{
    //public int[] MyPropertyArray { get; set; } = default!;
    //public int[] MyPropertyArray { get; set; } = default!;
    public Hoge HogeDozo { get; set; }
    public byte[]? BytesProp { get; set; }
    public string? YoStarDearYomoda { get; private set; }
    public int[] MyPropertyArray { get; set; } = default!;
    public int[][] MyPropertyArray2 { get; set; } = default!;
    public int? MyProperty4 { get; set; }
    public Dictionary<int, List<int?>> Dictman { get; set; } = default!;
    public HashSet<int> SetMan { get; set; } = default!;

    public Sonota1 SonotaProp { get; set; } = default!;

    public Guid guid { get; set; } = default!;
    public Guid? NullTtoguid { get; set; } = default!;
    public DateTime dtt { get; set; } = default!;
    public Sonota2 SonotaProp2 { get; set; } = default!;
    // public Huga? Nuga { get; set; } = default!;

    // TODO: check GUID, Date
    //public int MyProperty1 { get; set; }
    //public int? MyProperty2 { get; set; }
    //public Hoge? MyProperty3 { get; set; }
}


public enum Hoge : sbyte
{
    Huga,
    Yo,
    SOSOSO
}

public enum Huga : int
{
    ZZZ = 10,
    NONUM,
    HOKEPON
}

[MemoryPackable]
[MemoryPackUnion(0, typeof(SampleUnion1))]
[MemoryPackUnion(1, typeof(SampleUnion2))]
[GenerateTypeScript]
public partial interface IMogeUnion
{
}

[MemoryPackable]
[GenerateTypeScript]
public partial class SampleUnion1 : IMogeUnion
{
    public int? MyProperty { get; set; }
}

[MemoryPackable]
[GenerateTypeScript]
public partial class SampleUnion2 : IMogeUnion
{
    public string? MyProperty { get; set; }

}


[MemoryPackable(GenerateType.Object)]
[GenerateTypeScript]
public partial class Sonota1
{
    // public NoSerializableObject? MyProperty { get; set; }
    public int HokuHoku { get; set; }
}

public class NoSerializableObject
{

}

[MemoryPackable(SerializeLayout.Explicit)]
[GenerateTypeScript]
public partial class Sonota2
{
    [MemoryPackOrder(1)]
    public int MyProperty1 { get; set; }
    [MemoryPackOrder(0)]
    public int MyProperty2 { get; set; }
}

[MemoryPackable(GenerateType.Object, SerializeLayout.Explicit)]
public partial class Sonota3
{
    [MemoryPackOrder(0)]
    public int MyProperty { get; set; }
}




//var person = new Person();
//var bin = MemoryPackSerializer.Serialize(person);

//// overwrite data to existing instance.
//MemoryPackSerializer.Deserialize(bin, ref person);

//internal void WriteCore(ReadOnlySpan<byte> buffer, bool isFinalBlock = false)
//{
//    if (_mode != CompressionMode.Compress)
//        throw new InvalidOperationException(SR.BrotliStream_Decompress_UnsupportedOperation);
//    EnsureNotDisposed();

//    OperationStatus lastResult = OperationStatus.DestinationTooSmall;
//    Span<byte> output = new Span<byte>(_buffer);
//    while (lastResult == OperationStatus.DestinationTooSmall)
//    {
//        int bytesConsumed;
//        int bytesWritten;
//        lastResult = _encoder.Compress(buffer, output, out bytesConsumed, out bytesWritten, isFinalBlock);
//        if (lastResult == OperationStatus.InvalidData)
//            throw new InvalidOperationException(SR.BrotliStream_Compress_InvalidData);
//        if (bytesWritten > 0)
//            _stream.Write(output.Slice(0, bytesWritten));
//        if (bytesConsumed > 0)
//            buffer = buffer.Slice(bytesConsumed);
//    }
//}


//internal static partial class BrotliUtils
//{
//    public const int WindowBits_Min = 10;
//    public const int WindowBits_Default = 22;
//    public const int WindowBits_Max = 24;
//    public const int Quality_Min = 0;
//    public const int Quality_Default = 4;
//    public const int Quality_Max = 11;
//    public const int MaxInputSize = int.MaxValue - 515; // 515 is the max compressed extra bytes

//    internal static int GetQualityFromCompressionLevel(CompressionLevel compressionLevel) =>
//        compressionLevel switch
//        {
//            CompressionLevel.NoCompression => Quality_Min,
//            CompressionLevel.Fastest => 1,
//            CompressionLevel.Optimal => Quality_Default,
//            CompressionLevel.SmallestSize => Quality_Max,
//            _ => throw new ArgumentException(SR.ArgumentOutOfRange_Enum, nameof(compressionLevel))
//        };
//}


[MemoryPackable(GenerateType.Collection)]
public partial class ListGenerics<T> : List<T>
{
}

[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
}


[MemoryPackable]
public partial record struct FooStruct(int x, int y);

[MemoryPackable]
public partial class Nu
{
    public UnionType? XXX;
}

[MemoryPackable]
[MemoryPackUnion(0, typeof(A))]
public partial interface UnionType
{

}

[MemoryPackable]
public partial class A : UnionType
{

}

[MemoryPackable]
public partial class Foo
{

    //Foo(int x)
    //{

    //}

    //public Foo()
    //{

    //}
}


[MemoryPackable]
public partial class MonoMono
{
    public FooBarFruit Yey { get; set; } = default!;
}


public enum FooBarFruit
{
    APple, orange, grape
}



#pragma warning disable CS8618
[MemoryPackable]
public partial class HogeHoge
{
    public BigInteger P1;
    public Version P2;
    public Uri P3;
    public TimeZoneInfo P4;
    public BitArray P5;
    public StringBuilder P6;
    public Type P7;
    public int[,] P8;
    public int[,,] P9;
    public int[,,,] P10;
    // ng
    // public int[,,,,] A5;

    // generics
    public KeyValuePair<int, int> P11;
    public Lazy<int> P12;
    public Nullable<int> P13;
    // collecition
    public ArraySegment<int> P14;
    public Memory<int> P15;
    public ReadOnlyMemory<int> P16;
    public ReadOnlySequence<int> P17;

    public List<int> P18;
    public Stack<int> P19;
    public Queue<int> P20;
    public LinkedList<int> P21;
    public HashSet<int> P22;
    public PriorityQueue<int, int> P23;
    public ObservableCollection<int> P24;
    public Collection<int> P25;
    public ConcurrentQueue<int> P26;
    public ConcurrentStack<int> P27;
    public ConcurrentBag<int> P28;
    public Dictionary<int, int> P29;
    public SortedDictionary<int, int> P30;
    public SortedList<int, int> P31;
    public ConcurrentDictionary<int, int> P32;
    public ReadOnlyCollection<int> P33;
    public ReadOnlyObservableCollection<int> P34;
    public BlockingCollection<int> P35;

    public ImmutableArray<int> P36;
    public ImmutableList<int> P37;
    public ImmutableQueue<int> P38;
    public ImmutableStack<int> P39;
    public ImmutableDictionary<int, int> P40;
    // public ImmutableSortedDictionary<int, int> P41;
    public ImmutableSortedSet<int> P42;
    public ImmutableHashSet<int> P43;
    public IImmutableList<int> P44;
    public IImmutableQueue<int> P45;
    public IImmutableStack<int> P46;
    public IImmutableDictionary<int, int> P47;
    public IImmutableSet<int> P48;
    public IEnumerable<int> P49;
    public ICollection<int> P50;
    public IReadOnlyCollection<int> P51;
    public IList<int> P52;
    public IReadOnlyList<int> P53;
    public IDictionary<int, int> P54;
    public IReadOnlyDictionary<int, int> P55;
    public ILookup<int, int> P56;
    public IGrouping<int, int> P57;
    public ISet<int> P58;
    public IReadOnlySet<int> P59;

    // tuples
    public Tuple<int, string, int> T3;
    public ValueTuple<int, string, int> VT3;
    // more
    public Nullable<MyStruct> N1;
    public KeyValuePair<string, string> N2;
}


[MemoryPackable]
public partial struct MyStruct
{
    public string? V;
}


[MemoryPackable(GenerateType.Collection)]
public partial class ListInt : List<int>
{

}

[MemoryPackable(GenerateType.Collection)]
public partial class SetInt : HashSet<int>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class DictionaryIntInt : Dictionary<int, int>
{
}



[MemoryPackable(GenerateType.Collection)]
public partial class SetGenerics<T> : HashSet<T>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class DictionaryGenerics<TK, TV> : Dictionary<TK, TV>
    where TK : notnull
{
}


//public class MyCollection<T> : List<T>, IMemoryPackFormatterRegister
//{
//    static MyCollection()
//    {
//        if (!MemoryPackFormatterProvider.IsRegistered<MyCollection<T>>())
//        {
//            MemoryPackFormatterProvider.Register<MyCollection<T>>();
//        }
//    }

//    static void IMemoryPackFormatterRegister.RegisterFormatter()
//    {
//        MemoryPackFormatterProvider.RegisterCollection<MyCollection<T?>, T>();
//    }
//}


//[MemoryPackable]
//public partial class Packable<T>
//{
//    public int TakoyakiX { get; set; }
//    [MemoryPackIgnore]
//    public object? ObjectObject { get; set; }
//    [MemoryPackIgnore]
//    public Array? StandardArray { get; set; }
//    public int[]? Array { get; set; }
//    public int[,]? MoreArray { get; set; }
//    public List<int>? List { get; set; }
//    public Version? Version { get; set; }

//    public T? TTTTT { get; set; }

//    [MemoryPackFormatter]
//    public Nazo? MyProperty { get; set; }

//    [MemoryPackFormatter]
//    public Nazo2? MyProperty2 { get; set; }
//}

//public class Nazo
//{

//}
//public class Nazo2
//{

//}

//public class Tadano
//{
//    public int MyProperty { get; set; }
//}



//public class C
//{
//    public int Foo { get; init; }
//    public required int Bar { get; init; }



[MemoryPackable]
public partial class Sample
{
    // these types are serialized by default
    public int PublicField;
    // public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }

    // these types are not serialized by default
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;

    // use [MemoryPackIgnore] to remove target of public member
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;

    // use [MemoryPackInclude] to promote private member to serialization target
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}


public struct DateTimeParamDefault
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Sequential)]
[MemoryPackable]
public partial struct TesTest
{
    public ValueTuple<int, int> VTI;
    public MyMessageHeader MyMsgHead;
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Sequential)]
[MemoryPackable]
public partial struct DateTimeParamSequential
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Auto)]
[MemoryPackable]
public partial struct DateTimeParamAuto
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Explicit, Size = 25)]
[MemoryPackable]
public partial struct DateTimeParamExplicit
{
    [FieldOffset(9)]
    public DateTimeOffset DateTime;
    [FieldOffset(1)]
    public long Timestamp;  // 8
    [FieldOffset(0)]
    public bool IsItInSeconds; // 1
}

[StructLayout(LayoutKind.Auto)]
public struct MyMessageHeader
{
}

[MemoryPackable]
public partial struct HogeEEE
{
    public int X;
    public int Y;

    // [MemoryPackConstructor]
    public HogeEEE(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}




================================================
FILE: sandbox/SandboxConsoleApp/SandboxConsoleApp.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>disable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <!-- <PublishAot>true</PublishAot> -->
    </PropertyGroup>

    <ItemGroup>
      <Compile Remove="MemoryPackLogs\**" />
      <EmbeddedResource Remove="MemoryPackLogs\**" />
      <None Remove="MemoryPackLogs\**" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="ConsoleAppFramework" Version="4.2.3" />
        <PackageReference Include="MessagePack" Version="2.4.35" />
        <PackageReference Include="Newtonsoft.Json" Version="13.0.2" />
        <PackageReference Include="System.IO.Pipelines" Version="6.0.3" />
    </ItemGroup>

    <!-- output memoerypack serialization info to directory -->
    <ItemGroup>
        <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
    </ItemGroup>
    <PropertyGroup>
        <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
    </PropertyGroup>


    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
        <ProjectReference Include="..\..\src\MemoryPack.Streaming\MemoryPack.Streaming.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/SandboxConsoleApp/SystemTextJsonChecker.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace SandboxConsoleApp;

// check the System.Text.Json's constructor select rule.

// For a class, if the only constructor is a parameterized one, that constructor will be used.
// For a struct, or a class with multiple constructors, specify the one to use by applying the[JsonConstructor] attribute.
// When the attribute is not used, a public parameterless constructor is always used if present.

// MemoryPack choose class/struct as same rule.
// If has no explicit constrtucotr, use parameterless one.
// If has a one parameterless/parameterized constructor, choose it.
// If has multiple construcotrs, should apply [MemoryPackConstructor] attribute(no automatically choose one), otherwise generator error it.

// The parameter names of a parameterized constructor must match the property names.
// Matching is case-insensitive, and the constructor parameter must match the actual property name.

class SystemTextJsonChecker : ConsoleAppBase
{
    //[RootCommand]
    public void JsonConstructorSelector()
    {
#if false

#endif
        var one = JsonSerializer.Serialize(new One());
        var two = JsonSerializer.Serialize(new Two(1, 2));
        var three = JsonSerializer.Serialize(new Three());
        var four = JsonSerializer.Serialize(new Four(1));
        var five = JsonSerializer.Serialize(new Five(1, 2));
        var six = JsonSerializer.Serialize(new Six(1, 2));
        var seven = JsonSerializer.Serialize(new Seven(1, 2));

        Console.WriteLine("---");

        JsonSerializer.Deserialize<One>(one);
        JsonSerializer.Deserialize<Two>(two);

        // if exists parameterized one, used this
        JsonSerializer.Deserialize<Three>(three);

        // class exists two constructor, no.
        // JsonSerializer.Deserialize<Four>(four);

        // struct choosed default
        JsonSerializer.Deserialize<Five>(five);
        JsonSerializer.Deserialize<Six>(six);

        // choosed [JsonContructor](multiple JsonConstructor no)
        JsonSerializer.Deserialize<Seven>(seven);
    }

    [RootCommand]
    public void PrivateSerialization()
    {
        // private field/property can not annnotate JsonInclude
        var v = JsonSerializer.Serialize(new PrivateOK(99, 100)
        {
            PublicField = 1000,
            PublicProp = 9999
        });
        Console.WriteLine(v);
    }
}

public class One
{
    public One()
    {
        Console.WriteLine("Called One");
    }
}

public class Two
{
    public int X { get; }
    public int Y { get; }

    public Two(int x, int y)
    {
        Console.WriteLine("Called Two");
        this.X = x;
        this.Y = y;
    }
}

public class Three
{

    public int X { get; }
    public int Y { get; }

    public Three()
    {
        Console.WriteLine("Called Three One");
    }

    public Three(int x, int y)
    {
        Console.WriteLine("Called Three Two");
        this.X = x;
        this.Y = y;
    }
}

public class Four
{

    public int X { get; }
    public int Y { get; }

    public Four(int x)
    {
        Console.WriteLine("Called Four Single");
        this.X = x;
    }

    public Four(int x, int y)
    {
        Console.WriteLine("Called Four Two");
        this.X = x;
        this.Y = y;
    }
}




public struct Five
{
    public int X { get; }
    public int Y { get; }

    public Five(int x, int y)
    {
        Console.WriteLine("Called Five");
        this.X = x;
        this.Y = y;
    }
}



public struct Six
{
    public int X { get; }
    public int Y { get; }

    public Six()
    {

    }

    public Six(int x, int y)
    {
        Console.WriteLine("Called Six");
        this.X = x;
        this.Y = y;
    }
}


public struct Seven
{
    public int X { get; }
    public int Y { get; }

    public Seven()
    {

    }

    [JsonConstructor]
    public Seven(int x, int y)
    {
        Console.WriteLine("Called Six");
        this.X = x;
        this.Y = y;
    }
}

public class PrivateOK
{
    public int PublicField;
    public int PublicProp { get; set; }

    //[JsonInclude]
    //private int privateField;

    [JsonInclude]
    public int PrivateGetter { private get; set; }

    [JsonInclude]
    public int PrivateSetter { get; }


    // [JsonInclude]
    // int PrivateBoth { get; set; }

    public PrivateOK(int privateSetter, int privateBoth)
    {
        this.PrivateSetter = privateSetter;
        // this.PrivateBoth = privateBoth;
    }

}



================================================
FILE: sandbox/SandboxNet6/NamespaceTest.cs
================================================
﻿using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SandboxNet6
{
    [MemoryPackable]
    public partial class NamespaceTest
    {
        public int MyProperty { get; set; }
    }

}



================================================
FILE: sandbox/SandboxNet6/Program.cs
================================================
﻿// See https://aka.ms/new-console-template for more information
using MemoryPack;
using System.Buffers;
using System.Drawing;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;


// System.Buffers.IBufferWriter<byte>
Console.WriteLine("Hello, World!");


[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IForExternalUnion
{
    public int BaseValue { get; set; }
}

[MemoryPackable]
public partial class AForOne : IForExternalUnion
{
    public int BaseValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackable]
public partial class AForTwo : IForExternalUnion
{
    public int BaseValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackUnionFormatter(typeof(IForExternalUnion))]
[MemoryPackUnion(0, typeof(AForOne))]
[MemoryPackUnion(1, typeof(AForTwo))]
public partial class ForExternalUnionFormatter
{
}


[MemoryPackable]
public partial class HelloMemoryPackable
{
    public int MyProperty { get; set; }
}


[MemoryPackable]
public partial class HelloMemoryPackable2
{
    public HelloMemoryPackable? MyProperty { get; set; }
    // public TypeAccessException My3Property { get; set; }
}


[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(249, typeof(BarClass))]
public partial interface IUnionSample
{
}

[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}

[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}


[MemoryPackable]
public partial struct IncludesReferenceStruct
{
    public int X;
    public string? Y;
}


[MemoryPackable]
[MemoryPackUnion(0, typeof(GenricUnionA<>))]
[MemoryPackUnion(1, typeof(GenricUnionB<>))]
public partial interface IGenericUnion<ToaruHoge>
{
    ToaruHoge? Value { get; set; }
}


[MemoryPackable]
public partial class GenricUnionA<T> : IGenericUnion<T>
{
    public T? Value { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackable]
public partial class GenricUnionB<T> : IGenericUnion<T>
{
    public T? Value { get; set; }
    public double MyProperty { get; set; }
}


[MemoryPackable]
public partial struct PartialStructOne
{
    public int X;
    public int Y;

    //[MemoryPackConstructor]
    public PartialStructOne(int x)
    {
        this.X = x;
        this.Y = 0;
    }

    //[MemoryPackConstructor]
    public PartialStructOne(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}

//[MemoryPackable]
//public partial struct DateTimeParamDefault
//{
//    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
//    public long Timestamp;  // 8
//    public bool IsItInSeconds; // 1(+padding7) = 8
//}

//[StructLayout(LayoutKind.Sequential)]
//[MemoryPackable]
//public partial struct TesTest
//{
//    public ValueTuple<int, int> VTI;
//    public MyMessageHeader MyMsgHead;
//    public bool IsItInSeconds; // 1(+padding7) = 8
//}

//[StructLayout(LayoutKind.Sequential)]
//[MemoryPackable]
//public partial struct DateTimeParamSequential
//{
//    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
//    public long Timestamp;  // 8
//    public bool IsItInSeconds; // 1(+padding7) = 8
//}

//[StructLayout(LayoutKind.Auto)]
//[MemoryPackable]
//public partial struct DateTimeParamAuto
//{
//    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
//    public long Timestamp;  // 8
//    public bool IsItInSeconds; // 1(+padding7) = 8
//}

//[StructLayout(LayoutKind.Explicit, Size = 25)]
//[MemoryPackable]
//public partial struct DateTimeParamExplicit
//{
//    [FieldOffset(9)]
//    public DateTimeOffset DateTime;
//    [FieldOffset(1)]
//    public long Timestamp;  // 8
//    [FieldOffset(0)]
//    public bool IsItInSeconds; // 1
//}

//[StructLayout(LayoutKind.Auto)]
//public struct MyMessageHeader
//{
//}


public struct float2 { }
public struct quaternion { }

[Serializable]
[MemoryPackable]
public partial class PlayerInput
{
    public float2 move;
    public quaternion target;
    public List<KeyRecord> keyRecords = new();
}

public enum EAction : byte
{
    Ability1,
    Ability2,
    Ability3,
    Ability4,
    Ability5,
    Ability6,
}

public enum EActionStatus : byte
{
    KeyDown = 0,
    keyPressing = 1,
    KeyUp = 2,
}

public struct KeyRecord
{
    public EAction action;
    public EActionStatus status;
}



================================================
FILE: sandbox/SandboxNet6/SandboxNet6.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <LangVersion>10.0</LangVersion>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>

    <!--<ItemGroup>
        <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
    </ItemGroup>
    <PropertyGroup>
        <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
    </PropertyGroup>-->

</Project>



================================================
FILE: sandbox/SandboxWebApp/appsettings.Development.json
================================================
{
  "DetailedErrors": true,
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}



================================================
FILE: sandbox/SandboxWebApp/appsettings.json
================================================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}



================================================
FILE: sandbox/SandboxWebApp/Models.cs
================================================
﻿using MemoryPack;
using System.ComponentModel;
using System.Security.Principal;

namespace SandboxWebApp;

[MemoryPackable]
[GenerateTypeScript]
public partial class FooBarBazDayonDattayon
{
    public int MyProperty { get; set; }
}


[MemoryPackable]
[GenerateTypeScript]
public partial class AllConvertableType
{
    // supported primitives
    public bool MyBool { get; set; }
    public byte MyByte { get; set; }
    public sbyte MySByte { get; set; }
    public short MyShort { get; set; }
    public int MyInt { get; set; }
    public long MyLong { get; set; }
    public ushort MyUShort { get; set; }
    public uint MyUInt { get; set; }
    public ulong MyULong { get; set; }
    public float MyFloat { get; set; }
    public double MyDouble { get; set; }
    public Guid MyGuid { get; set; }
    public DateTime MyDate { get; set; }
    public NoMarkByteEnum MyEnum1 { get; set; }
    public NumberedUShortEnum MyEnum2 { get; set; }


    // nullable
    public bool? NullMyBool { get; set; }
    public byte? NullMyByte { get; set; }
    public sbyte? NullMySByte { get; set; }
    public short? NullMyShort { get; set; }
    public int? NullMyInt { get; set; }
    public long? NullMyLong { get; set; }
    public ushort? NullMyUShort { get; set; }
    public uint? NullMyUInt { get; set; }
    public ulong? NullMyULong { get; set; }
    public float? NullMyFloat { get; set; }
    public double? NullMyDouble { get; set; }
    public Guid? NullMyGuid { get; set; }
    public DateTime? NullMyDate { get; set; }
    public NoMarkByteEnum? NullMyEnum1 { get; set; }
    public NumberedUShortEnum? NullMyEnum2 { get; set; }

    // reference types
    public string? MyString { get; set; }
    public byte[]? MyBytes { get; set; }
    public int[]? MyIntArray { get; set; }
    public string[]? MyStringArray { get; set; }
    public List<int>? MyList { get; set; }
    public Dictionary<int, int>? MyDictionary { get; set; }
    public HashSet<int>? MySet { get; set; }
    public List<Dictionary<int, HashSet<string[]>>>? MyNestedNested { get; set; }

    public Dictionary<NoMarkByteEnum, bool>? DictCheck2 { get; set; }
    public Dictionary<Guid, int?>? DictCheck3 { get; set; }
    public Dictionary<int, string>? DictCheck4X { get; set; }

    // memory-packable
    public NestedObject? Nested1 { get; set; }
    public IMogeUnion? Union1 { get; set; }

    // not supported type
    // public LongEnumBow NonSupportLongEnumBow { get; set; }
    // public Dictionary<int, NOBOU?> ddd { get; set; }
}

public enum NOBOU : int
{
    AP = 99
}




[MemoryPackable]
[GenerateTypeScript]
public partial class NestedObject
{
    public int MyProperty { get; set; }
    public string? MyProperty2 { get; set; }
}

[MemoryPackable]
[GenerateTypeScript]
public partial class ArrayGenericsCheck
{
    // array
    public NestedObject[]? Array1 { get; set; }
    public IMogeUnion[]? Array2 { get; set; }
    public List<NoMarkByteEnum>? List1 { get; set; }

}

public enum NoMarkByteEnum : byte
{
    Apple, Orange, Grape
}

public enum NumberedUShortEnum : ushort
{
    Tokyo = 10,
    Chiba = 100,
    Saitama = 1000
}



[MemoryPackable]
[MemoryPackUnion(0, typeof(SampleUnion1))]
[MemoryPackUnion(1, typeof(SampleUnion2))]
[GenerateTypeScript]
public partial interface IMogeUnion
{
}

[MemoryPackable]
[GenerateTypeScript]
public partial class SampleUnion1 : IMogeUnion
{
    public int? MyProperty { get; set; }
}

[MemoryPackable]
[GenerateTypeScript]
public partial class SampleUnion2 : IMogeUnion
{
    public string? MyProperty { get; set; }
}


[MemoryPackable]
[GenerateTypeScript]
public partial class Subset
{
    public bool MyBool { get; set; }
    public byte MyByte { get; set; }
    public sbyte MySByte { get; set; }
    public short MyShort { get; set; }
}



// https://raw.githubusercontent.com/endel/msgpack-benchmark/master/sample-large.json
[MemoryPackable]
[GenerateTypeScript]
public partial class SampleLarge
{
    public string? _id { get; set; }
    public string? author { get; set; }
    public string? created_at { get; set; }
    public string? description { get; set; }
    public string? image { get; set; }
    public string[]? keywords { get; set; }
    public string? language { get; set; }
    public string? permalink { get; set; }
    public bool published { get; set; }
    public string? title { get; set; }
    public string? updated_at { get; set; }
    public string? url { get; set; }
}




[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}

public enum Gender
{
    Male, Female, Other
}


[MemoryPackable]
[GenerateTypeScript]
public partial class Rec
{
    public required Rec Id { get; init; }
}

[MemoryPackable]
[GenerateTypeScript]
public partial class NullableFloatTest
{
    public float? NullableFloat { get; set; }
    public double? NullableDouble { get; set; }
}



================================================
FILE: sandbox/SandboxWebApp/Program.cs
================================================
﻿using MemoryPack;
using MemoryPack.AspNetCoreMvcFormatter;
using System.Diagnostics;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter());
});


var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapRazorPages();

app.MapControllers();

app.Run();



================================================
FILE: sandbox/SandboxWebApp/SandboxWebApp.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net7.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.TypeScript.MSBuild" Version="4.9.0-beta">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
        <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
        <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
        <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
        <CompilerVisibleProperty Include="DesignTimeBuild" />
    </ItemGroup>
    <PropertyGroup>
        <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
        <MemoryPackGenerator_TypeScriptImportExtension>.js</MemoryPackGenerator_TypeScriptImportExtension>
        <!--<MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>-->
        <!--<MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>-->
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.AspNetCoreMvcFormatter\MemoryPack.AspNetCoreMvcFormatter.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>

</Project>



================================================
FILE: sandbox/SandboxWebApp/tsconfig.json
================================================
{
  "compileOnSave": true,
  "compilerOptions": {
    "noImplicitAny": true,
    "noEmitOnError": true,
    "removeComments": false,
    "strict": true,
    "sourceMap": true,
    "target": "ES2022"
  },
  "include": [
    "wwwroot/**/*"
  ]
}



================================================
FILE: sandbox/SandboxWebApp/Controllers/MemoryPackController.cs
================================================
﻿using MemoryPack;
using Microsoft.AspNetCore.Mvc;

namespace SandboxWebApp.Controllers;

[Route("api/")]
public class MemoryPackController : Controller
{
    [HttpPost]
    public AllConvertableType Post([FromBody] AllConvertableType value)
    // public Person Post([FromBody] Person value)
    {
        return value;
    }

    [Route("nullableFloat")]
    [HttpPost]
    public NullableFloatTest PostNullableTest([FromBody] NullableFloatTest input)
    {
        var ret = new NullableFloatTest
        {
            // If you're curious about the '* 1.0' part, DM me :-)
            NullableFloat = input.NullableFloat * 1.0F,
            NullableDouble = input.NullableDouble * 1.0D
        };

        return ret;
    }
}



================================================
FILE: sandbox/SandboxWebApp/Pages/_ViewImports.cshtml
================================================
﻿@using SandboxWebApp
@namespace SandboxWebApp.Pages
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers



================================================
FILE: sandbox/SandboxWebApp/Pages/_ViewStart.cshtml
================================================
﻿@{
    Layout = "_Layout";
}



================================================
FILE: sandbox/SandboxWebApp/Pages/Error.cshtml
================================================
﻿@page
@model ErrorModel
@{
    ViewData["Title"] = "Error";
}

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (Model.ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@Model.RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to the <strong>Development</strong> environment displays detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>



================================================
FILE: sandbox/SandboxWebApp/Pages/Error.cshtml.cs
================================================
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using System.Diagnostics;

namespace SandboxWebApp.Pages;
[ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
[IgnoreAntiforgeryToken]
public class ErrorModel : PageModel
{
    public string? RequestId { get; set; }

    public bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    private readonly ILogger<ErrorModel> _logger;

    public ErrorModel(ILogger<ErrorModel> logger)
    {
        _logger = logger;
    }

    public void OnGet()
    {
        RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
    }
}




================================================
FILE: sandbox/SandboxWebApp/Pages/Index.cshtml
================================================
﻿@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}

<script type="module">
    import { test } from "./js/file.js";
    import { test2 } from "./js/file.js";
    import { testNullableFloatWithValues } from "./js/file.js";
    import { testNullableFloatWithNulls } from "./js/file.js";
    import { hoge } from "./js/file.js";
    import { huga } from "./js/file.js";

    //hoge();
    //huga();
    test();
    test2();

    testNullableFloatWithValues();
    testNullableFloatWithNulls();

</script>

<div class="text-center">
    <input type="button" value="button" onclick="do()">
</div>



================================================
FILE: sandbox/SandboxWebApp/Pages/Index.cshtml.cs
================================================
﻿using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace SandboxWebApp.Pages;
public class IndexModel : PageModel
{
    private readonly ILogger<IndexModel> _logger;

    public IndexModel(ILogger<IndexModel> logger)
    {
        _logger = logger;
    }

    public void OnGet()
    {

    }
}



================================================
FILE: sandbox/SandboxWebApp/Pages/Privacy.cshtml
================================================
﻿@page
@model PrivacyModel
@{
    ViewData["Title"] = "Privacy Policy";
}
<h1>@ViewData["Title"]</h1>

<p>Use this page to detail your site's privacy policy.</p>



================================================
FILE: sandbox/SandboxWebApp/Pages/Privacy.cshtml.cs
================================================
﻿using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace SandboxWebApp.Pages;
public class PrivacyModel : PageModel
{
    private readonly ILogger<PrivacyModel> _logger;

    public PrivacyModel(ILogger<PrivacyModel> logger)
    {
        _logger = logger;
    }

    public void OnGet()
    {
    }
}




================================================
FILE: sandbox/SandboxWebApp/Pages/Shared/_Layout.cshtml
================================================
﻿<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@ViewData["Title"] - SandboxWebApp</title>
    <link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="~/css/site.css" asp-append-version="true" />
    <link rel="stylesheet" href="~/SandboxWebApp.styles.css" asp-append-version="true" />
</head>
<body>
    <header>
        <nav class="navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3">
            <div class="container">
                <a class="navbar-brand" asp-area="" asp-page="/Index">SandboxWebApp</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target=".navbar-collapse" aria-controls="navbarSupportedContent"
                        aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="navbar-collapse collapse d-sm-inline-flex justify-content-between">
                    <ul class="navbar-nav flex-grow-1">
                        <li class="nav-item">
                            <a class="nav-link text-dark" asp-area="" asp-page="/Index">Home</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link text-dark" asp-area="" asp-page="/Privacy">Privacy</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <div class="container">
        <main role="main" class="pb-3">
            @RenderBody()
        </main>
    </div>

    <footer class="border-top footer text-muted">
        <div class="container">
            &copy; 2022 - SandboxWebApp - <a asp-area="" asp-page="/Privacy">Privacy</a>
        </div>
    </footer>

    <script src="~/lib/jquery/dist/jquery.min.js"></script>
    <script src="~/lib/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
    <script src="~/js/site.js" asp-append-version="true"></script>

    @await RenderSectionAsync("Scripts", required: false)
</body>
</html>



================================================
FILE: sandbox/SandboxWebApp/Pages/Shared/_Layout.cshtml.css
================================================
﻿/* Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification
for details on configuring this project to bundle and minify static web assets. */

a.navbar-brand {
  white-space: normal;
  text-align: center;
  word-break: break-all;
}

a {
  color: #0077cc;
}

.btn-primary {
  color: #fff;
  background-color: #1b6ec2;
  border-color: #1861ac;
}

.nav-pills .nav-link.active, .nav-pills .show > .nav-link {
  color: #fff;
  background-color: #1b6ec2;
  border-color: #1861ac;
}

.border-top {
  border-top: 1px solid #e5e5e5;
}
.border-bottom {
  border-bottom: 1px solid #e5e5e5;
}

.box-shadow {
  box-shadow: 0 .25rem .75rem rgba(0, 0, 0, .05);
}

button.accept-policy {
  font-size: 1rem;
  line-height: inherit;
}

.footer {
  position: absolute;
  bottom: 0;
  width: 100%;
  white-space: nowrap;
  line-height: 60px;
}



================================================
FILE: sandbox/SandboxWebApp/Pages/Shared/_ValidationScriptsPartial.cshtml
================================================
﻿<script src="~/lib/jquery-validation/dist/jquery.validate.min.js"></script>
<script src="~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js"></script>



================================================
FILE: sandbox/SandboxWebApp/Properties/launchSettings.json
================================================
{
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5260",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}



================================================
FILE: sandbox/SandboxWebApp/tests/test.ts
================================================
﻿
import * as asserts from "assert";





================================================
FILE: sandbox/SandboxWebApp/wwwroot/css/site.css
================================================
html {
  font-size: 14px;
}

@media (min-width: 768px) {
  html {
    font-size: 16px;
  }
}

.btn:focus, .btn:active:focus, .btn-link.nav-link:focus, .form-control:focus, .form-check-input:focus {
  box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

html {
  position: relative;
  min-height: 100%;
}

body {
  margin-bottom: 60px;
}


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/file.js
================================================
import { AllConvertableType } from "./memorypack/AllConvertableType.js";
import { NestedObject } from "./memorypack/NestedObject.js";
import { SampleUnion1 } from "./memorypack/SampleUnion1.js";
import { SampleUnion2 } from "./memorypack/SampleUnion2.js";
import { Person } from "./memorypack/Person.js";
import { NullableFloatTest } from "./memorypack/NullableFloatTest.js";
export async function hoge() {
    let person = new Person();
    person.id = crypto.randomUUID();
    person.age = 30;
    person.firstName = "foo";
    person.lastName = "bar";
    person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
    person.gender = 2 /* Gender.Other */;
    person.emails = ["foo@bar.com", "zoo@bar.net"];
    // serialize to Uint8Array
    let bin = Person.serialize(person);
    let blob = new Blob([bin.buffer], { type: "application/x-memorypack" });
    let response = await fetch("http://localhost:5260/api", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    let buffer = await response.arrayBuffer();
    // deserialize from ArrayBuffer 
    let person2 = Person.deserialize(buffer);
}
export async function huga() {
    let person1 = new Person();
    person1.id = crypto.randomUUID();
    person1.age = 30;
    person1.firstName = "foo";
    person1.lastName = "bar";
    person1.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
    person1.gender = 2 /* Gender.Other */;
    person1.emails = ["foo@bar.com", "zoo@bar.net"];
    let person2 = new Person();
    person2.id = crypto.randomUUID();
    person2.age = 430;
    person2.firstName = "zoo";
    person2.lastName = "zzz";
    person2.dateOfBirth = new Date(2229, 12, 31, 0, 0, 0);
    person2.gender = 1 /* Gender.Female */;
    person2.emails = null;
    let array = Person.serializeArray([person1, person2]);
    try {
        let two = Person.deserializeArray(array.buffer);
        console.log(two);
    }
    catch (e) {
        console.log("no:" + e);
    }
}
export async function test() {
    const date = new Date();
    // setup
    const v = new AllConvertableType();
    v.myBool = true;
    v.myByte = 10;
    v.mySByte = -99;
    v.myShort = -1000;
    v.myInt = 99999;
    v.myLong = 2124141414999n;
    v.myUShort = 43141;
    v.myUInt = 400000;
    v.myULong = 243242n;
    v.myFloat = 31413.431251;
    v.myDouble = 9932.425252;
    v.myGuid = crypto.randomUUID();
    v.myDate = date;
    v.myEnum1 = 2 /* NoMarkByteEnum.Grape */;
    v.myEnum2 = 1000 /* NumberedUShortEnum.Saitama */;
    v.myString = "あいうえおかきくけこさしすせそ"; // japanese
    v.myBytes = new Uint8Array([10, 20, 10, 40, 99, 1000]);
    v.myIntArray = [999999, 10, 2131, 412, -42141];
    v.myStringArray = ["hogehgoe", "hugahgua", null, "漢字"];
    v.myList = [10, 20, 30, 40, 50];
    v.myDictionary = new Map();
    v.myDictionary.set(100, 99999);
    v.myDictionary.set(200, 40000);
    v.myDictionary.set(150, 50000);
    v.mySet = new Set();
    v.mySet.add(10);
    v.mySet.add(40);
    v.mySet.add(20);
    v.mySet.add(30);
    v.myNestedNested = [
        new Map(),
        new Map(),
        new Map(),
    ];
    const setA = new Set();
    setA.add(["hoge", "huga"]);
    setA.add(["a", "びー", "シー"]);
    const setB = new Set();
    setA.add(["zako", "notzako"]);
    setA.add(["a", "b", "c", "d", "いー"]);
    const setC = new Set();
    v.myNestedNested[0]?.set(100, setA);
    v.myNestedNested[1]?.set(200, setB);
    v.myNestedNested[2]?.set(300, setC);
    v.dictCheck2 = new Map();
    v.dictCheck2.set(0 /* NoMarkByteEnum.Apple */, true);
    v.dictCheck2.set(1 /* NoMarkByteEnum.Orange */, false);
    v.dictCheck3 = new Map();
    v.dictCheck3.set(crypto.randomUUID(), 100);
    v.dictCheck3.set(crypto.randomUUID(), null);
    v.dictCheck4X = new Map();
    v.dictCheck4X.set(9, "hogemoge");
    v.dictCheck4X.set(19, null);
    v.nested1 = new NestedObject();
    v.nested1.myProperty = 99999;
    v.nested1.myProperty2 = "hogemogeあいううえもげもげもげ";
    const vv = new SampleUnion1();
    vv.myProperty = 9999;
    v.union1 = vv;
    // call
    const bin = AllConvertableType.serialize(v);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" });
    const response = await fetch("http://localhost:5260/api/", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();
    const v2 = AllConvertableType.deserialize(buffer);
    assertObject(v, v2);
}
export async function test2() {
    const date = new Date();
    // setup
    const v = new AllConvertableType();
    v.nullMyBool = true;
    v.nullMyByte = 10;
    v.nullMySByte = -99;
    v.nullMyShort = -1000;
    v.nullMyInt = 99999;
    v.nullMyLong = 2124141414999n;
    v.nullMyUShort = 43141;
    v.nullMyUInt = 400000;
    v.nullMyULong = 243242n;
    v.nullMyFloat = 31413.431251;
    v.nullMyDouble = 9932.425252;
    v.nullMyGuid = crypto.randomUUID();
    v.nullMyDate = date;
    v.nullMyEnum1 = 2 /* NoMarkByteEnum.Grape */;
    v.nullMyEnum2 = 1000 /* NumberedUShortEnum.Saitama */;
    const vv = new SampleUnion2();
    vv.myProperty = "hogetakoあおえ";
    v.union1 = vv;
    // call
    const bin = AllConvertableType.serialize(v);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" });
    const response = await fetch("http://localhost:5260/api/", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();
    const v2 = AllConvertableType.deserialize(buffer);
    assertObject(v, v2);
}
export async function testNullableFloatWithValues() {
    const input = new NullableFloatTest();
    input.nullableFloat = 31413.431251;
    input.nullableDouble = 9932.425252;
    const bin = NullableFloatTest.serialize(input);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" });
    const response = await fetch("http://localhost:5260/api/nullableFloat", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();
    const output = NullableFloatTest.deserialize(buffer);
    assertNullableFloat(input, output);
    console.log("testNullableFloatWithValues passed.");
}
export async function testNullableFloatWithNulls() {
    const input = new NullableFloatTest();
    input.nullableFloat = null;
    input.nullableDouble = null;
    const bin = NullableFloatTest.serialize(input);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" });
    const response = await fetch("http://localhost:5260/api/nullableFloat", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();
    const output = NullableFloatTest.deserialize(buffer);
    assertIsNull(output.nullableFloat);
    assertIsNull(output.nullableDouble);
    console.log("testNullableFloatWithNulls passed.");
}
function assertNullableFloat(a, b) {
    ok(a.nullableFloat?.toFixed(1), b.nullableFloat?.toFixed(1));
    ok(a.nullableDouble?.toFixed(1), b.nullableDouble?.toFixed(1));
}
function assertObject(v, v2) {
    ok(v.myBool, v2.myBool);
    ok(v.myByte, v2.myByte);
    ok(v.mySByte, v2.mySByte);
    ok(v.myShort, v2.myShort);
    ok(v.myInt, v2.myInt);
    ok(v.myLong, v2.myLong);
    ok(v.myUShort, v2.myUShort);
    ok(v.myUInt, v2.myUInt);
    ok(v.myULong, v2.myULong);
    ok(v.myFloat.toFixed(1), v2.myFloat.toFixed(1));
    ok(v.myDouble.toFixed(1), v2.myDouble.toFixed(1));
    ok(v.myGuid, v2.myGuid);
    ok(v.myDate.getTime(), v2.myDate.getTime());
    ok(v.myEnum1, v2.myEnum1);
    ok(v.myEnum2, v2.myEnum2);
    ok(v.myString, v2.myString);
    if (v.myBytes != null) {
        ok(v.myBytes.length, v2.myBytes.length);
        for (let i = 0; i < v.myBytes.length; i++) {
            ok(v.myBytes[i], v2.myBytes[i]);
        }
    }
    if (v.myIntArray != null) {
        ok(v.myIntArray.length, v2.myIntArray.length);
        for (let i = 0; i < v.myIntArray.length; i++) {
            ok(v.myIntArray[i], v2.myIntArray[i]);
        }
    }
    if (v.myStringArray != null) {
        ok(v.myStringArray.length, v2.myStringArray.length);
        for (let i = 0; i < v.myStringArray.length; i++) {
            ok(v.myStringArray[i], v2.myStringArray[i]);
        }
    }
    if (v.myList != null) {
        ok(v.myList.length, v2.myList.length);
        for (let i = 0; i < v.myList.length; i++) {
            ok(v.myList[i], v2.myList[i]);
        }
    }
    if (v.myDictionary != null) {
        v.myDictionary?.forEach((v, k) => {
            ok(v, v2.myDictionary?.get(k));
        });
    }
    if (v.mySet != null) {
        v.mySet?.forEach(v => {
            ok(true, v2.mySet?.has(v));
        });
    }
    ok(v.nested1?.myProperty, v2.nested1?.myProperty);
    ok(v.nested1?.myProperty2, v2.nested1?.myProperty2);
    if (v.union1 instanceof SampleUnion1 && v2.union1 instanceof SampleUnion1) {
        ok(v.union1.myProperty, v2.union1.myProperty);
    }
    else if (v.union1 instanceof SampleUnion2 && v2.union1 instanceof SampleUnion2) {
        ok(v.union1.myProperty, v2.union1.myProperty);
    }
    else {
        ok(true, false);
    }
    console.log("test passed");
}
function assertIsNull(value) {
    if (value !== null)
        throw new Error("Invalid: value must be null.");
}
function ok(v1, v2) {
    if (v1 === v2)
        return;
    throw new Error("Invalid v1:" + v1 + " v2:" + v2);
}
//# sourceMappingURL=file.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/file.ts
================================================
﻿import { MemoryPackWriter } from "./memorypack/MemoryPackWriter.js";
import { MemoryPackReader } from "./memorypack/MemoryPackReader.js";
import { AllConvertableType } from "./memorypack/AllConvertableType.js";
import { NoMarkByteEnum } from "./memorypack/NoMarkByteEnum.js";
import { NumberedUShortEnum } from "./memorypack/NumberedUShortEnum.js";
import { NestedObject } from "./memorypack/NestedObject.js";
import { IMogeUnion } from "./memorypack/IMogeUnion.js";
import { SampleUnion1 } from "./memorypack/SampleUnion1.js";
import { Subset } from "./memorypack/Subset.js";
import { SampleUnion2 } from "./memorypack/SampleUnion2.js";
import { Person } from "./memorypack/Person.js";
import { Gender } from "./memorypack/Gender.js";
import { NullableFloatTest } from "./memorypack/NullableFloatTest.js";

export async function hoge() {



    let person = new Person();
    person.id = crypto.randomUUID();
    person.age = 30;
    person.firstName = "foo";
    person.lastName = "bar";
    person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
    person.gender = Gender.Other;
    person.emails = ["foo@bar.com", "zoo@bar.net"];

    // serialize to Uint8Array
    let bin = Person.serialize(person);

    let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })

    let response = await fetch("http://localhost:5260/api",
        { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });

    let buffer = await response.arrayBuffer();

    // deserialize from ArrayBuffer 
    let person2 = Person.deserialize(buffer);


}

export async function huga() {


    let person1 = new Person();
    person1.id = crypto.randomUUID();
    person1.age = 30;
    person1.firstName = "foo";
    person1.lastName = "bar";
    person1.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
    person1.gender = Gender.Other;
    person1.emails = ["foo@bar.com", "zoo@bar.net"];

    let person2 = new Person();
    person2.id = crypto.randomUUID();
    person2.age = 430;
    person2.firstName = "zoo";
    person2.lastName = "zzz";
    person2.dateOfBirth = new Date(2229, 12, 31, 0, 0, 0);
    person2.gender = Gender.Female;
    person2.emails = null;

    let array = Person.serializeArray([person1, person2]);

    try {
        let two = Person.deserializeArray(array.buffer);
        console.log(two);
    }
    catch (e) {
        console.log("no:" + e);
    }

}


export async function test() {

    const date = new Date();

    // setup
    const v = new AllConvertableType();
    v.myBool = true;
    v.myByte = 10;
    v.mySByte = -99;
    v.myShort = -1000;
    v.myInt = 99999;
    v.myLong = 2124141414999n;
    v.myUShort = 43141;
    v.myUInt = 400000;
    v.myULong = 243242n;
    v.myFloat = 31413.431251;
    v.myDouble = 9932.425252;
    v.myGuid = crypto.randomUUID();
    v.myDate = date;
    v.myEnum1 = NoMarkByteEnum.Grape;
    v.myEnum2 = NumberedUShortEnum.Saitama;

    v.myString = "あいうえおかきくけこさしすせそ"; // japanese
    v.myBytes = new Uint8Array([10, 20, 10, 40, 99, 1000]);
    v.myIntArray = [999999, 10, 2131, 412, -42141];
    v.myStringArray = ["hogehgoe", "hugahgua", null, "漢字"];
    v.myList = [10, 20, 30, 40, 50];
    v.myDictionary = new Map<number, number>();
    v.myDictionary.set(100, 99999);
    v.myDictionary.set(200, 40000);
    v.myDictionary.set(150, 50000);
    v.mySet = new Set<number>();
    v.mySet.add(10);
    v.mySet.add(40);
    v.mySet.add(20);
    v.mySet.add(30);

    v.myNestedNested = [
        new Map<number, Set<string[]>>(),
        new Map<number, Set<string[]>>(),
        new Map<number, Set<string[]>>(),
    ]
    const setA = new Set<string[]>();
    setA.add(["hoge", "huga"]);
    setA.add(["a", "びー", "シー"]);
    const setB = new Set<string[]>();
    setA.add(["zako", "notzako"]);
    setA.add(["a", "b", "c", "d", "いー"]);
    const setC = new Set<string[]>();

    v.myNestedNested[0]?.set(100, setA);
    v.myNestedNested[1]?.set(200, setB);
    v.myNestedNested[2]?.set(300, setC);

    v.dictCheck2 = new Map<NoMarkByteEnum, boolean>();
    v.dictCheck2.set(NoMarkByteEnum.Apple, true);
    v.dictCheck2.set(NoMarkByteEnum.Orange, false);
    v.dictCheck3 = new Map<string, number>();
    v.dictCheck3.set(crypto.randomUUID(), 100);
    v.dictCheck3.set(crypto.randomUUID(), null);
    v.dictCheck4X = new Map<number, string>();
    v.dictCheck4X.set(9, "hogemoge");
    v.dictCheck4X.set(19, null);

    v.nested1 = new NestedObject();
    v.nested1.myProperty = 99999;
    v.nested1.myProperty2 = "hogemogeあいううえもげもげもげ";

    const vv = new SampleUnion1();
    vv.myProperty = 9999;
    v.union1 = vv;

    // call

    const bin = AllConvertableType.serialize(v);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" })


    const response = await fetch("http://localhost:5260/api/", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();

    const v2 = AllConvertableType.deserialize(buffer);

    assertObject(v, v2!);
}

export async function test2() {

    const date = new Date();

    // setup
    const v = new AllConvertableType();
    v.nullMyBool = true;
    v.nullMyByte = 10;
    v.nullMySByte = -99;
    v.nullMyShort = -1000;
    v.nullMyInt = 99999;
    v.nullMyLong = 2124141414999n;
    v.nullMyUShort = 43141;
    v.nullMyUInt = 400000;
    v.nullMyULong = 243242n;
    v.nullMyFloat = 31413.431251;
    v.nullMyDouble = 9932.425252;
    v.nullMyGuid = crypto.randomUUID();
    v.nullMyDate = date;
    v.nullMyEnum1 = NoMarkByteEnum.Grape;
    v.nullMyEnum2 = NumberedUShortEnum.Saitama;

    const vv = new SampleUnion2();
    vv.myProperty = "hogetakoあおえ";
    v.union1 = vv;

    // call
    const bin = AllConvertableType.serialize(v);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" })


    const response = await fetch("http://localhost:5260/api/", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });
    if (response.status != 200) {
        console.log(response.status);
        return;
    }
    const buffer = await response.arrayBuffer();

    const v2 = AllConvertableType.deserialize(buffer);

    assertObject(v, v2!);
}

export async function testNullableFloatWithValues()
{
    const input = new NullableFloatTest();
    input.nullableFloat = 31413.431251;
    input.nullableDouble = 9932.425252;

    const bin = NullableFloatTest.serialize(input);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" })
    const response = await fetch("http://localhost:5260/api/nullableFloat", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });

    if (response.status != 200) {
        console.log(response.status);
        return;
    }

    const buffer = await response.arrayBuffer();
    const output = NullableFloatTest.deserialize(buffer);
    assertNullableFloat(input, output!);

    console.log("testNullableFloatWithValues passed.");
}

export async function testNullableFloatWithNulls() {
    const input = new NullableFloatTest();
    input.nullableFloat = null;
    input.nullableDouble = null;

    const bin = NullableFloatTest.serialize(input);
    const blob = new Blob([bin.buffer], { type: "application/x-memorypack" })
    const response = await fetch("http://localhost:5260/api/nullableFloat", { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });

    if (response.status != 200) {
        console.log(response.status);
        return;
    }

    const buffer = await response.arrayBuffer();
    const output = NullableFloatTest.deserialize(buffer);

    assertIsNull(output!.nullableFloat);
    assertIsNull(output!.nullableDouble);

    console.log("testNullableFloatWithNulls passed.");
}

function assertNullableFloat(a: NullableFloatTest, b: NullableFloatTest): void
{
    ok(a.nullableFloat?.toFixed(1), b.nullableFloat?.toFixed(1))
    ok(a.nullableDouble?.toFixed(1), b.nullableDouble?.toFixed(1))
}

function assertObject(v: AllConvertableType, v2: AllConvertableType): void {
    ok(v.myBool, v2.myBool);
    ok(v.myByte, v2.myByte);
    ok(v.mySByte, v2.mySByte);
    ok(v.myShort, v2.myShort);
    ok(v.myInt, v2.myInt);
    ok(v.myLong, v2.myLong);
    ok(v.myUShort, v2.myUShort);
    ok(v.myUInt, v2.myUInt);
    ok(v.myULong, v2.myULong);
    ok(v.myFloat.toFixed(1), v2.myFloat.toFixed(1));
    ok(v.myDouble.toFixed(1), v2.myDouble.toFixed(1));
    ok(v.myGuid, v2.myGuid);
    ok(v.myDate.getTime(), v2.myDate.getTime());
    ok(v.myEnum1, v2.myEnum1);
    ok(v.myEnum2, v2.myEnum2);

    ok(v.myString, v2.myString);

    if (v.myBytes != null) {
        ok(v.myBytes!.length, v2.myBytes!.length);
        for (let i = 0; i < v.myBytes!.length; i++) {
            ok(v.myBytes![i], v2.myBytes![i]);
        }
    }

    if (v.myIntArray != null) {
        ok(v.myIntArray!.length, v2.myIntArray!.length);
        for (let i = 0; i < v.myIntArray!.length; i++) {
            ok(v.myIntArray![i], v2.myIntArray![i]);
        }
    }

    if (v.myStringArray != null) {
        ok(v.myStringArray!.length, v2.myStringArray!.length);
        for (let i = 0; i < v.myStringArray!.length; i++) {
            ok(v.myStringArray![i], v2.myStringArray![i]);
        }
    }

    if (v.myList != null) {
        ok(v.myList!.length, v2.myList!.length);
        for (let i = 0; i < v.myList!.length; i++) {
            ok(v.myList![i], v2.myList![i]);
        }
    }

    if (v.myDictionary != null) {
        v.myDictionary?.forEach((v, k) => {
            ok(v, v2.myDictionary?.get(k));
        });
    }

    if (v.mySet != null) {
        v.mySet?.forEach(v => {
            ok(true, v2.mySet?.has(v));
        });
    }

    ok(v.nested1?.myProperty, v2.nested1?.myProperty);
    ok(v.nested1?.myProperty2, v2.nested1?.myProperty2);

    if (v.union1 instanceof SampleUnion1 && v2.union1 instanceof SampleUnion1) {
        ok(v.union1.myProperty, v2.union1.myProperty);
    } else if (v.union1 instanceof SampleUnion2 && v2.union1 instanceof SampleUnion2) {
        ok(v.union1.myProperty, v2.union1.myProperty);
    } else {
        ok(true, false);
    }

    console.log("test passed");
}

function assertIsNull(value: any) : void
{
    if (value !== null)
        throw new Error("Invalid: value must be null.");
}

function ok(v1: any, v2: any): void {
    if (v1 === v2) return;
    throw new Error("Invalid v1:" + v1 + " v2:" + v2);
}




================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/site.js
================================================
﻿


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/AllConvertableType.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { NestedObject } from "./NestedObject.js";
import { IMogeUnion } from "./IMogeUnion.js";
export class AllConvertableType {
    myBool;
    myByte;
    mySByte;
    myShort;
    myInt;
    myLong;
    myUShort;
    myUInt;
    myULong;
    myFloat;
    myDouble;
    myGuid;
    myDate;
    myEnum1;
    myEnum2;
    nullMyBool;
    nullMyByte;
    nullMySByte;
    nullMyShort;
    nullMyInt;
    nullMyLong;
    nullMyUShort;
    nullMyUInt;
    nullMyULong;
    nullMyFloat;
    nullMyDouble;
    nullMyGuid;
    nullMyDate;
    nullMyEnum1;
    nullMyEnum2;
    myString;
    myBytes;
    myIntArray;
    myStringArray;
    myList;
    myDictionary;
    mySet;
    myNestedNested;
    dictCheck2;
    dictCheck3;
    dictCheck4X;
    nested1;
    union1;
    constructor() {
        this.myBool = false;
        this.myByte = 0;
        this.mySByte = 0;
        this.myShort = 0;
        this.myInt = 0;
        this.myLong = 0n;
        this.myUShort = 0;
        this.myUInt = 0;
        this.myULong = 0n;
        this.myFloat = 0;
        this.myDouble = 0;
        this.myGuid = "00000000-0000-0000-0000-000000000000";
        this.myDate = new Date(0);
        this.myEnum1 = 0;
        this.myEnum2 = 0;
        this.nullMyBool = null;
        this.nullMyByte = null;
        this.nullMySByte = null;
        this.nullMyShort = null;
        this.nullMyInt = null;
        this.nullMyLong = null;
        this.nullMyUShort = null;
        this.nullMyUInt = null;
        this.nullMyULong = null;
        this.nullMyFloat = null;
        this.nullMyDouble = null;
        this.nullMyGuid = null;
        this.nullMyDate = null;
        this.nullMyEnum1 = null;
        this.nullMyEnum2 = null;
        this.myString = null;
        this.myBytes = null;
        this.myIntArray = null;
        this.myStringArray = null;
        this.myList = null;
        this.myDictionary = null;
        this.mySet = null;
        this.myNestedNested = null;
        this.dictCheck2 = null;
        this.dictCheck3 = null;
        this.dictCheck4X = null;
        this.nested1 = null;
        this.union1 = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(43);
        writer.writeBoolean(value.myBool);
        writer.writeUint8(value.myByte);
        writer.writeInt8(value.mySByte);
        writer.writeInt16(value.myShort);
        writer.writeInt32(value.myInt);
        writer.writeInt64(value.myLong);
        writer.writeUint16(value.myUShort);
        writer.writeUint32(value.myUInt);
        writer.writeUint64(value.myULong);
        writer.writeFloat32(value.myFloat);
        writer.writeFloat64(value.myDouble);
        writer.writeGuid(value.myGuid);
        writer.writeDate(value.myDate);
        writer.writeUint8(value.myEnum1);
        writer.writeUint16(value.myEnum2);
        writer.writeNullableBoolean(value.nullMyBool);
        writer.writeNullableUint8(value.nullMyByte);
        writer.writeNullableInt8(value.nullMySByte);
        writer.writeNullableInt16(value.nullMyShort);
        writer.writeNullableInt32(value.nullMyInt);
        writer.writeNullableInt64(value.nullMyLong);
        writer.writeNullableUint16(value.nullMyUShort);
        writer.writeNullableUint32(value.nullMyUInt);
        writer.writeNullableUint64(value.nullMyULong);
        writer.writeNullableFloat32(value.nullMyFloat);
        writer.writeNullableFloat64(value.nullMyDouble);
        writer.writeNullableGuid(value.nullMyGuid);
        writer.writeNullableDate(value.nullMyDate);
        writer.writeNullableUint8(value.nullMyEnum1);
        writer.writeNullableUint16(value.nullMyEnum2);
        writer.writeString(value.myString);
        writer.writeUint8Array(value.myBytes);
        writer.writeArray(value.myIntArray, (writer, x) => writer.writeInt32(x));
        writer.writeArray(value.myStringArray, (writer, x) => writer.writeString(x));
        writer.writeArray(value.myList, (writer, x) => writer.writeInt32(x));
        writer.writeMap(value.myDictionary, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeInt32(x));
        writer.writeSet(value.mySet, (writer, x) => writer.writeInt32(x));
        writer.writeArray(value.myNestedNested, (writer, x) => writer.writeMap(x, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeSet(x, (writer, x) => writer.writeArray(x, (writer, x) => writer.writeString(x)))));
        writer.writeMap(value.dictCheck2, (writer, x) => writer.writeUint8(x), (writer, x) => writer.writeBoolean(x));
        writer.writeMap(value.dictCheck3, (writer, x) => writer.writeGuid(x), (writer, x) => writer.writeNullableInt32(x));
        writer.writeMap(value.dictCheck4X, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeString(x));
        NestedObject.serializeCore(writer, value.nested1);
        IMogeUnion.serializeCore(writer, value.union1);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => AllConvertableType.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new AllConvertableType();
        if (count == 43) {
            value.myBool = reader.readBoolean();
            value.myByte = reader.readUint8();
            value.mySByte = reader.readInt8();
            value.myShort = reader.readInt16();
            value.myInt = reader.readInt32();
            value.myLong = reader.readInt64();
            value.myUShort = reader.readUint16();
            value.myUInt = reader.readUint32();
            value.myULong = reader.readUint64();
            value.myFloat = reader.readFloat32();
            value.myDouble = reader.readFloat64();
            value.myGuid = reader.readGuid();
            value.myDate = reader.readDate();
            value.myEnum1 = reader.readUint8();
            value.myEnum2 = reader.readUint16();
            value.nullMyBool = reader.readNullableBoolean();
            value.nullMyByte = reader.readNullableUint8();
            value.nullMySByte = reader.readNullableInt8();
            value.nullMyShort = reader.readNullableInt16();
            value.nullMyInt = reader.readNullableInt32();
            value.nullMyLong = reader.readNullableInt64();
            value.nullMyUShort = reader.readNullableUint16();
            value.nullMyUInt = reader.readNullableUint32();
            value.nullMyULong = reader.readNullableUint64();
            value.nullMyFloat = reader.readNullableFloat32();
            value.nullMyDouble = reader.readNullableFloat64();
            value.nullMyGuid = reader.readNullableGuid();
            value.nullMyDate = reader.readNullableDate();
            value.nullMyEnum1 = reader.readNullableUint8();
            value.nullMyEnum2 = reader.readNullableUint16();
            value.myString = reader.readString();
            value.myBytes = reader.readUint8Array();
            value.myIntArray = reader.readArray(reader => reader.readInt32());
            value.myStringArray = reader.readArray(reader => reader.readString());
            value.myList = reader.readArray(reader => reader.readInt32());
            value.myDictionary = reader.readMap(reader => reader.readInt32(), reader => reader.readInt32());
            value.mySet = reader.readSet(reader => reader.readInt32());
            value.myNestedNested = reader.readArray(reader => reader.readMap(reader => reader.readInt32(), reader => reader.readSet(reader => reader.readArray(reader => reader.readString()))));
            value.dictCheck2 = reader.readMap(reader => reader.readUint8(), reader => reader.readBoolean());
            value.dictCheck3 = reader.readMap(reader => reader.readGuid(), reader => reader.readNullableInt32());
            value.dictCheck4X = reader.readMap(reader => reader.readInt32(), reader => reader.readString());
            value.nested1 = NestedObject.deserializeCore(reader);
            value.union1 = IMogeUnion.deserializeCore(reader);
        }
        else if (count > 43) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myBool = reader.readBoolean();
            if (count == 1)
                return value;
            value.myByte = reader.readUint8();
            if (count == 2)
                return value;
            value.mySByte = reader.readInt8();
            if (count == 3)
                return value;
            value.myShort = reader.readInt16();
            if (count == 4)
                return value;
            value.myInt = reader.readInt32();
            if (count == 5)
                return value;
            value.myLong = reader.readInt64();
            if (count == 6)
                return value;
            value.myUShort = reader.readUint16();
            if (count == 7)
                return value;
            value.myUInt = reader.readUint32();
            if (count == 8)
                return value;
            value.myULong = reader.readUint64();
            if (count == 9)
                return value;
            value.myFloat = reader.readFloat32();
            if (count == 10)
                return value;
            value.myDouble = reader.readFloat64();
            if (count == 11)
                return value;
            value.myGuid = reader.readGuid();
            if (count == 12)
                return value;
            value.myDate = reader.readDate();
            if (count == 13)
                return value;
            value.myEnum1 = reader.readUint8();
            if (count == 14)
                return value;
            value.myEnum2 = reader.readUint16();
            if (count == 15)
                return value;
            value.nullMyBool = reader.readNullableBoolean();
            if (count == 16)
                return value;
            value.nullMyByte = reader.readNullableUint8();
            if (count == 17)
                return value;
            value.nullMySByte = reader.readNullableInt8();
            if (count == 18)
                return value;
            value.nullMyShort = reader.readNullableInt16();
            if (count == 19)
                return value;
            value.nullMyInt = reader.readNullableInt32();
            if (count == 20)
                return value;
            value.nullMyLong = reader.readNullableInt64();
            if (count == 21)
                return value;
            value.nullMyUShort = reader.readNullableUint16();
            if (count == 22)
                return value;
            value.nullMyUInt = reader.readNullableUint32();
            if (count == 23)
                return value;
            value.nullMyULong = reader.readNullableUint64();
            if (count == 24)
                return value;
            value.nullMyFloat = reader.readNullableFloat32();
            if (count == 25)
                return value;
            value.nullMyDouble = reader.readNullableFloat64();
            if (count == 26)
                return value;
            value.nullMyGuid = reader.readNullableGuid();
            if (count == 27)
                return value;
            value.nullMyDate = reader.readNullableDate();
            if (count == 28)
                return value;
            value.nullMyEnum1 = reader.readNullableUint8();
            if (count == 29)
                return value;
            value.nullMyEnum2 = reader.readNullableUint16();
            if (count == 30)
                return value;
            value.myString = reader.readString();
            if (count == 31)
                return value;
            value.myBytes = reader.readUint8Array();
            if (count == 32)
                return value;
            value.myIntArray = reader.readArray(reader => reader.readInt32());
            if (count == 33)
                return value;
            value.myStringArray = reader.readArray(reader => reader.readString());
            if (count == 34)
                return value;
            value.myList = reader.readArray(reader => reader.readInt32());
            if (count == 35)
                return value;
            value.myDictionary = reader.readMap(reader => reader.readInt32(), reader => reader.readInt32());
            if (count == 36)
                return value;
            value.mySet = reader.readSet(reader => reader.readInt32());
            if (count == 37)
                return value;
            value.myNestedNested = reader.readArray(reader => reader.readMap(reader => reader.readInt32(), reader => reader.readSet(reader => reader.readArray(reader => reader.readString()))));
            if (count == 38)
                return value;
            value.dictCheck2 = reader.readMap(reader => reader.readUint8(), reader => reader.readBoolean());
            if (count == 39)
                return value;
            value.dictCheck3 = reader.readMap(reader => reader.readGuid(), reader => reader.readNullableInt32());
            if (count == 40)
                return value;
            value.dictCheck4X = reader.readMap(reader => reader.readInt32(), reader => reader.readString());
            if (count == 41)
                return value;
            value.nested1 = NestedObject.deserializeCore(reader);
            if (count == 42)
                return value;
            value.union1 = IMogeUnion.deserializeCore(reader);
            if (count == 43)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => AllConvertableType.deserializeCore(reader));
    }
}
//# sourceMappingURL=AllConvertableType.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/AllConvertableType.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { NoMarkByteEnum } from "./NoMarkByteEnum.js";
import { NumberedUShortEnum } from "./NumberedUShortEnum.js";
import { NestedObject } from "./NestedObject.js";
import { IMogeUnion } from "./IMogeUnion.js";

export class AllConvertableType {
    myBool: boolean;
    myByte: number;
    mySByte: number;
    myShort: number;
    myInt: number;
    myLong: bigint;
    myUShort: number;
    myUInt: number;
    myULong: bigint;
    myFloat: number;
    myDouble: number;
    myGuid: string;
    myDate: Date;
    myEnum1: NoMarkByteEnum;
    myEnum2: NumberedUShortEnum;
    nullMyBool: boolean | null;
    nullMyByte: number | null;
    nullMySByte: number | null;
    nullMyShort: number | null;
    nullMyInt: number | null;
    nullMyLong: bigint | null;
    nullMyUShort: number | null;
    nullMyUInt: number | null;
    nullMyULong: bigint | null;
    nullMyFloat: number | null;
    nullMyDouble: number | null;
    nullMyGuid: string | null;
    nullMyDate: Date | null;
    nullMyEnum1: number | null;
    nullMyEnum2: number | null;
    myString: string | null;
    myBytes: Uint8Array | null;
    myIntArray: number[] | null;
    myStringArray: (string | null)[] | null;
    myList: number[] | null;
    myDictionary: Map<number, number> | null;
    mySet: Set<number> | null;
    myNestedNested: (Map<number, Set<(string | null)[] | null> | null> | null)[] | null;
    dictCheck2: Map<NoMarkByteEnum, boolean> | null;
    dictCheck3: Map<string, number | null> | null;
    dictCheck4X: Map<number, string | null> | null;
    nested1: NestedObject | null;
    union1: IMogeUnion | null;

    constructor() {
        this.myBool = false;
        this.myByte = 0;
        this.mySByte = 0;
        this.myShort = 0;
        this.myInt = 0;
        this.myLong = 0n;
        this.myUShort = 0;
        this.myUInt = 0;
        this.myULong = 0n;
        this.myFloat = 0;
        this.myDouble = 0;
        this.myGuid = "00000000-0000-0000-0000-000000000000";
        this.myDate = new Date(0);
        this.myEnum1 = 0;
        this.myEnum2 = 0;
        this.nullMyBool = null;
        this.nullMyByte = null;
        this.nullMySByte = null;
        this.nullMyShort = null;
        this.nullMyInt = null;
        this.nullMyLong = null;
        this.nullMyUShort = null;
        this.nullMyUInt = null;
        this.nullMyULong = null;
        this.nullMyFloat = null;
        this.nullMyDouble = null;
        this.nullMyGuid = null;
        this.nullMyDate = null;
        this.nullMyEnum1 = null;
        this.nullMyEnum2 = null;
        this.myString = null;
        this.myBytes = null;
        this.myIntArray = null;
        this.myStringArray = null;
        this.myList = null;
        this.myDictionary = null;
        this.mySet = null;
        this.myNestedNested = null;
        this.dictCheck2 = null;
        this.dictCheck3 = null;
        this.dictCheck4X = null;
        this.nested1 = null;
        this.union1 = null;

    }

    static serialize(value: AllConvertableType | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: AllConvertableType | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(43);
        writer.writeBoolean(value.myBool);
        writer.writeUint8(value.myByte);
        writer.writeInt8(value.mySByte);
        writer.writeInt16(value.myShort);
        writer.writeInt32(value.myInt);
        writer.writeInt64(value.myLong);
        writer.writeUint16(value.myUShort);
        writer.writeUint32(value.myUInt);
        writer.writeUint64(value.myULong);
        writer.writeFloat32(value.myFloat);
        writer.writeFloat64(value.myDouble);
        writer.writeGuid(value.myGuid);
        writer.writeDate(value.myDate);
        writer.writeUint8(value.myEnum1);
        writer.writeUint16(value.myEnum2);
        writer.writeNullableBoolean(value.nullMyBool);
        writer.writeNullableUint8(value.nullMyByte);
        writer.writeNullableInt8(value.nullMySByte);
        writer.writeNullableInt16(value.nullMyShort);
        writer.writeNullableInt32(value.nullMyInt);
        writer.writeNullableInt64(value.nullMyLong);
        writer.writeNullableUint16(value.nullMyUShort);
        writer.writeNullableUint32(value.nullMyUInt);
        writer.writeNullableUint64(value.nullMyULong);
        writer.writeNullableFloat32(value.nullMyFloat);
        writer.writeNullableFloat64(value.nullMyDouble);
        writer.writeNullableGuid(value.nullMyGuid);
        writer.writeNullableDate(value.nullMyDate);
        writer.writeNullableUint8(value.nullMyEnum1);
        writer.writeNullableUint16(value.nullMyEnum2);
        writer.writeString(value.myString);
        writer.writeUint8Array(value.myBytes);
        writer.writeArray(value.myIntArray, (writer, x) => writer.writeInt32(x));
        writer.writeArray(value.myStringArray, (writer, x) => writer.writeString(x));
        writer.writeArray(value.myList, (writer, x) => writer.writeInt32(x));
        writer.writeMap(value.myDictionary, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeInt32(x));
        writer.writeSet(value.mySet, (writer, x) => writer.writeInt32(x));
        writer.writeArray(value.myNestedNested, (writer, x) => writer.writeMap(x, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeSet(x, (writer, x) => writer.writeArray(x, (writer, x) => writer.writeString(x)))));
        writer.writeMap(value.dictCheck2, (writer, x) => writer.writeUint8(x), (writer, x) => writer.writeBoolean(x));
        writer.writeMap(value.dictCheck3, (writer, x) => writer.writeGuid(x), (writer, x) => writer.writeNullableInt32(x));
        writer.writeMap(value.dictCheck4X, (writer, x) => writer.writeInt32(x), (writer, x) => writer.writeString(x));
        NestedObject.serializeCore(writer, value.nested1);
        IMogeUnion.serializeCore(writer, value.union1);

    }

    static serializeArray(value: (AllConvertableType | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (AllConvertableType | null)[] | null): void {
        writer.writeArray(value, (writer, x) => AllConvertableType.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): AllConvertableType | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): AllConvertableType | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new AllConvertableType();
        if (count == 43) {
            value.myBool = reader.readBoolean();
            value.myByte = reader.readUint8();
            value.mySByte = reader.readInt8();
            value.myShort = reader.readInt16();
            value.myInt = reader.readInt32();
            value.myLong = reader.readInt64();
            value.myUShort = reader.readUint16();
            value.myUInt = reader.readUint32();
            value.myULong = reader.readUint64();
            value.myFloat = reader.readFloat32();
            value.myDouble = reader.readFloat64();
            value.myGuid = reader.readGuid();
            value.myDate = reader.readDate();
            value.myEnum1 = reader.readUint8();
            value.myEnum2 = reader.readUint16();
            value.nullMyBool = reader.readNullableBoolean();
            value.nullMyByte = reader.readNullableUint8();
            value.nullMySByte = reader.readNullableInt8();
            value.nullMyShort = reader.readNullableInt16();
            value.nullMyInt = reader.readNullableInt32();
            value.nullMyLong = reader.readNullableInt64();
            value.nullMyUShort = reader.readNullableUint16();
            value.nullMyUInt = reader.readNullableUint32();
            value.nullMyULong = reader.readNullableUint64();
            value.nullMyFloat = reader.readNullableFloat32();
            value.nullMyDouble = reader.readNullableFloat64();
            value.nullMyGuid = reader.readNullableGuid();
            value.nullMyDate = reader.readNullableDate();
            value.nullMyEnum1 = reader.readNullableUint8();
            value.nullMyEnum2 = reader.readNullableUint16();
            value.myString = reader.readString();
            value.myBytes = reader.readUint8Array();
            value.myIntArray = reader.readArray(reader => reader.readInt32());
            value.myStringArray = reader.readArray(reader => reader.readString());
            value.myList = reader.readArray(reader => reader.readInt32());
            value.myDictionary = reader.readMap(reader => reader.readInt32(), reader => reader.readInt32());
            value.mySet = reader.readSet(reader => reader.readInt32());
            value.myNestedNested = reader.readArray(reader => reader.readMap(reader => reader.readInt32(), reader => reader.readSet(reader => reader.readArray(reader => reader.readString()))));
            value.dictCheck2 = reader.readMap(reader => reader.readUint8(), reader => reader.readBoolean());
            value.dictCheck3 = reader.readMap(reader => reader.readGuid(), reader => reader.readNullableInt32());
            value.dictCheck4X = reader.readMap(reader => reader.readInt32(), reader => reader.readString());
            value.nested1 = NestedObject.deserializeCore(reader);
            value.union1 = IMogeUnion.deserializeCore(reader);

        }
        else if (count > 43) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myBool = reader.readBoolean(); if (count == 1) return value;
            value.myByte = reader.readUint8(); if (count == 2) return value;
            value.mySByte = reader.readInt8(); if (count == 3) return value;
            value.myShort = reader.readInt16(); if (count == 4) return value;
            value.myInt = reader.readInt32(); if (count == 5) return value;
            value.myLong = reader.readInt64(); if (count == 6) return value;
            value.myUShort = reader.readUint16(); if (count == 7) return value;
            value.myUInt = reader.readUint32(); if (count == 8) return value;
            value.myULong = reader.readUint64(); if (count == 9) return value;
            value.myFloat = reader.readFloat32(); if (count == 10) return value;
            value.myDouble = reader.readFloat64(); if (count == 11) return value;
            value.myGuid = reader.readGuid(); if (count == 12) return value;
            value.myDate = reader.readDate(); if (count == 13) return value;
            value.myEnum1 = reader.readUint8(); if (count == 14) return value;
            value.myEnum2 = reader.readUint16(); if (count == 15) return value;
            value.nullMyBool = reader.readNullableBoolean(); if (count == 16) return value;
            value.nullMyByte = reader.readNullableUint8(); if (count == 17) return value;
            value.nullMySByte = reader.readNullableInt8(); if (count == 18) return value;
            value.nullMyShort = reader.readNullableInt16(); if (count == 19) return value;
            value.nullMyInt = reader.readNullableInt32(); if (count == 20) return value;
            value.nullMyLong = reader.readNullableInt64(); if (count == 21) return value;
            value.nullMyUShort = reader.readNullableUint16(); if (count == 22) return value;
            value.nullMyUInt = reader.readNullableUint32(); if (count == 23) return value;
            value.nullMyULong = reader.readNullableUint64(); if (count == 24) return value;
            value.nullMyFloat = reader.readNullableFloat32(); if (count == 25) return value;
            value.nullMyDouble = reader.readNullableFloat64(); if (count == 26) return value;
            value.nullMyGuid = reader.readNullableGuid(); if (count == 27) return value;
            value.nullMyDate = reader.readNullableDate(); if (count == 28) return value;
            value.nullMyEnum1 = reader.readNullableUint8(); if (count == 29) return value;
            value.nullMyEnum2 = reader.readNullableUint16(); if (count == 30) return value;
            value.myString = reader.readString(); if (count == 31) return value;
            value.myBytes = reader.readUint8Array(); if (count == 32) return value;
            value.myIntArray = reader.readArray(reader => reader.readInt32()); if (count == 33) return value;
            value.myStringArray = reader.readArray(reader => reader.readString()); if (count == 34) return value;
            value.myList = reader.readArray(reader => reader.readInt32()); if (count == 35) return value;
            value.myDictionary = reader.readMap(reader => reader.readInt32(), reader => reader.readInt32()); if (count == 36) return value;
            value.mySet = reader.readSet(reader => reader.readInt32()); if (count == 37) return value;
            value.myNestedNested = reader.readArray(reader => reader.readMap(reader => reader.readInt32(), reader => reader.readSet(reader => reader.readArray(reader => reader.readString())))); if (count == 38) return value;
            value.dictCheck2 = reader.readMap(reader => reader.readUint8(), reader => reader.readBoolean()); if (count == 39) return value;
            value.dictCheck3 = reader.readMap(reader => reader.readGuid(), reader => reader.readNullableInt32()); if (count == 40) return value;
            value.dictCheck4X = reader.readMap(reader => reader.readInt32(), reader => reader.readString()); if (count == 41) return value;
            value.nested1 = NestedObject.deserializeCore(reader); if (count == 42) return value;
            value.union1 = IMogeUnion.deserializeCore(reader); if (count == 43) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (AllConvertableType | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (AllConvertableType | null)[] | null {
        return reader.readArray(reader => AllConvertableType.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/ArrayGenericsCheck.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { NestedObject } from "./NestedObject.js";
import { IMogeUnion } from "./IMogeUnion.js";
export class ArrayGenericsCheck {
    array1;
    array2;
    list1;
    constructor() {
        this.array1 = null;
        this.array2 = null;
        this.list1 = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(3);
        writer.writeArray(value.array1, (writer, x) => NestedObject.serializeCore(writer, x));
        writer.writeArray(value.array2, (writer, x) => IMogeUnion.serializeCore(writer, x));
        writer.writeArray(value.list1, (writer, x) => writer.writeUint8(x));
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => ArrayGenericsCheck.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new ArrayGenericsCheck();
        if (count == 3) {
            value.array1 = reader.readArray(reader => NestedObject.deserializeCore(reader));
            value.array2 = reader.readArray(reader => IMogeUnion.deserializeCore(reader));
            value.list1 = reader.readArray(reader => reader.readUint8());
        }
        else if (count > 3) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.array1 = reader.readArray(reader => NestedObject.deserializeCore(reader));
            if (count == 1)
                return value;
            value.array2 = reader.readArray(reader => IMogeUnion.deserializeCore(reader));
            if (count == 2)
                return value;
            value.list1 = reader.readArray(reader => reader.readUint8());
            if (count == 3)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => ArrayGenericsCheck.deserializeCore(reader));
    }
}
//# sourceMappingURL=ArrayGenericsCheck.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/ArrayGenericsCheck.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { NoMarkByteEnum } from "./NoMarkByteEnum.js";
import { NestedObject } from "./NestedObject.js";
import { IMogeUnion } from "./IMogeUnion.js";

export class ArrayGenericsCheck {
    array1: (NestedObject | null)[] | null;
    array2: (IMogeUnion | null)[] | null;
    list1: NoMarkByteEnum[] | null;

    constructor() {
        this.array1 = null;
        this.array2 = null;
        this.list1 = null;

    }

    static serialize(value: ArrayGenericsCheck | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: ArrayGenericsCheck | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(3);
        writer.writeArray(value.array1, (writer, x) => NestedObject.serializeCore(writer, x));
        writer.writeArray(value.array2, (writer, x) => IMogeUnion.serializeCore(writer, x));
        writer.writeArray(value.list1, (writer, x) => writer.writeUint8(x));

    }

    static serializeArray(value: (ArrayGenericsCheck | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (ArrayGenericsCheck | null)[] | null): void {
        writer.writeArray(value, (writer, x) => ArrayGenericsCheck.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): ArrayGenericsCheck | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): ArrayGenericsCheck | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new ArrayGenericsCheck();
        if (count == 3) {
            value.array1 = reader.readArray(reader => NestedObject.deserializeCore(reader));
            value.array2 = reader.readArray(reader => IMogeUnion.deserializeCore(reader));
            value.list1 = reader.readArray(reader => reader.readUint8());

        }
        else if (count > 3) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.array1 = reader.readArray(reader => NestedObject.deserializeCore(reader)); if (count == 1) return value;
            value.array2 = reader.readArray(reader => IMogeUnion.deserializeCore(reader)); if (count == 2) return value;
            value.list1 = reader.readArray(reader => reader.readUint8()); if (count == 3) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (ArrayGenericsCheck | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (ArrayGenericsCheck | null)[] | null {
        return reader.readArray(reader => ArrayGenericsCheck.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/FooBarBazDayonDattayon.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class FooBarBazDayonDattayon {
    myProperty;
    constructor() {
        this.myProperty = 0;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(1);
        writer.writeInt32(value.myProperty);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => FooBarBazDayonDattayon.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new FooBarBazDayonDattayon();
        if (count == 1) {
            value.myProperty = reader.readInt32();
        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myProperty = reader.readInt32();
            if (count == 1)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => FooBarBazDayonDattayon.deserializeCore(reader));
    }
}
//# sourceMappingURL=FooBarBazDayonDattayon.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/FooBarBazDayonDattayon.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class FooBarBazDayonDattayon {
    myProperty: number;

    constructor() {
        this.myProperty = 0;

    }

    static serialize(value: FooBarBazDayonDattayon | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: FooBarBazDayonDattayon | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(1);
        writer.writeInt32(value.myProperty);

    }

    static serializeArray(value: (FooBarBazDayonDattayon | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (FooBarBazDayonDattayon | null)[] | null): void {
        writer.writeArray(value, (writer, x) => FooBarBazDayonDattayon.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): FooBarBazDayonDattayon | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): FooBarBazDayonDattayon | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new FooBarBazDayonDattayon();
        if (count == 1) {
            value.myProperty = reader.readInt32();

        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myProperty = reader.readInt32(); if (count == 1) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (FooBarBazDayonDattayon | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (FooBarBazDayonDattayon | null)[] | null {
        return reader.readArray(reader => FooBarBazDayonDattayon.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Gender.js
================================================
export {};
//# sourceMappingURL=Gender.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Gender.ts
================================================
export const enum Gender {
    Male = 0,
    Female = 1,
    Other = 2,

}


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/IMogeUnion.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { SampleUnion1 } from "./SampleUnion1.js";
import { SampleUnion2 } from "./SampleUnion2.js";
export class IMogeUnion {
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        else if (value instanceof SampleUnion1) {
            writer.writeUnionHeader(0);
            SampleUnion1.serializeCore(writer, value);
            return;
        }
        else if (value instanceof SampleUnion2) {
            writer.writeUnionHeader(1);
            SampleUnion2.serializeCore(writer, value);
            return;
        }
        else {
            throw new Error("Concrete type is not in MemoryPackUnion");
        }
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => IMogeUnion.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, tag] = reader.tryReadUnionHeader();
        if (!ok) {
            return null;
        }
        switch (tag) {
            case 0:
                return SampleUnion1.deserializeCore(reader);
            case 1:
                return SampleUnion2.deserializeCore(reader);
            default:
                throw new Error("Tag is not found in this MemoryPackUnion");
        }
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => IMogeUnion.deserializeCore(reader));
    }
}
//# sourceMappingURL=IMogeUnion.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/IMogeUnion.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

import { SampleUnion1 } from "./SampleUnion1.js"; 
import { SampleUnion2 } from "./SampleUnion2.js"; 

export abstract class IMogeUnion {
    static serialize(value: IMogeUnion | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: IMogeUnion | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        else if (value instanceof SampleUnion1) {
            writer.writeUnionHeader(0);
            SampleUnion1.serializeCore(writer, value);
            return;
        }
        else if (value instanceof SampleUnion2) {
            writer.writeUnionHeader(1);
            SampleUnion2.serializeCore(writer, value);
            return;
        }

        else {
            throw new Error("Concrete type is not in MemoryPackUnion");
        }
    }

    static serializeArray(value: IMogeUnion[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: IMogeUnion[] | null): void {
        writer.writeArray(value, (writer, x) => IMogeUnion.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): IMogeUnion | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): IMogeUnion | null {
        const [ok, tag] = reader.tryReadUnionHeader();
        if (!ok) {
            return null;
        }

        switch (tag) {
            case 0:
                return SampleUnion1.deserializeCore(reader);
            case 1:
                return SampleUnion2.deserializeCore(reader);

            default:
                throw new Error("Tag is not found in this MemoryPackUnion");
        }
    }

    static deserializeArray(buffer: ArrayBuffer): (IMogeUnion | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (IMogeUnion | null)[] | null {
        return reader.readArray(reader => IMogeUnion.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/MemoryPackReader.js
================================================
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;
// bool
const TRUE = 1;
const FALSE = 0;
// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;
// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 4611686018427387903n;
export class MemoryPackReader {
    buffer;
    dataView;
    utf8Decoder;
    utf16Decoder;
    offset;
    constructor(buffer) {
        this.buffer = buffer;
        this.dataView = new DataView(this.buffer);
        this.utf8Decoder = null;
        this.utf16Decoder = null;
        this.offset = 0;
    }
    tryReadObjectHeader() {
        const memberCount = this.readUint8();
        return (memberCount == nullObject)
            ? [false, 0]
            : [true, memberCount];
    }
    tryReadUnionHeader() {
        const tag = this.readUint8();
        if (tag < 250) {
            return [true, tag];
        }
        else if (tag == 250) {
            const tag2 = this.readUint16();
            return [true, tag2];
        }
        else {
            return [false, 0];
        }
    }
    tryReadCollectionHeader() {
        const length = this.readInt32();
        if (length == nullCollection) {
            return [false, 0];
        }
        if ((this.buffer.byteLength - this.offset) < length) {
            throw new Error("header length is too large, length: " + length);
        }
        return [true, length];
    }
    readBoolean() {
        return this.readUint8() != 0;
    }
    readNullableBoolean() {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }
        return this.readUint8() == TRUE;
    }
    readUint8() {
        const v = this.dataView.getUint8(this.offset);
        this.offset += 1;
        return v;
    }
    readNullableUint8() {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }
        return this.readUint8();
    }
    readUint16() {
        const v = this.dataView.getUint16(this.offset, true);
        this.offset += 2;
        return v;
    }
    readNullableUint16() {
        if (this.readUint16() == FALSE) {
            this.offset += 2;
            return null;
        }
        return this.readUint16();
    }
    readUint32() {
        const v = this.dataView.getUint32(this.offset, true);
        this.offset += 4;
        return v;
    }
    readNullableUint32() {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }
        return this.readUint32();
    }
    readInt8() {
        const v = this.dataView.getInt8(this.offset);
        this.offset += 1;
        return v;
    }
    readNullableInt8() {
        if (this.readInt8() == FALSE) {
            this.offset += 1;
            return null;
        }
        return this.readInt8();
    }
    readInt16() {
        const v = this.dataView.getInt16(this.offset, true);
        this.offset += 2;
        return v;
    }
    readNullableInt16() {
        if (this.readInt16() == FALSE) {
            this.offset += 2;
            return null;
        }
        return this.readInt16();
    }
    readInt32() {
        const v = this.dataView.getInt32(this.offset, true);
        this.offset += 4;
        return v;
    }
    readNullableInt32() {
        if (this.readInt32() == FALSE) {
            this.offset += 4;
            return null;
        }
        return this.readInt32();
    }
    readInt64() {
        const v = this.dataView.getBigInt64(this.offset, true);
        this.offset += 8;
        return v;
    }
    readNullableInt64() {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }
        return this.readInt64();
    }
    readUint64() {
        const v = this.dataView.getBigUint64(this.offset, true);
        this.offset += 8;
        return v;
    }
    readNullableUint64() {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }
        return this.readUint64();
    }
    readFloat32() {
        const v = this.dataView.getFloat32(this.offset, true);
        this.offset += 4;
        return v;
    }
    readNullableFloat32() {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }
        return this.readFloat32();
    }
    readFloat64() {
        const v = this.dataView.getFloat64(this.offset, true);
        this.offset += 8;
        return v;
    }
    readNullableFloat64() {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }
        return this.readFloat64();
    }
    readString() {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }
        if (length == 0) {
            return "";
        }
        if (length > 0) {
            if (this.utf16Decoder == null) {
                this.utf16Decoder = new TextDecoder("utf-16", { ignoreBOM: true, fatal: true });
            }
            const byteLength = length * 2;
            const view = new Uint8Array(this.buffer, this.offset, byteLength); // don't use slice, it makes copy
            const v = this.utf16Decoder.decode(view);
            this.offset += byteLength;
            return v;
        }
        else {
            if (this.utf8Decoder == null) {
                this.utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
            }
            // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
            const utf8Length = ~length;
            this.offset += 4; // utf16-length, no use
            const view = new Uint8Array(this.buffer, this.offset, utf8Length); // don't use slice, it makes copy
            const v = this.utf8Decoder.decode(view);
            this.offset += utf8Length;
            return v;
        }
    }
    readArray(elementReader) {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }
        const result = new Array(length);
        for (var i = 0; i < result.length; i++) {
            result[i] = elementReader(this);
        }
        return result;
    }
    readMap(keyReader, valueReader) {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }
        const result = new Map();
        for (var i = 0; i < length; i++) {
            const key = keyReader(this);
            const value = valueReader(this);
            result.set(key, value);
        }
        return result;
    }
    readSet(elementReader) {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }
        const result = new Set();
        for (var i = 0; i < length; i++) {
            result.add(elementReader(this));
        }
        return result;
    }
    readGuid() {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"
        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;
        const b1 = this.readUint8();
        const b2 = this.readUint8();
        const b3 = this.readUint8();
        const b4 = this.readUint8();
        const b5 = this.readUint8();
        const b6 = this.readUint8();
        const b7 = this.readUint8();
        const b8 = this.readUint8();
        const b9 = this.readUint8();
        const b10 = this.readUint8();
        const b11 = this.readUint8();
        const b12 = this.readUint8();
        const b13 = this.readUint8();
        const b14 = this.readUint8();
        const b15 = this.readUint8();
        const b16 = this.readUint8();
        return b4.toString(16).padStart(2, "0") + b3.toString(16).padStart(2, "0") + b2.toString(16).padStart(2, "0") + b1.toString(16).padStart(2, "0") // a
            + "-"
            + b6.toString(16).padStart(2, "0") + b5.toString(16).padStart(2, "0") // b
            + "-"
            + b8.toString(16).padStart(2, "0") + b7.toString(16).padStart(2, "0") // c
            + "-"
            + b9.toString(16).padStart(2, "0") + b10.toString(16).padStart(2, "0") // d e
            + "-"
            + b11.toString(16).padStart(2, "0") + b12.toString(16).padStart(2, "0") // f g
            + b13.toString(16).padStart(2, "0") + b14.toString(16).padStart(2, "0") // h i
            + b15.toString(16).padStart(2, "0") + b16.toString(16).padStart(2, "0"); // j k
    }
    readNullableGuid() {
        if (this.readInt32() == FALSE) {
            this.offset += 16;
            return null;
        }
        return this.readGuid();
    }
    readDate() {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const ticks = this.readUint64() & dateTimeMask;
        const unixMillisecond = (ticks - unixEpochTicks) / 10000n;
        return new Date(Number(unixMillisecond));
    }
    readNullableDate() {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }
        return this.readDate();
    }
    readUint8Array() {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }
        const span = this.buffer.slice(this.offset, this.offset + length); // slice is copy
        this.offset += length;
        return new Uint8Array(span);
    }
}
//# sourceMappingURL=MemoryPackReader.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/MemoryPackReader.ts
================================================
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;

// bool
const TRUE = 1;
const FALSE = 0;

// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;

// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 0b00111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111n;

export class MemoryPackReader {
    private buffer: ArrayBuffer
    private dataView: DataView
    private utf8Decoder: TextDecoder | null
    private utf16Decoder: TextDecoder | null
    private offset: number

    public constructor(buffer: ArrayBuffer) {
        this.buffer = buffer;
        this.dataView = new DataView(this.buffer);
        this.utf8Decoder = null;
        this.utf16Decoder = null;
        this.offset = 0;
    }

    public tryReadObjectHeader(): [boolean, number] {
        const memberCount = this.readUint8();
        return (memberCount == nullObject)
            ? [false, 0]
            : [true, memberCount];
    }

    public tryReadUnionHeader(): [boolean, number] {
        const tag = this.readUint8();
        if (tag < 250) {
            return [true, tag];
        }
        else if (tag == 250) {
            const tag2 = this.readUint16();
            return [true, tag2];
        }
        else {
            return [false, 0];
        }
    }

    public tryReadCollectionHeader(): [boolean, number] {
        const length = this.readInt32();
        if (length == nullCollection) {
            return [false, 0];
        }

        if ((this.buffer.byteLength - this.offset) < length) {
            throw new Error("header length is too large, length: " + length);
        }

        return [true, length];
    }

    public readBoolean(): boolean {
        return this.readUint8() != 0;
    }

    public readNullableBoolean(): boolean | null {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }
        return this.readUint8() == TRUE;
    }

    public readUint8(): number {
        const v = this.dataView.getUint8(this.offset);
        this.offset += 1;
        return v;
    }

    public readNullableUint8(): number | null {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }

        return this.readUint8();
    }

    public readUint16(): number {
        const v = this.dataView.getUint16(this.offset, true);
        this.offset += 2;
        return v;
    }

    public readNullableUint16(): number | null {
        if (this.readUint16() == FALSE) {
            this.offset += 2;
            return null;
        }

        return this.readUint16();
    }

    public readUint32(): number {
        const v = this.dataView.getUint32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableUint32(): number | null {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readUint32();
    }

    public readInt8(): number {
        const v = this.dataView.getInt8(this.offset);
        this.offset += 1;
        return v;
    }

    public readNullableInt8(): number | null {
        if (this.readInt8() == FALSE) {
            this.offset += 1;
            return null;
        }

        return this.readInt8();
    }

    public readInt16(): number {
        const v = this.dataView.getInt16(this.offset, true);
        this.offset += 2;
        return v;
    }

    public readNullableInt16(): number | null {
        if (this.readInt16() == FALSE) {
            this.offset += 2;
            return null;
        }

        return this.readInt16();
    }

    public readInt32(): number {
        const v = this.dataView.getInt32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableInt32(): number | null {
        if (this.readInt32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readInt32();
    }

    public readInt64(): bigint {
        const v = this.dataView.getBigInt64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableInt64(): bigint | null {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readInt64();
    }

    public readUint64(): bigint {
        const v = this.dataView.getBigUint64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableUint64(): bigint | null {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readUint64();
    }

    public readFloat32(): number {
        const v = this.dataView.getFloat32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableFloat32(): number | null {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readFloat32();
    }

    public readFloat64(): number {
        const v = this.dataView.getFloat64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableFloat64(): number | null {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readFloat64();
    }

    public readString(): string | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        if (length == 0) {
            return "";
        }

        if (length > 0) {
            if (this.utf16Decoder == null) {
                this.utf16Decoder = new TextDecoder("utf-16", { ignoreBOM: true, fatal: true });
            }

            const byteLength = length * 2;
            const view = new Uint8Array(this.buffer, this.offset, byteLength); // don't use slice, it makes copy
            const v = this.utf16Decoder.decode(view);
            this.offset += byteLength;
            return v;
        }
        else {
            if (this.utf8Decoder == null) {
                this.utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
            }

            // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
            const utf8Length = ~length;
            this.offset += 4; // utf16-length, no use

            const view = new Uint8Array(this.buffer, this.offset, utf8Length); // don't use slice, it makes copy
            const v = this.utf8Decoder.decode(view);
            this.offset += utf8Length;
            return v;
        }
    }

    public readArray<T>(elementReader: (reader: MemoryPackReader) => T): T[] | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Array<T>(length);
        for (var i = 0; i < result.length; i++) {
            result[i] = elementReader(this);
        }
        return result;
    }

    public readMap<K, V>(keyReader: (reader: MemoryPackReader) => K, valueReader: (reader: MemoryPackReader) => V): Map<K, V> | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Map<K, V>();

        for (var i = 0; i < length; i++) {
            const key = keyReader(this);
            const value = valueReader(this);
            result.set(key, value);
        }

        return result;
    }

    public readSet<T>(elementReader: (reader: MemoryPackReader) => T): Set<T> | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Set<T>();
        for (var i = 0; i < length; i++) {
            result.add(elementReader(this));
        }
        return result;
    }

    public readGuid(): string {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"

        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;

        const b1 = this.readUint8();
        const b2 = this.readUint8();
        const b3 = this.readUint8();
        const b4 = this.readUint8();
        const b5 = this.readUint8();
        const b6 = this.readUint8();
        const b7 = this.readUint8();
        const b8 = this.readUint8();
        const b9 = this.readUint8();
        const b10 = this.readUint8();
        const b11 = this.readUint8();
        const b12 = this.readUint8();
        const b13 = this.readUint8();
        const b14 = this.readUint8();
        const b15 = this.readUint8();
        const b16 = this.readUint8();

        return b4.toString(16).padStart(2, "0") + b3.toString(16).padStart(2, "0") + b2.toString(16).padStart(2, "0") + b1.toString(16).padStart(2, "0") // a
            + "-"
            + b6.toString(16).padStart(2, "0") + b5.toString(16).padStart(2, "0") // b
            + "-"
            + b8.toString(16).padStart(2, "0") + b7.toString(16).padStart(2, "0") // c
            + "-"
            + b9.toString(16).padStart(2, "0") + b10.toString(16).padStart(2, "0") // d e
            + "-"
            + b11.toString(16).padStart(2, "0") + b12.toString(16).padStart(2, "0") // f g
            + b13.toString(16).padStart(2, "0") + b14.toString(16).padStart(2, "0") // h i
            + b15.toString(16).padStart(2, "0") + b16.toString(16).padStart(2, "0"); // j k
    }

    public readNullableGuid(): string | null {
        if (this.readInt32() == FALSE) {
            this.offset += 16;
            return null;
        }

        return this.readGuid();
    }

    public readDate(): Date {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const ticks = this.readUint64() & dateTimeMask;
        const unixMillisecond = (ticks - unixEpochTicks) / 10000n;
        return new Date(Number(unixMillisecond));
    }

    public readNullableDate(): Date | null {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readDate();
    }

    public readUint8Array(): Uint8Array | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const span = this.buffer.slice(this.offset, this.offset + length); // slice is copy
        this.offset += length;
        return new Uint8Array(span);
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/MemoryPackWriter.js
================================================
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;
// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;
// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 4611686018427387903n;
export class MemoryPackWriter {
    static singletonWriter;
    static getSharedInstance() {
        if (this.singletonWriter == null) {
            this.singletonWriter = new MemoryPackWriter();
        }
        this.singletonWriter.clear();
        return this.singletonWriter;
    }
    buffer;
    dataView;
    utf8Encoder;
    offset;
    constructor(initialCapacity = 256) {
        this.buffer = new Uint8Array(initialCapacity);
        this.dataView = new DataView(this.buffer.buffer);
        this.utf8Encoder = null;
        this.offset = 0;
    }
    ensureCapacity(count) {
        if (this.buffer.length - this.offset < count) {
            var nextCapacity = this.buffer.length;
            var to = this.offset + count;
            while (nextCapacity < to) {
                nextCapacity = nextCapacity * 2;
            }
            var nextBuffer = new Uint8Array(nextCapacity);
            nextBuffer.set(this.buffer);
            this.buffer = nextBuffer;
            this.dataView = new DataView(this.buffer.buffer);
        }
    }
    clearBuffer(count) {
        this.ensureCapacity(count);
        while (count >= 4) {
            this.dataView.setUint32(this.offset, 0, true);
            this.offset += 4;
            count -= 4;
        }
        if (count >= 2) {
            this.dataView.setUint16(this.offset, 0, true);
            this.offset += 2;
            count -= 2;
        }
        if (count >= 1) {
            this.dataView.setUint8(this.offset, 0);
            this.offset += 1;
        }
    }
    writeObjectHeader(memberCount) {
        this.writeUint8(memberCount);
    }
    writeNullObjectHeader() {
        this.writeUint8(nullObject);
    }
    writeUnionHeader(tag) {
        if (tag < 250) {
            this.writeUint8(tag);
        }
        else {
            this.writeUint8(250);
            this.writeUint16(tag);
        }
    }
    writeNullUnionHeader() {
        this.writeUint8(nullObject);
    }
    writeCollectionHeader(length) {
        this.writeInt32(length);
    }
    writeNullCollectionHeader() {
        this.writeInt32(nullCollection);
    }
    writeBoolean(value) {
        this.writeUint8(value ? 1 : 0);
    }
    writeNullableBoolean(value) {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }
        this.writeNullableUint8(value ? 1 : 0);
    }
    writeUint8(value) {
        this.ensureCapacity(1);
        this.dataView.setUint8(this.offset, value);
        this.offset += 1;
    }
    writeNullableUint8(value) {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }
        this.writeUint8(1);
        this.writeUint8(value);
    }
    writeUint16(value) {
        this.ensureCapacity(2);
        this.dataView.setUint16(this.offset, value, true);
        this.offset += 2;
    }
    writeNullableUint16(value) {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }
        this.writeUint16(1);
        this.writeUint16(value);
    }
    writeUint32(value) {
        this.ensureCapacity(4);
        this.dataView.setUint32(this.offset, value, true);
        this.offset += 4;
    }
    writeNullableUint32(value) {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }
        this.writeUint32(1);
        this.writeUint32(value);
    }
    writeInt8(value) {
        this.ensureCapacity(1);
        this.dataView.setInt8(this.offset, value);
        this.offset += 1;
    }
    writeNullableInt8(value) {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }
        this.writeInt8(1);
        this.writeInt8(value);
    }
    writeInt16(value) {
        this.ensureCapacity(2);
        this.dataView.setInt16(this.offset, value, true);
        this.offset += 2;
    }
    writeNullableInt16(value) {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }
        this.writeInt16(1);
        this.writeInt16(value);
    }
    writeInt32(value) {
        this.ensureCapacity(4);
        this.dataView.setInt32(this.offset, value, true);
        this.offset += 4;
    }
    writeNullableInt32(value) {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }
        this.writeInt32(1);
        this.writeInt32(value);
    }
    writeInt64(value) {
        this.ensureCapacity(8);
        this.dataView.setBigInt64(this.offset, value, true);
        this.offset += 8;
    }
    writeNullableInt64(value) {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }
        this.writeInt64(1n);
        this.writeInt64(value);
    }
    writeUint64(value) {
        this.ensureCapacity(8);
        this.dataView.setBigUint64(this.offset, value, true);
        this.offset += 8;
    }
    writeNullableUint64(value) {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }
        this.writeUint64(1n);
        this.writeUint64(value);
    }
    writeFloat32(value) {
        this.ensureCapacity(4);
        this.dataView.setFloat32(this.offset, value, true);
        this.offset += 4;
    }
    writeNullableFloat32(value) {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }
        this.writeUint32(1);
        this.writeFloat32(value);
    }
    writeFloat64(value) {
        this.ensureCapacity(8);
        this.dataView.setFloat64(this.offset, value, true);
        this.offset += 8;
    }
    writeNullableFloat64(value) {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }
        this.writeUint64(1n);
        this.writeFloat64(value);
    }
    writeString(value) {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }
        if (value.length == 0) {
            this.writeCollectionHeader(0);
            return;
        }
        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
        this.ensureCapacity(8 + ((value.length + 1) * 3));
        if (this.utf8Encoder == null) {
            this.utf8Encoder = new TextEncoder();
        }
        var encodeResult = this.utf8Encoder.encodeInto(value, this.buffer.subarray(this.offset + 8));
        if (encodeResult.written === undefined || encodeResult.read === undefined) {
            throw new Error("failed utf8 TextEncoder.encodeInto.");
        }
        this.dataView.setInt32(this.offset, ~encodeResult.written, true);
        this.dataView.setInt32(this.offset + 4, encodeResult.read, true);
        this.offset += (encodeResult.written + 8);
    }
    writeArray(value, elementWriter) {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }
        this.writeCollectionHeader(value.length);
        var len = value.length;
        for (var i = 0; i < len; i++) {
            elementWriter(this, value[i]);
        }
    }
    writeMap(value, keyWriter, valueWriter) {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }
        this.writeCollectionHeader(value.size);
        value.forEach((v, k) => {
            keyWriter(this, k);
            valueWriter(this, v);
        });
    }
    writeSet(value, elementWriter) {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }
        this.writeCollectionHeader(value.size);
        value.forEach(x => {
            elementWriter(this, x);
        });
    }
    writeGuid(value) {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"
        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;
        const b1 = parseInt(value.slice(0, 2), 16);
        const b2 = parseInt(value.slice(2, 4), 16);
        const b3 = parseInt(value.slice(4, 6), 16);
        const b4 = parseInt(value.slice(6, 8), 16);
        const a = b1 << 24 | b2 << 16 | b3 << 8 | b4;
        const b5 = parseInt(value.slice(9, 11), 16);
        const b6 = parseInt(value.slice(11, 13), 16);
        const b = b5 << 8 | b6;
        const b7 = parseInt(value.slice(14, 16), 16);
        const b8 = parseInt(value.slice(16, 18), 16);
        const c = b7 << 8 | b8;
        const d = parseInt(value.slice(19, 21), 16);
        const e = parseInt(value.slice(21, 23), 16);
        const f = parseInt(value.slice(24, 26), 16);
        const g = parseInt(value.slice(26, 28), 16);
        const h = parseInt(value.slice(28, 30), 16);
        const i = parseInt(value.slice(30, 32), 16);
        const j = parseInt(value.slice(32, 34), 16);
        const k = parseInt(value.slice(34, 36), 16);
        this.ensureCapacity(16);
        this.dataView.setInt32(this.offset, a, true);
        this.dataView.setInt16(this.offset + 4, b, true);
        this.dataView.setInt16(this.offset + 6, c, true);
        this.dataView.setUint8(this.offset + 8, d);
        this.dataView.setUint8(this.offset + 9, e);
        this.dataView.setUint8(this.offset + 10, f);
        this.dataView.setUint8(this.offset + 11, g);
        this.dataView.setUint8(this.offset + 12, h);
        this.dataView.setUint8(this.offset + 13, i);
        this.dataView.setUint8(this.offset + 14, j);
        this.dataView.setUint8(this.offset + 15, k);
        this.offset += 16;
    }
    writeNullableGuid(value) {
        if (value == null) {
            this.clearBuffer(20);
            return;
        }
        this.writeInt32(1);
        this.writeGuid(value);
    }
    writeDate(value) {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const unixMillisecond = BigInt(value.getTime());
        const ticks = unixMillisecond * 10000n + unixEpochTicks;
        this.writeUint64(ticks & dateTimeMask);
    }
    writeNullableDate(value) {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }
        this.writeInt64(1n);
        this.writeDate(value);
    }
    writeUint8Array(value) {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }
        this.ensureCapacity(value.length + 4);
        this.dataView.setInt32(this.offset, value.length, true);
        this.buffer.set(value, this.offset + 4);
        this.offset += (value.length + 4);
    }
    clear() {
        this.offset = 0;
    }
    getSpan() {
        return this.buffer.subarray(0, this.offset);
    }
    toArray() {
        return this.buffer.slice(0, this.offset);
    }
}
//# sourceMappingURL=MemoryPackWriter.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/MemoryPackWriter.ts
================================================
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;

// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;

// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 0b00111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111n;

export class MemoryPackWriter {
    static singletonWriter: MemoryPackWriter;

    public static getSharedInstance(): MemoryPackWriter {
        if (this.singletonWriter == null) {
            this.singletonWriter = new MemoryPackWriter();
        }
        this.singletonWriter.clear();
        return this.singletonWriter;
    }

    private buffer: Uint8Array
    private dataView: DataView;
    private utf8Encoder: TextEncoder | null;
    private offset: number

    public constructor(initialCapacity: number = 256) {
        this.buffer = new Uint8Array(initialCapacity);
        this.dataView = new DataView(this.buffer.buffer);
        this.utf8Encoder = null;
        this.offset = 0;
    }

    private ensureCapacity(count: number) {
        if (this.buffer.length - this.offset < count) {
            var nextCapacity = this.buffer.length;
            var to = this.offset + count;

            while (nextCapacity < to) {
                nextCapacity = nextCapacity * 2;
            }

            var nextBuffer = new Uint8Array(nextCapacity);
            nextBuffer.set(this.buffer);

            this.buffer = nextBuffer;
            this.dataView = new DataView(this.buffer.buffer);
        }
    }

    private clearBuffer(count: number): void {
        this.ensureCapacity(count);
        while (count >= 4) {
            this.dataView.setUint32(this.offset, 0, true);
            this.offset += 4;
            count -= 4;
        }
        if (count >= 2) {
            this.dataView.setUint16(this.offset, 0, true);
            this.offset += 2;
            count -= 2;
        }
        if (count >= 1) {
            this.dataView.setUint8(this.offset, 0);
            this.offset += 1;
        }
    }

    public writeObjectHeader(memberCount: number) {
        this.writeUint8(memberCount);
    }

    public writeNullObjectHeader(): void {
        this.writeUint8(nullObject);
    }

    public writeUnionHeader(tag: number) {
        if (tag < 250) {
            this.writeUint8(tag);
        } else {
            this.writeUint8(250);
            this.writeUint16(tag);
        }
    }

    public writeNullUnionHeader(): void {
        this.writeUint8(nullObject);
    }

    public writeCollectionHeader(length: number) {
        this.writeInt32(length);
    }

    public writeNullCollectionHeader() {
        this.writeInt32(nullCollection);
    }

    public writeBoolean(value: boolean): void {
        this.writeUint8(value ? 1 : 0);
    }

    public writeNullableBoolean(value: boolean | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }
        this.writeNullableUint8(value ? 1 : 0);
    }

    public writeUint8(value: number): void {
        this.ensureCapacity(1);
        this.dataView.setUint8(this.offset, value);
        this.offset += 1;
    }

    public writeNullableUint8(value: number | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }

        this.writeUint8(1);
        this.writeUint8(value);
    }

    public writeUint16(value: number): void {
        this.ensureCapacity(2);
        this.dataView.setUint16(this.offset, value, true);
        this.offset += 2;
    }

    public writeNullableUint16(value: number | null): void {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }

        this.writeUint16(1);
        this.writeUint16(value);
    }

    public writeUint32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setUint32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableUint32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }

        this.writeUint32(1);
        this.writeUint32(value);
    }

    public writeInt8(value: number): void {
        this.ensureCapacity(1);
        this.dataView.setInt8(this.offset, value);
        this.offset += 1;
    }

    public writeNullableInt8(value: number | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }

        this.writeInt8(1);
        this.writeInt8(value);
    }

    public writeInt16(value: number): void {
        this.ensureCapacity(2);
        this.dataView.setInt16(this.offset, value, true);
        this.offset += 2;
    }

    public writeNullableInt16(value: number | null): void {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }

        this.writeInt16(1);
        this.writeInt16(value);
    }

    public writeInt32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setInt32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableInt32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }
        this.writeInt32(1);
        this.writeInt32(value);
    }

    public writeInt64(value: bigint): void {
        this.ensureCapacity(8);
        this.dataView.setBigInt64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableInt64(value: bigint | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeInt64(1n);
        this.writeInt64(value);
    }

    public writeUint64(value: bigint): void {
        this.ensureCapacity(8);
        this.dataView.setBigUint64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableUint64(value: bigint | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeUint64(1n);
        this.writeUint64(value);
    }

    public writeFloat32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setFloat32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableFloat32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }

        this.writeUint32(1);
        this.writeFloat32(value);
    }

    public writeFloat64(value: number): void {
        this.ensureCapacity(8);
        this.dataView.setFloat64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableFloat64(value: number | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeUint64(1n);
        this.writeFloat64(value);
    }

    public writeString(value: string | null): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        if (value.length == 0) {
            this.writeCollectionHeader(0);
            return;
        }

        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
        this.ensureCapacity(8 + ((value.length + 1) * 3));

        if (this.utf8Encoder == null) {
            this.utf8Encoder = new TextEncoder();
        }

        var encodeResult = this.utf8Encoder.encodeInto(value, this.buffer.subarray(this.offset + 8));
        if (encodeResult.written === undefined || encodeResult.read === undefined) {
            throw new Error("failed utf8 TextEncoder.encodeInto.");
        }
        this.dataView.setInt32(this.offset, ~encodeResult.written, true);
        this.dataView.setInt32(this.offset + 4, encodeResult.read, true);

        this.offset += (encodeResult.written + 8);
    }

    public writeArray<T>(value: ArrayLike<T> | null, elementWriter: (writer: MemoryPackWriter, element: T) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.length);
        var len = value.length;
        for (var i = 0; i < len; i++) {
            elementWriter(this, value[i]);
        }
    }

    public writeMap<K, V>(value: Map<K, V> | null, keyWriter: (writer: MemoryPackWriter, key: K) => void, valueWriter: (writer: MemoryPackWriter, value: V) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.size);
        value.forEach((v, k) => {
            keyWriter(this, k);
            valueWriter(this, v);
        });
    }

    public writeSet<T>(value: Set<T> | null, elementWriter: (writer: MemoryPackWriter, element: T) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.size);
        value.forEach(x => {
            elementWriter(this, x);
        });
    }

    public writeGuid(value: string): void {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"

        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;

        const b1 = parseInt(value.slice(0, 2), 16);
        const b2 = parseInt(value.slice(2, 4), 16);
        const b3 = parseInt(value.slice(4, 6), 16);
        const b4 = parseInt(value.slice(6, 8), 16);
        const a = b1 << 24 | b2 << 16 | b3 << 8 | b4;

        const b5 = parseInt(value.slice(9, 11), 16);
        const b6 = parseInt(value.slice(11, 13), 16);
        const b = b5 << 8 | b6;

        const b7 = parseInt(value.slice(14, 16), 16);
        const b8 = parseInt(value.slice(16, 18), 16);
        const c = b7 << 8 | b8;

        const d = parseInt(value.slice(19, 21), 16);
        const e = parseInt(value.slice(21, 23), 16);

        const f = parseInt(value.slice(24, 26), 16);
        const g = parseInt(value.slice(26, 28), 16);
        const h = parseInt(value.slice(28, 30), 16);
        const i = parseInt(value.slice(30, 32), 16);
        const j = parseInt(value.slice(32, 34), 16);
        const k = parseInt(value.slice(34, 36), 16);

        this.ensureCapacity(16);

        this.dataView.setInt32(this.offset, a, true);
        this.dataView.setInt16(this.offset + 4, b, true);
        this.dataView.setInt16(this.offset + 6, c, true);
        this.dataView.setUint8(this.offset + 8, d);
        this.dataView.setUint8(this.offset + 9, e);
        this.dataView.setUint8(this.offset + 10, f);
        this.dataView.setUint8(this.offset + 11, g);
        this.dataView.setUint8(this.offset + 12, h);
        this.dataView.setUint8(this.offset + 13, i);
        this.dataView.setUint8(this.offset + 14, j);
        this.dataView.setUint8(this.offset + 15, k);

        this.offset += 16;
    }

    public writeNullableGuid(value: string | null): void {
        if (value == null) {
            this.clearBuffer(20);
            return;
        }

        this.writeInt32(1);
        this.writeGuid(value);
    }

    public writeDate(value: Date): void {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const unixMillisecond = BigInt(value.getTime());
        const ticks = unixMillisecond * 10000n + unixEpochTicks;
        this.writeUint64(ticks & dateTimeMask);
    }

    public writeNullableDate(value: Date | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeInt64(1n);
        this.writeDate(value);
    }

    public writeUint8Array(value: Uint8Array | null): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.ensureCapacity(value.length + 4);
        this.dataView.setInt32(this.offset, value.length, true);
        this.buffer.set(value, this.offset + 4);
        this.offset += (value.length + 4);
    }

    public clear(): void {
        this.offset = 0;
    }

    public getSpan(): Uint8Array {
        return this.buffer.subarray(0, this.offset);
    }

    public toArray(): Uint8Array {
        return this.buffer.slice(0, this.offset);
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NestedObject.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class NestedObject {
    myProperty;
    myProperty2;
    constructor() {
        this.myProperty = 0;
        this.myProperty2 = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(2);
        writer.writeInt32(value.myProperty);
        writer.writeString(value.myProperty2);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => NestedObject.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new NestedObject();
        if (count == 2) {
            value.myProperty = reader.readInt32();
            value.myProperty2 = reader.readString();
        }
        else if (count > 2) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myProperty = reader.readInt32();
            if (count == 1)
                return value;
            value.myProperty2 = reader.readString();
            if (count == 2)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => NestedObject.deserializeCore(reader));
    }
}
//# sourceMappingURL=NestedObject.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NestedObject.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class NestedObject {
    myProperty: number;
    myProperty2: string | null;

    constructor() {
        this.myProperty = 0;
        this.myProperty2 = null;

    }

    static serialize(value: NestedObject | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: NestedObject | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(2);
        writer.writeInt32(value.myProperty);
        writer.writeString(value.myProperty2);

    }

    static serializeArray(value: (NestedObject | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (NestedObject | null)[] | null): void {
        writer.writeArray(value, (writer, x) => NestedObject.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): NestedObject | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): NestedObject | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new NestedObject();
        if (count == 2) {
            value.myProperty = reader.readInt32();
            value.myProperty2 = reader.readString();

        }
        else if (count > 2) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myProperty = reader.readInt32(); if (count == 1) return value;
            value.myProperty2 = reader.readString(); if (count == 2) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (NestedObject | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (NestedObject | null)[] | null {
        return reader.readArray(reader => NestedObject.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NoMarkByteEnum.js
================================================
export {};
//# sourceMappingURL=NoMarkByteEnum.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NoMarkByteEnum.ts
================================================
export const enum NoMarkByteEnum {
    Apple = 0,
    Orange = 1,
    Grape = 2,

}


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NullableFloatTest.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class NullableFloatTest {
    nullableFloat;
    nullableDouble;
    constructor() {
        this.nullableFloat = null;
        this.nullableDouble = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(2);
        writer.writeNullableFloat32(value.nullableFloat);
        writer.writeNullableFloat64(value.nullableDouble);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => NullableFloatTest.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new NullableFloatTest();
        if (count == 2) {
            value.nullableFloat = reader.readNullableFloat32();
            value.nullableDouble = reader.readNullableFloat64();
        }
        else if (count > 2) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.nullableFloat = reader.readNullableFloat32();
            if (count == 1)
                return value;
            value.nullableDouble = reader.readNullableFloat64();
            if (count == 2)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => NullableFloatTest.deserializeCore(reader));
    }
}
//# sourceMappingURL=NullableFloatTest.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NullableFloatTest.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class NullableFloatTest {
    nullableFloat: number | null;
    nullableDouble: number | null;

    constructor() {
        this.nullableFloat = null;
        this.nullableDouble = null;

    }

    static serialize(value: NullableFloatTest | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: NullableFloatTest | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(2);
        writer.writeNullableFloat32(value.nullableFloat);
        writer.writeNullableFloat64(value.nullableDouble);

    }

    static serializeArray(value: (NullableFloatTest | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (NullableFloatTest | null)[] | null): void {
        writer.writeArray(value, (writer, x) => NullableFloatTest.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): NullableFloatTest | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): NullableFloatTest | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new NullableFloatTest();
        if (count == 2) {
            value.nullableFloat = reader.readNullableFloat32();
            value.nullableDouble = reader.readNullableFloat64();

        }
        else if (count > 2) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.nullableFloat = reader.readNullableFloat32(); if (count == 1) return value;
            value.nullableDouble = reader.readNullableFloat64(); if (count == 2) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (NullableFloatTest | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (NullableFloatTest | null)[] | null {
        return reader.readArray(reader => NullableFloatTest.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NumberedUShortEnum.js
================================================
export {};
//# sourceMappingURL=NumberedUShortEnum.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/NumberedUShortEnum.ts
================================================
export const enum NumberedUShortEnum {
    Tokyo = 10,
    Chiba = 100,
    Saitama = 1000,

}


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Person.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class Person {
    id;
    age;
    firstName;
    lastName;
    dateOfBirth;
    gender;
    emails;
    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => Person.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new Person();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());
        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.id = reader.readGuid();
            if (count == 1)
                return value;
            value.age = reader.readInt32();
            if (count == 2)
                return value;
            value.firstName = reader.readString();
            if (count == 3)
                return value;
            value.lastName = reader.readString();
            if (count == 4)
                return value;
            value.dateOfBirth = reader.readDate();
            if (count == 5)
                return value;
            value.gender = reader.readInt32();
            if (count == 6)
                return value;
            value.emails = reader.readArray(reader => reader.readString());
            if (count == 7)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => Person.deserializeCore(reader));
    }
}
//# sourceMappingURL=Person.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Person.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js";

export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;

    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;

    }

    static serialize(value: Person | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));

    }

    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        writer.writeArray(value, (writer, x) => Person.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): Person | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): Person | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new Person();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());

        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.id = reader.readGuid(); if (count == 1) return value;
            value.age = reader.readInt32(); if (count == 2) return value;
            value.firstName = reader.readString(); if (count == 3) return value;
            value.lastName = reader.readString(); if (count == 4) return value;
            value.dateOfBirth = reader.readDate(); if (count == 5) return value;
            value.gender = reader.readInt32(); if (count == 6) return value;
            value.emails = reader.readArray(reader => reader.readString()); if (count == 7) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        return reader.readArray(reader => Person.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/R.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class R {
    id;
    age;
    firstName;
    lastName;
    dateOfBirth;
    gender;
    emails;
    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => R.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new R();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());
        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.id = reader.readGuid();
            if (count == 1)
                return value;
            value.age = reader.readInt32();
            if (count == 2)
                return value;
            value.firstName = reader.readString();
            if (count == 3)
                return value;
            value.lastName = reader.readString();
            if (count == 4)
                return value;
            value.dateOfBirth = reader.readDate();
            if (count == 5)
                return value;
            value.gender = reader.readInt32();
            if (count == 6)
                return value;
            value.emails = reader.readArray(reader => reader.readString());
            if (count == 7)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => R.deserializeCore(reader));
    }
}
//# sourceMappingURL=R.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/R.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; 

export class R {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;

    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;

    }

    static serialize(value: R | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: R | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));

    }

    static serializeArray(value: R[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: R[] | null): void {
        writer.writeArray(value, (writer, x) => R.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): R | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): R | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new R();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());

        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.id = reader.readGuid(); if (count == 1) return value;
            value.age = reader.readInt32(); if (count == 2) return value;
            value.firstName = reader.readString(); if (count == 3) return value;
            value.lastName = reader.readString(); if (count == 4) return value;
            value.dateOfBirth = reader.readDate(); if (count == 5) return value;
            value.gender = reader.readInt32(); if (count == 6) return value;
            value.emails = reader.readArray(reader => reader.readString()); if (count == 7) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (R | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (R | null)[] | null {
        return reader.readArray(reader => R.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Re.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class Re {
    id;
    age;
    firstName;
    lastName;
    dateOfBirth;
    gender;
    emails;
    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => Re.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new Re();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());
        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.id = reader.readGuid();
            if (count == 1)
                return value;
            value.age = reader.readInt32();
            if (count == 2)
                return value;
            value.firstName = reader.readString();
            if (count == 3)
                return value;
            value.lastName = reader.readString();
            if (count == 4)
                return value;
            value.dateOfBirth = reader.readDate();
            if (count == 5)
                return value;
            value.gender = reader.readInt32();
            if (count == 6)
                return value;
            value.emails = reader.readArray(reader => reader.readString());
            if (count == 7)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => Re.deserializeCore(reader));
    }
}
//# sourceMappingURL=Re.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Re.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; 

export class Re {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;

    constructor() {
        this.id = "00000000-0000-0000-0000-000000000000";
        this.age = 0;
        this.firstName = null;
        this.lastName = null;
        this.dateOfBirth = new Date(0);
        this.gender = 0;
        this.emails = null;

    }

    static serialize(value: Re | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: Re | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(7);
        writer.writeGuid(value.id);
        writer.writeInt32(value.age);
        writer.writeString(value.firstName);
        writer.writeString(value.lastName);
        writer.writeDate(value.dateOfBirth);
        writer.writeInt32(value.gender);
        writer.writeArray(value.emails, (writer, x) => writer.writeString(x));

    }

    static serializeArray(value: Re[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: Re[] | null): void {
        writer.writeArray(value, (writer, x) => Re.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): Re | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): Re | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new Re();
        if (count == 7) {
            value.id = reader.readGuid();
            value.age = reader.readInt32();
            value.firstName = reader.readString();
            value.lastName = reader.readString();
            value.dateOfBirth = reader.readDate();
            value.gender = reader.readInt32();
            value.emails = reader.readArray(reader => reader.readString());

        }
        else if (count > 7) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.id = reader.readGuid(); if (count == 1) return value;
            value.age = reader.readInt32(); if (count == 2) return value;
            value.firstName = reader.readString(); if (count == 3) return value;
            value.lastName = reader.readString(); if (count == 4) return value;
            value.dateOfBirth = reader.readDate(); if (count == 5) return value;
            value.gender = reader.readInt32(); if (count == 6) return value;
            value.emails = reader.readArray(reader => reader.readString()); if (count == 7) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (Re | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Re | null)[] | null {
        return reader.readArray(reader => Re.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Rec.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class Rec {
    id;
    constructor() {
        this.id = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(1);
        Rec.serializeCore(writer, value.id);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => Rec.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new Rec();
        if (count == 1) {
            value.id = Rec.deserializeCore(reader);
        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.id = Rec.deserializeCore(reader);
            if (count == 1)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => Rec.deserializeCore(reader));
    }
}
//# sourceMappingURL=Rec.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Rec.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class Rec {
    id: Rec | null;

    constructor() {
        this.id = null;

    }

    static serialize(value: Rec | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: Rec | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(1);
        Rec.serializeCore(writer, value.id);

    }

    static serializeArray(value: (Rec | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (Rec | null)[] | null): void {
        writer.writeArray(value, (writer, x) => Rec.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): Rec | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): Rec | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new Rec();
        if (count == 1) {
            value.id = Rec.deserializeCore(reader);

        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.id = Rec.deserializeCore(reader); if (count == 1) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (Rec | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Rec | null)[] | null {
        return reader.readArray(reader => Rec.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleLarge.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class SampleLarge {
    _id;
    author;
    created_at;
    description;
    image;
    keywords;
    language;
    permalink;
    published;
    title;
    updated_at;
    url;
    constructor() {
        this._id = null;
        this.author = null;
        this.created_at = null;
        this.description = null;
        this.image = null;
        this.keywords = null;
        this.language = null;
        this.permalink = null;
        this.published = false;
        this.title = null;
        this.updated_at = null;
        this.url = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(12);
        writer.writeString(value._id);
        writer.writeString(value.author);
        writer.writeString(value.created_at);
        writer.writeString(value.description);
        writer.writeString(value.image);
        writer.writeArray(value.keywords, (writer, x) => writer.writeString(x));
        writer.writeString(value.language);
        writer.writeString(value.permalink);
        writer.writeBoolean(value.published);
        writer.writeString(value.title);
        writer.writeString(value.updated_at);
        writer.writeString(value.url);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => SampleLarge.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new SampleLarge();
        if (count == 12) {
            value._id = reader.readString();
            value.author = reader.readString();
            value.created_at = reader.readString();
            value.description = reader.readString();
            value.image = reader.readString();
            value.keywords = reader.readArray(reader => reader.readString());
            value.language = reader.readString();
            value.permalink = reader.readString();
            value.published = reader.readBoolean();
            value.title = reader.readString();
            value.updated_at = reader.readString();
            value.url = reader.readString();
        }
        else if (count > 12) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value._id = reader.readString();
            if (count == 1)
                return value;
            value.author = reader.readString();
            if (count == 2)
                return value;
            value.created_at = reader.readString();
            if (count == 3)
                return value;
            value.description = reader.readString();
            if (count == 4)
                return value;
            value.image = reader.readString();
            if (count == 5)
                return value;
            value.keywords = reader.readArray(reader => reader.readString());
            if (count == 6)
                return value;
            value.language = reader.readString();
            if (count == 7)
                return value;
            value.permalink = reader.readString();
            if (count == 8)
                return value;
            value.published = reader.readBoolean();
            if (count == 9)
                return value;
            value.title = reader.readString();
            if (count == 10)
                return value;
            value.updated_at = reader.readString();
            if (count == 11)
                return value;
            value.url = reader.readString();
            if (count == 12)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => SampleLarge.deserializeCore(reader));
    }
}
//# sourceMappingURL=SampleLarge.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleLarge.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class SampleLarge {
    _id: string | null;
    author: string | null;
    created_at: string | null;
    description: string | null;
    image: string | null;
    keywords: (string | null)[] | null;
    language: string | null;
    permalink: string | null;
    published: boolean;
    title: string | null;
    updated_at: string | null;
    url: string | null;

    constructor() {
        this._id = null;
        this.author = null;
        this.created_at = null;
        this.description = null;
        this.image = null;
        this.keywords = null;
        this.language = null;
        this.permalink = null;
        this.published = false;
        this.title = null;
        this.updated_at = null;
        this.url = null;

    }

    static serialize(value: SampleLarge | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: SampleLarge | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(12);
        writer.writeString(value._id);
        writer.writeString(value.author);
        writer.writeString(value.created_at);
        writer.writeString(value.description);
        writer.writeString(value.image);
        writer.writeArray(value.keywords, (writer, x) => writer.writeString(x));
        writer.writeString(value.language);
        writer.writeString(value.permalink);
        writer.writeBoolean(value.published);
        writer.writeString(value.title);
        writer.writeString(value.updated_at);
        writer.writeString(value.url);

    }

    static serializeArray(value: (SampleLarge | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (SampleLarge | null)[] | null): void {
        writer.writeArray(value, (writer, x) => SampleLarge.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): SampleLarge | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): SampleLarge | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new SampleLarge();
        if (count == 12) {
            value._id = reader.readString();
            value.author = reader.readString();
            value.created_at = reader.readString();
            value.description = reader.readString();
            value.image = reader.readString();
            value.keywords = reader.readArray(reader => reader.readString());
            value.language = reader.readString();
            value.permalink = reader.readString();
            value.published = reader.readBoolean();
            value.title = reader.readString();
            value.updated_at = reader.readString();
            value.url = reader.readString();

        }
        else if (count > 12) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value._id = reader.readString(); if (count == 1) return value;
            value.author = reader.readString(); if (count == 2) return value;
            value.created_at = reader.readString(); if (count == 3) return value;
            value.description = reader.readString(); if (count == 4) return value;
            value.image = reader.readString(); if (count == 5) return value;
            value.keywords = reader.readArray(reader => reader.readString()); if (count == 6) return value;
            value.language = reader.readString(); if (count == 7) return value;
            value.permalink = reader.readString(); if (count == 8) return value;
            value.published = reader.readBoolean(); if (count == 9) return value;
            value.title = reader.readString(); if (count == 10) return value;
            value.updated_at = reader.readString(); if (count == 11) return value;
            value.url = reader.readString(); if (count == 12) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (SampleLarge | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (SampleLarge | null)[] | null {
        return reader.readArray(reader => SampleLarge.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleUnion1.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class SampleUnion1 {
    myProperty;
    constructor() {
        this.myProperty = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(1);
        writer.writeNullableInt32(value.myProperty);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => SampleUnion1.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new SampleUnion1();
        if (count == 1) {
            value.myProperty = reader.readNullableInt32();
        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myProperty = reader.readNullableInt32();
            if (count == 1)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => SampleUnion1.deserializeCore(reader));
    }
}
//# sourceMappingURL=SampleUnion1.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleUnion1.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { IMogeUnion } from "./IMogeUnion.js";

export class SampleUnion1 implements IMogeUnion {
    myProperty: number | null;

    constructor() {
        this.myProperty = null;

    }

    static serialize(value: SampleUnion1 | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: SampleUnion1 | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(1);
        writer.writeNullableInt32(value.myProperty);

    }

    static serializeArray(value: (SampleUnion1 | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (SampleUnion1 | null)[] | null): void {
        writer.writeArray(value, (writer, x) => SampleUnion1.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): SampleUnion1 | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): SampleUnion1 | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new SampleUnion1();
        if (count == 1) {
            value.myProperty = reader.readNullableInt32();

        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myProperty = reader.readNullableInt32(); if (count == 1) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (SampleUnion1 | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (SampleUnion1 | null)[] | null {
        return reader.readArray(reader => SampleUnion1.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleUnion2.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class SampleUnion2 {
    myProperty;
    constructor() {
        this.myProperty = null;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(1);
        writer.writeString(value.myProperty);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => SampleUnion2.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new SampleUnion2();
        if (count == 1) {
            value.myProperty = reader.readString();
        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myProperty = reader.readString();
            if (count == 1)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => SampleUnion2.deserializeCore(reader));
    }
}
//# sourceMappingURL=SampleUnion2.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/SampleUnion2.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { IMogeUnion } from "./IMogeUnion.js";

export class SampleUnion2 implements IMogeUnion {
    myProperty: string | null;

    constructor() {
        this.myProperty = null;

    }

    static serialize(value: SampleUnion2 | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: SampleUnion2 | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(1);
        writer.writeString(value.myProperty);

    }

    static serializeArray(value: (SampleUnion2 | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (SampleUnion2 | null)[] | null): void {
        writer.writeArray(value, (writer, x) => SampleUnion2.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): SampleUnion2 | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): SampleUnion2 | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new SampleUnion2();
        if (count == 1) {
            value.myProperty = reader.readString();

        }
        else if (count > 1) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myProperty = reader.readString(); if (count == 1) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (SampleUnion2 | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (SampleUnion2 | null)[] | null {
        return reader.readArray(reader => SampleUnion2.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Subset.js
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
export class Subset {
    myBool;
    myByte;
    mySByte;
    myShort;
    constructor() {
        this.myBool = false;
        this.myByte = 0;
        this.mySByte = 0;
        this.myShort = 0;
    }
    static serialize(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }
    static serializeCore(writer, value) {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
        writer.writeObjectHeader(4);
        writer.writeBoolean(value.myBool);
        writer.writeUint8(value.myByte);
        writer.writeInt8(value.mySByte);
        writer.writeInt16(value.myShort);
    }
    static serializeArray(value) {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }
    static serializeArrayCore(writer, value) {
        writer.writeArray(value, (writer, x) => Subset.serializeCore(writer, x));
    }
    static deserialize(buffer) {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }
    static deserializeCore(reader) {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }
        const value = new Subset();
        if (count == 4) {
            value.myBool = reader.readBoolean();
            value.myByte = reader.readUint8();
            value.mySByte = reader.readInt8();
            value.myShort = reader.readInt16();
        }
        else if (count > 4) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0)
                return value;
            value.myBool = reader.readBoolean();
            if (count == 1)
                return value;
            value.myByte = reader.readUint8();
            if (count == 2)
                return value;
            value.mySByte = reader.readInt8();
            if (count == 3)
                return value;
            value.myShort = reader.readInt16();
            if (count == 4)
                return value;
        }
        return value;
    }
    static deserializeArray(buffer) {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }
    static deserializeArrayCore(reader) {
        return reader.readArray(reader => Subset.deserializeCore(reader));
    }
}
//# sourceMappingURL=Subset.js.map


================================================
FILE: sandbox/SandboxWebApp/wwwroot/js/memorypack/Subset.ts
================================================
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";

export class Subset {
    myBool: boolean;
    myByte: number;
    mySByte: number;
    myShort: number;

    constructor() {
        this.myBool = false;
        this.myByte = 0;
        this.mySByte = 0;
        this.myShort = 0;

    }

    static serialize(value: Subset | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: Subset | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

        writer.writeObjectHeader(4);
        writer.writeBoolean(value.myBool);
        writer.writeUint8(value.myByte);
        writer.writeInt8(value.mySByte);
        writer.writeInt16(value.myShort);

    }

    static serializeArray(value: (Subset | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (Subset | null)[] | null): void {
        writer.writeArray(value, (writer, x) => Subset.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): Subset | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): Subset | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new Subset();
        if (count == 4) {
            value.myBool = reader.readBoolean();
            value.myByte = reader.readUint8();
            value.mySByte = reader.readInt8();
            value.myShort = reader.readInt16();

        }
        else if (count > 4) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
            if (count == 0) return value;
            value.myBool = reader.readBoolean(); if (count == 1) return value;
            value.myByte = reader.readUint8(); if (count == 2) return value;
            value.mySByte = reader.readInt8(); if (count == 3) return value;
            value.myShort = reader.readInt16(); if (count == 4) return value;

        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): (Subset | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Subset | null)[] | null {
        return reader.readArray(reader => Subset.deserializeCore(reader));
    }
}



================================================
FILE: sandbox/SandboxWebApp/wwwroot/lib/bootstrap/LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2011-2021 Twitter, Inc.
Copyright (c) 2011-2021 The Bootstrap Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



================================================
FILE: sandbox/SandboxWebApp/wwwroot/lib/jquery/LICENSE.txt
================================================

Copyright OpenJS Foundation and other contributors, https://openjsf.org/

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


================================================
FILE: sandbox/SandboxWebApp/wwwroot/lib/jquery-validation/LICENSE.md
================================================
The MIT License (MIT)
=====================

Copyright Jörn Zaefferer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



================================================
FILE: sandbox/SandboxWebApp/wwwroot/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.js
================================================
/**
 * @license
 * Unobtrusive validation support library for jQuery and jQuery Validate
 * Copyright (c) .NET Foundation. All rights reserved.
 * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
 * @version v4.0.0
 */

/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: false */
/*global document: false, jQuery: false */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define("jquery.validate.unobtrusive", ['jquery-validation'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS-like environments that support module.exports     
        module.exports = factory(require('jquery-validation'));
    } else {
        // Browser global
        jQuery.validator.unobtrusive = factory(jQuery);
    }
}(function ($) {
    var $jQval = $.validator,
        adapters,
        data_validation = "unobtrusiveValidation";

    function setValidationValues(options, ruleName, value) {
        options.rules[ruleName] = value;
        if (options.message) {
            options.messages[ruleName] = options.message;
        }
    }

    function splitAndTrim(value) {
        return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
    }

    function escapeAttributeValue(value) {
        // As mentioned on http://api.jquery.com/category/selectors/
        return value.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g, "\\$1");
    }

    function getModelPrefix(fieldName) {
        return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
    }

    function appendModelPrefix(value, prefix) {
        if (value.indexOf("*.") === 0) {
            value = value.replace("*.", prefix);
        }
        return value;
    }

    function onError(error, inputElement) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-for='" + escapeAttributeValue(inputElement[0].name) + "']"),
            replaceAttrValue = container.attr("data-valmsg-replace"),
            replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) !== false : null;

        container.removeClass("field-validation-valid").addClass("field-validation-error");
        error.data("unobtrusiveContainer", container);

        if (replace) {
            container.empty();
            error.removeClass("input-validation-error").appendTo(container);
        }
        else {
            error.hide();
        }
    }

    function onErrors(event, validator) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-summary=true]"),
            list = container.find("ul");

        if (list && list.length && validator.errorList.length) {
            list.empty();
            container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

            $.each(validator.errorList, function () {
                $("<li />").html(this.message).appendTo(list);
            });
        }
    }

    function onSuccess(error) {  // 'this' is the form element
        var container = error.data("unobtrusiveContainer");

        if (container) {
            var replaceAttrValue = container.attr("data-valmsg-replace"),
                replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) : null;

            container.addClass("field-validation-valid").removeClass("field-validation-error");
            error.removeData("unobtrusiveContainer");

            if (replace) {
                container.empty();
            }
        }
    }

    function onReset(event) {  // 'this' is the form element
        var $form = $(this),
            key = '__jquery_unobtrusive_validation_form_reset';
        if ($form.data(key)) {
            return;
        }
        // Set a flag that indicates we're currently resetting the form.
        $form.data(key, true);
        try {
            $form.data("validator").resetForm();
        } finally {
            $form.removeData(key);
        }

        $form.find(".validation-summary-errors")
            .addClass("validation-summary-valid")
            .removeClass("validation-summary-errors");
        $form.find(".field-validation-error")
            .addClass("field-validation-valid")
            .removeClass("field-validation-error")
            .removeData("unobtrusiveContainer")
            .find(">*")  // If we were using valmsg-replace, get the underlying error
            .removeData("unobtrusiveContainer");
    }

    function validationInfo(form) {
        var $form = $(form),
            result = $form.data(data_validation),
            onResetProxy = $.proxy(onReset, form),
            defaultOptions = $jQval.unobtrusive.options || {},
            execInContext = function (name, args) {
                var func = defaultOptions[name];
                func && $.isFunction(func) && func.apply(form, args);
            };

        if (!result) {
            result = {
                options: {  // options structure passed to jQuery Validate's validate() method
                    errorClass: defaultOptions.errorClass || "input-validation-error",
                    errorElement: defaultOptions.errorElement || "span",
                    errorPlacement: function () {
                        onError.apply(form, arguments);
                        execInContext("errorPlacement", arguments);
                    },
                    invalidHandler: function () {
                        onErrors.apply(form, arguments);
                        execInContext("invalidHandler", arguments);
                    },
                    messages: {},
                    rules: {},
                    success: function () {
                        onSuccess.apply(form, arguments);
                        execInContext("success", arguments);
                    }
                },
                attachValidation: function () {
                    $form
                        .off("reset." + data_validation, onResetProxy)
                        .on("reset." + data_validation, onResetProxy)
                        .validate(this.options);
                },
                validate: function () {  // a validation function that is called by unobtrusive Ajax
                    $form.validate();
                    return $form.valid();
                }
            };
            $form.data(data_validation, result);
        }

        return result;
    }

    $jQval.unobtrusive = {
        adapters: [],

        parseElement: function (element, skipAttach) {
            /// <summary>
            /// Parses a single HTML element for unobtrusive validation attributes.
            /// </summary>
            /// <param name="element" domElement="true">The HTML element to be parsed.</param>
            /// <param name="skipAttach" type="Boolean">[Optional] true to skip attaching the
            /// validation to the form. If parsing just this single element, you should specify true.
            /// If parsing several elements, you should specify false, and manually attach the validation
            /// to the form when you are finished. The default is false.</param>
            var $element = $(element),
                form = $element.parents("form")[0],
                valInfo, rules, messages;

            if (!form) {  // Cannot do client-side validation without a form
                return;
            }

            valInfo = validationInfo(form);
            valInfo.options.rules[element.name] = rules = {};
            valInfo.options.messages[element.name] = messages = {};

            $.each(this.adapters, function () {
                var prefix = "data-val-" + this.name,
                    message = $element.attr(prefix),
                    paramValues = {};

                if (message !== undefined) {  // Compare against undefined, because an empty message is legal (and falsy)
                    prefix += "-";

                    $.each(this.params, function () {
                        paramValues[this] = $element.attr(prefix + this);
                    });

                    this.adapt({
                        element: element,
                        form: form,
                        message: message,
                        params: paramValues,
                        rules: rules,
                        messages: messages
                    });
                }
            });

            $.extend(rules, { "__dummy__": true });

            if (!skipAttach) {
                valInfo.attachValidation();
            }
        },

        parse: function (selector) {
            /// <summary>
            /// Parses all the HTML elements in the specified selector. It looks for input elements decorated
            /// with the [data-val=true] attribute value and enables validation according to the data-val-*
            /// attribute values.
            /// </summary>
            /// <param name="selector" type="String">Any valid jQuery selector.</param>

            // $forms includes all forms in selector's DOM hierarchy (parent, children and self) that have at least one
            // element with data-val=true
            var $selector = $(selector),
                $forms = $selector.parents()
                    .addBack()
                    .filter("form")
                    .add($selector.find("form"))
                    .has("[data-val=true]");

            $selector.find("[data-val=true]").each(function () {
                $jQval.unobtrusive.parseElement(this, true);
            });

            $forms.each(function () {
                var info = validationInfo(this);
                if (info) {
                    info.attachValidation();
                }
            });
        }
    };

    adapters = $jQval.unobtrusive.adapters;

    adapters.add = function (adapterName, params, fn) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="params" type="Array" optional="true">[Optional] An array of parameter names (strings) that will
        /// be extracted from the data-val-nnnn-mmmm HTML attributes (where nnnn is the adapter name, and
        /// mmmm is the parameter name).</param>
        /// <param name="fn" type="Function">The function to call, which adapts the values from the HTML
        /// attributes into jQuery Validate rules and/or messages.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        if (!fn) {  // Called with no params, just a function
            fn = params;
            params = [];
        }
        this.push({ name: adapterName, params: params, adapt: fn });
        return this;
    };

    adapters.addBool = function (adapterName, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has no parameter values.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, function (options) {
            setValidationValues(options, ruleName || adapterName, true);
        });
    };

    adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation has three potential rules (one for min-only, one for max-only, and
        /// one for min-and-max). The HTML parameters are expected to be named -min and -max.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="minRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a minimum value.</param>
        /// <param name="maxRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a maximum value.</param>
        /// <param name="minMaxRuleName" type="String">The name of the jQuery Validate rule to be used when you
        /// have both a minimum and maximum value.</param>
        /// <param name="minAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the minimum value. The default is "min".</param>
        /// <param name="maxAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the maximum value. The default is "max".</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
            var min = options.params.min,
                max = options.params.max;

            if (min && max) {
                setValidationValues(options, minMaxRuleName, [min, max]);
            }
            else if (min) {
                setValidationValues(options, minRuleName, min);
            }
            else if (max) {
                setValidationValues(options, maxRuleName, max);
            }
        });
    };

    adapters.addSingleVal = function (adapterName, attribute, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has a single value.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute(where nnnn is the adapter name).</param>
        /// <param name="attribute" type="String">[Optional] The name of the HTML attribute that contains the value.
        /// The default is "val".</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [attribute || "val"], function (options) {
            setValidationValues(options, ruleName || adapterName, options.params[attribute]);
        });
    };

    $jQval.addMethod("__dummy__", function (value, element, params) {
        return true;
    });

    $jQval.addMethod("regex", function (value, element, params) {
        var match;
        if (this.optional(element)) {
            return true;
        }

        match = new RegExp(params).exec(value);
        return (match && (match.index === 0) && (match[0].length === value.length));
    });

    $jQval.addMethod("nonalphamin", function (value, element, nonalphamin) {
        var match;
        if (nonalphamin) {
            match = value.match(/\W/g);
            match = match && match.length >= nonalphamin;
        }
        return match;
    });

    if ($jQval.methods.extension) {
        adapters.addSingleVal("accept", "mimtype");
        adapters.addSingleVal("extension", "extension");
    } else {
        // for backward compatibility, when the 'extension' validation method does not exist, such as with versions
        // of JQuery Validation plugin prior to 1.10, we should use the 'accept' method for
        // validating the extension, and ignore mime-type validations as they are not supported.
        adapters.addSingleVal("extension", "extension", "accept");
    }

    adapters.addSingleVal("regex", "pattern");
    adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
    adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
    adapters.addMinMax("minlength", "minlength").addMinMax("maxlength", "minlength", "maxlength");
    adapters.add("equalto", ["other"], function (options) {
        var prefix = getModelPrefix(options.element.name),
            other = options.params.other,
            fullOtherName = appendModelPrefix(other, prefix),
            element = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(fullOtherName) + "']")[0];

        setValidationValues(options, "equalTo", element);
    });
    adapters.add("required", function (options) {
        // jQuery Validate equates "required" with "mandatory" for checkbox elements
        if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
            setValidationValues(options, "required", true);
        }
    });
    adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
        var value = {
            url: options.params.url,
            type: options.params.type || "GET",
            data: {}
        },
            prefix = getModelPrefix(options.element.name);

        $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
            var paramName = appendModelPrefix(fieldName, prefix);
            value.data[paramName] = function () {
                var field = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(paramName) + "']");
                // For checkboxes and radio buttons, only pick up values from checked fields.
                if (field.is(":checkbox")) {
                    return field.filter(":checked").val() || field.filter(":hidden").val() || '';
                }
                else if (field.is(":radio")) {
                    return field.filter(":checked").val() || '';
                }
                return field.val();
            };
        });

        setValidationValues(options, "remote", value);
    });
    adapters.add("password", ["min", "nonalphamin", "regex"], function (options) {
        if (options.params.min) {
            setValidationValues(options, "minlength", options.params.min);
        }
        if (options.params.nonalphamin) {
            setValidationValues(options, "nonalphamin", options.params.nonalphamin);
        }
        if (options.params.regex) {
            setValidationValues(options, "regex", options.params.regex);
        }
    });
    adapters.add("fileextensions", ["extensions"], function (options) {
        setValidationValues(options, "extension", options.params.extensions);
    });

    $(function () {
        $jQval.unobtrusive.parse(document);
    });

    return $jQval.unobtrusive;
}));



================================================
FILE: sandbox/SandboxWebApp/wwwroot/lib/jquery-validation-unobtrusive/LICENSE.txt
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/MemoryPack/MemoryPack.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net7.0;net8.0;netstandard2.1</TargetFrameworks>
        <!-- This project is meta package -->
        <IncludeBuildOutput>false</IncludeBuildOutput>
        <IncludeContentInPack>true</IncludeContentInPack>
        <NoWarn>$(NoWarn);NU5128</NoWarn>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <PackageTags>serializer</PackageTags>
        <Description>Zero encoding extreme performance binary serializer for C#.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\MemoryPack.Generator\MemoryPack.Generator.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/MemoryPack.AspNetCoreMvcFormatter/MediaTypeHeaderValues.cs
================================================
﻿using Microsoft.Net.Http.Headers;

namespace MemoryPack.AspNetCoreMvcFormatter;

public static class MediaTypeHeaderValues
{
    public static readonly MediaTypeHeaderValue ApplicationMemoryPack =
        MediaTypeHeaderValue.Parse("application/x-memorypack");
}



================================================
FILE: src/MemoryPack.AspNetCoreMvcFormatter/MemoryPack.AspNetCoreMvcFormatter.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFrameworks>net7.0;net6.0</TargetFrameworks>
        <OutputType>Library</OutputType>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <Description>ASP.NET Input/Output Formatter of MemoryPack.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\MemoryPack.Core\MemoryPack.Core.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/MemoryPack.AspNetCoreMvcFormatter/MemoryPackInputFormatter.cs
================================================
﻿using Microsoft.AspNetCore.Mvc.Formatters;

namespace MemoryPack.AspNetCoreMvcFormatter;

public class MemoryPackInputFormatter : InputFormatter
{
    public MemoryPackInputFormatter()
    {
        SupportedMediaTypes.Add(MediaTypeHeaderValues.ApplicationMemoryPack);
    }

    public override async Task<InputFormatterResult> ReadRequestBodyAsync(InputFormatterContext context)
    {
        var request = context.HttpContext.Request;
        var result = await MemoryPackSerializer.DeserializeAsync(context.ModelType, request.Body, cancellationToken: context.HttpContext.RequestAborted).ConfigureAwait(false);
        return await InputFormatterResult.SuccessAsync(result).ConfigureAwait(false);
    }
}



================================================
FILE: src/MemoryPack.AspNetCoreMvcFormatter/MemoryPackOutputFormatter.cs
================================================
﻿using System.Net.Mime;
using Microsoft.AspNetCore.Mvc.Formatters;

namespace MemoryPack.AspNetCoreMvcFormatter;

public class MemoryPackOutputFormatter : OutputFormatter
{
    readonly MemoryPackSerializerOptions? options;
    readonly bool checkContentType = false;

    public MemoryPackOutputFormatter(bool checkContentType = false)
        : this(null!)
    {
        this.checkContentType = checkContentType;
    }

    public MemoryPackOutputFormatter(MemoryPackSerializerOptions options)
    {
        this.options = options;
        SupportedMediaTypes.Add(MediaTypeHeaderValues.ApplicationMemoryPack);
    }

    public override bool CanWriteResult(OutputFormatterCanWriteContext context)
    {
        if (checkContentType)
        {
            return MediaTypeHeaderValues.ApplicationMemoryPack.MatchesMediaType(context.ContentType);
        }
        else
        {
            return true;
        }
    }

    public override Task WriteResponseBodyAsync(OutputFormatterWriteContext context)
    {
        context.ContentType = MediaTypeHeaderValues.ApplicationMemoryPack.MediaType;

        if (context.Object == null)
        {
            var writer = context.HttpContext.Response.BodyWriter;
            var span = writer.GetSpan(1);
            span[0] = MemoryPackCode.NullObject;
            writer.Advance(1);
            return writer.FlushAsync().AsTask();
        }
        else
        {
            var objectType = (context.ObjectType == null || context.ObjectType == typeof(object))
                ? context.Object.GetType()
                : context.ObjectType;

            var writer = context.HttpContext.Response.BodyWriter;
            MemoryPackSerializer.Serialize(objectType, writer, context.Object, this.options);
            return writer.FlushAsync().AsTask();
        }
    }
}



================================================
FILE: src/MemoryPack.AspNetCoreMvcFormatter/Properties/launchSettings.json
================================================
{
  "profiles": {
    "MemoryPack.AspNetCoreMvcFormatter": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:50975;http://localhost:50976"
    }
  }
}


================================================
FILE: src/MemoryPack.Core/Attributes.cs
================================================
﻿namespace MemoryPack;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackableAttribute : Attribute
{
    public GenerateType GenerateType { get; }
    public SerializeLayout SerializeLayout { get; }

    // ctor parameter is parsed in MemoryPackGenerator.Parser TypeMeta for detect which ctor used in MemoryPack.Generator.
    // if modify ctor, be careful.

    /// <summary>
    /// [generateType, (VersionTolerant or CircularReference) ? SerializeLayout.Explicit : SerializeLayout.Sequential]
    /// </summary>
    /// <param name="generateType"></param>
    public MemoryPackableAttribute(GenerateType generateType = GenerateType.Object)
    {
        this.GenerateType = generateType;
        this.SerializeLayout = (generateType == GenerateType.VersionTolerant || generateType == GenerateType.CircularReference)
            ? SerializeLayout.Explicit
            : SerializeLayout.Sequential;
    }

    /// <summary>
    /// [GenerateType.Object, serializeLayout]
    /// </summary>
    public MemoryPackableAttribute(SerializeLayout serializeLayout)
    {
        this.GenerateType = GenerateType.Object;
        this.SerializeLayout = serializeLayout;
    }

    public MemoryPackableAttribute(GenerateType generateType, SerializeLayout serializeLayout)
    {
        this.GenerateType = generateType;
        this.SerializeLayout = serializeLayout;
    }
}

public enum GenerateType
{
    Object,
    VersionTolerant,
    CircularReference,
    Collection,
    NoGenerate
}

public enum SerializeLayout
{
    Sequential, // default
    Explicit
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
public sealed class MemoryPackUnionAttribute : Attribute
{
    public ushort Tag { get; }
    public Type Type { get; }

    public MemoryPackUnionAttribute(ushort tag, Type type)
    {
        this.Tag = tag;
        this.Type = type;
    }
}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackUnionFormatterAttribute : Attribute
{
    public Type Type { get; }

    public MemoryPackUnionFormatterAttribute(Type type)
    {
        this.Type = type;
    }
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackAllowSerializeAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackOrderAttribute : Attribute
{
    public int Order { get; }

    public MemoryPackOrderAttribute(int order)
    {
        this.Order = order;
    }
}

#if !UNITY_2021_2_OR_NEWER

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<TFormatter, T> : Attribute
    where TFormatter : IMemoryPackFormatter<T>
{
    public abstract TFormatter GetFormatter();
}

#endif

// similar naming as System.Text.Json attribtues
// https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonattribute

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackIgnoreAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackIncludeAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackConstructorAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackOnSerializingAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackOnSerializedAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackOnDeserializingAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public sealed class MemoryPackOnDeserializedAttribute : Attribute
{
}

// Others

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
public sealed class GenerateTypeScriptAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public sealed class SuppressDefaultInitializationAttribute : Attribute;



================================================
FILE: src/MemoryPack.Core/CustomFormatterAttributes.cs
================================================
﻿using MemoryPack.Compression;
using MemoryPack.Formatters;

namespace MemoryPack;

#if !UNITY_2021_2_OR_NEWER

public sealed class Utf8StringFormatterAttribute : MemoryPackCustomFormatterAttribute<Utf8StringFormatter, string>
{
    public override Utf8StringFormatter GetFormatter()
    {
        return Utf8StringFormatter.Default;
    }
}

public sealed class Utf16StringFormatterAttribute : MemoryPackCustomFormatterAttribute<Utf16StringFormatter, string>
{
    public override Utf16StringFormatter GetFormatter()
    {
        return Utf16StringFormatter.Default;
    }
}

public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<DictionaryFormatter<string, TValue?>, Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);

    public override DictionaryFormatter<string, TValue?> GetFormatter()
    {
        return formatter;
    }
}

public sealed class InternStringFormatterAttribute : MemoryPackCustomFormatterAttribute<InternStringFormatter, string>
{
    public override InternStringFormatter GetFormatter()
    {
        return InternStringFormatter.Default;
    }
}

public sealed class BitPackFormatterAttribute : MemoryPackCustomFormatterAttribute<BitPackFormatter, bool[]>
{
    public override BitPackFormatter GetFormatter()
    {
        return BitPackFormatter.Default;
    }
}

public sealed class BrotliFormatterAttribute : MemoryPackCustomFormatterAttribute<BrotliFormatter, byte[]>
{
    public System.IO.Compression.CompressionLevel CompressionLevel { get; }
    public int Window { get; }
    public int DecompressionSizeLimit { get; }

    public BrotliFormatterAttribute(System.IO.Compression.CompressionLevel compressionLevel = System.IO.Compression.CompressionLevel.Fastest, int window = BrotliUtils.WindowBits_Default, int decompressionSizeLimit = BrotliFormatter.DefaultDecompssionSizeLimit)
    {
        this.CompressionLevel = compressionLevel;
        this.Window = window;
        this.DecompressionSizeLimit = decompressionSizeLimit;
    }

    public override BrotliFormatter GetFormatter()
    {
        return new BrotliFormatter(CompressionLevel, Window, DecompressionSizeLimit);
    }
}

public sealed class BrotliFormatterAttribute<T> : MemoryPackCustomFormatterAttribute<BrotliFormatter<T>, T>
{
    public System.IO.Compression.CompressionLevel CompressionLevel { get; }
    public int Window { get; }

    public BrotliFormatterAttribute(System.IO.Compression.CompressionLevel compressionLevel = System.IO.Compression.CompressionLevel.Fastest, int window = BrotliUtils.WindowBits_Default)
    {
        this.CompressionLevel = compressionLevel;
        this.Window = window;
    }

    public override BrotliFormatter<T> GetFormatter()
    {
        return new BrotliFormatter<T>(CompressionLevel, Window);
    }
}

public sealed class BrotliStringFormatterAttribute : MemoryPackCustomFormatterAttribute<BrotliStringFormatter, string>
{
    public System.IO.Compression.CompressionLevel CompressionLevel { get; }
    public int Window { get; }
    public int DecompressionSizeLimit { get; }

    public BrotliStringFormatterAttribute(System.IO.Compression.CompressionLevel compressionLevel = System.IO.Compression.CompressionLevel.Fastest, int window = BrotliUtils.WindowBits_Default, int decompressionSizeLimit = BrotliFormatter.DefaultDecompssionSizeLimit)
    {
        this.CompressionLevel = compressionLevel;
        this.Window = window;
        this.DecompressionSizeLimit = decompressionSizeLimit;
    }

    public override BrotliStringFormatter GetFormatter()
    {
        return new BrotliStringFormatter(CompressionLevel, Window, DecompressionSizeLimit);
    }
}

public sealed class MemoryPoolFormatterAttribute<T> : MemoryPackCustomFormatterAttribute<MemoryPoolFormatter<T>, Memory<T?>>
{
    static readonly MemoryPoolFormatter<T> formatter = new MemoryPoolFormatter<T>();

    public override MemoryPoolFormatter<T> GetFormatter()
    {
        return formatter;
    }
}

public sealed class ReadOnlyMemoryPoolFormatterAttribute<T> : MemoryPackCustomFormatterAttribute<ReadOnlyMemoryPoolFormatter<T>, ReadOnlyMemory<T?>>
{
    static readonly ReadOnlyMemoryPoolFormatter<T> formatter = new ReadOnlyMemoryPoolFormatter<T>();

    public override ReadOnlyMemoryPoolFormatter<T> GetFormatter()
    {
        return formatter;
    }
}

#endif



================================================
FILE: src/MemoryPack.Core/IMemoryPackable.cs
================================================
﻿using System.Buffers;

namespace MemoryPack;

#if NET7_0_OR_GREATER

public interface IFixedSizeMemoryPackable
{
    static abstract int Size { get; }
}

#endif

public interface IMemoryPackFormatterRegister
{
#if NET7_0_OR_GREATER
    static abstract void RegisterFormatter();
#endif
}

public interface IMemoryPackable<T> : IMemoryPackFormatterRegister
{
    // note: serialize parameter should be `ref readonly` but current lang spec can not.
    // see proposal https://github.com/dotnet/csharplang/issues/6010

#if NET7_0_OR_GREATER
    static abstract void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
        where TBufferWriter : IBufferWriter<byte>;
    static abstract void Deserialize(ref MemoryPackReader reader, scoped ref T? value);
#endif
}



================================================
FILE: src/MemoryPack.Core/IMemoryPackFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;

namespace MemoryPack;

[Preserve]
public interface IMemoryPackFormatter
{
    [Preserve]
    void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref object? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>;
#else
        where TBufferWriter : class, IBufferWriter<byte>;
#endif
    [Preserve]
    void Deserialize(ref MemoryPackReader reader, scoped ref object? value);
}

[Preserve]
public interface IMemoryPackFormatter<T>
{
    [Preserve]
    void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>;
#else
        where TBufferWriter : class, IBufferWriter<byte>;
#endif
    [Preserve]
    void Deserialize(ref MemoryPackReader reader, scoped ref T? value);
}

[Preserve]
public abstract class MemoryPackFormatter<T> : IMemoryPackFormatter<T>, IMemoryPackFormatter
{
    [Preserve]
    public abstract void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>;
#else
        where TBufferWriter : class, IBufferWriter<byte>;
#endif
    [Preserve]
    public abstract void Deserialize(ref MemoryPackReader reader, scoped ref T? value);

    [Preserve]
    void IMemoryPackFormatter.Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref object? value)
    {
        var v = (value == null)
            ? default(T?)
            : (T?)value;
        Serialize(ref writer, ref v);
    }

    [Preserve]
    void IMemoryPackFormatter.Deserialize(ref MemoryPackReader reader, scoped ref object? value)
    {
        var v = (value == null)
            ? default(T?)
            : (T?)value;
        Deserialize(ref reader, ref v);
        value = v;
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPack.Core.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net7.0;net8.0;netstandard2.1</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
        <RootNamespace>MemoryPack</RootNamespace>
        <NoWarn>$(NoWarn);CS1591;CA2255</NoWarn>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <PackageTags>serializer</PackageTags>
        <Description>Core libraries(attribute, logics) of MemoryPack.</Description>
    </PropertyGroup>

    <ItemGroup>
        <InternalsVisibleTo Include="MemoryPack.Streaming, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee" />
    </ItemGroup>

    <ItemGroup Condition="$(TargetFramework) == 'netstandard2.1'">
        <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
        <PackageReference Include="System.Collections.Immutable" Version="6.0.0" />
    </ItemGroup>

    <ItemGroup>
        <None Update="Formatters\TupleFormatter.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>TupleFormatter.cs</LastGenOutput>
        </None>
        <None Update="MemoryPackFormatterProvider.WellknownTypes.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>MemoryPackFormatterProvider.WellknownTypes.cs</LastGenOutput>
        </None>
        <None Update="MemoryPackReader.Unmanaged.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>MemoryPackReader.Unmanaged.cs</LastGenOutput>
        </None>
        <None Update="MemoryPackWriter.Unmanaged.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>MemoryPackWriter.Unmanaged.cs</LastGenOutput>
        </None>
    </ItemGroup>

    <ItemGroup>
        <Service Include="{508349b6-6b84-4df5-91f0-309beebad82d}" />
    </ItemGroup>

    <ItemGroup>
        <Compile Update="Formatters\TupleFormatter.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>TupleFormatter.tt</DependentUpon>
        </Compile>
        <Compile Update="MemoryPackFormatterProvider.WellknownTypes.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>MemoryPackFormatterProvider.WellknownTypes.tt</DependentUpon>
        </Compile>
        <Compile Update="MemoryPackReader.Unmanaged.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>MemoryPackReader.Unmanaged.tt</DependentUpon>
        </Compile>
        <Compile Update="MemoryPackWriter.Unmanaged.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>MemoryPackWriter.Unmanaged.tt</DependentUpon>
        </Compile>
    </ItemGroup>

</Project>



================================================
FILE: src/MemoryPack.Core/MemoryPackCode.cs
================================================
﻿namespace MemoryPack;

public static class MemoryPackCode
{
    // Collection Header
    // 0~* is length, -1 is null
    public const int NullCollection = -1;

    // Object/Union Header
    // 0~249 is member count or tag, 250~254 is unused, 255 is null
    public const byte WideTag = 250; // for Union, 250 is wide tag
    public const byte ReferenceId = 250; // for CircularReference, 250 is referenceId marker, next VarInt id reference.

    public const byte Reserved1 = 250;
    public const byte Reserved2 = 251;
    public const byte Reserved3 = 252;
    public const byte Reserved4 = 253;
    public const byte Reserved5 = 254;
    public const byte NullObject = 255;

    // predefined, C# compiler optimize byte[] as ReadOnlySpan<byte> property
    internal static ReadOnlySpan<byte> NullCollectionData => new byte[] { 255, 255, 255, 255 }; // -1
    internal static ReadOnlySpan<byte> ZeroCollectionData => new byte[] { 0, 0, 0, 0 }; // 0
}



================================================
FILE: src/MemoryPack.Core/MemoryPackFormatterProvider.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;

namespace MemoryPack;

// This service provider is not extension point, for wellknown types
// and fallback if can't resolve in compile time(like generics).
// Therefore, unlike MessagePack for C#, it is static and not extensible.

public static partial class MemoryPackFormatterProvider
{
    // for nongenerics methods
    static readonly ConcurrentDictionary<Type, IMemoryPackFormatter> formatters = new ConcurrentDictionary<Type, IMemoryPackFormatter>(Environment.ProcessorCount, 150);

    // custom generic formatters
    static readonly ConcurrentDictionary<Type, Type> genericFormatterFactory = new ConcurrentDictionary<Type, Type>();

    // custom generic collection formatters
    static readonly ConcurrentDictionary<Type, Type> genericCollectionFormatterFactory = new ConcurrentDictionary<Type, Type>();

    // generics known types
    static readonly Dictionary<Type, Type> KnownGenericTypeFormatters = new Dictionary<Type, Type>(3)
    {
        { typeof(KeyValuePair<,>), typeof(KeyValuePairFormatter<,>) },
        { typeof(Lazy<>), typeof(LazyFormatter<>) },
        { typeof(Nullable<>), typeof(NullableFormatter<>) },
    };

    static partial void RegisterInitialFormatters();

    static MemoryPackFormatterProvider()
    {
        // Initialize on startup
        RegisterWellKnownTypesFormatters();
        // Extension for Unity or others
        RegisterInitialFormatters();
    }

    public static bool IsRegistered<T>() => Check<T>.registered;

    public static void Register<T>(MemoryPackFormatter<T> formatter)
    {
        Check<T>.registered = true; // avoid to call Cache() constructor called.
        formatters[typeof(T)] = formatter;
        Cache<T>.formatter = formatter;
    }

#if NET7_0_OR_GREATER

    public static void Register<T>()
        where T : IMemoryPackFormatterRegister
    {
        T.RegisterFormatter();
    }

#endif

    public static void RegisterGenericType(Type genericType, Type genericFormatterType)
    {
        if (genericType.IsGenericType && genericFormatterType.IsGenericType)
        {
            genericFormatterFactory[genericType] = genericFormatterType;
        }
        else
        {
            MemoryPackSerializationException.ThrowMessage($"Registered type is not generic type. genericType:{genericType.FullName}, formatterType:{genericFormatterType.FullName}");
        }
    }

    public static void RegisterCollection<TCollection, TElement>()
        where TCollection : ICollection<TElement?>, new()
    {
        Register(new GenericCollectionFormatter<TCollection, TElement>());
    }

    public static void RegisterCollection(Type genericCollectionType)
    {
        if (genericCollectionType.IsGenericType && genericCollectionType.GetGenericArguments().Length == 1)
        {
            genericCollectionFormatterFactory[genericCollectionType] = typeof(GenericCollectionFormatter<,>);
        }
        else
        {
            MemoryPackSerializationException.ThrowMessage($"Registered generic collection is not filled generic formatter constraint. type: {genericCollectionType.FullName}");
        }
    }

    public static void RegisterSet<TSet, TElement>()
        where TSet : ISet<TElement?>, new()
    {
        Register(new GenericSetFormatter<TSet, TElement>());
    }

    public static void RegisterSet(Type genericSetType)
    {
        if (genericSetType.IsGenericType && genericSetType.GetGenericArguments().Length == 1)
        {
            genericCollectionFormatterFactory[genericSetType] = typeof(GenericSetFormatter<,>);
        }
        else
        {
            MemoryPackSerializationException.ThrowMessage($"Registered generic set is not filled generic formatter constraint. type: {genericSetType.FullName}");
        }
    }

    public static void RegisterDictionary<TDictionary, TKey, TValue>()
            where TKey : notnull
            where TDictionary : IDictionary<TKey, TValue?>, new()
    {
        Register(new GenericDictionaryFormatter<TDictionary, TKey, TValue>());
    }

    public static void RegisterDictionary(Type genericDictionaryType)
    {
        if (genericDictionaryType.IsGenericType && genericDictionaryType.GetGenericArguments().Length == 2)
        {
            genericCollectionFormatterFactory[genericDictionaryType] = typeof(GenericDictionaryFormatter<,,>);
        }
        else
        {
            MemoryPackSerializationException.ThrowMessage($"Registered generic collection is not filled generic formatter constraint. type: {genericDictionaryType.FullName}");
        }
    }

    // almostly get from Writer/Reader
    // in future, will change static provider to instance provider.

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static MemoryPackFormatter<T> GetFormatter<T>()
    {
        return Cache<T>.formatter;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IMemoryPackFormatter GetFormatter(Type type)
    {
        if (formatters.TryGetValue(type, out var formatter))
        {
            return formatter;
        }

        if (TryInvokeRegisterFormatter(type))
        {
            // try again
            if (formatters.TryGetValue(type, out formatter))
            {
                return formatter;
            }
        }

        if (TypeHelpers.IsAnonymous(type))
        {
            formatter = new ErrorMemoryPackFormatter(type, "Serialize anonymous type is not supported, use record or tuple instead.");
            goto END;
        }

        // non registered, try to create generic formatter
        // can not detect IsReferenceOrContainsReference but it only uses array type select so safe).
        var formatter2 = CreateGenericFormatter(type, typeIsReferenceOrContainsReferences: true) as IMemoryPackFormatter;
        if (formatter2 == null)
        {
            formatter2 = new ErrorMemoryPackFormatter(type);
        }
        formatter = formatter2;

    END:
        formatters[type] = formatter;
        return formatter;
    }

    static bool TryInvokeRegisterFormatter(Type type)
    {
        if (typeof(IMemoryPackFormatterRegister).IsAssignableFrom(type))
        {
            // currently C# can not call like `if (T is IMemoryPackFormatterRegister) T.RegisterFormatter()`, so use reflection instead.
            var m = type.GetMethod("MemoryPack.IMemoryPackFormatterRegister.RegisterFormatter", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
            if (m == null)
            {
                // Roslyn3.11 generator generate public static method
                m = type.GetMethod("RegisterFormatter", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
            }
            if (m == null)
            {
                throw new InvalidOperationException("Type implements IMemoryPackFormatterRegister but can not found RegisterFormatter. Type: " + type.FullName);
            }
            m!.Invoke(null, null); // Cache<T>.formatter will set from method
            return true;
        }

        return false;
    }

    static class Check<T>
    {
        public static bool registered;
    }

    static class Cache<T>
    {
        public static MemoryPackFormatter<T> formatter = default!;

        static Cache()
        {
            if (Check<T>.registered) return;

            try
            {
                var type = typeof(T);
                if (TryInvokeRegisterFormatter(type))
                {
                    return;
                }

                if (TypeHelpers.IsAnonymous(type))
                {
                    formatter = new ErrorMemoryPackFormatter<T>("Serialize anonymous type is not supported, use record or tuple instead.");
                    goto END;
                }

                var typeIsReferenceOrContainsReferences = RuntimeHelpers.IsReferenceOrContainsReferences<T>();
                var f = CreateGenericFormatter(type, typeIsReferenceOrContainsReferences) as MemoryPackFormatter<T>;

                formatter = f ?? new ErrorMemoryPackFormatter<T>();
            }
            catch (Exception ex)
            {
                formatter = new ErrorMemoryPackFormatter<T>(ex);
            }

        END:
            formatters[typeof(T)] = formatter;
            Check<T>.registered = true;
        }
    }

    internal static object? CreateGenericFormatter(Type type, bool typeIsReferenceOrContainsReferences)
    {
        Type? formatterType = null;

        if (type.IsArray)
        {
            if (type.IsSZArray)
            {
                if (!typeIsReferenceOrContainsReferences)
                {
                    formatterType = typeof(DangerousUnmanagedArrayFormatter<>).MakeGenericType(type.GetElementType()!);
                    goto CREATE;
                }
                else
                {
                    formatterType = typeof(ArrayFormatter<>).MakeGenericType(type.GetElementType()!);
                    goto CREATE;
                }
            }
            else
            {
                var rank = type.GetArrayRank();
                switch (rank)
                {
                    case 2:
                        formatterType = typeof(TwoDimensionalArrayFormatter<>).MakeGenericType(type.GetElementType()!);
                        goto CREATE;
                    case 3:
                        formatterType = typeof(ThreeDimensionalArrayFormatter<>).MakeGenericType(type.GetElementType()!);
                        goto CREATE;
                    case 4:
                        formatterType = typeof(FourDimensionalArrayFormatter<>).MakeGenericType(type.GetElementType()!);
                        goto CREATE;
                    default:
                        return null; // not supported
                }
            }
        }

        if (type.IsEnum || !typeIsReferenceOrContainsReferences)
        {
            formatterType = typeof(DangerousUnmanagedFormatter<>).MakeGenericType(type);
            goto CREATE;
        }

        formatterType = TryCreateGenericFormatterType(type, TupleFormatterTypes.TupleFormatters);
        if (formatterType != null) goto CREATE;

        formatterType = TryCreateGenericFormatterType(type, KnownGenericTypeFormatters);
        if (formatterType != null) goto CREATE;

        formatterType = TryCreateGenericFormatterType(type, ArrayLikeFormatters);
        if (formatterType != null) goto CREATE;

        formatterType = TryCreateGenericFormatterType(type, CollectionFormatters);
        if (formatterType != null) goto CREATE;

#if !UNITY_2021_2_OR_NEWER
        formatterType = TryCreateGenericFormatterType(type, ImmutableCollectionFormatters);
        if (formatterType != null) goto CREATE;
#endif

#if NET8_0_OR_GREATER
        formatterType = TryCreateGenericFormatterType(type, FrozenCollectionFormatters);
        if (formatterType != null) goto CREATE;
#endif

        formatterType = TryCreateGenericFormatterType(type, InterfaceCollectionFormatters);
        if (formatterType != null) goto CREATE;

        // finally custom generated
        formatterType = TryCreateGenericFormatterType(type, genericFormatterFactory);
        if (formatterType != null) goto CREATE;

        // genericCollectionFormatterFactory
        formatterType = TryCreateGenericCollectionFormatterType(type);
        if (formatterType != null) goto CREATE;

        // Can't resolve formatter, return null(will create ErrorMemoryPackFormatter<T>).
        return null;

    CREATE:
        return Activator.CreateInstance(formatterType);
    }

    static Type? TryCreateGenericFormatterType(Type type, IDictionary<Type, Type> knownTypes)
    {
        if (type.IsGenericType)
        {
            var genericDefinition = type.GetGenericTypeDefinition();

            if (knownTypes.TryGetValue(genericDefinition, out var formatterType))
            {
                return formatterType.MakeGenericType(type.GetGenericArguments());
            }
        }

        return null;
    }

    static Type? TryCreateGenericCollectionFormatterType(Type type)
    {
        if (type.IsGenericType && genericCollectionFormatterFactory.TryGetValue(type, out var formatterType))
        {
            var genericDefinition = type.GetGenericTypeDefinition();
            var elementTypes = genericDefinition.GetGenericArguments();

            // formatterType is <TCollection, TArgs> so concat type at first
            return formatterType.MakeGenericType(elementTypes.Prepend(type).ToArray());
        }

        return null;
    }
}

internal sealed class ErrorMemoryPackFormatter : IMemoryPackFormatter
{
    readonly Type type;
    readonly string? message;

    public ErrorMemoryPackFormatter(Type type)
    {
        this.type = type;
        this.message = null;
    }

    public ErrorMemoryPackFormatter(Type type, string message)
    {
        this.type = type;
        this.message = message;
    }

    public void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref object? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        Throw();
    }

    public void Deserialize(ref MemoryPackReader reader, scoped ref object? value)
    {
        Throw();
    }

    [DoesNotReturn]
    void Throw()
    {
        if (message != null)
        {
            MemoryPackSerializationException.ThrowMessage(message);
        }
        else
        {
            MemoryPackSerializationException.ThrowNotRegisteredInProvider(type);
        }
    }
}

internal sealed class ErrorMemoryPackFormatter<T> : MemoryPackFormatter<T>
{
    readonly Exception? exception;
    readonly string? message;

    public ErrorMemoryPackFormatter()
    {
        this.exception = null;
        this.message = null;
    }

    public ErrorMemoryPackFormatter(Exception exception)
    {
        this.exception = exception;
        this.message = null;
    }

    public ErrorMemoryPackFormatter(string message)
    {
        this.exception = null;
        this.message = message;
    }

    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        Throw();
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        Throw();
    }

    [DoesNotReturn]
    void Throw()
    {
        if (exception != null)
        {
            MemoryPackSerializationException.ThrowRegisterInProviderFailed(typeof(T), exception);
        }
        else if (message != null)
        {
            MemoryPackSerializationException.ThrowMessage(message);
        }
        else
        {
            MemoryPackSerializationException.ThrowNotRegisteredInProvider(typeof(T));
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackFormatterProvider.WellknownTypes.cs
================================================
﻿using MemoryPack.Formatters;
using System.Collections;
using System.Globalization;
using System.Text;
using System.Numerics;

namespace MemoryPack;

public static partial class MemoryPackFormatterProvider
{
    internal static void RegisterWellKnownTypesFormatters()
    {
        Register(new UnmanagedFormatter<SByte>());
        Register(new UnmanagedArrayFormatter<SByte>());
        Register(new NullableFormatter<SByte>());
        Register(new UnmanagedFormatter<Byte>());
        Register(new UnmanagedArrayFormatter<Byte>());
        Register(new NullableFormatter<Byte>());
        Register(new UnmanagedFormatter<Int16>());
        Register(new UnmanagedArrayFormatter<Int16>());
        Register(new NullableFormatter<Int16>());
        Register(new UnmanagedFormatter<UInt16>());
        Register(new UnmanagedArrayFormatter<UInt16>());
        Register(new NullableFormatter<UInt16>());
        Register(new UnmanagedFormatter<Int32>());
        Register(new UnmanagedArrayFormatter<Int32>());
        Register(new NullableFormatter<Int32>());
        Register(new UnmanagedFormatter<UInt32>());
        Register(new UnmanagedArrayFormatter<UInt32>());
        Register(new NullableFormatter<UInt32>());
        Register(new UnmanagedFormatter<Int64>());
        Register(new UnmanagedArrayFormatter<Int64>());
        Register(new NullableFormatter<Int64>());
        Register(new UnmanagedFormatter<UInt64>());
        Register(new UnmanagedArrayFormatter<UInt64>());
        Register(new NullableFormatter<UInt64>());
        Register(new UnmanagedFormatter<Char>());
        Register(new UnmanagedArrayFormatter<Char>());
        Register(new NullableFormatter<Char>());
        Register(new UnmanagedFormatter<Single>());
        Register(new UnmanagedArrayFormatter<Single>());
        Register(new NullableFormatter<Single>());
        Register(new UnmanagedFormatter<Double>());
        Register(new UnmanagedArrayFormatter<Double>());
        Register(new NullableFormatter<Double>());
        Register(new UnmanagedFormatter<Decimal>());
        Register(new UnmanagedArrayFormatter<Decimal>());
        Register(new NullableFormatter<Decimal>());
        Register(new UnmanagedFormatter<Boolean>());
        Register(new UnmanagedArrayFormatter<Boolean>());
        Register(new NullableFormatter<Boolean>());
        Register(new UnmanagedFormatter<IntPtr>());
        Register(new UnmanagedArrayFormatter<IntPtr>());
        Register(new NullableFormatter<IntPtr>());
        Register(new UnmanagedFormatter<UIntPtr>());
        Register(new UnmanagedArrayFormatter<UIntPtr>());
        Register(new NullableFormatter<UIntPtr>());
        Register(new UnmanagedFormatter<DateTime>());
        Register(new UnmanagedArrayFormatter<DateTime>());
        Register(new NullableFormatter<DateTime>());
        Register(new UnmanagedFormatter<DateTimeOffset>());
        Register(new UnmanagedArrayFormatter<DateTimeOffset>());
        Register(new NullableFormatter<DateTimeOffset>());
        Register(new UnmanagedFormatter<TimeSpan>());
        Register(new UnmanagedArrayFormatter<TimeSpan>());
        Register(new NullableFormatter<TimeSpan>());
        Register(new UnmanagedFormatter<Guid>());
        Register(new UnmanagedArrayFormatter<Guid>());
        Register(new NullableFormatter<Guid>());
        Register(new UnmanagedFormatter<Complex>());
        Register(new UnmanagedArrayFormatter<Complex>());
        Register(new NullableFormatter<Complex>());
        Register(new UnmanagedFormatter<Plane>());
        Register(new UnmanagedArrayFormatter<Plane>());
        Register(new NullableFormatter<Plane>());
        Register(new UnmanagedFormatter<Quaternion>());
        Register(new UnmanagedArrayFormatter<Quaternion>());
        Register(new NullableFormatter<Quaternion>());
        Register(new UnmanagedFormatter<Matrix3x2>());
        Register(new UnmanagedArrayFormatter<Matrix3x2>());
        Register(new NullableFormatter<Matrix3x2>());
        Register(new UnmanagedFormatter<Matrix4x4>());
        Register(new UnmanagedArrayFormatter<Matrix4x4>());
        Register(new NullableFormatter<Matrix4x4>());
        Register(new UnmanagedFormatter<Vector2>());
        Register(new UnmanagedArrayFormatter<Vector2>());
        Register(new NullableFormatter<Vector2>());
        Register(new UnmanagedFormatter<Vector3>());
        Register(new UnmanagedArrayFormatter<Vector3>());
        Register(new NullableFormatter<Vector3>());
        Register(new UnmanagedFormatter<Vector4>());
        Register(new UnmanagedArrayFormatter<Vector4>());
        Register(new NullableFormatter<Vector4>());
#if NET7_0_OR_GREATER
        Register(new UnmanagedFormatter<Rune>());
        Register(new UnmanagedArrayFormatter<Rune>());
        Register(new NullableFormatter<Rune>());
        Register(new UnmanagedFormatter<DateOnly>());
        Register(new UnmanagedArrayFormatter<DateOnly>());
        Register(new NullableFormatter<DateOnly>());
        Register(new UnmanagedFormatter<TimeOnly>());
        Register(new UnmanagedArrayFormatter<TimeOnly>());
        Register(new NullableFormatter<TimeOnly>());
        Register(new UnmanagedFormatter<Half>());
        Register(new UnmanagedArrayFormatter<Half>());
        Register(new NullableFormatter<Half>());
        Register(new UnmanagedFormatter<Int128>());
        Register(new UnmanagedArrayFormatter<Int128>());
        Register(new NullableFormatter<Int128>());
        Register(new UnmanagedFormatter<UInt128>());
        Register(new UnmanagedArrayFormatter<UInt128>());
        Register(new NullableFormatter<UInt128>());
#endif
        Register(new StringFormatter());
        Register(new ArrayFormatter<String>());
        Register(new VersionFormatter());
        Register(new ArrayFormatter<Version>());
        Register(new UriFormatter());
        Register(new ArrayFormatter<Uri>());
        Register(new TimeZoneInfoFormatter());
        Register(new ArrayFormatter<TimeZoneInfo>());
        Register(new BigIntegerFormatter());
        Register(new ArrayFormatter<BigInteger>());
        Register(new BitArrayFormatter());
        Register(new ArrayFormatter<BitArray>());
        Register(new StringBuilderFormatter());
        Register(new ArrayFormatter<StringBuilder>());
        Register(new TypeFormatter());
        Register(new ArrayFormatter<Type>());
        Register(new CultureInfoFormatter());
        Register(new ArrayFormatter<CultureInfo>());
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackFormatterProvider.WellknownTypes.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Numerics" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var unmanagedTypes = new Type[]
    {
        typeof(sbyte),
        typeof(byte),
        typeof(short),
        typeof(ushort),
        typeof(int),
        typeof(uint),
        typeof(long),
        typeof(ulong),
        typeof(char),
        typeof(float),
        typeof(double),
        typeof(decimal),
        typeof(bool),
        typeof(IntPtr),
        typeof(UIntPtr),

        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(TimeSpan),
        typeof(Guid),
    };
    var unmanagedTypeNames = unmanagedTypes
        .Select(x => x.Name)
        .Concat(new []
        {
            // System.Numerics(BigInteger is not unmanaged type)
            "Complex",
            "Plane",
            "Quaternion",
            "Matrix3x2",
            "Matrix4x4",
            "Vector2",
            "Vector3",
            "Vector4",
        });

    var net7UnmanagedTypeNames = new[]
    {
        "Rune",
        "DateOnly",
        "TimeOnly",
        "Half",
        "Int128",
        "UInt128",
    };

    var knownTypes = new Type[]
    {
        typeof(string),
        typeof(Version),
        typeof(Uri),
    };

    var knownTypesNames = knownTypes
        .Select(x => x.Name)
        .Concat(new []
        {
            "TimeZoneInfo",
            "BigInteger",
            "BitArray",
            "StringBuilder",
            "Type",
            "CultureInfo",
        });
#>
using MemoryPack.Formatters;
using System.Collections;
using System.Globalization;
using System.Text;
using System.Numerics;

namespace MemoryPack;

public static partial class MemoryPackFormatterProvider
{
    internal static void RegisterWellKnownTypesFormatters()
    {
<# foreach(var item in unmanagedTypeNames) { #>
        Register(new UnmanagedFormatter<<#= item #>>());
        Register(new UnmanagedArrayFormatter<<#= item #>>());
        Register(new NullableFormatter<<#= item #>>());
<# } #>
#if NET7_0_OR_GREATER
<# foreach(var item in net7UnmanagedTypeNames) { #>
        Register(new UnmanagedFormatter<<#= item #>>());
        Register(new UnmanagedArrayFormatter<<#= item #>>());
        Register(new NullableFormatter<<#= item #>>());
<# } #>
#endif
<# foreach(var item in knownTypesNames) { #>
        Register(new <#= item #>Formatter());
        Register(new ArrayFormatter<<#= item #>>());
<# } #>
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackReader.cs
================================================
﻿using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
#if NET7_0_OR_GREATER
using System.Text.Unicode;
#endif

namespace MemoryPack;

#if NET7_0_OR_GREATER
using static GC;
using static MemoryMarshal;
#else
using static MemoryPack.Internal.MemoryMarshalEx;
#endif

[StructLayout(LayoutKind.Auto)]
public ref partial struct MemoryPackReader
{
    ReadOnlySequence<byte> bufferSource;
    readonly long totalLength;
#if NET7_0_OR_GREATER
    ref byte bufferReference;
#else
    ReadOnlySpan<byte> bufferReference;
#endif
    int bufferLength;
    byte[]? rentBuffer;
    int advancedCount;
    int consumed;   // total length of consumed
    readonly MemoryPackReaderOptionalState optionalState;

    public int Consumed => consumed;
    public long Remaining => totalLength - consumed;
    public MemoryPackReaderOptionalState OptionalState => optionalState;
    public MemoryPackSerializerOptions Options => optionalState.Options;

    public MemoryPackReader(in ReadOnlySequence<byte> sequence, MemoryPackReaderOptionalState optionalState)
    {
        this.bufferSource = sequence.IsSingleSegment ? ReadOnlySequence<byte>.Empty : sequence;
        var span = sequence.FirstSpan;
#if NET7_0_OR_GREATER
        this.bufferReference = ref MemoryMarshal.GetReference(span);
#else
        this.bufferReference = span;
#endif
        this.bufferLength = span.Length;
        this.advancedCount = 0;
        this.consumed = 0;
        this.rentBuffer = null;
        this.totalLength = sequence.Length;
        this.optionalState = optionalState;
    }

    public MemoryPackReader(ReadOnlySpan<byte> buffer, MemoryPackReaderOptionalState optionalState)
    {
        this.bufferSource = ReadOnlySequence<byte>.Empty;
#if NET7_0_OR_GREATER
        this.bufferReference = ref MemoryMarshal.GetReference(buffer);
#else
        this.bufferReference = buffer;
#endif
        this.bufferLength = buffer.Length;
        this.advancedCount = 0;
        this.consumed = 0;
        this.rentBuffer = null;
        this.totalLength = buffer.Length;
        this.optionalState = optionalState;
    }

    // buffer operations

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref byte GetSpanReference(int sizeHint)
    {
        if (sizeHint <= bufferLength)
        {
#if NET7_0_OR_GREATER
            return ref bufferReference;
#else
            return ref MemoryMarshal.GetReference(bufferReference);
#endif
        }

        return ref GetNextSpan(sizeHint);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    ref byte GetNextSpan(int sizeHint)
    {
        if (rentBuffer != null)
        {
            ArrayPool<byte>.Shared.Return(rentBuffer);
            rentBuffer = null;
        }

        if (Remaining == 0)
        {
            MemoryPackSerializationException.ThrowSequenceReachedEnd();
        }

        try
        {
            bufferSource = bufferSource.Slice(advancedCount);
        }
        catch (ArgumentOutOfRangeException)
        {
            MemoryPackSerializationException.ThrowSequenceReachedEnd();
        }

        advancedCount = 0;

        if (sizeHint <= Remaining)
        {
            if (sizeHint <= bufferSource.FirstSpan.Length)
            {
#if NET7_0_OR_GREATER
                bufferReference = ref MemoryMarshal.GetReference(bufferSource.FirstSpan);
                bufferLength = bufferSource.FirstSpan.Length;
                return ref bufferReference;
#else
                bufferReference = bufferSource.FirstSpan;
                bufferLength = bufferSource.FirstSpan.Length;
                return ref MemoryMarshal.GetReference(bufferReference);
#endif
            }

            rentBuffer = ArrayPool<byte>.Shared.Rent(sizeHint);
            bufferSource.Slice(0, sizeHint).CopyTo(rentBuffer);
            var span = rentBuffer.AsSpan(0, sizeHint);
#if NET7_0_OR_GREATER
            bufferReference = ref MemoryMarshal.GetReference(span);
            bufferLength = span.Length;
            return ref bufferReference;
#else
            bufferReference = span;
            bufferLength = span.Length;
            return ref MemoryMarshal.GetReference(bufferReference);
#endif
        }

        MemoryPackSerializationException.ThrowSequenceReachedEnd();
#if NET7_0_OR_GREATER
        return ref bufferReference; // dummy.
#else
        return ref MemoryMarshal.GetReference(bufferReference);
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        if (count == 0) return;

        var rest = bufferLength - count;
        if (rest < 0)
        {
            if (TryAdvanceSequence(count))
            {
                return;
            }
        }

        bufferLength = rest;
#if NET7_0_OR_GREATER
        bufferReference = ref Unsafe.Add(ref bufferReference, count);
#else
        bufferReference = bufferReference.Slice(count);
#endif
        advancedCount += count;
        consumed += count;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    bool TryAdvanceSequence(int count)
    {
        var rest = bufferSource.Length - count;
        if (rest < 0)
        {
            MemoryPackSerializationException.ThrowInvalidAdvance();
        }

        bufferSource = bufferSource.Slice(advancedCount + count);
#if NET7_0_OR_GREATER
        bufferReference = ref MemoryMarshal.GetReference(bufferSource.FirstSpan);
#else
        bufferReference = bufferSource.FirstSpan;
#endif
        bufferLength = bufferSource.FirstSpan.Length;
        advancedCount = 0;
        consumed += count;
        return true;
    }

    public void GetRemainingSource(out ReadOnlySpan<byte> singleSource, out ReadOnlySequence<byte> remainingSource)
    {
        if (bufferSource.IsEmpty)
        {
            remainingSource = ReadOnlySequence<byte>.Empty;
#if NET7_0_OR_GREATER
            singleSource = MemoryMarshal.CreateReadOnlySpan(ref bufferReference, bufferLength);
#else
            singleSource = bufferReference;
#endif
            return;
        }
        else
        {
            if (bufferSource.IsSingleSegment)
            {
                remainingSource = ReadOnlySequence<byte>.Empty;
                singleSource = bufferSource.FirstSpan.Slice(advancedCount);
                return;
            }

            singleSource = default;
            remainingSource = bufferSource.Slice(advancedCount);
            if (remainingSource.IsSingleSegment)
            {
                singleSource = remainingSource.FirstSpan;
                remainingSource = ReadOnlySequence<byte>.Empty;
                return;
            }
            return;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Dispose()
    {
        if (rentBuffer != null)
        {
            ArrayPool<byte>.Shared.Return(rentBuffer);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IMemoryPackFormatter GetFormatter(Type type)
    {
        return MemoryPackFormatterProvider.GetFormatter(type);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IMemoryPackFormatter<T> GetFormatter<T>()
    {
        return MemoryPackFormatterProvider.GetFormatter<T>();
    }

    // read methods

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryReadObjectHeader(out byte memberCount)
    {
        memberCount = GetSpanReference(1);
        Advance(1);
        return memberCount != MemoryPackCode.NullObject;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryReadUnionHeader(out ushort tag)
    {
        var firstTag = GetSpanReference(1);
        Advance(1);
        if (firstTag < MemoryPackCode.WideTag)
        {
            tag = firstTag;
            return true;
        }
        else if (firstTag == MemoryPackCode.WideTag)
        {
            ReadUnmanaged(out tag);
            return true;
        }
        else
        {
            tag = 0;
            return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryReadCollectionHeader(out int length)
    {
        length = Unsafe.ReadUnaligned<int>(ref GetSpanReference(4));
        Advance(4);

        // If collection-length is larger than buffer-length, it is invalid data.
        if (Remaining < length)
        {
            MemoryPackSerializationException.ThrowInsufficientBufferUnless(length);
        }

        return length != MemoryPackCode.NullCollection;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool PeekIsNull()
    {
        var code = GetSpanReference(1);
        return code == MemoryPackCode.NullObject;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPeekObjectHeader(out byte memberCount)
    {
        memberCount = GetSpanReference(1);
        return memberCount != MemoryPackCode.NullObject;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPeekUnionHeader(out ushort tag)
    {
        var firstTag = GetSpanReference(1);
        if (firstTag < MemoryPackCode.WideTag)
        {
            tag = firstTag;
            return true;
        }
        else if (firstTag == MemoryPackCode.WideTag)
        {
            ref var spanRef = ref GetSpanReference(sizeof(ushort) + 1); // skip firstTag
            tag = Unsafe.ReadUnaligned<ushort>(ref Unsafe.Add(ref spanRef, 1));
            return true;
        }
        else
        {
            tag = 0;
            return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryPeekCollectionHeader(out int length)
    {
        length = Unsafe.ReadUnaligned<int>(ref GetSpanReference(4));

        // If collection-length is larger than buffer-length, it is invalid data.
        if (Remaining < length)
        {
            MemoryPackSerializationException.ThrowInsufficientBufferUnless(length);
        }

        return length != MemoryPackCode.NullCollection;
    }

    /// <summary>
    /// no validate collection size, be careful to use.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool DangerousTryReadCollectionHeader(out int length)
    {
        length = Unsafe.ReadUnaligned<int>(ref GetSpanReference(4));
        Advance(4);

        return length != MemoryPackCode.NullCollection;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public string? ReadString()
    {
        if (!TryReadCollectionHeader(out var length))
        {
            return null;
        }
        if (length == 0)
        {
            return "";
        }

        if (length > 0)
        {
            return ReadUtf16(length);
        }
        else
        {
            return ReadUtf8(length);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    string ReadUtf16(int length)
    {
        var byteCount = checked(length * 2);
        ref var src = ref GetSpanReference(byteCount);

        var str = new string(MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<byte, char>(ref src), length));

        Advance(byteCount);

        return str;
    }

    [MethodImpl(MethodImplOptions.NoInlining)] // non default, no inline
    string ReadUtf8(int utf8Length)
    {
        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
        // already read utf8 length, but it is complement.

        utf8Length = ~utf8Length;

        ref var spanRef = ref GetSpanReference(utf8Length + 4); // + read utf16 length

        string str;
        var utf16Length = Unsafe.ReadUnaligned<int>(ref spanRef);

        if (utf16Length <= 0)
        {
            var src = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.Add(ref spanRef, 4), utf8Length);
            str = Encoding.UTF8.GetString(src);
        }
        else
        {
            // check malformed utf16Length
            var max = unchecked((Remaining + 1) * 3);
            if (max < 0) max = int.MaxValue;
            if (max < utf16Length)
            {
                MemoryPackSerializationException.ThrowInsufficientBufferUnless(utf8Length);
            }


#if NET7_0_OR_GREATER
            // regular path, know decoded UTF16 length will gets faster decode result
            unsafe
            {
                fixed (byte* p = &Unsafe.Add(ref spanRef, 4))
                {
                    str = string.Create(utf16Length, ((IntPtr)p, utf8Length), static (dest, state) =>
                    {
                        var src = MemoryMarshal.CreateSpan(ref Unsafe.AsRef<byte>((byte*)state.Item1), state.Item2);
                        var status = Utf8.ToUtf16(src, dest, out var bytesRead, out var charsWritten, replaceInvalidSequences: false);
                        if (status != OperationStatus.Done)
                        {
                            MemoryPackSerializationException.ThrowFailedEncoding(status);
                        }
                    });
                }
            }
#else
            var src = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.Add(ref spanRef, 4), utf8Length);
            str = Encoding.UTF8.GetString(src);
#endif
        }

        Advance(utf8Length + 4);

        return str;
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 ReadUnmanaged<T1>()
        where T1 : unmanaged
    {
        var size = Unsafe.SizeOf<T1>();
        ref var spanRef = ref GetSpanReference(size);
        var value1 = Unsafe.ReadUnaligned<T1>(ref spanRef);
        Advance(size);
        return value1;
    }

#if NET7_0_OR_GREATER

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadPackable<T>(scoped ref T? value)
        where T : IMemoryPackable<T>
    {
        T.Deserialize(ref this, ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? ReadPackable<T>()
        where T : IMemoryPackable<T>
    {
        T? value = default;
        T.Deserialize(ref this, ref value);
        return value;
    }

#else

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadPackable<T>(scoped ref T? value)
        where T : IMemoryPackable<T>
    {
        ReadValue(ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? ReadPackable<T>()
        where T : IMemoryPackable<T>
    {
        return ReadValue<T>();
    }

#endif

    // non packable, get formatter dynamically.
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadValue<T>(scoped ref T? value)
    {
        GetFormatter<T>().Deserialize(ref this, ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? ReadValue<T>()
    {
        T? value = default;
        GetFormatter<T>().Deserialize(ref this, ref value);
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadValue(Type type, ref object? value)
    {
        GetFormatter(type).Deserialize(ref this, ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public object? ReadValue(Type type)
    {
        object? value = default;
        GetFormatter(type).Deserialize(ref this, ref value);
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadValueWithFormatter<TFormatter, T>(TFormatter formatter, scoped ref T? value)
        where TFormatter : IMemoryPackFormatter<T>
    {
        formatter.Deserialize(ref this, ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? ReadValueWithFormatter<TFormatter, T>(TFormatter formatter)
        where TFormatter : IMemoryPackFormatter<T>
    {
        T? value = default;
        formatter.Deserialize(ref this, ref value);
        return value;
    }

    #region ReadArray/Span

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T?[]? ReadArray<T>()
    {
        T?[]? value = default;
        ReadArray(ref value);
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadArray<T>(scoped ref T?[]? value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousReadUnmanagedArray(ref value);
            return;
        }

        if (!TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        // T[] support overwrite
        if (value == null || value.Length != length)
        {
            value = new T[length];
        }

        var formatter = GetFormatter<T>();
        for (int i = 0; i < length; i++)
        {
            formatter.Deserialize(ref this, ref value[i]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadSpan<T>(scoped ref Span<T?> value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousReadUnmanagedSpan(ref value);
            return;
        }

        if (!TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        if (value.Length != length)
        {
            value = new T[length];
        }

        var formatter = GetFormatter<T>();
        for (int i = 0; i < length; i++)
        {
            formatter.Deserialize(ref this, ref value[i]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T?[]? ReadPackableArray<T>()
        where T : IMemoryPackable<T>
    {
        T?[]? value = default;
        ReadPackableArray(ref value);
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadPackableArray<T>(scoped ref T?[]? value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        ReadArray(ref value);
        return;
#else
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousReadUnmanagedArray(ref value);
            return;
        }

        if (!TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        // T[] support overwrite
        if (value == null || value.Length != length)
        {
            value = new T[length];
        }

        for (int i = 0; i < length; i++)
        {
            T.Deserialize(ref this, ref value[i]);
        }
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadPackableSpan<T>(scoped ref Span<T?> value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        ReadSpan(ref value);
        return;
#else
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousReadUnmanagedSpan(ref value);
            return;
        }

        if (!TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        if (value.Length != length)
        {
            value = new T[length];
        }

        for (int i = 0; i < length; i++)
        {
            T.Deserialize(ref this, ref value[i]);
        }
#endif
    }

    #endregion

    #region UnmanagedArray/Span

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T[]? ReadUnmanagedArray<T>()
        where T : unmanaged
    {
        return DangerousReadUnmanagedArray<T>();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadUnmanagedArray<T>(scoped ref T[]? value)
        where T : unmanaged
    {
        DangerousReadUnmanagedArray<T>(ref value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadUnmanagedSpan<T>(scoped ref Span<T> value)
        where T : unmanaged
    {
        DangerousReadUnmanagedSpan<T>(ref value);
    }

    // T: should be unamanged type
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public unsafe T[]? DangerousReadUnmanagedArray<T>()
    {
        if (!TryReadCollectionHeader(out var length))
        {
            return null;
        }

        if (length == 0) return Array.Empty<T>();

        var byteCount = length * Unsafe.SizeOf<T>();
        ref var src = ref GetSpanReference(byteCount);
        var dest = AllocateUninitializedArray<T>(length);
        Unsafe.CopyBlockUnaligned(ref Unsafe.As<T, byte>(ref GetArrayDataReference(dest)), ref src, (uint)byteCount);
        Advance(byteCount);

        return dest;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public unsafe void DangerousReadUnmanagedArray<T>(scoped ref T[]? value)
    {
        if (!TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        var byteCount = length * Unsafe.SizeOf<T>();
        ref var src = ref GetSpanReference(byteCount);

        if (value == null || value.Length != length)
        {
            value = AllocateUninitializedArray<T>(length);
        }

        ref var dest = ref Unsafe.As<T, byte>(ref GetArrayDataReference(value));
        Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

        Advance(byteCount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public unsafe void DangerousReadUnmanagedSpan<T>(scoped ref Span<T> value)
    {
        if (!TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        var byteCount = length * Unsafe.SizeOf<T>();
        ref var src = ref GetSpanReference(byteCount);

        if (value == null || value.Length != length)
        {
            value = AllocateUninitializedArray<T>(length);
        }

        ref var dest = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value));
        Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

        Advance(byteCount);
    }

    #endregion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadSpanWithoutReadLengthHeader<T>(int length, scoped ref Span<T?> value)
    {
        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            if (value.Length != length)
            {
                value = AllocateUninitializedArray<T>(length);
            }

            var byteCount = length * Unsafe.SizeOf<T>();
            ref var src = ref GetSpanReference(byteCount);
            ref var dest = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)!);
            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

            Advance(byteCount);
        }
        else
        {
            if (value.Length != length)
            {
                value = new T[length];
            }

            var formatter = GetFormatter<T>();
            for (int i = 0; i < length; i++)
            {
                formatter.Deserialize(ref this, ref value[i]);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ReadPackableSpanWithoutReadLengthHeader<T>(int length, scoped ref Span<T?> value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        ReadSpanWithoutReadLengthHeader(length, ref value);
        return;
#else
        if (length == 0)
        {
            value = Array.Empty<T>();
            return;
        }

        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            if (value.Length != length)
            {
                value = AllocateUninitializedArray<T>(length);
            }

            var byteCount = length * Unsafe.SizeOf<T>();
            ref var src = ref GetSpanReference(byteCount);
            ref var dest = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)!);
            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

            Advance(byteCount);
        }
        else
        {
            if (value.Length != length)
            {
                value = new T[length];
            }

            for (int i = 0; i < length; i++)
            {
                T.Deserialize(ref this, ref value[i]);
            }
        }
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public unsafe void DangerousReadUnmanagedSpanView<T>(out bool isNull, out ReadOnlySpan<byte> view)
    {
        if (!TryReadCollectionHeader(out var length))
        {
            isNull = true;
            view = default;
            return;
        }

        isNull = false;

        if (length == 0)
        {
            view = Array.Empty<byte>();
            return;
        }

        var byteCount = length * Unsafe.SizeOf<T>();
        ref var src = ref GetSpanReference(byteCount);

        var span = MemoryMarshal.CreateReadOnlySpan(ref src, byteCount);

        Advance(byteCount);
        view = span; // safe until call next GetSpanReference
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackReader.Unmanaged.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    string MakeT(int count) => string.Join(", ", Enumerable.Range(1, count).Select(x => $"T{x}"));
    string MakeArgs(int count) => string.Join(", ", Enumerable.Range(1, count).Select(x => $"out T{x} value{x}"));
    string MakeWhere(int count) => string.Join("\r\n        ", Enumerable.Range(1, count).Select(x => $"where T{x} : unmanaged"));
    string MakeSize(int count) => string.Join(" + ", Enumerable.Range(1, count).Select(x => $"Unsafe.SizeOf<T{x}>()"));
#>
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack;

public ref partial struct MemoryPackReader
{
<# foreach(var dangerous in new[] { false, true }) { #>
<# for(var i = 1; i < 16; i++ ) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void <#= dangerous ? "Dangerous" : "" #>ReadUnmanaged<<#= MakeT(i) #>>(<#= MakeArgs(i) #>)
<# if(!dangerous) { #>
        <#= MakeWhere(i) #>
<# } #>
    {
        var size = <#= MakeSize(i) #>;
        ref var spanRef = ref GetSpanReference(size);
        value1 = Unsafe.ReadUnaligned<T1>(ref spanRef);
<# for(var j = 2; j <= i; j++) { #>
        value<#= j #> = Unsafe.ReadUnaligned<T<#= j #>>(ref Unsafe.Add(ref spanRef, <#= MakeSize(j - 1) #>));
<# } #>
        Advance(size);
    }

<# } } #>
}



================================================
FILE: src/MemoryPack.Core/MemoryPackReaderOptionalState.cs
================================================
﻿using System.Collections.Concurrent;

namespace MemoryPack;

public static class MemoryPackReaderOptionalStatePool
{
    static readonly ConcurrentQueue<MemoryPackReaderOptionalState> queue = new ConcurrentQueue<MemoryPackReaderOptionalState>();

    public static MemoryPackReaderOptionalState Rent(MemoryPackSerializerOptions? options)
    {
        if (!queue.TryDequeue(out var state))
        {
            state = new MemoryPackReaderOptionalState();
        }

        state.Init(options);
        return state;
    }

    internal static void Return(MemoryPackReaderOptionalState state)
    {
        state.Reset();
        queue.Enqueue(state);
    }
}

public sealed class MemoryPackReaderOptionalState : IDisposable
{
    readonly Dictionary<uint, object> refToObject;
    public MemoryPackSerializerOptions Options { get; private set; }

    internal MemoryPackReaderOptionalState()
    {
        refToObject = new Dictionary<uint, object>();
        Options = null!;
    }

    internal void Init(MemoryPackSerializerOptions? options)
    {
        Options = options ?? MemoryPackSerializerOptions.Default;
    }

    public object GetObjectReference(uint id)
    {
        if (refToObject.TryGetValue(id, out var value))
        {
            return value;
        }
        MemoryPackSerializationException.ThrowMessage("Object is not found in this reference id:" + id);
        return null!;
    }

    public void AddObjectReference(uint id, object value)
    {
        if (!refToObject.TryAdd(id, value))
        {
            MemoryPackSerializationException.ThrowMessage("Object is already added, id:" + id);
        }
    }

    public void Reset()
    {
        refToObject.Clear();
        Options = null!;
    }

    void IDisposable.Dispose()
    {
        MemoryPackReaderOptionalStatePool.Return(this);
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackReaderWriter.VarInt.cs
================================================
﻿namespace MemoryPack;

// VarInt, first sbyte is value or typeCode

// 0~127 = unsigned byte value
// -1~-120 = signed byte value
// -121 = byte
// -122 = sbyte
// -123 = ushort
// -124 = short
// -125 = uint
// -126 = int
// -127 = ulong
// -128 = long 

internal static class VarIntCodes
{
    public const byte MaxSingleValue = 127;
    public const sbyte MinSingleValue = -120;

    public const sbyte Byte = -121;
    public const sbyte SByte = -122;
    public const sbyte UInt16 = -123;
    public const sbyte Int16 = -124;
    public const sbyte UInt32 = -125;
    public const sbyte Int32 = -126;
    public const sbyte UInt64 = -127;
    public const sbyte Int64 = -128;
}

public ref partial struct MemoryPackWriter<TBufferWriter>
{
    public void WriteVarInt(byte x)
    {
        if (x <= VarIntCodes.MaxSingleValue)
        {
            WriteUnmanaged((sbyte)x);
        }
        else
        {
            WriteUnmanaged(VarIntCodes.Byte, x);
        }
    }

    public void WriteVarInt(sbyte x)
    {
        if (VarIntCodes.MinSingleValue <= x)
        {
            WriteUnmanaged(x);
        }
        else
        {
            WriteUnmanaged(VarIntCodes.SByte, x);
        }
    }

    public void WriteVarInt(ushort x)
    {
        if (x <= VarIntCodes.MaxSingleValue)
        {
            WriteUnmanaged((sbyte)x);
        }
        else
        {
            WriteUnmanaged(VarIntCodes.UInt16, (UInt16)x);
        }
    }

    public void WriteVarInt(short x)
    {
        if (0 <= x)
        {
            if (x <= VarIntCodes.MaxSingleValue) // same as sbyte.MaxValue
            {
                WriteUnmanaged((sbyte)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
        }
        else
        {
            if (VarIntCodes.MinSingleValue <= x)
            {
                WriteUnmanaged((sbyte)x);
            }
            else if (sbyte.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.SByte, (SByte)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
        }
    }

    public void WriteVarInt(uint x)
    {
        if (x <= VarIntCodes.MaxSingleValue)
        {
            WriteUnmanaged((sbyte)x);
        }
        else if (x <= ushort.MaxValue)
        {
            WriteUnmanaged(VarIntCodes.UInt16, (UInt16)x);
        }
        else
        {
            WriteUnmanaged(VarIntCodes.UInt32, (UInt32)x);
        }
    }

    public void WriteVarInt(int x)
    {
        if (0 <= x)
        {
            if (x <= VarIntCodes.MaxSingleValue) // same as sbyte.MaxValue
            {
                WriteUnmanaged((sbyte)x);
            }
            else if (x <= short.MaxValue)
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int32, (Int32)x);
            }
        }
        else
        {
            if (VarIntCodes.MinSingleValue <= x)
            {
                WriteUnmanaged((sbyte)x);
            }
            else if (sbyte.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.SByte, (SByte)x);
            }
            else if (short.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int32, (Int32)x);
            }
        }
    }

    public void WriteVarInt(ulong x)
    {
        if (x <= VarIntCodes.MaxSingleValue)
        {
            WriteUnmanaged((sbyte)x);
        }
        else if (x <= ushort.MaxValue)
        {
            WriteUnmanaged(VarIntCodes.UInt16, (UInt16)x);
        }
        else if (x <= uint.MaxValue)
        {
            WriteUnmanaged(VarIntCodes.UInt32, (UInt32)x);
        }
        else
        {
            WriteUnmanaged(VarIntCodes.UInt64, (UInt64)x);
        }
    }

    public void WriteVarInt(long x)
    {
        if (0 <= x)
        {
            if (x <= VarIntCodes.MaxSingleValue) // same as sbyte.MaxValue
            {
                WriteUnmanaged((sbyte)x);
            }
            else if (x <= short.MaxValue)
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
            else if (x <= int.MaxValue)
            {
                WriteUnmanaged(VarIntCodes.Int32, (Int32)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int64, (Int64)x);
            }
        }
        else
        {
            if (VarIntCodes.MinSingleValue <= x)
            {
                WriteUnmanaged((sbyte)x);
            }
            else if (sbyte.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.SByte, (SByte)x);
            }
            else if (short.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.Int16, (Int16)x);
            }
            else if (int.MinValue <= x)
            {
                WriteUnmanaged(VarIntCodes.Int32, (Int32)x);
            }
            else
            {
                WriteUnmanaged(VarIntCodes.Int64, (Int64)x);
            }
        }
    }
}

public ref partial struct MemoryPackReader
{
    public byte ReadVarIntByte()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return checked((byte)ReadUnmanaged<sbyte>());
            case VarIntCodes.UInt16:
                return checked((byte)ReadUnmanaged<byte>());
            case VarIntCodes.Int16:
                return checked((byte)ReadUnmanaged<short>());
            case VarIntCodes.UInt32:
                return checked((byte)ReadUnmanaged<uint>());
            case VarIntCodes.Int32:
                return checked((byte)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return checked((byte)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((byte)ReadUnmanaged<long>());
            default:
                return checked((byte)typeCode);
        }
    }

    public sbyte ReadVarIntSByte()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return checked((sbyte)ReadUnmanaged<byte>());
            case VarIntCodes.SByte:
                return ReadUnmanaged<sbyte>();
            case VarIntCodes.UInt16:
                return checked((sbyte)ReadUnmanaged<ushort>());
            case VarIntCodes.Int16:
                return checked((sbyte)ReadUnmanaged<short>());
            case VarIntCodes.UInt32:
                return checked((sbyte)ReadUnmanaged<uint>());
            case VarIntCodes.Int32:
                return checked((sbyte)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return checked((sbyte)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((sbyte)ReadUnmanaged<long>());
            default:
                return typeCode;
        }
    }

    public ushort ReadVarIntUInt16()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return checked((ushort)ReadUnmanaged<sbyte>());
            case VarIntCodes.UInt16:
                return ReadUnmanaged<ushort>();
            case VarIntCodes.Int16:
                return checked((ushort)ReadUnmanaged<short>());
            case VarIntCodes.UInt32:
                return checked((ushort)ReadUnmanaged<uint>());
            case VarIntCodes.Int32:
                return checked((ushort)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return checked((ushort)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((ushort)ReadUnmanaged<long>());
            default:
                return checked((ushort)typeCode);
        }
    }

    public short ReadVarIntInt16()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return ReadUnmanaged<sbyte>();
            case VarIntCodes.UInt16:
                return checked((short)ReadUnmanaged<ushort>());
            case VarIntCodes.Int16:
                return ReadUnmanaged<short>();
            case VarIntCodes.UInt32:
                return checked((short)ReadUnmanaged<uint>());
            case VarIntCodes.Int32:
                return checked((short)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return checked((short)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((short)ReadUnmanaged<long>());
            default:
                return typeCode;
        }
    }

    public uint ReadVarIntUInt32()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return checked((uint)ReadUnmanaged<sbyte>());
            case VarIntCodes.UInt16:
                return ReadUnmanaged<ushort>();
            case VarIntCodes.Int16:
                return checked((uint)ReadUnmanaged<short>());
            case VarIntCodes.UInt32:
                return ReadUnmanaged<uint>();
            case VarIntCodes.Int32:
                return checked((uint)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return checked((uint)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((uint)ReadUnmanaged<long>());
            default:
                return checked((uint)typeCode);
        }
    }

    public int ReadVarIntInt32()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return ReadUnmanaged<sbyte>();
            case VarIntCodes.UInt16:
                return ReadUnmanaged<ushort>();
            case VarIntCodes.Int16:
                return ReadUnmanaged<short>();
            case VarIntCodes.UInt32:
                return checked((int)ReadUnmanaged<uint>());
            case VarIntCodes.Int32:
                return ReadUnmanaged<int>();
            case VarIntCodes.UInt64:
                return checked((int)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return checked((int)ReadUnmanaged<long>());
            default:
                return typeCode;
        }
    }

    public ulong ReadVarIntUInt64()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return checked((ulong)ReadUnmanaged<sbyte>());
            case VarIntCodes.UInt16:
                return ReadUnmanaged<ushort>();
            case VarIntCodes.Int16:
                return checked((ulong)ReadUnmanaged<short>());
            case VarIntCodes.UInt32:
                return ReadUnmanaged<uint>();
            case VarIntCodes.Int32:
                return checked((ulong)ReadUnmanaged<int>());
            case VarIntCodes.UInt64:
                return ReadUnmanaged<ulong>();
            case VarIntCodes.Int64:
                return checked((ulong)ReadUnmanaged<long>());
            default:
                return checked((ulong)typeCode);
        }
    }

    public long ReadVarIntInt64()
    {
        ReadUnmanaged(out sbyte typeCode);

        switch (typeCode)
        {
            case VarIntCodes.Byte:
                return ReadUnmanaged<byte>();
            case VarIntCodes.SByte:
                return ReadUnmanaged<sbyte>();
            case VarIntCodes.UInt16:
                return ReadUnmanaged<ushort>();
            case VarIntCodes.Int16:
                return ReadUnmanaged<short>();
            case VarIntCodes.UInt32:
                return ReadUnmanaged<uint>();
            case VarIntCodes.Int32:
                return ReadUnmanaged<int>();
            case VarIntCodes.UInt64:
                return checked((long)ReadUnmanaged<ulong>());
            case VarIntCodes.Int64:
                return ReadUnmanaged<long>();
            default:
                return typeCode;
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializationException.cs
================================================
﻿using System.Buffers;
using System.Diagnostics.CodeAnalysis;

namespace MemoryPack;

public class MemoryPackSerializationException : Exception
{
    public MemoryPackSerializationException(string message)
        : base(message)
    {
    }

    public MemoryPackSerializationException(string message, Exception innerException)
        : base(message, innerException)
    {
    }

    [DoesNotReturn]
    public static void ThrowMessage(string message)
    {
        throw new MemoryPackSerializationException(message);
    }

    [DoesNotReturn]
    public static void ThrowInvalidPropertyCount(byte expected, byte actual)
    {
        throw new MemoryPackSerializationException($"Current object's property count is {expected} but binary's header maked as {actual}, can't deserialize about versioning.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidPropertyCount(Type type, byte expected, byte actual)
    {
        throw new MemoryPackSerializationException($"{type.FullName} property count is {expected} but binary's header maked as {actual}, can't deserialize about versioning.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidCollection()
    {
        throw new MemoryPackSerializationException($"Current read to collection, the buffer header is not collection.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidRange(int expected, int actual)
    {
        throw new MemoryPackSerializationException($"Requires size is {expected} but buffer length is {actual}.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidAdvance()
    {
        throw new MemoryPackSerializationException($"Cannot advance past the end of the buffer.");
    }

    [DoesNotReturn]
    public static void ThrowSequenceReachedEnd()
    {
        throw new MemoryPackSerializationException($"Sequence reached end, reader can not provide more buffer.");
    }

    [DoesNotReturn]
    public static void ThrowWriteInvalidMemberCount(byte memberCount)
    {
        throw new MemoryPackSerializationException($"MemberCount/Tag allows < 250 but try to write {memberCount}.");
    }

    [DoesNotReturn]
    public static void ThrowInsufficientBufferUnless(int length)
    {
        throw new MemoryPackSerializationException($"Length header size is larger than buffer size, length: {length}.");
    }

    [DoesNotReturn]
    public static void ThrowNotRegisteredInProvider(Type type)
    {
        throw new MemoryPackSerializationException($"{type.FullName} is not registered in this provider.");
    }

    [DoesNotReturn]
    public static void ThrowRegisterInProviderFailed(Type type, Exception innerException)
    {
        throw new MemoryPackSerializationException($"{type.FullName} is failed in provider at creating formatter.", innerException);
    }

    [DoesNotReturn]
    public static void ThrowNotFoundInUnionType(Type actualType, Type baseType)
    {
        throw new MemoryPackSerializationException($"Type {actualType.FullName} is not annotated in {baseType.FullName} MemoryPackUnion.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidTag(ushort tag, Type baseType)
    {
        throw new MemoryPackSerializationException($"Data read tag: {tag} but not found in {baseType.FullName} MemoryPackUnion annotations.");
    }

    [DoesNotReturn]
    public static void ThrowReachedDepthLimit(Type type)
    {
        throw new MemoryPackSerializationException($"Serializing Type '{type}' reached depth limit, maybe detect circular reference.");
    }

    [DoesNotReturn]
    public static void ThrowInvalidConcurrrentCollectionOperation()
    {
        throw new MemoryPackSerializationException($"ConcurrentCollection is Added/Removed in serializing, however serialize concurrent collection is not thread-safe.");
    }

    [DoesNotReturn]
    public static void ThrowDeserializeObjectIsNull(string target)
    {
        throw new MemoryPackSerializationException($"Deserialized {target} is null.");
    }

    [DoesNotReturn]
    public static void ThrowFailedEncoding(OperationStatus status)
    {
        throw new MemoryPackSerializationException($"Failed in Utf8 encoding/decoding process, status: {status}.");
    }

    [DoesNotReturn]
    public static void ThrowCompressionFailed(OperationStatus status)
    {
        throw new MemoryPackSerializationException($"Failed in Brotli compression/decompression process, status: {status}.");
    }

    [DoesNotReturn]
    public static void ThrowCompressionFailed()
    {
        throw new MemoryPackSerializationException($"Failed in Brotli compression/decompression process.");
    }

    [DoesNotReturn]
    public static void ThrowAlreadyDecompressed()
    {
        throw new MemoryPackSerializationException($"BrotliDecompressor can not invoke Decompress twice, already invoked.");
    }

    [DoesNotReturn]
    public static void ThrowDecompressionSizeLimitExceeded(int limit, int size)
    {
        throw new MemoryPackSerializationException($"In decompress process, limit is {limit} but target size is {size}.");
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializer.Deserialize.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack;

public static partial class MemoryPackSerializer
{
    [ThreadStatic]
    static MemoryPackReaderOptionalState? threadStaticReaderOptionalState;

    public static T? Deserialize<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
        T>(ReadOnlySpan<byte> buffer, MemoryPackSerializerOptions? options = default)
    {
        T? value = default;
        Deserialize(buffer, ref value, options);
        return value;
    }

    public static int Deserialize<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
        T>(ReadOnlySpan<byte> buffer, ref T? value, MemoryPackSerializerOptions? options = default)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            if (buffer.Length < Unsafe.SizeOf<T>())
            {
                MemoryPackSerializationException.ThrowInvalidRange(Unsafe.SizeOf<T>(), buffer.Length);
            }
            value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(buffer));
            return Unsafe.SizeOf<T>();
        }

        var state = threadStaticReaderOptionalState;
        if (state == null)
        {
            state = threadStaticReaderOptionalState = new MemoryPackReaderOptionalState();
        }
        state.Init(options);

        var reader = new MemoryPackReader(buffer, state);
        try
        {
            reader.ReadValue(ref value);
            return reader.Consumed;
        }
        finally
        {
            reader.Dispose();
            state.Reset();
        }
    }

    public static T? Deserialize<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
        T>(in ReadOnlySequence<byte> buffer, MemoryPackSerializerOptions? options = default)
    {
        T? value = default;
        Deserialize<T>(buffer, ref value, options);
        return value;
    }

    public static int Deserialize<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
        T>(in ReadOnlySequence<byte> buffer, ref T? value, MemoryPackSerializerOptions? options = default)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            int sizeOfT = Unsafe.SizeOf<T>();
            if (buffer.Length < sizeOfT)
            {
                MemoryPackSerializationException.ThrowInvalidRange(Unsafe.SizeOf<T>(), (int)buffer.Length);
            }

            ReadOnlySequence<byte> sliced = buffer.Slice(0, sizeOfT);

            if (sliced.IsSingleSegment)
            {
                value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(sliced.FirstSpan));
                return sizeOfT;
            }
            else
            {
                // We can't read directly from ReadOnlySequence<byte> to T, so we copy to a temp array.
                // if less than 512 bytes, use stackalloc, otherwise use MemoryPool<byte>
                byte[]? tempArray = null;

                Span<byte> tempSpan = sizeOfT <= 512 ? stackalloc byte[sizeOfT] : default;

                try
                {
                    if (sizeOfT > 512)
                    {
                        tempArray = ArrayPool<byte>.Shared.Rent(sizeOfT);
                        tempSpan = tempArray;
                    }

                    sliced.CopyTo(tempSpan);
                    value = Unsafe.ReadUnaligned<T>(ref MemoryMarshal.GetReference(tempSpan));
                    return sizeOfT;
                }
                finally
                {
                    if (tempArray is not null)
                    {
                        ArrayPool<byte>.Shared.Return(tempArray);
                    }
                }
            }
        }

        var state = threadStaticReaderOptionalState;
        if (state == null)
        {
            state = threadStaticReaderOptionalState = new MemoryPackReaderOptionalState();
        }
        state.Init(options);

        var reader = new MemoryPackReader(buffer, state);
        try
        {
            reader.ReadValue(ref value);
            return reader.Consumed;
        }
        finally
        {
            reader.Dispose();
            state.Reset();
        }
    }

    public static async ValueTask<T?> DeserializeAsync<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
#endif
        T>(Stream stream, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        if (stream is MemoryStream ms && ms.TryGetBuffer(out ArraySegment<byte> streamBuffer))
        {
            cancellationToken.ThrowIfCancellationRequested();
            T? value = default;
            var bytesRead = Deserialize<T>(streamBuffer.AsSpan(checked((int)ms.Position)), ref value, options);

            // Emulate that we had actually "read" from the stream.
            ms.Seek(bytesRead, SeekOrigin.Current);

            return value;
        }

        var builder = ReusableReadOnlySequenceBuilderPool.Rent();
        try
        {
            var buffer = ArrayPool<byte>.Shared.Rent(65536); // initial 64K
            var offset = 0;
            do
            {
                if (offset == buffer.Length)
                {
                    builder.Add(buffer, returnToPool: true);
                    buffer = ArrayPool<byte>.Shared.Rent(MathEx.NewArrayCapacity(buffer.Length));
                    offset = 0;
                }

                int read = 0;
                try
                {
                    read = await stream.ReadAsync(buffer.AsMemory(offset, buffer.Length - offset), cancellationToken).ConfigureAwait(false);
                }
                catch
                {
                    // buffer is not added in builder, so return here.
                    ArrayPool<byte>.Shared.Return(buffer);
                    throw;
                }

                offset += read;

                if (read == 0)
                {
                    builder.Add(buffer.AsMemory(0, offset), returnToPool: true);
                    break;

                }
            } while (true);

            // If single buffer, we can avoid ReadOnlySequence build cost.
            if (builder.TryGetSingleMemory(out var memory))
            {
                return Deserialize<T>(memory.Span, options);
            }
            else
            {
                var seq = builder.Build();
                var result = Deserialize<T>(seq, options);
                return result;
            }
        }
        finally
        {
            builder.Reset();
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializer.NonGenerics.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack;

public static partial class MemoryPackSerializer
{
    // Serialize

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static byte[] Serialize(Type type, object? value, MemoryPackSerializerOptions? options = default)
    {
        var state = threadStaticState;
        if (state == null)
        {
            state = threadStaticState = new SerializerWriterThreadStaticState();
        }
        state.Init(options);

        try
        {
            var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref state.BufferWriter, state.BufferWriter.DangerousGetFirstBuffer(), state.OptionalState);
            Serialize(type, ref writer, value);
            return state.BufferWriter.ToArrayAndReset();
        }
        finally
        {
            state.Reset();
        }
    }

    public static unsafe void Serialize<TBufferWriter>(Type type, in TBufferWriter bufferWriter, object? value, MemoryPackSerializerOptions? options = default)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        var state = threadStaticWriterOptionalState;
        if (state == null)
        {
            state = threadStaticWriterOptionalState = new MemoryPackWriterOptionalState();
        }
        state.Init(options);

        try
        {
            var writer = new MemoryPackWriter<TBufferWriter>(ref Unsafe.AsRef(in bufferWriter), state);
            Serialize(type, ref writer, value);
        }
        finally
        {
            state.Reset();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Serialize<TBufferWriter>(Type type, ref MemoryPackWriter<TBufferWriter> writer, object? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        writer.GetFormatter(type).Serialize(ref writer, ref value);
        writer.Flush();
    }

    public static async ValueTask SerializeAsync(Type type, Stream stream, object? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        var tempWriter = ReusableLinkedArrayBufferWriterPool.Rent();
        try
        {
            SerializeToTempWriter(tempWriter, type, value, options);
            await tempWriter.WriteToAndResetAsync(stream, cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            ReusableLinkedArrayBufferWriterPool.Return(tempWriter);
        }
    }

    static void SerializeToTempWriter(ReusableLinkedArrayBufferWriter bufferWriter, Type type, object? value, MemoryPackSerializerOptions? options)
    {
        var state = threadStaticWriterOptionalState;
        if (state == null)
        {
            state = threadStaticWriterOptionalState = new MemoryPackWriterOptionalState();
        }
        state.Init(options);

        var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufferWriter, state);

        try
        {
            Serialize(type, ref writer, value);
        }
        finally
        {
            state.Reset();
        }
    }

    // Deserialize

    public static object? Deserialize(Type type, ReadOnlySpan<byte> buffer, MemoryPackSerializerOptions? options = default)
    {
        object? value = default;
        Deserialize(type, buffer, ref value, options);
        return value;
    }

    public static int Deserialize(Type type, ReadOnlySpan<byte> buffer, ref object? value, MemoryPackSerializerOptions? options = default)
    {
        var state = threadStaticReaderOptionalState;
        if (state == null)
        {
            state = threadStaticReaderOptionalState = new MemoryPackReaderOptionalState();
        }
        state.Init(options);

        var reader = new MemoryPackReader(buffer, state);
        try
        {
            reader.GetFormatter(type).Deserialize(ref reader, ref value);
            return reader.Consumed;
        }
        finally
        {
            reader.Dispose();
            state.Reset();
        }
    }

    public static object? Deserialize(Type type, in ReadOnlySequence<byte> buffer, MemoryPackSerializerOptions? options = default)
    {
        object? value = default;
        Deserialize(type, buffer, ref value, options);
        return value;
    }

    public static int Deserialize(Type type, in ReadOnlySequence<byte> buffer, ref object? value, MemoryPackSerializerOptions? options = default)
    {
        var state = threadStaticReaderOptionalState;
        if (state == null)
        {
            state = threadStaticReaderOptionalState = new MemoryPackReaderOptionalState();
        }
        state.Init(options);

        var reader = new MemoryPackReader(buffer, state);
        try
        {
            reader.GetFormatter(type).Deserialize(ref reader, ref value);
            return reader.Consumed;
        }
        finally
        {
            reader.Dispose();
            state.Reset();
        }
    }

    public static async ValueTask<object?> DeserializeAsync(Type type, Stream stream, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        if (stream is MemoryStream ms && ms.TryGetBuffer(out ArraySegment<byte> streamBuffer))
        {
            cancellationToken.ThrowIfCancellationRequested();
            object? value = default;
            var bytesRead = Deserialize(type, streamBuffer.AsSpan(checked((int)ms.Position)), ref value, options);

            // Emulate that we had actually "read" from the stream.
            ms.Seek(bytesRead, SeekOrigin.Current);

            return value;
        }

        var builder = ReusableReadOnlySequenceBuilderPool.Rent();
        try
        {
            var buffer = ArrayPool<byte>.Shared.Rent(65536); // initial 64K
            var offset = 0;
            do
            {
                if (offset == buffer.Length)
                {
                    builder.Add(buffer, returnToPool: true);
                    buffer = ArrayPool<byte>.Shared.Rent(MathEx.NewArrayCapacity(buffer.Length));
                    offset = 0;
                }

                int read = 0;
                try
                {
                    read = await stream.ReadAsync(buffer.AsMemory(offset, buffer.Length - offset), cancellationToken).ConfigureAwait(false);
                }
                catch
                {
                    // buffer is not added in builder, so return here.
                    ArrayPool<byte>.Shared.Return(buffer);
                    throw;
                }

                offset += read;

                if (read == 0)
                {
                    builder.Add(buffer.AsMemory(0, offset), returnToPool: true);
                    break;

                }
            } while (true);

            // If single buffer, we can avoid ReadOnlySequence build cost.
            if (builder.TryGetSingleMemory(out var memory))
            {
                return Deserialize(type, memory.Span, options);
            }
            else
            {
                var seq = builder.Build();
                var result = Deserialize(type, seq, options);
                return result;
            }
        }
        finally
        {
            builder.Reset();
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializer.Serialize.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack;

#if NET7_0_OR_GREATER
using static MemoryMarshal;
using static GC;
#else
using static MemoryPack.Internal.MemoryMarshalEx;
#endif

public static partial class MemoryPackSerializer
{
    [ThreadStatic]
    static SerializerWriterThreadStaticState? threadStaticState;
    [ThreadStatic]
    static MemoryPackWriterOptionalState? threadStaticWriterOptionalState;

    public static byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            var array = AllocateUninitializedArray<byte>(Unsafe.SizeOf<T>());
            Unsafe.WriteUnaligned(ref GetArrayDataReference(array), value);
            return array;
        }
#if NET7_0_OR_GREATER
        var typeKind = TypeHelpers.TryGetUnmanagedSZArrayElementSizeOrMemoryPackableFixedSize<T>(out var elementSize);
        if (typeKind == TypeHelpers.TypeKind.None)
        {
            // do nothing
        }
        else if (typeKind == TypeHelpers.TypeKind.UnmanagedSZArray)
        {
            if (value == null)
            {
                return MemoryPackCode.NullCollectionData.ToArray();
            }

            var srcArray = ((Array)(object)value!);
            var length = srcArray.Length;
            if (length == 0)
            {
                return new byte[4] { 0, 0, 0, 0 };
            }

            var dataSize = elementSize * length;
            var destArray = AllocateUninitializedArray<byte>(dataSize + 4);
            ref var head = ref MemoryMarshal.GetArrayDataReference(destArray);

            Unsafe.WriteUnaligned(ref head, length);
            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref head, 4), ref MemoryMarshal.GetArrayDataReference(srcArray), (uint)dataSize);

            return destArray;
        }
        else if (typeKind == TypeHelpers.TypeKind.FixedSizeMemoryPackable)
        {
            var buffer = new byte[(value == null) ? 1 : elementSize];
            var bufferWriter = new FixedArrayBufferWriter(buffer);
            var writer = new MemoryPackWriter<FixedArrayBufferWriter>(ref bufferWriter, buffer, MemoryPackWriterOptionalState.NullState);
            Serialize(ref writer, value);
            return bufferWriter.GetFilledBuffer();
        }
#endif

        var state = threadStaticState;
        if (state == null)
        {
            state = threadStaticState = new SerializerWriterThreadStaticState();
        }
        state.Init(options);

        try
        {
            var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref state.BufferWriter, state.BufferWriter.DangerousGetFirstBuffer(), state.OptionalState);
            Serialize(ref writer, value);
            return state.BufferWriter.ToArrayAndReset();
        }
        finally
        {
            state.Reset();
        }
    }

    public static unsafe void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        ref var bufferWriterRef = ref Unsafe.AsRef(in bufferWriter);
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            var buffer = bufferWriterRef.GetSpan(Unsafe.SizeOf<T>());
            Unsafe.WriteUnaligned(ref MemoryMarshal.GetReference(buffer), value);
            bufferWriterRef.Advance(Unsafe.SizeOf<T>());
            return;
        }
#if NET7_0_OR_GREATER
        var typeKind = TypeHelpers.TryGetUnmanagedSZArrayElementSizeOrMemoryPackableFixedSize<T>(out var elementSize);
        if (typeKind == TypeHelpers.TypeKind.UnmanagedSZArray)
        {
            if (value == null)
            {
                var span = bufferWriterRef.GetSpan(4);
                MemoryPackCode.NullCollectionData.CopyTo(span);
                bufferWriterRef.Advance(4);
                return;
            }

            var srcArray = ((Array)(object)value!);
            var length = srcArray.Length;
            if (length == 0)
            {
                var span = bufferWriterRef.GetSpan(4);
                MemoryPackCode.ZeroCollectionData.CopyTo(span);
                bufferWriterRef.Advance(4);
                return;
            }

            var dataSize = elementSize * length;
            var destSpan = bufferWriterRef.GetSpan(dataSize + 4);
            ref var head = ref MemoryMarshal.GetReference(destSpan);

            Unsafe.WriteUnaligned(ref head, length);
            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref head, 4), ref MemoryMarshal.GetArrayDataReference(srcArray), (uint)dataSize);

            bufferWriterRef.Advance(dataSize + 4);
            return;
        }
#endif

        var state = threadStaticWriterOptionalState;
        if (state == null)
        {
            state = threadStaticWriterOptionalState = new MemoryPackWriterOptionalState();
        }
        state.Init(options);

        try
        {
            var writer = new MemoryPackWriter<TBufferWriter>(ref bufferWriterRef, state);
            Serialize(ref writer, value);
        }
        finally
        {
            state.Reset();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Serialize<T, TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, in T? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        writer.WriteValue(value);
        writer.Flush();
    }

    public static async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        var tempWriter = ReusableLinkedArrayBufferWriterPool.Rent();
        try
        {
            Serialize(tempWriter, value, options);
            await tempWriter.WriteToAndResetAsync(stream, cancellationToken).ConfigureAwait(false);
            await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            ReusableLinkedArrayBufferWriterPool.Return(tempWriter);
        }
    }

    sealed class SerializerWriterThreadStaticState
    {
        public ReusableLinkedArrayBufferWriter BufferWriter;
        public MemoryPackWriterOptionalState OptionalState;

        public SerializerWriterThreadStaticState()
        {
            BufferWriter = new ReusableLinkedArrayBufferWriter(useFirstBuffer: true, pinned: true);
            OptionalState = new MemoryPackWriterOptionalState();
        }

        public void Init(MemoryPackSerializerOptions? options)
        {
            OptionalState.Init(options);
        }

        public void Reset()
        {
            BufferWriter.Reset();
            OptionalState.Reset();
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializer.StateBackup.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace MemoryPack;

public static partial class MemoryPackSerializer
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static StateSnapshot ResetState(bool resetReaderState = true, bool resetWriterState = true)
        => new(resetReaderState, resetWriterState);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static StateSnapshot ResetReaderState()
        => new(true, false);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static StateSnapshot ResetWriterState()
        => new(false, true);

    // Nested types

    public readonly struct StateSnapshot : IDisposable
    {
        readonly bool _resetReaderState;
        readonly bool _resetWriterState;
        readonly SerializerWriterThreadStaticState? _threadStaticState;
        readonly MemoryPackWriterOptionalState? _threadStaticWriterOptionalState;
        readonly MemoryPackReaderOptionalState? _threadStaticReaderOptionalState;

        internal StateSnapshot(bool resetReaderState, bool resetWriterState)
        {
            _resetReaderState = resetReaderState;
            _resetWriterState = resetWriterState;

            if (resetReaderState)
            {
                _threadStaticReaderOptionalState = threadStaticReaderOptionalState;
                threadStaticReaderOptionalState = null;

            }

            if (resetWriterState)
            {
                _threadStaticState = threadStaticState;
                threadStaticState = null;
                _threadStaticWriterOptionalState = threadStaticWriterOptionalState;
                threadStaticWriterOptionalState = null;
            }
        }

        public void Dispose()
        {
            if (_resetReaderState)
            {
                threadStaticReaderOptionalState = _threadStaticReaderOptionalState;
            }

            if (_resetWriterState)
            {
                threadStaticState = _threadStaticState;
                threadStaticWriterOptionalState = _threadStaticWriterOptionalState;
            }
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackSerializerOptions.cs
================================================
﻿namespace MemoryPack
{
    public record MemoryPackSerializerOptions
    {
        // Default is Utf8
        public static readonly MemoryPackSerializerOptions Default = new MemoryPackSerializerOptions { StringEncoding = StringEncoding.Utf8 };

        public static readonly MemoryPackSerializerOptions Utf8 = Default with { StringEncoding = StringEncoding.Utf8 };
        public static readonly MemoryPackSerializerOptions Utf16 = Default with { StringEncoding = StringEncoding.Utf16 };

        public StringEncoding StringEncoding { get; init; }
        public IServiceProvider? ServiceProvider { get; init; }
    }

    public enum StringEncoding : byte
    {
        Utf16,
        Utf8,
    }
}

#if !NET5_0_OR_GREATER

namespace System.Runtime.CompilerServices
{
    internal sealed class IsExternalInit
    {
    }
}

#endif



================================================
FILE: src/MemoryPack.Core/MemoryPackWriter.cs
================================================
﻿using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
#if NET7_0_OR_GREATER
using System.Text.Unicode;
#endif

namespace MemoryPack;

#if NET7_0_OR_GREATER
using static MemoryMarshal;
#else
using static MemoryPack.Internal.MemoryMarshalEx;
#endif

[StructLayout(LayoutKind.Auto)]
public ref partial struct MemoryPackWriter<TBufferWriter>
#if NET7_0_OR_GREATER
    where TBufferWriter : IBufferWriter<byte>
#else
    where TBufferWriter : class, IBufferWriter<byte>
#endif
{
    const int DepthLimit = 1000;

#if NET7_0_OR_GREATER
    ref TBufferWriter bufferWriter;
    ref byte bufferReference;
#else
    TBufferWriter bufferWriter;
    Span<byte> bufferReference;
#endif
    int bufferLength;
    int advancedCount;
    int depth; // check recursive serialize
    int writtenCount;
    readonly bool serializeStringAsUtf8;
    readonly MemoryPackWriterOptionalState optionalState;

    public int WrittenCount => writtenCount;
    public int BufferLength => bufferLength;
    public MemoryPackWriterOptionalState OptionalState => optionalState;
    public MemoryPackSerializerOptions Options => optionalState.Options;

    public MemoryPackWriter(ref TBufferWriter writer, MemoryPackWriterOptionalState optionalState)
    {
#if NET7_0_OR_GREATER
        this.bufferWriter = ref writer;
        this.bufferReference = ref Unsafe.NullRef<byte>();
#else
        this.bufferWriter = writer;
        this.bufferReference = default;
#endif
        this.bufferLength = 0;
        this.advancedCount = 0;
        this.writtenCount = 0;
        this.depth = 0;
        this.serializeStringAsUtf8 = optionalState.Options.StringEncoding == StringEncoding.Utf8;
        this.optionalState = optionalState;
    }

    // optimized ctor, avoid first GetSpan call if we can.
    public MemoryPackWriter(ref TBufferWriter writer, byte[] firstBufferOfWriter, MemoryPackWriterOptionalState optionalState)
    {
#if NET7_0_OR_GREATER
        this.bufferWriter = ref writer;
        this.bufferReference = ref GetArrayDataReference(firstBufferOfWriter);
#else
        this.bufferWriter = writer;
        this.bufferReference = firstBufferOfWriter.AsSpan();
#endif
        this.bufferLength = firstBufferOfWriter.Length;
        this.advancedCount = 0;
        this.writtenCount = 0;
        this.depth = 0;
        this.serializeStringAsUtf8 = optionalState.Options.StringEncoding == StringEncoding.Utf8;
        this.optionalState = optionalState;
    }

    public MemoryPackWriter(ref TBufferWriter writer, Span<byte> firstBufferOfWriter, MemoryPackWriterOptionalState optionalState)
    {
#if NET7_0_OR_GREATER
        this.bufferWriter = ref writer;
        this.bufferReference = ref MemoryMarshal.GetReference(firstBufferOfWriter);
#else
        this.bufferWriter = writer;
        this.bufferReference = firstBufferOfWriter;
#endif
        this.bufferLength = firstBufferOfWriter.Length;
        this.advancedCount = 0;
        this.writtenCount = 0;
        this.depth = 0;
        this.serializeStringAsUtf8 = optionalState.Options.StringEncoding == StringEncoding.Utf8;
        this.optionalState = optionalState;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref byte GetSpanReference(int sizeHint)
    {
        if (bufferLength < sizeHint)
        {
            RequestNewBuffer(sizeHint);
        }

#if NET7_0_OR_GREATER
        return ref bufferReference;
#else
        return ref MemoryMarshal.GetReference(bufferReference);
#endif
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    void RequestNewBuffer(int sizeHint)
    {
        if (advancedCount != 0)
        {
            bufferWriter.Advance(advancedCount);
            advancedCount = 0;
        }
        var span = bufferWriter.GetSpan(sizeHint);
#if NET7_0_OR_GREATER
        bufferReference = ref MemoryMarshal.GetReference(span);
#else
        bufferReference = span;
#endif
        bufferLength = span.Length;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        if (count == 0) return;

        var rest = bufferLength - count;
        if (rest < 0)
        {
            MemoryPackSerializationException.ThrowInvalidAdvance();
        }

        bufferLength = rest;
#if NET7_0_OR_GREATER
        bufferReference = ref Unsafe.Add(ref bufferReference, count);
#else
        bufferReference = bufferReference.Slice(count);
#endif
        advancedCount += count;
        writtenCount += count;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Flush()
    {
        if (advancedCount != 0)
        {
            bufferWriter.Advance(advancedCount);
            advancedCount = 0;
        }
#if NET7_0_OR_GREATER
        bufferReference = ref Unsafe.NullRef<byte>();
#else
        bufferReference = default;
#endif
        bufferLength = 0;
        writtenCount = 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IMemoryPackFormatter GetFormatter(Type type)
    {
        return MemoryPackFormatterProvider.GetFormatter(type);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IMemoryPackFormatter<T> GetFormatter<T>()
    {
        return MemoryPackFormatterProvider.GetFormatter<T>();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetStringWriteLength(string? value)
    {
        if (value == null || value.Length == 0)
        {
            return 4;
        }

        if (serializeStringAsUtf8)
        {
            return Encoding.UTF8.GetByteCount(value) + 8;
        }
        else
        {
            return checked(value.Length * 2) + 4;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetUnmanageArrayWriteLength<T>(T[]? value)
        where T : unmanaged
    {
        if (value == null || value.Length == 0)
        {
            return 4;
        }

        return (Unsafe.SizeOf<T>() * value.Length) + 4;
    }

    // Write methods

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteObjectHeader(byte memberCount)
    {
        if (memberCount >= MemoryPackCode.Reserved1)
        {
            MemoryPackSerializationException.ThrowWriteInvalidMemberCount(memberCount);
        }
        GetSpanReference(1) = memberCount;
        Advance(1);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteNullObjectHeader()
    {
        GetSpanReference(1) = MemoryPackCode.NullObject;
        Advance(1);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteObjectReferenceId(uint referenceId)
    {
        GetSpanReference(1) = MemoryPackCode.ReferenceId;
        Advance(1);
        WriteVarInt(referenceId);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUnionHeader(ushort tag)
    {
        if (tag < MemoryPackCode.WideTag)
        {
            GetSpanReference(1) = (byte)tag;
            Advance(1);
        }
        else
        {
            ref var spanRef = ref GetSpanReference(3);
            Unsafe.WriteUnaligned(ref spanRef, MemoryPackCode.WideTag);
            Unsafe.WriteUnaligned(ref Unsafe.Add(ref spanRef, 1), tag);
            Advance(3);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteNullUnionHeader()
    {
        WriteNullObjectHeader();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteCollectionHeader(int length)
    {
        Unsafe.WriteUnaligned(ref GetSpanReference(4), length);
        Advance(4);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteNullCollectionHeader()
    {
        Unsafe.WriteUnaligned(ref GetSpanReference(4), MemoryPackCode.NullCollection);
        Advance(4);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteString(string? value)
    {
        if (serializeStringAsUtf8)
        {
            WriteUtf8(value);
        }
        else
        {
            WriteUtf16(value);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUtf16(string? value)
    {
        if (value == null)
        {
            WriteNullCollectionHeader();
            return;
        }

        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        var copyByteCount = checked(value.Length * 2);

        ref var dest = ref GetSpanReference(copyByteCount + 4);
        Unsafe.WriteUnaligned(ref dest, value.Length);

#if NET7_0_OR_GREATER
        ref var src = ref Unsafe.As<char, byte>(ref Unsafe.AsRef(in value.GetPinnableReference()));
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)copyByteCount);
#else
        MemoryMarshal.AsBytes(value.AsSpan()).CopyTo(MemoryMarshal.CreateSpan(ref Unsafe.Add(ref dest, 4), copyByteCount));
#endif

        Advance(copyByteCount + 4);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUtf16(ReadOnlySpan<char> value)
    {
        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        var copyByteCount = checked(value.Length * 2);

        ref var dest = ref GetSpanReference(copyByteCount + 4);
        Unsafe.WriteUnaligned(ref dest, value.Length);
        MemoryMarshal.AsBytes(value).CopyTo(MemoryMarshal.CreateSpan(ref Unsafe.Add(ref dest, 4), copyByteCount));
        Advance(copyByteCount + 4);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUtf8(string? value)
    {
        if (value == null)
        {
            WriteNullCollectionHeader();
            return;
        }

        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)

        var source = value.AsSpan();

        // UTF8.GetMaxByteCount -> (length + 1) * 3
        var maxByteCount = (source.Length + 1) * 3;

        ref var destPointer = ref GetSpanReference(maxByteCount + 8); // header

        // write utf16-length
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref destPointer, 4), source.Length);

        var dest = MemoryMarshal.CreateSpan(ref Unsafe.Add(ref destPointer, 8), maxByteCount);
#if NET7_0_OR_GREATER
        var status = Utf8.FromUtf16(source, dest, out var _, out var bytesWritten, replaceInvalidSequences: false);
        if (status != OperationStatus.Done)
        {
            MemoryPackSerializationException.ThrowFailedEncoding(status);
        }
#else
        var bytesWritten = Encoding.UTF8.GetBytes(value, dest);
#endif

        // write written utf8-length in header, that is ~length
        Unsafe.WriteUnaligned(ref destPointer, ~bytesWritten);
        Advance(bytesWritten + 8); // + header
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUtf8(ReadOnlySpan<byte> utf8Value, int utf16Length = -1)
    {
        if (utf8Value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)

        ref var destPointer = ref GetSpanReference(utf8Value.Length + 8); // header

        Unsafe.WriteUnaligned(ref destPointer, ~utf8Value.Length);
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref destPointer, 4), utf16Length);

        var dest = MemoryMarshal.CreateSpan(ref Unsafe.Add(ref destPointer, 8), utf8Value.Length);
        utf8Value.CopyTo(dest);

        Advance(utf8Value.Length + 8);
    }

#if NET7_0_OR_GREATER

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WritePackable<T>(scoped in T? value)
        where T : IMemoryPackable<T>
    {
        depth++;
        if (depth == DepthLimit) MemoryPackSerializationException.ThrowReachedDepthLimit(typeof(T));
        T.Serialize(ref this, ref Unsafe.AsRef(in value));
        depth--;
    }

#else

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WritePackable<T>(scoped in T? value)
        where T : IMemoryPackable<T>
    {
        WriteValue(value);
    }

#endif

    // non packable, get formatter dynamically.
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteValue<T>(scoped in T? value)
    {
        depth++;
        if (depth == DepthLimit) MemoryPackSerializationException.ThrowReachedDepthLimit(typeof(T));
        GetFormatter<T>().Serialize(ref this, ref Unsafe.AsRef(in value));
        depth--;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteValue(Type type, object? value)
    {
        depth++;
        if (depth == DepthLimit) MemoryPackSerializationException.ThrowReachedDepthLimit(type);
        GetFormatter(type).Serialize(ref this, ref value);
        depth--;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteValueWithFormatter<TFormatter, T>(TFormatter formatter, scoped in T? value)
        where TFormatter : IMemoryPackFormatter<T>
    {
        depth++;
        formatter.Serialize(ref this, ref Unsafe.AsRef(in value));
        depth--;
    }

    #region WriteArray/Span

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteArray<T>(T?[]? value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedArray(value);
            return;
        }

        if (value == null)
        {
            WriteNullCollectionHeader();
            return;
        }

        var formatter = GetFormatter<T>();
        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            formatter.Serialize(ref this, ref value[i]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteSpan<T>(scoped Span<T?> value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedSpan(value);
            return;
        }

        var formatter = GetFormatter<T>();
        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            formatter.Serialize(ref this, ref value[i]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteSpan<T>(scoped ReadOnlySpan<T?> value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedSpan(value);
            return;
        }

        var formatter = GetFormatter<T>();
        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            formatter.Serialize(ref this, ref Unsafe.AsRef(in value[i]));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WritePackableArray<T>(T?[]? value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        WriteArray(value);
        return;
#else

        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedArray(value);
            return;
        }

        if (value == null)
        {
            WriteNullCollectionHeader();
            return;
        }

        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            T.Serialize(ref this, ref value[i]);
        }
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WritePackableSpan<T>(scoped Span<T?> value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        WriteSpan(value);
        return;
#else
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedSpan(value);
            return;
        }

        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            T.Serialize(ref this, ref value[i]);
        }
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WritePackableSpan<T>(scoped ReadOnlySpan<T?> value)
        where T : IMemoryPackable<T>
    {
#if !NET7_0_OR_GREATER
        WriteSpan(value);
        return;
#else
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            DangerousWriteUnmanagedSpan(value);
            return;
        }

        WriteCollectionHeader(value.Length);
        for (int i = 0; i < value.Length; i++)
        {
            T.Serialize(ref this, ref Unsafe.AsRef(in value[i]));
        }
#endif
    }

    #endregion

    #region WriteUnmanagedArray/Span

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUnmanagedArray<T>(T[]? value)
        where T : unmanaged
    {
        DangerousWriteUnmanagedArray(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUnmanagedSpan<T>(scoped Span<T> value)
        where T : unmanaged
    {
        DangerousWriteUnmanagedSpan(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteUnmanagedSpan<T>(scoped ReadOnlySpan<T> value)
        where T : unmanaged
    {
        DangerousWriteUnmanagedSpan(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DangerousWriteUnmanagedArray<T>(T[]? value)
    {
        if (value == null)
        {
            WriteNullCollectionHeader();
            return;
        }
        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        var srcLength = Unsafe.SizeOf<T>() * value.Length;
        var allocSize = srcLength + 4;

        ref var dest = ref GetSpanReference(allocSize);
        ref var src = ref Unsafe.As<T, byte>(ref GetArrayDataReference(value));

        Unsafe.WriteUnaligned(ref dest, value.Length);
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)srcLength);

        Advance(allocSize);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DangerousWriteUnmanagedSpan<T>(scoped Span<T> value)
    {
        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        var srcLength = Unsafe.SizeOf<T>() * value.Length;
        var allocSize = srcLength + 4;

        ref var dest = ref GetSpanReference(allocSize);
        ref var src = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value));

        Unsafe.WriteUnaligned(ref dest, value.Length);
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)srcLength);

        Advance(allocSize);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DangerousWriteUnmanagedSpan<T>(scoped ReadOnlySpan<T> value)
    {
        if (value.Length == 0)
        {
            WriteCollectionHeader(0);
            return;
        }

        var srcLength = Unsafe.SizeOf<T>() * value.Length;
        var allocSize = srcLength + 4;

        ref var dest = ref GetSpanReference(allocSize);
        ref var src = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value));

        Unsafe.WriteUnaligned(ref dest, value.Length);
        Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)srcLength);

        Advance(allocSize);
    }

    #endregion


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WriteSpanWithoutLengthHeader<T>(scoped ReadOnlySpan<T?> value)
    {
        if (value.Length == 0) return;

        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            var srcLength = Unsafe.SizeOf<T>() * value.Length;
            ref var dest = ref GetSpanReference(srcLength);
            ref var src = ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)!);

            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)srcLength);

            Advance(srcLength);
            return;
        }
        else
        {
            var formatter = GetFormatter<T>();
            for (int i = 0; i < value.Length; i++)
            {
                formatter.Serialize(ref this, ref Unsafe.AsRef(in value[i]));
            }
        }
    }
}



================================================
FILE: src/MemoryPack.Core/MemoryPackWriter.Unmanaged.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    string MakeT(int count) => string.Join(", ", Enumerable.Range(1, count).Select(x => $"T{x}"));
    string MakeArgs(int count) => string.Join(", ", Enumerable.Range(1, count).Select(x => $"scoped in T{x} value{x}"));
    string MakeWhere(int count) => string.Join("\r\n        ", Enumerable.Range(1, count).Select(x => $"where T{x} : unmanaged"));
    string MakeSize(int count) => string.Join(" + ", Enumerable.Range(1, count).Select(x => $"Unsafe.SizeOf<T{x}>()"));
#>
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack;

public ref partial struct MemoryPackWriter<TBufferWriter>
{
<# foreach(var dangerous in new[] { false, true }) { #>
<# for(var i = 1; i < 16; i++ ) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void <#= dangerous ? "Dangerous" : "" #>WriteUnmanaged<<#= MakeT(i) #>>(<#= MakeArgs(i) #>)
<# if(!dangerous) { #>
        <#= MakeWhere(i) #>
<# } #>
    {
        var size = <#= MakeSize(i) #>;
        ref var spanRef = ref GetSpanReference(size);
        Unsafe.WriteUnaligned(ref spanRef, value1);
<# for(var j = 2; j <= i; j++) { #>
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref spanRef, <#= MakeSize(j - 1) #>), value<#= j #>);
<# } #>
        Advance(size);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void <#= dangerous ? "Dangerous" : "" #>WriteUnmanagedWithObjectHeader<<#= MakeT(i) #>>(byte propertyCount, <#= MakeArgs(i) #>)
<# if(!dangerous) { #>
        <#= MakeWhere(i) #>
<# } #>
    {
        var size = <#= MakeSize(i) #> + 1;
        ref var spanRef = ref GetSpanReference(size);
        Unsafe.WriteUnaligned(ref spanRef, propertyCount);
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref spanRef, 1), value1);
<# for(var j = 2; j <= i; j++) { #>
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref spanRef, <#= MakeSize(j - 1) #> + 1), value<#= j #>);
<# } #>
        Advance(size);
    }

<# } } #>
}



================================================
FILE: src/MemoryPack.Core/MemoryPackWriterOptionalState.cs
================================================
﻿using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

namespace MemoryPack;

public static class MemoryPackWriterOptionalStatePool
{
    static readonly ConcurrentQueue<MemoryPackWriterOptionalState> queue = new ConcurrentQueue<MemoryPackWriterOptionalState>();

    public static MemoryPackWriterOptionalState Rent(MemoryPackSerializerOptions? options)
    {
        if (!queue.TryDequeue(out var state))
        {
            state = new MemoryPackWriterOptionalState();
        }

        state.Init(options);
        return state;
    }

    internal static void Return(MemoryPackWriterOptionalState state)
    {
        state.Reset();
        queue.Enqueue(state);
    }
}

public sealed class MemoryPackWriterOptionalState : IDisposable
{
    internal static readonly MemoryPackWriterOptionalState NullState = new MemoryPackWriterOptionalState(true);

    uint nextId;
    readonly Dictionary<object, uint> objectToRef;

    public MemoryPackSerializerOptions Options { get; private set; }

    internal MemoryPackWriterOptionalState()
    {
        objectToRef = new Dictionary<object, uint>(ReferenceEqualityComparer.Instance);
        Options = null!;
        nextId = 0;
    }

    MemoryPackWriterOptionalState(bool _)
    {
        objectToRef = null!;
        Options = MemoryPackSerializerOptions.Default;
        nextId = 0;
    }

    internal void Init(MemoryPackSerializerOptions? options)
    {
        Options = options ?? MemoryPackSerializerOptions.Default;
    }

    public void Reset()
    {
        objectToRef.Clear();
        Options = null!;
        nextId = 0;
    }

    public (bool existsReference, uint id) GetOrAddReference(object value)
    {
#if NET7_0_OR_GREATER
        ref var id = ref CollectionsMarshal.GetValueRefOrAddDefault(objectToRef, value, out var exists);
        if (exists)
        {
            return (true, id);
        }
        else
        {
            id = nextId++;
            return (false, id);
        }
#else
        if (objectToRef.TryGetValue(value, out var id))
        {
            return (true, id);
        }
        else
        {
            id = nextId++;
            objectToRef.Add(value, id);
            return (false, id);
        }
#endif
    }

    void IDisposable.Dispose()
    {
        MemoryPackWriterOptionalStatePool.Return(this);
    }

    // ReferenceEqualityComparer is exsits in .NET 6 but NetStandard 2.1 does not.
    sealed class ReferenceEqualityComparer : IEqualityComparer<object>
    {
        ReferenceEqualityComparer() { }

        public static ReferenceEqualityComparer Instance { get; } = new ReferenceEqualityComparer();

        public new bool Equals(object? x, object? y) => ReferenceEquals(x, y);

        public int GetHashCode(object obj)
        {
            return RuntimeHelpers.GetHashCode(obj);
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Compression/BitPackFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;

#if NET7_0_OR_GREATER
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
#endif

namespace MemoryPack.Compression;

[Preserve]
public sealed class BitPackFormatter : MemoryPackFormatter<bool[]>
{
    public static readonly BitPackFormatter Default = new BitPackFormatter();

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref bool[]? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }
        writer.WriteCollectionHeader(value.Length);
        if (value.Length == 0)
        {
            return;
        }

        var data = 0;
#if NET7_0_OR_GREATER
        ref var item = ref MemoryMarshal.GetArrayDataReference(value);
#else
        ref var item = ref value[0];
#endif
        ref var end = ref Unsafe.Add(ref item, value.Length);

#if NET7_0_OR_GREATER
        if (value.Length >= 32)
        {
            ref var loopEnd = ref Unsafe.Subtract(ref end, 32);
            if (Vector256.IsHardwareAccelerated)
            {
                while (!Unsafe.IsAddressGreaterThan(ref item, ref loopEnd))
                {
                    var vector = Vector256.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item));
                    // false -> 1 true -> 0
                    data = (int)Vector256.Equals(vector, Vector256<byte>.Zero).ExtractMostSignificantBits();
                    writer.WriteUnmanaged(~data);
                    item = ref Unsafe.Add(ref item, 32);
                }
            }
            else if (Vector128.IsHardwareAccelerated)
            {
                while (!Unsafe.IsAddressGreaterThan(ref item, ref loopEnd))
                {
                    var bits0 = (ushort)Vector128.Equals(Vector128.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item)), Vector128<byte>.Zero).ExtractMostSignificantBits();
                    var bits1 = (ushort)Vector128.Equals(Vector128.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item), 16), Vector128<byte>.Zero).ExtractMostSignificantBits();
                    data = bits0 | (bits1 << 16);
                    writer.WriteUnmanaged(~data);
                    item = ref Unsafe.Add(ref item, 32);
                }
            }
            else if (Vector64.IsHardwareAccelerated)
            {
                while (!Unsafe.IsAddressGreaterThan(ref item, ref loopEnd))
                {
                    var bits0 = (byte)Vector64.Equals(Vector64.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item)), Vector64<byte>.Zero).ExtractMostSignificantBits();
                    var bits1 = (byte)Vector64.Equals(Vector64.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item), 8), Vector64<byte>.Zero).ExtractMostSignificantBits();
                    var bits2 = (byte)Vector64.Equals(Vector64.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item), 16), Vector64<byte>.Zero).ExtractMostSignificantBits();
                    var bits3 = (byte)Vector64.Equals(Vector64.LoadUnsafe(ref Unsafe.As<bool, byte>(ref item), 24), Vector64<byte>.Zero).ExtractMostSignificantBits();
                    data = bits0 | (bits1 << 8) | (bits2 << 16) | (bits3 << 24);
                    writer.WriteUnmanaged(~data);
                    item = ref Unsafe.Add(ref item, 32);
                }
            }

            data = 0;
        }
#endif
        var bit = 0;
        while (Unsafe.IsAddressLessThan(ref item, ref end))
        {
            Set(ref data, bit, item);

            item = ref Unsafe.Add(ref item, 1);
            bit += 1;

            if (bit == 32)
            {
                writer.WriteUnmanaged(data);
                data = 0;
                bit = 0;
            }
        }

        if (bit != 0)
        {
            writer.WriteUnmanaged(data);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref bool[]? value)
    {
        if (!reader.DangerousTryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (length == 0)
        {
            value = Array.Empty<bool>();
            return;
        }

        var readCount = ((length - 1) / 32) + 1;
        var requireSize = readCount * 4;
        if (reader.Remaining < requireSize)
        {
            MemoryPackSerializationException.ThrowInsufficientBufferUnless(length);
        }

        if (value == null || value.Length != length)
        {
            value = new bool[length];
        }

        var bit = 0;
        var data = 0;
        for (int i = 0; i < value.Length; i++)
        {
            if (bit == 0)
            {
                reader.ReadUnmanaged(out data);
            }

            value[i] = Get(data, bit);

            bit += 1;

            if (bit == 32)
            {
                data = 0;
                bit = 0;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Get(int data, int index)
    {
        return (data & (1 << index)) != 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(ref int data, int index, bool value)
    {
        int bitMask = 1 << index;
        if (value)
        {
            data |= bitMask;
        }
        else
        {
            data &= ~bitMask;
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Compression/BrotliCompressor.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;
using System.IO.Compression;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Compression;

#if !NET7_0_OR_GREATER
#pragma warning disable CS8602
#endif

public
#if NET7_0_OR_GREATER
    struct
#else
    class
#endif
    BrotliCompressor : IBufferWriter<byte>, IDisposable
{
    ReusableLinkedArrayBufferWriter? bufferWriter;
    readonly int quality;
    readonly int window;

#if NET7_0_OR_GREATER

    public BrotliCompressor()
        : this(CompressionLevel.Fastest)
    {

    }

#endif

    public BrotliCompressor(CompressionLevel compressionLevel)
        : this(BrotliUtils.GetQualityFromCompressionLevel(compressionLevel), BrotliUtils.WindowBits_Default)
    {

    }

    public BrotliCompressor(CompressionLevel compressionLevel, int window)
        : this(BrotliUtils.GetQualityFromCompressionLevel(compressionLevel), window)
    {

    }

    public BrotliCompressor(int quality = 1, int window = 22)
    {
        this.bufferWriter = ReusableLinkedArrayBufferWriterPool.Rent();
        this.quality = quality;
        this.window = window;
    }

    void IBufferWriter<byte>.Advance(int count)
    {
        ThrowIfDisposed();
        bufferWriter.Advance(count);
    }

    Memory<byte> IBufferWriter<byte>.GetMemory(int sizeHint)
    {
        ThrowIfDisposed();
        return bufferWriter.GetMemory(sizeHint);
    }

    Span<byte> IBufferWriter<byte>.GetSpan(int sizeHint)
    {
        ThrowIfDisposed();
        return bufferWriter.GetSpan(sizeHint);
    }

    public int GetMaxCompressedLength()
    {
        ThrowIfDisposed();
        return BrotliUtils.BrotliEncoderMaxCompressedSize(bufferWriter.TotalWritten);
    }

    public byte[] ToArray()
    {
        ThrowIfDisposed();

        using var encoder = new BrotliEncoder(quality, window);

        var maxLength = BrotliUtils.BrotliEncoderMaxCompressedSize(bufferWriter.TotalWritten);

        var finalBuffer = ArrayPool<byte>.Shared.Rent(maxLength);
        try
        {
            var writtenCount = 0;
            var destination = finalBuffer.AsSpan(0, maxLength);
            foreach (var source in bufferWriter)
            {
                var status = encoder.Compress(source.Span, destination, out var bytesConsumed, out var bytesWritten, isFinalBlock: false);
                if (status != OperationStatus.Done)
                {
                    MemoryPackSerializationException.ThrowCompressionFailed(status);
                }

                if (bytesConsumed != source.Span.Length)
                {
                    MemoryPackSerializationException.ThrowCompressionFailed();
                }

                if (bytesWritten > 0)
                {
                    destination = destination.Slice(bytesWritten);
                    writtenCount += bytesWritten;
                }
            }

            // call BrotliEncoderOperation.Finish
            var finalStatus = encoder.Compress(ReadOnlySpan<byte>.Empty, destination, out var consumed, out var written, isFinalBlock: true);
            writtenCount += written;

            return finalBuffer.AsSpan(0, writtenCount).ToArray();
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(finalBuffer);
        }
    }

    public void CopyTo<TBufferWriter>(in TBufferWriter destBufferWriter)
        where TBufferWriter : IBufferWriter<byte>
    {
        ThrowIfDisposed();

        var encoder = new BrotliEncoder(quality, window);
        try
        {
            var writtenNotAdvanced = 0;
            foreach (var item in bufferWriter)
            {
                writtenNotAdvanced = CompressCore(ref encoder, item.Span, ref Unsafe.AsRef(in destBufferWriter), initialLength: null, isFinalBlock: false);
            }

            // call BrotliEncoderOperation.Finish
            var finalBlockLength = (writtenNotAdvanced == 0) ? null : (int?)(writtenNotAdvanced + 10);
            CompressCore(ref encoder, ReadOnlySpan<byte>.Empty, ref Unsafe.AsRef(in destBufferWriter), initialLength: finalBlockLength, isFinalBlock: true);
        }
        finally
        {
            encoder.Dispose();
        }
    }

    public async ValueTask CopyToAsync(Stream stream, int bufferSize = 65535, CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        using var encoder = new BrotliEncoder(quality, window);

        var buffer = ArrayPool<byte>.Shared.Rent(bufferSize);
        try
        {
            foreach (var item in bufferWriter)
            {
                var source = item;
                var lastResult = OperationStatus.DestinationTooSmall;
                while (lastResult == OperationStatus.DestinationTooSmall)
                {
                    lastResult = encoder.Compress(source.Span, buffer, out int bytesConsumed, out int bytesWritten, isFinalBlock: false);
                    if (lastResult == OperationStatus.InvalidData) MemoryPackSerializationException.ThrowCompressionFailed();
                    if (bytesWritten > 0)
                    {
                        await stream.WriteAsync(buffer.AsMemory(0, bytesWritten), cancellationToken).ConfigureAwait(false);
                    }
                    if (bytesConsumed > 0)
                    {
                        source = source.Slice(bytesConsumed);
                    }
                }
            }

            // call BrotliEncoderOperation.Finish
            var finalStatus = OperationStatus.DestinationTooSmall;
            while (finalStatus == OperationStatus.DestinationTooSmall)
            {
                finalStatus = encoder.Compress(ReadOnlySpan<byte>.Empty, buffer, out var consumed, out var written, isFinalBlock: true);
                if (written > 0)
                {
                    await stream.WriteAsync(buffer.AsMemory(0, written), cancellationToken).ConfigureAwait(false);
                }
            }
            if (finalStatus != OperationStatus.Done)
            {
                MemoryPackSerializationException.ThrowCompressionFailed(finalStatus);
            }
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(buffer);
        }
    }

    public void CopyTo<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> memoryPackWriter)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        ThrowIfDisposed();

        var encoder = new BrotliEncoder(quality, window);
        try
        {
            var bytesWritten = 0;
            foreach (var item in bufferWriter)
            {
                var span = item.Span;
                if (span.Length <= 0) continue;
                bytesWritten += CompressCore(ref encoder, span, ref memoryPackWriter, initialLength: null, isFinalBlock: false);
            }

            // call BrotliEncoderOperation.Finish
            var finalBlockMaxLength = BrotliUtils.BrotliEncoderMaxCompressedSize(bytesWritten) - bytesWritten;
            CompressCore(ref encoder, ReadOnlySpan<byte>.Empty, ref memoryPackWriter, initialLength: finalBlockMaxLength, isFinalBlock: true);
        }
        finally
        {
            encoder.Dispose();
        }
    }

    static int CompressCore<TBufferWriter>(ref BrotliEncoder encoder, ReadOnlySpan<byte> source, ref TBufferWriter destBufferWriter, int? initialLength, bool isFinalBlock)
        where TBufferWriter : IBufferWriter<byte>
    {
        var writtenNotAdvanced = 0;

        var lastResult = OperationStatus.DestinationTooSmall;
        while (lastResult == OperationStatus.DestinationTooSmall)
        {
            var dest = destBufferWriter.GetSpan(initialLength ?? source.Length);

            lastResult = encoder.Compress(source, dest, out int bytesConsumed, out int bytesWritten, isFinalBlock: isFinalBlock);
            writtenNotAdvanced += bytesConsumed;

            if (lastResult == OperationStatus.InvalidData) MemoryPackSerializationException.ThrowCompressionFailed();
            if (bytesWritten > 0)
            {
                destBufferWriter.Advance(bytesWritten);
                writtenNotAdvanced = 0;
            }
            if (bytesConsumed > 0)
            {
                source = source.Slice(bytesConsumed);
            }
        }

        return writtenNotAdvanced;
    }

    static int CompressCore<TBufferWriter>(ref BrotliEncoder encoder, ReadOnlySpan<byte> source, ref MemoryPackWriter<TBufferWriter> destBufferWriter, int? initialLength, bool isFinalBlock)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        var totalWritten = 0;

        var lastResult = OperationStatus.DestinationTooSmall;

        var destLength = initialLength ?? BrotliUtils.BrotliEncoderMaxCompressedSize(source.Length);
        while (lastResult == OperationStatus.DestinationTooSmall)
        {
            ref var spanRef = ref destBufferWriter.GetSpanReference(destLength);
            var dest = MemoryMarshal.CreateSpan(ref spanRef, destBufferWriter.BufferLength);

            lastResult = encoder.Compress(source, dest, out int bytesConsumed, out int bytesWritten, isFinalBlock: isFinalBlock);
            totalWritten += bytesWritten;

            if (lastResult == OperationStatus.InvalidData) MemoryPackSerializationException.ThrowCompressionFailed();
            if (bytesWritten > 0)
            {
                destBufferWriter.Advance(bytesWritten);
            }
            if (bytesConsumed > 0)
            {
                source = source.Slice(bytesConsumed);
            }
        }

        return totalWritten;
    }

    public void Dispose()
    {
        if (bufferWriter == null) return;

        bufferWriter.Reset();
        ReusableLinkedArrayBufferWriterPool.Return(bufferWriter);
        bufferWriter = null!;
    }

#if NET7_0_OR_GREATER
    [MemberNotNull(nameof(bufferWriter))]
#endif
    void ThrowIfDisposed()
    {
        if (bufferWriter == null)
        {
            throw new ObjectDisposedException(null);
        }
    }
}

internal static partial class BrotliUtils
{
    public const int WindowBits_Min = 10;
    public const int WindowBits_Default = 22;
    public const int WindowBits_Max = 24;
    public const int Quality_Min = 0;
    public const int Quality_Default = 4;
    public const int Quality_Max = 11;
    public const int MaxInputSize = int.MaxValue - 515; // 515 is the max compressed extra bytes

    internal static int GetQualityFromCompressionLevel(CompressionLevel compressionLevel) =>
        compressionLevel switch
        {
            CompressionLevel.NoCompression => Quality_Min,
            CompressionLevel.Fastest => 1,
            CompressionLevel.Optimal => Quality_Default,
#if NET7_0_OR_GREATER
            CompressionLevel.SmallestSize => Quality_Max,
#endif
            _ => throw new ArgumentException()
        };


    // https://github.com/dotnet/runtime/issues/35142
    // BrotliEncoder.GetMaxCompressedLength is broken in .NET 7
    // port from encode.c https://github.com/google/brotli/blob/3914999fcc1fda92e750ef9190aa6db9bf7bdb07/c/enc/encode.c#L1200
    internal static int BrotliEncoderMaxCompressedSize(int input_size)
    {
        var num_large_blocks = input_size >> 14;
        var overhead = 2 + (4 * num_large_blocks) + 3 + 1;
        var result = input_size + overhead;
        if (input_size == 0) return 2;
        return (result < input_size) ? 0 : result;
    }
}



================================================
FILE: src/MemoryPack.Core/Compression/BrotliDecompressor.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Diagnostics;
using System.IO.Compression;

namespace MemoryPack.Compression;

public struct BrotliDecompressor : IDisposable
{
    ReusableReadOnlySequenceBuilder? sequenceBuilder;

    public ReadOnlySequence<byte> Decompress(ReadOnlySpan<byte> compressedSpan)
    {
        return Decompress(compressedSpan, out _);
    }

    public ReadOnlySequence<byte> Decompress(ReadOnlySpan<byte> compressedSpan, out int consumed)
    {
        if (sequenceBuilder != null)
        {
            MemoryPackSerializationException.ThrowAlreadyDecompressed();
        }

        sequenceBuilder = ReusableReadOnlySequenceBuilderPool.Rent();
        var decoder = new BrotliDecoder();
        try
        {
            var status = OperationStatus.DestinationTooSmall;
            DecompressCore(ref status, ref decoder, compressedSpan, out consumed);
            if (status == OperationStatus.NeedMoreData)
            {
                MemoryPackSerializationException.ThrowCompressionFailed(status);
            }
        }
        finally
        {
            decoder.Dispose();
        }

        return sequenceBuilder.Build();
    }

    public ReadOnlySequence<byte> Decompress(ReadOnlySequence<byte> compressedSequence)
    {
        return Decompress(compressedSequence, out _);
    }

    public ReadOnlySequence<byte> Decompress(ReadOnlySequence<byte> compressedSequence, out int consumed)
    {
        if (sequenceBuilder != null)
        {
            MemoryPackSerializationException.ThrowAlreadyDecompressed();
        }

        sequenceBuilder = ReusableReadOnlySequenceBuilderPool.Rent();
        var decoder = new BrotliDecoder();
        try
        {
            var status = OperationStatus.DestinationTooSmall;
            consumed = 0;
            foreach (var item in compressedSequence)
            {
                DecompressCore(ref status, ref decoder, item.Span, out var bytesConsumed);
                consumed += bytesConsumed;
            }

            if (status == OperationStatus.NeedMoreData)
            {
                MemoryPackSerializationException.ThrowCompressionFailed(status);
            }
        }
        finally
        {
            decoder.Dispose();
        }

        return sequenceBuilder.Build();
    }

    void DecompressCore(ref OperationStatus status, ref BrotliDecoder decoder, ReadOnlySpan<byte> source, out int consumed)
    {
        Debug.Assert(sequenceBuilder != null);
        consumed = 0;

        byte[]? buffer = null;
        status = OperationStatus.DestinationTooSmall;
        var nextCapacity = source.Length;
        while (status == OperationStatus.DestinationTooSmall)
        {
            if (buffer == null)
            {
                nextCapacity = GetDoubleCapacity(nextCapacity);
                buffer = ArrayPool<byte>.Shared.Rent(nextCapacity);
            }

            status = decoder.Decompress(source, buffer, out var bytesConsumed, out var bytesWritten);
            consumed += bytesConsumed;

            if (status == OperationStatus.InvalidData)
            {
                MemoryPackSerializationException.ThrowCompressionFailed(status);
            }

            if (status == OperationStatus.NeedMoreData)
            {
                if (bytesWritten > 0)
                {
                    sequenceBuilder.Add(buffer.AsMemory(0, bytesWritten), true);
                }
                if (bytesConsumed > 0)
                {
                    source = source.Slice(bytesConsumed);
                }
                if (source.Length != 0)
                {
                    // not consumed source fully
                    MemoryPackSerializationException.ThrowCompressionFailed();
                }

                // continue for next sequence. 
                return;
            }

            if (bytesConsumed > 0)
            {
                source = source.Slice(bytesConsumed);
            }
            if (bytesWritten > 0)
            {
                sequenceBuilder.Add(buffer.AsMemory(0, bytesWritten), true);
                buffer = null;
            }
        }
    }

    public void Dispose()
    {
        if (sequenceBuilder != null)
        {
            ReusableReadOnlySequenceBuilderPool.Return(sequenceBuilder);
            sequenceBuilder = null;
        }
    }

    int GetDoubleCapacity(int length)
    {
        var newCapacity = unchecked(length * 2);
        if ((uint)newCapacity > int.MaxValue) newCapacity = int.MaxValue;
        return Math.Max(newCapacity, 4096);
    }
}



================================================
FILE: src/MemoryPack.Core/Compression/BrotliFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.IO.Compression;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Compression;

// serialize as (uncompressedLength, compressedLength, values...)

[Preserve]
public sealed class BrotliFormatter : MemoryPackFormatter<byte[]>
{
    internal const int DefaultDecompssionSizeLimit = 1024 * 1024 * 128; // 128MB

    public static readonly BrotliFormatter Default = new BrotliFormatter();

    readonly System.IO.Compression.CompressionLevel compressionLevel;
    readonly int window;
    readonly int decompressionSizeLimit;

    public BrotliFormatter()
        : this(System.IO.Compression.CompressionLevel.Fastest)
    {

    }

    public BrotliFormatter(System.IO.Compression.CompressionLevel compressionLevel)
        : this(compressionLevel, BrotliUtils.WindowBits_Default)
    {
    }

    public BrotliFormatter(System.IO.Compression.CompressionLevel compressionLevel, int window)
        : this(compressionLevel, window, DefaultDecompssionSizeLimit)
    {
    }

    public BrotliFormatter(System.IO.Compression.CompressionLevel compressionLevel, int window, int decompressionSizeLimit)
    {
        this.compressionLevel = compressionLevel;
        this.window = window;
        this.decompressionSizeLimit = decompressionSizeLimit;
    }

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref byte[]? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        if (value.Length == 0)
        {
            writer.WriteCollectionHeader(0);
            return;
        }

        var quality = BrotliUtils.GetQualityFromCompressionLevel(compressionLevel);

        using var encoder = new BrotliEncoder(quality, window);

        var maxLength = BrotliUtils.BrotliEncoderMaxCompressedSize(value.Length);

        ref var head = ref writer.GetSpanReference(maxLength + 8);

        var dest = MemoryMarshal.CreateSpan(ref Unsafe.Add(ref head, 8), maxLength);
        var status = encoder.Compress(value.AsSpan(), dest, out var bytesConsumed, out var bytesWritten, isFinalBlock: true);
        if (status != OperationStatus.Done)
        {
            MemoryPackSerializationException.ThrowCompressionFailed(status);
        }

        if (bytesConsumed != value.Length)
        {
            MemoryPackSerializationException.ThrowCompressionFailed();
        }

        // write to buffer header (uncompressedLength, compressedLength, values...)
        Unsafe.WriteUnaligned(ref head, value.Length);
        Unsafe.WriteUnaligned(ref Unsafe.Add(ref head, 4), bytesWritten);

        writer.Advance(bytesWritten + 8);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref byte[]? value)
    {
        var uncompressedLength = reader.ReadUnmanaged<int>();

        reader.DangerousReadUnmanagedSpanView<byte>(out var isNull, out var compressedBuffer);

        if (isNull)
        {
            value = null;
            return;
        }

        if (compressedBuffer.Length == 0)
        {
            value = Array.Empty<byte>();
            return;
        }

        // security, require to check length
        if (decompressionSizeLimit < uncompressedLength)
        {
            MemoryPackSerializationException.ThrowDecompressionSizeLimitExceeded(decompressionSizeLimit, uncompressedLength);
        }

        if (value == null || value.Length != uncompressedLength)
        {
            value = new byte[uncompressedLength];
        }

        using var decoder = new BrotliDecoder();

        var status = decoder.Decompress(compressedBuffer, value, out var bytesConsumed, out var bytesWritten);
        if (status != OperationStatus.Done)
        {
            MemoryPackSerializationException.ThrowCompressionFailed(status);
        }

        if (bytesConsumed != compressedBuffer.Length || bytesWritten != value.Length)
        {
            MemoryPackSerializationException.ThrowCompressionFailed();
        }
    }
}


[Preserve]
public sealed class BrotliFormatter<T> : MemoryPackFormatter<T>
{
    internal const int DefaultDecompssionSizeLimit = 1024 * 1024 * 128; // 128MB

    public static readonly BrotliFormatter Default = new BrotliFormatter();

    readonly System.IO.Compression.CompressionLevel compressionLevel;
    readonly int window;

    public BrotliFormatter()
        : this(System.IO.Compression.CompressionLevel.Fastest)
    {

    }

    public BrotliFormatter(System.IO.Compression.CompressionLevel compressionLevel)
        : this(compressionLevel, BrotliUtils.WindowBits_Default)
    {
    }

    public BrotliFormatter(System.IO.Compression.CompressionLevel compressionLevel, int window)
    {
        this.compressionLevel = compressionLevel;
        this.window = window;
    }

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        var compressor = new BrotliCompressor(compressionLevel, window);
        try
        {
            var coWriter = new MemoryPackWriter<BrotliCompressor>(ref compressor, writer.OptionalState);

            coWriter.WriteValue(value);
            coWriter.Flush();

            compressor.CopyTo(ref writer);
        }
        finally
        {
            compressor.Dispose();
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        using var decompressor = new BrotliDecompressor();

        reader.GetRemainingSource(out var singleSource, out var remainingSource);

        int consumed;
        ReadOnlySequence<byte> decompressedSource;
        if (singleSource.Length != 0)
        {
            decompressedSource = decompressor.Decompress(singleSource, out consumed);
        }
        else
        {
            decompressedSource = decompressor.Decompress(remainingSource, out consumed);
        }

        using var coReader = new MemoryPackReader(decompressedSource, reader.OptionalState);
        coReader.ReadValue(ref value);

        reader.Advance(consumed);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/ArrayFormatters.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;

// Array and Array-like type formatters
// T[]
// T[] where T: unmnaged
// Memory
// ReadOnlyMemory
// ArraySegment
// ReadOnlySequence

namespace MemoryPack
{
    public static partial class MemoryPackFormatterProvider
    {
        static readonly Dictionary<Type, Type> ArrayLikeFormatters = new Dictionary<Type, Type>(4)
        {
            // If T[], choose UnmanagedArrayFormatter or DangerousUnmanagedTypeArrayFormatter or ArrayFormatter
            { typeof(ArraySegment<>), typeof(ArraySegmentFormatter<>) },
            { typeof(Memory<>), typeof(MemoryFormatter<>) },
            { typeof(ReadOnlyMemory<>), typeof(ReadOnlyMemoryFormatter<>) },
            { typeof(ReadOnlySequence<>), typeof(ReadOnlySequenceFormatter<>) },
        };
    }
}

namespace MemoryPack.Formatters
{
    [Preserve]
    public sealed class UnmanagedArrayFormatter<T> : MemoryPackFormatter<T[]>
            where T : unmanaged
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T[]? value)
        {
            writer.WriteUnmanagedArray(value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref T[]? value)
        {
            reader.ReadUnmanagedArray<T>(ref value);
        }
    }

    [Preserve]
    public sealed class DangerousUnmanagedArrayFormatter<T> : MemoryPackFormatter<T[]>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T[]? value)
        {
            writer.DangerousWriteUnmanagedArray(value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref T[]? value)
        {
            reader.DangerousReadUnmanagedArray<T>(ref value);
        }
    }

    [Preserve]
    public sealed class ArrayFormatter<T> : MemoryPackFormatter<T?[]>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T?[]? value)
        {
            writer.WriteArray(value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref T?[]? value)
        {
            reader.ReadArray(ref value);
        }
    }

    [Preserve]
    public sealed class ArraySegmentFormatter<T> : MemoryPackFormatter<ArraySegment<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ArraySegment<T?> value)
        {
            writer.WriteSpan(value.AsMemory().Span);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ArraySegment<T?> value)
        {
            var array = reader.ReadArray<T>();
            value = (array == null) ? default : (ArraySegment<T?>)array;
        }
    }

    [Preserve]
    public sealed class MemoryFormatter<T> : MemoryPackFormatter<Memory<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Memory<T?> value)
        {
            writer.WriteSpan(value.Span);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Memory<T?> value)
        {
            value = reader.ReadArray<T>();
        }
    }

    [Preserve]
    public sealed class ReadOnlyMemoryFormatter<T> : MemoryPackFormatter<ReadOnlyMemory<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ReadOnlyMemory<T?> value)
        {
            writer.WriteSpan(value.Span);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ReadOnlyMemory<T?> value)
        {
            value = reader.ReadArray<T>();
        }
    }

    [Preserve]
    public sealed class ReadOnlySequenceFormatter<T> : MemoryPackFormatter<ReadOnlySequence<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ReadOnlySequence<T?> value)
        {
            if (value.IsSingleSegment)
            {
                writer.WriteSpan(value.FirstSpan);
                return;
            }

            writer.WriteCollectionHeader(checked((int)value.Length));
            foreach (var memory in value)
            {
                writer.WriteSpanWithoutLengthHeader(memory.Span);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ReadOnlySequence<T?> value)
        {
            var array = reader.ReadArray<T>();
            value = (array == null) ? default : new ReadOnlySequence<T?>(array);
        }
    }

    [Preserve]
    public sealed class MemoryPoolFormatter<T> : MemoryPackFormatter<Memory<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Memory<T?> value)
        {
            writer.WriteSpan(value.Span);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Memory<T?> value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = Memory<T?>.Empty;
                return;
            }

            var memory = ArrayPool<T?>.Shared.Rent(length).AsMemory(0, length);
            var span = memory.Span;
            reader.ReadSpanWithoutReadLengthHeader(length, ref span);
            value = memory;
        }
    }

    [Preserve]
    public sealed class ReadOnlyMemoryPoolFormatter<T> : MemoryPackFormatter<ReadOnlyMemory<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ReadOnlyMemory<T?> value)
        {
            writer.WriteSpan(value.Span);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ReadOnlyMemory<T?> value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = Memory<T?>.Empty;
                return;
            }

            var memory = ArrayPool<T?>.Shared.Rent(length).AsMemory(0, length);
            var span = memory.Span;
            reader.ReadSpanWithoutReadLengthHeader(length, ref span);
            value = memory;
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/BigIntegerFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class BigIntegerFormatter : MemoryPackFormatter<BigInteger>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref BigInteger value)
    {
#if !UNITY_2021_2_OR_NEWER
        Span<byte> temp = stackalloc byte[255];
        if (value.TryWriteBytes(temp, out var written))
        {
            writer.WriteUnmanagedSpan(temp.Slice(written));
            return;
        }
        else
#endif
        {
            var byteArray = value.ToByteArray();
            writer.WriteUnmanagedArray(byteArray);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref BigInteger value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        ref var src = ref reader.GetSpanReference(length);
        value = new BigInteger(MemoryMarshal.CreateReadOnlySpan(ref src, length));

        reader.Advance(length);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/BitArrayFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Collections;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class BitArrayFormatter : MemoryPackFormatter<BitArray>
{
    // serialize [m_length, m_array]

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref BitArray? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        ref var view = ref Unsafe.As<BitArray, BitArrayView>(ref value);

        writer.WriteUnmanagedWithObjectHeader(2, view.m_length);
        writer.WriteUnmanagedArray(view.m_array);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref BitArray? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 2) MemoryPackSerializationException.ThrowInvalidPropertyCount(2, count);

        reader.ReadUnmanaged(out int length);

        var bitArray = new BitArray(length, false); // create internal int[] and set m_length to length

        ref var view = ref Unsafe.As<BitArray, BitArrayView>(ref bitArray);
        reader.ReadUnmanagedArray(ref view.m_array!);

        value = bitArray;
    }
}

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
[Preserve]
internal class BitArrayView
{
    public int[] m_array;
    public int m_length;
    public int _version;
}



================================================
FILE: src/MemoryPack.Core/Formatters/CollectionFormatters.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Clear support collection formatters
// List, Stack, Queue, LinkedList, HashSet, PriorityQueue,
// ObservableCollection, Collection
// ConcurrentQueue, ConcurrentStack, ConcurrentBag
// Dictionary, SortedDictionary, SortedList, ConcurrentDictionary

// Not supported clear
// ReadOnlyCollection, ReadOnlyObservableCollection, BlockingCollection

namespace MemoryPack
{
    public static partial class MemoryPackFormatterProvider
    {
        static readonly Dictionary<Type, Type> CollectionFormatters = new Dictionary<Type, Type>(18)
        {
            { typeof(List<>), typeof(ListFormatter<>) },
            { typeof(Stack<>), typeof(StackFormatter<>) },
            { typeof(Queue<>), typeof(QueueFormatter<>) },
            { typeof(LinkedList<>), typeof(LinkedListFormatter<>) },
            { typeof(HashSet<>), typeof(HashSetFormatter<>) },
            { typeof(SortedSet<>), typeof(SortedSetFormatter<>) },
#if NET7_0_OR_GREATER
            { typeof(PriorityQueue<,>), typeof(PriorityQueueFormatter<,>) },
#endif
            { typeof(ObservableCollection<>), typeof(ObservableCollectionFormatter<>) },
            { typeof(Collection<>), typeof(CollectionFormatter<>) },
            { typeof(ConcurrentQueue<>), typeof(ConcurrentQueueFormatter<>) },
            { typeof(ConcurrentStack<>), typeof(ConcurrentStackFormatter<>) },
            { typeof(ConcurrentBag<>), typeof(ConcurrentBagFormatter<>) },
            { typeof(Dictionary<,>), typeof(DictionaryFormatter<,>) },
            { typeof(SortedDictionary<,>), typeof(SortedDictionaryFormatter<,>) },
            { typeof(SortedList<,>), typeof(SortedListFormatter<,>) },
            { typeof(ConcurrentDictionary<,>), typeof(ConcurrentDictionaryFormatter<,>) },
            { typeof(ReadOnlyCollection<>), typeof(ReadOnlyCollectionFormatter<>) },
            { typeof(ReadOnlyObservableCollection<>), typeof(ReadOnlyObservableCollectionFormatter<>) },
            { typeof(BlockingCollection<>), typeof(BlockingCollectionFormatter<>) },
        };
    }
}

namespace MemoryPack.Formatters
{
    [Preserve]
    public static class ListFormatter
    {
        [Preserve]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SerializePackable<T, TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, List<T?>? value)
            where T : IMemoryPackable<T>
#if NET7_0_OR_GREATER
            where TBufferWriter : IBufferWriter<byte>
#else
            where TBufferWriter : class, IBufferWriter<byte>
#endif
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

#if NET7_0_OR_GREATER
            writer.WritePackableSpan(CollectionsMarshal.AsSpan(value));
#else
            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
#endif
        }

        [Preserve]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static List<T?>? DeserializePackable<T>(ref MemoryPackReader reader)
            where T : IMemoryPackable<T>
        {
            List<T?>? value = default;
            DeserializePackable<T>(ref reader, ref value);
            return value;
        }

        [Preserve]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DeserializePackable<T>(ref MemoryPackReader reader, scoped ref List<T?>? value)
            where T : IMemoryPackable<T>
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new List<T?>(length);
            }
#if NET7_0_OR_GREATER
            else if (value.Count == length)
            {
                value.Clear();
            }

            var span = CollectionsMarshalEx.CreateSpan(value, length);
            reader.ReadPackableSpanWithoutReadLengthHeader(length, ref span);
#else
            else
            {
                value.Clear();
            }
            var formatter = reader.GetFormatter<T?>();
            for (var i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
#endif
        }
    }

    [Preserve]
    public sealed class ListFormatter<T> : MemoryPackFormatter<List<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref List<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }
#if NET7_0_OR_GREATER
            writer.WriteSpan(CollectionsMarshal.AsSpan(value));
#else
            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
#endif
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref List<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new List<T?>(length);
            }
#if NET7_0_OR_GREATER
            else if (value.Count == length)
            {
                value.Clear();
            }

            var span = CollectionsMarshalEx.CreateSpan(value, length);
            reader.ReadSpanWithoutReadLengthHeader(length, ref span);
#else
            else
            {
                value.Clear();
            }
            var formatter = reader.GetFormatter<T?>();
            for (var i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
#endif
        }
    }

    [Preserve]
    public sealed class StackFormatter<T> : MemoryPackFormatter<Stack<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Stack<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

#if NET7_0_OR_GREATER
            writer.WriteSpan(CollectionsMarshalEx.AsSpan(value));
#else
            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value.Reverse()) // serialize reverse order
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
#endif
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Stack<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new Stack<T?>(length);
            }
#if NET7_0_OR_GREATER
            else if (value.Count != length)
            {
                value.Clear();
            }

            var span = CollectionsMarshalEx.CreateSpan(value, length);
            reader.ReadSpanWithoutReadLengthHeader(length, ref span);
#else
            else
            {
                value.Clear();
            }
            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Push(v);
            }
#endif
        }
    }

    [Preserve]
    public sealed class QueueFormatter<T> : MemoryPackFormatter<Queue<T?>>
    {
        // Queue is circular buffer, can't optimize like List, Stack.

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Queue<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Queue<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new Queue<T?>(length);
            }
            else
            {
                value.Clear();
#if NET7_0_OR_GREATER
                value.EnsureCapacity(length);
#endif
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Enqueue(v);
            }
        }
    }

    [Preserve]
    public sealed class LinkedListFormatter<T> : MemoryPackFormatter<LinkedList<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref LinkedList<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref LinkedList<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new LinkedList<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.AddLast(v);
            }
        }
    }

    [Preserve]
    public sealed class HashSetFormatter<T> : MemoryPackFormatter<HashSet<T?>>
    {
        readonly IEqualityComparer<T?>? equalityComparer;

        public HashSetFormatter()
            : this(null)
        {
        }

        public HashSetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref HashSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref HashSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new HashSet<T?>(length, equalityComparer);
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }

    [Preserve]
    public sealed class SortedSetFormatter<T> : MemoryPackFormatter<SortedSet<T?>>
    {
        readonly IComparer<T?>? comparer;

        public SortedSetFormatter()
            : this(null)
        {
        }

        public SortedSetFormatter(IComparer<T?>? comparer)
        {
            this.comparer = comparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref SortedSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref SortedSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new SortedSet<T?>(comparer);
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }

#if NET7_0_OR_GREATER

    [Preserve]
    public sealed class PriorityQueueFormatter<TElement, TPriority> : MemoryPackFormatter<PriorityQueue<TElement?, TPriority?>>
    {
        static PriorityQueueFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<(TElement?, TPriority?)>())
            {
                MemoryPackFormatterProvider.Register(new ValueTupleFormatter<TElement?, TPriority?>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref PriorityQueue<TElement?, TPriority?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<(TElement?, TPriority?)>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value.UnorderedItems)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref PriorityQueue<TElement?, TPriority?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new PriorityQueue<TElement?, TPriority?>(length);
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<(TElement?, TPriority?)>();
            for (int i = 0; i < length; i++)
            {
                (TElement?, TPriority?) v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Enqueue(v.Item1, v.Item2);
            }
        }
    }

#endif

    [Preserve]
    public sealed class CollectionFormatter<T> : MemoryPackFormatter<Collection<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Collection<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Collection<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new Collection<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }

    [Preserve]
    public sealed class ObservableCollectionFormatter<T> : MemoryPackFormatter<ObservableCollection<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ObservableCollection<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ObservableCollection<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new ObservableCollection<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }

    [Preserve]
    public sealed class ConcurrentQueueFormatter<T> : MemoryPackFormatter<ConcurrentQueue<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ConcurrentQueue<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // note: serializing ConcurretnCollection(Queue/Stack/Bag/Dictionary) is not thread-safe.
            // operate Add/Remove in iterating in other thread, not guranteed correct result

            var formatter = writer.GetFormatter<T?>();
            var count = value.Count;
            writer.WriteCollectionHeader(count);
            var i = 0;
            foreach (var item in value)
            {
                i++;
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }

            if (i != count) MemoryPackSerializationException.ThrowInvalidConcurrrentCollectionOperation();
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ConcurrentQueue<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new ConcurrentQueue<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Enqueue(v);
            }
        }
    }

    [Preserve]
    public sealed class ConcurrentStackFormatter<T> : MemoryPackFormatter<ConcurrentStack<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ConcurrentStack<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // reverse order in serialize
            var count = value.Count;
            T?[] rentArray = ArrayPool<T?>.Shared.Rent(count);
            try
            {
                var i = 0;
                foreach (var item in value)
                {
                    rentArray[i++] = item;
                }
                if (i != count) MemoryPackSerializationException.ThrowInvalidConcurrrentCollectionOperation();

                var formatter = writer.GetFormatter<T?>();
                writer.WriteCollectionHeader(count);
                for (i = i - 1; i >= 0; i--)
                {
                    formatter.Serialize(ref writer, ref rentArray[i]);
                }
            }
            finally
            {
                ArrayPool<T?>.Shared.Return(rentArray, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ConcurrentStack<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new ConcurrentStack<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Push(v);
            }
        }
    }

    [Preserve]
    public sealed class ConcurrentBagFormatter<T> : MemoryPackFormatter<ConcurrentBag<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ConcurrentBag<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            var count = value.Count;
            writer.WriteCollectionHeader(count);
            var i = 0;
            foreach (var item in value)
            {
                i++;
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }

            if (i != count) MemoryPackSerializationException.ThrowInvalidConcurrrentCollectionOperation();
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ConcurrentBag<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new ConcurrentBag<T?>();
            }
            else
            {
                value.Clear();
            }

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }

    [Preserve]
    public sealed class DictionaryFormatter<TKey, TValue> : MemoryPackFormatter<Dictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? equalityComparer;

        public DictionaryFormatter()
            : this(null)
        {

        }

        public DictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Dictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref Dictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new Dictionary<TKey, TValue?>(length, equalityComparer);
            }
            else
            {
                value.Clear();
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                value.Add(k!, v);
            }
        }
    }

    [Preserve]
    public sealed class SortedDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<SortedDictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IComparer<TKey>? comparer;

        public SortedDictionaryFormatter()
            : this(null)
        {

        }

        public SortedDictionaryFormatter(IComparer<TKey>? comparer)
        {
            this.comparer = comparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref SortedDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref SortedDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new SortedDictionary<TKey, TValue?>(comparer);
            }
            else
            {
                value.Clear();
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                value.Add(k!, v);
            }
        }
    }

    [Preserve]
    public sealed class SortedListFormatter<TKey, TValue> : MemoryPackFormatter<SortedList<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IComparer<TKey>? comparer;

        public SortedListFormatter()
            : this(null)
        {

        }

        public SortedListFormatter(IComparer<TKey>? comparer)
        {
            this.comparer = comparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref SortedList<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref SortedList<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new SortedList<TKey, TValue?>(length, comparer);
            }
            else
            {
                value.Clear();
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                value.Add(k!, v);
            }
        }
    }

    [Preserve]
    public sealed class ConcurrentDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<ConcurrentDictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? equalityComparer;

        public ConcurrentDictionaryFormatter()
            : this(null)
        {

        }

        public ConcurrentDictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ConcurrentDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            var count = value.Count;
            writer.WriteCollectionHeader(count);
            var i = 0;
            foreach (var item in value)
            {
                i++;
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }

            if (i != count) MemoryPackSerializationException.ThrowInvalidConcurrrentCollectionOperation();
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ConcurrentDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (value == null)
            {
                value = new ConcurrentDictionary<TKey, TValue?>(equalityComparer);
            }
            else
            {
                value.Clear();
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                value.TryAdd(k!, v);
            }
        }
    }

    [Preserve]
    public sealed class ReadOnlyCollectionFormatter<T> : MemoryPackFormatter<ReadOnlyCollection<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ReadOnlyCollection<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ReadOnlyCollection<T?>? value)
        {
            var array = reader.ReadArray<T?>();

            if (array == null)
            {
                value = null;
            }
            else
            {
                value = new ReadOnlyCollection<T?>(array);
            }
        }
    }

    [Preserve]
    public sealed class ReadOnlyObservableCollectionFormatter<T> : MemoryPackFormatter<ReadOnlyObservableCollection<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ReadOnlyObservableCollection<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ReadOnlyObservableCollection<T?>? value)
        {
            var array = reader.ReadArray<T?>();

            if (array == null)
            {
                value = null;
            }
            else
            {
                value = new ReadOnlyObservableCollection<T?>(new ObservableCollection<T?>(array));
            }
        }
    }

    [Preserve]
    public sealed class BlockingCollectionFormatter<T> : MemoryPackFormatter<BlockingCollection<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref BlockingCollection<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref BlockingCollection<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            value = new BlockingCollection<T?>();

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                value.Add(v);
            }
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/CultureInfoFormatter.cs
================================================
using System.Globalization;
using MemoryPack.Internal;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class CultureInfoFormatter : MemoryPackFormatter<CultureInfo>
{
    // treat as a string(Name).

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref CultureInfo? value)
    {
        writer.WriteString(value?.Name);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref CultureInfo? value)
    {
        var str = reader.ReadString();
        if (str == null)
        {
            value = null;
        }
        else
        {
            value = CultureInfo.GetCultureInfo(str);
        }
    }
}


================================================
FILE: src/MemoryPack.Core/Formatters/DynamicUnionFormatter.cs
================================================
﻿namespace MemoryPack.Formatters;

public sealed class DynamicUnionFormatter<T> : MemoryPackFormatter<T>
    where T : class
{
    readonly Dictionary<Type, ushort> typeToTag;
    readonly Dictionary<ushort, Type> tagToType;

    public DynamicUnionFormatter(params (ushort Tag, Type Type)[] memoryPackUnions)
    {
        typeToTag = memoryPackUnions.ToDictionary(x => x.Type, x => x.Tag);
        tagToType = memoryPackUnions.ToDictionary(x => x.Tag, x => x.Type);
    }

    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        if (value == null)
        {
            writer.WriteNullUnionHeader();
            return;
        }

        var type = value.GetType();
        if (typeToTag.TryGetValue(type, out var tag))
        {
            writer.WriteUnionHeader(tag);
            writer.WriteValue(type, value);
        }
        else
        {
            MemoryPackSerializationException.ThrowNotFoundInUnionType(type, typeof(T));
        }
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        if (!reader.TryReadUnionHeader(out var tag))
        {
            value = default;
            return;
        }
        
        if (tagToType.TryGetValue(tag, out var type))
        {
            object? v = value;
            reader.ReadValue(type, ref v);
            value = (T?)v;
        }
        else
        {
            MemoryPackSerializationException.ThrowInvalidTag(tag, typeof(T));
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/FrozenCollectionFormatter.cs
================================================
﻿#if NET8_0_OR_GREATER
using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Collections.Frozen;

// Frozen Collections formatters

namespace MemoryPack
{
    public static partial class MemoryPackFormatterProvider
    {
        static readonly Dictionary<Type, Type> FrozenCollectionFormatters = new Dictionary<Type, Type>()
        {
            { typeof(FrozenDictionary<,>), typeof(FrozenDictionaryFormatter<,>) },
            { typeof(FrozenSet<>), typeof(FrozenSetFormatter<>) },
        };
    }
}

namespace MemoryPack.Formatters
{
    [Preserve]
    public sealed class FrozenDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<FrozenDictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? equalityComparer;

        public FrozenDictionaryFormatter() : this(null)
        {

        }

        public FrozenDictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref FrozenDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            var count = value.Count;
            writer.WriteCollectionHeader(count);
            var i = 0;
            foreach (var item in value)
            {
                i++;
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }

            if (i != count) MemoryPackSerializationException.ThrowInvalidConcurrrentCollectionOperation();
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref FrozenDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var dict = new Dictionary<TKey, TValue?>(length, equalityComparer);

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (var i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                dict.Add(k!, v);
            }
            value = dict.ToFrozenDictionary(equalityComparer);
        }
    }

    public sealed class FrozenSetFormatter<T> : MemoryPackFormatter<FrozenSet<T?>>
    {
        readonly IEqualityComparer<T?>? equalityComparer;

        public FrozenSetFormatter() : this(null)
        {
        }

        public FrozenSetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref FrozenSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref FrozenSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var set = new HashSet<T>(length, equalityComparer);

            var formatter = reader.GetFormatter<T?>();
            for (int i = 0; i < length; i++)
            {
                T? v = default;
                formatter.Deserialize(ref reader, ref v);
                set.Add(v!);
            }

            value = set.ToFrozenSet(equalityComparer)!;
        }
    }
}
#endif



================================================
FILE: src/MemoryPack.Core/Formatters/GenericCollectionFormatters.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class GenericCollectionFormatter<TCollection, TElement> : MemoryPackFormatter<TCollection?>
    where TCollection : ICollection<TElement?>, new()
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TCollection? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        var formatter = writer.GetFormatter<TElement?>();

        writer.WriteCollectionHeader(value.Count);
        foreach (var item in value)
        {
            var v = item;
            formatter.Serialize(ref writer, ref v);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref TCollection? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        var formatter = reader.GetFormatter<TElement?>();

        var collection = new TCollection();
        for (int i = 0; i < length; i++)
        {
            TElement? v = default;
            formatter.Deserialize(ref reader, ref v);
            collection.Add(v);
        }

        value = collection;
    }
}

[Preserve]
public abstract class GenericSetFormatterBase<TSet, TElement> : MemoryPackFormatter<TSet?>
    where TSet : ISet<TElement?>
{
    [Preserve]
    protected abstract TSet CreateSet();

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TSet? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        var formatter = writer.GetFormatter<TElement?>();

        writer.WriteCollectionHeader(value.Count);
        foreach (var item in value)
        {
            var v = item;
            formatter.Serialize(ref writer, ref v);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref TSet? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        var formatter = reader.GetFormatter<TElement?>();

        var collection = CreateSet();
        for (int i = 0; i < length; i++)
        {
            TElement? v = default;
            formatter.Deserialize(ref reader, ref v);
            collection.Add(v);
        }

        value = collection;
    }
}

[Preserve]
public sealed class GenericSetFormatter<TSet, TElement> : GenericSetFormatterBase<TSet, TElement>
    where TSet : ISet<TElement?>, new()
{
    protected override TSet CreateSet()
    {
        return new();
    }
}

[Preserve]
public abstract class GenericDictionaryFormatterBase<TDictionary, TKey, TValue> : MemoryPackFormatter<TDictionary?>
    where TKey : notnull
    where TDictionary : IDictionary<TKey, TValue?>
{
    [Preserve]
    protected abstract TDictionary CreateDictionary();

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TDictionary? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        var keyFormatter = writer.GetFormatter<TKey>();
        var valueFormatter = writer.GetFormatter<TValue>();

        writer.WriteCollectionHeader(value.Count);
        foreach (var item in value)
        {
            KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref TDictionary? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = default;
            return;
        }

        var keyFormatter = reader.GetFormatter<TKey>();
        var valueFormatter = reader.GetFormatter<TValue>();

        var dict = CreateDictionary();
        for (int i = 0; i < length; i++)
        {
            KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
            dict.Add(k!, v);
        }

        value = dict;
    }
}

[Preserve]
public sealed class GenericDictionaryFormatter<TDictionary, TKey, TValue> : GenericDictionaryFormatterBase<TDictionary, TKey, TValue>
    where TKey : notnull
    where TDictionary : IDictionary<TKey, TValue?>, new()
{
    [Preserve]
    protected override TDictionary CreateDictionary()
    {
        return new();
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/ImmutableCollectionFormatters.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Buffers;
using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Immutable Collections formatters

namespace MemoryPack
{
    public static partial class MemoryPackFormatterProvider
    {
        static readonly Dictionary<Type, Type> ImmutableCollectionFormatters = new Dictionary<Type, Type>()
        {
            { typeof(ImmutableArray<>), typeof(ImmutableArrayFormatter<>) },
            { typeof(ImmutableList<>), typeof(ImmutableListFormatter<>) },
            { typeof(ImmutableQueue<>), typeof(ImmutableQueueFormatter<>) },
            { typeof(ImmutableStack<>), typeof(ImmutableStackFormatter<>) },
            { typeof(ImmutableDictionary<,>), typeof(ImmutableDictionaryFormatter<,>) },
            { typeof(ImmutableSortedDictionary<,>), typeof(ImmutableSortedDictionaryFormatter<,>) },
            { typeof(ImmutableSortedSet<>), typeof(ImmutableSortedSetFormatter<>) },
            { typeof(ImmutableHashSet<>), typeof(ImmutableHashSetFormatter<>) },
            { typeof(IImmutableList<>), typeof(InterfaceImmutableListFormatter<>) },
            { typeof(IImmutableQueue<>), typeof(InterfaceImmutableQueueFormatter<>) },
            { typeof(IImmutableStack<>), typeof(InterfaceImmutableStackFormatter<>) },
            { typeof(IImmutableDictionary<,>), typeof(InterfaceImmutableDictionaryFormatter<,>) },
            { typeof(IImmutableSet<>), typeof(InterfaceImmutableSetFormatter<>) },
        };
    }
}

namespace MemoryPack.Formatters
{
    [Preserve]
    public sealed class ImmutableArrayFormatter<T> : MemoryPackFormatter<ImmutableArray<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableArray<T?> value)
        {
            if (value.IsDefault)
            {
                writer.WriteNullCollectionHeader();
            }
            else
            {
                writer.WriteSpan(value.AsSpan());
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableArray<T?> value)
        {
            var array = reader.ReadArray<T?>();
            if (array == null)
            {
                value = default;
                return;
            }

            if (array.Length == 0)
            {
                value = ImmutableArray<T?>.Empty;
                return;
            }

#if NET8_0_OR_GREATER
            value = ImmutableCollectionsMarshal.AsImmutableArray(array);
#else
            // create Empty and replace inner T[] field(avoid defensive copy of Create)
            value = ImmutableArray.Create<T?>();
            ref var view = ref Unsafe.As<ImmutableArray<T?>, ImmutableArrayView<T?>>(ref value);
            view.array = array;
#endif
        }
    }

    [Preserve]
    internal struct ImmutableArrayView<T>
    {
        public T[]? array;
    }

    [Preserve]
    public sealed class ImmutableListFormatter<T> : MemoryPackFormatter<ImmutableList<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableList<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableList<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableList<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableList.Create(item);
                return;
            }

            var formatter = reader.GetFormatter<T?>();

            var builder = ImmutableList.CreateBuilder<T?>();
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                builder.Add(item);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class ImmutableQueueFormatter<T> : MemoryPackFormatter<ImmutableQueue<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableQueue<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // ImmutableQueue<T> has no Count, so use similar serialization of IEnumerable<T>

            var tempBuffer = ReusableLinkedArrayBufferWriterPool.Rent();
            try
            {
                var tempWriter = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState);

                var count = 0;
                var formatter = writer.GetFormatter<T?>();
                foreach (var item in value)
                {
                    count++;
                    var v = item;
                    formatter.Serialize(ref tempWriter, ref v);
                }

                tempWriter.Flush();

                // write to parameter writer.
                writer.WriteCollectionHeader(count);
                tempBuffer.WriteToAndReset(ref writer);
            }
            finally
            {
                ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableQueue<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableQueue<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableQueue.Create(item);
                return;
            }

            // ImmutableQueue<T> has no builder

            var rentArray = ArrayPool<T?>.Shared.Rent(length);
            try
            {
                var formatter = reader.GetFormatter<T?>();
                for (int i = 0; i < length; i++)
                {
                    formatter.Deserialize(ref reader, ref rentArray[i]);
                }

                if (rentArray.Length == length)
                {
                    // we can use T[] ctor
                    value = ImmutableQueue.Create(rentArray);
                    return;
                }
                else
                {
                    // IEnumerable<T> method
                    value = ImmutableQueue.CreateRange((new ArraySegment<T?>(rentArray, 0, length)).AsEnumerable());
                }
            }
            finally
            {
                ArrayPool<T?>.Shared.Return(rentArray, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
            }
        }
    }

    [Preserve]
    public sealed class ImmutableStackFormatter<T> : MemoryPackFormatter<ImmutableStack<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableStack<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // ImmutableStack<T> has no Count, so use similar serialization of IEnumerable<T>

            var tempBuffer = ReusableLinkedArrayBufferWriterPool.Rent();
            try
            {
                var tempWriter = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState);

                var count = 0;
                var formatter = writer.GetFormatter<T?>();

                foreach (var item in value.AsEnumerable().Reverse()) // serialize reverse order
                {
                    count++;
                    var v = item;
                    formatter.Serialize(ref tempWriter, ref v);
                }

                tempWriter.Flush();

                // write to parameter writer.
                writer.WriteCollectionHeader(count);
                tempBuffer.WriteToAndReset(ref writer);
            }
            finally
            {
                ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableStack<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableStack<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableStack.Create(item);
                return;
            }

            // ImmutableStack<T> has no builder

            var rentArray = ArrayPool<T?>.Shared.Rent(length);
            try
            {
                var formatter = reader.GetFormatter<T?>();
                for (int i = 0; i < length; i++)
                {
                    formatter.Deserialize(ref reader, ref rentArray[i]);
                }

                if (rentArray.Length == length)
                {
                    // we can use T[] ctor
                    value = ImmutableStack.Create(rentArray);
                    return;
                }
                else
                {
                    // IEnumerable<T> method
                    value = ImmutableStack.CreateRange((new ArraySegment<T?>(rentArray, 0, length)).AsEnumerable());
                }
            }
            finally
            {
                ArrayPool<T?>.Shared.Return(rentArray, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
            }
        }
    }

    [Preserve]
    public sealed class ImmutableDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<ImmutableDictionary<TKey, TValue?>?>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? keyEqualityComparer;
        readonly IEqualityComparer<TValue?>? valueEqualityComparer;

        public ImmutableDictionaryFormatter()
            : this(null, null)
        {

        }

        public ImmutableDictionaryFormatter(IEqualityComparer<TKey>? keyEqualityComparer, IEqualityComparer<TValue?>? valueEqualityComparer)
        {
            this.keyEqualityComparer = keyEqualityComparer;
            this.valueEqualityComparer = valueEqualityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableDictionary<TKey, TValue?>.Empty;
                if (keyEqualityComparer != null || valueEqualityComparer != null)
                {
                    value = value.WithComparers(keyEqualityComparer, valueEqualityComparer);
                }
                return;
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();

            var builder = ImmutableDictionary.CreateBuilder<TKey, TValue?>(keyEqualityComparer, valueEqualityComparer);
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                builder.Add(k!, v);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class ImmutableHashSetFormatter<T> : MemoryPackFormatter<ImmutableHashSet<T?>>
    {
        readonly IEqualityComparer<T?>? equalityComparer;

        public ImmutableHashSetFormatter()
            : this(null)
        {

        }

        public ImmutableHashSetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableHashSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableHashSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableHashSet<T?>.Empty;
                if (equalityComparer != null)
                {
                    value = value.WithComparer(equalityComparer);
                }
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableHashSet.Create(equalityComparer, item);
                return;
            }

            var formatter = reader.GetFormatter<T?>();

            var builder = ImmutableHashSet.CreateBuilder<T?>(equalityComparer);
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                builder.Add(item);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class ImmutableSortedDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<ImmutableSortedDictionary<TKey, TValue?>?>
        where TKey : notnull
    {
        readonly IComparer<TKey>? keyComparer;
        readonly IEqualityComparer<TValue?>? valueEqualityComparer;

        public ImmutableSortedDictionaryFormatter()
            : this(null, null)
        {

        }

        public ImmutableSortedDictionaryFormatter(IComparer<TKey>? keyComparer, IEqualityComparer<TValue?>? valueEqualityComparer)
        {
            this.keyComparer = keyComparer;
            this.valueEqualityComparer = valueEqualityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableSortedDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableSortedDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableSortedDictionary<TKey, TValue?>.Empty;
                if (keyComparer != null || valueEqualityComparer != null)
                {
                    value = value.WithComparers(keyComparer, valueEqualityComparer);
                }
                return;
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();

            var builder = ImmutableSortedDictionary.CreateBuilder<TKey, TValue?>(keyComparer, valueEqualityComparer);
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                builder.Add(k!, v);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class ImmutableSortedSetFormatter<T> : MemoryPackFormatter<ImmutableSortedSet<T?>>
    {
        readonly IComparer<T?>? keyComparer;

        public ImmutableSortedSetFormatter()
            : this(null)
        {

        }

        public ImmutableSortedSetFormatter(IComparer<T?>? keyComparer)
        {
            this.keyComparer = keyComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ImmutableSortedSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ImmutableSortedSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableSortedSet<T?>.Empty;
                if (keyComparer != null)
                {
                    value = value.WithComparer(keyComparer);
                }
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableSortedSet.Create(keyComparer, item);
                return;
            }

            var formatter = reader.GetFormatter<T?>();

            var builder = ImmutableSortedSet.CreateBuilder<T?>(keyComparer);
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                builder.Add(item);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class InterfaceImmutableListFormatter<T> : MemoryPackFormatter<IImmutableList<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IImmutableList<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IImmutableList<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableList<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableList.Create(item);
                return;
            }

            var formatter = reader.GetFormatter<T?>();

            var builder = ImmutableList.CreateBuilder<T?>();
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                builder.Add(item);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class InterfaceImmutableQueueFormatter<T> : MemoryPackFormatter<IImmutableQueue<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IImmutableQueue<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // ImmutableQueue<T> has no Count, so use similar serialization of IEnumerable<T>

            var tempBuffer = ReusableLinkedArrayBufferWriterPool.Rent();
            try
            {
                var tempWriter = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState);

                var count = 0;
                var formatter = writer.GetFormatter<T?>();
                foreach (var item in value)
                {
                    count++;
                    var v = item;
                    formatter.Serialize(ref tempWriter, ref v);
                }

                tempWriter.Flush();

                // write to parameter writer.
                writer.WriteCollectionHeader(count);
                tempBuffer.WriteToAndReset(ref writer);
            }
            finally
            {
                ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IImmutableQueue<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableQueue<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableQueue.Create(item);
                return;
            }

            // ImmutableQueue<T> has no builder

            var rentArray = ArrayPool<T?>.Shared.Rent(length);
            try
            {
                var formatter = reader.GetFormatter<T?>();
                for (int i = 0; i < length; i++)
                {
                    formatter.Deserialize(ref reader, ref rentArray[i]);
                }

                if (rentArray.Length == length)
                {
                    // we can use T[] ctor
                    value = ImmutableQueue.Create(rentArray);
                    return;
                }
                else
                {
                    // IEnumerable<T> method
                    value = ImmutableQueue.CreateRange((new ArraySegment<T?>(rentArray, 0, length)).AsEnumerable());
                }
            }
            finally
            {
                ArrayPool<T?>.Shared.Return(rentArray, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
            }
        }
    }

    [Preserve]
    public sealed class InterfaceImmutableStackFormatter<T> : MemoryPackFormatter<IImmutableStack<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IImmutableStack<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            // ImmutableStack<T> has no Count, so use similar serialization of IEnumerable<T>

            var tempBuffer = ReusableLinkedArrayBufferWriterPool.Rent();
            try
            {
                var tempWriter = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState);

                var count = 0;
                var formatter = writer.GetFormatter<T?>();
                foreach (var item in value.AsEnumerable().Reverse()) // serialize reverse order
                {
                    count++;
                    var v = item;
                    formatter.Serialize(ref tempWriter, ref v);
                }

                tempWriter.Flush();

                // write to parameter writer.
                writer.WriteCollectionHeader(count);
                tempBuffer.WriteToAndReset(ref writer);
            }
            finally
            {
                ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IImmutableStack<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                value = ImmutableStack<T?>.Empty;
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableStack.Create(item);
                return;
            }

            // ImmutableStack<T> has no builder

            var rentArray = ArrayPool<T?>.Shared.Rent(length);
            try
            {
                var formatter = reader.GetFormatter<T?>();
                for (int i = 0; i < length; i++)
                {
                    formatter.Deserialize(ref reader, ref rentArray[i]);
                }

                if (rentArray.Length == length)
                {
                    // we can use T[] ctor
                    value = ImmutableStack.Create(rentArray);
                    return;
                }
                else
                {
                    // IEnumerable<T> method
                    value = ImmutableStack.CreateRange((new ArraySegment<T?>(rentArray, 0, length)).AsEnumerable());
                }
            }
            finally
            {
                ArrayPool<T?>.Shared.Return(rentArray, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
            }
        }
    }

    [Preserve]
    public sealed class InterfaceImmutableDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<IImmutableDictionary<TKey, TValue?>?>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? keyEqualityComparer;
        readonly IEqualityComparer<TValue?>? valueEqualityComparer;

        public InterfaceImmutableDictionaryFormatter()
            : this(null, null)
        {

        }

        public InterfaceImmutableDictionaryFormatter(IEqualityComparer<TKey>? keyEqualityComparer, IEqualityComparer<TValue?>? valueEqualityComparer)
        {
            this.keyEqualityComparer = keyEqualityComparer;
            this.valueEqualityComparer = valueEqualityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IImmutableDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IImmutableDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                if (keyEqualityComparer != null || valueEqualityComparer != null)
                {
                    value = ImmutableDictionary<TKey, TValue?>.Empty.WithComparers(keyEqualityComparer, valueEqualityComparer);
                }
                else
                {
                    value = ImmutableDictionary<TKey, TValue?>.Empty;
                }
                return;
            }

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();

            var builder = ImmutableDictionary.CreateBuilder<TKey, TValue?>(keyEqualityComparer, valueEqualityComparer);
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                builder.Add(k!, v);
            }

            value = builder.ToImmutable();
        }
    }

    [Preserve]
    public sealed class InterfaceImmutableSetFormatter<T> : MemoryPackFormatter<IImmutableSet<T?>>
    {
        readonly IEqualityComparer<T?>? equalityComparer;

        public InterfaceImmutableSetFormatter()
            : this(null)
        {

        }

        public InterfaceImmutableSetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IImmutableSet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T?>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IImmutableSet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            if (length == 0)
            {
                if (equalityComparer != null)
                {
                    value = ImmutableHashSet<T?>.Empty.WithComparer(equalityComparer);
                }
                else
                {
                    value = ImmutableHashSet<T?>.Empty;
                }
                return;
            }

            if (length == 1)
            {
                var item = reader.ReadValue<T>();
                value = ImmutableHashSet.Create(equalityComparer, item);
                return;
            }

            var formatter = reader.GetFormatter<T?>();

            var builder = ImmutableHashSet.CreateBuilder<T?>(equalityComparer);
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                builder.Add(item);
            }

            value = builder.ToImmutable();
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/InterfaceCollectionFormatters.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Internal;
using System.Buffers;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// interface collection formatters
// IEnumerable, ICollection, IReadOnlyCollection, IList, IReadOnlyList
// IDictionary, IReadOnlyDictionary, ILookup, IGrouping, ISet, IReadOnlySet

namespace MemoryPack
{
    public static partial class MemoryPackFormatterProvider
    {
        static readonly Dictionary<Type, Type> InterfaceCollectionFormatters = new(11)
        {
            { typeof(IEnumerable<>), typeof(InterfaceEnumerableFormatter<>) },
            { typeof(ICollection<>), typeof(InterfaceCollectionFormatter<>) },
            { typeof(IReadOnlyCollection<>), typeof(InterfaceReadOnlyCollectionFormatter<>) },
            { typeof(IList<>), typeof(InterfaceListFormatter<>) },
            { typeof(IReadOnlyList<>), typeof(InterfaceReadOnlyListFormatter<>) },
            { typeof(IDictionary<,>), typeof(InterfaceDictionaryFormatter<,>) },
            { typeof(IReadOnlyDictionary<,>), typeof(InterfaceReadOnlyDictionaryFormatter<,>) },
            { typeof(ILookup<,>), typeof(InterfaceLookupFormatter<,>) },
            { typeof(IGrouping<,>), typeof(InterfaceGroupingFormatter<,>) },
            { typeof(ISet<>), typeof(InterfaceSetFormatter<>) },
#if NET7_0_OR_GREATER
            { typeof(IReadOnlySet<>), typeof(InterfaceReadOnlySetFormatter<>) },
#endif
        };
    }
}

namespace MemoryPack.Formatters
{
    using static InterfaceCollectionFormatterUtils;

    file static class InterfaceCollectionFormatterUtils
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TrySerializeOptimized<TBufferWriter, TCollection, TElement>(ref MemoryPackWriter<TBufferWriter> writer, [NotNullWhen(false)] scoped ref TCollection? value)
            where TCollection : IEnumerable<TElement>
#if NET7_0_OR_GREATER
            where TBufferWriter : IBufferWriter<byte>
#else
            where TBufferWriter : class, IBufferWriter<byte>
#endif
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return true;
            }

            // optimize for list or array

            if (value is TElement?[] array)
            {
                writer.WriteArray(array);
                return true;
            }

#if NET7_0_OR_GREATER
            if (value is List<TElement?> list)
            {
                writer.WriteSpan(CollectionsMarshal.AsSpan(list));
                return true;
            }
#endif

            return false;
        }

        public static void SerializeCollection<TBufferWriter, TCollection, TElement>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TCollection? value)
            where TCollection : ICollection<TElement>
#if NET7_0_OR_GREATER
            where TBufferWriter : IBufferWriter<byte>
#else
            where TBufferWriter : class, IBufferWriter<byte>
#endif
        {
            if (TrySerializeOptimized<TBufferWriter, TCollection, TElement>(ref writer, ref value)) return;

            var formatter = writer.GetFormatter<TElement>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v!);
            }
        }

        public static void SerializeReadOnlyCollection<TBufferWriter, TCollection, TElement>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TCollection? value)
            where TCollection : IReadOnlyCollection<TElement>
#if NET7_0_OR_GREATER
            where TBufferWriter : IBufferWriter<byte>
#else
            where TBufferWriter : class, IBufferWriter<byte>
#endif
        {
            if (TrySerializeOptimized<TBufferWriter, TCollection, TElement>(ref writer, ref value)) return;

            var formatter = writer.GetFormatter<TElement>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v!);
            }
        }

        public static List<T?>? ReadList<T>(ref MemoryPackReader reader)
        {
            var formatter = reader.GetFormatter<List<T?>>();
            List<T?>? v = default;
            formatter.Deserialize(ref reader, ref v);
            return v;
        }
    }

    [Preserve]
    public sealed class InterfaceEnumerableFormatter<T> : MemoryPackFormatter<IEnumerable<T?>>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IEnumerable<T?>? value)
        {
            if (TrySerializeOptimized<TBufferWriter, IEnumerable<T?>, T?>(ref writer, ref value)) return;

            if (value.TryGetNonEnumeratedCountEx(out var count))
            {
                var formatter = writer.GetFormatter<T?>();
                writer.WriteCollectionHeader(count);
                foreach (var item in value)
                {
                    var v = item;
                    formatter.Serialize(ref writer, ref v);
                }
            }
            else
            {
                // write to tempbuffer(because we don't know length so can't write header)
                var tempBuffer = ReusableLinkedArrayBufferWriterPool.Rent();
                try
                {
                    var tempWriter = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState);

                    count = 0;
                    var formatter = writer.GetFormatter<T?>();
                    foreach (var item in value)
                    {
                        count++;
                        var v = item;
                        formatter.Serialize(ref tempWriter, ref v);
                    }

                    tempWriter.Flush();

                    // write to parameter writer.
                    writer.WriteCollectionHeader(count);
                    tempBuffer.WriteToAndReset(ref writer);
                }
                finally
                {
                    ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
                }
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IEnumerable<T?>? value)
        {
            value = reader.ReadArray<T?>();
        }
    }

    [Preserve]
    public sealed class InterfaceCollectionFormatter<T> : MemoryPackFormatter<ICollection<T?>>
    {
        static InterfaceCollectionFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<List<T?>>())
            {
                MemoryPackFormatterProvider.Register(new ListFormatter<T>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ICollection<T?>? value)
        {
            SerializeCollection<TBufferWriter, ICollection<T?>, T?>(ref writer, ref value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ICollection<T?>? value)
        {
            value = ReadList<T?>(ref reader);
        }
    }

    [Preserve]
    public sealed class InterfaceReadOnlyCollectionFormatter<T> : MemoryPackFormatter<IReadOnlyCollection<T?>>
    {
        static InterfaceReadOnlyCollectionFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<List<T?>>())
            {
                MemoryPackFormatterProvider.Register(new ListFormatter<T>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IReadOnlyCollection<T?>? value)
        {
            SerializeReadOnlyCollection<TBufferWriter, IReadOnlyCollection<T?>, T?>(ref writer, ref value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IReadOnlyCollection<T?>? value)
        {
            value = ReadList<T?>(ref reader);
        }
    }

    [Preserve]
    public sealed class InterfaceListFormatter<T> : MemoryPackFormatter<IList<T?>>
    {
        static InterfaceListFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<List<T?>>())
            {
                MemoryPackFormatterProvider.Register(new ListFormatter<T>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IList<T?>? value)
        {
            SerializeCollection<TBufferWriter, IList<T?>, T?>(ref writer, ref value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IList<T?>? value)
        {
            value = ReadList<T?>(ref reader);
        }
    }

    [Preserve]
    public sealed class InterfaceReadOnlyListFormatter<T> : MemoryPackFormatter<IReadOnlyList<T?>>
    {
        static InterfaceReadOnlyListFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<List<T?>>())
            {
                MemoryPackFormatterProvider.Register(new ListFormatter<T>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IReadOnlyList<T?>? value)
        {
            SerializeReadOnlyCollection<TBufferWriter, IReadOnlyList<T?>, T?>(ref writer, ref value);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IReadOnlyList<T?>? value)
        {
            value = ReadList<T?>(ref reader);
        }
    }

    [Preserve]
    public sealed class InterfaceDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<IDictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? equalityComparer;

        public InterfaceDictionaryFormatter()
            : this(null)
        {

        }

        public InterfaceDictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var dict = new Dictionary<TKey, TValue?>(equalityComparer);

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                dict.Add(k!, v);
            }

            value = dict;
        }
    }

    [Preserve]
    public sealed class InterfaceReadOnlyDictionaryFormatter<TKey, TValue> : MemoryPackFormatter<IReadOnlyDictionary<TKey, TValue?>>
        where TKey : notnull
    {
        readonly IEqualityComparer<TKey>? equalityComparer;

        public InterfaceReadOnlyDictionaryFormatter()
            : this(null)
        {

        }

        public InterfaceReadOnlyDictionaryFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IReadOnlyDictionary<TKey, TValue?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var keyFormatter = writer.GetFormatter<TKey>();
            var valueFormatter = writer.GetFormatter<TValue>();

            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                KeyValuePairFormatter.Serialize(keyFormatter, valueFormatter, ref writer, item!);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IReadOnlyDictionary<TKey, TValue?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var dict = new Dictionary<TKey, TValue?>(equalityComparer);

            var keyFormatter = reader.GetFormatter<TKey>();
            var valueFormatter = reader.GetFormatter<TValue>();
            for (int i = 0; i < length; i++)
            {
                KeyValuePairFormatter.Deserialize(keyFormatter, valueFormatter, ref reader, out var k, out var v);
                dict.Add(k!, v);
            }

            value = dict;
        }
    }

    [Preserve]
    public sealed class InterfaceLookupFormatter<TKey, TElement> : MemoryPackFormatter<ILookup<TKey, TElement>>
        where TKey : notnull
    {
        static InterfaceLookupFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<IGrouping<TKey, TElement>>())
            {
                MemoryPackFormatterProvider.Register(new InterfaceGroupingFormatter<TKey, TElement>());
            }
        }

        readonly IEqualityComparer<TKey>? equalityComparer;

        public InterfaceLookupFormatter()
            : this(null)
        {

        }

        public InterfaceLookupFormatter(IEqualityComparer<TKey>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }


        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ILookup<TKey, TElement>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<IGrouping<TKey, TElement>>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ILookup<TKey, TElement>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var dict = new Dictionary<TKey, IGrouping<TKey, TElement>>(equalityComparer);

            var formatter = reader.GetFormatter<IGrouping<TKey, TElement>>();
            for (int i = 0; i < length; i++)
            {
                IGrouping<TKey, TElement>? item = default;
                formatter.Deserialize(ref reader, ref item);
                if (item != null)
                {
                    dict.Add(item.Key, item);
                }
            }
            value = new Lookup<TKey, TElement>(dict);
        }
    }

    [Preserve]
    public sealed class InterfaceGroupingFormatter<TKey, TElement> : MemoryPackFormatter<IGrouping<TKey, TElement>>
        where TKey : notnull
    {
        // serialize as {key, [collection]}

        static InterfaceGroupingFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<IEnumerable<TElement>>())
            {
                MemoryPackFormatterProvider.Register(new InterfaceEnumerableFormatter<TElement>());
            }
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IGrouping<TKey, TElement>? value)
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                return;
            }

            writer.WriteObjectHeader(2);
            writer.WriteValue(value.Key);
            writer.WriteValue<IEnumerable<TElement>>(value); // write as IEnumerable<TElement>
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IGrouping<TKey, TElement>? value)
        {
            if (!reader.TryReadObjectHeader(out var count))
            {
                value = null;
                return;
            }

            if (count != 2) MemoryPackSerializationException.ThrowInvalidPropertyCount(2, count);

            var key = reader.ReadValue<TKey>();
            var values = reader.ReadArray<TElement>() as IEnumerable<TElement>;

            if (key == null) MemoryPackSerializationException.ThrowDeserializeObjectIsNull(nameof(key));
            if (values == null) MemoryPackSerializationException.ThrowDeserializeObjectIsNull(nameof(values));

            value = new Grouping<TKey, TElement>(key, values);

        }
    }

    [Preserve]
    public sealed class InterfaceSetFormatter<T> : MemoryPackFormatter<ISet<T?>>
    {
        static InterfaceSetFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<HashSet<T>>())
            {
                MemoryPackFormatterProvider.Register(new HashSetFormatter<T>());
            }
        }

        readonly IEqualityComparer<T?>? equalityComparer;

        public InterfaceSetFormatter()
            : this(null)
        {
        }

        public InterfaceSetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ISet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref ISet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var set = new HashSet<T?>(length, equalityComparer);

            var formatter = reader.GetFormatter<T>();
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                set.Add(item);
            }

            value = set;
        }
    }

#if NET7_0_OR_GREATER

    [Preserve]
    public sealed class InterfaceReadOnlySetFormatter<T> : MemoryPackFormatter<IReadOnlySet<T?>>
    {
        static InterfaceReadOnlySetFormatter()
        {
            if (!MemoryPackFormatterProvider.IsRegistered<HashSet<T>>())
            {
                MemoryPackFormatterProvider.Register(new HashSetFormatter<T>());
            }
        }

        readonly IEqualityComparer<T?>? equalityComparer;

        public InterfaceReadOnlySetFormatter()
            : this(null)
        {
        }

        public InterfaceReadOnlySetFormatter(IEqualityComparer<T?>? equalityComparer)
        {
            this.equalityComparer = equalityComparer;
        }

        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref IReadOnlySet<T?>? value)
        {
            if (value == null)
            {
                writer.WriteNullCollectionHeader();
                return;
            }

            var formatter = writer.GetFormatter<T>();
            writer.WriteCollectionHeader(value.Count);
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, scoped ref IReadOnlySet<T?>? value)
        {
            if (!reader.TryReadCollectionHeader(out var length))
            {
                value = null;
                return;
            }

            var set = new HashSet<T?>(length, equalityComparer);

            var formatter = reader.GetFormatter<T>();
            for (int i = 0; i < length; i++)
            {
                T? item = default;
                formatter.Deserialize(ref reader, ref item);
                set.Add(item);
            }

            value = set;
        }
    }

#endif

    [Preserve]
    internal sealed class Grouping<TKey, TElement> : IGrouping<TKey, TElement>
    {
        readonly TKey key;
        readonly IEnumerable<TElement> elements;

        public Grouping(TKey key, IEnumerable<TElement> elements)
        {
            this.key = key;
            this.elements = elements;
        }

        public TKey Key
        {
            get
            {
                return this.key;
            }
        }

        public IEnumerator<TElement> GetEnumerator()
        {
            return this.elements.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.elements.GetEnumerator();
        }
    }

    [Preserve]
    internal sealed class Lookup<TKey, TElement> : ILookup<TKey, TElement>
        where TKey : notnull
    {
        readonly Dictionary<TKey, IGrouping<TKey, TElement>> groupings;

        public Lookup(Dictionary<TKey, IGrouping<TKey, TElement>> groupings)
        {
            this.groupings = groupings;
        }

        public IEnumerable<TElement> this[TKey key]
        {
            get
            {
                return this.groupings.TryGetValue(key, out var value) ? value : Enumerable.Empty<TElement>();
            }
        }

        public int Count
        {
            get
            {
                return this.groupings.Count;
            }
        }

        public bool Contains(TKey key)
        {
            return this.groupings.ContainsKey(key);
        }

        public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
        {
            return this.groupings.Values.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.groupings.Values.GetEnumerator();
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/KeyValuePairFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

[Preserve]
public static class KeyValuePairFormatter
{
    // for Dictionary serialization

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Serialize<TKey, TValue, TBufferWriter>(IMemoryPackFormatter<TKey> keyFormatter, IMemoryPackFormatter<TValue> valueFormatter, ref MemoryPackWriter<TBufferWriter> writer, KeyValuePair<TKey?, TValue?> value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<KeyValuePair<TKey?, TValue?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        value.Deconstruct(out var k, out var v);
        keyFormatter.Serialize(ref writer, ref k);
        valueFormatter.Serialize(ref writer, ref v);
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deserialize<TKey, TValue>(IMemoryPackFormatter<TKey> keyFormatter, IMemoryPackFormatter<TValue> valueFormatter, ref MemoryPackReader reader, out TKey? key, out TValue? value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<KeyValuePair<TKey?, TValue?>>())
        {
            reader.DangerousReadUnmanaged(out KeyValuePair<TKey?, TValue?> kvp);
            key = kvp.Key;
            value = kvp.Value;
            return;
        }

        key = default;
        value = default;
        keyFormatter.Deserialize(ref reader, ref key);
        valueFormatter.Deserialize(ref reader, ref value);
    }
}

[Preserve]
public sealed class KeyValuePairFormatter<TKey, TValue> : MemoryPackFormatter<KeyValuePair<TKey?, TValue?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref KeyValuePair<TKey?, TValue?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<KeyValuePair<TKey?, TValue?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Key);
        writer.WriteValue(value.Value);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref KeyValuePair<TKey?, TValue?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<KeyValuePair<TKey?, TValue?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new KeyValuePair<TKey?, TValue?>(
            reader.ReadValue<TKey>(),
            reader.ReadValue<TValue>()
        );
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/LazyFormatter.cs
================================================
﻿using MemoryPack.Internal;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class LazyFormatter<T> : MemoryPackFormatter<Lazy<T?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Lazy<T?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(1);
        writer.WriteValue(value.Value);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Lazy<T?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 1) MemoryPackSerializationException.ThrowInvalidPropertyCount(1, count);

        var v = reader.ReadValue<T>();
        value = new Lazy<T?>(v);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/MemoryPackableFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

#if NET7_0_OR_GREATER

[Preserve]
public sealed class MemoryPackableFormatter<T> : MemoryPackFormatter<T>
    where T : IMemoryPackable<T>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        T.Serialize(ref writer, ref Unsafe.AsRef(in value));
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        T.Deserialize(ref reader, ref value);
    }
}

#endif



================================================
FILE: src/MemoryPack.Core/Formatters/MultiDimensionalArrayFormatters.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class TwoDimensionalArrayFormatter<T> : MemoryPackFormatter<T?[,]>
{
    // {i-length, j-length, [total-length, values]}

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T?[,]? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(3);

        var i = value.GetLength(0);
        var j = value.GetLength(1);
        writer.WriteUnmanaged(i, j);

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * i * j;
            ref var src = ref MemoryMarshal.GetArrayDataReference(value);
            ref var dest = ref writer.GetSpanReference(byteCount + 4);

            Unsafe.WriteUnaligned(ref dest, value.Length);
            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)byteCount);
            writer.Advance(byteCount + 4);
        }
        else
#endif
        {

            writer.WriteCollectionHeader(value.Length);
            var formatter = writer.GetFormatter<T?>();
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T?[,]? value)
    {
        if (!reader.TryReadObjectHeader(out var propertyCount))
        {
            value = null;
            return;
        }

        if (propertyCount != 3)
        {
            MemoryPackSerializationException.ThrowInvalidPropertyCount(3, propertyCount);
        }

        reader.ReadUnmanaged(out int iLength, out int jLength);

        if (!reader.TryReadCollectionHeader(out var length))
        {
            MemoryPackSerializationException.ThrowInvalidCollection();
        }

        if (value != null && value.GetLength(0) == iLength && value.GetLength(1) == jLength && value.Length == length)
        {
            // allow overwrite
        }
        else
        {
            value = new T[iLength, jLength];
        }

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * iLength * jLength;
            ref var dest = ref MemoryMarshal.GetArrayDataReference(value);
            ref var src = ref reader.GetSpanReference(byteCount);
            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

            reader.Advance(byteCount);
        }
        else
#endif
        {
            var formatter = reader.GetFormatter<T?>();

            var i = 0;
            var j = -1;
            var count = 0;
            while (count++ < length)
            {
                if (j < jLength - 1)
                {
                    j++;
                }
                else
                {
                    j = 0;
                    i++;
                }

                formatter.Deserialize(ref reader, ref value[i, j]);
            }
        }
    }
}

[Preserve]
public sealed class ThreeDimensionalArrayFormatter<T> : MemoryPackFormatter<T?[,,]>
{
    // {i-length, j-length, k-length, [total-length, values]}

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T?[,,]? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(4);

        var i = value.GetLength(0);
        var j = value.GetLength(1);
        var k = value.GetLength(2);
        writer.WriteUnmanaged(i, j, k);

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * i * j * k;
            ref var src = ref MemoryMarshal.GetArrayDataReference(value);
            ref var dest = ref writer.GetSpanReference(byteCount + 4);

            Unsafe.WriteUnaligned(ref dest, value.Length);
            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)byteCount);
            writer.Advance(byteCount + 4);
        }
        else
#endif
        {
            writer.WriteCollectionHeader(value.Length);
            var formatter = writer.GetFormatter<T?>();
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T?[,,]? value)
    {
        if (!reader.TryReadObjectHeader(out var propertyCount))
        {
            value = null;
            return;
        }

        if (propertyCount != 4)
        {
            MemoryPackSerializationException.ThrowInvalidPropertyCount(4, propertyCount);
        }

        reader.ReadUnmanaged(out int iLength, out int jLength, out int kLength);

        if (!reader.TryReadCollectionHeader(out var length))
        {
            MemoryPackSerializationException.ThrowInvalidCollection();
        }

        if (value != null && value.GetLength(0) == iLength && value.GetLength(1) == jLength && value.GetLength(2) == kLength && value.Length == length)
        {
            // allow overwrite
        }
        else
        {
            value = new T[iLength, jLength, kLength];
        }

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * iLength * jLength * kLength;
            ref var dest = ref MemoryMarshal.GetArrayDataReference(value);
            ref var src = ref reader.GetSpanReference(byteCount);
            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

            reader.Advance(byteCount);
        }
        else
#endif
        {
            var formatter = reader.GetFormatter<T?>();

            var i = 0;
            var j = 0;
            var k = -1;
            var count = 0;
            while (count++ < length)
            {
                if (k < kLength - 1)
                {
                    k++;
                }
                else if (j < jLength - 1)
                {
                    k = 0;
                    j++;
                }
                else
                {
                    k = 0;
                    j = 0;
                    i++;
                }

                formatter.Deserialize(ref reader, ref value[i, j, k]);
            }
        }
    }
}

[Preserve]
public sealed class FourDimensionalArrayFormatter<T> : MemoryPackFormatter<T?[,,,]>
{
    // {i-length, j-length, k-length, l-length, [total-length, values]}

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T?[,,,]? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(5);

        var i = value.GetLength(0);
        var j = value.GetLength(1);
        var k = value.GetLength(2);
        var l = value.GetLength(3);
        writer.WriteUnmanaged(i, j, k, l);

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * i * j * k * l;
            ref var src = ref MemoryMarshal.GetArrayDataReference(value);
            ref var dest = ref writer.GetSpanReference(byteCount + 4);

            Unsafe.WriteUnaligned(ref dest, value.Length);
            Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref dest, 4), ref src, (uint)byteCount);
            writer.Advance(byteCount + 4);
        }
        else
#endif
        {
            writer.WriteCollectionHeader(value.Length);
            var formatter = writer.GetFormatter<T?>();
            foreach (var item in value)
            {
                var v = item;
                formatter.Serialize(ref writer, ref v);
            }
        }
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T?[,,,]? value)
    {
        if (!reader.TryReadObjectHeader(out var propertyCount))
        {
            value = null;
            return;
        }

        if (propertyCount != 5)
        {
            MemoryPackSerializationException.ThrowInvalidPropertyCount(5, propertyCount);
        }

        reader.ReadUnmanaged(out int iLength, out int jLength, out int kLength, out int lLength);

        if (!reader.TryReadCollectionHeader(out var length))
        {
            MemoryPackSerializationException.ThrowInvalidCollection();
        }

        if (value != null && value.GetLength(0) == iLength && value.GetLength(1) == jLength && value.GetLength(2) == kLength && value.GetLength(3) == lLength && value.Length == length)
        {
            // allow overwrite
        }
        else
        {
            value = new T[iLength, jLength, kLength, lLength];
        }

#if NET7_0_OR_GREATER
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T?>())
        {
            var byteCount = Unsafe.SizeOf<T>() * iLength * jLength * kLength * lLength;
            ref var dest = ref MemoryMarshal.GetArrayDataReference(value);
            ref var src = ref reader.GetSpanReference(byteCount);
            Unsafe.CopyBlockUnaligned(ref dest, ref src, (uint)byteCount);

            reader.Advance(byteCount);
        }
        else
#endif
        {
            var formatter = reader.GetFormatter<T?>();

            var i = 0;
            var j = 0;
            var k = 0;
            var l = -1;
            var count = 0;
            while (count++ < length)
            {
                if (l < lLength - 1)
                {
                    l++;
                }
                else if (k < kLength - 1)
                {
                    l = 0;
                    k++;
                }
                else if (j < jLength - 1)
                {
                    l = 0;
                    k = 0;
                    j++;
                }
                else
                {
                    l = 0;
                    k = 0;
                    j = 0;
                    i++;
                }

                formatter.Deserialize(ref reader, ref value[i, j, k, l]);
            }
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/NullableFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class NullableFormatter<T> : MemoryPackFormatter<T?>
    where T : struct
{
    // Nullable<T> is sometimes serialized on UnmanagedFormatter.
    // to keep same result, check if type is unmanaged.

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        if (!value.HasValue)
        {
            writer.WriteNullObjectHeader();
            return;
        }
        else
        {
            writer.WriteObjectHeader(1);
        }

        writer.WriteValue(value.Value);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 1) MemoryPackSerializationException.ThrowInvalidPropertyCount(1, count);

        value = reader.ReadValue<T>();
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/StringBuilderFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class StringBuilderFormatter : MemoryPackFormatter<StringBuilder>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref StringBuilder? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

#if NET7_0_OR_GREATER

        // for performance reason, currently StringBuilder encode as Utf16, however try to write Utf8?
        // if (writer.Options.StringEncoding == StringEncoding.Utf16)
        {
            writer.WriteCollectionHeader(value.Length);

            foreach (var chunk in value.GetChunks())
            {
                ref var p = ref writer.GetSpanReference(checked(chunk.Length * 2));
                ref var src = ref Unsafe.As<char, byte>(ref MemoryMarshal.GetReference(chunk.Span));
                Unsafe.CopyBlockUnaligned(ref p, ref src, (uint)chunk.Length * 2);

                writer.Advance(chunk.Length * 2);
            }
            return;
        }

#else
        // write as utf16
        writer.WriteUtf16(value.ToString());
#endif
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref StringBuilder? value)
    {
        if (!reader.TryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (value == null)
        {
            value = new StringBuilder(length);
        }
        else
        {
            value.Clear();
            value.EnsureCapacity(length);
        }

        // note: require to check is Utf8
        // note: to improvement append as chunk(per 64K?)
        var size = checked(length * 2);
        ref var p = ref reader.GetSpanReference(size);
        var src = MemoryMarshal.CreateSpan(ref Unsafe.As<byte, char>(ref p), length);
        value.Append(src);

        reader.Advance(size);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/StringFormatter.cs
================================================
﻿using MemoryPack.Compression;
using MemoryPack.Internal;
using System.Buffers;
using System.IO.Compression;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class StringFormatter : MemoryPackFormatter<string>
{
    public static readonly StringFormatter Default = new StringFormatter();

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref string? value)
    {
        writer.WriteString(value);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref string? value)
    {
        value = reader.ReadString();
    }
}

[Preserve]
public sealed class Utf8StringFormatter : MemoryPackFormatter<string>
{
    public static readonly Utf8StringFormatter Default = new Utf8StringFormatter();

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref string? value)
    {
        writer.WriteUtf8(value);
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref string? value)
    {
        value = reader.ReadString();
    }
}

[Preserve]
public sealed class Utf16StringFormatter : MemoryPackFormatter<string>
{
    public static readonly Utf16StringFormatter Default = new Utf16StringFormatter();

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref string? value)
    {
        writer.WriteUtf16(value);
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref string? value)
    {
        value = reader.ReadString();
    }
}

[Preserve]
public sealed class InternStringFormatter : MemoryPackFormatter<string>
{
    public static readonly InternStringFormatter Default = new InternStringFormatter();

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref string? value)
    {
        writer.WriteString(value);
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref string? value)
    {
        var str = reader.ReadString();
        if (str == null)
        {
            value = null;
            return;
        }

        value = string.Intern(str);
    }
}

[Preserve]
public sealed class BrotliStringFormatter : MemoryPackFormatter<string>
{
    [ThreadStatic]
    static StrongBox<int>? threadStaticConsumedBox;

    internal const int DefaultDecompssionSizeLimit = 1024 * 1024 * 128; // 128MB

    public static readonly BrotliStringFormatter Default = new BrotliStringFormatter();

    readonly System.IO.Compression.CompressionLevel compressionLevel;
    readonly int window;
    readonly int decompressionSizeLimit;

    public BrotliStringFormatter()
        : this(System.IO.Compression.CompressionLevel.Fastest)
    {

    }

    public BrotliStringFormatter(System.IO.Compression.CompressionLevel compressionLevel)
        : this(compressionLevel, BrotliUtils.WindowBits_Default)
    {
        this.compressionLevel = compressionLevel;
    }

    public BrotliStringFormatter(System.IO.Compression.CompressionLevel compressionLevel, int window)
        : this(compressionLevel, window, DefaultDecompssionSizeLimit)
    {
    }

    public BrotliStringFormatter(System.IO.Compression.CompressionLevel compressionLevel, int window, int decompressionSizeLimit)
    {
        this.compressionLevel = compressionLevel;
        this.window = window;
        this.decompressionSizeLimit = decompressionSizeLimit;
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref string? value)
    {
        if (value == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        if (value.Length == 0)
        {
            writer.WriteCollectionHeader(0);
            return;
        }

        var quality = BrotliUtils.GetQualityFromCompressionLevel(compressionLevel);
        using var encoder = new BrotliEncoder(quality, window);

        var srcLength = value.Length * 2;
        var maxLength = BrotliUtils.BrotliEncoderMaxCompressedSize(srcLength);

        ref var spanRef = ref writer.GetSpanReference(maxLength + 4);
        var dest = MemoryMarshal.CreateSpan(ref Unsafe.Add(ref spanRef, 4), maxLength);

        var status = encoder.Compress(MemoryMarshal.AsBytes(value.AsSpan()), dest, out var bytesConsumed, out var bytesWritten, isFinalBlock: true);
        if (status != OperationStatus.Done)
        {
            MemoryPackSerializationException.ThrowCompressionFailed(status);
        }

        if (bytesConsumed != srcLength)
        {
            MemoryPackSerializationException.ThrowCompressionFailed();
        }

        Unsafe.WriteUnaligned(ref spanRef, value.Length);
        writer.Advance(bytesWritten + 4);
    }

    [Preserve]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref string? value)
    {
        if (!reader.DangerousTryReadCollectionHeader(out var length))
        {
            value = null;
            return;
        }

        if (length == 0)
        {
            value = "";
            return;
        }

        var byteLength = length * 2;

        // security, require to check length
        if (decompressionSizeLimit < byteLength)
        {
            MemoryPackSerializationException.ThrowDecompressionSizeLimitExceeded(decompressionSizeLimit, byteLength);
        }

        reader.GetRemainingSource(out var singleSource, out var remainingSource);

        var consumedBox = threadStaticConsumedBox;
        if (consumedBox == null)
        {
            consumedBox = threadStaticConsumedBox = new StrongBox<int>();
        }
        else
        {
            consumedBox.Value = 0;
        }

        if (singleSource.Length != 0)
        {
            unsafe
            {
                fixed (byte* p = singleSource)
                {
                    value = string.Create(length, ((IntPtr)p, singleSource.Length, byteLength, consumedBox), static (stringSpan, state) =>
                    {
                        var src = MemoryMarshal.CreateSpan(ref Unsafe.AsRef<byte>((byte*)state.Item1), state.Item2);
                        var destination = MemoryMarshal.AsBytes(stringSpan);

                        using var decoder = new BrotliDecoder();
                        var status = decoder.Decompress(src, destination, out var bytesConsumed, out var bytesWritten);
                        if (status != OperationStatus.Done)
                        {
                            MemoryPackSerializationException.ThrowCompressionFailed(status);
                        }
                        if (bytesWritten != state.byteLength)
                        {
                            MemoryPackSerializationException.ThrowCompressionFailed();
                        }

                        state.consumedBox.Value = bytesConsumed;
                    });
                    reader.Advance(consumedBox.Value);
                }
            }
        }
        else
        {
            value = string.Create(length, (remainingSource, remainingSource.Length, byteLength, consumedBox), static (stringSpan, state) =>
            {
                var destination = MemoryMarshal.AsBytes(stringSpan);

                using var decoder = new BrotliDecoder();

                var consumed = 0;
                OperationStatus status = OperationStatus.DestinationTooSmall;
                foreach (var item in state.remainingSource)
                {
                    status = decoder.Decompress(item.Span, destination, out var bytesConsumed, out var bytesWritten);
                    consumed += bytesConsumed;

                    destination = destination.Slice(bytesWritten);
                    if (status == OperationStatus.Done)
                    {
                        break;
                    }
                }
                if (status != OperationStatus.Done)
                {
                    MemoryPackSerializationException.ThrowCompressionFailed(status);
                }

                state.consumedBox.Value = consumed;
            });
            reader.Advance(consumedBox.Value);
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/TimeZoneInfoFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class TimeZoneInfoFormatter : MemoryPackFormatter<TimeZoneInfo>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref TimeZoneInfo? value)
    {
        writer.WriteString(value?.ToSerializedString());
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref TimeZoneInfo? value)
    {
        var source = reader.ReadString();
        if (source == null)
        {
            value = null;
            return;
        }

        value = TimeZoneInfo.FromSerializedString(source);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/TupleFormatter.cs
================================================
﻿using MemoryPack.Internal;

namespace MemoryPack.Formatters;

internal static class TupleFormatterTypes
{
    public static readonly Dictionary<Type, Type> TupleFormatters = new Dictionary<Type, Type>(16)
    {
        { typeof(Tuple<>), typeof(TupleFormatter<>) },
        { typeof(ValueTuple<>), typeof(ValueTupleFormatter<>) },
        { typeof(Tuple<,>), typeof(TupleFormatter<,>) },
        { typeof(ValueTuple<,>), typeof(ValueTupleFormatter<,>) },
        { typeof(Tuple<,,>), typeof(TupleFormatter<,,>) },
        { typeof(ValueTuple<,,>), typeof(ValueTupleFormatter<,,>) },
        { typeof(Tuple<,,,>), typeof(TupleFormatter<,,,>) },
        { typeof(ValueTuple<,,,>), typeof(ValueTupleFormatter<,,,>) },
        { typeof(Tuple<,,,,>), typeof(TupleFormatter<,,,,>) },
        { typeof(ValueTuple<,,,,>), typeof(ValueTupleFormatter<,,,,>) },
        { typeof(Tuple<,,,,,>), typeof(TupleFormatter<,,,,,>) },
        { typeof(ValueTuple<,,,,,>), typeof(ValueTupleFormatter<,,,,,>) },
        { typeof(Tuple<,,,,,,>), typeof(TupleFormatter<,,,,,,>) },
        { typeof(ValueTuple<,,,,,,>), typeof(ValueTupleFormatter<,,,,,,>) },
        { typeof(Tuple<,,,,,,,>), typeof(TupleFormatter<,,,,,,,>) },
        { typeof(ValueTuple<,,,,,,,>), typeof(ValueTupleFormatter<,,,,,,,>) },
    };
}

[Preserve]
public sealed class TupleFormatter<T1> : MemoryPackFormatter<Tuple<T1?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(1);
        writer.WriteValue(value.Item1);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 1) MemoryPackSerializationException.ThrowInvalidPropertyCount(1, count);

        value = new Tuple<T1?>(
            reader.ReadValue<T1>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2> : MemoryPackFormatter<Tuple<T1?, T2?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(2);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 2) MemoryPackSerializationException.ThrowInvalidPropertyCount(2, count);

        value = new Tuple<T1?, T2?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3> : MemoryPackFormatter<Tuple<T1?, T2?, T3?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(3);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 3) MemoryPackSerializationException.ThrowInvalidPropertyCount(3, count);

        value = new Tuple<T1?, T2?, T3?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3, T4> : MemoryPackFormatter<Tuple<T1?, T2?, T3?, T4?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?, T4?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(4);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?, T4?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 4) MemoryPackSerializationException.ThrowInvalidPropertyCount(4, count);

        value = new Tuple<T1?, T2?, T3?, T4?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3, T4, T5> : MemoryPackFormatter<Tuple<T1?, T2?, T3?, T4?, T5?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(5);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 5) MemoryPackSerializationException.ThrowInvalidPropertyCount(5, count);

        value = new Tuple<T1?, T2?, T3?, T4?, T5?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6> : MemoryPackFormatter<Tuple<T1?, T2?, T3?, T4?, T5?, T6?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(6);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 6) MemoryPackSerializationException.ThrowInvalidPropertyCount(6, count);

        value = new Tuple<T1?, T2?, T3?, T4?, T5?, T6?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6, T7> : MemoryPackFormatter<Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(7);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
        writer.WriteValue(value.Item7);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 7) MemoryPackSerializationException.ThrowInvalidPropertyCount(7, count);

        value = new Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>(),
            reader.ReadValue<T7>()
        );
    }
}

[Preserve]
public sealed class TupleFormatter<T1, T2, T3, T4, T5, T6, T7, TRest> : MemoryPackFormatter<Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>>
    where TRest : notnull
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(8);
        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
        writer.WriteValue(value.Item7);
        writer.WriteValue(value.Rest);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 8) MemoryPackSerializationException.ThrowInvalidPropertyCount(8, count);

        value = new Tuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>(),
            reader.ReadValue<T7>(),
            reader.ReadValue<TRest>()!
        );
    }
}


[Preserve]
public sealed class ValueTupleFormatter<T1> : MemoryPackFormatter<ValueTuple<T1?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?>(
            reader.ReadValue<T1>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2> : MemoryPackFormatter<ValueTuple<T1?, T2?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3, T4> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?, T4?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?, T4?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?, T4?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?, T4?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?, T4?, T5?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?, T4?, T5?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6, T7> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
        writer.WriteValue(value.Item7);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>(),
            reader.ReadValue<T7>()
        );
    }
}

[Preserve]
public sealed class ValueTupleFormatter<T1, T2, T3, T4, T5, T6, T7, TRest> : MemoryPackFormatter<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>>
    where TRest : struct
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

        writer.WriteValue(value.Item1);
        writer.WriteValue(value.Item2);
        writer.WriteValue(value.Item3);
        writer.WriteValue(value.Item4);
        writer.WriteValue(value.Item5);
        writer.WriteValue(value.Item6);
        writer.WriteValue(value.Item7);
        writer.WriteValue(value.Rest);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TRest>(
            reader.ReadValue<T1>(),
            reader.ReadValue<T2>(),
            reader.ReadValue<T3>(),
            reader.ReadValue<T4>(),
            reader.ReadValue<T5>(),
            reader.ReadValue<T6>(),
            reader.ReadValue<T7>(),
            reader.ReadValue<TRest>()!
        );
    }
}




================================================
FILE: src/MemoryPack.Core/Formatters/TupleFormatter.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    // T8 = TRest where TRest : notnull
    string TOrRest(int i) => (i == 8) ? "TRest" : $"T{i}";
    string ItemOrRest(int i) => (i == 8) ? $"Rest" : $"Item{i}";
    string CreateT(int i) => string.Join(", ", Enumerable.Range(1, i).Select(x => (x == 8) ? "TRest" : $"T{x}"));
    string CreateTNull(int i) => string.Join(", ", Enumerable.Range(1, i).Select(x => (x == 8) ? "TRest" : $"T{x}?"));
#>
using MemoryPack.Internal;

namespace MemoryPack.Formatters;

internal static class TupleFormatterTypes
{
    public static readonly Dictionary<Type, Type> TupleFormatters = new Dictionary<Type, Type>(16)
    {
<# for (var i = 0; i <= 7; i++ ) { var comma = new string(',', i); #>
        { typeof(Tuple<<#= comma #>>), typeof(TupleFormatter<<#= comma #>>) },
        { typeof(ValueTuple<<#= comma #>>), typeof(ValueTupleFormatter<<#= comma #>>) },
<# } #>
    };
}

<# for (var i = 1; i <= 8; i++ ) { #>
[Preserve]
public sealed class TupleFormatter<<#= CreateT(i) #>> : MemoryPackFormatter<Tuple<<#= CreateTNull(i) #>>>
<# if (i == 8) { #>
    where TRest : notnull
<# } #>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Tuple<<#= CreateTNull(i) #>>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(<#= i #>);
<# for ( var j = 1; j <= i; j++ ) { #>
        writer.WriteValue(value.<#= ItemOrRest(j) #>);
<# } #>
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Tuple<<#= CreateTNull(i) #>>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != <#= i #>) MemoryPackSerializationException.ThrowInvalidPropertyCount(<#= i #>, count);

        value = new Tuple<<#= CreateTNull(i) #>>(
<# for ( var j = 1; j <= i; j++ ) { #>
            reader.ReadValue<<#= TOrRest(j) #>>()<#= (j == 8) ? "!" : (j != i) ? "," : "" #>
<# } #>
        );
    }
}

<# } #>

<# for (var i = 1; i <= 8; i++ ) { #>
[Preserve]
public sealed class ValueTupleFormatter<<#= CreateT(i) #>> : MemoryPackFormatter<ValueTuple<<#= CreateTNull(i) #>>>
<# if (i == 8) { #>
    where TRest : struct
<# } #>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref ValueTuple<<#= CreateTNull(i) #>> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<<#= CreateTNull(i) #>>>())
        {
            writer.DangerousWriteUnmanaged(value);
            return;
        }

<# for ( var j = 1; j <= i; j++ ) { #>
        writer.WriteValue(value.<#= ItemOrRest(j) #>);
<# } #>
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref ValueTuple<<#= CreateTNull(i) #>> value)
    {
        if (!System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences<ValueTuple<<#= CreateTNull(i) #>>>())
        {
            reader.DangerousReadUnmanaged(out value);
            return;
        }

        value = new ValueTuple<<#= CreateTNull(i) #>>(
<# for ( var j = 1; j <= i; j++ ) { #>
            reader.ReadValue<<#= TOrRest(j) #>>()<#= (j == 8) ? "!" : (j != i) ? "," : "" #>
<# } #>
        );
    }
}

<# } #>



================================================
FILE: src/MemoryPack.Core/Formatters/TypeFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Text.RegularExpressions;

namespace MemoryPack.Formatters;

[Preserve]
public sealed partial class TypeFormatter : MemoryPackFormatter<Type>
{
    // Remove Version, Culture, PublicKeyToken from AssemblyQualifiedName.
    // Result will be "TypeName, Assembly"
    // see:http://msdn.microsoft.com/en-us/library/w3f99sx1.aspx

#if NET7_0_OR_GREATER

    [GeneratedRegex(@", Version=\d+.\d+.\d+.\d+, Culture=[\w-]+, PublicKeyToken=(?:null|[a-f0-9]{16})")]
    private static partial Regex ShortTypeNameRegex();

#else

    static readonly Regex _shortTypeNameRegex = new Regex(@", Version=\d+.\d+.\d+.\d+, Culture=[\w-]+, PublicKeyToken=(?:null|[a-f0-9]{16})", RegexOptions.Compiled);
    static Regex ShortTypeNameRegex() => _shortTypeNameRegex;

#endif

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Type? value)
    {
        var full = value?.AssemblyQualifiedName;
        if (full == null)
        {
            writer.WriteNullCollectionHeader();
            return;
        }

        var shortName = ShortTypeNameRegex().Replace(full, "");
        writer.WriteString(shortName);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Type? value)
    {
        var typeName = reader.ReadString();
        if (typeName == null)
        {
            value = null;
            return;
        }

        value = Type.GetType(typeName, throwOnError: true);
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/UnmanagedFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MemoryPack.Formatters;

// for unamanged types( https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types )
// * sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool
// * Any enum type
// * Any pointer type
// * Any user-defined struct type that contains fields of unmanaged types only
[Preserve]
public sealed class UnmanagedFormatter<T> : MemoryPackFormatter<T>
where T : unmanaged
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T value)
    {
        Unsafe.WriteUnaligned(ref writer.GetSpanReference(Unsafe.SizeOf<T>()), value);
        writer.Advance(Unsafe.SizeOf<T>());
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T value)
    {
        value = Unsafe.ReadUnaligned<T>(ref reader.GetSpanReference(Unsafe.SizeOf<T>()));
        reader.Advance(Unsafe.SizeOf<T>());
    }
}

[Preserve]
public sealed class DangerousUnmanagedFormatter<T> : MemoryPackFormatter<T>
{
    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref T? value)
    {
        Unsafe.WriteUnaligned(ref writer.GetSpanReference(Unsafe.SizeOf<T>()), value);
        writer.Advance(Unsafe.SizeOf<T>());
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref T? value)
    {
        value = Unsafe.ReadUnaligned<T>(ref reader.GetSpanReference(Unsafe.SizeOf<T>()));
        reader.Advance(Unsafe.SizeOf<T>());
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/UriFormatter.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class UriFormatter : MemoryPackFormatter<Uri>
{
    // treat as a string(OriginalString).

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Uri? value)
    {
        writer.WriteString(value?.OriginalString);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Uri? value)
    {
        var str = reader.ReadString();
        if (str == null)
        {
            value = null;
        }
        else
        {
            value = new Uri(str, UriKind.RelativeOrAbsolute);
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Formatters/VersionFormatter.cs
================================================
﻿using MemoryPack.Internal;

namespace MemoryPack.Formatters;

[Preserve]
public sealed class VersionFormatter : MemoryPackFormatter<Version>
{
    // Serialize as [Major, Minor, Build, Revision]

    [Preserve]
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Version? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteUnmanagedWithObjectHeader(4, value.Major, value.Minor, value.Build, value.Revision);
    }

    [Preserve]
    public override void Deserialize(ref MemoryPackReader reader, scoped ref Version? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        if (count != 4) MemoryPackSerializationException.ThrowInvalidPropertyCount(4, count);

        reader.ReadUnmanaged(out int major, out int minor, out int build, out int revision);

        // when use new Version(major, minor), build and revision will be -1, it can not use constructor.
        if (revision == -1)
        {
            if (build == -1)
            {
                value = new Version(major, minor);
            }
            else
            {
                value = new Version(major, minor, build);
            }
        }
        else
        {
            value = new Version(major, minor, build, revision);
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/CollectionsMarshalEx.cs
================================================
﻿#if NET7_0_OR_GREATER

#pragma warning disable CS8618
#pragma warning disable CS0649

using System.Runtime.CompilerServices;

namespace MemoryPack.Internal;

internal static class CollectionsMarshalEx
{
    /// <summary>
    /// similar as AsSpan but modify size to create fixed-size span.
    /// </summary>
    public static Span<T?> CreateSpan<T>(List<T?> list, int length)
    {
        list.EnsureCapacity(length);

        ref var view = ref Unsafe.As<List<T?>, ListView<T?>>(ref list);
        view._size = length;
        return view._items.AsSpan(0, length);
    }

    public static Span<T?> AsSpan<T>(Stack<T?> stack)
    {
        ref var view = ref Unsafe.As<Stack<T?>, StackView<T?>>(ref stack);
        return view._items.AsSpan(0, view._size);
    }

    public static Span<T?> CreateSpan<T>(Stack<T?> stack, int length)
    {
        stack.EnsureCapacity(length);

        ref var view = ref Unsafe.As<Stack<T?>, StackView<T?>>(ref stack);
        view._size = length;
        return view._items.AsSpan(0, view._size);
    }

    // NOTE: These structure depndent on .NET 7, if changed, require to keep same structure.

    internal sealed class ListView<T>
    {
        public T[] _items;
        public int _size;
        public int _version;
    }

    internal sealed class StackView<T>
    {
        public T[] _items;
        public int _size;
        public int _version;
    }
}

#endif



================================================
FILE: src/MemoryPack.Core/Internal/EnumerableExtensions.cs
================================================
﻿namespace MemoryPack.Internal;

internal static class EnumerableExtensions
{
    public static bool TryGetNonEnumeratedCountEx<T>(this IEnumerable<T> value, out int count)
    {
        // TryGetNonEnumeratedCount is not check IReadOnlyCollection<T> so add check manually.
        // https://github.com/dotnet/runtime/issues/54764

#if NET7_0_OR_GREATER
        if (value.TryGetNonEnumeratedCount(out count))
        {
            return true;
        }
#else
        count = 0;
        if (value is ICollection<T> collection)
        {
            count = collection.Count;
            return true;
        }
#endif

        if (value is IReadOnlyCollection<T> readOnlyCollection)
        {
            count = readOnlyCollection.Count;
            return true;
        }

        return false;
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/FixedArrayBufferWriter.cs
================================================
﻿using System.Buffers;
using System.Runtime.CompilerServices;

namespace MemoryPack.Internal;

internal struct FixedArrayBufferWriter : IBufferWriter<byte>
{
    byte[] buffer;
    int written;

    public FixedArrayBufferWriter(byte[] buffer)
    {
        this.buffer = buffer;
        this.written = 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        this.written += count;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Memory<byte> GetMemory(int sizeHint = 0)
    {
        var memory = buffer.AsMemory(written);
        if (memory.Length >= sizeHint)
        {
            return memory;
        }

        MemoryPackSerializationException.ThrowMessage("Requested invalid sizeHint.");
        return memory;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Span<byte> GetSpan(int sizeHint = 0)
    {
        var span = buffer.AsSpan(written);
        if (span.Length >= sizeHint)
        {
            return span;
        }

        MemoryPackSerializationException.ThrowMessage("Requested invalid sizeHint.");
        return span;
    }

    public byte[] GetFilledBuffer()
    {
        if (written != buffer.Length)
        {
            MemoryPackSerializationException.ThrowMessage("Not filled buffer.");
        }

        return buffer;
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/MathEx.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace MemoryPack.Internal;

internal static class MathEx
{
    const int ArrayMexLength = 0x7FFFFFC7;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int NewArrayCapacity(int size)
    {
        var newSize = unchecked(size * 2);
        if ((uint)newSize > ArrayMexLength)
        {
            newSize = ArrayMexLength;
        }
        return newSize;
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/MemoryMarshalEx.cs
================================================
﻿#if !NET7_0_OR_GREATER

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Internal;

internal static class MemoryMarshalEx
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ref T GetArrayDataReference<T>(T[] array)
    {
        return ref MemoryMarshal.GetReference(array.AsSpan());
    }

    // GC
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] AllocateUninitializedArray<T>(int length, bool pinned = false)
    {
        return new T[length];
    }
}

#endif



================================================
FILE: src/MemoryPack.Core/Internal/PreserveAttribute.cs
================================================
﻿namespace MemoryPack.Internal;

// Preserve for Unity IL2CPP(internal but used for code generator)

public sealed class PreserveAttribute : System.Attribute
{
}



================================================
FILE: src/MemoryPack.Core/Internal/ReusableLinkedArrayBufferWriter.cs
================================================
﻿using System.Buffers;
using System.Collections;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Internal;

#if NET7_0_OR_GREATER
using static GC;
using static MemoryMarshal;
#else
using static MemoryPack.Internal.MemoryMarshalEx;
#endif

// internal but used by generator code

public static class ReusableLinkedArrayBufferWriterPool
{
    static readonly ConcurrentQueue<ReusableLinkedArrayBufferWriter> queue = new ConcurrentQueue<ReusableLinkedArrayBufferWriter>();

    public static ReusableLinkedArrayBufferWriter Rent()
    {
        if (queue.TryDequeue(out var writer))
        {
            return writer;
        }
        return new ReusableLinkedArrayBufferWriter(useFirstBuffer: false, pinned: false); // does not cache firstBuffer
    }

    public static void Return(ReusableLinkedArrayBufferWriter writer)
    {
        writer.Reset();
        queue.Enqueue(writer);
    }
}

// This class has large buffer so should cache [ThreadStatic] or Pool.
public sealed class ReusableLinkedArrayBufferWriter : IBufferWriter<byte>
{
    const int InitialBufferSize = 262144; // 256K(32768, 65536, 131072, 262144)
    static readonly byte[] noUseFirstBufferSentinel = new byte[0];

    List<BufferSegment> buffers; // add freezed buffer.

    byte[] firstBuffer; // cache firstBuffer to avoid call ArrayPoo.Rent/Return
    int firstBufferWritten;

    BufferSegment current;
    int nextBufferSize;

    int totalWritten;

    public int TotalWritten => totalWritten;
    bool UseFirstBuffer => firstBuffer != noUseFirstBufferSentinel;

    public ReusableLinkedArrayBufferWriter(bool useFirstBuffer, bool pinned)
    {
        this.buffers = new List<BufferSegment>();
        this.firstBuffer = useFirstBuffer
            ? AllocateUninitializedArray<byte>(InitialBufferSize, pinned)
            : noUseFirstBufferSentinel;
        this.firstBufferWritten = 0;
        this.current = default;
        this.nextBufferSize = InitialBufferSize;
        this.totalWritten = 0;
    }

    public byte[] DangerousGetFirstBuffer() => firstBuffer;

    public Memory<byte> GetMemory(int sizeHint = 0)
    {
        // MemoryPack don't use GetMemory.
        throw new NotSupportedException();
    }

    public Span<byte> GetSpan(int sizeHint = 0)
    {
        if (current.IsNull)
        {
            // use firstBuffer
            var free = firstBuffer.Length - firstBufferWritten;
            if (free != 0 && sizeHint <= free)
            {
                return firstBuffer.AsSpan(firstBufferWritten);
            }
        }
        else
        {
            var buffer = current.FreeBuffer;
            if (buffer.Length > sizeHint)
            {
                return buffer;
            }
        }

        BufferSegment next;
        if (sizeHint <= nextBufferSize)
        {
            next = new BufferSegment(nextBufferSize);
            nextBufferSize = MathEx.NewArrayCapacity(nextBufferSize);
        }
        else
        {
            next = new BufferSegment(sizeHint);
        }

        if (current.WrittenCount != 0)
        {
            buffers.Add(current);
        }
        current = next;
        return next.FreeBuffer;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        if (current.IsNull)
        {
            firstBufferWritten += count;
        }
        else
        {
            current.Advance(count);
        }
        totalWritten += count;
    }

    public byte[] ToArrayAndReset()
    {
        if (totalWritten == 0) return Array.Empty<byte>();

        var result = AllocateUninitializedArray<byte>(totalWritten);
        var dest = result.AsSpan();

        if (UseFirstBuffer)
        {
            firstBuffer.AsSpan(0, firstBufferWritten).CopyTo(dest);
            dest = dest.Slice(firstBufferWritten);
        }

        if (buffers.Count > 0)
        {
#if NET7_0_OR_GREATER
            foreach (ref var item in CollectionsMarshal.AsSpan(buffers))
#else
            foreach (var item in buffers)
#endif
            {
                item.WrittenBuffer.CopyTo(dest);
                dest = dest.Slice(item.WrittenCount);
                item.Clear(); // reset buffer-segment in this loop to avoid iterate twice for Reset
            }
        }

        if (!current.IsNull)
        {
            current.WrittenBuffer.CopyTo(dest);
            current.Clear();
        }

        ResetCore();
        return result;
    }

    public void WriteToAndReset<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        if (totalWritten == 0) return;

        if (UseFirstBuffer)
        {
            ref var spanRef = ref writer.GetSpanReference(firstBufferWritten);
            firstBuffer.AsSpan(0, firstBufferWritten).CopyTo(MemoryMarshal.CreateSpan(ref spanRef, firstBufferWritten));
            writer.Advance(firstBufferWritten);
        }

        if (buffers.Count > 0)
        {
#if NET7_0_OR_GREATER
            foreach (ref var item in CollectionsMarshal.AsSpan(buffers))
#else
            foreach (var item in buffers)
#endif
            {
                ref var spanRef = ref writer.GetSpanReference(item.WrittenCount);
                item.WrittenBuffer.CopyTo(MemoryMarshal.CreateSpan(ref spanRef, item.WrittenCount));
                writer.Advance(item.WrittenCount);
                item.Clear(); // reset
            }
        }

        if (!current.IsNull)
        {
            ref var spanRef = ref writer.GetSpanReference(current.WrittenCount);
            current.WrittenBuffer.CopyTo(MemoryMarshal.CreateSpan(ref spanRef, current.WrittenCount));
            writer.Advance(current.WrittenCount);
            current.Clear();
        }

        ResetCore();
    }

    public async ValueTask WriteToAndResetAsync(Stream stream, CancellationToken cancellationToken)
    {
        if (totalWritten == 0) return;

        if (UseFirstBuffer)
        {
            await stream.WriteAsync(firstBuffer.AsMemory(0, firstBufferWritten), cancellationToken).ConfigureAwait(false);
        }

        if (buffers.Count > 0)
        {
            foreach (var item in buffers)
            {
                await stream.WriteAsync(item.WrittenMemory, cancellationToken).ConfigureAwait(false);
                item.Clear(); // reset
            }
        }

        if (!current.IsNull)
        {
            await stream.WriteAsync(current.WrittenMemory, cancellationToken).ConfigureAwait(false);
            current.Clear();
        }

        ResetCore();
    }

    public Enumerator GetEnumerator()
    {
        return new Enumerator(this);
    }

    // reset without list's BufferSegment element
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ResetCore()
    {
        firstBufferWritten = 0;
        buffers.Clear();
        totalWritten = 0;
        current = default;
        nextBufferSize = InitialBufferSize;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Reset()
    {
        if (totalWritten == 0) return;
#if NET7_0_OR_GREATER
        foreach (ref var item in CollectionsMarshal.AsSpan(buffers))
#else
        foreach (var item in buffers)
#endif
        {
            item.Clear();
        }
        current.Clear();
        ResetCore();
    }

    public struct Enumerator : IEnumerator<Memory<byte>>
    {
        ReusableLinkedArrayBufferWriter parent;
        State state;
        Memory<byte> current;
        List<BufferSegment>.Enumerator buffersEnumerator;

        public Enumerator(ReusableLinkedArrayBufferWriter parent)
        {
            this.parent = parent;
            this.state = default;
            this.current = default;
            this.buffersEnumerator = default;
        }

        public Memory<byte> Current => current;

        object IEnumerator.Current => throw new NotSupportedException();

        public void Dispose()
        {
        }

        public bool MoveNext()
        {
            if (state == State.FirstBuffer)
            {
                state = State.BuffersInit;

                if (parent.UseFirstBuffer)
                {
                    current = parent.firstBuffer.AsMemory(0, parent.firstBufferWritten);
                    return true;
                }
            }

            if (state == State.BuffersInit)
            {
                state = State.BuffersIterate;

                buffersEnumerator = parent.buffers.GetEnumerator();
            }

            if (state == State.BuffersIterate)
            {
                if (buffersEnumerator.MoveNext())
                {
                    current = buffersEnumerator.Current.WrittenMemory;
                    return true;
                }

                buffersEnumerator.Dispose();
                state = State.Current;
            }

            if (state == State.Current)
            {
                state = State.End;

                current = parent.current.WrittenMemory;
                return true;
            }

            return false;
        }

        public void Reset()
        {
            throw new NotSupportedException();
        }

        enum State
        {
            FirstBuffer,
            BuffersInit,
            BuffersIterate,
            Current,
            End
        }
    }
}

internal struct BufferSegment
{
    byte[] buffer;
    int written;

    public bool IsNull => buffer == null;

    public int WrittenCount => written;
    public Span<byte> WrittenBuffer => buffer.AsSpan(0, written);
    public Memory<byte> WrittenMemory => buffer.AsMemory(0, written);
    public Span<byte> FreeBuffer => buffer.AsSpan(written);

    public BufferSegment(int size)
    {
        buffer = ArrayPool<byte>.Shared.Rent(size);
        written = 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Advance(int count)
    {
        written += count;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear()
    {
        if (buffer != null)
        {
            ArrayPool<byte>.Shared.Return(buffer);
        }
        buffer = null!;
        written = 0;
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/ReusableReadOnlySequenceBuilder.cs
================================================
﻿using System.Buffers;
using System.Collections.Concurrent;
using System.Runtime.InteropServices;

namespace MemoryPack.Internal;

internal static class ReusableReadOnlySequenceBuilderPool
{
    static readonly ConcurrentQueue<ReusableReadOnlySequenceBuilder> queue = new();

    public static ReusableReadOnlySequenceBuilder Rent()
    {
        if (queue.TryDequeue(out var builder))
        {
            return builder;
        }
        return new ReusableReadOnlySequenceBuilder();
    }

    public static void Return(ReusableReadOnlySequenceBuilder builder)
    {
        builder.Reset();
        queue.Enqueue(builder);
    }
}

internal sealed class ReusableReadOnlySequenceBuilder
{
    readonly Stack<Segment> segmentPool;
    readonly List<Segment> list;

    public ReusableReadOnlySequenceBuilder()
    {
        list = new();
        segmentPool = new Stack<Segment>();
    }

    public void Add(ReadOnlyMemory<byte> buffer, bool returnToPool)
    {
        if (!segmentPool.TryPop(out var segment))
        {
            segment = new Segment();
        }

        segment.SetBuffer(buffer, returnToPool);
        list.Add(segment);
    }

    public bool TryGetSingleMemory(out ReadOnlyMemory<byte> memory)
    {
        if (list.Count == 1)
        {
            memory = list[0].Memory;
            return true;
        }
        memory = default;
        return false;
    }

    public ReadOnlySequence<byte> Build()
    {
        if (list.Count == 0)
        {
            return ReadOnlySequence<byte>.Empty;
        }

        if (list.Count == 1)
        {
            return new ReadOnlySequence<byte>(list[0].Memory);
        }

        long running = 0;
#if NET7_0_OR_GREATER
        var span = CollectionsMarshal.AsSpan(list);
        for (int i = 0; i < span.Length; i++)
        {
            var next = i < span.Length - 1 ? span[i + 1] : null;
            span[i].SetRunningIndexAndNext(running, next);
            running += span[i].Memory.Length;
        }
        var firstSegment = span[0];
        var lastSegment = span[span.Length - 1];
#else
        var span = list;
        for (int i = 0; i < span.Count; i++)
        {
            var next = i < span.Count - 1 ? span[i + 1] : null;
            span[i].SetRunningIndexAndNext(running, next);
            running += span[i].Memory.Length;
        }
        var firstSegment = span[0];
        var lastSegment = span[span.Count - 1];
#endif
        return new ReadOnlySequence<byte>(firstSegment, 0, lastSegment, lastSegment.Memory.Length);
    }

    public void Reset()
    {
#if NET7_0_OR_GREATER
        var span = CollectionsMarshal.AsSpan(list);
#else
        var span = list;
#endif
        foreach (var item in span)
        {
            item.Reset();
            segmentPool.Push(item);
        }
        list.Clear();
    }

    class Segment : ReadOnlySequenceSegment<byte>
    {
        bool returnToPool;

        public Segment()
        {
            returnToPool = false;
        }

        public void SetBuffer(ReadOnlyMemory<byte> buffer, bool returnToPool)
        {
            Memory = buffer;
            this.returnToPool = returnToPool;
        }

        public void Reset()
        {
            if (returnToPool)
            {
                if (MemoryMarshal.TryGetArray(Memory, out var segment) && segment.Array != null)
                {
                    ArrayPool<byte>.Shared.Return(segment.Array, clearArray: false);
                }
            }
            Memory = default;
            RunningIndex = 0;
            Next = null;
        }

        public void SetRunningIndexAndNext(long runningIndex, Segment? nextSegment)
        {
            RunningIndex = runningIndex;
            Next = nextSegment;
        }
    }
}



================================================
FILE: src/MemoryPack.Core/Internal/TypeHelpers.cs
================================================
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Internal;

internal static class TypeHelpers
{
    static readonly MethodInfo isReferenceOrContainsReferences = typeof(RuntimeHelpers).GetMethod("IsReferenceOrContainsReferences")!;
    static readonly MethodInfo unsafeSizeOf = typeof(Unsafe).GetMethod("SizeOf")!;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsReferenceOrNullable<T>()
    {
        return Cache<T>.IsReferenceOrNullable;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TypeKind TryGetUnmanagedSZArrayElementSizeOrMemoryPackableFixedSize<T>(out int size)
    {
        if (Cache<T>.IsUnmanagedSZArray)
        {
            size = Cache<T>.UnmanagedSZArrayElementSize;
            return TypeKind.UnmanagedSZArray;
        }
        else
        {
            if (Cache<T>.IsFixedSizeMemoryPackable)
            {
                size = Cache<T>.MemoryPackableFixedSize;
                return TypeKind.FixedSizeMemoryPackable;
            }
        }

        size = 0;
        return TypeKind.None;
    }

    public static bool IsAnonymous(Type type)
    {
        return type.Namespace == null
               && type.IsSealed
               && (type.Name.StartsWith("<>f__AnonymousType", StringComparison.Ordinal)
                   || type.Name.StartsWith("<>__AnonType", StringComparison.Ordinal)
                   || type.Name.StartsWith("VB$AnonymousType_", StringComparison.Ordinal))
               && type.IsDefined(typeof(CompilerGeneratedAttribute), false);
    }

    static class Cache<T>
    {
        public static bool IsReferenceOrNullable;
        public static bool IsUnmanagedSZArray;
        public static int UnmanagedSZArrayElementSize;
        public static bool IsFixedSizeMemoryPackable = false;
        public static int MemoryPackableFixedSize = 0;

        static Cache()
        {
            try
            {
                var type = typeof(T);
                IsReferenceOrNullable = !type.IsValueType || Nullable.GetUnderlyingType(type) != null;

                if (type.IsSZArray)
                {
                    var elementType = type.GetElementType();
                    bool containsReference = (bool)(isReferenceOrContainsReferences.MakeGenericMethod(elementType!).Invoke(null, null)!);
                    if (!containsReference)
                    {
                        IsUnmanagedSZArray = true;
                        UnmanagedSZArrayElementSize = (int)unsafeSizeOf.MakeGenericMethod(elementType!).Invoke(null, null)!;
                    }
                }
#if NET7_0_OR_GREATER
                else
                {
                    if (typeof(IFixedSizeMemoryPackable).IsAssignableFrom(type))
                    {
                        var prop = type.GetProperty("global::MemoryPack.IFixedSizeMemoryPackable.Size", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                        if (prop != null)
                        {
                            IsFixedSizeMemoryPackable = true;
                            MemoryPackableFixedSize = (int)prop.GetValue(null)!;
                        }
                    }
                }
#endif
            }
            catch
            {
                IsUnmanagedSZArray = false;
                IsFixedSizeMemoryPackable = false;
            }
        }
    }

    internal enum TypeKind : byte
    {
        None,
        UnmanagedSZArray,
        FixedSizeMemoryPackable
    }
}



================================================
FILE: src/MemoryPack.Generator/CoreEnums.cs
================================================
﻿namespace MemoryPack.Generator;

// should synchronize with MemoryPack.Core.Attributes.cs GenerateType
public enum GenerateType
{
    Object,
    VersionTolerant,
    CircularReference,
    Collection,
    NoGenerate,

    // only used in Generator
    Union
}

public enum SerializeLayout
{
    Sequential, // default
    Explicit
}



================================================
FILE: src/MemoryPack.Generator/DiagnosticDescriptors.cs
================================================
﻿using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Text;

namespace MemoryPack.Generator;

internal static class DiagnosticDescriptors
{
    const string Category = "GenerateMemoryPack";

    public static readonly DiagnosticDescriptor MustBePartial = new(
        id: "MEMPACK001",
        title: "MemoryPackable object must be partial",
        messageFormat: "The MemoryPackable object '{0}' must be partial",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor AbstractMustUnion = new(
        id: "MEMPACK003",
        title: "abstract/interface type of MemoryPackable object must annotate with Union",
        messageFormat: "abstract/interface type of MemoryPackable object '{0}' must annotate with Union",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MultipleCtorWithoutAttribute = new(
        id: "MEMPACK004",
        title: "Require [MemoryPackConstructor] when exists multiple constructors",
        messageFormat: "The MemoryPackable object '{0}' must annotate with [MemoryPackConstructor] when exists multiple constructors",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MultipleCtorAttribute = new(
        id: "MEMPACK005",
        title: "[MemoryPackConstructor] exists in multiple constructors",
        messageFormat: "Mupltiple [MemoryPackConstructor] exists in '{0}' but allows only single ctor",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor ConstructorHasNoMatchedParameter = new(
        id: "MEMPACK006",
        title: "MemoryPackObject's constructor has no matched parameter",
        messageFormat: "The MemoryPackable object '{0}' constructor's parameter '{1}' must match a serialized member name(case-insensitive)",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor OnMethodHasParameter = new(
        id: "MEMPACK007",
        title: "MemoryPackObject's On*** methods must has no parameter",
        messageFormat: "The MemoryPackable object '{0}''s '{1}' method must has no parameter",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor OnMethodInUnamannagedType = new(
        id: "MEMPACK008",
        title: "MemoryPackObject's On*** methods can't annotate in unamnaged struct",
        messageFormat: "The MemoryPackable object '{0}' is unmanaged struct that can't annotate On***Attribute however '{1}' method annotaed",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor OverrideMemberCantAddAnnotation = new(
        id: "MEMPACK009",
        title: "Override member can't annotate Ignore/Include attribute",
        messageFormat: "The MemoryPackable object '{0}' override member '{1}' can't annotate {2} attribute",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor SealedTypeCantBeUnion = new(
        id: "MEMPACK010",
        title: "Sealed type can't be union",
        messageFormat: "The MemoryPackable object '{0}' is sealed type so can't be Union",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);


    public static readonly DiagnosticDescriptor ConcreteTypeCantBeUnion = new(
        id: "MEMPACK011",
        title: "Concrete type can't be union",
        messageFormat: "The MemoryPackable object '{0}' can be Union, only allow abstract or interface",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);


    public static readonly DiagnosticDescriptor UnionTagDuplicate = new(
        id: "MEMPACK012",
        title: "Union tag is duplicate",
        messageFormat: "The MemoryPackable object '{0}' union tag value is duplicate",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);


    public static readonly DiagnosticDescriptor UnionMemberTypeNotImplementBaseType = new(
        id: "MEMPACK013",
        title: "Union member not implement union interface",
        messageFormat: "The MemoryPackable object '{0}' union member '{1}' not implement union interface",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);


    public static readonly DiagnosticDescriptor UnionMemberTypeNotDerivedBaseType = new(
        id: "MEMPACK014",
        title: "Union member not dervided union base type",
        messageFormat: "The MemoryPackable object '{0}' union member '{1}' not derived union type",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UnionMemberNotAllowStruct = new(
        id: "MEMPACK015",
        title: "Union member can't be struct",
        messageFormat: "The MemoryPackable object '{0}' union member '{1}' can't be member, not allows struct",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UnionMemberMustBeMemoryPackable = new(
        id: "MEMPACK016",
        title: "Union member must be MemoryPackable",
        messageFormat: "The MemoryPackable object '{0}' union member '{1}' must be MemoryPackable",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MembersCountOver250 = new(
        id: "MEMPACK017",
        title: "Members count limit",
        messageFormat: "The MemoryPackable object '{0}' member count is '{1}', however limit size is 249",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MemberCantSerializeType = new(
        id: "MEMPACK018",
        title: "Member can't serialize type",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' type is '{2}' that can't serialize",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MemberIsNotMemoryPackable = new(
        id: "MEMPACK019",
        title: "Member is not MemoryPackable object",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' type '{2}' is not MemoryPackable. Annotate [MemoryPackable] to '{2}' or if external type that can serialize, annotate `[MemoryPackAllowSerialize]` to member",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor TypeIsRefStruct = new(
        id: "MEMPACK020",
        title: "Type is ref struct",
        messageFormat: "The MemoryPackable object '{0}' is ref struct, it can not serialize",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor MemberIsRefStruct = new(
        id: "MEMPACK021",
        title: "Member is ref struct",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' type '{2}' is ref struct, it can not serialize",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor CollectionGenerateIsAbstract = new(
        id: "MEMPACK022",
        title: "Collection type not allows interface/abstract",
        messageFormat: "The MemoryPackable object '{0}' is GenerateType.Collection but interface/abstract, only allows concrete type",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor CollectionGenerateNotImplementedInterface = new(
        id: "MEMPACK023",
        title: "Collection type must implement collection interface",
        messageFormat: "The MemoryPackable object '{0}' is GenerateType.Collection but not implemented collection interface(ICollection<T>/ISet<T>/IDictionary<TKey,TValue>)",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor CollectionGenerateNoParameterlessConstructor = new(
        id: "MEMPACK024",
        title: "Collection type must require parameterless constructor",
        messageFormat: "The MemoryPackable object '{0}' is GenerateType.Collection but not exists parameterless constructor",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor AllMembersMustAnnotateOrder = new(
        id: "MEMPACK025",
        title: "All members must annotate MemoryPackOrder when SerializeLayout.Explicit",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' is not annotated MemoryPackOrder",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor AllMembersMustBeContinuousNumber = new(
        id: "MEMPACK026",
        title: "All MemoryPackOrder members must be continuous number from zero",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' is not continuous number from zero",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptMustBeMemoryPackable = new(
        id: "MEMPACK027",
        title: "GenerateTypeScript must be MemoryPackable",
        messageFormat: "Type '{0}' is annotated GenerateTypeScript but not annotated MemoryPackable",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptOnlyAllowsGenerateTypeObject = new(
        id: "MEMPACK028",
        title: "GenerateTypeScript must be MemoryPackable(GenerateType.Object)",
        messageFormat: "Type '{0}' is annotated GenerateTypeScript, its MemoryPackable only allows GenerateType.Object",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptDoesNotAllowGenerics = new(
        id: "MEMPACK029",
        title: "GenerateTypeScript type does not allow generics",
        messageFormat: "Type '{0}' is annotated GenerateTypeScript that does not allow generics parameter",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptDoesNotAllowLongEnum = new(
        id: "MEMPACK030",
        title: "GenerateTypeScript type does not allow 64bit enum",
        messageFormat: "GenerateTypeScript type '{0}' has not support 64bit(long/ulong) enum type '{1}', 64bit enum is not supported in typescript generation",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptNotSupportedType = new(
        id: "MEMPACK031",
        title: "not allow GenerateTypeScript type",
        messageFormat: "GenerateTypeScript type '{0}' member '{1}' type '{2}' is not supported type in typescript generation",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeScriptNotSupportedCustomFormatter = new(
        id: "MEMPACK032",
        title: "not allow GenerateTypeScript type",
        messageFormat: "GenerateTypeScript type '{0}' member '{1}' is annnotated [MemoryPackCustomFormatter] that not supported in typescript generation",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor CircularReferenceOnlyAllowsParameterlessConstructor = new(
        id: "MEMPACK033",
        title: "CircularReference MemoryPack Object must require parameterless constructor",
        messageFormat: "The MemoryPackable object '{0}' is GenerateType.CircularReference but not exists parameterless constructor.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UnamangedStructWithLayoutAutoField = new(
        id: "MEMPACK034",
        title: "Before .NET 7 unmanaged struct must annotate LayoutKind.Auto or Explicit",
        messageFormat: "The unmanaged struct '{0}' has LayoutKind.Auto field('{1}'). Before .NET 7, if field contains Auto then automatically promote to LayoutKind.Auto but .NET 7 is Sequential so breaking binary compatibility when runtime upgraded. To safety, you have to annotate [StructLayout(LayoutKind.Auto)] or LayoutKind.Explicit to type.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor UnamangedStructMemoryPackCtor = new(
        id: "MEMPACK035",
        title: "Unamanged strcut does not allow [MemoryPackConstructor]",
        messageFormat: "The unamanged struct '{0}' can not annotate with [MemoryPackConstructor] because don't call any constructors",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor InheritTypeCanNotIncludeParentPrivateMember = new(
        id: "MEMPACK036",
        title: "Inherit type can not include private member",
        messageFormat: "Type '{0}' can not include parent type's private member '{1}'",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor ReadOnlyFieldMustBeConstructorMember = new(
        id: "MEMPACK037",
        title: "Readonly field must be constructor member",
        messageFormat: "Type '{0}' readonly field '{1}' must be constructor member",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor DuplicateOrderDoesNotAllow = new(
        id: "MEMPACK038",
        title: "All members order must be unique",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' is duplicated order between '{2}'.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor GenerateTypeCannotSpeciyToUnionBaseType = new(
        id: "MEMPACK039",
        title: "GenerateType cannot be specified for the Union base type itself",
        messageFormat: "The MemoryPackable object '{0}' cannot specify '{1}'. Because it is Union base type.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor SuppressDefaultInitializationMustBeSettable = new(
        id: "MEMPACK040",
        title: "Readonly member cannot specify [SuppressDefaultInitialization]",
        messageFormat: "The MemoryPackable object '{0}' member '{1}' has [SuppressDefaultInitialization], it cannot be readonly, init-only and required.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor VersionTolerantOnUnmanagedStruct = new(
        id: "MEMPACK041",
        title: "Invalid usage of VersionTolerant on unmanaged struct",
        messageFormat: "The unmanaged struct '{0}' cannot be used for VersionTolerant serialization.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NestedContainingTypesMustBePartial = new(
        id: "MEMPACK042",
        title: "Nested MemoryPackable object's containing type(s) must be partial",
        messageFormat: "The MemoryPackable object '{0}' containing type(s) must be partial",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}



================================================
FILE: src/MemoryPack.Generator/EquatableArray.cs
================================================
﻿using System.Collections;
using System.Runtime.CompilerServices;

namespace MemoryPack.Generator;

public readonly struct EquatableArray<T> : IEquatable<EquatableArray<T>>, IEnumerable<T>
    where T : IEquatable<T>
{
    readonly T[]? array;

    public EquatableArray() // for collection literal []
    {
        array = [];
    }

    public EquatableArray(T[] array)
    {
        this.array = array;
    }

    public static implicit operator EquatableArray<T>(T[] array)
    {
        return new EquatableArray<T>(array);
    }

    public ref readonly T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => ref array![index];
    }

    public int Length => array!.Length;

    public ReadOnlySpan<T> AsSpan()
    {
        return array.AsSpan();
    }

    public ReadOnlySpan<T>.Enumerator GetEnumerator()
    {
        return AsSpan().GetEnumerator();
    }

    IEnumerator<T> IEnumerable<T>.GetEnumerator()
    {
        return array.AsEnumerable().GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return array.AsEnumerable().GetEnumerator();
    }

    public bool Equals(EquatableArray<T> other)
    {
        return AsSpan().SequenceEqual(other.AsSpan());
    }
}



================================================
FILE: src/MemoryPack.Generator/EquatableTypeSymbol.cs
================================================
﻿using Microsoft.CodeAnalysis;
using System.Collections.Immutable;

namespace MemoryPack.Generator;

public class EquatableTypeSymbol(ITypeSymbol typeSymbol) : IEquatable<EquatableTypeSymbol>
{
    // Used for build argument parser, maybe ok to equals name.
    public ITypeSymbol TypeSymbol => typeSymbol;

    // GetMembers is called for Enum and fields is not condition for command equality.
    public ImmutableArray<ISymbol> GetMembers() => typeSymbol.GetMembers();

    public TypeKind TypeKind { get; } = typeSymbol.TypeKind;
    public SpecialType SpecialType { get; } = typeSymbol.SpecialType;

    public string ToFullyQualifiedFormatDisplayString() => typeSymbol.ToFullyQualifiedFormatDisplayString();
    public string ToDisplayString(NullableFlowState state, SymbolDisplayFormat format) => typeSymbol.ToDisplayString(state, format);

    public bool Equals(EquatableTypeSymbol other)
    {
        if (this.TypeKind != other.TypeKind) return false;
        if (this.SpecialType != other.SpecialType) return false;
        if (this.TypeSymbol.Name != other.TypeSymbol.Name) return false;

        return this.TypeSymbol.EqualsNamespaceAndName(other.TypeSymbol);
    }
}

static class EquatableTypeSymbolExtensions
{
    public static EquatableTypeSymbol ToEquatable(this ITypeSymbol typeSymbol) => new(typeSymbol);
}



================================================
FILE: src/MemoryPack.Generator/Extensions.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MemoryPack.Generator;

internal static class Extensions
{
    private const string UnderScorePrefix = "_";

    public static string NewLine(this IEnumerable<string> source)
    {
        return string.Join(Environment.NewLine, source);
    }

    public static bool EqualsNamespaceAndName(this ITypeSymbol? left, ITypeSymbol? right)
    {
        if (left == null && right == null) return true;
        if (left == null || right == null) return false;

        var l = left.ContainingNamespace;
        var r = right.ContainingNamespace;
        while (l != null && r != null)
        {
            if (l.Name != r.Name) return false;

            l = l.ContainingNamespace;
            r = r.ContainingNamespace;
        }

        return (left.Name == right.Name);
    }

    public static bool ContainsAttribute(this ISymbol symbol, INamedTypeSymbol attribtue)
    {
        return symbol.GetAttributes().Any(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, attribtue));
    }

    public static AttributeData? GetAttribute(this ISymbol symbol, INamedTypeSymbol attribtue)
    {
        return symbol.GetAttributes().FirstOrDefault(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, attribtue));
    }

    public static AttributeData? GetImplAttribute(this ISymbol symbol, INamedTypeSymbol implAttribtue)
    {
        return symbol.GetAttributes().FirstOrDefault(x =>
        {
            if (x.AttributeClass == null) return false;
            if (x.AttributeClass.EqualsUnconstructedGenericType(implAttribtue)) return true;

            foreach (var item in x.AttributeClass.GetAllBaseTypes())
            {
                if (item.EqualsUnconstructedGenericType(implAttribtue))
                {
                    return true;
                }
            }
            return false;
        });
    }

    public static IEnumerable<ISymbol> GetAllMembers(this INamedTypeSymbol symbol, bool withoutOverride = true)
    {
        // Iterate Parent -> Derived
        if (symbol.BaseType != null)
        {
            foreach (var item in GetAllMembers(symbol.BaseType))
            {
                // override item already iterated in parent type
                if (!withoutOverride || !item.IsOverride)
                {
                    yield return item;
                }
            }
        }

        foreach (var item in symbol.GetMembers())
        {
            if (!withoutOverride || !item.IsOverride)
            {
                yield return item;
            }
        }
    }

    public static IEnumerable<ISymbol> GetParentMembers(this INamedTypeSymbol symbol)
    {
        // Iterate Parent -> Derived
        if (symbol.BaseType != null)
        {
            foreach (var item in GetAllMembers(symbol.BaseType))
            {
                // override item already iterated in parent type
                if (!item.IsOverride)
                {
                    yield return item;
                }
            }
        }
    }

    public static bool TryGetMemoryPackableType(this ITypeSymbol symbol, ReferenceSymbols references, out GenerateType generateType, out SerializeLayout serializeLayout)
    {
        var memPackAttr = symbol.GetAttribute(references.MemoryPackableAttribute);
        var packableCtorArgs = memPackAttr?.ConstructorArguments;
        generateType = GenerateType.Object;
        serializeLayout = SerializeLayout.Sequential;

        if (memPackAttr == null || packableCtorArgs == null)
        {
            var memPackUnionFormatterAttr = symbol.GetAttribute(references.MemoryPackUnionFormatterAttribute);
            generateType = memPackUnionFormatterAttr != null ? GenerateType.Union : GenerateType.NoGenerate;
            serializeLayout = SerializeLayout.Sequential;
            return false;
        }

        if (packableCtorArgs.Value.Length != 0)
        {
            // MemoryPackable has three attribtues
            // [GenerateType generateType]
            // [SerializeLayout serializeLayout]
            // [GenerateType generateType, SerializeLayout serializeLayout]

            if (packableCtorArgs.Value.Length == 1)
            {
                var ctorValue = packableCtorArgs.Value[0];

                // check which construcotr was used
                var attrConstructor = memPackAttr.AttributeConstructor;
                var isSerializeLayout = attrConstructor!.Parameters[0].Type.Name == nameof(SerializeLayout);
                if (isSerializeLayout)
                {
                    generateType = GenerateType.Object;
                    serializeLayout = (SerializeLayout)(ctorValue.Value!);
                }
                else
                {
                    generateType = (GenerateType)(ctorValue.Value!);
                    serializeLayout = SerializeLayout.Sequential;
                    if (generateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
                    {
                        serializeLayout = SerializeLayout.Explicit;
                    }
                }
            }
            else
            {
                generateType = (GenerateType)(packableCtorArgs.Value[0].Value ?? GenerateType.Object);
                serializeLayout = (SerializeLayout)(packableCtorArgs.Value[1].Value ?? SerializeLayout.Sequential);
            }
        }

        if (generateType == GenerateType.Object && (symbol.IsStatic || symbol.IsAbstract))
        {
            // static or abstract class is Union, set as NoGenerate
            generateType = GenerateType.Union;
            serializeLayout = SerializeLayout.Sequential;
        }

        return true;
    }

    public static bool IsMemoryPackableNoGenerate(this ITypeSymbol symbol, ReferenceSymbols references)
    {
        var memPackAttr = symbol.GetAttribute(references.MemoryPackableAttribute);
        var packableCtorArgs = memPackAttr?.ConstructorArguments;
        if (memPackAttr == null || packableCtorArgs == null)
        {
            return false;
        }
        else if (packableCtorArgs.Value.Length != 0)
        {
            // MemoryPackable has three attribtues
            // [GenerateType generateType]
            // [SerializeLayout serializeLayout]
            // [GenerateType generateType, SerializeLayout serializeLayout]

            if (packableCtorArgs.Value.Length == 1)
            {
                var ctorValue = packableCtorArgs.Value[0];

                // check which constructor was used
                var attrConstructor = memPackAttr.AttributeConstructor;
                var isSerializeLayout = attrConstructor!.Parameters[0].Type.Name == nameof(SerializeLayout);
                if (isSerializeLayout)
                {
                    return false;
                }
                else
                {

                    var generateType = (GenerateType)(ctorValue.Value!);
                    return generateType is GenerateType.NoGenerate;
                }
            }
            else
            {
                var generateType = (GenerateType)(packableCtorArgs.Value[0].Value ?? GenerateType.Object);

                return generateType is GenerateType.NoGenerate;
            }
        }

        return false;
    }

    public static bool IsWillImplementMemoryPackUnion(this ITypeSymbol symbol, ReferenceSymbols references)
    {
        return symbol.IsAbstract && symbol.ContainsAttribute(references.MemoryPackUnionAttribute);
    }

    public static bool HasDuplicate<T>(this IEnumerable<T> source)
    {
        var set = new HashSet<T>();
        foreach (var item in source)
        {
            if (!set.Add(item))
            {
                return true;
            }
        }
        return false;
    }

    public static IEnumerable<INamedTypeSymbol> GetAllBaseTypes(this INamedTypeSymbol symbol)
    {
        var t = symbol.BaseType;
        while (t != null)
        {
            yield return t;
            t = t.BaseType;
        }
    }

    internal static string ToFullyQualifiedFormatDisplayString(this ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    public static string FullyQualifiedToString(this ISymbol symbol)
    {
        return symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    public static bool EqualsUnconstructedGenericType(this INamedTypeSymbol left, INamedTypeSymbol right)
    {
        var l = left.IsGenericType ? left.ConstructUnboundGenericType() : left;
        var r = right.IsGenericType ? right.ConstructUnboundGenericType() : right;
        return SymbolEqualityComparer.Default.Equals(l, r);
    }

    public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => DistinctBy(source, keySelector, null);

    public static IEnumerable<TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer)
    {
        return DistinctByIterator(source, keySelector, comparer);
    }

    private static IEnumerable<TSource> DistinctByIterator<TSource, TKey>(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer)
    {
        using IEnumerator<TSource> enumerator = source.GetEnumerator();

        if (enumerator.MoveNext())
        {
            var set = new HashSet<TKey>(comparer);
            do
            {
                TSource element = enumerator.Current;
                if (set.Add(keySelector(element)))
                {
                    yield return element;
                }
            }
            while (enumerator.MoveNext());
        }
    }

    public static bool TryGetConstructorParameter(this IMethodSymbol constructor, ISymbol member, out IParameterSymbol? constructorParameter)
    {
        constructorParameter = GetConstructorParameter(constructor, member.Name);
        if (constructorParameter == null && member.Name.StartsWith(UnderScorePrefix))
        {
            constructorParameter = GetConstructorParameter(constructor, member.Name.Substring(UnderScorePrefix.Length));
        }

        return constructorParameter != null;

        static IParameterSymbol? GetConstructorParameter(IMethodSymbol constructor, string name) => constructor.Parameters.FirstOrDefault(x => x.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }

    public static bool ContainsConstructorParameter(this IEnumerable<MemberMeta> members, IParameterSymbol constructorParameter) =>
        members.Any(x =>
            x.IsConstructorParameter &&
            string.Equals(constructorParameter.Name, x.ConstructorParameterName, StringComparison.OrdinalIgnoreCase));
}



================================================
FILE: src/MemoryPack.Generator/IGeneratorContext.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace MemoryPack.Generator;

// share context for SourceGenerator and IncrementalGenerator
public interface IGeneratorContext
{
    CancellationToken CancellationToken { get; }
    void ReportDiagnostic(Diagnostic diagnostic);
    void AddSource(string hintName, string source);
    LanguageVersion LanguageVersion { get; }
    bool IsNet7OrGreater { get; }
    bool IsForUnity { get; }
}

public static class GeneratorContextExtensions
{
    public static bool IsCSharp9OrGreater(this IGeneratorContext context)
    {
        return (int)context.LanguageVersion >= 900; // C# 9 == 900
    }

    public static bool IsCSharp10OrGreater(this IGeneratorContext context)
    {
        return (int)context.LanguageVersion >= 1000; // C# 10 == 1000
    }

    public static bool IsCSharp11OrGreater(this IGeneratorContext context)
    {
        return (int)context.LanguageVersion >= 1100; // C# 11 == 1100
    }
}



================================================
FILE: src/MemoryPack.Generator/MemoryPack.Generator.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
        <LangVersion>12</LangVersion>
        <ImplicitUsings>enable</ImplicitUsings>
        <AnalyzerLanguage>cs</AnalyzerLanguage>
        <Nullable>enable</Nullable>
        <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);PackBuildOutputs</TargetsForTfmSpecificContentInPackage>
        <IncludeBuildOutput>false</IncludeBuildOutput>
        <DevelopmentDependency>true</DevelopmentDependency>
        <IncludeSymbols>false</IncludeSymbols>
        <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>
        <IsRoslynComponent>true</IsRoslynComponent>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <PackageTags>serializer</PackageTags>
        <Description>Code generator for MemoryPack.</Description>
    </PropertyGroup>

    <ItemGroup>
        <!-- https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support?view=vs-2022 -->
        <!-- require to support SyntaxValueProvider.ForAttributeWithMetadataName(Roslyn 4.3.0, VS2022 17.3) -->
        <!-- Unity 2022.3.12f1 or newer supports 4.3.0 -->
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.3.0" PrivateAssets="all" />
        <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.3">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>

    <!-- for nuget publish -->
    <Target Name="PackBuildOutputs" DependsOnTargets="SatelliteDllsProjectOutputGroup;DebugSymbolsProjectOutputGroup">
        <ItemGroup>
            <TfmSpecificPackageFile Include="$(TargetDir)\*.dll" PackagePath="analyzers\dotnet\cs" />
            <TfmSpecificPackageFile Include="@(SatelliteDllsProjectOutputGroupOutput->'%(FinalOutputPath)')" PackagePath="analyzers\dotnet\cs\%(SatelliteDllsProjectOutputGroupOutput.Culture)\" />
        </ItemGroup>
    </Target>

</Project>



================================================
FILE: src/MemoryPack.Generator/MemoryPackGenerator.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace MemoryPack.Generator;

// dotnet/runtime generators.

// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.RegularExpressions/gen/
// https://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/gen
// https://github.com/dotnet/runtime/tree/main/src/libraries/System.Private.CoreLib/gen
// https://github.com/dotnet/runtime/tree/main/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen
// https://github.com/dotnet/runtime/tree/main/src/libraries/System.Runtime.InteropServices.JavaScript/gen/JSImportGenerator
// https://github.com/dotnet/runtime/tree/main/src/libraries/System.Runtime.InteropServices/gen/LibraryImportGenerator
// https://github.com/dotnet/runtime/tree/main/src/tests/Common/XUnitWrapperGenerator

// documents, blogs.

// https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md
// https://andrewlock.net/creating-a-source-generator-part-1-creating-an-incremental-source-generator/
// https://qiita.com/WiZLite/items/48f37278cf13be899e40
// https://zenn.dev/pcysl5edgo/articles/6d9be0dd99c008
// https://neue.cc/2021/05/08_600.html
// https://www.thinktecture.com/en/net/roslyn-source-generators-introduction/

// for check generated file
// <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
// <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>

[Generator(LanguageNames.CSharp)]
public partial class MemoryPackGenerator : IIncrementalGenerator
{
    public const string MemoryPackableAttributeFullName = "MemoryPack.MemoryPackableAttribute";
    public const string MemoryPackUnionFormatterAttributeFullName = "MemoryPack.MemoryPackUnionFormatterAttribute";
    public const string GenerateTypeScriptAttributeFullName = "MemoryPack.GenerateTypeScriptAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // no need RegisterPostInitializationOutput

        RegisterMemoryPackable(context);
        RegisterTypeScript(context);
    }

    void RegisterMemoryPackable(IncrementalGeneratorInitializationContext context)
    {
        // return dir of info output or null .
        var logProvider = context.AnalyzerConfigOptionsProvider
            .Select((configOptions, token) =>
            {
                if (configOptions.GlobalOptions.TryGetValue("build_property.MemoryPackGenerator_SerializationInfoOutputDirectory", out var path))
                {
                    return path;
                }

                return (string?)null;
            })
            .WithTrackingName("MemoryPack.MemoryPackable.0_AnalyzerConfigOptionsProvider"); // annotate for IncrementalGeneratorTest

        var parseOptions = context.ParseOptionsProvider
            .Select((parseOptions, token) =>
            {
                var csOptions = (CSharpParseOptions)parseOptions;
                var langVersion = csOptions.LanguageVersion;
                var net7 = csOptions.PreprocessorSymbolNames.Contains("NET7_0_OR_GREATER");
                return (langVersion, net7);
            })
            .WithTrackingName("MemoryPack.MemoryPackable.0_ParseOptionsProvider");

        var typeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
                MemoryPackableAttributeFullName,
                predicate: static (node, token) =>
                {
                    // search [MemoryPackable] class or struct or interface or record
                    return (node is ClassDeclarationSyntax
                                 or StructDeclarationSyntax
                                 or RecordDeclarationSyntax
                                 or InterfaceDeclarationSyntax);
                },
                transform: static (context, token) =>
                {
                    return (TypeDeclarationSyntax)context.TargetNode;
                })
                .WithTrackingName("MemoryPack.MemoryPackable.1_ForAttributeMemoryPackableAttribute");

        var typeDeclarations2 = context.SyntaxProvider.ForAttributeWithMetadataName(
                MemoryPackUnionFormatterAttributeFullName,
                predicate: static (node, token) =>
                {
                    return (node is ClassDeclarationSyntax);
                },
                transform: static (context, token) =>
                {
                    return (TypeDeclarationSyntax)context.TargetNode;
                })
                .WithTrackingName("MemoryPack.MemoryPackable.1_ForAttributeMemoryPackUnion");

        {
            var source = typeDeclarations
                .Combine(context.CompilationProvider)
                .WithComparer(Comparer.Instance)
                .Combine(logProvider)
                .Combine(parseOptions)
                .WithTrackingName("MemoryPack.MemoryPackable.2_MemoryPackableCombined");

            context.RegisterSourceOutput(source, static (context, source) =>
            {
                var (typeDeclaration, compilation) = source.Left.Item1;
                var logPath = source.Left.Item2;
                var (langVersion, net7) = source.Right;

                Generate(typeDeclaration, compilation, logPath, new GeneratorContext(context, langVersion, net7));
            });
        }
        {
            var source = typeDeclarations2
                .Combine(context.CompilationProvider)
                .WithComparer(Comparer.Instance)
                .Combine(logProvider)
                .Combine(parseOptions)
                .WithTrackingName("MemoryPack.MemoryPackable.2_MemoryPackUnionCombined");

            context.RegisterSourceOutput(source, static (context, source) =>
            {
                var (typeDeclaration, compilation) = source.Left.Item1;
                var logPath = source.Left.Item2;
                var (langVersion, net7) = source.Right;

                Generate(typeDeclaration, compilation, logPath, new GeneratorContext(context, langVersion, net7));
            });
        }
    }

    void RegisterTypeScript(IncrementalGeneratorInitializationContext context)
    {
        var typeScriptEnabled = context.AnalyzerConfigOptionsProvider
            .Select((configOptions, token) =>
            {
                // https://github.com/dotnet/project-system/blob/main/docs/design-time-builds.md
                var isDesignTimeBuild = configOptions.GlobalOptions.TryGetValue("build_property.DesignTimeBuild", out var designTimeBuild) && designTimeBuild == "true";

                string? path;
                if (!configOptions.GlobalOptions.TryGetValue("build_property.MemoryPackGenerator_TypeScriptOutputDirectory", out path))
                {
                    path = null;
                }
                string ext;
                if (!configOptions.GlobalOptions.TryGetValue("build_property.MemoryPackGenerator_TypeScriptImportExtension", out ext!))
                {
                    ext = ".js";
                }

                string convertProp;
                if (!configOptions.GlobalOptions.TryGetValue("build_property.MemoryPackGenerator_TypeScriptConvertPropertyName", out convertProp!))
                {
                    convertProp = "true";
                }

                if (!configOptions.GlobalOptions.TryGetValue("build_property.MemoryPackGenerator_TypeScriptEnableNullableTypes", out var enableNullableTypes))
                {
                    enableNullableTypes = "false";
                }

                if (!bool.TryParse(convertProp, out var convert)) convert = true;

                if (path == null) return null;

                return new TypeScriptGenerateOptions
                {
                    OutputDirectory = path,
                    ImportExtension = ext,
                    ConvertPropertyName = convert,
                    EnableNullableTypes = bool.TryParse(enableNullableTypes, out var enabledNullableTypesParsed) && enabledNullableTypesParsed,
                    IsDesignTimeBuild = isDesignTimeBuild
                };
            });

        var typeScriptDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
                GenerateTypeScriptAttributeFullName,
                predicate: static (node, token) =>
                {
                    return (node is ClassDeclarationSyntax
                                 or RecordDeclarationSyntax
                                 or InterfaceDeclarationSyntax);
                },
                transform: static (context, token) =>
                {
                    return (TypeDeclarationSyntax)context.TargetNode;
                });

        var typeScriptGenerateSource = typeScriptDeclarations
            .Combine(context.CompilationProvider)
            .WithComparer(Comparer.Instance)
            .Combine(typeScriptEnabled)
            .Where(x => x.Right != null) // filter
            .Collect();

        context.RegisterSourceOutput(typeScriptGenerateSource, static (context, source) =>
        {
            ReferenceSymbols? reference = null;
            string? generatePath = null;

            var unionMap = new Dictionary<ITypeSymbol, ITypeSymbol>(SymbolEqualityComparer.Default); // <impl, base>
            foreach (var item in source)
            {
                var tsOptions = item.Right;
                if (tsOptions == null) continue;
                if (tsOptions.IsDesignTimeBuild) continue; // designtime build(in IDE), do nothing.

                var syntax = item.Left.Item1;
                var compilation = item.Left.Item2;
                var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
                var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken) as ITypeSymbol;
                if (typeSymbol == null) continue;
                if (reference == null)
                {
                    reference = new ReferenceSymbols(compilation);
                }

                if (generatePath is null && item.Right is { } options)
                {
                    generatePath = options.OutputDirectory;
                }

                var isUnion = typeSymbol.ContainsAttribute(reference.MemoryPackUnionAttribute);

                if (isUnion)
                {
                    var unionTags = typeSymbol.GetAttributes()
                        .Where(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, reference.MemoryPackUnionAttribute))
                        .Where(x => x.ConstructorArguments.Length == 2)
                        .Select(x => (INamedTypeSymbol)x.ConstructorArguments[1].Value!);
                    foreach (var implType in unionTags)
                    {
                        unionMap[implType] = typeSymbol;
                    }
                }
            }

            if (generatePath != null)
            {
                var collector = new TypeCollector();
                foreach (var item in source)
                {
                    var typeDeclaration = item.Left.Item1;
                    var compilation = item.Left.Item2;

                    if (reference == null)
                    {
                        reference = new ReferenceSymbols(compilation);
                    }

                    var meta = GenerateTypeScript(typeDeclaration, compilation, item.Right!, context, reference, unionMap);
                    if (meta != null)
                    {
                        collector.Visit(meta, false);
                    }
                }

                GenerateEnums(collector.GetEnums(), generatePath);

                // generate runtime
                var runtime = new[]{
                    ("MemoryPackWriter.ts", TypeScriptRuntime.MemoryPackWriter),
                    ("MemoryPackReader.ts", TypeScriptRuntime.MemoryPackReader),
                };

                foreach (var item in runtime)
                {
                    var filePath = Path.Combine(generatePath, item.Item1);
                    if (!File.Exists(filePath))
                    {
                        File.WriteAllText(filePath, item.Item2, new UTF8Encoding(false));
                    }
                }
            }
        });
    }

    class Comparer : IEqualityComparer<(TypeDeclarationSyntax, Compilation)>
    {
        public static readonly Comparer Instance = new Comparer();

        public bool Equals((TypeDeclarationSyntax, Compilation) x, (TypeDeclarationSyntax, Compilation) y)
        {
            return x.Item1.Equals(y.Item1);
        }

        public int GetHashCode((TypeDeclarationSyntax, Compilation) obj)
        {
            return obj.Item1.GetHashCode();
        }
    }

    class GeneratorContext : IGeneratorContext
    {
        SourceProductionContext context;

        public GeneratorContext(SourceProductionContext context, LanguageVersion languageVersion, bool isNet70OrGreater)
        {
            this.context = context;
            this.LanguageVersion = languageVersion;
            this.IsNet7OrGreater = isNet70OrGreater;
        }

        public CancellationToken CancellationToken => context.CancellationToken;

        public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { get; }

        public bool IsNet7OrGreater { get; }

        public bool IsForUnity => false;

        public void AddSource(string hintName, string source)
        {
            context.AddSource(hintName, source);
        }

        public void ReportDiagnostic(Diagnostic diagnostic)
        {
            context.ReportDiagnostic(diagnostic);
        }
    }
}



================================================
FILE: src/MemoryPack.Generator/MemoryPackGenerator.Emitter.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;
using System.Text;

namespace MemoryPack.Generator;

partial class MemoryPackGenerator
{
    static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, string? serializationInfoLogDirectoryPath, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return;
        }

        // verify is partial
        if (!IsPartial(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        if (IsNested(syntax) && !IsNestedContainingTypesPartial(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedContainingTypesMustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var reference = new ReferenceSymbols(compilation);

        var unionSymbol = default(INamedTypeSymbol);
        var unionFormatterAttr = typeSymbol.GetAttribute(reference.MemoryPackUnionFormatterAttribute);
        if (unionFormatterAttr != null)
        {
            // change symbol
            unionSymbol = unionFormatterAttr.ConstructorArguments[0].Value as INamedTypeSymbol;
            if (unionSymbol == null) return;
        }
        var unionFormatter = (unionSymbol != null);

        var typeMeta = new TypeMeta(typeSymbol, reference);
        if (unionFormatter)
        {
            // replace original symbol
            typeMeta.Symbol = unionSymbol!;
        }

        if (!unionFormatter && !typeMeta.IsUnion && typeMeta.GenerateType == GenerateType.NoGenerate)
        {
            return;
        }

        // ReportDiagnostic when validate failed.
        if (!typeMeta.Validate(syntax, context, unionFormatter))
        {
            return;
        }

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var sb = new StringBuilder();

        sb.AppendLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.

using System;
using MemoryPack;
");

        var ns = typeMeta.Symbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            if (context.IsCSharp10OrGreater())
            {
                sb.AppendLine($"namespace {ns};");
            }
            else
            {
                sb.AppendLine($"namespace {ns} {{");
            }
        }
        sb.AppendLine();

        // Write document comment as remarks
        if (typeMeta.GenerateType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
        {
            BuildDebugInfo(sb, typeMeta, true);

            // also output to log
            if (serializationInfoLogDirectoryPath != null)
            {
                try
                {
                    if (!Directory.Exists(serializationInfoLogDirectoryPath))
                    {
                        Directory.CreateDirectory(serializationInfoLogDirectoryPath);
                    }
                    var logSw = new StringBuilder();
                    BuildDebugInfo(logSw, typeMeta, false);
                    var message = logSw.ToString();

                    File.WriteAllText(Path.Combine(serializationInfoLogDirectoryPath, $"{fullType}.txt"), message, new UTF8Encoding(false));
                }
                catch (Exception ex)
                {
                    Trace.WriteLine(ex.ToString());
                }
            }
        }

        // emit type info
        if (unionFormatter)
        {
            typeMeta.EmitUnionFormatterTemplate(sb, context, typeSymbol);
        }
        else
        {
            typeMeta.Emit(sb, context);
        }

        if (!ns.IsGlobalNamespace && !context.IsCSharp10OrGreater())
        {
            sb.AppendLine($"}}");
        }

        var code = sb.ToString();
        context.AddSource($"{fullType}.MemoryPackFormatter.g.cs", code);
    }

    static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    static bool IsNestedContainingTypesPartial(TypeDeclarationSyntax typeDeclaration)
    {
        if (typeDeclaration.Parent is TypeDeclarationSyntax parentTypeDeclaration)
        {
            if (!IsPartial(parentTypeDeclaration))
                return false;

            return IsNestedContainingTypesPartial(parentTypeDeclaration);
        }
        else
        {
            return true;
        }
    }

    static bool IsNested(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Parent is TypeDeclarationSyntax;
    }

    static void BuildDebugInfo(StringBuilder sb, TypeMeta type, bool xmlDocument)
    {
        string WithEscape(ISymbol symbol)
        {
            var str = symbol.FullyQualifiedToString().Replace("global::", "");
            if (xmlDocument)
            {
                return str.Replace("<", "&lt;").Replace(">", "&gt;");
            }
            else
            {
                return str;
            }
        }

        if (!xmlDocument)
        {
            if (type.IsUnmanagedType)
            {
                sb.Append("GenerateType unmanaged ");
            }
            else
            {
                sb.Append("GenerateType " + type.GenerateType.ToString() + " ");
            }
            sb.AppendLine(WithEscape(type.Symbol));
            sb.AppendLine("---");
        }
        else
        {
            sb.AppendLine("/// <remarks>");
            if (type.IsUnmanagedType)
            {
                sb.AppendLine("/// MemoryPack GenerateType: unmanaged<br/>");
            }
            else
            {
                sb.AppendLine("/// MemoryPack GenerateType: " + type.GenerateType.ToString() + "<br/>");
            }
            sb.AppendLine("/// <code>");
        }

        foreach (var item in type.Members)
        {
            if (xmlDocument)
            {
                sb.Append("/// <b>");
            }

            sb.Append(WithEscape(item.MemberType));
            if (xmlDocument)
            {
                sb.Append("</b>");
            }

            sb.Append(" ");
            sb.Append(item.Name);

            if (xmlDocument)
            {
                sb.AppendLine("<br/>");
            }
            else
            {
                sb.AppendLine();
            }
        }
        if (xmlDocument)
        {
            sb.AppendLine("/// </code>");
            sb.AppendLine("/// </remarks>");
        }
    }
}

public partial class TypeMeta
{
    public void Emit(StringBuilder writer, IGeneratorContext context)
    {
        if (IsUnion)
        {
            writer.AppendLine(EmitUnionTemplate(context));
            return;
        }

        if (GenerateType == GenerateType.Collection)
        {
            writer.AppendLine(EmitGenericCollectionTemplate(context));
            return;
        }

        var serializeBody = "";
        var deserializeBody = "";
        if (IsUnmanagedType)
        {
            serializeBody = $$"""
        writer.WriteUnmanaged(value);
""";
            deserializeBody = $$"""
        reader.ReadUnmanaged(out value);
""";
        }
        else
        {
            var originalMembers = Members;
            if (GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
            {
                // for emit time, replace padded empty
                if (Members.Length != 0)
                {
                    var maxOrder = Members.Max(x => x.Order);
                    var tempMembers = new MemberMeta[maxOrder + 1];
                    for (int i = 0; i <= maxOrder; i++)
                    {
                        tempMembers[i] = Members.FirstOrDefault(x => x.Order == i) ?? MemberMeta.CreateEmpty(i);
                    }
                    Members = tempMembers;
                }
            }

            serializeBody = EmitSerializeBody(context.IsForUnity);
            deserializeBody = EmitDeserializeBody();

            Members = originalMembers;
        }

        var classOrStructOrRecord = (IsRecord, IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class",
        };

        var containingTypeDeclarations = new List<string>();
        var containingType = Symbol.ContainingType;
        while (containingType is not null)
        {
            containingTypeDeclarations.Add((containingType.IsRecord, containingType.IsValueType) switch
            {
                (true, true) => $"partial record struct {containingType.Name}",
                (true, false) => $"partial record {containingType.Name}",
                (false, true) => $"partial struct {containingType.Name}",
                (false, false) => $"partial class {containingType.Name}",
            });
            containingType = containingType.ContainingType;
        }
        containingTypeDeclarations.Reverse();

        var nullable = IsValueType ? "" : "?";

        string staticRegisterFormatterMethod, staticMemoryPackableMethod, scopedRef, constraint, registerBody, registerT;
        var fixedSizeInterface = "";
        var fixedSizeMethod = "";
        scopedRef = (context.IsCSharp11OrGreater())
            ? "scoped ref"
            : "ref";
        if (!context.IsNet7OrGreater)
        {
            staticRegisterFormatterMethod = "public static void ";
            staticMemoryPackableMethod = "public static void ";
            constraint = context.IsForUnity ? "" : "where TBufferWriter : class, System.Buffers.IBufferWriter<byte>";
            registerBody = $"global::MemoryPack.MemoryPackFormatterProvider.Register(new {Symbol.Name}Formatter());";
            registerT = "RegisterFormatter();";
        }
        else
        {
            staticRegisterFormatterMethod = $"static void IMemoryPackFormatterRegister.";
            staticMemoryPackableMethod = $"static void IMemoryPackable<{TypeName}>.";
            constraint = "";
            registerBody = $"global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.MemoryPackableFormatter<{TypeName}>());";
            registerT = $"global::MemoryPack.MemoryPackFormatterProvider.Register<{TypeName}>();";

            // similar as VersionTolerantOptimized but not includes String, Array
            var fixedSize = false;
            if (Members.All(x => x.Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable or MemberKind.Blank))
            {
                fixedSize = true;
            }

            var callbackCount = new[] { this.OnSerializing, this.OnSerialized, this.OnDeserialized, this.OnDeserializing }.Select(x => x.Length).Sum();
            if (fixedSize && GenerateType == GenerateType.Object && !this.IsValueType && callbackCount == 0)
            {
                var sizeOf = string.Join(" + ", Members.Select(x => $"System.Runtime.CompilerServices.Unsafe.SizeOf<{x.MemberType.FullyQualifiedToString()}>()"));
                var headerPlus = (Members.Length == 0) ? "1" : "1 + ";
                fixedSizeInterface = ", global::MemoryPack.IFixedSizeMemoryPackable";
                fixedSizeMethod = $$"""

    [global::MemoryPack.Internal.Preserve]
    static int global::MemoryPack.IFixedSizeMemoryPackable.Size => {{headerPlus}}{{sizeOf}};

""";
            }
        }
        var serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        foreach (var declaration in containingTypeDeclarations)
        {
            writer.AppendLine(declaration);
            writer.AppendLine("{");
        }

        writer.AppendLine($$"""
partial {{classOrStructOrRecord}} {{TypeName}} : IMemoryPackable<{{TypeName}}>{{fixedSizeInterface}}
{
{{EmitCustomFormatters()}}
    static partial void StaticConstructor();

    static {{Symbol.Name}}()
    {
        {{registerT}}
        StaticConstructor();
    }
{{fixedSizeMethod}}
    [global::MemoryPack.Internal.Preserve]
    {{staticRegisterFormatterMethod}}RegisterFormatter()
    {
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{TypeName}}>())
        {
            {{registerBody}}
        }
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{TypeName}}[]>())
        {
            global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.ArrayFormatter<{{TypeName}}>());
        }
{{EmitAdditionalRegisterFormatter("        ", context)}}
    }

    [global::MemoryPack.Internal.Preserve]
    {{staticMemoryPackableMethod}}{{serializeMethodSignarture}} writer, {{scopedRef}} {{TypeName}}{{nullable}} value) {{constraint}}
    {
{{OnSerializing.Select(x => "        " + x.Emit()).NewLine()}}
{{serializeBody}}
    END:
{{OnSerialized.Select(x => "        " + x.Emit()).NewLine()}}
        return;
    }

    [global::MemoryPack.Internal.Preserve]
    {{staticMemoryPackableMethod}}Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{TypeName}}{{nullable}} value)
    {
{{OnDeserializing.Select(x => "        " + x.Emit()).NewLine()}}
{{deserializeBody}}
    END:
{{OnDeserialized.Select(x => "        " + x.Emit()).NewLine()}}
        return;
    }
}
""");

        if (!context.IsNet7OrGreater)
        {
            // add formatter(can not use MemoryPackableFormatter)

            var code = $$"""
partial {{classOrStructOrRecord}} {{TypeName}}
{
    [global::MemoryPack.Internal.Preserve]
    sealed class {{Symbol.Name}}Formatter : MemoryPackFormatter<{{TypeName}}>
    {
        [global::MemoryPack.Internal.Preserve]
        public override void {{serializeMethodSignarture}} writer,  {{scopedRef}} {{TypeName}} value)
        {
            {{TypeName}}.Serialize(ref writer, ref value);
        }

        [global::MemoryPack.Internal.Preserve]
        public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{TypeName}} value)
        {
            {{TypeName}}.Deserialize(ref reader, ref value);
        }
    }
}
""";
            writer.AppendLine(code);
        }

        for(int i = 0; i < containingTypeDeclarations.Count; ++i)
        {
            writer.AppendLine("}");
        }
    }

    private string EmitDeserializeBody()
    {
        var count = Members.Length;

        var isVersionTolerant = this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference;
        var readBeginBody = "";
        var readEndBody = "";
        var commentOutInvalidBody = "";
        var circularReferenceBody = "";
        var circularReferenceBody2 = "";

        if (isVersionTolerant)
        {
            readBeginBody = """
        Span<int> deltas = stackalloc int[count];
        for (int i = 0; i < count; i++)
        {
            deltas[i] = reader.ReadVarIntInt32();
        }
""";

            readEndBody = """
        if (count == readCount) goto END;

        for (int i = readCount; i < count; i++)
        {
            reader.Advance(deltas[i]);
        }
""";

            commentOutInvalidBody = "// ";
        }
        if (GenerateType == GenerateType.CircularReference)
        {
            circularReferenceBody = $$"""
        uint id;
        if (count == MemoryPackCode.ReferenceId)
        {
            id = reader.ReadVarIntUInt32();
            value = ({{TypeName}})reader.OptionalState.GetObjectReference(id);
            goto END;
        }
""";

            circularReferenceBody2 = $$"""
        id = reader.ReadVarIntUInt32();
        if (value == null)
        {
            value = new {{TypeName}}();
        }
        reader.OptionalState.AddObjectReference(id, value);
""";
        }

        return $$"""
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = default!;
            goto END;
        }
{{circularReferenceBody}}
{{readBeginBody}}
{{circularReferenceBody2}}
{{Members.Where(x => x.Symbol != null).Select(x => $"        {x.MemberType.FullyQualifiedToString()} __{x.Name};").NewLine()}}

        {{(!isVersionTolerant ? "" : "var readCount = " + count + ";")}}
        if (count == {{count}})
        {
            {{(IsValueType ? "" : "if (value == null)")}}
            {
{{EmitDeserializeMembers(Members, "                ")}}

                goto NEW;
            }
{{(IsValueType ? "#if false" : "            else")}}
            {
{{Members.Where(x => x.Symbol != null).Select(x => $"                __{x.Name} = value.@{x.Name};").NewLine()}}

{{Members.Select(x => "                " + x.EmitReadRefDeserialize(x.Order, GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)).NewLine()}}

                goto SET;
            }
{{(IsValueType ? "#endif" : "")}}
        }
        {{commentOutInvalidBody}}else if (count > {{count}})
        {{commentOutInvalidBody}}{
            {{commentOutInvalidBody}}MemoryPackSerializationException.ThrowInvalidPropertyCount(typeof({{TypeName}}), {{count}}, count);
            {{commentOutInvalidBody}}goto READ_END;
        {{commentOutInvalidBody}}}
        else
        {
            {{(IsValueType ? "" : "if (value == null)")}}
            {
{{Members.Where(x => x.Symbol != null).Select(x => $"               __{x.Name} = default!;").NewLine()}}
            }
{{(IsValueType ? "#if false" : "            else")}}
            {
{{Members.Where(x => x.Symbol != null).Select(x => $"               __{x.Name} = value.@{x.Name};").NewLine()}}
            }
{{(IsValueType ? "#endif" : "")}}

            if (count == 0) goto SKIP_READ;
{{Members.Select((x, i) => "            " + x.EmitReadRefDeserialize(x.Order, GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference) + $" if (count == {i + 1}) goto SKIP_READ;").NewLine()}}

    SKIP_READ:
            {{(IsValueType ? "" : "if (value == null)")}}
            {
                goto NEW;
            }
{{(IsValueType ? "#if false" : "            else")}}
            {
                goto SET;
            }
{{(IsValueType ? "#endif" : "")}}
        }

    SET:
        {{(!IsUseEmptyConstructor ? "goto NEW;" : "")}}
{{Members.Where(x => x.IsAssignable).Select(x => $"        {(IsUseEmptyConstructor ? "" : "// ")}value.@{x.Name} = __{x.Name};").NewLine()}}
        goto READ_END;

    NEW:
        value = {{EmitConstructor()}}
        {
{{EmitDeserializeConstruction("            ")}}
        };
{{EmitDeserializeConstructionWithBranching("        ")}}
    READ_END:
{{readEndBody}}
""";
    }

    string EmitAdditionalRegisterFormatter(string indent, IGeneratorContext context)
    {
        var collector = new TypeCollector();
        collector.Visit(this, false);

        var types = collector.GetTypes()
            .Select(x => (x, reference.KnownTypes.GetNonDefaultFormatterName(x)))
            .Where(x => x.Item2 != null)
            .Where(x =>
            {
                if (!context.IsNet7OrGreater)
                {
                    if (x.Item2!.StartsWith("global::MemoryPack.Formatters.InterfaceReadOnlySetFormatter"))
                    {
                        return false;
                    }
                    if (x.Item2!.StartsWith("global::MemoryPack.Formatters.PriorityQueueFormatter"))
                    {
                        return false;
                    }
                }
                return true;
            })
            .ToArray();

        if (types.Length == 0) return "";

        var sb = new StringBuilder();
        foreach (var (symbol, formatter) in types)
        {
            sb.AppendLine($"{indent}if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{symbol.FullyQualifiedToString()}>())");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    global::MemoryPack.MemoryPackFormatterProvider.Register(new {formatter}());");
            sb.AppendLine($"{indent}}}");
        }

        return sb.ToString();
    }

    string EmitCustomFormatters()
    {
        var sb = new StringBuilder();
        foreach (var item in Members.Where(x => x.Kind == MemberKind.CustomFormatter))
        {
            var fieldOrProp = item.IsField ? "Field" : "Property";

            sb.AppendLine($"    static readonly {item.CustomFormatterName} __{item.Name}Formatter = System.Reflection.CustomAttributeExtensions.GetCustomAttribute<{item.CustomFormatter!.FullyQualifiedToString()}>(typeof({this.Symbol.FullyQualifiedToString()}).Get{fieldOrProp}(\"{item.Name}\", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)).GetFormatter();");
        }
        return sb.ToString();
    }

    string EmitSerializeBody(bool isForUnity)
    {
        if (this.GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference)
        {
            if (Members.All(x => x.Kind is MemberKind.Unmanaged or MemberKind.String or MemberKind.Enum or MemberKind.UnmanagedArray or MemberKind.UnmanagedNullable or MemberKind.Blank))
            {
                return EmitVersionTorelantSerializeBodyOptimized(isForUnity);
            }
            else
            {
                return EmitVersionTorelantSerializeBody(isForUnity);
            }
        }

        return $$"""
{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            goto END;
        }
""" : "")}}

{{EmitSerializeMembers(Members, "        ", toTempWriter: false, writeObjectHeader: true)}}
""";
    }

    string EmitVersionTorelantSerializeBody(bool isForUnity)
    {
        var newTempWriter = isForUnity
            ? "new MemoryPackWriter(ref System.Runtime.CompilerServices.Unsafe.As<global::MemoryPack.Internal.ReusableLinkedArrayBufferWriter, System.Buffers.IBufferWriter<byte>>(ref tempBuffer), writer.OptionalState)"
            : "new MemoryPackWriter<global::MemoryPack.Internal.ReusableLinkedArrayBufferWriter>(ref tempBuffer, writer.OptionalState)";

        var checkCircularReference = "";
        if (GenerateType == GenerateType.CircularReference)
        {
            checkCircularReference = """
        var (existsReference, id) = writer.OptionalState.GetOrAddReference(value);
        if (existsReference)
        {
            writer.WriteObjectReferenceId(id);
            goto END;
        }
""";
        }

        return $$"""
{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            goto END;
        }
""" : "")}}
{{checkCircularReference}}
        var tempBuffer = global::MemoryPack.Internal.ReusableLinkedArrayBufferWriterPool.Rent();
        try
        {
            Span<int> offsets = stackalloc int[{{Members.Length}}];
            var tempWriter = {{newTempWriter}};

{{EmitSerializeMembers(Members, "            ", toTempWriter: true, writeObjectHeader: false)}}

            tempWriter.Flush();

            writer.WriteObjectHeader({{Members.Length}});
            for (int i = 0; i < {{Members.Length}}; i++)
            {
                int delta;
                if (i == 0)
                {
                    delta = offsets[i];
                }
                else
                {
                    delta = offsets[i] - offsets[i - 1];
                }
                writer.WriteVarInt(delta);
            }
            {{(GenerateType == GenerateType.CircularReference ? "writer.WriteVarInt(id);" : "")}}
            tempBuffer.WriteToAndReset(ref writer);
        }
        finally
        {
            global::MemoryPack.Internal.ReusableLinkedArrayBufferWriterPool.Return(tempBuffer);
        }
""";
    }

    // Optimized is all member is fixed size
    string EmitVersionTorelantSerializeBodyOptimized(bool isForUnity)
    {
        static string EmitLengthHeader(MemberMeta[] members)
        {
            var sb = new StringBuilder();
            foreach (var item in members)
            {
                sb.AppendLine("        " + item.EmitVarIntLength());
            }
            return sb.ToString();
        }

        var checkCircularReference = "";
        if (GenerateType == GenerateType.CircularReference)
        {
            checkCircularReference = """
        var (existsReference, id) = writer.OptionalState.GetOrAddReference(value);
        if (existsReference)
        {
            writer.WriteObjectReferenceId(id);
            goto END;
        }
""";
        }

        return $$"""
{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            goto END;
        }
""" : "")}}
{{checkCircularReference}}
        writer.WriteObjectHeader({{Members.Length}});
{{EmitLengthHeader(Members)}}
        {{(GenerateType == GenerateType.CircularReference ? "writer.WriteVarInt(id);" : "")}}
{{EmitSerializeMembers(Members, "        ", toTempWriter: false, writeObjectHeader: false)}}
""";
    }

    // toTempWriter is VersionTolerant
    public string EmitSerializeMembers(MemberMeta[] members, string indent, bool toTempWriter, bool writeObjectHeader)
    {
        // members is guranteed writable.
        if (members.Length == 0 && writeObjectHeader)
        {
            return $"{indent}writer.WriteObjectHeader(0);";
        }

        var writer = toTempWriter ? "tempWriter" : "writer";

        var sb = new StringBuilder();
        for (int i = 0; i < members.Length; i++)
        {
            if (!(members[i].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable) || toTempWriter)
            {
                sb.Append(indent);
                if (i == 0 && writeObjectHeader)
                {
                    sb.AppendLine($"{writer}.WriteObjectHeader({Members.Length});");
                    sb.Append(indent);
                }

                sb.Append(members[i].EmitSerialize(writer));
                if (toTempWriter)
                {
                    sb.AppendLine($" offsets[{i}] = tempWriter.WrittenCount;");
                }
                else
                {
                    sb.AppendLine();
                }
                continue;
            }

            // search optimization
            var optimizeFrom = i;
            var optimizeTo = i;
            var limit = Math.Min(members.Length, i + 15);
            var dangerous = "";
            for (int j = i; j < limit; j++)
            {
                if (members[j].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable)
                {
                    if (members[j].Kind is MemberKind.UnmanagedNullable)
                    {
                        dangerous = "Dangerous";
                    }
                    optimizeTo = j;
                    continue;
                }
                else
                {
                    break;
                }
            }

            // write method
            sb.Append(indent);
            if (optimizeFrom == 0 && writeObjectHeader)
            {
                sb.Append($"{writer}.{dangerous}WriteUnmanagedWithObjectHeader(");
                sb.Append(members.Length);
                sb.Append(", ");
            }
            else
            {
                sb.Append($"{writer}.{dangerous}WriteUnmanaged(");
            }

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }
                sb.Append("value.@");
                sb.Append(members[index].Name);
            }
            sb.Append(");");

            if (toTempWriter)
            {
                sb.AppendLine($" offsets[{i}] = tempWriter.WrittenCount;");
            }
            else
            {
                sb.AppendLine();
            }

            i = optimizeTo;
        }

        return sb.ToString();
    }

    // for optimize, can use same count, value == null.
    public string EmitDeserializeMembers(MemberMeta[] members, string indent)
    {
        // {{Members.Select(x => "                " + x.EmitReadToDeserialize()).NewLine()}}
        var sb = new StringBuilder();
        for (int i = 0; i < members.Length; i++)
        {
            if (!(members[i].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable) || (GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference))
            {
                sb.Append(indent);
                sb.AppendLine(members[i].EmitReadToDeserialize(i, GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference));
                continue;
            }

            // search optimization
            var optimizeFrom = i;
            var optimizeTo = i;
            var limit = Math.Min(members.Length, i + 15);
            var dangerous = "";
            for (int j = i; j < limit; j++)
            {
                if (members[j].Kind is MemberKind.Unmanaged or MemberKind.Enum or MemberKind.UnmanagedNullable)
                {
                    if (members[j].Kind is MemberKind.UnmanagedNullable)
                    {
                        dangerous = "Dangerous";
                    }
                    optimizeTo = j;
                    continue;
                }
                else
                {
                    break;
                }
            }

            // write read method
            sb.Append(indent);
            sb.Append($"reader.{dangerous}ReadUnmanaged(");

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }
                sb.Append("out __");
                sb.Append(members[index].Name);
            }
            sb.AppendLine(");");

            i = optimizeTo;
        }

        return sb.ToString();
    }

    string EmitConstructor()
    {
        // no need `;` because after using object initializer
        if (this.Constructor == null || this.Constructor.Parameters.Length == 0)
        {
            return $"new {TypeName}()";
        }
        else
        {
            var nameDict = Members.Where(x => x.IsConstructorParameter).ToDictionary(x => x.ConstructorParameterName, x => x.Name, StringComparer.OrdinalIgnoreCase);
            var parameters = this.Constructor.Parameters
                .Select(x =>
                {
                    if (nameDict.TryGetValue(x.Name, out var name))
                    {
                        return $"__{name}";
                    }
                    return null; // invalid, validated.
                })
                .Where(x => x != null);

            return $"new {TypeName}({string.Join(", ", parameters)})";
        }
    }

    string EmitDeserializeConstruction(string indent)
    {
        // all value is deserialized, __Name is exsits.
        return string.Join("," + Environment.NewLine, Members
            .Where(x => x is { IsSettable: true, IsConstructorParameter: false, SuppressDefaultInitialization: false })
            .Select(x => $"{indent}@{x.Name} = __{x.Name}"));
    }

    string EmitDeserializeConstructionWithBranching(string indent)
    {
        var members = Members
            .Select((x, i) => (x, i))
            .Where(v => v.x.SuppressDefaultInitialization);

        var lines = GenerateType is GenerateType.VersionTolerant or GenerateType.CircularReference
            ? members.Select(v => $"{indent}if (deltas.Length > {v.i} && deltas[{v.i}] != 0) value.@{v.x.Name} = __{v.x.Name};")
            : members.Select(v => $"{indent}if ({v.i + 1} <= count) value.@{v.x.Name} = __{v.x.Name};");

        return lines.NewLine();
    }

    string EmitUnionTemplate(IGeneratorContext context)
    {
        var classOrInterfaceOrRecord = IsRecord ? "record" : (Symbol.TypeKind == TypeKind.Interface) ? "interface" : "class";

        var staticRegisterFormatterMethod = (context.IsNet7OrGreater)
            ? $"static void IMemoryPackFormatterRegister."
            : "public static void ";
        var register = (context.IsNet7OrGreater)
            ? $"global::MemoryPack.MemoryPackFormatterProvider.Register<{TypeName}>();"
            : "RegisterFormatter();";
        var scopedRef = context.IsCSharp11OrGreater()
            ? "scoped ref"
            : "ref";
        string serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        var code = $$"""

partial {{classOrInterfaceOrRecord}} {{TypeName}} : IMemoryPackFormatterRegister
{
    static partial void StaticConstructor();

    static {{Symbol.Name}}()
    {
        {{register}}
        StaticConstructor();
    }

    [global::MemoryPack.Internal.Preserve]
    {{staticRegisterFormatterMethod}}RegisterFormatter()
    {
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{TypeName}}>())
        {
            global::MemoryPack.MemoryPackFormatterProvider.Register(new {{Symbol.Name}}Formatter());
        }
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{TypeName}}[]>())
        {
            global::MemoryPack.MemoryPackFormatterProvider.Register(new global::MemoryPack.Formatters.ArrayFormatter<{{TypeName}}>());
        }
    }

    [global::MemoryPack.Internal.Preserve]
    sealed class {{Symbol.Name}}Formatter : MemoryPackFormatter<{{TypeName}}>
    {
{{EmitUnionTypeToTagField()}}

        [global::MemoryPack.Internal.Preserve]
        public override void {{serializeMethodSignarture}} writer, {{scopedRef}} {{TypeName}}? value)
        {
{{OnSerializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionSerializeBody()}}
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
        }

        [global::MemoryPack.Internal.Preserve]
        public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{TypeName}}? value)
        {
{{OnDeserializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionDeserializeBody()}}
{{OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}
        }
    }
}
""";

        return code;
    }

    public void EmitUnionFormatterTemplate(StringBuilder writer, IGeneratorContext context, INamedTypeSymbol formatterSymbol)
    {
        var scopedRef = context.IsCSharp11OrGreater()
            ? "scoped ref"
            : "ref";
        string serializeMethodSignarture = context.IsForUnity
            ? "Serialize(ref MemoryPackWriter"
            : "Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter>";

        string registerFormatterCode;
        if (!Symbol.IsGenericType || !Symbol.IsUnboundGenericType)
        {
            registerFormatterCode = $$"""
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{Symbol.FullyQualifiedToString()}}>())
        {
            global::MemoryPack.MemoryPackFormatterProvider.Register(new {{TypeName}}());
        }
""";
        }
        else
        {
            registerFormatterCode = $$"""
        global::MemoryPack.MemoryPackFormatterProvider.RegisterGenericType(typeof({{Symbol.ConstructUnboundGenericType().FullyQualifiedToString()}}), typeof({{formatterSymbol.ConstructUnboundGenericType().FullyQualifiedToString()}}));
""";
        }

        var symbolFullQualified = ToUnionTagTypeFullyQualifiedToString(Symbol);
        var initializerName = TypeName.Replace("global::", "").Replace("<", "_").Replace(">", "_") + "Initializer";

        var code = $$"""
[global::MemoryPack.Internal.Preserve]
partial class {{TypeName}} : MemoryPackFormatter<{{symbolFullQualified}}>
{
{{EmitUnionTypeToTagField()}}

        [global::MemoryPack.Internal.Preserve]
        public override void {{serializeMethodSignarture}} writer, {{scopedRef}} {{symbolFullQualified}}? value)
        {
{{OnSerializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionSerializeBody()}}
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
        }

        [global::MemoryPack.Internal.Preserve]
        public override void Deserialize(ref MemoryPackReader reader, {{scopedRef}} {{symbolFullQualified}}? value)
        {
{{OnDeserializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionDeserializeBody()}}
{{OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}
        }
}

public static class {{initializerName}}
{
#if NET5_0_OR_GREATER
    [System.Runtime.CompilerServices.ModuleInitializer]
#endif
    public static void RegisterFormatter()
    {
{{registerFormatterCode}}
    }
}
""";

        writer.AppendLine(code);
    }

    string ToUnionTagTypeFullyQualifiedToString(INamedTypeSymbol type)
    {
        if (type.IsGenericType && this.Symbol.IsGenericType)
        {
            // when generic type, it is unconstructed.( typeof(T<>) ) so construct symbol's T
            var typeName = string.Join(", ", this.Symbol.TypeArguments.Select(x => x.FullyQualifiedToString()));
            return type.FullyQualifiedToString().Replace("<>", "<" + typeName + ">");
        }
        else
        {
            return type.FullyQualifiedToString();
        }
    }

    string EmitUnionTypeToTagField()
    {
        var elements = UnionTags.Select(x => $"            {{ typeof({ToUnionTagTypeFullyQualifiedToString(x.Type)}), {x.Tag} }},").NewLine();

        return $$"""
        static readonly System.Collections.Generic.Dictionary<Type, ushort> __typeToTag = new({{UnionTags.Length}})
        {
{{elements}}
        };
""";
    }

    string EmitUnionSerializeBody()
    {
        var symbolFullQualified = ToUnionTagTypeFullyQualifiedToString(Symbol);

        var writeBody = UnionTags
            .Select(x =>
            {
                var method = (x.Type.TryGetMemoryPackableType(reference, out var genType, out _) && genType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
                    ? "WritePackable"
                    : "WriteValue";
                return $"                    case {x.Tag}: writer.{method}(System.Runtime.CompilerServices.Unsafe.As<{symbolFullQualified}?, {ToUnionTagTypeFullyQualifiedToString(x.Type)}>(ref value)); break;";
            })
            .NewLine();

        return $$"""
            if (value == null)
            {
                writer.WriteNullUnionHeader();
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
                return;
            }

            if (__typeToTag.TryGetValue(value.GetType(), out var tag))
            {
                writer.WriteUnionHeader(tag);

                switch (tag)
                {
{{writeBody}}
                    default:
                        break;
                }
            }
            else
            {
                MemoryPackSerializationException.ThrowNotFoundInUnionType(value.GetType(), typeof({{symbolFullQualified}}));
            }
""";
    }

    string EmitUnionDeserializeBody()
    {
        var symbolFullQualified = ToUnionTagTypeFullyQualifiedToString(Symbol);

        var readBody = UnionTags.Select(x =>
        {
            var tagTypeFullQualified = ToUnionTagTypeFullyQualifiedToString(x.Type);

            var method = (x.Type.TryGetMemoryPackableType(reference, out var genType, out _) && genType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
                ? "ReadPackable"
                : "ReadValue";

            var castString = method == "ReadPackable" && symbolFullQualified != tagTypeFullQualified
                ? $"({tagTypeFullQualified})"
                : "";

            return $$"""
                case {{x.Tag}}:
                    if (value is {{tagTypeFullQualified}})
                    {
                        reader.{{method}}(ref System.Runtime.CompilerServices.Unsafe.As<{{symbolFullQualified}}?, {{tagTypeFullQualified}}>(ref value));
                    }
                    else
                    {
                        value = {{castString}}reader.{{method}}<{{tagTypeFullQualified}}>();
                    }
                    break;
""";
        }).NewLine();


        return $$"""
            if (!reader.TryReadUnionHeader(out var tag))
            {
                value = default;
{{OnDeserialized.Select(x => "                " + x.Emit()).NewLine()}}
                return;
            }

            switch (tag)
            {
{{readBody}}
                default:
                    MemoryPackSerializationException.ThrowInvalidTag(tag, typeof({{symbolFullQualified}}));
                    break;
            }
""";
    }

    string EmitGenericCollectionTemplate(IGeneratorContext context)
    {
        var (collectionKind, collectionSymbol) = ParseCollectionKind(Symbol, reference);
        var methodName = collectionKind switch
        {
            CollectionKind.Collection => "Collection",
            CollectionKind.Set => "Set",
            CollectionKind.Dictionary => "Dictionary",
            _ => "",
        };

        var typeArgs = string.Join(", ", collectionSymbol!.TypeArguments.Select(x => x.FullyQualifiedToString()));

        var staticRegisterFormatterMethod = (context.IsNet7OrGreater)
            ? $"static void IMemoryPackFormatterRegister."
            : "public static void ";
        var register = (context.IsNet7OrGreater)
            ? $"global::MemoryPack.MemoryPackFormatterProvider.Register<{TypeName}>();"
            : "RegisterFormatter();";

        var code = $$"""
partial class {{TypeName}} : IMemoryPackFormatterRegister
{
    static partial void StaticConstructor();

    static {{Symbol.Name}}()
    {
        {{register}}
        StaticConstructor();
    }

    {{staticRegisterFormatterMethod}}RegisterFormatter()
    {
        if (!global::MemoryPack.MemoryPackFormatterProvider.IsRegistered<{{TypeName}}>())
        {
            global::MemoryPack.MemoryPackFormatterProvider.Register{{methodName}}<{{TypeName}}, {{typeArgs}}>();
        }
    }
}
""";

        return code;
    }
}

public partial class MethodMeta
{
    public string Emit()
    {
        var instance = (IsStatic) ? ""
            : (IsValueType) ? "value."
            : "value?.";

        if (UseReaderArgument)
        {
            return $"{instance}{Name}(ref reader, ref value);";
        }
        else if (UseWriterArgument)
        {
            return $"{instance}{Name}(ref writer, ref value);";
        }
        else
        {
            return $"{instance}{Name}();";
        }
    }
}

public partial class MemberMeta
{
    public string EmitSerialize(string writer)
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{writer}.WritePackable(value.@{Name});";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{writer}.WriteUnmanaged(value.@{Name});";
            case MemberKind.UnmanagedNullable:
                return $"{writer}.DangerousWriteUnmanaged(value.@{Name});";
            case MemberKind.String:
                return $"{writer}.WriteString(value.@{Name});";
            case MemberKind.UnmanagedArray:
                return $"{writer}.WriteUnmanagedArray(value.@{Name});";
            case MemberKind.MemoryPackableArray:
                return $"{writer}.WritePackableArray(value.@{Name});";
            case MemberKind.MemoryPackableList:
                return $"global::MemoryPack.Formatters.ListFormatter.SerializePackable(ref {writer}, value.@{Name});";
            case MemberKind.Array:
                return $"{writer}.WriteArray(value.@{Name});";
            case MemberKind.Blank:
                return "";
            case MemberKind.CustomFormatter:
                return $"{writer}.WriteValueWithFormatter(__{Name}Formatter, value.@{Name});";
            default:
                return $"{writer}.WriteValue(value.@{Name});";
        }
    }

    public string EmitVarIntLength()
    {
        switch (Kind)
        {
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
            case MemberKind.UnmanagedNullable:
                return $"writer.WriteVarInt(System.Runtime.CompilerServices.Unsafe.SizeOf<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>());";
            case MemberKind.String:
                return $"writer.WriteVarInt(writer.GetStringWriteLength(value.@{Name}));";
            case MemberKind.UnmanagedArray:
                return $"writer.WriteVarInt(writer.GetUnmanageArrayWriteLength<{(MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(value.@{Name}));";
            case MemberKind.Blank:
                return $"writer.WriteVarInt(0);";
            default:
                throw new InvalidOperationException("This MemberKind is not supported, Kind:" + Kind);
        }
    }

    public string EmitReadToDeserialize(int i, bool requireDeltaCheck)
    {
        var equalDefault = Kind == MemberKind.Blank
            ? "{ }"
            : $"{{ __{Name} = default; }}";

        var pre = requireDeltaCheck
            ? $"if (deltas[{i}] == 0) {equalDefault} else "
            : "";

        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{pre}__{Name} = reader.ReadPackable<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{pre}reader.ReadUnmanaged(out __{Name});";
            case MemberKind.UnmanagedNullable:
                return $"{pre}reader.DangerousReadUnmanaged(out __{Name});";
            case MemberKind.String:
                return $"{pre}__{Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"{pre}__{Name} = reader.ReadUnmanagedArray<{(MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.MemoryPackableArray:
                return $"{pre}__{Name} = reader.ReadPackableArray<{(MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.MemoryPackableList:
                return $"{pre}__{Name} = global::MemoryPack.Formatters.ListFormatter.DeserializePackable<{(MemberType as INamedTypeSymbol)!.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(ref reader);";
            case MemberKind.Array:
                return $"{pre}__{Name} = reader.ReadArray<{(MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Blank:
                return $"{pre}reader.Advance(deltas[{i}]);";
            case MemberKind.CustomFormatter:
                {
                    var mt = MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    return $"{pre}__{Name} = reader.ReadValueWithFormatter<{CustomFormatterName}, {mt}>(__{Name}Formatter);";
                }
            default:
                return $"{pre}__{Name} = reader.ReadValue<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
        }
    }

    public string EmitReadRefDeserialize(int i, bool requireDeltaCheck)
    {
        var pre = requireDeltaCheck
            ? $"if (deltas[{i}] != 0) "
            : "";

        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"{pre}reader.ReadPackable(ref __{Name});";
            case MemberKind.Unmanaged:
            case MemberKind.Enum:
                return $"{pre}reader.ReadUnmanaged(out __{Name});";
            case MemberKind.UnmanagedNullable:
                return $"{pre}reader.DangerousReadUnmanaged(out __{Name});";
            case MemberKind.String:
                return $"{pre}__{Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"{pre}reader.ReadUnmanagedArray(ref __{Name});";
            case MemberKind.MemoryPackableArray:
                return $"{pre}reader.ReadPackableArray(ref __{Name});";
            case MemberKind.MemoryPackableList:
                return $"{pre}global::MemoryPack.Formatters.ListFormatter.DeserializePackable(ref reader, ref __{Name});";
            case MemberKind.Array:
                return $"{pre}reader.ReadArray(ref __{Name});";
            case MemberKind.Blank:
                return $"{pre}reader.Advance(deltas[{i}]);";
            case MemberKind.CustomFormatter:
                return $"{pre}reader.ReadValueWithFormatter(__{Name}Formatter, ref __{Name});";
            default:
                return $"{pre}reader.ReadValue(ref __{Name});";
        }
    }
}



================================================
FILE: src/MemoryPack.Generator/MemoryPackGenerator.Parser.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.ComponentModel;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;

namespace MemoryPack.Generator;

public enum CollectionKind
{
    None, Collection, Set, Dictionary
}

public enum MemberKind
{
    MemoryPackable, // IMemoryPackable<> or [MemoryPackable]
    Unmanaged,
    Nullable,
    UnmanagedNullable,
    KnownType,
    String,
    Array,
    UnmanagedArray,
    MemoryPackableArray, // T[] where T: IMemoryPackable<T>
    MemoryPackableList, // List<T> where T: IMemoryPackable<T>
    MemoryPackableCollection, // GenerateType.Collection
    MemoryPackableNoGenerate, // GenerateType.NoGenerate
    MemoryPackableUnion,
    Enum,

    // from attribute
    AllowSerialize,
    MemoryPackUnion,

    Object, // others allow
    RefLike, // not allowed
    NonSerializable, // not allowed
    Blank, // blank marker
    CustomFormatter, // used [MemoryPackCustomFormatterAttribtue]
}

public partial class TypeMeta
{
    DiagnosticDescriptor? ctorInvalid = null;

    readonly ReferenceSymbols reference;
    public INamedTypeSymbol Symbol { get; set; }
    public GenerateType GenerateType { get; }
    public SerializeLayout SerializeLayout { get; }
    /// <summary>MinimallyQualifiedFormat(include generics T)</summary>
    public string TypeName { get; }
    public MemberMeta[] Members { get; private set; }
    public bool IsValueType { get; set; }
    public bool IsUnmanagedType { get; }
    public bool IsUnion { get; }
    public bool IsRecord { get; }
    public bool IsInterfaceOrAbstract { get; }
    public IMethodSymbol? Constructor { get; }
    public MethodMeta[] OnSerializing { get; }
    public MethodMeta[] OnSerialized { get; }
    public MethodMeta[] OnDeserializing { get; }
    public MethodMeta[] OnDeserialized { get; }
    public (ushort Tag, INamedTypeSymbol Type)[] UnionTags { get; }
    public bool IsUseEmptyConstructor => Constructor == null || Constructor.Parameters.IsEmpty;

    public TypeMeta(INamedTypeSymbol symbol, ReferenceSymbols reference)
    {
        this.reference = reference;
        this.Symbol = symbol;

        symbol.TryGetMemoryPackableType(reference, out var generateType, out var serializeLayout);
        this.GenerateType = generateType;
        this.SerializeLayout = serializeLayout;

        this.TypeName = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        this.Constructor = ChooseConstructor(symbol, reference);

        this.Members = symbol.GetAllMembers() // iterate includes parent type
            .Where(x => x is (IFieldSymbol or IPropertySymbol) and { IsStatic: false, IsImplicitlyDeclared: false, CanBeReferencedByName: true })
            .Reverse()
            .DistinctBy(x => x.Name) // remove duplicate name(new)
            .Reverse()
            .Where(x =>
            {
                var include = x.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                var ignore = x.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                if (ignore) return false;
                if (include) return true;
                return x.DeclaredAccessibility is Accessibility.Public;
            })
            .Where(x =>
            {
                if (x is IPropertySymbol p)
                {
                    // set only can't be serializable member
                    if (p.GetMethod == null && p.SetMethod != null)
                    {
                        return false;
                    }
                    if (p.IsIndexer) return false;
                }
                return true;
            })
            .Select((x, i) => new MemberMeta(x, Constructor, reference, i))
            .OrderBy(x => x.Order)
            .ToArray();

        this.IsValueType = symbol.IsValueType;
        this.IsUnmanagedType = symbol.IsUnmanagedType;
        this.IsInterfaceOrAbstract = symbol.IsAbstract;
        this.IsUnion = symbol.ContainsAttribute(reference.MemoryPackUnionAttribute);
        this.IsRecord = symbol.IsRecord;
        this.OnSerializing = CollectMethod(reference.MemoryPackOnSerializingAttribute, IsValueType, isReader: false);
        this.OnSerialized = CollectMethod(reference.MemoryPackOnSerializedAttribute, IsValueType, isReader: false);
        this.OnDeserializing = CollectMethod(reference.MemoryPackOnDeserializingAttribute, IsValueType, isReader: true);
        this.OnDeserialized = CollectMethod(reference.MemoryPackOnDeserializedAttribute, IsValueType, isReader: true);

        if (IsUnion)
        {
            this.UnionTags = symbol.GetAttributes()
                .Where(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, reference.MemoryPackUnionAttribute))
                .Where(x => x.ConstructorArguments.Length == 2)
                .Select(x => ((ushort)x.ConstructorArguments[0].Value!, (INamedTypeSymbol)x.ConstructorArguments[1].Value!))
                .ToArray();
        }
        else
        {
            this.UnionTags = Array.Empty<(ushort, INamedTypeSymbol)>();
        }
    }

    // MemoryPack choose class/struct as same rule.
    // If has no explicit constrtucotr, use parameterless one(includes private).
    // If has a one parameterless/parameterized constructor, choose it.
    // If has multiple construcotrs, should apply [MemoryPackConstructor] attribute(no automatically choose one), otherwise generator error it.
    IMethodSymbol? ChooseConstructor(INamedTypeSymbol symbol, ReferenceSymbols reference)
    {
        var ctors = symbol.InstanceConstructors
            .Where(x => !x.IsImplicitlyDeclared) // remove empty ctor(struct always generate it), record's clone ctor
            .ToArray();

        if (ctors.Length == 0)
        {
            return null; // allows null as ok(not exists explicitly declared constructor == has implictly empty ctor)
        }

        if (!Symbol.IsUnmanagedType && ctors.Length == 1)
        {
            return ctors[0];
        }

        var ctorWithAttrs = ctors.Where(x => x.ContainsAttribute(reference.MemoryPackConstructorAttribute)).ToArray();

        if (Symbol.IsUnmanagedType)
        {
            if (ctorWithAttrs.Length != 0)
            {
                ctorInvalid = DiagnosticDescriptors.UnamangedStructMemoryPackCtor;
            }
            return null;
        }

        if (ctorWithAttrs.Length == 0)
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorWithoutAttribute;
            return null;
        }
        else if (ctorWithAttrs.Length == 1)
        {
            return ctorWithAttrs[0]; // ok
        }
        else
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorAttribute;
            return null;
        }
    }

    MethodMeta[] CollectMethod(INamedTypeSymbol attribute, bool isValueType, bool isReader)
    {
        return Symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.ContainsAttribute(attribute))
            .Select(x => new MethodMeta(x, isValueType, isReader))
            .ToArray();
    }

    public static (CollectionKind, INamedTypeSymbol?) ParseCollectionKind(INamedTypeSymbol? symbol, ReferenceSymbols reference)
    {
        if (symbol == null) goto NONE;

        INamedTypeSymbol? dictionary = default;
        INamedTypeSymbol? set = default;
        INamedTypeSymbol? collection = default;
        foreach (var item in symbol.AllInterfaces)
        {
            if (item.EqualsUnconstructedGenericType(reference.KnownTypes.System_Collections_Generic_IDictionary_T))
            {
                dictionary = item;
            }
            else if (item.EqualsUnconstructedGenericType(reference.KnownTypes.System_Collections_Generic_ISet_T))
            {
                set = item;
            }
            else if (item.EqualsUnconstructedGenericType(reference.KnownTypes.System_Collections_Generic_ICollection_T))
            {
                collection = item;
            }
        }

        if (dictionary != null)
        {
            return (CollectionKind.Dictionary, dictionary);
        }
        if (set != null)
        {
            return (CollectionKind.Set, set);
        }
        if (collection != null)
        {
            return (CollectionKind.Collection, collection);
        }

    NONE:
        return (CollectionKind.None, null);
    }

    public bool Validate(TypeDeclarationSyntax syntax, IGeneratorContext context, bool unionFormatter)
    {
        var noError = true;
        if (unionFormatter) goto UNION_VALIDATIONS;

        if (GenerateType == GenerateType.NoGenerate) return true;
        if (GenerateType is GenerateType.Collection)
        {
            if (Symbol.IsAbstract)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CollectionGenerateIsAbstract, syntax.Identifier.GetLocation(), Symbol.Name));
                return false;
            }

            var (kind, symbol) = ParseCollectionKind(Symbol, reference);
            if (kind == CollectionKind.None)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CollectionGenerateNotImplementedInterface, syntax.Identifier.GetLocation(), Symbol.Name));
                return false;
            }

            var hasParameterlessConstructor = Symbol.InstanceConstructors
                .Where(x => x.DeclaredAccessibility == Accessibility.Public)
                .Any(x => x.Parameters.Length == 0);
            if (!hasParameterlessConstructor)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CollectionGenerateNoParameterlessConstructor, syntax.Identifier.GetLocation(), Symbol.Name));
                return false;
            }

            return true;
        }
        if (GenerateType is GenerateType.CircularReference)
        {
            if (!this.IsUseEmptyConstructor)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CircularReferenceOnlyAllowsParameterlessConstructor, syntax.Identifier.GetLocation(), Symbol.Name));
                return false;
            }
        }

        // GenerateType.Objector VersionTorelant validation

        // ref strcut
        if (this.Symbol.IsRefLikeType)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.TypeIsRefStruct, syntax.Identifier.GetLocation(), Symbol.Name));
            return false;
        }

        // interface/abstract but not union
        if (IsInterfaceOrAbstract && !IsUnion)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AbstractMustUnion, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        // ctor
        if (ctorInvalid != null)
        {
            context.ReportDiagnostic(Diagnostic.Create(ctorInvalid, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        if (this.IsUnmanagedType)
        {
            if (GenerateType is GenerateType.VersionTolerant)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.VersionTolerantOnUnmanagedStruct, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            var structLayoutFields = this.Symbol.GetAllMembers()
                .OfType<IFieldSymbol>()
                .Select(x =>
                {
                    if (x.IsStatic) return null;

                    // ValueTuple, DateTime, DateTimeOffset is auto but can not get from Roslyn GetAttributes.

                    if (SymbolEqualityComparer.Default.Equals(x.Type, reference.KnownTypes.System_DateTime) || SymbolEqualityComparer.Default.Equals(x.Type, reference.KnownTypes.System_DateTimeOffset))
                    {
                        return Tuple.Create(x.Type, LayoutKind.Auto);
                    }

                    if (x.Type is INamedTypeSymbol nts && nts.IsGenericType)
                    {
                        var fullyQualifiedString = nts.ConstructUnboundGenericType().FullyQualifiedToString();
                        if (fullyQualifiedString.StartsWith("global::System.ValueTuple<"))
                        {
                            return Tuple.Create(x.Type, LayoutKind.Auto);
                        }
                    }

                    var structLayout = x.Type.GetAttribute(reference.KnownTypes.System_Runtime_InteropServices_StructLayout);
                    var layoutKind = (structLayout != null && structLayout.ConstructorArguments.Length != 0)
                        ? structLayout.ConstructorArguments[0].Value
                        : null;

                    if (layoutKind != null)
                    {
                        return Tuple.Create(x.Type, (LayoutKind)layoutKind);
                    }

                    return null;
                })
                .Where(x => x != null && x.Item2 == LayoutKind.Auto)
                .ToArray();

            // has auto field, should mark Auto in lower Net6
            if (structLayoutFields.Length != 0)
            {
                var structLayout = Symbol.GetAttribute(reference.KnownTypes.System_Runtime_InteropServices_StructLayout);
                var layoutKind = (structLayout != null && structLayout.ConstructorArguments.Length != 0)
                    ? structLayout.ConstructorArguments[0].Value
                    : null;

                if (layoutKind == null || (LayoutKind)layoutKind == LayoutKind.Sequential)
                {
                    var autoTypes = string.Join(", ", structLayoutFields.Select(x => x!.Item1.Name));

                    if (!context.IsNet7OrGreater)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnamangedStructWithLayoutAutoField, syntax.Identifier.GetLocation(), Symbol.Name, autoTypes));
                        noError = false;
                    }
                }
            }
        }
        else
        {
            // check ctor members
            if (this.Constructor != null)
            {
                foreach (var parameter in Constructor.Parameters)
                {
                    if (!Members.ContainsConstructorParameter(parameter))
                    {
                        var location = Constructor.Locations.FirstOrDefault() ?? syntax.Identifier.GetLocation();

                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ConstructorHasNoMatchedParameter, location, Symbol.Name, parameter.Name));
                        noError = false;
                    }
                }
            }

            foreach (var item in Members)
            {
                if (item.IsField && ((IFieldSymbol)item.Symbol).IsReadOnly && !item.IsConstructorParameter)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ReadOnlyFieldMustBeConstructorMember, item.GetLocation(syntax), Symbol.Name, item.Name));
                    noError = false;
                }
                else if (item is { SuppressDefaultInitialization: true, IsAssignable: false })
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SuppressDefaultInitializationMustBeSettable, item.GetLocation(syntax), Symbol.Name, item.Name));
                    noError = false;
                }
            }
        }

        // methods
        foreach (var item in OnSerializing.Concat(OnSerialized).Concat(OnDeserializing).Concat(OnDeserialized))
        {
            // diagnostics location should be method identifier
            // however methodsymbol -> methodsyntax is slightly hard so use type identifier instead.

            if (IsUnmanagedType)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodInUnamannagedType, item.GetLocation(syntax), Symbol.Name, item.Name));
                noError = false;
                continue;
            }

            if (item.Symbol.Parameters.Length != 0)
            {
                // if (ref reader/writer), ok.
                if (item.Symbol.Parameters.Length == 2)
                {
                    if (item.Symbol.Parameters[0].RefKind == RefKind.Ref && item.Symbol.Parameters[1].RefKind == RefKind.Ref)
                    {
                        // ref ref is ok.
                        continue;
                    }
                }

                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodHasParameter, item.GetLocation(syntax), Symbol.Name, item.Name));
                noError = false;
            }
        }

        if (Symbol.BaseType != null)
        {
            // Member override member can't annotate[Ignore][Include]
            foreach (var item in Symbol.GetAllMembers(withoutOverride: false))
            {
                if (item.IsOverride)
                {
                    var include = item.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                    var ignore = item.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                    if (include || ignore)
                    {
                        var location = item.Locations.FirstOrDefault() ?? syntax.Identifier.GetLocation();

                        var attr = include ? "MemoryPackInclude" : "MemoryPackIgnore";
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OverrideMemberCantAddAnnotation, location, Symbol.Name, item.Name, attr));
                        noError = false;
                    }
                }
            }

            // inherit type can not serialize parent private member
            foreach (var item in Symbol.GetParentMembers())
            {
                var include = item.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                var ignore = item.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                if (include && item.DeclaredAccessibility == Accessibility.Private)
                {
                    var location = item.Locations.FirstOrDefault() ?? syntax.Identifier.GetLocation();
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.InheritTypeCanNotIncludeParentPrivateMember, location, Symbol.Name, item.Name));
                    noError = false;
                }
            }
        }

        // ALl Members
        if (Members.Length >= 250) // MemoryPackCode.Reserved1
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MembersCountOver250, syntax.Identifier.GetLocation(), Symbol.Name, Members.Length));
            noError = false;
        }

        // exists can't serialize member
        foreach (var item in Members)
        {

            if (item.Kind == MemberKind.NonSerializable)
            {
                if (item.MemberType.SpecialType is SpecialType.System_Object or SpecialType.System_Array or SpecialType.System_Delegate or SpecialType.System_MulticastDelegate || item.MemberType.TypeKind == TypeKind.Delegate)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MemberCantSerializeType, item.GetLocation(syntax), Symbol.Name, item.Name, item.MemberType.FullyQualifiedToString()));
                    noError = false;
                }
                else
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MemberIsNotMemoryPackable, item.GetLocation(syntax), Symbol.Name, item.Name, item.MemberType.FullyQualifiedToString()));
                    noError = false;
                }
            }
            else if (item.Kind == MemberKind.RefLike)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MemberIsRefStruct, item.GetLocation(syntax), Symbol.Name, item.Name, item.MemberType.FullyQualifiedToString()));
                noError = false;
            }
        }

        // order
        if (SerializeLayout == SerializeLayout.Explicit)
        {
            // All members must annotate MemoryPackOrder
            foreach (var item in Members)
            {
                if (!item.HasExplicitOrder)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AllMembersMustAnnotateOrder, item.GetLocation(syntax), Symbol.Name, item.Name));
                    noError = false;
                }
            }

            // don't allow duplicate order
            var orderSet = new Dictionary<int, MemberMeta>(Members.Length);
            foreach (var item in Members)
            {
                if (orderSet.TryGetValue(item.Order, out var duplicateMember))
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.DuplicateOrderDoesNotAllow, item.GetLocation(syntax), Symbol.Name, item.Name, duplicateMember.Name));
                    noError = false;
                }
                else
                {
                    orderSet.Add(item.Order, item);
                }
            }

            // Annotated MemoryPackOrder must be continuous number from zero if GenerateType.Object.
            if (noError && GenerateType == GenerateType.Object)
            {
                var expectedOrder = 0;
                foreach (var item in Members)
                {
                    if (item.Order != expectedOrder)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AllMembersMustBeContinuousNumber, item.GetLocation(syntax), Symbol.Name, item.Name));
                        noError = false;
                        break;
                    }
                    expectedOrder++;
                }
            }
        }

    // Union validations
    UNION_VALIDATIONS:
        if (IsUnion)
        {
            if (Symbol.IsSealed)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SealedTypeCantBeUnion, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            if (!Symbol.IsAbstract)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ConcreteTypeCantBeUnion, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            if (GenerateType != GenerateType.Union)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeCannotSpeciyToUnionBaseType, syntax.Identifier.GetLocation(), Symbol.Name, GenerateType));
                noError = false;
            }

            if (UnionTags.Select(x => x.Tag).HasDuplicate())
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionTagDuplicate, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            foreach (var item in UnionTags)
            {
                // type does not derived target symbol
                if (Symbol.TypeKind == TypeKind.Interface)
                {
                    // interface, check interfaces.
                    var check = item.Type.IsGenericType
                        ? item.Type.OriginalDefinition.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(Symbol))
                        : item.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, Symbol));

                    if (!check)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberTypeNotImplementBaseType, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                        noError = false;
                    }
                }
                else
                {
                    // abstract type, check base.
                    var check = item.Type.IsGenericType
                        ? item.Type.OriginalDefinition.GetAllBaseTypes().Any(x => x.EqualsUnconstructedGenericType(Symbol))
                        : item.Type.GetAllBaseTypes().Any(x => SymbolEqualityComparer.Default.Equals(x, Symbol));

                    if (!check)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberTypeNotDerivedBaseType, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                        noError = false;
                    }
                }

                if (item.Type.IsValueType)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberNotAllowStruct, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                    noError = false;
                }

                if (!item.Type.ContainsAttribute(reference.MemoryPackableAttribute))
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberMustBeMemoryPackable, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                    noError = false;
                }
            }
        }

        return noError;
    }

    public override string ToString()
    {
        return this.TypeName;
    }
}

partial class MemberMeta
{
    public ISymbol Symbol { get; }
    public string Name { get; }
    public ITypeSymbol MemberType { get; }
    public INamedTypeSymbol? CustomFormatter { get; }
    public string? CustomFormatterName { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsSettable { get; }
    public bool IsAssignable { get; }
    public bool IsConstructorParameter { get; }
    public string? ConstructorParameterName { get; }
    public int Order { get; }
    public bool HasExplicitOrder { get; }
    public MemberKind Kind { get; }
    public bool SuppressDefaultInitialization { get; }

    MemberMeta(int order)
    {
        this.Symbol = null!;
        this.Name = null!;
        this.MemberType = null!;
        this.Order = order;
        this.Kind = MemberKind.Blank;
    }

    public MemberMeta(ISymbol symbol, IMethodSymbol? constructor, ReferenceSymbols references, int sequentialOrder)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.Order = sequentialOrder;
        this.SuppressDefaultInitialization = symbol.ContainsAttribute(references.SkipOverwriteDefaultAttribute);
        var orderAttr = symbol.GetAttribute(references.MemoryPackOrderAttribute);
        if (orderAttr != null)
        {
            this.Order = (int)(orderAttr.ConstructorArguments[0].Value ?? sequentialOrder);
            this.HasExplicitOrder = true;

        }
        else
        {
            this.HasExplicitOrder = false;
        }

        if (constructor != null)
        {
            this.IsConstructorParameter = constructor.TryGetConstructorParameter(symbol, out var constructorParameter);
            this.ConstructorParameterName = constructorParameter?.Name;
        }
        else
        {
            this.IsConstructorParameter = false;
        }

        if (symbol is IFieldSymbol f)
        {
            IsProperty = false;
            IsField = true;
            IsSettable = !f.IsReadOnly; // readonly field can not set.
            IsAssignable = IsSettable
#if !ROSLYN3
                 && !f.IsRequired
#endif
                ;
            MemberType = f.Type;
        }
        else if (symbol is IPropertySymbol p)
        {
            IsProperty = true;
            IsField = false;
            IsSettable = !p.IsReadOnly;
            IsAssignable = IsSettable
#if !ROSLYN3
                && !p.IsRequired
#endif
                && (p.SetMethod != null && !p.SetMethod.IsInitOnly);
            MemberType = p.Type;
        }
        else
        {
            throw new Exception("member is not field or property.");
        }

        if (references.MemoryPackCustomFormatterAttribute != null)
        {
            var genericFormatter = false;
            var customFormatterAttr = symbol.GetImplAttribute(references.MemoryPackCustomFormatterAttribute);
            if (customFormatterAttr == null && references.MemoryPackCustomFormatter2Attribute != null)
            {
                customFormatterAttr = symbol.GetImplAttribute(references.MemoryPackCustomFormatter2Attribute);
                genericFormatter = true;
            }

            if (customFormatterAttr != null)
            {
                CustomFormatter = customFormatterAttr.AttributeClass!;
                Kind = MemberKind.CustomFormatter;

                string formatterName;
                if (genericFormatter)
                {
                    formatterName = CustomFormatter.GetAllBaseTypes().First(x => x.EqualsUnconstructedGenericType(references.MemoryPackCustomFormatter2Attribute!))
                        .TypeArguments[0].FullyQualifiedToString();
                }
                else
                {
                    formatterName = $"IMemoryPackFormatter<{MemberType.FullyQualifiedToString()}>";
                }
                CustomFormatterName = formatterName;
                return;
            }
        }

        Kind = ParseMemberKind(symbol, MemberType, references);
    }

    public static MemberMeta CreateEmpty(int order)
    {
        return new MemberMeta(order);
    }

    public Location GetLocation(TypeDeclarationSyntax fallback)
    {
        var location = Symbol.Locations.FirstOrDefault() ?? fallback.Identifier.GetLocation();
        return location;
    }

    static MemberKind ParseMemberKind(ISymbol? memberSymbol, ITypeSymbol memberType, ReferenceSymbols references)
    {
        if (memberType.SpecialType is SpecialType.System_Object or SpecialType.System_Array or SpecialType.System_Delegate or SpecialType.System_MulticastDelegate || memberType.TypeKind == TypeKind.Delegate)
        {
            return MemberKind.NonSerializable; // object, Array, delegate is not allowed
        }
        else if (memberType.TypeKind == TypeKind.Enum)
        {
            return MemberKind.Enum;
        }
        else if (memberType.IsUnmanagedType)
        {
            if (memberType is INamedTypeSymbol unmanagedNts)
            {
                if (unmanagedNts.IsRefLikeType)
                {
                    return MemberKind.RefLike;
                }
                if (unmanagedNts.EqualsUnconstructedGenericType(references.KnownTypes.System_Nullable_T))
                {
                    // unamanged nullable<T> can not pass to where T:unmanaged constraint
                    if (unmanagedNts.TypeArguments[0].IsUnmanagedType)
                    {
                        return MemberKind.UnmanagedNullable;
                    }
                    else
                    {
                        return MemberKind.Nullable;
                    }
                }
            }

            return MemberKind.Unmanaged;
        }
        else if (memberType.SpecialType == SpecialType.System_String)
        {
            return MemberKind.String;
        }
        else if (memberType.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(references.IMemoryPackable)))
        {
            return MemberKind.MemoryPackable;
        }
        else if (memberType.TryGetMemoryPackableType(references, out var generateType, out var serializeLayout))
        {
            switch (generateType)
            {
                case GenerateType.Object:
                case GenerateType.VersionTolerant:
                case GenerateType.CircularReference:
                    return MemberKind.MemoryPackable;
                case GenerateType.Collection:
                    return MemberKind.MemoryPackableCollection;
                case GenerateType.Union:
                    return MemberKind.MemoryPackableUnion;
                case GenerateType.NoGenerate:
                default:
                    return MemberKind.MemoryPackableNoGenerate;
            }
        }
        else if (memberType.IsWillImplementMemoryPackUnion(references))
        {
            return MemberKind.MemoryPackUnion;
        }
        else if (memberType.TypeKind == TypeKind.Array)
        {
            if (memberType is IArrayTypeSymbol array)
            {
                if (array.IsSZArray)
                {
                    var elemType = array.ElementType;
                    if (elemType.IsUnmanagedType)
                    {
                        if (elemType is INamedTypeSymbol unmanagedNts && unmanagedNts.EqualsUnconstructedGenericType(references.KnownTypes.System_Nullable_T))
                        {
                            // T?[] can not use Write/ReadUnmanagedArray
                            return MemberKind.Array;
                        }
                        else
                        {
                            return MemberKind.UnmanagedArray;
                        }
                    }
                    else
                    {
                        if (elemType.TryGetMemoryPackableType(references, out var elemGenerateType, out _) && elemGenerateType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
                        {
                            return MemberKind.MemoryPackableArray;
                        }

                        return MemberKind.Array;
                    }
                }
                else
                {
                    // allows 2, 3, 4
                    if (array.Rank <= 4)
                    {
                        return MemberKind.Object;
                    }
                }
            }

            return MemberKind.NonSerializable;
        }
        else if (memberType.TypeKind == TypeKind.TypeParameter) // T
        {
            return MemberKind.Object;
        }
        else
        {
            // or non unmanaged type
            if (memberType is INamedTypeSymbol nts)
            {
                if (nts.IsRefLikeType)
                {
                    return MemberKind.RefLike;
                }
                if (nts.EqualsUnconstructedGenericType(references.KnownTypes.System_Nullable_T))
                {
                    return MemberKind.Nullable;
                }

                if (nts.EqualsUnconstructedGenericType(references.KnownTypes.System_Collections_Generic_List_T))
                {
                    if (nts.TypeArguments[0].TryGetMemoryPackableType(references, out var elemGenerateType, out _) && elemGenerateType is GenerateType.Object or GenerateType.VersionTolerant or GenerateType.CircularReference)
                    {
                        return MemberKind.MemoryPackableList;
                    }
                    return MemberKind.KnownType;
                }
            }

            if (references.KnownTypes.Contains(memberType))
            {
                return MemberKind.KnownType;
            }

            if (memberSymbol != null)
            {
                if (memberSymbol.ContainsAttribute(references.MemoryPackAllowSerializeAttribute))
                {
                    return MemberKind.AllowSerialize;
                }
            }

            return MemberKind.NonSerializable; // maybe can't serialize, diagnostics target
        }
    }
}

public partial class MethodMeta
{
    public IMethodSymbol Symbol { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool UseReaderArgument { get; }
    public bool UseWriterArgument { get; }

    public MethodMeta(IMethodSymbol symbol, bool isValueType, bool isReader)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.IsStatic = symbol.IsStatic;
        this.IsValueType = isValueType;

        var hasArg = symbol.Parameters.Length != 0;
        if (hasArg)
        {
            if (isReader)
            {
                this.UseReaderArgument = true;
            }
            else
            {
                this.UseWriterArgument = true;
            }
        }
    }

    public Location GetLocation(TypeDeclarationSyntax fallback)
    {
        var location = Symbol.Locations.FirstOrDefault() ?? fallback.Identifier.GetLocation();
        return location;
    }
}



================================================
FILE: src/MemoryPack.Generator/MemoryPackGenerator.TypeScript.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Diagnostics;
using System.Dynamic;
using System.IO.Compression;
using System.Text;
using System.Xml.Serialization;

namespace MemoryPack.Generator;

public record TypeScriptGenerateOptions
{
    public string OutputDirectory { get; set; } = default!;
    public string ImportExtension { get; set; } = default!;
    public bool ConvertPropertyName { get; set; } = true;
    public bool EnableNullableTypes { get; set; } = false;
    public bool IsDesignTimeBuild { get; set; } = false;
}

partial class MemoryPackGenerator
{
    static TypeMeta? GenerateTypeScript(TypeDeclarationSyntax syntax, Compilation compilation, TypeScriptGenerateOptions typeScriptGenerateOptions, in SourceProductionContext context,
        ReferenceSymbols reference, IReadOnlyDictionary<ITypeSymbol, ITypeSymbol> unionMap)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return null;
        }

        // require [MemoryPackable]
        if (!typeSymbol.ContainsAttribute(reference.MemoryPackableAttribute))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptMustBeMemoryPackable, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return null;
        }

        var typeMeta = new TypeMeta(typeSymbol, reference);

        if (typeMeta.GenerateType is not (GenerateType.Object or GenerateType.Union))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptOnlyAllowsGenerateTypeObject, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return null;
        }

        if (!Validate(typeMeta, syntax, context, reference))
        {
            return null;
        }

        var sb = new StringBuilder();

        sb.AppendLine($$"""
import { MemoryPackWriter } from "./MemoryPackWriter{{typeScriptGenerateOptions.ImportExtension}}";
import { MemoryPackReader } from "./MemoryPackReader{{typeScriptGenerateOptions.ImportExtension}}";
""");

        var collector = new TypeCollector();
        collector.Visit(typeMeta, true);

        // validate invalid enum
        foreach (var item in collector.GetEnums())
        {
            if (item.TypeKind == TypeKind.Enum && item is INamedTypeSymbol nts)
            {
                if (nts.EnumUnderlyingType!.SpecialType is SpecialType.System_Int64 or SpecialType.System_UInt64)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptDoesNotAllowLongEnum, syntax.Identifier.GetLocation(), typeSymbol.Name, item.FullyQualifiedToString()));
                    return null;
                }
            }
        }

        // add import(enum, union, memorypackable)
        foreach (var item in collector.GetEnums())
        {
            sb.AppendLine($"import {{ {item.Name} }} from \"./{item.Name}{typeScriptGenerateOptions.ImportExtension}\";");
        }
        foreach (var item in collector.GetMemoryPackableTypes(reference)
            .Where(x => !SymbolEqualityComparer.Default.Equals(x, typeSymbol) && !x.IsMemoryPackableNoGenerate(reference)))
        {
            sb.AppendLine($"import {{ {item.Name} }} from \"./{item.Name}{typeScriptGenerateOptions.ImportExtension}\";");
        }
        sb.AppendLine();

        try
        {
            typeMeta.EmitTypescript(sb, unionMap, typeScriptGenerateOptions);
        }
        catch (NotSupportedTypeException ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptNotSupportedType, ex.MemberMeta!.GetLocation(syntax),
                typeMeta.Symbol.Name, ex.MemberMeta.Name, ex.MemberMeta.MemberType.FullyQualifiedToString()));
            return null;
        }

        // save to file
        try
        {
            if (!Directory.Exists(typeScriptGenerateOptions.OutputDirectory))
            {
                Directory.CreateDirectory(typeScriptGenerateOptions.OutputDirectory);
            }

            File.WriteAllText(Path.Combine(typeScriptGenerateOptions.OutputDirectory, $"{typeMeta.TypeName}.ts"), sb.ToString(), new UTF8Encoding(false));
        }
        catch (Exception ex)
        {
            Trace.WriteLine(ex.ToString());
        }

        return typeMeta;
    }

    static void GenerateEnums(IEnumerable<ISymbol?>? enums, string typeScriptOutputDirectoryPath)
    {
        if (enums == null) return;
        if (!Directory.Exists(typeScriptOutputDirectoryPath))
        {
            Directory.CreateDirectory(typeScriptOutputDirectoryPath);
        }

        foreach (var e in enums)
        {
            if (e is INamedTypeSymbol typeSymbol)
            {
                if (typeSymbol.TypeKind != TypeKind.Enum) continue;

                var sb = new StringBuilder();
                foreach (var member in typeSymbol.GetMembers())
                {
                    // (ok[0] as IFieldSymbol).ConstantValue
                    var fs = member as IFieldSymbol;
                    if (fs == null) continue;
                    var value = fs.HasConstantValue ? $" = {fs.ConstantValue}" : "";
                    sb.AppendLine($"    {fs.Name}{value},");
                }

                var code = $$"""
export const enum {{typeSymbol.Name}} {
{{sb.ToString()}}
}
""";

                File.WriteAllText(Path.Combine(typeScriptOutputDirectoryPath, $"{typeSymbol.Name}.ts"), code, new UTF8Encoding(false));
            }
        }
    }

    static bool Validate(TypeMeta type, TypeDeclarationSyntax syntax, in SourceProductionContext context, ReferenceSymbols reference)
    {
        var typeSymbol = type.Symbol;

        if (type.Symbol.IsGenericType)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptDoesNotAllowGenerics, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return false;
        }

        foreach (var item in type.Members)
        {
            if (item.Kind == MemberKind.CustomFormatter)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.GenerateTypeScriptNotSupportedCustomFormatter, item.GetLocation(syntax), typeSymbol.Name));
                return false;
            }
        }

        return true;
    }
}

public partial class TypeMeta
{
    public void EmitTypescript(StringBuilder sb, IReadOnlyDictionary<ITypeSymbol, ITypeSymbol> unionMap, TypeScriptGenerateOptions options)
    {
        string importExt = options.ImportExtension;
        if (IsUnion)
        {
            EmitTypeScriptUnion(sb, importExt);
            return;
        }

        if (!unionMap.TryGetValue(Symbol, out var union))
        {
            union = null;
        }

        var tsMembers = Members.Select(x => new TypeScriptMember(x, reference, options)).ToArray();
        var impl = (union != null) ? $"implements {union.Name} " : "";

        var code = $$"""
export class {{TypeName}} {{impl}}{
{{EmitTypeScriptMembers(tsMembers)}}
    constructor() {
{{EmitTypeScriptMembersInit(tsMembers)}}
    }

    static serialize(value: {{TypeName}} | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: {{TypeName}} | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }

{{EmitTypeScriptSerializeBody(tsMembers)}}
    }

    static serializeArray(value: ({{TypeName}} | null)[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: ({{TypeName}} | null)[] | null): void {
        writer.writeArray(value, (writer, x) => {{TypeName}}.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): {{TypeName}} | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): {{TypeName}} | null {
        const [ok, count] = reader.tryReadObjectHeader();
        if (!ok) {
            return null;
        }

        const value = new {{TypeName}}();
        if (count == {{tsMembers.Length}}) {
{{EmitTypeScriptDeserializeBody(tsMembers, false)}}
        }
        else if (count > {{tsMembers.Length}}) {
            throw new Error("Current object's property count is larger than type schema, can't deserialize about versioning.");
        }
        else {
{{EmitTypeScriptDeserializeBody(tsMembers, true)}}
        }
        return value;
    }

    static deserializeArray(buffer: ArrayBuffer): ({{TypeName}} | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): ({{TypeName}} | null)[] | null {
        return reader.readArray(reader => {{TypeName}}.deserializeCore(reader));
    }
}
""";

        sb.AppendLine(code);
    }

    public void EmitTypeScriptUnion(StringBuilder sb, string importExt)
    {
        string EmitUnionSerialize()
        {
            var sb = new StringBuilder();
            foreach (var item in UnionTags)
            {
                sb.AppendLine($$"""
        else if (value instanceof {{item.Type.Name}}) {
            writer.writeUnionHeader({{item.Tag}});
            {{item.Type.Name}}.serializeCore(writer, value);
            return;
        }
""");
            }
            return sb.ToString();
        }

        string EmitUnionDeserialize()
        {
            var sb = new StringBuilder();
            foreach (var item in UnionTags)
            {
                sb.AppendLine($$"""
            case {{item.Tag}}:
                return {{item.Type.Name}}.deserializeCore(reader);
""");
            }
            return sb.ToString();
        }

        foreach (var item in UnionTags)
        {
            sb.AppendLine($"import {{ {item.Type.Name} }} from \"./{item.Type.Name}{importExt}\"; ");
        }
        sb.AppendLine();

        var code = $$"""
export abstract class {{TypeName}} {
    static serialize(value: {{TypeName}} | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeCore(writer, value);
        return writer.toArray();
    }

    static serializeCore(writer: MemoryPackWriter, value: {{TypeName}} | null): void {
        if (value == null) {
            writer.writeNullObjectHeader();
            return;
        }
{{EmitUnionSerialize()}}
        else {
            throw new Error("Concrete type is not in MemoryPackUnion");
        }
    }

    static serializeArray(value: {{TypeName}}[] | null): Uint8Array {
        const writer = MemoryPackWriter.getSharedInstance();
        this.serializeArrayCore(writer, value);
        return writer.toArray();
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: {{TypeName}}[] | null): void {
        writer.writeArray(value, (writer, x) => {{TypeName}}.serializeCore(writer, x));
    }

    static deserialize(buffer: ArrayBuffer): {{TypeName}} | null {
        return this.deserializeCore(new MemoryPackReader(buffer));
    }

    static deserializeCore(reader: MemoryPackReader): {{TypeName}} | null {
        const [ok, tag] = reader.tryReadUnionHeader();
        if (!ok) {
            return null;
        }

        switch (tag) {
{{EmitUnionDeserialize()}}
            default:
                throw new Error("Tag is not found in this MemoryPackUnion");
        }
    }

    static deserializeArray(buffer: ArrayBuffer): ({{TypeName}} | null)[] | null {
        return this.deserializeArrayCore(new MemoryPackReader(buffer));
    }

    static deserializeArrayCore(reader: MemoryPackReader): ({{TypeName}} | null)[] | null {
        return reader.readArray(reader => {{TypeName}}.deserializeCore(reader));
    }
}
""";
        sb.AppendLine(code);
    }

    public string EmitTypeScriptMembers(TypeScriptMember[] members)
    {
        var sb = new StringBuilder();

        foreach (var item in members)
        {
            sb.AppendLine($"    {item.MemberName}: {item.TypeName};");
        }

        return sb.ToString();
    }

    public string EmitTypeScriptMembersInit(TypeScriptMember[] members)
    {
        var sb = new StringBuilder();

        foreach (var item in members)
        {
            sb.AppendLine($"        this.{item.MemberName} = {item.DefaultValue};");
        }

        return sb.ToString();
    }

    public string EmitTypeScriptSerializeBody(TypeScriptMember[] members)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"        writer.writeObjectHeader({members.Length});");
        foreach (var item in members)
        {
            sb.AppendLine($"        {string.Format(item.WriteMethodTemplate, "value." + item.MemberName)};");
        }

        return sb.ToString();
    }

    public string EmitTypeScriptDeserializeBody(TypeScriptMember[] members, bool emitSkip)
    {
        var sb = new StringBuilder();

        if (!emitSkip)
        {
            foreach (var item in members)
            {
                sb.AppendLine($"            value.{item.MemberName} = {item.ReadMethodTemplate};");
            }
        }
        else
        {
            sb.AppendLine("            if (count == 0) return value;");
            for (int i = 0; i < members.Length; i++)
            {
                var item = members[i];
                sb.AppendLine($"            value.{item.MemberName} = {item.ReadMethodTemplate}; if (count == {i + 1}) return value;");
            }
        }


        return sb.ToString();
    }
}



================================================
FILE: src/MemoryPack.Generator/ReferenceSymbols.cs
================================================
﻿using Microsoft.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;

namespace MemoryPack.Generator;

public class ReferenceSymbols
{
    public Compilation Compilation { get; }

    public INamedTypeSymbol MemoryPackableAttribute { get; }
    public INamedTypeSymbol MemoryPackUnionAttribute { get; }
    public INamedTypeSymbol MemoryPackUnionFormatterAttribute { get; }
    public INamedTypeSymbol MemoryPackConstructorAttribute { get; }
    public INamedTypeSymbol MemoryPackAllowSerializeAttribute { get; }
    public INamedTypeSymbol MemoryPackOrderAttribute { get; }
    public INamedTypeSymbol? MemoryPackCustomFormatterAttribute { get; } // Unity is null.
    public INamedTypeSymbol? MemoryPackCustomFormatter2Attribute { get; } // Unity is null.
    public INamedTypeSymbol MemoryPackIgnoreAttribute { get; }
    public INamedTypeSymbol MemoryPackIncludeAttribute { get; }
    public INamedTypeSymbol MemoryPackOnSerializingAttribute { get; }
    public INamedTypeSymbol MemoryPackOnSerializedAttribute { get; }
    public INamedTypeSymbol MemoryPackOnDeserializingAttribute { get; }
    public INamedTypeSymbol MemoryPackOnDeserializedAttribute { get; }
    public INamedTypeSymbol SkipOverwriteDefaultAttribute { get; }
    public INamedTypeSymbol GenerateTypeScriptAttribute { get; }
    public INamedTypeSymbol IMemoryPackable { get; }

    public WellKnownTypes KnownTypes { get; }

    public ReferenceSymbols(Compilation compilation)
    {
        Compilation = compilation;

        // MemoryPack
        MemoryPackableAttribute = GetTypeByMetadataName(MemoryPackGenerator.MemoryPackableAttributeFullName);
        MemoryPackUnionAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackUnionAttribute");
        MemoryPackUnionFormatterAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackUnionFormatterAttribute");
        MemoryPackConstructorAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackConstructorAttribute");
        MemoryPackAllowSerializeAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackAllowSerializeAttribute");
        MemoryPackOrderAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackOrderAttribute");
        MemoryPackCustomFormatterAttribute = compilation.GetTypeByMetadataName("MemoryPack.MemoryPackCustomFormatterAttribute`1")?.ConstructUnboundGenericType();
        MemoryPackCustomFormatter2Attribute = compilation.GetTypeByMetadataName("MemoryPack.MemoryPackCustomFormatterAttribute`2")?.ConstructUnboundGenericType();
        MemoryPackIgnoreAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackIgnoreAttribute");
        MemoryPackIncludeAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackIncludeAttribute");
        MemoryPackOnSerializingAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackOnSerializingAttribute");
        MemoryPackOnSerializedAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackOnSerializedAttribute");
        MemoryPackOnDeserializingAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackOnDeserializingAttribute");
        MemoryPackOnDeserializedAttribute = GetTypeByMetadataName("MemoryPack.MemoryPackOnDeserializedAttribute");
        SkipOverwriteDefaultAttribute = GetTypeByMetadataName("MemoryPack.SuppressDefaultInitializationAttribute");
        GenerateTypeScriptAttribute = GetTypeByMetadataName(MemoryPackGenerator.GenerateTypeScriptAttributeFullName);
        IMemoryPackable = GetTypeByMetadataName("MemoryPack.IMemoryPackable`1").ConstructUnboundGenericType();
        KnownTypes = new WellKnownTypes(this);
    }

    INamedTypeSymbol GetTypeByMetadataName(string metadataName)
    {
        var symbol = Compilation.GetTypeByMetadataName(metadataName);
        if (symbol == null)
        {
            throw new InvalidOperationException($"Type {metadataName} is not found in compilation.");
        }
        return symbol;
    }

    // UnamnaagedType no need.
    public class WellKnownTypes
    {
        readonly ReferenceSymbols parent;

        public INamedTypeSymbol System_Collections_Generic_IEnumerable_T { get; }
        public INamedTypeSymbol System_Collections_Generic_ICollection_T { get; }
        public INamedTypeSymbol System_Collections_Generic_ISet_T { get; }
        public INamedTypeSymbol System_Collections_Generic_IDictionary_T { get; }
        public INamedTypeSymbol System_Collections_Generic_List_T { get; }

        public INamedTypeSymbol System_Guid { get; }
        public INamedTypeSymbol System_Version { get; }
        public INamedTypeSymbol System_Uri { get; }

        public INamedTypeSymbol System_Numerics_BigInteger { get; }
        public INamedTypeSymbol System_TimeZoneInfo { get; }
        public INamedTypeSymbol System_Collections_BitArray { get; }
        public INamedTypeSymbol System_Text_StringBuilder { get; }
        public INamedTypeSymbol System_Type { get; }
        public INamedTypeSymbol System_Globalization_CultureInfo { get; }
        public INamedTypeSymbol System_Lazy_T { get; }
        public INamedTypeSymbol System_Collections_Generic_KeyValuePair_T { get; }
        public INamedTypeSymbol System_Nullable_T { get; }

        public INamedTypeSymbol System_DateTime { get; }
        public INamedTypeSymbol System_DateTimeOffset { get; }
        public INamedTypeSymbol System_Runtime_InteropServices_StructLayout { get; }

        // netstandard2.0 source generator has there reference so use string instead...
        //public INamedTypeSymbol System_Memory_T { get; }
        //public INamedTypeSymbol System_ReadOnlyMemory_T { get; }
        //public INamedTypeSymbol System_Buffers_ReadOnlySequence_T { get; }
        //public INamedTypeSymbol System_Collections_Generic_PriorityQueue_T { get; }
        const string System_Memory_T = "global::System.Memory<>";
        const string System_ReadOnlyMemory_T = "global::System.ReadOnlyMemory<>";
        const string System_Buffers_ReadOnlySequence_T = "global::System.Buffers.ReadOnlySequence<>";
        const string System_Collections_Generic_PriorityQueue_T = "global::System.Collections.Generic.PriorityQueue<,>";

        readonly HashSet<ITypeSymbol> knownTypes;

        static readonly Dictionary<string, string> knownGenericTypes = new()
        {
            // ArrayFormatters
            { "System.ArraySegment<>", "global::MemoryPack.Formatters.ArraySegmentFormatter<TREPLACE>" },
            { "System.Memory<>", "global::MemoryPack.Formatters.MemoryFormatter<TREPLACE>" },
            { "System.ReadOnlyMemory<>", "global::MemoryPack.Formatters.ReadOnlyMemoryFormatter<TREPLACE>" },
            { "System.Buffers.ReadOnlySequence<>", "global::MemoryPack.Formatters.ReadOnlySequenceFormatter<TREPLACE>" },

            // CollectionFormatters
            { "System.Collections.Generic.List<>", "global::MemoryPack.Formatters.ListFormatter<TREPLACE>" },
            { "System.Collections.Generic.Stack<>", "global::MemoryPack.Formatters.StackFormatter<TREPLACE>" },
            { "System.Collections.Generic.Queue<>", "global::MemoryPack.Formatters.QueueFormatter<TREPLACE>" },
            { "System.Collections.Generic.LinkedList<>", "global::MemoryPack.Formatters.LinkedListFormatter<TREPLACE>" },
            { "System.Collections.Generic.HashSet<>", "global::MemoryPack.Formatters.HashSetFormatter<TREPLACE>" },
            { "System.Collections.Generic.SortedSet<>", "global::MemoryPack.Formatters.SortedSetFormatter<TREPLACE>" },
            { "System.Collections.Generic.PriorityQueue<,>", "global::MemoryPack.Formatters.PriorityQueueFormatter<TREPLACE>" },
            { "System.Collections.ObjectModel.ObservableCollection<>", "global::MemoryPack.Formatters.ObservableCollectionFormatter<TREPLACE>" },
            { "System.Collections.ObjectModel.Collection<>", "global::MemoryPack.Formatters.CollectionFormatter<TREPLACE>" },
            { "System.Collections.Concurrent.ConcurrentQueue<>", "global::MemoryPack.Formatters.ConcurrentQueueFormatter<TREPLACE>" },
            { "System.Collections.Concurrent.ConcurrentStack<>", "global::MemoryPack.Formatters.ConcurrentStackFormatter<TREPLACE>" },
            { "System.Collections.Concurrent.ConcurrentBag<>", "global::MemoryPack.Formatters.ConcurrentBagFormatter<TREPLACE>" },
            { "System.Collections.Generic.Dictionary<,>", "global::MemoryPack.Formatters.DictionaryFormatter<TREPLACE>" },
            { "System.Collections.Generic.SortedDictionary<,>", "global::MemoryPack.Formatters.SortedDictionaryFormatter<TREPLACE>" },
            { "System.Collections.Generic.SortedList<,>", "global::MemoryPack.Formatters.SortedListFormatter<TREPLACE>" },
            { "System.Collections.Concurrent.ConcurrentDictionary<,>", "global::MemoryPack.Formatters.ConcurrentDictionaryFormatter<TREPLACE>" },
            { "System.Collections.ObjectModel.ReadOnlyCollection<>", "global::MemoryPack.Formatters.ReadOnlyCollectionFormatter<TREPLACE>" },
            { "System.Collections.ObjectModel.ReadOnlyObservableCollection<>", "global::MemoryPack.Formatters.ReadOnlyObservableCollectionFormatter<TREPLACE>" },
            { "System.Collections.Concurrent.BlockingCollection<>", "global::MemoryPack.Formatters.BlockingCollectionFormatter<TREPLACE>" },

            // ImmutableCollectionFormatters
            { "System.Collections.Immutable.ImmutableArray<>", "global::MemoryPack.Formatters.ImmutableArrayFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableList<>", "global::MemoryPack.Formatters.ImmutableListFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableQueue<>", "global::MemoryPack.Formatters.ImmutableQueueFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableStack<>", "global::MemoryPack.Formatters.ImmutableStackFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableDictionary<,>", "global::MemoryPack.Formatters.ImmutableDictionaryFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableSortedDictionary<,>", "global::MemoryPack.Formatters.ImmutableSortedDictionaryFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableSortedSet<>", "global::MemoryPack.Formatters.ImmutableSortedSetFormatter<TREPLACE>" },
            { "System.Collections.Immutable.ImmutableHashSet<>", "global::MemoryPack.Formatters.ImmutableHashSetFormatter<TREPLACE>" },
            { "System.Collections.Immutable.IImmutableList<>", "global::MemoryPack.Formatters.InterfaceImmutableListFormatter<TREPLACE>" },
            { "System.Collections.Immutable.IImmutableQueue<>", "global::MemoryPack.Formatters.InterfaceImmutableQueueFormatter<TREPLACE>" },
            { "System.Collections.Immutable.IImmutableStack<>", "global::MemoryPack.Formatters.InterfaceImmutableStackFormatter<TREPLACE>" },
            { "System.Collections.Immutable.IImmutableDictionary<,>", "global::MemoryPack.Formatters.InterfaceImmutableDictionaryFormatter<TREPLACE>" },
            { "System.Collections.Immutable.IImmutableSet<>", "global::MemoryPack.Formatters.InterfaceImmutableSetFormatter<TREPLACE>" },

            // InterfaceCollectionFormatters
            { "System.Collections.Generic.IEnumerable<>", "global::MemoryPack.Formatters.InterfaceEnumerableFormatter<TREPLACE>" },
            { "System.Collections.Generic.ICollection<>", "global::MemoryPack.Formatters.InterfaceCollectionFormatter<TREPLACE>" },
            { "System.Collections.Generic.IReadOnlyCollection<>", "global::MemoryPack.Formatters.InterfaceReadOnlyCollectionFormatter<TREPLACE>" },
            { "System.Collections.Generic.IList<>", "global::MemoryPack.Formatters.InterfaceListFormatter<TREPLACE>" },
            { "System.Collections.Generic.IReadOnlyList<>", "global::MemoryPack.Formatters.InterfaceReadOnlyListFormatter<TREPLACE>" },
            { "System.Collections.Generic.IDictionary<,>", "global::MemoryPack.Formatters.InterfaceDictionaryFormatter<TREPLACE>" },
            { "System.Collections.Generic.IReadOnlyDictionary<,>", "global::MemoryPack.Formatters.InterfaceReadOnlyDictionaryFormatter<TREPLACE>" },
            { "System.Linq.ILookup<,>", "global::MemoryPack.Formatters.InterfaceLookupFormatter<TREPLACE>" },
            { "System.Linq.IGrouping<,>", "global::MemoryPack.Formatters.InterfaceGroupingFormatter<TREPLACE>" },
            { "System.Collections.Generic.ISet<>", "global::MemoryPack.Formatters.InterfaceSetFormatter<TREPLACE>" },
            { "System.Collections.Generic.IReadOnlySet<>", "global::MemoryPack.Formatters.InterfaceReadOnlySetFormatter<TREPLACE>" },

            { "System.Collections.Generic.KeyValuePair<,>", "global::MemoryPack.Formatters.KeyValuePairFormatter<TREPLACE>" },
            { "System.Lazy<>", "global::MemoryPack.Formatters.LazyFormatter<TREPLACE>" },

            // TupleFormatters
            { "System.Tuple<>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,,,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,,,,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.Tuple<,,,,,,,>", "global::MemoryPack.Formatters.TupleFormatter<TREPLACE>" },
            { "System.ValueTuple<>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,,,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,,,,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
            { "System.ValueTuple<,,,,,,,>", "global::MemoryPack.Formatters.ValueTupleFormatter<TREPLACE>" },
        };

        public WellKnownTypes(ReferenceSymbols parent)
        {
            this.parent = parent;
            System_Collections_Generic_IEnumerable_T = GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1").ConstructUnboundGenericType();
            System_Collections_Generic_ICollection_T = GetTypeByMetadataName("System.Collections.Generic.ICollection`1").ConstructUnboundGenericType();
            System_Collections_Generic_ISet_T = GetTypeByMetadataName("System.Collections.Generic.ISet`1").ConstructUnboundGenericType();
            System_Collections_Generic_IDictionary_T = GetTypeByMetadataName("System.Collections.Generic.IDictionary`2").ConstructUnboundGenericType();
            System_Collections_Generic_List_T = GetTypeByMetadataName("System.Collections.Generic.List`1").ConstructUnboundGenericType();
            System_Guid = GetTypeByMetadataName("System.Guid");
            System_Version = GetTypeByMetadataName("System.Version");
            System_Uri = GetTypeByMetadataName("System.Uri");
            System_Numerics_BigInteger = GetTypeByMetadataName("System.Numerics.BigInteger");
            System_TimeZoneInfo = GetTypeByMetadataName("System.TimeZoneInfo");
            System_Collections_BitArray = GetTypeByMetadataName("System.Collections.BitArray");
            System_Text_StringBuilder = GetTypeByMetadataName("System.Text.StringBuilder");
            System_Type = GetTypeByMetadataName("System.Type");
            System_Globalization_CultureInfo = GetTypeByMetadataName("System.Globalization.CultureInfo");
            System_Lazy_T = GetTypeByMetadataName("System.Lazy`1").ConstructUnboundGenericType();
            System_Collections_Generic_KeyValuePair_T = GetTypeByMetadataName("System.Collections.Generic.KeyValuePair`2").ConstructUnboundGenericType();
            System_Nullable_T = GetTypeByMetadataName("System.Nullable`1").ConstructUnboundGenericType();
            //System_Memory_T = GetTypeByMetadataName("System.Memory").ConstructUnboundGenericType();
            //System_ReadOnlyMemory_T = GetTypeByMetadataName("System.ReadOnlyMemory").ConstructUnboundGenericType();
            //System_Buffers_ReadOnlySequence_T = GetTypeByMetadataName("System.Buffers.ReadOnlySequence").ConstructUnboundGenericType();
            //System_Collections_Generic_PriorityQueue_T = GetTypeByMetadataName("System.Collections.Generic.PriorityQueue").ConstructUnboundGenericType();

            System_DateTime = GetTypeByMetadataName("System.DateTime");
            System_DateTimeOffset = GetTypeByMetadataName("System.DateTimeOffset");
            System_Runtime_InteropServices_StructLayout = GetTypeByMetadataName("System.Runtime.InteropServices.StructLayoutAttribute");

            knownTypes = new HashSet<ITypeSymbol>(new[]
            {
                System_Collections_Generic_IEnumerable_T,
                System_Collections_Generic_ICollection_T,
                System_Collections_Generic_ISet_T,
                System_Collections_Generic_IDictionary_T,
                System_Version,
                System_Uri,
                System_Numerics_BigInteger,
                System_TimeZoneInfo,
                System_Collections_BitArray,
                System_Text_StringBuilder,
                System_Type,
                System_Globalization_CultureInfo,
                System_Lazy_T,
                System_Collections_Generic_KeyValuePair_T,
                System_Nullable_T,
                //System_Memory_T,
                //System_ReadOnlyMemory_T,
                //System_Buffers_ReadOnlySequence_T,
                //System_Collections_Generic_PriorityQueue_T
            }, SymbolEqualityComparer.Default);
        }

        public bool Contains(ITypeSymbol symbol)
        {
            var constructedSymbol = symbol;
            if (symbol is INamedTypeSymbol nts && nts.IsGenericType)
            {
                symbol = nts.ConstructUnboundGenericType();
            }

            var contains1 = knownTypes.Contains(symbol);
            if (contains1) return true;

            var fullyQualifiedString = symbol.FullyQualifiedToString();
            if (fullyQualifiedString is System_Memory_T or System_ReadOnlyMemory_T or System_Buffers_ReadOnlySequence_T or System_Collections_Generic_PriorityQueue_T)
            {
                return true;
            }

            // tuple
            if (fullyQualifiedString.StartsWith("global::System.Tuple<") || fullyQualifiedString.StartsWith("global::System.ValueTuple<"))
            {
                return true;
            }

            // Most collections are basically serializable, wellknown
            var isIterable = constructedSymbol.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(System_Collections_Generic_IEnumerable_T));
            if (isIterable)
            {
                return true;
            }

            return false;
        }

        public string? GetNonDefaultFormatterName(ITypeSymbol? type)
        {
            if (type == null) return null;

            if (type.TypeKind == TypeKind.Enum)
            {
                return $"global::MemoryPack.Formatters.UnmanagedFormatter<{type.FullyQualifiedToString()}>";
            }

            if (type.TypeKind == TypeKind.Array)
            {
                if (type is IArrayTypeSymbol array)
                {
                    if (array.IsSZArray)
                    {
                        return $"global::MemoryPack.Formatters.ArrayFormatter<{array.ElementType.FullyQualifiedToString()}>";
                    }
                    else
                    {
                        if (array.Rank == 2)
                        {
                            return $"global::MemoryPack.Formatters.TwoDimensionalArrayFormatter<{array.ElementType.FullyQualifiedToString()}>";
                        }
                        else if (array.Rank == 3)
                        {
                            return $"global::MemoryPack.Formatters.ThreeDimensionalArrayFormatter<{array.ElementType.FullyQualifiedToString()}>";
                        }
                        else if (array.Rank == 4)
                        {
                            return $"global::MemoryPack.Formatters.FourDimensionalArrayFormatter<{array.ElementType.FullyQualifiedToString()}>";
                        }
                    }
                }

                return null;
            }

            if (type is not INamedTypeSymbol named) return null;

            if (!named.IsGenericType) return null;

            var genericType = named.ConstructUnboundGenericType();
            var genericTypeString = genericType.ToDisplayString();
            var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            // var isOpenGenericType = type.TypeArguments.Any(x => x is ITypeParameterSymbol);

            // nullable
            if (genericTypeString == "T?")
            {
                var firstTypeArgument = named.TypeArguments[0];
                var f = "global::MemoryPack.Formatters.NullableFormatter<" + firstTypeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">";
                return f;
            }

            // known types
            if (knownGenericTypes.TryGetValue(genericTypeString, out var formatter))
            {
                var typeArgs = string.Join(", ", named.TypeArguments.Select(x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                var f = formatter.Replace("TREPLACE", typeArgs);
                return f;
            }

            return null;
        }

        INamedTypeSymbol GetTypeByMetadataName(string metadataName) => parent.GetTypeByMetadataName(metadataName);
    }
}




================================================
FILE: src/MemoryPack.Generator/TypeCollector.cs
================================================
﻿using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Text;

namespace MemoryPack.Generator;

public class TypeCollector
{
    HashSet<ITypeSymbol> types = new(SymbolEqualityComparer.Default);

    public void Visit(TypeMeta typeMeta, bool visitInterface)
    {
        Visit(typeMeta.Symbol, visitInterface);
        foreach (var item in typeMeta.Members.Where(x => x.Symbol != null))
        {
            Visit(item.MemberType, visitInterface);
        }
    }

    public void Visit(ISymbol symbol, bool visitInterface)
    {
        if (symbol is ITypeSymbol typeSymbol)
        {
            // 7~20 is primitive
            if ((int)typeSymbol.SpecialType is >= 7 and <= 20)
            {
                return;
            }

            if (!types.Add(typeSymbol))
            {
                return;
            }

            if (typeSymbol is IArrayTypeSymbol array)
            {
                Visit(array.ElementType, visitInterface);
            }
            else if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
            {
                if (visitInterface)
                {
                    foreach (var item in namedTypeSymbol.AllInterfaces)
                    {
                        Visit(item, visitInterface);
                    }

                    foreach (var item in namedTypeSymbol.GetAllBaseTypes())
                    {
                        Visit(item, visitInterface);
                    }
                }

                if (namedTypeSymbol.IsGenericType)
                {
                    foreach (var item in namedTypeSymbol.TypeArguments)
                    {
                        Visit(item, visitInterface);
                    }
                }
            }
        }
    }

    public IEnumerable<ITypeSymbol> GetEnums()
    {
        foreach (var typeSymbol in types)
        {
            if (typeSymbol.TypeKind == TypeKind.Enum)
            {
                yield return typeSymbol;
            }
        }
    }

    public IEnumerable<ITypeSymbol> GetMemoryPackableTypes(ReferenceSymbols reference)
    {
        foreach (var typeSymbol in types)
        {
            if (typeSymbol.ContainsAttribute(reference.MemoryPackableAttribute))
            {
                yield return typeSymbol;
            }
        }
    }

    public IEnumerable<ITypeSymbol> GetTypes()
    {
        return types.OfType<ITypeSymbol>();
    }
}



================================================
FILE: src/MemoryPack.Generator/TypeScriptMember.cs
================================================
﻿using Microsoft.CodeAnalysis;

namespace MemoryPack.Generator;

internal class TypeScriptType
{
    public string TypeName { get; set; } = default!;
    public bool IsNullable { get; set; }
    public string DefaultValue { get; set; } = default!;
    public string WriteMethodTemplate { get; set; } = default!;
    public string ReadMethodTemplate { get; set; } = default!;
}

internal class TypeScriptTypeCore
{
    public string TypeName { get; set; } = default!;
    public string DefaultValue { get; set; } = default!;
    public string BinaryOperationMethod { get; set; } = default!;
}

internal class NotSupportedTypeException : Exception
{
    public ITypeSymbol ErrorTypeSymbol { get; }
    public MemberMeta? MemberMeta { get; set; }

    public NotSupportedTypeException(ITypeSymbol typeSymbol)
    {
        this.ErrorTypeSymbol = typeSymbol;
    }
}

public class TypeScriptMember
{
    public MemberMeta Member { get; }
    public string MemberName { get; }
    public string TypeName { get; }
    public string DefaultValue { get; }
    public string WriteMethodTemplate { get; }
    public string ReadMethodTemplate { get; }

    public TypeScriptMember(MemberMeta member, ReferenceSymbols references, TypeScriptGenerateOptions options)
    {
        this.Member = member;
        this.MemberName = options.ConvertPropertyName
            ? Char.ToLowerInvariant(member.Name[0]) + member.Name.Substring(1)
            : member.Name;

        TypeScriptType tsType;
        try
        {
            tsType = ConvertToTypeScriptType(member.MemberType, references, options);
        }
        catch (NotSupportedTypeException ex)
        {
            ex.MemberMeta = member;
            throw;
        }

        this.TypeName = tsType.TypeName;
        this.DefaultValue = tsType.DefaultValue;
        this.WriteMethodTemplate = tsType.WriteMethodTemplate;
        this.ReadMethodTemplate = tsType.ReadMethodTemplate;
    }

    TypeScriptType ConvertToTypeScriptType(ITypeSymbol symbol, ReferenceSymbols references, TypeScriptGenerateOptions options)
    {
        if (symbol.TypeKind == TypeKind.Enum)
        {
            var primitiveType = ConvertFromSymbol(symbol, references, options)!;

            // enum uses self typename(convert to const enum)
            return new TypeScriptType
            {
                TypeName = symbol.Name,
                DefaultValue = primitiveType.DefaultValue,
                IsNullable = symbol.NullableAnnotation == NullableAnnotation.Annotated || symbol.IsReferenceType,
                WriteMethodTemplate = $"writer.write{primitiveType.BinaryOperationMethod}({{0}})",
                ReadMethodTemplate = $"reader.read{primitiveType.BinaryOperationMethod}()"
            };
        }

        if (symbol.TypeKind == TypeKind.Array)
        {
            if (symbol is IArrayTypeSymbol array && array.IsSZArray)
            {
                var elemType = array.ElementType;
                if (elemType.SpecialType == SpecialType.System_Byte)
                {
                    return new TypeScriptType
                    {
                        TypeName = $"Uint8Array | null",
                        DefaultValue = "null",
                        WriteMethodTemplate = $"writer.writeUint8Array({{0}})",
                        ReadMethodTemplate = $"reader.readUint8Array()"
                    };
                }

                var innerType = ConvertToTypeScriptType(elemType, references, options);
                var typeName = innerType.TypeName.Contains("null") ? $"({innerType.TypeName})" : innerType.TypeName;

                var elementWriter = string.Format(innerType.WriteMethodTemplate, "x");
                var elementReader = string.Format(innerType.ReadMethodTemplate);

                return new TypeScriptType
                {
                    TypeName = $"{typeName}[] | null",
                    DefaultValue = "null",
                    WriteMethodTemplate = $"writer.writeArray({{0}}, (writer, x) => {elementWriter})",
                    ReadMethodTemplate = $"reader.readArray(reader => {elementReader})"
                };
            }
        }

        // is collection

        var (collectionKind, collectionSymbol) = TypeMeta.ParseCollectionKind(symbol as INamedTypeSymbol, references);
        switch (collectionKind)
        {
            case CollectionKind.Collection:
                {
                    var innerType = ConvertToTypeScriptType(collectionSymbol!.TypeArguments[0], references, options);
                    // same as Array
                    var typeName = innerType.TypeName.Contains("null") ? $"({innerType.TypeName})" : innerType.TypeName;

                    var elementWriter = string.Format(innerType.WriteMethodTemplate, "x");
                    var elementReader = string.Format(innerType.ReadMethodTemplate);

                    return new TypeScriptType
                    {
                        TypeName = $"{typeName}[] | null",
                        DefaultValue = "null",
                        WriteMethodTemplate = $"writer.writeArray({{0}}, (writer, x) => {elementWriter})",
                        ReadMethodTemplate = $"reader.readArray(reader => {elementReader})"
                    };
                }
            case CollectionKind.Set:
                {
                    var innerType = ConvertToTypeScriptType(collectionSymbol!.TypeArguments[0], references, options);
                    var elementWriter = string.Format(innerType.WriteMethodTemplate, "x");
                    var elementReader = string.Format(innerType.ReadMethodTemplate);

                    return new TypeScriptType
                    {
                        TypeName = $"Set<{innerType.TypeName}> | null",
                        DefaultValue = "null",
                        WriteMethodTemplate = $"writer.writeSet({{0}}, (writer, x) => {elementWriter})",
                        ReadMethodTemplate = $"reader.readSet(reader => {elementReader})"
                    };
                }
            case CollectionKind.Dictionary:
                {
                    var keyType = ConvertToTypeScriptType(collectionSymbol!.TypeArguments[0], references, options);
                    var valueType = ConvertToTypeScriptType(collectionSymbol!.TypeArguments[1], references, options);
                    var keyWriter = string.Format(keyType.WriteMethodTemplate, "x");
                    var keyReader = string.Format(keyType.ReadMethodTemplate);
                    var valueWriter = string.Format(valueType.WriteMethodTemplate, "x");
                    var valueReader = string.Format(valueType.ReadMethodTemplate);

                    return new TypeScriptType
                    {
                        TypeName = $"Map<{keyType.TypeName}, {valueType.TypeName}> | null",
                        DefaultValue = "null",
                        WriteMethodTemplate = $"writer.writeMap({{0}}, (writer, x) => {keyWriter}, (writer, x) => {valueWriter})",
                        ReadMethodTemplate = $"reader.readMap(reader => {keyReader}, reader => {valueReader})"
                    };
                }
            default:
                break;
        }

        if (symbol.TryGetMemoryPackableType(references, out _, out _) || symbol.IsWillImplementMemoryPackUnion(references))
        {
            return new TypeScriptType
            {
                TypeName = $"{symbol.Name} | null",
                DefaultValue = "null",
                WriteMethodTemplate = $"{symbol.Name}.serializeCore(writer, {{0}})",
                ReadMethodTemplate = $"{symbol.Name}.deserializeCore(reader)"
            };
        }

        var isNullable = (symbol is INamedTypeSymbol nts && nts.EqualsUnconstructedGenericType(references.KnownTypes.System_Nullable_T));
        if (isNullable)
        {
            var primitiveType = ConvertFromSymbol(((INamedTypeSymbol)symbol).TypeArguments[0], references, options)!;

            return new TypeScriptType
            {
                TypeName = $"{primitiveType.TypeName} | null",
                DefaultValue = "null",
                WriteMethodTemplate = $"writer.writeNullable{primitiveType.BinaryOperationMethod}({{0}})",
                ReadMethodTemplate = $"reader.readNullable{primitiveType.BinaryOperationMethod}()"
            };
        }

        // others
        {
            var primitiveType = ConvertFromSymbol(symbol, references, options)!;
            return new TypeScriptType
            {
                TypeName = $"{primitiveType.TypeName}",
                DefaultValue = primitiveType.DefaultValue,
                WriteMethodTemplate = $"writer.write{primitiveType.BinaryOperationMethod}({{0}})",
                ReadMethodTemplate = $"reader.read{primitiveType.BinaryOperationMethod}()"
            };
        }
    }

    TypeScriptTypeCore ConvertFromSymbol(ITypeSymbol typeSymbol, ReferenceSymbols reference, TypeScriptGenerateOptions options)
    {
        var isNullable =
            options.EnableNullableTypes &&
            typeSymbol.IsReferenceType &&
            typeSymbol.NullableAnnotation == NullableAnnotation.Annotated;

        var fromSpecial = ConvertFromSpecialType(typeSymbol.SpecialType, isNullable, options.EnableNullableTypes);
        if (fromSpecial != null) return fromSpecial;

        // + Guid or Enum
        var namedType = typeSymbol as INamedTypeSymbol;
        if (namedType == null) throw new NotSupportedTypeException(typeSymbol);

        if (namedType.TypeKind == TypeKind.Enum)
        {
            var specialType = namedType.EnumUnderlyingType!.SpecialType;
            return ConvertFromSpecialType(specialType, isNullable, options.EnableNullableTypes)!;
        }

        if (SymbolEqualityComparer.Default.Equals(namedType, reference.KnownTypes.System_Guid))
        {
            return new TypeScriptTypeCore
            {
                TypeName = "string",
                DefaultValue = "\"00000000-0000-0000-0000-000000000000\"",
                BinaryOperationMethod = "Guid"
            };
        }

        throw new NotSupportedTypeException(typeSymbol);
    }

    TypeScriptTypeCore? ConvertFromSpecialType(
        SpecialType specialType,
        bool isNullable,
        bool allowNullableTypes)
    {
        // NOTE The function to get the TypeScript type was duplicated in order
        //      to keep the old behavior of the code generator.
        return allowNullableTypes
            ? GetNullableTypesAllowedTypeScriptType(specialType, isNullable)
            : GetNonNullableTypesAllowedTypeScriptType(specialType);
    }

    static TypeScriptTypeCore? GetNonNullableTypesAllowedTypeScriptType(SpecialType specialType)
    {
        string typeName;
        string binaryOperationMethod;
        string defaultValue;

        switch (specialType)
        {
            case SpecialType.System_Boolean:
                typeName = "boolean";
                binaryOperationMethod = "Boolean";
                defaultValue = "false";

                break;

            case SpecialType.System_String:
                typeName = "string | null";
                binaryOperationMethod = "String";
                defaultValue = "null";

                break;

            case SpecialType.System_SByte:
                typeName = "number";
                binaryOperationMethod = "Int8";
                defaultValue = "0";

                break;

            case SpecialType.System_Byte:
                typeName = "number";
                binaryOperationMethod = "Uint8";
                defaultValue = "0";

                break;

            case SpecialType.System_Int16:
                typeName = "number";
                binaryOperationMethod = "Int16";
                defaultValue = "0";

                break;

            case SpecialType.System_UInt16:
                typeName = "number";
                binaryOperationMethod = "Uint16";
                defaultValue = "0";

                break;

            case SpecialType.System_Int32:
                typeName = "number";
                binaryOperationMethod = "Int32";
                defaultValue = "0";

                break;

            case SpecialType.System_UInt32:
                typeName = "number";
                binaryOperationMethod = "Uint32";
                defaultValue = "0";

                break;

            case SpecialType.System_Single:
                typeName = "number";
                binaryOperationMethod = "Float32";
                defaultValue = "0";

                break;

            case SpecialType.System_Double:
                typeName = "number";
                binaryOperationMethod = "Float64";
                defaultValue = "0";

                break;

            case SpecialType.System_Int64:
                typeName = "bigint";
                binaryOperationMethod = "Int64";
                defaultValue = "0n";

                break;

            case SpecialType.System_UInt64:
                typeName = "bigint";
                binaryOperationMethod = "Uint64";
                defaultValue = "0n";

                break;

            case SpecialType.System_DateTime:
                typeName = "Date";
                binaryOperationMethod = "Date";
                defaultValue = "new Date(0)";

                break;

            default:
                return null;
        }

        return new TypeScriptTypeCore
        {
            TypeName = typeName,
            DefaultValue = defaultValue,
            BinaryOperationMethod = binaryOperationMethod
        };
    }

    static TypeScriptTypeCore? GetNullableTypesAllowedTypeScriptType(SpecialType specialType, bool isNullable)
    {
        string typeName;
        string binaryOperationMethod;
        string defaultValue;

        string GetTypeName(string typeName) =>
            isNullable ? $"{typeName} | null" : typeName;

        string GetDefaultValue(string defaultValue) =>
            isNullable ? "null" : defaultValue;

        switch (specialType)
        {
            case SpecialType.System_Boolean:
                typeName = GetTypeName("boolean");
                binaryOperationMethod = "Boolean";
                defaultValue = GetDefaultValue("false");

                break;

            case SpecialType.System_String:
                typeName = GetTypeName("string");
                binaryOperationMethod = "String";
                defaultValue = GetDefaultValue(@"""""");

                break;

            case SpecialType.System_SByte:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Int8";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Byte:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Uint8";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Int16:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Int16";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_UInt16:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Uint16";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Int32:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Int32";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_UInt32:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Uint32";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Single:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Float32";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Double:
                typeName = GetTypeName("number");
                binaryOperationMethod = "Float64";
                defaultValue = GetDefaultValue("0");

                break;

            case SpecialType.System_Int64:
                typeName = GetTypeName("bigint");
                binaryOperationMethod = "Int64";
                defaultValue = GetDefaultValue("0n");

                break;

            case SpecialType.System_UInt64:
                typeName = GetTypeName("bigint");
                binaryOperationMethod = "Uint64";
                defaultValue = GetDefaultValue("0n");

                break;

            case SpecialType.System_DateTime:
                typeName = GetTypeName("Date");
                binaryOperationMethod = "Date";
                defaultValue = GetDefaultValue("new Date(0)");

                break;

            default:
                return null;
        }

        return new TypeScriptTypeCore
        {
            TypeName = typeName,
            DefaultValue = defaultValue,
            BinaryOperationMethod = binaryOperationMethod
        };
    }
}



================================================
FILE: src/MemoryPack.Generator/TypeScriptRuntime.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MemoryPack.Generator;

public static class TypeScriptRuntime
{
    public static readonly string MemoryPackWriter = """
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;

// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;

// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 0b00111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111n;

export class MemoryPackWriter {
    static singletonWriter: MemoryPackWriter;

    public static getSharedInstance(): MemoryPackWriter {
        if (this.singletonWriter == null) {
            this.singletonWriter = new MemoryPackWriter();
        }
        this.singletonWriter.clear();
        return this.singletonWriter;
    }

    private buffer: Uint8Array
    private dataView: DataView;
    private utf8Encoder: TextEncoder | null;
    private offset: number

    public constructor(initialCapacity: number = 256) {
        this.buffer = new Uint8Array(initialCapacity);
        this.dataView = new DataView(this.buffer.buffer);
        this.utf8Encoder = null;
        this.offset = 0;
    }

    private ensureCapacity(count: number) {
        if (this.buffer.length - this.offset < count) {
            var nextCapacity = this.buffer.length;
            var to = this.offset + count;

            while (nextCapacity < to) {
                nextCapacity = nextCapacity * 2;
            }

            var nextBuffer = new Uint8Array(nextCapacity);
            nextBuffer.set(this.buffer);

            this.buffer = nextBuffer;
            this.dataView = new DataView(this.buffer.buffer);
        }
    }

    private clearBuffer(count: number): void {
        this.ensureCapacity(count);
        while (count >= 4) {
            this.dataView.setUint32(this.offset, 0, true);
            this.offset += 4;
            count -= 4;
        }
        if (count >= 2) {
            this.dataView.setUint16(this.offset, 0, true);
            this.offset += 2;
            count -= 2;
        }
        if (count >= 1) {
            this.dataView.setUint8(this.offset, 0);
            this.offset += 1;
        }
    }

    public writeObjectHeader(memberCount: number) {
        this.writeUint8(memberCount);
    }

    public writeNullObjectHeader(): void {
        this.writeUint8(nullObject);
    }

    public writeUnionHeader(tag: number) {
        if (tag < 250) {
            this.writeUint8(tag);
        } else {
            this.writeUint8(250);
            this.writeUint16(tag);
        }
    }

    public writeNullUnionHeader(): void {
        this.writeUint8(nullObject);
    }

    public writeCollectionHeader(length: number) {
        this.writeInt32(length);
    }

    public writeNullCollectionHeader() {
        this.writeInt32(nullCollection);
    }

    public writeBoolean(value: boolean): void {
        this.writeUint8(value ? 1 : 0);
    }

    public writeNullableBoolean(value: boolean | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }
        this.writeNullableUint8(value ? 1 : 0);
    }

    public writeUint8(value: number): void {
        this.ensureCapacity(1);
        this.dataView.setUint8(this.offset, value);
        this.offset += 1;
    }

    public writeNullableUint8(value: number | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }

        this.writeUint8(1);
        this.writeUint8(value);
    }

    public writeUint16(value: number): void {
        this.ensureCapacity(2);
        this.dataView.setUint16(this.offset, value, true);
        this.offset += 2;
    }

    public writeNullableUint16(value: number | null): void {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }

        this.writeUint16(1);
        this.writeUint16(value);
    }

    public writeUint32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setUint32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableUint32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }

        this.writeUint32(1);
        this.writeUint32(value);
    }

    public writeInt8(value: number): void {
        this.ensureCapacity(1);
        this.dataView.setInt8(this.offset, value);
        this.offset += 1;
    }

    public writeNullableInt8(value: number | null): void {
        if (value == null) {
            this.clearBuffer(2);
            return;
        }

        this.writeInt8(1);
        this.writeInt8(value);
    }

    public writeInt16(value: number): void {
        this.ensureCapacity(2);
        this.dataView.setInt16(this.offset, value, true);
        this.offset += 2;
    }

    public writeNullableInt16(value: number | null): void {
        if (value == null) {
            this.clearBuffer(4);
            return;
        }

        this.writeInt16(1);
        this.writeInt16(value);
    }

    public writeInt32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setInt32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableInt32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }
        this.writeInt32(1);
        this.writeInt32(value);
    }

    public writeInt64(value: bigint): void {
        this.ensureCapacity(8);
        this.dataView.setBigInt64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableInt64(value: bigint | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeInt64(1n);
        this.writeInt64(value);
    }

    public writeUint64(value: bigint): void {
        this.ensureCapacity(8);
        this.dataView.setBigUint64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableUint64(value: bigint | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeUint64(1n);
        this.writeUint64(value);
    }

    public writeFloat32(value: number): void {
        this.ensureCapacity(4);
        this.dataView.setFloat32(this.offset, value, true);
        this.offset += 4;
    }

    public writeNullableFloat32(value: number | null): void {
        if (value == null) {
            this.clearBuffer(8);
            return;
        }

        this.writeUint32(1);
        this.writeFloat32(value);
    }

    public writeFloat64(value: number): void {
        this.ensureCapacity(8);
        this.dataView.setFloat64(this.offset, value, true);
        this.offset += 8;
    }

    public writeNullableFloat64(value: number | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeUint64(1n);
        this.writeFloat64(value);
    }

    public writeString(value: string | null): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        if (value.length == 0) {
            this.writeCollectionHeader(0);
            return;
        }

        // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
        this.ensureCapacity(8 + ((value.length + 1) * 3));

        if (this.utf8Encoder == null) {
            this.utf8Encoder = new TextEncoder();
        }

        var encodeResult = this.utf8Encoder.encodeInto(value, this.buffer.subarray(this.offset + 8));
        if (encodeResult.written === undefined || encodeResult.read === undefined) {
            throw new Error("failed utf8 TextEncoder.encodeInto.");
        }
        this.dataView.setInt32(this.offset, ~encodeResult.written, true);
        this.dataView.setInt32(this.offset + 4, encodeResult.read, true);

        this.offset += (encodeResult.written + 8);
    }

    public writeArray<T>(value: ArrayLike<T> | null, elementWriter: (writer: MemoryPackWriter, element: T) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.length);
        var len = value.length;
        for (var i = 0; i < len; i++) {
            elementWriter(this, value[i]);
        }
    }

    public writeMap<K, V>(value: Map<K, V> | null, keyWriter: (writer: MemoryPackWriter, key: K) => void, valueWriter: (writer: MemoryPackWriter, value: V) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.size);
        value.forEach((v, k) => {
            keyWriter(this, k);
            valueWriter(this, v);
        });
    }

    public writeSet<T>(value: Set<T> | null, elementWriter: (writer: MemoryPackWriter, element: T) => void): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.writeCollectionHeader(value.size);
        value.forEach(x => {
            elementWriter(this, x);
        });
    }

    public writeGuid(value: string): void {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"

        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;

        const b1 = parseInt(value.slice(0, 2), 16);
        const b2 = parseInt(value.slice(2, 4), 16);
        const b3 = parseInt(value.slice(4, 6), 16);
        const b4 = parseInt(value.slice(6, 8), 16);
        const a = b1 << 24 | b2 << 16 | b3 << 8 | b4;

        const b5 = parseInt(value.slice(9, 11), 16);
        const b6 = parseInt(value.slice(11, 13), 16);
        const b = b5 << 8 | b6;

        const b7 = parseInt(value.slice(14, 16), 16);
        const b8 = parseInt(value.slice(16, 18), 16);
        const c = b7 << 8 | b8;

        const d = parseInt(value.slice(19, 21), 16);
        const e = parseInt(value.slice(21, 23), 16);

        const f = parseInt(value.slice(24, 26), 16);
        const g = parseInt(value.slice(26, 28), 16);
        const h = parseInt(value.slice(28, 30), 16);
        const i = parseInt(value.slice(30, 32), 16);
        const j = parseInt(value.slice(32, 34), 16);
        const k = parseInt(value.slice(34, 36), 16);

        this.ensureCapacity(16);

        this.dataView.setInt32(this.offset, a, true);
        this.dataView.setInt16(this.offset + 4, b, true);
        this.dataView.setInt16(this.offset + 6, c, true);
        this.dataView.setUint8(this.offset + 8, d);
        this.dataView.setUint8(this.offset + 9, e);
        this.dataView.setUint8(this.offset + 10, f);
        this.dataView.setUint8(this.offset + 11, g);
        this.dataView.setUint8(this.offset + 12, h);
        this.dataView.setUint8(this.offset + 13, i);
        this.dataView.setUint8(this.offset + 14, j);
        this.dataView.setUint8(this.offset + 15, k);

        this.offset += 16;
    }

    public writeNullableGuid(value: string | null): void {
        if (value == null) {
            this.clearBuffer(20);
            return;
        }

        this.writeInt32(1);
        this.writeGuid(value);
    }

    public writeDate(value: Date): void {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const unixMillisecond = BigInt(value.getTime());
        const ticks = unixMillisecond * 10000n + unixEpochTicks;
        this.writeUint64(ticks & dateTimeMask);
    }

    public writeNullableDate(value: Date | null): void {
        if (value == null) {
            this.clearBuffer(16);
            return;
        }

        this.writeInt64(1n);
        this.writeDate(value);
    }

    public writeUint8Array(value: Uint8Array | null): void {
        if (value == null) {
            this.writeNullCollectionHeader();
            return;
        }

        this.ensureCapacity(value.length + 4);
        this.dataView.setInt32(this.offset, value.length, true);
        this.buffer.set(value, this.offset + 4);
        this.offset += (value.length + 4);
    }

    public clear(): void {
        this.offset = 0;
    }

    public getSpan(): Uint8Array {
        return this.buffer.subarray(0, this.offset);
    }

    public toArray(): Uint8Array {
        return this.buffer.slice(0, this.offset);
    }
}

""";

    public static readonly string MemoryPackReader = """
// Code of MemoryPack
const nullCollection = -1;
const union = 254;
const nullObject = 255;

// bool
const TRUE = 1;
const FALSE = 0;

// DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks
const unixEpochTicks = 621355968000000000n;

// 01-62 bit represents ticks
// 63-64 bit represents DateTimeKind(we trim kind)
const dateTimeMask = 0b00111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111n;

export class MemoryPackReader {
    private buffer: ArrayBuffer
    private dataView: DataView
    private utf8Decoder: TextDecoder | null
    private utf16Decoder: TextDecoder | null
    private offset: number

    public constructor(buffer: ArrayBuffer) {
        this.buffer = buffer;
        this.dataView = new DataView(this.buffer);
        this.utf8Decoder = null;
        this.utf16Decoder = null;
        this.offset = 0;
    }

    public tryReadObjectHeader(): [boolean, number] {
        const memberCount = this.readUint8();
        return (memberCount == nullObject)
            ? [false, 0]
            : [true, memberCount];
    }

    public tryReadUnionHeader(): [boolean, number] {
        const tag = this.readUint8();
        if (tag < 250) {
            return [true, tag];
        }
        else if (tag == 250) {
            const tag2 = this.readUint16();
            return [true, tag2];
        }
        else {
            return [false, 0];
        }
    }

    public tryReadCollectionHeader(): [boolean, number] {
        const length = this.readInt32();
        if (length == nullCollection) {
            return [false, 0];
        }

        if ((this.buffer.byteLength - this.offset) < length) {
            throw new Error("header length is too large, length: " + length);
        }

        return [true, length];
    }

    public readBoolean(): boolean {
        return this.readUint8() != 0;
    }

    public readNullableBoolean(): boolean | null {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }
        return this.readUint8() == TRUE;
    }

    public readUint8(): number {
        const v = this.dataView.getUint8(this.offset);
        this.offset += 1;
        return v;
    }

    public readNullableUint8(): number | null {
        if (this.readUint8() == FALSE) {
            this.offset += 1;
            return null;
        }

        return this.readUint8();
    }

    public readUint16(): number {
        const v = this.dataView.getUint16(this.offset, true);
        this.offset += 2;
        return v;
    }

    public readNullableUint16(): number | null {
        if (this.readUint16() == FALSE) {
            this.offset += 2;
            return null;
        }

        return this.readUint16();
    }

    public readUint32(): number {
        const v = this.dataView.getUint32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableUint32(): number | null {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readUint32();
    }

    public readInt8(): number {
        const v = this.dataView.getInt8(this.offset);
        this.offset += 1;
        return v;
    }

    public readNullableInt8(): number | null {
        if (this.readInt8() == FALSE) {
            this.offset += 1;
            return null;
        }

        return this.readInt8();
    }

    public readInt16(): number {
        const v = this.dataView.getInt16(this.offset, true);
        this.offset += 2;
        return v;
    }

    public readNullableInt16(): number | null {
        if (this.readInt16() == FALSE) {
            this.offset += 2;
            return null;
        }

        return this.readInt16();
    }

    public readInt32(): number {
        const v = this.dataView.getInt32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableInt32(): number | null {
        if (this.readInt32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readInt32();
    }

    public readInt64(): bigint {
        const v = this.dataView.getBigInt64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableInt64(): bigint | null {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readInt64();
    }

    public readUint64(): bigint {
        const v = this.dataView.getBigUint64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableUint64(): bigint | null {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readUint64();
    }

    public readFloat32(): number {
        const v = this.dataView.getFloat32(this.offset, true);
        this.offset += 4;
        return v;
    }

    public readNullableFloat32(): number | null {
        if (this.readUint32() == FALSE) {
            this.offset += 4;
            return null;
        }

        return this.readFloat32();
    }

    public readFloat64(): number {
        const v = this.dataView.getFloat64(this.offset, true);
        this.offset += 8;
        return v;
    }

    public readNullableFloat64(): number | null {
        if (this.readUint64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readFloat64();
    }

    public readString(): string | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        if (length == 0) {
            return "";
        }

        if (length > 0) {
            if (this.utf16Decoder == null) {
                this.utf16Decoder = new TextDecoder("utf-16", { ignoreBOM: true, fatal: true });
            }

            const byteLength = length * 2;
            const view = new Uint8Array(this.buffer, this.offset, byteLength); // don't use slice, it makes copy
            const v = this.utf16Decoder.decode(view);
            this.offset += byteLength;
            return v;
        }
        else {
            if (this.utf8Decoder == null) {
                this.utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
            }

            // (int ~utf8-byte-count, int utf16-length, utf8-bytes)
            const utf8Length = ~length;
            this.offset += 4; // utf16-length, no use

            const view = new Uint8Array(this.buffer, this.offset, utf8Length); // don't use slice, it makes copy
            const v = this.utf8Decoder.decode(view);
            this.offset += utf8Length;
            return v;
        }
    }

    public readArray<T>(elementReader: (reader: MemoryPackReader) => T): T[] | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Array<T>(length);
        for (var i = 0; i < result.length; i++) {
            result[i] = elementReader(this);
        }
        return result;
    }

    public readMap<K, V>(keyReader: (reader: MemoryPackReader) => K, valueReader: (reader: MemoryPackReader) => V): Map<K, V> | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Map<K, V>();

        for (var i = 0; i < length; i++) {
            const key = keyReader(this);
            const value = valueReader(this);
            result.set(key, value);
        }

        return result;
    }

    public readSet<T>(elementReader: (reader: MemoryPackReader) => T): Set<T> | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const result = new Set<T>();
        for (var i = 0; i < length; i++) {
            result.add(elementReader(this));
        }
        return result;
    }

    public readGuid(): string {
        // e.g. "CA761232-ED42-11CE-BACD-00AA0057B223"

        // int _a;
        // short _b;
        // short _c;
        // byte _d;
        // byte _e;
        // byte _f;
        // byte _g;
        // byte _h;
        // byte _i;
        // byte _j;
        // byte _k;

        const b1 = this.readUint8();
        const b2 = this.readUint8();
        const b3 = this.readUint8();
        const b4 = this.readUint8();
        const b5 = this.readUint8();
        const b6 = this.readUint8();
        const b7 = this.readUint8();
        const b8 = this.readUint8();
        const b9 = this.readUint8();
        const b10 = this.readUint8();
        const b11 = this.readUint8();
        const b12 = this.readUint8();
        const b13 = this.readUint8();
        const b14 = this.readUint8();
        const b15 = this.readUint8();
        const b16 = this.readUint8();

        return b4.toString(16).padStart(2, "0") + b3.toString(16).padStart(2, "0") + b2.toString(16).padStart(2, "0") + b1.toString(16).padStart(2, "0") // a
            + "-"
            + b6.toString(16).padStart(2, "0") + b5.toString(16).padStart(2, "0") // b
            + "-"
            + b8.toString(16).padStart(2, "0") + b7.toString(16).padStart(2, "0") // c
            + "-"
            + b9.toString(16).padStart(2, "0") + b10.toString(16).padStart(2, "0") // d e
            + "-"
            + b11.toString(16).padStart(2, "0") + b12.toString(16).padStart(2, "0") // f g
            + b13.toString(16).padStart(2, "0") + b14.toString(16).padStart(2, "0") // h i
            + b15.toString(16).padStart(2, "0") + b16.toString(16).padStart(2, "0"); // j k
    }

    public readNullableGuid(): string | null {
        if (this.readInt32() == FALSE) {
            this.offset += 16;
            return null;
        }

        return this.readGuid();
    }

    public readDate(): Date {
        // Date.getTime is UTC Unix time of millisecond
        // .NET Ticks(ulong dateData) is 100-nanosecond from 1/1/0001 12:00am
        const ticks = this.readUint64() & dateTimeMask;
        const unixMillisecond = (ticks - unixEpochTicks) / 10000n;
        return new Date(Number(unixMillisecond));
    }

    public readNullableDate(): Date | null {
        if (this.readInt64() == 0n) {
            this.offset += 8;
            return null;
        }

        return this.readDate();
    }

    public readUint8Array(): Uint8Array | null {
        const [ok, length] = this.tryReadCollectionHeader();
        if (!ok) {
            return null;
        }

        const span = this.buffer.slice(this.offset, this.offset + length); // slice is copy
        this.offset += length;
        return new Uint8Array(span);
    }
}

""";
}



================================================
FILE: src/MemoryPack.Generator/Properties/launchSettings.json
================================================
{
  "profiles": {
    "MemoryPack.Generator": {
      "commandName": "DebugRoslynComponent",
      "targetProject": "..\\..\\sandbox\\SandboxConsoleApp\\SandboxConsoleApp.csproj"
    }
  }
}


================================================
FILE: src/MemoryPack.Streaming/MemoryPack.Streaming.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net7.0;netstandard2.1</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <NoWarn>$(NoWarn);CS1591;CA2255</NoWarn>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <PackageTags>serializer</PackageTags>
        <Description>Additional streaming support for MemoryPack.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="System.IO.Pipelines" Version="6.0.3" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\MemoryPack.Core\MemoryPack.Core.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/MemoryPack.Streaming/MemoryPackStreamingSerializer.cs
================================================
﻿using MemoryPack.Internal;
using System.Buffers;
using System.IO.Pipelines;
using System.Runtime.CompilerServices;

namespace MemoryPack.Streaming;

public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        static void WriteCollectionHeader(PipeWriter pipeWriter, int count, MemoryPackWriterOptionalState state)
        {
            var writer = new MemoryPackWriter<PipeWriter>(ref pipeWriter, state);
            writer.WriteCollectionHeader(count);
            writer.Flush();
        }

        static bool WriteWhileReachFlushRate(PipeWriter pipeWriter, IEnumerator<T> enumerator, int flushRate, MemoryPackWriterOptionalState state)
        {
            var writer = new MemoryPackWriter<PipeWriter>(ref pipeWriter, state);
            while (enumerator.MoveNext())
            {
                writer.WriteValue(enumerator.Current);
                if (flushRate < writer.WrittenCount)
                {
                    writer.Flush();
                    return true;
                }
            }

            writer.Flush();
            return false; // false when completed.
        }

        using var state = MemoryPackWriterOptionalStatePool.Rent(options);

        WriteCollectionHeader(pipeWriter, count, state);

        using var enumerator = source.GetEnumerator();

        while (WriteWhileReachFlushRate(pipeWriter, enumerator, flushRate, state))
        {
            await pipeWriter.FlushAsync(cancellationToken).ConfigureAwait(false);
        }

        await pipeWriter.FlushAsync(cancellationToken).ConfigureAwait(false);
    }

    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        static void WriteCollectionHeader(ReusableLinkedArrayBufferWriter bufferWriter, int count, MemoryPackWriterOptionalState state)
        {
            var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufferWriter, state);
            writer.WriteCollectionHeader(count);
            writer.Flush();
        }

        static bool WriteWhileReachFlushRate(ReusableLinkedArrayBufferWriter bufferWriter, IEnumerator<T> enumerator, int flushRate, MemoryPackWriterOptionalState state)
        {
            var writer = new MemoryPackWriter<ReusableLinkedArrayBufferWriter>(ref bufferWriter, state);
            while (enumerator.MoveNext())
            {
                writer.WriteValue(enumerator.Current);
                if (flushRate < writer.WrittenCount)
                {
                    writer.Flush();
                    return true;
                }
            }

            writer.Flush();
            return false; // false when completed.
        }

        using var state = MemoryPackWriterOptionalStatePool.Rent(options);

        var tempWriter = ReusableLinkedArrayBufferWriterPool.Rent();
        try
        {
            WriteCollectionHeader(tempWriter, count, state);

            using var enumerator = source.GetEnumerator();

            while (WriteWhileReachFlushRate(tempWriter, enumerator, flushRate, state))
            {
                await tempWriter.WriteToAndResetAsync(stream, cancellationToken).ConfigureAwait(false);
            }
            await tempWriter.WriteToAndResetAsync(stream, cancellationToken).ConfigureAwait(false);
        }
        finally
        {
            ReusableLinkedArrayBufferWriterPool.Return(tempWriter);
        }
    }

    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, MemoryPackSerializerOptions? options = default, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        static bool ReadCollectionHeader(in ReadOnlySequence<byte> buffer, MemoryPackReaderOptionalState state, out int length)
        {
            using var reader = new MemoryPackReader(buffer, state);

            // allow to use `Dangerous` read header.
            return reader.DangerousTryReadCollectionHeader(out length);
        }

        static int Deserialize(in ReadOnlySequence<byte> buffer, int bufferAtLeast, List<T?> itemBuffer, StrongBox<int> remain, bool bufferIsFull, MemoryPackReaderOptionalState state)
        {
            using var reader = new MemoryPackReader(buffer, state);

            while (bufferIsFull || bufferAtLeast < reader.Remaining)
            {
                if (remain.Value == 0)
                {
                    return reader.Consumed;
                }

                itemBuffer.Add(reader.ReadValue<T?>());
                remain.Value--;
            }

            return reader.Consumed;
        }

        if (readMinimumSize < bufferAtLeast)
        {
            throw new ArgumentException($"readMinimumSize must larger than bufferAtLeast. readMinimumSize: {readMinimumSize} bufferAtLeast:{bufferAtLeast}");
        }

        using var state = MemoryPackReaderOptionalStatePool.Rent(options);

        var itemBuffer = new List<T?>();
        var readResult = await pipeReader.ReadAtLeastAsync(readMinimumSize, cancellationToken).ConfigureAwait(false);

        if (!readResult.IsCanceled)
        {
            var buffer = readResult.Buffer;
            if (ReadCollectionHeader(buffer, state, out var length))
            {
                pipeReader.AdvanceTo(buffer.GetPosition(4));
                if (readResult.IsCompleted)
                {
                    buffer = buffer.Slice(4);
                }

                var remain = new StrongBox<int>(length);
                while (remain.Value != 0)
                {
                    if (!readResult.IsCompleted)
                    {
                        readResult = await pipeReader.ReadAtLeastAsync(readMinimumSize, cancellationToken).ConfigureAwait(false);
                        buffer = readResult.Buffer;
                    }

                    if (readResult.IsCanceled)
                    {
                        yield break;
                    }

                    var consumedByteCount = Deserialize(buffer, bufferAtLeast, itemBuffer, remain, readResult.IsCompleted, state);

                    if (itemBuffer.Count > 0)
                    {
                        foreach (var item in itemBuffer)
                        {
                            yield return item;
                        }
                        itemBuffer.Clear();
                    }

                    if (readResult.IsCompleted)
                    {
                        buffer = buffer.Slice(consumedByteCount);

                        if (consumedByteCount == 0 || buffer.Length == 0)
                        {
                            await pipeReader.CompleteAsync().ConfigureAwait(false);
                            yield break;
                        }
                    }
                    else
                    {
                        pipeReader.AdvanceTo(buffer.GetPosition(consumedByteCount));
                    }
                }
            }
        }

        foreach (var item in itemBuffer)
        {
            yield return item;
        }
    }

    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
    {
        return DeserializeAsync<T>(PipeReader.Create(stream), bufferAtLeast, readMinimumSize, options, cancellationToken);
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Editor.meta
================================================
fileFormatVersion: 2
guid: 340b9d67c20f8074dbdc77a98bf50222
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity.meta
================================================
fileFormatVersion: 2
guid: 4453ae29c67b3b34094dd91dbf7d2c42
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/NuGet.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
    <add key="local" value="/Users/s24061/packages" />
  </packageSources>
  <disabledPackageSources />
  <packageSourceCredentials />
  <activePackageSource>
    <add key="All" value="(Aggregate source)" />
  </activePackageSource>
  <config>
    <add key="repositoryPath" value="./Packages" />
    <add key="PackagesConfigDirectoryPath" value="." />
    <add key="slimRestore" value="true" />
    <add key="ReadOnlyPackageFiles" value="false" />
  </config>
</configuration>


================================================
FILE: src/MemoryPack.Unity/Assets/NuGet.config.meta
================================================
fileFormatVersion: 2
guid: 5f68d08f3f4da46d8ae08934118710a9
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="System.Collections.Immutable" version="6.0.0" manuallyInstalled="true" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" />
</packages>


================================================
FILE: src/MemoryPack.Unity/Assets/packages.config.meta
================================================
fileFormatVersion: 2
guid: e92171552d517412984ee582c2c3d86d
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages.meta
================================================
fileFormatVersion: 2
guid: 67f4dc03015bd40a897401d6ee72d5fc
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Resources.meta
================================================
fileFormatVersion: 2
guid: b7b1d130f3cff4e478b08195007c3fd8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Scenes.meta
================================================
fileFormatVersion: 2
guid: 131a6b21c8605f84396be9f6751fb6e3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests.meta
================================================
fileFormatVersion: 2
guid: a1fa33fc368e97a49a9d962e57c2ef64
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Editor/PackageExporter.cs
================================================
﻿#if UNITY_EDITOR

using System;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

public static class PackageExporter
{
    [MenuItem("Tools/Export Unitypackage")]
    public static void Export()
    {
        var roots = new[] { "Plugins/MemoryPack" };

        foreach (var root in roots)
        {
            var version = GetVersion(root);
            var fn = root.Split('/').Last();

            var fileName = string.IsNullOrEmpty(version) ? $"{fn}.unitypackage" : $"{fn}.{version}.unitypackage";
            var exportPath = "./" + fileName;

            var path = Path.Combine(Application.dataPath, root);
            var assets = Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories)
                .Where(x => Path.GetExtension(x) is ".cs" or ".asmdef" or ".json" or ".meta" or ".dll")
                .Select(x => "Assets" + x.Replace(Application.dataPath, "").Replace(@"\", "/"))
                .ToArray();

            var netStandardsAsset = Directory.EnumerateFiles(Path.Combine(Application.dataPath, "Plugins/"), "*", SearchOption.AllDirectories)
                .Select(x => "Assets" + x.Replace(Application.dataPath, "").Replace(@"\", "/"))
                .ToArray();

            assets = netStandardsAsset.Concat(assets).ToArray();

            AssetDatabase.ExportPackage(
                assets,
                exportPath,
                ExportPackageOptions.Default);

            UnityEngine.Debug.Log("Export complete: " + Path.GetFullPath(exportPath) + Environment.NewLine + string.Join(Environment.NewLine, assets));
        }
    }

    static string GetVersion(string root)
    {
        var version = Environment.GetEnvironmentVariable("UNITY_PACKAGE_VERSION");
        var versionJson = Path.Combine(Application.dataPath, root, "package.json");

        if (File.Exists(versionJson))
        {
            var v = JsonUtility.FromJson<Version>(File.ReadAllText(versionJson));

            if (!string.IsNullOrEmpty(version))
            {
                if (v.version != version)
                {
                    var msg = $"package.json and env version are mismatched. UNITY_PACKAGE_VERSION:{version}, package.json:{v.version}";

                    if (Application.isBatchMode)
                    {
                        Console.WriteLine(msg);
                        Application.Quit(1);
                    }

                    throw new Exception("package.json and env version are mismatched.");
                }
            }

            version = v.version;
        }

        return version;
    }

    public class Version
    {
        public string version;
    }
}

#endif



================================================
FILE: src/MemoryPack.Unity/Assets/Editor/PackageExporter.cs.meta
================================================
fileFormatVersion: 2
guid: 3f14e53a9b34d1747938b6962994711a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/package.json
================================================
{
    "name": "com.cysharp.memorypack",
    "displayName": "MemoryPack",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.21.4",
    "unity": "2022.3",
    "unityRelease": "12f1",
    "description": "Zero encoding extreme performance binary serializer for C#.",
    "keywords": [ "Serialization" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {}
}



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/package.json.meta
================================================
fileFormatVersion: 2
guid: 6e9131239c37ee8479af2a3e1f79f5d0
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime.meta
================================================
fileFormatVersion: 2
guid: 0f1635dedba3a224080ec41edec697e5
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/MemoryPack.Unity.asmdef
================================================
{
    "name": "MemoryPack.Unity",
    "rootNamespace": "MemoryPack",
    "references": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": true,
    "precompiledReferences": [
        "MemoryPack.Core.dll"
    ],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/MemoryPack.Unity.asmdef.meta
================================================
fileFormatVersion: 2
guid: 756335c0388f7114790e504ed368ae1d
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/ProviderInitializer.cs
================================================
﻿#nullable enable

using MemoryPack.Formatters;
using UnityEngine;

namespace MemoryPack
{
    public static partial class MemoryPackUnityFormatterProviderInitializer
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
        public static void RegisterInitialFormatters()
        {
            // struct
            UnityRegister<UnityEngine.Vector2>();
            UnityRegister<UnityEngine.Vector3>();
            UnityRegister<UnityEngine.Vector4>();
            UnityRegister<UnityEngine.Quaternion>();
            UnityRegister<UnityEngine.Color>();
            UnityRegister<UnityEngine.Bounds>();
            UnityRegister<UnityEngine.Rect>();
            UnityRegister<UnityEngine.Keyframe>();
            MemoryPackFormatterProvider.Register(new UnmanagedFormatter<UnityEngine.WrapMode>());
            UnityRegister<UnityEngine.Matrix4x4>();
            UnityRegister<UnityEngine.GradientColorKey>();
            UnityRegister<UnityEngine.GradientAlphaKey>();
            MemoryPackFormatterProvider.Register(new UnmanagedFormatter<UnityEngine.GradientMode>());
            UnityRegister<UnityEngine.Color32>();
            UnityRegister<UnityEngine.LayerMask>();
            UnityRegister<UnityEngine.Vector2Int>();
            UnityRegister<UnityEngine.Vector3Int>();
            UnityRegister<UnityEngine.RangeInt>();
            UnityRegister<UnityEngine.RectInt>();
            UnityRegister<UnityEngine.BoundsInt>();

            // class
            if (!MemoryPackFormatterProvider.IsRegistered<AnimationCurve>())
            {
                MemoryPackFormatterProvider.Register(new AnimationCurveFormatter());
                MemoryPackFormatterProvider.Register(new ArrayFormatter<AnimationCurve>());
                MemoryPackFormatterProvider.Register(new ListFormatter<AnimationCurve>());
            }
            if (!MemoryPackFormatterProvider.IsRegistered<Gradient>())
            {
                MemoryPackFormatterProvider.Register(new GradientFormatter());
                MemoryPackFormatterProvider.Register(new ArrayFormatter<Gradient>());
                MemoryPackFormatterProvider.Register(new ListFormatter<Gradient>());
            }
            if (!MemoryPackFormatterProvider.IsRegistered<RectOffset>())
            {
                MemoryPackFormatterProvider.Register(new RectOffsetFormatter());
                MemoryPackFormatterProvider.Register(new ArrayFormatter<RectOffset>());
                MemoryPackFormatterProvider.Register(new ListFormatter<RectOffset>());
            }
        }

        static void UnityRegister<T>()
            where T : unmanaged
        {
            MemoryPackFormatterProvider.Register(new UnmanagedFormatter<T>());
            MemoryPackFormatterProvider.Register(new UnmanagedArrayFormatter<T>());
            MemoryPackFormatterProvider.Register(new ListFormatter<T>());
            MemoryPackFormatterProvider.Register(new NullableFormatter<T>());
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/ProviderInitializer.cs.meta
================================================
fileFormatVersion: 2
guid: 031150f227b81a94a8fd30bb205ab850
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/UnityFormatters.cs
================================================
﻿#nullable enable

using MemoryPack.Internal;
using UnityEngine;

namespace MemoryPack
{
    [Preserve]
    internal sealed class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref AnimationCurve? value)
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                return;
            }

            writer.WriteUnmanagedWithObjectHeader(3, value.@preWrapMode, value.@postWrapMode);
            writer.WriteUnmanagedArray(value.@keys);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, ref AnimationCurve? value)
        {
            if (!reader.TryReadObjectHeader(out var count))
            {
                value = null;
                return;
            }

            if (count != 3) MemoryPackSerializationException.ThrowInvalidPropertyCount(3, count);

            reader.ReadUnmanaged(out WrapMode preWrapMode, out WrapMode postWrapMode);
            var keys = reader.ReadUnmanagedArray<global::UnityEngine.Keyframe>();

            if (value == null)
            {
                value = new AnimationCurve();
            }

            value.preWrapMode = preWrapMode;
            value.postWrapMode = postWrapMode;
            value.keys = keys;
        }
    }

    [Preserve]
    internal sealed class GradientFormatter : MemoryPackFormatter<Gradient>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref Gradient? value)
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                return;
            }

            writer.WriteObjectHeader(3);
            writer.WriteUnmanagedArray(value.@colorKeys);
            writer.WriteUnmanagedArray(value.@alphaKeys);
            writer.WriteUnmanaged(value.@mode);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, ref Gradient? value)
        {
            if (!reader.TryReadObjectHeader(out var count))
            {
                value = null;
                return;
            }

            if (count != 3) MemoryPackSerializationException.ThrowInvalidPropertyCount(3, count);

            var colorKeys = reader.ReadUnmanagedArray<global::UnityEngine.GradientColorKey>();
            var alphaKeys = reader.ReadUnmanagedArray<global::UnityEngine.GradientAlphaKey>();
            reader.ReadUnmanaged(out GradientMode mode);

            if (value == null)
            {
                value = new Gradient();
            }

            value.colorKeys = colorKeys;
            value.alphaKeys = alphaKeys;
            value.mode = mode;
        }
    }

    [Preserve]
    internal sealed class RectOffsetFormatter : MemoryPackFormatter<RectOffset>
    {
        [Preserve]
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref RectOffset? value)
        {
            if (value == null)
            {
                writer.WriteNullObjectHeader();
                return;
            }

            writer.WriteUnmanagedWithObjectHeader(4, value.@left, value.@right, value.@top, value.@bottom);
        }

        [Preserve]
        public override void Deserialize(ref MemoryPackReader reader, ref RectOffset? value)
        {
            if (!reader.TryReadObjectHeader(out var count))
            {
                value = null;
                return;
            }

            if (count != 4) MemoryPackSerializationException.ThrowInvalidPropertyCount(4, count);

            reader.ReadUnmanaged(out int left, out int right, out int top, out int bottom);

            if (value == null)
            {
                value = new RectOffset(left, right, top, bottom);
            }
            else
            {
                value.left = left;
                value.right = right;
                value.top = top;
                value.bottom = bottom;
            }
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/MemoryPack.Unity/Runtime/UnityFormatters.cs.meta
================================================
fileFormatVersion: 2
guid: 4e8b601bad4e9394baceb6c8449f22c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0.meta
================================================
fileFormatVersion: 2
guid: e099a3b44c5ac444fb09326bad17d9f8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0.meta
================================================
fileFormatVersion: 2
guid: 3171a0a1e6f4a4036a39561dd83e74aa
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive.meta
================================================
fileFormatVersion: 2
guid: 12aed87b6d6ba4b84bce041321f8aca7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: a179a887315984ab198f0e3241e3ef23
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: 99cf0957db5bf48188efc106c9acce06
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: fa1c34196dac64a6e8c60cc9fdefd375
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/System.Collections.Immutable.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata>
    <id>System.Collections.Immutable</id>
    <version>6.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <projectUrl>https://dot.net/</projectUrl>
    <description>This package provides collections that are thread safe and guaranteed to never change their contents, also known as immutable collections. Like strings, any methods that perform modifications will not change the existing instance but instead return a new instance. For efficiency reasons, the implementation uses a sharing mechanism to ensure that newly created instances share as much data as possible with the previous instance while ensuring that operations have a predictable time complexity.

Commonly Used Types:
System.Collections.Immutable.ImmutableArray
System.Collections.Immutable.ImmutableArray&lt;T&gt;
System.Collections.Immutable.ImmutableDictionary
System.Collections.Immutable.ImmutableDictionary&lt;TKey,TValue&gt;
System.Collections.Immutable.ImmutableHashSet
System.Collections.Immutable.ImmutableHashSet&lt;T&gt;
System.Collections.Immutable.ImmutableList
System.Collections.Immutable.ImmutableList&lt;T&gt;
System.Collections.Immutable.ImmutableQueue
System.Collections.Immutable.ImmutableQueue&lt;T&gt;
System.Collections.Immutable.ImmutableSortedDictionary
System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;
System.Collections.Immutable.ImmutableSortedSet
System.Collections.Immutable.ImmutableSortedSet&lt;T&gt;
System.Collections.Immutable.ImmutableStack
System.Collections.Immutable.ImmutableStack&lt;T&gt;</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="4822e3c3aa77eb82b2fb33c9321f923cf11ddde6" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.1">
        <dependency id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" exclude="Build,Analyzers" />
        <dependency id="System.Memory" version="4.5.4" exclude="Build,Analyzers" />
      </group>
      <group targetFramework="net6.0">
        <dependency id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" exclude="Build,Analyzers" />
      </group>
      <group targetFramework=".NETStandard2.0">
        <dependency id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" exclude="Build,Analyzers" />
        <dependency id="System.Memory" version="4.5.4" exclude="Build,Analyzers" />
      </group>
    </dependencies>
  </metadata>
</package>


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/System.Collections.Immutable.nuspec.meta
================================================
fileFormatVersion: 2
guid: 2945cffe804864d00920f6afc4c2e9b0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/THIRD-PARTY-NOTICES.TXT
================================================
.NET Runtime uses third-party libraries or other resources that may be
distributed under licenses different than the .NET Runtime software.

In the event that we accidentally failed to list a required notice, please
bring it to our attention. Post an issue or email us:

           dotnet@microsoft.com

The attached notices are provided for information only.

License notice for ASP.NET
-------------------------------

Copyright (c) .NET Foundation. All rights reserved.
Licensed under the Apache License, Version 2.0.

Available at
https://github.com/dotnet/aspnetcore/blob/main/LICENSE.txt

License notice for Slicing-by-8
-------------------------------

http://sourceforge.net/projects/slicing-by-8/

Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved


This software program is licensed subject to the BSD License,  available at
http://www.opensource.org/licenses/bsd-license.html.


License notice for Unicode data
-------------------------------

https://www.unicode.org/license.html

Copyright © 1991-2020 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Unicode data files and any associated documentation
(the "Data Files") or Unicode software and any associated documentation
(the "Software") to deal in the Data Files or Software
without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, and/or sell copies of
the Data Files or Software, and to permit persons to whom the Data Files
or Software are furnished to do so, provided that either
(a) this copyright and permission notice appear with all copies
of the Data Files or Software, or
(b) this copyright and permission notice appear in associated
Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in these Data Files or Software without prior
written authorization of the copyright holder.

License notice for Zlib
-----------------------

https://github.com/madler/zlib
http://zlib.net/zlib_license.html

/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/

License notice for Mono
-------------------------------

http://www.mono-project.com/docs/about-mono/

Copyright (c) .NET Foundation Contributors

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software  and associated documentation files (the Software), to deal
in the Software without restriction,  including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense,  and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so,  subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for International Organization for Standardization
-----------------------------------------------------------------

Portions (C) International Organization for Standardization 1986:
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

License notice for Intel
------------------------

"Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Xamarin and Novell
-------------------------------------

Copyright (c) 2015 Xamarin, Inc (http://www.xamarin.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Copyright (c) 2011 Novell, Inc (http://www.novell.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Third party notice for W3C
--------------------------

"W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE
Status: This license takes effect 13 May, 2015.
This work is being provided by the copyright holders under the following license.
License
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.
Permission to copy, modify, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:
The full text of this NOTICE in a location viewable to users of the redistributed or derivative work.
Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software and Document Short Notice should be included.
Notice of any changes or modifications, through a copyright statement on the new code or document such as "This software or document includes material copied from or derived from [title and URI of the W3C document]. Copyright © [YEAR] W3C® (MIT, ERCIM, Keio, Beihang)."
Disclaimers
THIS WORK IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.
The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders."

License notice for Bit Twiddling Hacks
--------------------------------------

Bit Twiddling Hacks

By Sean Eron Anderson
seander@cs.stanford.edu

Individually, the code snippets here are in the public domain (unless otherwise
noted) — feel free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are
distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and
without even the implied warranty of merchantability or fitness for a particular
purpose.

License notice for Brotli
--------------------------------------

Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

compress_fragment.c:
Copyright (c) 2011, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

decode_fuzzer.c:
Copyright (c) 2015 The Chromium Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

License notice for Json.NET
-------------------------------

https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md

The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized base64 encoding / decoding
--------------------------------------------------------

Copyright (c) 2005-2007, Nick Galbreath
Copyright (c) 2013-2017, Alfred Klomp
Copyright (c) 2015-2017, Wojciech Mula
Copyright (c) 2016-2017, Matthieu Darbois
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for RFC 3492
---------------------------

The punycode implementation is based on the sample code in RFC 3492

Copyright (C) The Internet Society (2003).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

License notice for Algorithm from Internet Draft document "UUIDs and GUIDs"
---------------------------------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, or Digital Equipment Corporation be used in advertising
or publicity pertaining to distribution of the software without
specific, written prior permission.  Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
Corporation makes any representations about the suitability of
this software for any purpose.

Copyright(C) The Internet Society 1997. All Rights Reserved.

This document and translations of it may be copied and furnished to others,
and derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published and distributed, in
whole or in part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such copies and
derivative works.However, this document itself may not be modified in any
way, such as by removing the copyright notice or references to the Internet
Society or other Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for copyrights
defined in the Internet Standards process must be followed, or as required
to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked
by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS IS"
basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE
DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

License notice for Algorithm from RFC 4122 -
A Universally Unique IDentifier (UUID) URN Namespace
----------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
Copyright (c) 1998 Microsoft.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, Microsoft, or Digital Equipment Corporation be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission. Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
Equipment Corporation makes any representations about the
suitability of this software for any purpose."

License notice for The LLVM Compiler Infrastructure
---------------------------------------------------

Developed by:

    LLVM Team

    University of Illinois at Urbana-Champaign

    http://llvm.org

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimers.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimers in the
      documentation and/or other materials provided with the distribution.

    * Neither the names of the LLVM Team, University of Illinois at
      Urbana-Champaign, nor the names of its contributors may be used to
      endorse or promote products derived from this Software without specific
      prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
SOFTWARE.

License notice for Bob Jenkins
------------------------------

By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this
code any way you wish, private, educational, or commercial.  It's free.

License notice for Greg Parker
------------------------------

Greg Parker     gparker@cs.stanford.edu     December 2000
This code is in the public domain and may be copied or modified without
permission.

License notice for libunwind based code
----------------------------------------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for Printing Floating-Point Numbers (Dragon4)
------------------------------------------------------------

/******************************************************************************
  Copyright (c) 2014 Ryan Juckett
  http://www.ryanjuckett.com/

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
******************************************************************************/

License notice for Printing Floating-point Numbers (Grisu3)
-----------------------------------------------------------

Copyright 2012 the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xxHash
-------------------------

xxHash Library
Copyright (c) 2012-2014, Yann Collet
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Berkeley SoftFloat Release 3e
------------------------------------------------

https://github.com/ucb-bar/berkeley-softfloat-3
https://github.com/ucb-bar/berkeley-softfloat-3/blob/master/COPYING.txt

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xoshiro RNGs
--------------------------------

Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>.

License for fastmod (https://github.com/lemire/fastmod) and ibm-fpgen (https://github.com/nigeltao/parse-number-fxx-test-data)
--------------------------------------

   Copyright 2018 Daniel Lemire

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

License notice for The C++ REST SDK
-----------------------------------

C++ REST SDK

The MIT License (MIT)

Copyright (c) Microsoft Corporation

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for MessagePack-CSharp
-------------------------------------

MessagePack for C#

MIT License

Copyright (c) 2017 Yoshifumi Kawai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for lz4net
-------------------------------------

lz4net

Copyright (c) 2013-2017, Milosz Krajewski

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Nerdbank.Streams
-----------------------------------

The MIT License (MIT)

Copyright (c) Andrew Arnott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for RapidJSON
----------------------------

Tencent is pleased to support the open source community by making RapidJSON available.

Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved.

Licensed under the MIT License (the "License"); you may not use this file except
in compliance with the License. You may obtain a copy of the License at

http://opensource.org/licenses/MIT

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.

License notice for DirectX Math Library
---------------------------------------

https://github.com/microsoft/DirectXMath/blob/master/LICENSE

                               The MIT License (MIT)

Copyright (c) 2011-2020 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for ldap4net
---------------------------

The MIT License (MIT)

Copyright (c) 2018 Alexander Chermyanin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized sorting code
------------------------------------------

MIT License

Copyright (c) 2020 Dan Shechter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for musl
-----------------------

musl as a whole is licensed under the following standard MIT license:

Copyright © 2005-2020 Rich Felker, et al.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


License notice for "Faster Unsigned Division by Constants"
------------------------------

Reference implementations of computing and using the "magic number" approach to dividing
by constants, including codegen instructions. The unsigned division incorporates the
"round down" optimization per ridiculous_fish.

This is free and unencumbered software. Any copyright is dedicated to the Public Domain.


License notice for mimalloc
-----------------------------------

MIT License

Copyright (c) 2019 Microsoft Corporation, Daan Leijen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: 71a8c7dda12c046648896459e9869dfe
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: 8d31ee2ee5bf14b75a6f90a0b982e7c5
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp2.0.meta
================================================
fileFormatVersion: 2
guid: 4f885f563e8c54761921cc8bc65c1a76
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp3.1.meta
================================================
fileFormatVersion: 2
guid: a6709de31f9034d0f92e678fbfce2def
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp2.0/System.Collections.Immutable.targets
================================================
<Project InitialTargets="NETStandardCompatError_System_Collections_Immutable_netcoreapp3_1">
  <Target Name="NETStandardCompatError_System_Collections_Immutable_netcoreapp3_1"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Error Text="System.Collections.Immutable doesn't support $(TargetFramework). Consider updating your TargetFramework to netcoreapp3.1 or later." />
  </Target>
</Project>



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp2.0/System.Collections.Immutable.targets.meta
================================================
fileFormatVersion: 2
guid: eafd8ef9be205409691a9d80d531f825
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp3.1/_._
================================================
[Empty file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/buildTransitive/netcoreapp3.1/_._.meta
================================================
fileFormatVersion: 2
guid: d6fb258e1656045e8858ca27409f8b37
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/lib/netstandard2.0.meta
================================================
fileFormatVersion: 2
guid: 43b9ebf4352ea4063a7940a3fe6c93a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/lib/netstandard2.0/System.Collections.Immutable.dll.meta
================================================
fileFormatVersion: 2
guid: 86d00c2c404e6438fa79eef89e6cbe00
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Collections.Immutable.6.0.0/lib/netstandard2.0/System.Collections.Immutable.xml.meta
================================================
fileFormatVersion: 2
guid: b2f4374853df649a297a275f3ee7b2f9
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive.meta
================================================
fileFormatVersion: 2
guid: 7621934dba3b24b1b822f44a1202ed18
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: 2d9a5e31d0d5f46c28bd4c51ae9b8cd0
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: 4ae455b5af59447068bdf9a595e1061b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: e2570dd43251a4151acb78f55e7f3704
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/System.Runtime.CompilerServices.Unsafe.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd">
  <metadata>
    <id>System.Runtime.CompilerServices.Unsafe</id>
    <version>6.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <projectUrl>https://dot.net/</projectUrl>
    <description>Provides the System.Runtime.CompilerServices.Unsafe class, which provides generic, low-level functionality for manipulating pointers.

Commonly Used Types:
System.Runtime.CompilerServices.Unsafe</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="4822e3c3aa77eb82b2fb33c9321f923cf11ddde6" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.1" />
      <group targetFramework=".NETCoreApp3.1" />
      <group targetFramework="net6.0" />
      <group targetFramework=".NETStandard2.0" />
    </dependencies>
    <frameworkAssemblies>
      <frameworkAssembly assemblyName="mscorlib" targetFramework=".NETFramework4.6.1" />
    </frameworkAssemblies>
  </metadata>
</package>


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/System.Runtime.CompilerServices.Unsafe.nuspec.meta
================================================
fileFormatVersion: 2
guid: 66483a01341bd40f69be4b66fefc9351
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/THIRD-PARTY-NOTICES.TXT
================================================
.NET Runtime uses third-party libraries or other resources that may be
distributed under licenses different than the .NET Runtime software.

In the event that we accidentally failed to list a required notice, please
bring it to our attention. Post an issue or email us:

           dotnet@microsoft.com

The attached notices are provided for information only.

License notice for ASP.NET
-------------------------------

Copyright (c) .NET Foundation. All rights reserved.
Licensed under the Apache License, Version 2.0.

Available at
https://github.com/dotnet/aspnetcore/blob/main/LICENSE.txt

License notice for Slicing-by-8
-------------------------------

http://sourceforge.net/projects/slicing-by-8/

Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved


This software program is licensed subject to the BSD License,  available at
http://www.opensource.org/licenses/bsd-license.html.


License notice for Unicode data
-------------------------------

https://www.unicode.org/license.html

Copyright © 1991-2020 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Unicode data files and any associated documentation
(the "Data Files") or Unicode software and any associated documentation
(the "Software") to deal in the Data Files or Software
without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, and/or sell copies of
the Data Files or Software, and to permit persons to whom the Data Files
or Software are furnished to do so, provided that either
(a) this copyright and permission notice appear with all copies
of the Data Files or Software, or
(b) this copyright and permission notice appear in associated
Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in these Data Files or Software without prior
written authorization of the copyright holder.

License notice for Zlib
-----------------------

https://github.com/madler/zlib
http://zlib.net/zlib_license.html

/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/

License notice for Mono
-------------------------------

http://www.mono-project.com/docs/about-mono/

Copyright (c) .NET Foundation Contributors

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software  and associated documentation files (the Software), to deal
in the Software without restriction,  including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense,  and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so,  subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for International Organization for Standardization
-----------------------------------------------------------------

Portions (C) International Organization for Standardization 1986:
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

License notice for Intel
------------------------

"Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Xamarin and Novell
-------------------------------------

Copyright (c) 2015 Xamarin, Inc (http://www.xamarin.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Copyright (c) 2011 Novell, Inc (http://www.novell.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Third party notice for W3C
--------------------------

"W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE
Status: This license takes effect 13 May, 2015.
This work is being provided by the copyright holders under the following license.
License
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.
Permission to copy, modify, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:
The full text of this NOTICE in a location viewable to users of the redistributed or derivative work.
Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software and Document Short Notice should be included.
Notice of any changes or modifications, through a copyright statement on the new code or document such as "This software or document includes material copied from or derived from [title and URI of the W3C document]. Copyright © [YEAR] W3C® (MIT, ERCIM, Keio, Beihang)."
Disclaimers
THIS WORK IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.
The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders."

License notice for Bit Twiddling Hacks
--------------------------------------

Bit Twiddling Hacks

By Sean Eron Anderson
seander@cs.stanford.edu

Individually, the code snippets here are in the public domain (unless otherwise
noted) — feel free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are
distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and
without even the implied warranty of merchantability or fitness for a particular
purpose.

License notice for Brotli
--------------------------------------

Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

compress_fragment.c:
Copyright (c) 2011, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

decode_fuzzer.c:
Copyright (c) 2015 The Chromium Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

License notice for Json.NET
-------------------------------

https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md

The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized base64 encoding / decoding
--------------------------------------------------------

Copyright (c) 2005-2007, Nick Galbreath
Copyright (c) 2013-2017, Alfred Klomp
Copyright (c) 2015-2017, Wojciech Mula
Copyright (c) 2016-2017, Matthieu Darbois
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for RFC 3492
---------------------------

The punycode implementation is based on the sample code in RFC 3492

Copyright (C) The Internet Society (2003).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

License notice for Algorithm from Internet Draft document "UUIDs and GUIDs"
---------------------------------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, or Digital Equipment Corporation be used in advertising
or publicity pertaining to distribution of the software without
specific, written prior permission.  Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
Corporation makes any representations about the suitability of
this software for any purpose.

Copyright(C) The Internet Society 1997. All Rights Reserved.

This document and translations of it may be copied and furnished to others,
and derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published and distributed, in
whole or in part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such copies and
derivative works.However, this document itself may not be modified in any
way, such as by removing the copyright notice or references to the Internet
Society or other Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for copyrights
defined in the Internet Standards process must be followed, or as required
to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked
by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS IS"
basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE
DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

License notice for Algorithm from RFC 4122 -
A Universally Unique IDentifier (UUID) URN Namespace
----------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
Copyright (c) 1998 Microsoft.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, Microsoft, or Digital Equipment Corporation be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission. Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
Equipment Corporation makes any representations about the
suitability of this software for any purpose."

License notice for The LLVM Compiler Infrastructure
---------------------------------------------------

Developed by:

    LLVM Team

    University of Illinois at Urbana-Champaign

    http://llvm.org

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimers.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimers in the
      documentation and/or other materials provided with the distribution.

    * Neither the names of the LLVM Team, University of Illinois at
      Urbana-Champaign, nor the names of its contributors may be used to
      endorse or promote products derived from this Software without specific
      prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
SOFTWARE.

License notice for Bob Jenkins
------------------------------

By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this
code any way you wish, private, educational, or commercial.  It's free.

License notice for Greg Parker
------------------------------

Greg Parker     gparker@cs.stanford.edu     December 2000
This code is in the public domain and may be copied or modified without
permission.

License notice for libunwind based code
----------------------------------------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for Printing Floating-Point Numbers (Dragon4)
------------------------------------------------------------

/******************************************************************************
  Copyright (c) 2014 Ryan Juckett
  http://www.ryanjuckett.com/

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
******************************************************************************/

License notice for Printing Floating-point Numbers (Grisu3)
-----------------------------------------------------------

Copyright 2012 the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xxHash
-------------------------

xxHash Library
Copyright (c) 2012-2014, Yann Collet
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Berkeley SoftFloat Release 3e
------------------------------------------------

https://github.com/ucb-bar/berkeley-softfloat-3
https://github.com/ucb-bar/berkeley-softfloat-3/blob/master/COPYING.txt

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xoshiro RNGs
--------------------------------

Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>.

License for fastmod (https://github.com/lemire/fastmod) and ibm-fpgen (https://github.com/nigeltao/parse-number-fxx-test-data)
--------------------------------------

   Copyright 2018 Daniel Lemire

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

License notice for The C++ REST SDK
-----------------------------------

C++ REST SDK

The MIT License (MIT)

Copyright (c) Microsoft Corporation

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for MessagePack-CSharp
-------------------------------------

MessagePack for C#

MIT License

Copyright (c) 2017 Yoshifumi Kawai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for lz4net
-------------------------------------

lz4net

Copyright (c) 2013-2017, Milosz Krajewski

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Nerdbank.Streams
-----------------------------------

The MIT License (MIT)

Copyright (c) Andrew Arnott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for RapidJSON
----------------------------

Tencent is pleased to support the open source community by making RapidJSON available.

Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved.

Licensed under the MIT License (the "License"); you may not use this file except
in compliance with the License. You may obtain a copy of the License at

http://opensource.org/licenses/MIT

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.

License notice for DirectX Math Library
---------------------------------------

https://github.com/microsoft/DirectXMath/blob/master/LICENSE

                               The MIT License (MIT)

Copyright (c) 2011-2020 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for ldap4net
---------------------------

The MIT License (MIT)

Copyright (c) 2018 Alexander Chermyanin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized sorting code
------------------------------------------

MIT License

Copyright (c) 2020 Dan Shechter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for musl
-----------------------

musl as a whole is licensed under the following standard MIT license:

Copyright © 2005-2020 Rich Felker, et al.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


License notice for "Faster Unsigned Division by Constants"
------------------------------

Reference implementations of computing and using the "magic number" approach to dividing
by constants, including codegen instructions. The unsigned division incorporates the
"round down" optimization per ridiculous_fish.

This is free and unencumbered software. Any copyright is dedicated to the Public Domain.


License notice for mimalloc
-----------------------------------

MIT License

Copyright (c) 2019 Microsoft Corporation, Daan Leijen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: e0adc825ac780433fa36619b2a0d1a47
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: b374e994cfa8a40699ccfe48d8865337
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0.meta
================================================
fileFormatVersion: 2
guid: cfe80331339a04b539c30dcd3b4445ea
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1.meta
================================================
fileFormatVersion: 2
guid: ac4875688fd9244bf91a460ede7ed13e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0/System.Runtime.CompilerServices.Unsafe.targets
================================================
<Project InitialTargets="NETStandardCompatError_System_Runtime_CompilerServices_Unsafe_netcoreapp3_1">
  <Target Name="NETStandardCompatError_System_Runtime_CompilerServices_Unsafe_netcoreapp3_1"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Error Text="System.Runtime.CompilerServices.Unsafe doesn't support $(TargetFramework). Consider updating your TargetFramework to netcoreapp3.1 or later." />
  </Target>
</Project>



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0/System.Runtime.CompilerServices.Unsafe.targets.meta
================================================
fileFormatVersion: 2
guid: 53df268cc3b5b481eab04c6aa53f2116
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1/_._
================================================
[Empty file]


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1/_._.meta
================================================
fileFormatVersion: 2
guid: 2bd41ec9351684811a8ae5e217738c4e
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0.meta
================================================
fileFormatVersion: 2
guid: 0fa8cf31247a341ba890a31a402c1483
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll.meta
================================================
fileFormatVersion: 2
guid: 9c13872d8858d4fef9f6582dcd343096
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.xml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Runtime.CompilerServices.Unsafe</name>
  </assembly>
  <members>
    <member name="T:System.Runtime.CompilerServices.Unsafe">
      <summary>Contains generic, low-level functionality for manipulating pointers.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.Int32)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.IntPtr)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.UIntPtr)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(System.Void*,System.Int32)">
      <summary>Adds an element offset to the given void pointer.</summary>
      <param name="source">The void pointer to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of void pointer.</typeparam>
      <returns>A new void pointer that reflects the addition of offset to the specified pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.IntPtr)">
      <summary>Adds a byte offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="byteOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of byte offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.UIntPtr)">
      <summary>Adds a byte offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="byteOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of byte offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AreSame``1(``0@,``0@)">
      <summary>Determines whether the specified references point to the same location.</summary>
      <param name="left">The first reference to compare.</param>
      <param name="right">The second reference to compare.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> point to the same location; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.As``1(System.Object)">
      <summary>Casts the given object to the specified type.</summary>
      <param name="o">The object to cast.</param>
      <typeparam name="T">The type which the object will be cast to.</typeparam>
      <returns>The original object, casted to the given type.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)">
      <summary>Reinterprets the given reference as a reference to a value of type <typeparamref name="TTo" />.</summary>
      <param name="source">The reference to reinterpret.</param>
      <typeparam name="TFrom">The type of reference to reinterpret.</typeparam>
      <typeparam name="TTo">The desired type of the reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="TTo" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsPointer``1(``0@)">
      <summary>Returns a pointer to the given by-ref parameter.</summary>
      <param name="value">The object whose pointer is obtained.</param>
      <typeparam name="T">The type of object.</typeparam>
      <returns>A pointer to the given value.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(``0@)">
      <summary>Reinterprets the given read-only reference as a reference.</summary>
      <param name="source">The read-only reference to reinterpret.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(System.Void*)">
      <summary>Reinterprets the given location as a reference to a value of type <typeparamref name="T" />.</summary>
      <param name="source">The location of the value to reference.</param>
      <typeparam name="T">The type of the interpreted location.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ByteOffset``1(``0@,``0@)">
      <summary>Determines the byte offset from origin to target from the given references.</summary>
      <param name="origin">The reference to origin.</param>
      <param name="target">The reference to target.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>Byte offset from origin to target i.e. <paramref name="target" /> - <paramref name="origin" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Copy``1(``0@,System.Void*)">
      <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to copy to.</param>
      <param name="source">A pointer to the value to copy.</param>
      <typeparam name="T">The type of value to copy.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Copy``1(System.Void*,``0@)">
      <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to copy to.</param>
      <param name="source">A reference to the value to copy.</param>
      <typeparam name="T">The type of value to copy.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Byte@,System.Byte@,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Void*,System.Void*,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Byte@,System.Byte@,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Void*,System.Void*,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Byte@,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Void*,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Byte@,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Void*,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsAddressGreaterThan``1(``0@,``0@)">
      <summary>Returns a value that indicates whether a specified reference is greater than another specified reference.</summary>
      <param name="left">The first value to compare.</param>
      <param name="right">The second value to compare.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsAddressLessThan``1(``0@,``0@)">
      <summary>Returns a value that indicates whether a specified reference is less than another specified reference.</summary>
      <param name="left">The first value to compare.</param>
      <param name="right">The second value to compare.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)">
      <summary>Determines if a given reference to a value of type <typeparamref name="T" /> is a null reference.</summary>
      <param name="source">The reference to check.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="source" /> is a null reference; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.NullRef``1">
      <summary>Returns a reference to a value of type <typeparamref name="T" /> that is a null reference.</summary>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" /> that is a null reference.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Read``1(System.Void*)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Byte@)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Void*)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1">
      <summary>Returns the size of an object of the given type parameter.</summary>
      <typeparam name="T">The type of object whose size is retrieved.</typeparam>
      <returns>The size of an object of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SkipInit``1(``0@)">
      <summary>Bypasses definite assignment rules for a given value.</summary>
      <param name="value">The uninitialized object.</param>
      <typeparam name="T">The type of the uninitialized object.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.Int32)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.IntPtr)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.UIntPtr)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(System.Void*,System.Int32)">
      <summary>Subtracts an element offset from the given void pointer.</summary>
      <param name="source">The void pointer to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of the void pointer.</typeparam>
      <returns>A new void pointer that reflects the subtraction of offset from the specified pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.IntPtr)">
      <summary>Subtracts a byte offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="byteOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of byte offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.UIntPtr)">
      <summary>Subtracts a byte offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="byteOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subraction of byte offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Unbox``1(System.Object)">
      <summary>Returns a <see langword="mutable ref" /> to a boxed value.</summary>
      <param name="box">The value to unbox.</param>
      <typeparam name="T">The type to be unboxed.</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="box" /> is <see langword="null" />, and <typeparamref name="T" /> is a non-nullable value type.</exception>
      <exception cref="T:System.InvalidCastException">
        <paramref name="box" /> is not a boxed value type.
         
-or-

<paramref name="box" /> is not a boxed <typeparamref name="T" />.</exception>
      <exception cref="T:System.TypeLoadException">
        <typeparamref name="T" /> cannot be found.</exception>
      <returns>A <see langword="mutable ref" /> to the boxed value <paramref name="box" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Write``1(System.Void*,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Byte@,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Void*,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
  </members>
</doc>


================================================
FILE: src/MemoryPack.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.xml.meta
================================================
fileFormatVersion: 2
guid: 71ea00f8605824751b00461432db57d3
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Scenes/RuntimeUnitTestScene.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &7065226
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 7065227}
  - component: {fileID: 7065230}
  - component: {fileID: 7065229}
  - component: {fileID: 7065228}
  m_Layer: 0
  m_Name: ListScrollbar
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &7065227
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7065226}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1082069005}
  m_Father: {fileID: 2110047695}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 1, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 30, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &7065228
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7065226}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10907, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &7065229
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7065226}
  m_CullTransparentMesh: 1
--- !u!114 &7065230
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 7065226}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2a4db7a114972834c8e4117be1d82ba3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 0
    m_WrapAround: 0
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 2099141205}
  m_HandleRect: {fileID: 2099141204}
  m_Direction: 2
  m_Value: 0
  m_Size: 1
  m_NumberOfSteps: 0
  m_OnValueChanged:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &64804225
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 64804226}
  - component: {fileID: 64804227}
  - component: {fileID: 64804228}
  m_Layer: 0
  m_Name: Handle2
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &64804226
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 64804225}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 1336971389}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 20, y: 20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &64804227
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 64804225}
  m_CullTransparentMesh: 1
--- !u!114 &64804228
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 64804225}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!1 &344055191
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 344055192}
  - component: {fileID: 344055194}
  - component: {fileID: 344055193}
  m_Layer: 0
  m_Name: ScrollableText
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &344055192
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 344055191}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1254114780}
  - {fileID: 1274721982}
  m_Father: {fileID: 1913115880}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &344055193
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 344055191}
  m_CullTransparentMesh: 1
--- !u!114 &344055194
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 344055191}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1aa08ab6e0800fa44ae55d278d1423e3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Content: {fileID: 1254114780}
  m_Horizontal: 0
  m_Vertical: 1
  m_MovementType: 1
  m_Elasticity: 0.1
  m_Inertia: 1
  m_DecelerationRate: 0.135
  m_ScrollSensitivity: 1
  m_Viewport: {fileID: 0}
  m_HorizontalScrollbar: {fileID: 0}
  m_VerticalScrollbar: {fileID: 1274721981}
  m_HorizontalScrollbarVisibility: 0
  m_VerticalScrollbarVisibility: 0
  m_HorizontalScrollbarSpacing: 0
  m_VerticalScrollbarSpacing: 0
  m_OnValueChanged:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &452324892
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 452324893}
  - component: {fileID: 452324897}
  - component: {fileID: 452324896}
  - component: {fileID: 452324895}
  - component: {fileID: 452324894}
  m_Layer: 0
  m_Name: ClearButton
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &452324893
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 452324892}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1359853362}
  m_Father: {fileID: 2145402911}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &452324894
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 452324892}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 306cc8c2b49d7114eaa3623786fc2126, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreLayout: 0
  m_MinWidth: -1
  m_MinHeight: 50
  m_PreferredWidth: -1
  m_PreferredHeight: -1
  m_FlexibleWidth: -1
  m_FlexibleHeight: -1
  m_LayoutPriority: 1
--- !u!114 &452324895
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 452324892}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &452324896
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 452324892}
  m_CullTransparentMesh: 1
--- !u!114 &452324897
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 452324892}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_WrapAround: 0
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 452324895}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &731568400
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 731568401}
  - component: {fileID: 731568404}
  - component: {fileID: 731568403}
  - component: {fileID: 731568402}
  m_Layer: 0
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &731568401
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 731568400}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1913115880}
  m_Father: {fileID: 1182845598}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!114 &731568402
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 731568400}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &731568403
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 731568400}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
  m_PresetInfoIsWorld: 0
--- !u!223 &731568404
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 731568400}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_AdditionalShaderChannelsFlag: 0
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!1 &1082069004
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1082069005}
  m_Layer: 0
  m_Name: Sliding Area
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1082069005
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1082069004}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 2099141204}
  m_Father: {fileID: 7065227}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: -20, y: -20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!1 &1182845595
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1182845598}
  - component: {fileID: 1182845597}
  - component: {fileID: 1182845596}
  m_Layer: 0
  m_Name: SceneRoot
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &1182845596
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1182845595}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 660baed073888b8438569f57e42679b2, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  clearButton: {fileID: 452324897}
  list: {fileID: 2145402911}
  listScrollBar: {fileID: 7065230}
  logText: {fileID: 1254114783}
  logScrollBar: {fileID: 1274721981}
--- !u!20 &1182845597
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1182845595}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 1
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 0
  orthographic size: 5
  m_Depth: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 3
  m_HDR: 1
  m_AllowMSAA: 1
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 1
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &1182845598
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1182845595}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1630623241}
  - {fileID: 731568401}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &1254114779
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1254114780}
  - component: {fileID: 1254114782}
  - component: {fileID: 1254114783}
  - component: {fileID: 1254114781}
  m_Layer: 0
  m_Name: Log
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1254114780
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1254114779}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 344055192}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 15, y: 0}
  m_SizeDelta: {x: -35, y: 0}
  m_Pivot: {x: 0, y: 1}
--- !u!114 &1254114781
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1254114779}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3245ec927659c4140ac4f8d17403cc18, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalFit: 0
  m_VerticalFit: 2
--- !u!222 &1254114782
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1254114779}
  m_CullTransparentMesh: 1
--- !u!114 &1254114783
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1254114779}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 24
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 0
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: 
--- !u!1 &1274721980
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1274721982}
  - component: {fileID: 1274721981}
  - component: {fileID: 1274721984}
  - component: {fileID: 1274721983}
  m_Layer: 0
  m_Name: LogScrollbar
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &1274721981
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1274721980}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2a4db7a114972834c8e4117be1d82ba3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 0
    m_WrapAround: 0
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 64804228}
  m_HandleRect: {fileID: 64804226}
  m_Direction: 2
  m_Value: 0
  m_Size: 1
  m_NumberOfSteps: 0
  m_OnValueChanged:
    m_PersistentCalls:
      m_Calls: []
--- !u!224 &1274721982
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1274721980}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 1336971389}
  m_Father: {fileID: 344055192}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 1, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: -15, y: 0}
  m_SizeDelta: {x: 30, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1274721983
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1274721980}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10907, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &1274721984
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1274721980}
  m_CullTransparentMesh: 1
--- !u!1 &1336971388
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1336971389}
  m_Layer: 0
  m_Name: Sliding Area2
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1336971389
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1336971388}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 64804226}
  m_Father: {fileID: 1274721982}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: -20, y: -20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!1 &1359853361
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1359853362}
  - component: {fileID: 1359853364}
  - component: {fileID: 1359853363}
  m_Layer: 0
  m_Name: ButtonText
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1359853362
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1359853361}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 452324893}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1359853363
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1359853361}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 24
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Clear
--- !u!222 &1359853364
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1359853361}
  m_CullTransparentMesh: 1
--- !u!1 &1630623240
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1630623241}
  - component: {fileID: 1630623243}
  - component: {fileID: 1630623242}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &1630623241
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1630623240}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 1182845598}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &1630623242
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1630623240}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_SendPointerHoverToParent: 1
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &1630623243
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1630623240}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!1 &1913115879
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1913115880}
  - component: {fileID: 1913115882}
  - component: {fileID: 1913115881}
  m_Layer: 0
  m_Name: HorizontalSplitter
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1913115880
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1913115879}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 2110047695}
  - {fileID: 344055192}
  m_Father: {fileID: 731568401}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &1913115881
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1913115879}
  m_CullTransparentMesh: 1
--- !u!114 &1913115882
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1913115879}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 30649d3a9faa99c48a7b1166b86bf2a0, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Padding:
    m_Left: 0
    m_Right: 0
    m_Top: 0
    m_Bottom: 0
  m_ChildAlignment: 0
  m_Spacing: 10
  m_ChildForceExpandWidth: 1
  m_ChildForceExpandHeight: 1
  m_ChildControlWidth: 1
  m_ChildControlHeight: 1
  m_ChildScaleWidth: 0
  m_ChildScaleHeight: 0
  m_ReverseArrangement: 0
--- !u!1 &2099141203
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2099141204}
  - component: {fileID: 2099141206}
  - component: {fileID: 2099141205}
  m_Layer: 0
  m_Name: Handle
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2099141204
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2099141203}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 1082069005}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 20, y: 20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &2099141205
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2099141203}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &2099141206
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2099141203}
  m_CullTransparentMesh: 1
--- !u!1 &2110047694
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2110047695}
  - component: {fileID: 2110047697}
  - component: {fileID: 2110047696}
  m_Layer: 0
  m_Name: ButtonList
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2110047695
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2110047694}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 2145402911}
  - {fileID: 7065227}
  m_Father: {fileID: 1913115880}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &2110047696
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2110047694}
  m_CullTransparentMesh: 1
--- !u!114 &2110047697
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2110047694}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 1aa08ab6e0800fa44ae55d278d1423e3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Content: {fileID: 2145402911}
  m_Horizontal: 0
  m_Vertical: 1
  m_MovementType: 2
  m_Elasticity: 0.1
  m_Inertia: 1
  m_DecelerationRate: 0.135
  m_ScrollSensitivity: 1
  m_Viewport: {fileID: 0}
  m_HorizontalScrollbar: {fileID: 0}
  m_VerticalScrollbar: {fileID: 7065230}
  m_HorizontalScrollbarVisibility: 0
  m_VerticalScrollbarVisibility: 0
  m_HorizontalScrollbarSpacing: 0
  m_VerticalScrollbarSpacing: 0
  m_OnValueChanged:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &2145402910
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2145402911}
  - component: {fileID: 2145402913}
  - component: {fileID: 2145402912}
  m_Layer: 0
  m_Name: ListLayoutToAttach
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2145402911
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2145402910}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 452324893}
  m_Father: {fileID: 2110047695}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 1}
--- !u!114 &2145402912
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2145402910}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 3245ec927659c4140ac4f8d17403cc18, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalFit: 0
  m_VerticalFit: 2
--- !u!114 &2145402913
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2145402910}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 59f8146938fff824cb5fd77236b75775, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Padding:
    m_Left: 10
    m_Right: 20
    m_Top: 10
    m_Bottom: 10
  m_ChildAlignment: 0
  m_Spacing: 10
  m_ChildForceExpandWidth: 1
  m_ChildForceExpandHeight: 0
  m_ChildControlWidth: 1
  m_ChildControlHeight: 1
  m_ChildScaleWidth: 0
  m_ChildScaleHeight: 0
  m_ReverseArrangement: 0



================================================
FILE: src/MemoryPack.Unity/Assets/Scenes/RuntimeUnitTestScene.unity.meta
================================================
fileFormatVersion: 2
guid: f825a3a508f34d1429d39576f6080bc4
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Scenes/SampleScene.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 0
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 500
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 500
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 2
    m_PVRDenoiserTypeDirect: 0
    m_PVRDenoiserTypeIndirect: 0
    m_PVRDenoiserTypeAO: 0
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 0
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &519420028
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 519420032}
  - component: {fileID: 519420031}
  - component: {fileID: 519420029}
  - component: {fileID: 519420033}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!81 &519420029
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
--- !u!20 &519420031
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 2
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 1
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 0
  m_HDR: 1
  m_AllowMSAA: 0
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 0
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &519420032
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &519420033
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 504f6db822cebea42af99779a86d893d, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 



================================================
FILE: src/MemoryPack.Unity/Assets/Scenes/SampleScene.unity.meta
================================================
fileFormatVersion: 2
guid: 2cda990e2423bbf4892e6590ba056729
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/AotTest.cs
================================================
﻿using MemoryPack;
using MemoryPack.Formatters;
using Models;
using NUnit.Framework;
using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AotTest
{
    // https://github.com/Cysharp/MemoryPack/issues/34

    [Test]
    public void Dict()
    {
        var container = new MyContainer();

        container.Dict[1] = "One";
        container.Dict[2] = "Two";
        container.Dict[3] = "Three";

        var bin = MemoryPackSerializer.Serialize(container);
        var val = MemoryPackSerializer.Deserialize<MyContainer>(bin);

        Assert.AreEqual(val.Dict.Count, 3);
        Assert.AreEqual(val.Dict[1], "One");
        Assert.AreEqual(val.Dict[2], "Two");
        Assert.AreEqual(val.Dict[3], "Three");
    }

    [Test]
    public void List()
    {
        var container = new MyContainer2();

        container.List.Add(1);
        container.List.Add(2);
        container.List.Add(3);

        var bin = MemoryPackSerializer.Serialize(container);
        var val = MemoryPackSerializer.Deserialize<MyContainer2>(bin);

        Assert.AreEqual(val.List.Count, 3);
        Assert.AreEqual(val.List[0], 1);
        Assert.AreEqual(val.List[1], 2);
        Assert.AreEqual(val.List[2], 3);
    }

    [Test]
    public void Set()
    {
        var container = new MyContainer3();

        container.Set.Add(1);
        container.Set.Add(2);
        container.Set.Add(3);

        var bin = MemoryPackSerializer.Serialize(container);
        var val = MemoryPackSerializer.Deserialize<MyContainer3>(bin);

        Assert.AreEqual(val.Set.Count, 3);
        Assert.AreEqual(val.Set.Contains(1), true);
        Assert.AreEqual(val.Set.Contains(2), true);
        Assert.AreEqual(val.Set.Contains(3), true);
    }

    [Test]
    public void CheckIsRegistered()
    {
        //if (!MemoryPackFormatterProvider.IsRegistered<KeyValuePair<int, string>>())
        //{
        //    var f = new KeyValuePairFormatter<int, string>();
        //    var bufferWriter = new NullBufferWriter();
        //    var writer = new MemoryPackWriter<NullBufferWriter>(ref bufferWriter, MemoryPackSerializeOptions.Default);
        //    var value = default(KeyValuePair<int, string>);
        //    f.Serialize(ref writer, ref value);
        //}

        //var isRegistered = MemoryPackFormatterProvider.IsRegistered<KeyValuePair<int, string>>();
        //UnityEngine.Debug.Log("KVP<int,string> is registered?: " + isRegistered);
        //var f = MemoryPackFormatterProvider.GetFormatter<KeyValuePair<int, string>>();
        //UnityEngine.Debug.Log("f is not null: " + (f != null));

        ////var array = new ArrayBufferWriter<byte>();
        ////var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref array, MemoryPackSerializeOptions.Default);

        ////f.Serialize(ref writer, ref kvp);


        //var kvp = new KeyValuePair<int, string>(1, "One");
        // この行を入れると動く
        //MemoryPackSerializer.Serialize(kvp);
    }
}

sealed class NullBufferWriter : IBufferWriter<byte>
{
    byte[] dummyBuffer;

    public void Advance(int count)
    {
    }

    public Memory<byte> GetMemory(int sizeHint = 0)
    {
        if (dummyBuffer == null || dummyBuffer.Length < sizeHint)
        {
            dummyBuffer = new byte[sizeHint];
        }
        return dummyBuffer;
    }

    public Span<byte> GetSpan(int sizeHint = 0)
    {
        return GetMemory(sizeHint).Span;
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/AotTest.cs.meta
================================================
fileFormatVersion: 2
guid: 25b768c0f9017c24393e5e460eec674d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/BuiltinTest.cs
================================================
﻿using MemoryPack;
using MemoryPack.Formatters;
using MemoryPack.Tests.Models;
using Models;
using NUnit.Framework;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.TestTools;

public class BuiltinTest
{
    private T Convert<T>(T value)
    {
        return MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value));
    }

    private void ConvertEqual<T>(T value)
    {
        var v = MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value));
        Assert.AreEqual(value, v);
    }

    private void ConvertCollectionEqual<T>(T[] value)
    {
        var v = MemoryPackSerializer.Deserialize<T[]>(MemoryPackSerializer.Serialize(value));
        CollectionAssert.AreEqual(value, v);
    }

    [Test]
    public void Primitive()
    {
        var bin = MemoryPackSerializer.Serialize(100);
        var v = MemoryPackSerializer.Deserialize<int>(bin);
        Debug.Log("100 is ok: " + v);
    }

    [Test]
    public void StringArray()
    {
        var bin = MemoryPackSerializer.Serialize(new[] { "foo", "bar", "あいうえお" });
        var v = MemoryPackSerializer.Deserialize<string[]>(bin);
        Debug.Log("foo bar あいうえお is ok: " + string.Join(" ", v));
    }

    [Test]
    public void SerializeSimpleClass()
    {
        var bin = MemoryPackSerializer.Serialize(new Takoyaki { MyProperty = 9999 });
        Debug.Log("Payload size:" + bin.Length);
        var v2 = MemoryPackSerializer.Deserialize<Takoyaki>(bin);
        Debug.Log("OK Deserialzie:" + v2.MyProperty);
    }

    [Test]
    public void SerializeVersionTolerant()
    {
        var bin = MemoryPackSerializer.Serialize(new VersionTolerant3 { MyProperty1 = 9999, MyProperty2 = 3, MyProperty3 = 99 });
        Debug.Log("Payload size:" + bin.Length);
        var v2 = MemoryPackSerializer.Deserialize<VersionTolerant3>(bin);
        Debug.Log("OK Deserialzie:" + (v2.MyProperty1, v2.MyProperty2, v2.MyProperty3));
    }

    [Test]
    public void ArrayCheckd()
    {
        var bin = MemoryPackSerializer.Serialize(new[] { new Takoyaki { MyProperty = 9999 } });
        Debug.Log("Payload size:" + bin.Length);
        var v2 = MemoryPackSerializer.Deserialize<Takoyaki[]>(bin);
        Debug.Log("OK Deserialzie:" + v2[0].MyProperty);
    }

    [Test]
    public void TupleT()
    {
        _ = new TupleFormatter<int>();
        _ = new TupleFormatter<int, int>();
        _ = new TupleFormatter<int, int, int>();
        _ = new TupleFormatter<int, int, int, int>();
        _ = new TupleFormatter<int, int, int, int, int>();
        _ = new TupleFormatter<int, int, int, int, int, int>();
        _ = new TupleFormatter<int, int, int, int, int, int, int>();
        _ = new TupleFormatter<int, int, int, int, int, int, int, int>();

        ConvertEqual(Tuple.Create(1));
        ConvertEqual(Tuple.Create(1, 2));
        ConvertEqual(Tuple.Create(1, 2, 3));
        ConvertEqual(Tuple.Create(1, 2, 3, 4));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6, 7));
        // ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6, 7, 8));
    }

    [Test]
    public void ValueTupleT()
    {
        _ = new ValueTupleFormatter<int>();
        _ = new ValueTupleFormatter<int, int>();
        _ = new ValueTupleFormatter<int, int, int>();
        _ = new ValueTupleFormatter<int, int, int, int>();
        _ = new ValueTupleFormatter<int, int, int, int, int>();
        _ = new ValueTupleFormatter<int, int, int, int, int, int>();
        _ = new ValueTupleFormatter<int, int, int, int, int, int, int>();
        //_ = new ValueTupleFormatter<int, int, int, int, int, int, int, int>();

        ConvertEqual(ValueTuple.Create(1));
        ConvertEqual(ValueTuple.Create(1, 2));
        ConvertEqual(ValueTuple.Create(1, 2, 3));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6, 7));
        // ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6, 7, 8));
    }

    [Test]
    public void EnumTes()
    {
        ConvertEqual(BEnum.B);
        ConvertEqual(NormalEnum.A);
        ConvertEqual(NotNotEnum.C);
    }

    public enum BEnum : byte
    {
        A, B, C
    }
    public enum NormalEnum
    {
        A, B, C
    }

    public enum NotNotEnum : long
    {
        A, B, C
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/BuiltinTest.cs.meta
================================================
fileFormatVersion: 2
guid: add625a9eb15c7c4ca54ea6b0cca1cc7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects.meta
================================================
fileFormatVersion: 2
guid: 69431390e740d0646b3aa1e8d607b6eb
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/PerfTest.cs
================================================
﻿using MemoryPack;
using MemoryPack.Tests.Models;
using NUnit.Framework;
using Unity.PerformanceTesting;
using UnityEngine;

public class PerfTest
{
    Person person;
    Primitives primitives;
    NestCase nestCase;

    string personJson;
    string primitivesJson;
    string nestCaseJson;

    byte[] personMempack;
    byte[] primitivesMempack;
    byte[] nestCaseMempack;

    public PerfTest()
    {
        person = new Person { Age = 888, Name = "aaaaaaaaa" };
        primitives = new Primitives()
        {
            Bool = false,
            Byte = 12,
            Char = 'z',
            Double = 1231.214,
            Float = 314.532f,
            Int = 9999,
            Long = 99999999,
            Short = 12,
            String = "hogemogehugahuga"
        };

        var inner = new Inner { Int = 9999999, String = "hogemoge", Double = 1321.2 };
        nestCase = new NestCase
        {
            A = inner,
            B = inner,
            C = inner,
            D = inner,
            E = inner,
            F = inner,
            G = inner,
            H = inner,
            I = inner,
        };

        personJson = JsonUtility.ToJson(person);
        primitivesJson = JsonUtility.ToJson(primitives);
        nestCaseJson = JsonUtility.ToJson(nestCase);

        personMempack = MemoryPackSerializer.Serialize(person);
        primitivesMempack = MemoryPackSerializer.Serialize(primitives);
        nestCaseMempack = MemoryPackSerializer.Serialize(nestCase);

        Debug.Log(JsonUtility.FromJson<Person>(personJson).Name == person.Name);
        Debug.Log(JsonUtility.FromJson<Primitives>(primitivesJson).Short == primitives.Short);
        Debug.Log(JsonUtility.FromJson<NestCase>(nestCaseJson).E.Double == nestCase.E.Double);

        Debug.Log(MemoryPackSerializer.Deserialize<Person>(personMempack).Name == person.Name);
        Debug.Log(MemoryPackSerializer.Deserialize<Primitives>(primitivesMempack).Short == primitives.Short);
        Debug.Log(MemoryPackSerializer.Deserialize<NestCase>(nestCaseMempack).E.Double == nestCase.E.Double);
    }

    [Test, Performance]
    public void Serialize_Person_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.ToJson(person);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Serialize_Primitives_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.ToJson(primitives);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Serialize_Nestcase_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.ToJson(nestCase);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Serialize_Person_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Serialize(person);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Serialize_Primitives_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Serialize(primitives);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Serialize_Nestcase_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Serialize(nestCase);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    //



    [Test, Performance]
    public void Deserialize_Person_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.FromJson<Person>(personJson);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Deserialize_Primitives_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.FromJson<Primitives>(primitivesJson);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Deserialize_Nestcase_JsonUtility()
    {
        Measure.Method(() =>
        {
            JsonUtility.FromJson<NestCase>(nestCaseJson);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Deserialize_Person_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Deserialize<Person>(personMempack);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Deserialize_Primitives_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Deserialize<Primitives>(primitivesMempack);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }

    [Test, Performance]
    public void Deserialize_Nestcase_MemoryPack()
    {
        Measure.Method(() =>
        {
            MemoryPackSerializer.Deserialize<NestCase>(nestCaseMempack);
        })
        .WarmupCount(10)
        .IterationsPerMeasurement(10000)
        .MeasurementCount(10)
        .Run();
    }
}




================================================
FILE: src/MemoryPack.Unity/Assets/Tests/PerfTest.cs.meta
================================================
fileFormatVersion: 2
guid: cb85405cc6388ed4787dca22cd5197c3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/SampleOne.cs
================================================
﻿using MemoryPack;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SampleOne : MonoBehaviour
{
    void Start()
    {
        var bin = MemoryPackSerializer.Serialize(new MyPerson { Age = 9999, Name = "hogemogeふがふが" });
        Debug.Log("Payload size:" + bin.Length);
        var v2 = MemoryPackSerializer.Deserialize<MyPerson>(bin);
        Debug.Log("OK Deserialzie:" + v2.Age + ":" + v2.Name);
    }
}

[MemoryPackable]
public partial class MyPerson
{
    public int Age { get; set; }
    public string Name { get; set; }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/SampleOne.cs.meta
================================================
fileFormatVersion: 2
guid: 504f6db822cebea42af99779a86d893d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/Tests.asmdef
================================================
{
    "name": "Tests",
    "rootNamespace": "",
    "references": [
        "UnityEngine.TestRunner",
        "UnityEditor.TestRunner",
        "MemoryPack",
        "MemoryPackObjects",
        "Unity.PerformanceTesting"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": true,
    "precompiledReferences": [
        "nunit.framework.dll",
        "MemoryPack.Core.dll"
    ],
    "autoReferenced": false,
    "defineConstraints": [
        "UNITY_INCLUDE_TESTS"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MemoryPack.Unity/Assets/Tests/Tests.asmdef.meta
================================================
fileFormatVersion: 2
guid: 8523c8951da01234897c3a4fd579a47d
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/UnityPrimitivesTest.cs
================================================
﻿using Assets.Scripts.MemoryPackObjects;
using MemoryPack;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Assets.Tests
{
    public class UnityPrimitivesTest
    {
        private T Convert<T>(T value)
        {
            return MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value));
        }

        private void ConvertEqual<T>(T value)
        {
            var v = MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value));
            Assert.AreEqual(value, v);
        }

        private void ConvertCollectionEqual<T>(T[] value)
        {
            var v = MemoryPackSerializer.Deserialize<T[]>(MemoryPackSerializer.Serialize(value));
            CollectionAssert.AreEqual(value, v);
        }

        [Test]
        public void Vector()
        {
            var v3 = new Vector3(10.2f, 12.34f, 1.9f);
            ConvertEqual(v3);

            var v3Array = new[]{
                new Vector3(10.2f, 12.34f, 1.9f),
                new Vector3(30.2f, 11.34f, 10.9f),
                new Vector3(980.2f, 1231.34f, 4.9f)
            };
            ConvertCollectionEqual(v3Array);

            var vv = new Vector3ArrayValue()
            {
                Array = v3Array
            };

            var vv2 = Convert(vv);
            CollectionAssert.AreEqual(vv2.Array, vv.Array);
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/UnityPrimitivesTest.cs.meta
================================================
fileFormatVersion: 2
guid: 82ec7bb402842784fb4cee9b8ab38afe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Containers.cs
================================================
﻿using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Models
{
    [MemoryPackable]
    public partial class MyContainer
    {
        public Dictionary<int, string> Dict = new();
    }

    [MemoryPackable]
    public partial class MyContainer2
    {
        public List<int> List = new();
    }

    [MemoryPackable]
    public partial class MyContainer3
    {
        public HashSet<long> Set = new();
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Containers.cs.meta
================================================
fileFormatVersion: 2
guid: 1a4d05f79da8b1646b2f61351b7f025a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Ctors.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial class NoCtor
    {
        public int X { get; set; }
    }

    [MemoryPackable]
    public partial class OneCtor
    {
        public int X { get; set; }


        public OneCtor()
        {

        }
    }

    [MemoryPackable]
    public partial class OneCtor2
    {
        public int X { get; }
        public int Y { get; }

        public OneCtor2(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }
    }

    //[MemoryPackable]
    //public partial class TwoCtor
    //{
    //    public TwoCtor()
    //    {

    //    }

    //    public TwoCtor(int x, int y)
    //    {

    //    }
    //}

    [MemoryPackable]
    public partial class ExplicitlyCtor
    {
        public int X { get; }
        public int Y { get; set; }

        public ExplicitlyCtor()
        {

        }

        [MemoryPackConstructor]
        public ExplicitlyCtor(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }
    }



    //[MemoryPackable]
    //public partial class MultipleExplicitlyCtor
    //{
    //    [MemoryPackConstructor]
    //    public MultipleExplicitlyCtor()
    //    {

    //    }

    //    [MemoryPackConstructor]
    //    public MultipleExplicitlyCtor(int x, int y)
    //    {

    //    }
    //}


    [MemoryPackable]
    public partial class ParameterCheck
    {
        bool prop1SetCalled;

        string mp;
        public string MyProperty1
        {
            get { return mp; }
            set
            {
                mp = value;
                prop1SetCalled = true;
            }
        }
        public string? MyProperty2;

        public ParameterCheck(string myProperty1)
        {
            this.mp = myProperty1;
        }

        public bool IsProp1SetCalled()
        {
            return prop1SetCalled;
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Ctors.cs.meta
================================================
fileFormatVersion: 2
guid: 4b67d6e8f8e9b2b47bb50fc03b4cc78a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/GenericsType.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial class GenericsType<T>
    {
        public int MyProperty1 { get; set; }
        public T? MyProperty2 { get; set; }
    }


    [MemoryPackable]
    public partial class MoreComplecsGenerics<T1, T2>
        where T1 : notnull
    {
        public Dictionary<T1, GenericsType<T2>>? Dict { get; set; }
    }

    // Union

    [MemoryPackable]
    [MemoryPackUnion(0, typeof(GenricUnionA<>))]
    [MemoryPackUnion(1, typeof(GenricUnionB<>))]
    public partial interface IGenericUnion<ToaruHoge>
    {
        ToaruHoge? Value { get; set; }
    }


    [MemoryPackable]
    public partial class GenricUnionA<T> : IGenericUnion<T>
    {
        public T? Value { get; set; }
        public int MyProperty { get; set; }
    }

    [MemoryPackable]
    public partial class GenricUnionB<T> : IGenericUnion<T>
    {
        public T? Value { get; set; }
        public double MyProperty { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/GenericsType.cs.meta
================================================
fileFormatVersion: 2
guid: b16041e7d46169f4f842325a358cd365
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Include.cs
================================================
﻿#pragma warning disable IDE0044 // Add readonly modifier
#pragma warning disable IDE0051 // Remove unused private members
#pragma warning disable CS0169
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class Include
    {
        public int PublicProp { get; set; }
        public int PublicField;

        [MemoryPackIgnore]
        public string? NoInclude { get; set; }

        public string? PrivateSet { get; private set; }
        public string? PrivateGet { private get; set; }

        [MemoryPackInclude]
        private string? PrivateProp { get; set; }
        [MemoryPackInclude]
        private int PrivateField;

        public void SetAll(int publicProp, int publicFIeld, string privateSet, string privateGet, string privateProp, int privateField)
        {
            this.PublicProp = publicProp;
            this.PublicField = publicFIeld;
            this.PrivateSet = privateSet;
            this.PrivateGet = privateGet;
            this.PrivateProp = privateProp;
            this.PrivateField = privateField;
        }

        public (int, int, string?, string?, string?, int) GetAll()
        {
            return (PublicProp, PublicField, PrivateSet, PrivateGet, PrivateProp, PrivateField);
        }
    }

    [MemoryPackable]
    public partial class NoInclude
    {
        public int PublicProp { get; set; }
        public int PublicField;

        public string? PrivateSet { get; private set; }
        public string? PrivateGet { private get; set; }

        private string? PrivateProp { get; set; }
        private int PrivateField;

        public void SetAll(int publicProp, int publicFIeld, string privateSet, string privateGet, string privateProp, int privateField)
        {
            this.PublicProp = publicProp;
            this.PublicField = publicFIeld;
            this.PrivateSet = privateSet;
            this.PrivateGet = privateGet;
            this.PrivateProp = privateProp;
            this.PrivateField = privateField;
        }

        public (int, int, string?, string?, string?, int) GetAll()
        {
            return (PublicProp, PublicField, PrivateSet, PrivateGet, PrivateProp, PrivateField);
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Include.cs.meta
================================================
fileFormatVersion: 2
guid: 2402759b151ca95478d9b1177f587593
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Issues.cs
================================================
﻿using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Assets.Scripts.MemoryPackObjects
{
    public struct float2 { }
    public struct quaternion { }

    [Serializable]
    [MemoryPackable]
    public partial class PlayerInput
    {
        public float2 move;
        public quaternion target;
        public List<KeyRecord> keyRecords = new();
    }

    public enum EAction : byte
    {
        Ability1,
        Ability2,
        Ability3,
        Ability4,
        Ability5,
        Ability6,
    }

    public enum EActionStatus : byte
    {
        KeyDown = 0,
        keyPressing = 1,
        KeyUp = 2,
    }

    [MemoryPackable]
    public partial struct KeyRecord
    {
        public EAction action;
        public EActionStatus status;
    }

}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Issues.cs.meta
================================================
fileFormatVersion: 2
guid: 8d490f9903377a24598f2aa9672e7e2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/ManyMembers.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class ManyMembers
    {
        public int MyProperty1;
        public int MyProperty2;
        public int MyProperty3;
        public int MyProperty4;
        public int MyProperty5;
        public int MyProperty6;
        public int MyProperty7;
        public int MyProperty8;
        public int MyProperty9;
        public int MyProperty10;
        public int MyProperty11;
        public int MyProperty12;
        public int MyProperty13;
        public int MyProperty14;
        public int MyProperty15;
        public int MyProperty16;
        public int MyProperty17;
        public int MyProperty18;
        public int MyProperty19;
        public int MyProperty20;
        public int MyProperty21;
        public int MyProperty22;
        public int MyProperty23;
        public int MyProperty24;
        public int MyProperty25;
        public int MyProperty26;
        public int MyProperty27;
        public int MyProperty28;
        public int MyProperty29;
        public int MyProperty30;
        public int MyProperty31;
        public int MyProperty32;
        public int MyProperty33;
        public int MyProperty34;
        public int MyProperty35;
        public int MyProperty36;
        public int MyProperty37;
        public int MyProperty38;
        public int MyProperty39;
        public int MyProperty40;
        public int MyProperty41;
        public int MyProperty42;
        public int MyProperty43;
        public int MyProperty44;
        public int MyProperty45;
        public int MyProperty46;
        public int MyProperty47;
        public int MyProperty48;
        public int MyProperty49;
        public int MyProperty50;
        public int MyProperty51;
        public int MyProperty52;
        public int MyProperty53;
        public int MyProperty54;
        public int MyProperty55;
        public int MyProperty56;
        public int MyProperty57;
        public int MyProperty58;
        public int MyProperty59;
        public int MyProperty60;
        public int MyProperty61;
        public int MyProperty62;
        public int MyProperty63;
        public int MyProperty64;
        public int MyProperty65;
        public int MyProperty66;
        public int MyProperty67;
        public int MyProperty68;
        public int MyProperty69;
        public int MyProperty70;
        public int MyProperty71;
        public int MyProperty72;
        public int MyProperty73;
        public int MyProperty74;
        public int MyProperty75;
        public int MyProperty76;
        public int MyProperty77;
        public int MyProperty78;
        public int MyProperty79;
        public int MyProperty80;
        public int MyProperty81;
        public int MyProperty82;
        public int MyProperty83;
        public int MyProperty84;
        public int MyProperty85;
        public int MyProperty86;
        public int MyProperty87;
        public int MyProperty88;
        public int MyProperty89;
        public int MyProperty90;
        public int MyProperty91;
        public int MyProperty92;
        public int MyProperty93;
        public int MyProperty94;
        public int MyProperty95;
        public int MyProperty96;
        public int MyProperty97;
        public int MyProperty98;
        public int MyProperty99;
        public int MyProperty100;
        public int MyProperty101;
        public int MyProperty102;
        public int MyProperty103;
        public int MyProperty104;
        public int MyProperty105;
        public int MyProperty106;
        public int MyProperty107;
        public int MyProperty108;
        public int MyProperty109;
        public int MyProperty110;
        public int MyProperty111;
        public int MyProperty112;
        public int MyProperty113;
        public int MyProperty114;
        public int MyProperty115;
        public int MyProperty116;
        public int MyProperty117;
        public int MyProperty118;
        public int MyProperty119;
        public int MyProperty120;
        public int MyProperty121;
        public int MyProperty122;
        public int MyProperty123;
        public int MyProperty124;
        public int MyProperty125;
        public int MyProperty126;
        public int MyProperty127;
        public int MyProperty128;
        public int MyProperty129;
        public int MyProperty130;
        public int MyProperty131;
        public int MyProperty132;
        public int MyProperty133;
        public int MyProperty134;
        public int MyProperty135;
        public int MyProperty136;
        public int MyProperty137;
        public int MyProperty138;
        public int MyProperty139;
        public int MyProperty140;
        public int MyProperty141;
        public int MyProperty142;
        public int MyProperty143;
        public int MyProperty144;
        public int MyProperty145;
        public int MyProperty146;
        public int MyProperty147;
        public int MyProperty148;
        public int MyProperty149;
        public int MyProperty150;
        public int MyProperty151;
        public int MyProperty152;
        public int MyProperty153;
        public int MyProperty154;
        public int MyProperty155;
        public int MyProperty156;
        public int MyProperty157;
        public int MyProperty158;
        public int MyProperty159;
        public int MyProperty160;
        public int MyProperty161;
        public int MyProperty162;
        public int MyProperty163;
        public int MyProperty164;
        public int MyProperty165;
        public int MyProperty166;
        public int MyProperty167;
        public int MyProperty168;
        public int MyProperty169;
        public int MyProperty170;
        public int MyProperty171;
        public int MyProperty172;
        public int MyProperty173;
        public int MyProperty174;
        public int MyProperty175;
        public int MyProperty176;
        public int MyProperty177;
        public int MyProperty178;
        public int MyProperty179;
        public int MyProperty180;
        public int MyProperty181;
        public int MyProperty182;
        public int MyProperty183;
        public int MyProperty184;
        public int MyProperty185;
        public int MyProperty186;
        public int MyProperty187;
        public int MyProperty188;
        public int MyProperty189;
        public int MyProperty190;
        public int MyProperty191;
        public int MyProperty192;
        public int MyProperty193;
        public int MyProperty194;
        public int MyProperty195;
        public int MyProperty196;
        public int MyProperty197;
        public int MyProperty198;
        public int MyProperty199;
        public int MyProperty200;
        public int MyProperty201;
        public int MyProperty202;
        public int MyProperty203;
        public int MyProperty204;
        public int MyProperty205;
        public int MyProperty206;
        public int MyProperty207;
        public int MyProperty208;
        public int MyProperty209;
        public int MyProperty210;
        public int MyProperty211;
        public int MyProperty212;
        public int MyProperty213;
        public int MyProperty214;
        public int MyProperty215;
        public int MyProperty216;
        public int MyProperty217;
        public int MyProperty218;
        public int MyProperty219;
        public int MyProperty220;
        public int MyProperty221;
        public int MyProperty222;
        public int MyProperty223;
        public int MyProperty224;
        public int MyProperty225;
        public int MyProperty226;
        public int MyProperty227;
        public int MyProperty228;
        public int MyProperty229;
        public int MyProperty230;
        public int MyProperty231;
        public int MyProperty232;
        public int MyProperty233;
        public int MyProperty234;
        public int MyProperty235;
        public int MyProperty236;
        public int MyProperty237;
        public int MyProperty238;
        public int MyProperty239;
        public int MyProperty240;
        public int MyProperty241;
        public int MyProperty242;
        public int MyProperty243;
        public int MyProperty244;
        public int MyProperty245;
        public int MyProperty246;
        public int MyProperty247;
        public int MyProperty248;
        public int MyProperty249;
        //public int MyProperty250;
        //public int MyProperty251;
    }

}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/ManyMembers.cs.meta
================================================
fileFormatVersion: 2
guid: 3cd954e2c35c89940859192387263747
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MemberKinds.cs
================================================
﻿#nullable enable
#pragma warning disable CS0649

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial class MemberKindsAllUnmanaged
    {
        public int A; // public field
        [MemoryPackInclude]
        private int B; // private field
        public readonly int C; // public readonly field
        [MemoryPackInclude]
        private readonly int D; // readonly field

        public int E { get; set; } // public property
        public int F { private get; set; } // private get
        public int G { get; private set; } // private set
        [MemoryPackInclude]
        private int H { get; set; } // private property

        int i;
        public int I1 => i; // get only
        public int I2 { set { i = value; } } // set only

        int j;
        [MemoryPackInclude]
        private int J1 => j; // private get only
        [MemoryPackInclude]
        private int J2 { set { j = value; } } // private set only

        int[] kArray = new int[1];

        public MemberKindsAllUnmanaged(int c, int d)
        {
            this.C = c;
            this.D = d;
        }

        public ref int K
        {
            get { return ref kArray[0]; }
        }

        public void SetH(int h)
        {
            this.H = h;
        }

        public int GetH()
        {
            return H;
        }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MemberKinds.cs.meta
================================================
fileFormatVersion: 2
guid: beabc933d1d942d49a0889a116681555
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MemoryPackObjects.asmdef
================================================
{
    "name": "MemoryPackObjects",
    "rootNamespace": "",
    "references": [
        "GUID:756335c0388f7114790e504ed368ae1d"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MemoryPackObjects.asmdef.meta
================================================
fileFormatVersion: 2
guid: 8c1b41d592f8f0444841f0ee638f0ae6
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MethodCall.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial class MethodCall
    {
        public static List<string> Log { get; } = new List<string>();

        int mp;
        public int MyProperty
        {
            get
            {
                Log.Add("Get");
                return mp;
            }
            set
            {
                Log.Add("Set");
                mp = value;
            }
        }

        public MethodCall()
        {
            Log.Add("Constructor");
        }

        [MemoryPackOnSerializing]
        public static void OnSerializing1()
        {
            Log.Add(nameof(OnSerializing1));
        }

        // check allow private.
        [MemoryPackOnSerializing]
        void OnSerializing2()
        {
            Log.Add(nameof(OnSerializing2));
        }


        [MemoryPackOnSerialized]
        static void OnSerialized1()
        {
            Log.Add(nameof(OnSerialized1));
        }

        [MemoryPackOnSerialized]
        public void OnSerialized2()
        {
            Log.Add(nameof(OnSerialized2));
        }

        [MemoryPackOnDeserializing]
        public static void OnDeserializing1()
        {
            Log.Add(nameof(OnDeserializing1));
        }

        [MemoryPackOnDeserializing]
        public void OnDeserializing2()
        {
            Log.Add(nameof(OnDeserializing2));
        }

        [MemoryPackOnDeserialized]
        public static void OnDeserialized1()
        {
            Log.Add(nameof(OnDeserialized1));
        }

        [MemoryPackOnDeserialized]
        public void OnDeserialized2()
        {
            Log.Add(nameof(OnDeserialized2));
        }

        // not allow parameter exists.

        //[MemoryPackOnSerialized]
        //public void InvalidMethodThatHasParameter(int x)
        //{
        //}
    }


    // unmanaged type can't add attributes.
    //[MemoryPackable]
    //public partial struct UnmanagedStructMethod
    //{
    //    public int X;

    //    [MemoryPackOnSerialized]
    //    public void Foo()
    //    {
    //    }
    //}
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/MethodCall.cs.meta
================================================
fileFormatVersion: 2
guid: a621c0b9a89e3de468dbc84bc0755276
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Overwrite.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class Overwrite
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
        public String? MyProperty3 { get; set; }
        public string? MyProperty4 { get; set; }
    }

    [MemoryPackable]
    public partial struct Overwrite2
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
        public String? MyProperty3 { get; set; }
        public string? MyProperty4 { get; set; }
    }


    [MemoryPackable]
    public partial class Overwrite3
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
        public String? MyProperty3 { get; set; }
        public string? MyProperty4 { get; set; }

        public Overwrite3(int myProperty1, int myProperty2)
        {
            this.MyProperty1 = myProperty1;
            this.MyProperty2 = myProperty2;
        }
    }

    [MemoryPackable]
    public partial class Overwrite4
    {
        public int MyProperty1 { get; set; }
        public Overwrite? MyProperty2 { get; set; }
        public List<int>? MyProperty3 { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Overwrite.cs.meta
================================================
fileFormatVersion: 2
guid: 889a6bf82332ec84ba623ca32e565135
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Perf.cs
================================================
﻿using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    [Serializable]
    public partial class Person
    {
        public int Age;
        public string Name;
    }

    [MemoryPackable]
    [Serializable]
    public partial class Primitives
    {
        public short Short;
        public int Int;
        public long Long;
        public byte Byte;
        public bool Bool;
        public char Char;
        public float Float;
        public double Double;
        public string String;
    }

    [MemoryPackable]
    [Serializable]
    public partial class NestCase
    {

        public Inner A;
        public Inner B;
        public Inner C;
        public Inner D;
        public Inner E;
        public Inner F;
        public Inner G;
        public Inner H;
        public Inner I;
    }

    [MemoryPackable]
    [Serializable]
    public partial class Inner
    {
        public int Int;
        public double Double;
        public string String;
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Perf.cs.meta
================================================
fileFormatVersion: 2
guid: 910d527ddda885349bb8ae3d85d0e421
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/PrimitiveArrays.cs
================================================
﻿using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Text;
using System.Threading.Tasks;

namespace Assets.Scripts.MemoryPackObjects
{
    [MemoryPackable]
    public partial class Vector3ArrayValue
    {
        public Vector3[] Array { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/PrimitiveArrays.cs.meta
================================================
fileFormatVersion: 2
guid: 4bd8bf6bb84e05e48816db6f9d20821b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Records.cs
================================================
﻿#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial struct UnmanagedStruct
    {
        public int X;
        public int Y;
        public int Z;
    }

    [MemoryPackable]
    public partial struct IncludesReferenceStruct
    {
        public int X;
        public string? Y;
    }

#if NET7_0_OR_GREATER

[MemoryPackable]
public partial class RequiredType
{
    public required int MyProperty1 { get; set; }
    public required string MyProperty2 { get; set; }
}

[MemoryPackable]
public partial struct RequiredType2
{
    public required int MyProperty1 { get; set; }
    public required string MyProperty2 { get; set; }

    public void F()
    {
        // new MyRecord()
    }
}

#endif

    [MemoryPackable]
    public partial struct StructWithConstructor1
    {
        public string MyProperty { get; set; }

        public StructWithConstructor1(string myProperty)
        {
            this.MyProperty = myProperty;
        }
    }

    //[MemoryPackable]
    //public partial record MyRecord(int foo, int bar, string baz);

    //[MemoryPackable]
    //public partial record struct StructRecordUnmanaged(int foo, int bar);


    //[MemoryPackable]
    //public partial record struct StructRecordWithReference(int foo, string bar);
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Records.cs.meta
================================================
fileFormatVersion: 2
guid: ed2e26fa292ab2f40b6044c7d90a7b4a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Recursive.cs
================================================
﻿#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class Recursive
    {
        public int MyProperty { get; set; }
        public Recursive? Rec { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Recursive.cs.meta
================================================
fileFormatVersion: 2
guid: b85f52988d5687d43b66b8da8791b05a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/StandardType.cs
================================================
﻿#nullable enable
using MemoryPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// namespaced
namespace MemoryPack.Tests.Models
{
    // MEMPACK001 must be partial
    // [MemoryPackable]
    //public class Ng
    //{

    //}

    [MemoryPackable]
    public partial class StandardTypeZero
    {
    }

    [MemoryPackable]
    public partial class StandardTypeOne
    {
        public int One { get; set; }
    }


    [MemoryPackable]
    public partial class StandardTypeTwo
    {
        public int One { get; set; }
        public int Two { get; set; }

        public StandardTypeTwo()
        {
            // _ = new StandardTypeTwoFormatter();
        }

        // MEMPACK002 nested is not allowed
        //[MemoryPackable]
        //public partial class Nested
        //{
        //    public int One { get; set; }
        //}
    }

    [MemoryPackable]
    public partial struct StandardUnmanagedStruct
    {
        public int MyProperty { get; set; }
    }

    [MemoryPackable]
    public partial struct StandardStruct
    {
        public string MyProperty { get; set; }

        //public StandardStruct()
        //{
        //    MyProperty = default!;
        //}
    }

}

// another namespace, same type name
namespace MemoryPack.Tests.Models.More
{

    [MemoryPackable]
    public partial class StandardTypeTwo
    {
        public string? One { get; set; }
        public string? Two { get; set; }

        public StandardTypeTwo()
        {
            // new StandardTypeTwoFormatter();
        }
    }
}

[MemoryPackable]
public partial class GlobalNamespaceType
{
    public int MyProperty { get; set; }

    public GlobalNamespaceType()
    {
        // _ = new GlobalNamespaceTypeFormatter();
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/StandardType.cs.meta
================================================
fileFormatVersion: 2
guid: aed61abe6d946634da5f6f9919049277
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Takoyaki.cs
================================================
﻿#nullable enable
using MemoryPack;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Models
{
    [MemoryPackable]
    public partial class Takoyaki
    {
        public int MyProperty { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Takoyaki.cs.meta
================================================
fileFormatVersion: 2
guid: 0048565f26e942d4aaeb56e5fb2a4898
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Union.cs
================================================
﻿#nullable enable
// using Microsoft.CodeAnalysis.Operations;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    [MemoryPackable]
    public partial class StandardBase
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
    }

    [MemoryPackable]
    public partial class Derived1 : StandardBase
    {
        public int DerivedProp1 { get; set; }
        public int DerivedProp2 { get; set; }
    }

    [MemoryPackable]
    public partial class Derived2 : Derived1
    {
        public int Derived2Prop1 { get; set; }
        public int Derived2Prop2 { get; set; }
    }


    [MemoryPackable]
    [MemoryPackUnion(0, typeof(Impl1))]
    [MemoryPackUnion(1, typeof(Impl2))]
    public partial interface IUnionInterface
    {
        int MyProperty { get; }
    }

    [MemoryPackable]
    public partial class Impl1 : IUnionInterface
    {
        public int MyProperty { get; set; }
        public long Foo { get; set; }
    }

    [MemoryPackable]
    public partial class Impl2 : IUnionInterface
    {
        public int MyProperty { get; set; }
        public string? Bar { get; set; }
    }

    [MemoryPackable]
    [MemoryPackUnion(0, typeof(ImplA1))]
    [MemoryPackUnion(1, typeof(ImplA2))]
    public abstract partial class UnionAbstractClass
    {
        public virtual int MyProperty { get; set; }
    }

    [MemoryPackable]
    public partial class ImplA1 : UnionAbstractClass
    {
        public override int MyProperty { get; set; }
        public long Foo { get; set; }
    }

    [MemoryPackable]
    public partial class ImplA2 : UnionAbstractClass
    {
        public override int MyProperty { get; set; }
        public string? Bar { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Union.cs.meta
================================================
fileFormatVersion: 2
guid: e5daf3a97c80527478bb84831d7ee420
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Versioned.cs
================================================
﻿#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class VTWrapper<T>
    {
        public T? Versioned { get; set; }
        public int[]? Values { get; set; }
    }


    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant0
    {
    }

    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant1
    {
        [MemoryPackOrder(0)]
        public int MyProperty1 { get; set; } = default;
    }


    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant2
    {
        [MemoryPackOrder(0)]
        public int MyProperty1 { get; set; } = default;

        [MemoryPackOrder(1)]
        public long MyProperty2 { get; set; } = default;
    }



    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant3
    {
        [MemoryPackOrder(0)]
        public int MyProperty1 { get; set; } = default;

        [MemoryPackOrder(1)]
        public long MyProperty2 { get; set; } = default;

        [MemoryPackOrder(2)]
        public short MyProperty3 { get; set; } = default;
    }


    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant4
    {
        [MemoryPackOrder(0)]
        public int MyProperty1 { get; set; } = default;

        //[MemoryPackOrder(1)]
        //public long MyProperty2 { get; set; } = default;

        [MemoryPackOrder(2)]
        public short MyProperty3 { get; set; } = default;
    }

    [MemoryPackable(GenerateType.VersionTolerant)]
    public partial class VersionTolerant5
    {
        //[MemoryPackOrder(0)]
        //public int MyProperty1 { get; set; } = default;

        //[MemoryPackOrder(1)]
        //public long MyProperty2 { get; set; } = default;

        [MemoryPackOrder(2)]
        public short MyProperty3 { get; set; } = default;

        [MemoryPackOrder(5)]
        public string MyProperty6 { get; set; } = default!;
    }

}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Versioned.cs.meta
================================================
fileFormatVersion: 2
guid: b9b53f9ea1526d74da860065423451f9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Versioning.cs
================================================
﻿#nullable enable
//using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{
    [MemoryPackable]
    public partial class Versioning0
    {
    }

    [MemoryPackable]
    public partial class Versioning1
    {
        public int MyProperty1 { get; set; }
    }

    [MemoryPackable]
    public partial class Versioning2
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
    }

    [MemoryPackable]
    public partial class Versioning3
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
        public int MyProperty3 { get; set; }
    }

    [MemoryPackable]
    public partial class Versioning4
    {
        public int MyProperty1 { get; set; }
        public int MyProperty2 { get; set; }
        public int MyProperty3 { get; set; }
        public int MyProperty4 { get; set; }
    }

    [MemoryPackable]
    public partial class WrappedVersioning2
    {
        public string? Before { get; set; }
        public Versioning2? V2 { get; set; }
        public string? After { get; set; }
    }


    [MemoryPackable]
    public partial class WrappedVersioning4
    {
        public string? Before { get; set; }
        public Versioning4? V4 { get; set; }
        public string? After { get; set; }
    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/Versioning.cs.meta
================================================
fileFormatVersion: 2
guid: 69427bf8113081440aeb9fd95227a7b0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/WellknownTypes.cs
================================================
﻿#nullable enable
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections;
using System.Collections.Generic;
//using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models
{

    // no error generatable.
#pragma warning disable CS8618
    [MemoryPackable]
    public partial class HogeHoge
    {
        public BigInteger P1;
        public Version P2;
        public Uri P3;
        public TimeZoneInfo P4;
        public BitArray P5;
        public StringBuilder P6;
        public Type P7;
        public int[,] P8;
        public int[,,] P9;
        public int[,,,] P10;
        // generics
        public KeyValuePair<int, int> P11;
        public Lazy<int> P12;
        public Nullable<int> P13;
        // collecition
        public ArraySegment<int> P14;
        public Memory<int> P15;
        public ReadOnlyMemory<int> P16;
        public ReadOnlySequence<int> P17;

        public List<int> P18;
        public Stack<int> P19;
        public Queue<int> P20;
        public LinkedList<int> P21;
        public HashSet<int> P22;
        //public PriorityQueue<int, int> P23;
        public ObservableCollection<int> P24;
        public Collection<int> P25;
        public ConcurrentQueue<int> P26;
        public ConcurrentStack<int> P27;
        public ConcurrentBag<int> P28;
        public Dictionary<int, int> P29;
        public SortedDictionary<int, int> P30;
        public SortedList<int, int> P31;
        public ConcurrentDictionary<int, int> P32;
        public ReadOnlyCollection<int> P33;
        public ReadOnlyObservableCollection<int> P34;
        public BlockingCollection<int> P35;

        //public ImmutableArray<int> P36;
        //public ImmutableList<int> P37;
        //public ImmutableQueue<int> P38;
        //public ImmutableStack<int> P39;
        //public ImmutableDictionary<int, int> P40;
        //public ImmutableSortedDictionary<int, int> P41;
        //public ImmutableSortedSet<int> P42;
        //public ImmutableHashSet<int> P43;
        //public IImmutableList<int> P44;
        //public IImmutableQueue<int> P45;
        //public IImmutableStack<int> P46;
        //public IImmutableDictionary<int, int> P47;
        //public IImmutableSet<int> P48;
        public IEnumerable<int> P49;
        public ICollection<int> P50;
        public IReadOnlyCollection<int> P51;
        public IList<int> P52;
        public IReadOnlyList<int> P53;
        public IDictionary<int, int> P54;
        public IReadOnlyDictionary<int, int> P55;
        public ILookup<int, int> P56;
        public IGrouping<int, int> P57;
        public ISet<int> P58;
        //public IReadOnlySet<int> P59;

        // tuples
        public Tuple<int, string, int> T3;
        public ValueTuple<int, string, int> VT3;
        // more
        public Nullable<MyStruct> N1;
        public KeyValuePair<string, string> N2;

        public IUnionType? U1;
    }


    [MemoryPackable]
    public partial struct MyStruct
    {
        public string? V;
    }

    [MemoryPackUnion(0, typeof(AUnion))]
    public partial interface IUnionType
    {

    }



    [MemoryPackable]
    public partial class AUnion : IUnionType
    {

    }
}



================================================
FILE: src/MemoryPack.Unity/Assets/Tests/MemoryPackObjects/WellknownTypes.cs.meta
================================================
fileFormatVersion: 2
guid: 2f166b33c812a264e81aab631d35ccc1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/MemoryPack.Unity/Packages/manifest.json
================================================
{
  "dependencies": {
    "com.cysharp.memorypack.internal": "file:../../MemoryPack/bin/Debug/netstandard2.1",
    "com.cysharp.runtimeunittesttoolkit": "https://github.com/Cysharp/RuntimeUnitTestToolkit.git?path=RuntimeUnitTestToolkit/Assets/RuntimeUnitTestToolkit#2.6.1",
    "com.github-glitchenzo.nugetforunity": "https://github.com/GlitchEnzo/NuGetForUnity.git?path=/src/NuGetForUnity",
    "com.unity.collab-proxy": "2.4.3",
    "com.unity.ide.rider": "3.0.31",
    "com.unity.ide.visualstudio": "2.0.22",
    "com.unity.ide.vscode": "1.2.5",
    "com.unity.test-framework": "1.1.33",
    "com.unity.test-framework.performance": "2.8.1-preview",
    "com.unity.textmeshpro": "3.0.6",
    "com.unity.timeline": "1.7.6",
    "com.unity.toolchain.win-x86_64-linux-x86_64": "2.0.9",
    "com.unity.ugui": "1.0.0",
    "com.unity.modules.ai": "1.0.0",
    "com.unity.modules.androidjni": "1.0.0",
    "com.unity.modules.animation": "1.0.0",
    "com.unity.modules.assetbundle": "1.0.0",
    "com.unity.modules.audio": "1.0.0",
    "com.unity.modules.cloth": "1.0.0",
    "com.unity.modules.director": "1.0.0",
    "com.unity.modules.imageconversion": "1.0.0",
    "com.unity.modules.imgui": "1.0.0",
    "com.unity.modules.jsonserialize": "1.0.0",
    "com.unity.modules.particlesystem": "1.0.0",
    "com.unity.modules.physics": "1.0.0",
    "com.unity.modules.physics2d": "1.0.0",
    "com.unity.modules.screencapture": "1.0.0",
    "com.unity.modules.terrain": "1.0.0",
    "com.unity.modules.terrainphysics": "1.0.0",
    "com.unity.modules.tilemap": "1.0.0",
    "com.unity.modules.ui": "1.0.0",
    "com.unity.modules.uielements": "1.0.0",
    "com.unity.modules.umbra": "1.0.0",
    "com.unity.modules.unityanalytics": "1.0.0",
    "com.unity.modules.unitywebrequest": "1.0.0",
    "com.unity.modules.unitywebrequestassetbundle": "1.0.0",
    "com.unity.modules.unitywebrequestaudio": "1.0.0",
    "com.unity.modules.unitywebrequesttexture": "1.0.0",
    "com.unity.modules.unitywebrequestwww": "1.0.0",
    "com.unity.modules.vehicles": "1.0.0",
    "com.unity.modules.video": "1.0.0",
    "com.unity.modules.vr": "1.0.0",
    "com.unity.modules.wind": "1.0.0",
    "com.unity.modules.xr": "1.0.0"
  }
}



================================================
FILE: src/MemoryPack.Unity/Packages/packages-lock.json
================================================
{
  "dependencies": {
    "com.cysharp.memorypack.internal": {
      "version": "file:../../MemoryPack/bin/Debug/netstandard2.1",
      "depth": 0,
      "source": "local",
      "dependencies": {}
    },
    "com.cysharp.runtimeunittesttoolkit": {
      "version": "https://github.com/Cysharp/RuntimeUnitTestToolkit.git?path=RuntimeUnitTestToolkit/Assets/RuntimeUnitTestToolkit#2.6.1",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "eec2dd0bbf7a627cad80a529ba328585178e5747"
    },
    "com.github-glitchenzo.nugetforunity": {
      "version": "https://github.com/GlitchEnzo/NuGetForUnity.git?path=/src/NuGetForUnity",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "b93741e2b5fe9073e169853ade0039c7cf2595f0"
    },
    "com.unity.collab-proxy": {
      "version": "2.4.3",
      "depth": 0,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.ext.nunit": {
      "version": "1.0.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.rider": {
      "version": "3.0.31",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.visualstudio": {
      "version": "2.0.22",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.test-framework": "1.1.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.vscode": {
      "version": "1.2.5",
      "depth": 0,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.sysroot": {
      "version": "2.0.10",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.sysroot.linux-x86_64": {
      "version": "2.0.9",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.sysroot": "2.0.10"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.test-framework": {
      "version": "1.1.33",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.test-framework.performance": {
      "version": "2.8.1-preview",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.test-framework": "1.1.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.textmeshpro": {
      "version": "3.0.6",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ugui": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.timeline": {
      "version": "1.7.6",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.director": "1.0.0",
        "com.unity.modules.animation": "1.0.0",
        "com.unity.modules.particlesystem": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.toolchain.win-x86_64-linux-x86_64": {
      "version": "2.0.9",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.sysroot": "2.0.10",
        "com.unity.sysroot.linux-x86_64": "2.0.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ugui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0"
      }
    },
    "com.unity.modules.ai": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.androidjni": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.animation": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.assetbundle": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.audio": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.cloth": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0"
      }
    },
    "com.unity.modules.director": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.animation": "1.0.0"
      }
    },
    "com.unity.modules.imageconversion": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.imgui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.jsonserialize": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.particlesystem": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics2d": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.screencapture": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.subsystems": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.terrain": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.terrainphysics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.terrain": "1.0.0"
      }
    },
    "com.unity.modules.tilemap": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics2d": "1.0.0"
      }
    },
    "com.unity.modules.ui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.uielements": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.umbra": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.unityanalytics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequest": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.unitywebrequestassetbundle": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.assetbundle": "1.0.0",
        "com.unity.modules.unitywebrequest": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequestaudio": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.audio": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequesttexture": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequestwww": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.unitywebrequestassetbundle": "1.0.0",
        "com.unity.modules.unitywebrequestaudio": "1.0.0",
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.assetbundle": "1.0.0",
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.vehicles": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0"
      }
    },
    "com.unity.modules.video": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.unitywebrequest": "1.0.0"
      }
    },
    "com.unity.modules.vr": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.xr": "1.0.0"
      }
    },
    "com.unity.modules.wind": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.xr": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.subsystems": "1.0.0"
      }
    }
  }
}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/AudioManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!11 &1
AudioManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Volume: 1
  Rolloff Scale: 1
  Doppler Factor: 1
  Default Speaker Mode: 2
  m_SampleRate: 0
  m_DSPBufferSize: 1024
  m_VirtualVoiceCount: 512
  m_RealVoiceCount: 32
  m_SpatializerPlugin: 
  m_AmbisonicDecoderPlugin: 
  m_DisableAudio: 0
  m_VirtualizeEffects: 1
  m_RequestedDSPBufferSize: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/BurstAotSettings_StandaloneWindows.json
================================================
{
  "MonoBehaviour": {
    "Version": 4,
    "EnableBurstCompilation": true,
    "EnableOptimisations": true,
    "EnableSafetyChecks": false,
    "EnableDebugInAllBuilds": false,
    "UsePlatformSDKLinker": false,
    "CpuMinTargetX32": 0,
    "CpuMaxTargetX32": 0,
    "CpuMinTargetX64": 0,
    "CpuMaxTargetX64": 0,
    "CpuTargetsX32": 6,
    "CpuTargetsX64": 72,
    "OptimizeFor": 0
  }
}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/ClusterInputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!236 &1
ClusterInputManager:
  m_ObjectHideFlags: 0
  m_Inputs: []



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/CommonBurstAotSettings.json
================================================
{
  "MonoBehaviour": {
    "Version": 4,
    "DisabledWarnings": ""
  }
}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/DynamicsManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!55 &1
PhysicsManager:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Gravity: {x: 0, y: -9.81, z: 0}
  m_DefaultMaterial: {fileID: 0}
  m_BounceThreshold: 2
  m_DefaultMaxDepenetrationVelocity: 10
  m_SleepThreshold: 0.005
  m_DefaultContactOffset: 0.01
  m_DefaultSolverIterations: 6
  m_DefaultSolverVelocityIterations: 1
  m_QueriesHitBackfaces: 0
  m_QueriesHitTriggers: 1
  m_EnableAdaptiveForce: 0
  m_ClothInterCollisionDistance: 0.1
  m_ClothInterCollisionStiffness: 0.2
  m_ContactsGeneration: 1
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  m_AutoSimulation: 1
  m_AutoSyncTransforms: 0
  m_ReuseCollisionCallbacks: 1
  m_ClothInterCollisionSettingsToggle: 0
  m_ClothGravity: {x: 0, y: -9.81, z: 0}
  m_ContactPairsMode: 0
  m_BroadphaseType: 0
  m_WorldBounds:
    m_Center: {x: 0, y: 0, z: 0}
    m_Extent: {x: 250, y: 250, z: 250}
  m_WorldSubdivisions: 8
  m_FrictionType: 0
  m_EnableEnhancedDeterminism: 0
  m_EnableUnifiedHeightmaps: 1
  m_SolverType: 0
  m_DefaultMaxAngularSpeed: 50



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/EditorBuildSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1045 &1
EditorBuildSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Scenes:
  - enabled: 0
    path: Assets/Scenes/SampleScene.unity
    guid: 2cda990e2423bbf4892e6590ba056729
  - enabled: 1
    path: Assets/Scenes/RuntimeUnitTestScene.unity
    guid: f825a3a508f34d1429d39576f6080bc4
  m_configObjects: {}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/EditorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!159 &1
EditorSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_SerializationMode: 2
  m_LineEndingsForNewScripts: 0
  m_DefaultBehaviorMode: 1
  m_PrefabRegularEnvironment: {fileID: 0}
  m_PrefabUIEnvironment: {fileID: 0}
  m_SpritePackerMode: 4
  m_SpritePackerPaddingPower: 1
  m_EtcTextureCompressorBehavior: 1
  m_EtcTextureFastCompressor: 1
  m_EtcTextureNormalCompressor: 2
  m_EtcTextureBestCompressor: 4
  m_ProjectGenerationIncludedExtensions: txt;xml;fnt;cd;asmdef;asmref;rsp
  m_ProjectGenerationRootNamespace: 
  m_EnableTextureStreamingInEditMode: 1
  m_EnableTextureStreamingInPlayMode: 1
  m_AsyncShaderCompilation: 1
  m_CachingShaderPreprocessor: 1
  m_PrefabModeAllowAutoSave: 1
  m_EnterPlayModeOptionsEnabled: 0
  m_EnterPlayModeOptions: 3
  m_GameObjectNamingDigits: 1
  m_GameObjectNamingScheme: 0
  m_AssetNamingUsesSpace: 1
  m_UseLegacyProbeSampleCount: 0
  m_SerializeInlineMappingsOnOneLine: 1
  m_DisableCookiesInLightmapper: 1
  m_AssetPipelineMode: 1
  m_CacheServerMode: 0
  m_CacheServerEndpoint: 
  m_CacheServerNamespacePrefix: default
  m_CacheServerEnableDownload: 1
  m_CacheServerEnableUpload: 1
  m_CacheServerEnableAuth: 0
  m_CacheServerEnableTls: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/GraphicsSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!30 &1
GraphicsSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Deferred:
    m_Mode: 1
    m_Shader: {fileID: 69, guid: 0000000000000000f000000000000000, type: 0}
  m_DeferredReflections:
    m_Mode: 1
    m_Shader: {fileID: 74, guid: 0000000000000000f000000000000000, type: 0}
  m_ScreenSpaceShadows:
    m_Mode: 1
    m_Shader: {fileID: 64, guid: 0000000000000000f000000000000000, type: 0}
  m_LegacyDeferred:
    m_Mode: 1
    m_Shader: {fileID: 63, guid: 0000000000000000f000000000000000, type: 0}
  m_DepthNormals:
    m_Mode: 1
    m_Shader: {fileID: 62, guid: 0000000000000000f000000000000000, type: 0}
  m_MotionVectors:
    m_Mode: 1
    m_Shader: {fileID: 75, guid: 0000000000000000f000000000000000, type: 0}
  m_LightHalo:
    m_Mode: 1
    m_Shader: {fileID: 105, guid: 0000000000000000f000000000000000, type: 0}
  m_LensFlare:
    m_Mode: 1
    m_Shader: {fileID: 102, guid: 0000000000000000f000000000000000, type: 0}
  m_VideoShadersIncludeMode: 2
  m_AlwaysIncludedShaders:
  - {fileID: 7, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15104, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15105, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15106, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10753, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10770, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10783, guid: 0000000000000000f000000000000000, type: 0}
  m_PreloadedShaders: []
  m_SpritesDefaultMaterial: {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_CustomRenderPipeline: {fileID: 0}
  m_TransparencySortMode: 0
  m_TransparencySortAxis: {x: 0, y: 0, z: 1}
  m_DefaultRenderingPath: 1
  m_DefaultMobileRenderingPath: 1
  m_TierSettings: []
  m_LightmapStripping: 0
  m_FogStripping: 0
  m_InstancingStripping: 0
  m_LightmapKeepPlain: 1
  m_LightmapKeepDirCombined: 1
  m_LightmapKeepDynamicPlain: 1
  m_LightmapKeepDynamicDirCombined: 1
  m_LightmapKeepShadowMask: 1
  m_LightmapKeepSubtractive: 1
  m_FogKeepLinear: 1
  m_FogKeepExp: 1
  m_FogKeepExp2: 1
  m_AlbedoSwatchInfos: []
  m_LightsUseLinearIntensity: 0
  m_LightsUseColorTemperature: 0
  m_DefaultRenderingLayerMask: 1
  m_LogWhenShaderIsCompiled: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/InputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!13 &1
InputManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Axes:
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: a
    altPositiveButton: d
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: s
    altPositiveButton: w
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: mouse 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: mouse 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: mouse 2
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: space
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse X
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse Y
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse ScrollWheel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 2
    joyNum: 0
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 0
    type: 2
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 1
    type: 2
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 0
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 1
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 2
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 3
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: enter
    altNegativeButton: 
    altPositiveButton: space
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Cancel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: escape
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: joystick button 8
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: backspace
    altNegativeButton: 
    altPositiveButton: joystick button 9
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Reset
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Next
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page down
    altNegativeButton: 
    altPositiveButton: joystick button 5
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Previous
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page up
    altNegativeButton: 
    altPositiveButton: joystick button 4
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Validate
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Persistent
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: right shift
    altNegativeButton: 
    altPositiveButton: joystick button 2
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Multiplier
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: joystick button 3
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 6
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 5
    joyNum: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/MemorySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!387306366 &1
MemorySettings:
  m_ObjectHideFlags: 0
  m_EditorMemorySettings:
    m_MainAllocatorBlockSize: -1
    m_ThreadAllocatorBlockSize: -1
    m_MainGfxBlockSize: -1
    m_ThreadGfxBlockSize: -1
    m_CacheBlockSize: -1
    m_TypetreeBlockSize: -1
    m_ProfilerBlockSize: -1
    m_ProfilerEditorBlockSize: -1
    m_BucketAllocatorGranularity: -1
    m_BucketAllocatorBucketsCount: -1
    m_BucketAllocatorBlockSize: -1
    m_BucketAllocatorBlockCount: -1
    m_ProfilerBucketAllocatorGranularity: -1
    m_ProfilerBucketAllocatorBucketsCount: -1
    m_ProfilerBucketAllocatorBlockSize: -1
    m_ProfilerBucketAllocatorBlockCount: -1
    m_TempAllocatorSizeMain: -1
    m_JobTempAllocatorBlockSize: -1
    m_BackgroundJobTempAllocatorBlockSize: -1
    m_JobTempAllocatorReducedBlockSize: -1
    m_TempAllocatorSizeGIBakingWorker: -1
    m_TempAllocatorSizeNavMeshWorker: -1
    m_TempAllocatorSizeAudioWorker: -1
    m_TempAllocatorSizeCloudWorker: -1
    m_TempAllocatorSizeGfx: -1
    m_TempAllocatorSizeJobWorker: -1
    m_TempAllocatorSizeBackgroundWorker: -1
    m_TempAllocatorSizePreloadManager: -1
  m_PlatformMemorySettings: {}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/NavMeshAreas.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!126 &1
NavMeshProjectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  areas:
  - name: Walkable
    cost: 1
  - name: Not Walkable
    cost: 1
  - name: Jump
    cost: 2
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  m_LastAgentTypeID: -887442657
  m_Settings:
  - serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.75
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_SettingNames:
  - Humanoid



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/NetworkManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!149 &1
NetworkManager:
  m_ObjectHideFlags: 0
  m_DebugLevel: 0
  m_Sendrate: 15
  m_AssetToPrefab: {}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/PackageManagerSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 61
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 13964, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_EnablePreReleasePackages: 1
  m_EnablePackageDependencies: 1
  m_AdvancedSettingsExpanded: 1
  m_ScopedRegistriesSettingsExpanded: 1
  m_SeeAllPackageVersions: 0
  oneTimeWarningShown: 1
  m_Registries:
  - m_Id: main
    m_Name: 
    m_Url: https://packages.unity.com
    m_Scopes: []
    m_IsDefault: 1
    m_Capabilities: 7
  m_UserSelectedRegistryName: 
  m_UserAddingNewScopedRegistry: 0
  m_RegistryInfoDraft:
    m_Modified: 0
    m_ErrorMessage: 
    m_UserModificationsInstanceId: -830
    m_OriginalInstanceId: -832
  m_LoadAssets: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/Physics2DSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!19 &1
Physics2DSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_Gravity: {x: 0, y: -9.81}
  m_DefaultMaterial: {fileID: 0}
  m_VelocityIterations: 8
  m_PositionIterations: 3
  m_VelocityThreshold: 1
  m_MaxLinearCorrection: 0.2
  m_MaxAngularCorrection: 8
  m_MaxTranslationSpeed: 100
  m_MaxRotationSpeed: 360
  m_BaumgarteScale: 0.2
  m_BaumgarteTimeOfImpactScale: 0.75
  m_TimeToSleep: 0.5
  m_LinearSleepTolerance: 0.01
  m_AngularSleepTolerance: 2
  m_DefaultContactOffset: 0.01
  m_JobOptions:
    serializedVersion: 2
    useMultithreading: 0
    useConsistencySorting: 0
    m_InterpolationPosesPerJob: 100
    m_NewContactsPerJob: 30
    m_CollideContactsPerJob: 100
    m_ClearFlagsPerJob: 200
    m_ClearBodyForcesPerJob: 200
    m_SyncDiscreteFixturesPerJob: 50
    m_SyncContinuousFixturesPerJob: 50
    m_FindNearestContactsPerJob: 100
    m_UpdateTriggerContactsPerJob: 100
    m_IslandSolverCostThreshold: 100
    m_IslandSolverBodyCostScale: 1
    m_IslandSolverContactCostScale: 10
    m_IslandSolverJointCostScale: 10
    m_IslandSolverBodiesPerJob: 50
    m_IslandSolverContactsPerJob: 50
  m_SimulationMode: 0
  m_QueriesHitTriggers: 1
  m_QueriesStartInColliders: 1
  m_CallbacksOnDisable: 1
  m_ReuseCollisionCallbacks: 1
  m_AutoSyncTransforms: 0
  m_AlwaysShowColliders: 0
  m_ShowColliderSleep: 1
  m_ShowColliderContacts: 0
  m_ShowColliderAABB: 0
  m_ContactArrowScale: 0.2
  m_ColliderAwakeColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.7529412}
  m_ColliderAsleepColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.36078432}
  m_ColliderContactColor: {r: 1, g: 0, b: 1, a: 0.6862745}
  m_ColliderAABBColor: {r: 1, g: 1, b: 0, a: 0.2509804}
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/PresetManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1386491679 &1
PresetManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_DefaultPresets: {}



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/ProjectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 26
  productGUID: acb124f57b8f0a94eb410450e48f7724
  AndroidProfiler: 0
  AndroidFilterTouchesWhenObscured: 0
  AndroidEnableSustainedPerformanceMode: 0
  defaultScreenOrientation: 4
  targetDevice: 2
  useOnDemandResources: 0
  accelerometerFrequency: 60
  companyName: DefaultCompany
  productName: MemoryPack.Unity
  defaultCursor: {fileID: 0}
  cursorHotspot: {x: 0, y: 0}
  m_SplashScreenBackgroundColor: {r: 0.13725491, g: 0.12156863, b: 0.1254902, a: 1}
  m_ShowUnitySplashScreen: 0
  m_ShowUnitySplashLogo: 1
  m_SplashScreenOverlayOpacity: 1
  m_SplashScreenAnimation: 1
  m_SplashScreenLogoStyle: 1
  m_SplashScreenDrawMode: 0
  m_SplashScreenBackgroundAnimationZoom: 1
  m_SplashScreenLogoAnimationZoom: 1
  m_SplashScreenBackgroundLandscapeAspect: 1
  m_SplashScreenBackgroundPortraitAspect: 1
  m_SplashScreenBackgroundLandscapeUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenBackgroundPortraitUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenLogos: []
  m_VirtualRealitySplashScreen: {fileID: 0}
  m_HolographicTrackingLossScreen: {fileID: 0}
  defaultScreenWidth: 1920
  defaultScreenHeight: 1080
  defaultScreenWidthWeb: 960
  defaultScreenHeightWeb: 600
  m_StereoRenderingPath: 0
  m_ActiveColorSpace: 0
  unsupportedMSAAFallback: 0
  m_SpriteBatchVertexThreshold: 300
  m_MTRendering: 1
  mipStripping: 0
  numberOfMipsStripped: 0
  numberOfMipsStrippedPerMipmapLimitGroup: {}
  m_StackTraceTypes: 010000000100000001000000010000000100000001000000
  iosShowActivityIndicatorOnLoading: -1
  androidShowActivityIndicatorOnLoading: -1
  iosUseCustomAppBackgroundBehavior: 0
  allowedAutorotateToPortrait: 1
  allowedAutorotateToPortraitUpsideDown: 1
  allowedAutorotateToLandscapeRight: 1
  allowedAutorotateToLandscapeLeft: 1
  useOSAutorotation: 1
  use32BitDisplayBuffer: 1
  preserveFramebufferAlpha: 0
  disableDepthAndStencilBuffers: 0
  androidStartInFullscreen: 1
  androidRenderOutsideSafeArea: 1
  androidUseSwappy: 1
  androidBlitType: 0
  androidResizableWindow: 0
  androidDefaultWindowWidth: 1920
  androidDefaultWindowHeight: 1080
  androidMinimumWindowWidth: 400
  androidMinimumWindowHeight: 300
  androidFullscreenMode: 1
  androidAutoRotationBehavior: 1
  defaultIsNativeResolution: 1
  macRetinaSupport: 1
  runInBackground: 1
  captureSingleScreen: 0
  muteOtherAudioSources: 0
  Prepare IOS For Recording: 0
  Force IOS Speakers When Recording: 0
  deferSystemGesturesMode: 0
  hideHomeButton: 0
  submitAnalytics: 1
  usePlayerLog: 1
  dedicatedServerOptimizations: 0
  bakeCollisionMeshes: 0
  forceSingleInstance: 0
  useFlipModelSwapchain: 1
  resizableWindow: 1
  useMacAppStoreValidation: 0
  macAppStoreCategory: public.app-category.games
  gpuSkinning: 0
  xboxPIXTextureCapture: 0
  xboxEnableAvatar: 0
  xboxEnableKinect: 0
  xboxEnableKinectAutoTracking: 0
  xboxEnableFitness: 0
  visibleInBackground: 1
  allowFullscreenSwitch: 1
  fullscreenMode: 3
  xboxSpeechDB: 0
  xboxEnableHeadOrientation: 0
  xboxEnableGuest: 0
  xboxEnablePIXSampling: 0
  metalFramebufferOnly: 0
  xboxOneResolution: 0
  xboxOneSResolution: 0
  xboxOneXResolution: 3
  xboxOneMonoLoggingLevel: 0
  xboxOneLoggingLevel: 1
  xboxOneDisableEsram: 0
  xboxOneEnableTypeOptimization: 0
  xboxOnePresentImmediateThreshold: 0
  switchQueueCommandMemory: 1048576
  switchQueueControlMemory: 16384
  switchQueueComputeMemory: 262144
  switchNVNShaderPoolsGranularity: 33554432
  switchNVNDefaultPoolsGranularity: 16777216
  switchNVNOtherPoolsGranularity: 16777216
  switchGpuScratchPoolGranularity: 2097152
  switchAllowGpuScratchShrinking: 0
  switchNVNMaxPublicTextureIDCount: 0
  switchNVNMaxPublicSamplerIDCount: 0
  switchNVNGraphicsFirmwareMemory: 32
  switchMaxWorkerMultiple: 8
  stadiaPresentMode: 0
  stadiaTargetFramerate: 0
  vulkanNumSwapchainBuffers: 3
  vulkanEnableSetSRGBWrite: 0
  vulkanEnablePreTransform: 0
  vulkanEnableLateAcquireNextImage: 0
  vulkanEnableCommandBufferRecycling: 1
  loadStoreDebugModeEnabled: 0
  visionOSBundleVersion: 1.0
  tvOSBundleVersion: 1.0
  bundleVersion: 1.0
  preloadedAssets: []
  metroInputSource: 0
  wsaTransparentSwapchain: 0
  m_HolographicPauseOnTrackingLoss: 1
  xboxOneDisableKinectGpuReservation: 1
  xboxOneEnable7thCore: 1
  vrSettings:
    enable360StereoCapture: 0
  isWsaHolographicRemotingEnabled: 0
  enableFrameTimingStats: 0
  enableOpenGLProfilerGPURecorders: 1
  allowHDRDisplaySupport: 0
  useHDRDisplay: 0
  hdrBitDepth: 0
  m_ColorGamuts: 00000000
  targetPixelDensity: 30
  resolutionScalingMode: 0
  resetResolutionOnWindowResize: 0
  androidSupportedAspectRatio: 1
  androidMaxAspectRatio: 2.1
  applicationIdentifier:
    Standalone: com.DefaultCompany.2DProject
  buildNumber:
    Standalone: 0
    VisionOS: 0
    iPhone: 0
    tvOS: 0
  overrideDefaultApplicationIdentifier: 1
  AndroidBundleVersionCode: 1
  AndroidMinSdkVersion: 22
  AndroidTargetSdkVersion: 0
  AndroidPreferredInstallLocation: 1
  aotOptions: nimt-trampolines=1024
  stripEngineCode: 1
  iPhoneStrippingLevel: 0
  iPhoneScriptCallOptimization: 0
  ForceInternetPermission: 0
  ForceSDCardPermission: 0
  CreateWallpaper: 0
  APKExpansionFiles: 0
  keepLoadedShadersAlive: 0
  StripUnusedMeshComponents: 0
  strictShaderVariantMatching: 0
  VertexChannelCompressionMask: 4054
  iPhoneSdkVersion: 988
  iOSTargetOSVersionString: 12.0
  tvOSSdkVersion: 0
  tvOSRequireExtendedGameController: 0
  tvOSTargetOSVersionString: 12.0
  VisionOSSdkVersion: 0
  VisionOSTargetOSVersionString: 1.0
  uIPrerenderedIcon: 0
  uIRequiresPersistentWiFi: 0
  uIRequiresFullScreen: 1
  uIStatusBarHidden: 1
  uIExitOnSuspend: 0
  uIStatusBarStyle: 0
  appleTVSplashScreen: {fileID: 0}
  appleTVSplashScreen2x: {fileID: 0}
  tvOSSmallIconLayers: []
  tvOSSmallIconLayers2x: []
  tvOSLargeIconLayers: []
  tvOSLargeIconLayers2x: []
  tvOSTopShelfImageLayers: []
  tvOSTopShelfImageLayers2x: []
  tvOSTopShelfImageWideLayers: []
  tvOSTopShelfImageWideLayers2x: []
  iOSLaunchScreenType: 0
  iOSLaunchScreenPortrait: {fileID: 0}
  iOSLaunchScreenLandscape: {fileID: 0}
  iOSLaunchScreenBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreenFillPct: 100
  iOSLaunchScreenSize: 100
  iOSLaunchScreenCustomXibPath: 
  iOSLaunchScreeniPadType: 0
  iOSLaunchScreeniPadImage: {fileID: 0}
  iOSLaunchScreeniPadBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreeniPadFillPct: 100
  iOSLaunchScreeniPadSize: 100
  iOSLaunchScreeniPadCustomXibPath: 
  iOSLaunchScreenCustomStoryboardPath: 
  iOSLaunchScreeniPadCustomStoryboardPath: 
  iOSDeviceRequirements: []
  iOSURLSchemes: []
  macOSURLSchemes: []
  iOSBackgroundModes: 0
  iOSMetalForceHardShadows: 0
  metalEditorSupport: 1
  metalAPIValidation: 1
  metalCompileShaderBinary: 0
  iOSRenderExtraFrameOnPause: 0
  iosCopyPluginsCodeInsteadOfSymlink: 0
  appleDeveloperTeamID: 
  iOSManualSigningProvisioningProfileID: 
  tvOSManualSigningProvisioningProfileID: 
  VisionOSManualSigningProvisioningProfileID: 
  iOSManualSigningProvisioningProfileType: 0
  tvOSManualSigningProvisioningProfileType: 0
  VisionOSManualSigningProvisioningProfileType: 0
  appleEnableAutomaticSigning: 0
  iOSRequireARKit: 0
  iOSAutomaticallyDetectAndAddCapabilities: 1
  appleEnableProMotion: 0
  shaderPrecisionModel: 0
  clonedFromGUID: 10ad67313f4034357812315f3c407484
  templatePackageId: com.unity.template.2d@6.1.1
  templateDefaultScene: Assets/Scenes/SampleScene.unity
  useCustomMainManifest: 0
  useCustomLauncherManifest: 0
  useCustomMainGradleTemplate: 0
  useCustomLauncherGradleManifest: 0
  useCustomBaseGradleTemplate: 0
  useCustomGradlePropertiesTemplate: 0
  useCustomGradleSettingsTemplate: 0
  useCustomProguardFile: 0
  AndroidTargetArchitectures: 1
  AndroidTargetDevices: 0
  AndroidSplashScreenScale: 0
  androidSplashScreen: {fileID: 0}
  AndroidKeystoreName: 
  AndroidKeyaliasName: 
  AndroidEnableArmv9SecurityFeatures: 0
  AndroidBuildApkPerCpuArchitecture: 0
  AndroidTVCompatibility: 0
  AndroidIsGame: 1
  AndroidEnableTango: 0
  androidEnableBanner: 1
  androidUseLowAccuracyLocation: 0
  androidUseCustomKeystore: 0
  m_AndroidBanners:
  - width: 320
    height: 180
    banner: {fileID: 0}
  androidGamepadSupportLevel: 0
  chromeosInputEmulation: 1
  AndroidMinifyRelease: 0
  AndroidMinifyDebug: 0
  AndroidValidateAppBundleSize: 1
  AndroidAppBundleSizeToValidate: 150
  m_BuildTargetIcons: []
  m_BuildTargetPlatformIcons: []
  m_BuildTargetBatching: []
  m_BuildTargetShaderSettings: []
  m_BuildTargetGraphicsJobs:
  - m_BuildTarget: MacStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: Switch
    m_GraphicsJobs: 0
  - m_BuildTarget: MetroSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AppleTVSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: BJMSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: LinuxStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: PS4Player
    m_GraphicsJobs: 0
  - m_BuildTarget: iOSSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: WindowsStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: XboxOnePlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: LuminSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AndroidPlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: WebGLSupport
    m_GraphicsJobs: 0
  m_BuildTargetGraphicsJobMode: []
  m_BuildTargetGraphicsAPIs:
  - m_BuildTarget: AndroidPlayer
    m_APIs: 150000000b000000
    m_Automatic: 1
  - m_BuildTarget: iOSSupport
    m_APIs: 10000000
    m_Automatic: 1
  m_BuildTargetVRSettings: []
  m_DefaultShaderChunkSizeInMB: 16
  m_DefaultShaderChunkCount: 0
  openGLRequireES31: 0
  openGLRequireES31AEP: 0
  openGLRequireES32: 0
  m_TemplateCustomTags: {}
  mobileMTRendering:
    Android: 1
    iPhone: 1
    tvOS: 1
  m_BuildTargetGroupLightmapEncodingQuality: []
  m_BuildTargetGroupHDRCubemapEncodingQuality: []
  m_BuildTargetGroupLightmapSettings: []
  m_BuildTargetGroupLoadStoreDebugModeSettings: []
  m_BuildTargetNormalMapEncoding: []
  m_BuildTargetDefaultTextureCompressionFormat:
  - m_BuildTarget: Android
    m_Format: 3
  playModeTestRunnerEnabled: 0
  runPlayModeTestAsEditModeTest: 0
  actionOnDotNetUnhandledException: 1
  enableInternalProfiler: 0
  logObjCUncaughtExceptions: 1
  enableCrashReportAPI: 0
  cameraUsageDescription: 
  locationUsageDescription: 
  microphoneUsageDescription: 
  bluetoothUsageDescription: 
  macOSTargetOSVersion: 10.13.0
  switchNMETAOverride: 
  switchNetLibKey: 
  switchSocketMemoryPoolSize: 6144
  switchSocketAllocatorPoolSize: 128
  switchSocketConcurrencyLimit: 14
  switchScreenResolutionBehavior: 2
  switchUseCPUProfiler: 0
  switchEnableFileSystemTrace: 0
  switchLTOSetting: 0
  switchApplicationID: 0x01004b9000490000
  switchNSODependencies: 
  switchCompilerFlags: 
  switchTitleNames_0: 
  switchTitleNames_1: 
  switchTitleNames_2: 
  switchTitleNames_3: 
  switchTitleNames_4: 
  switchTitleNames_5: 
  switchTitleNames_6: 
  switchTitleNames_7: 
  switchTitleNames_8: 
  switchTitleNames_9: 
  switchTitleNames_10: 
  switchTitleNames_11: 
  switchTitleNames_12: 
  switchTitleNames_13: 
  switchTitleNames_14: 
  switchTitleNames_15: 
  switchPublisherNames_0: 
  switchPublisherNames_1: 
  switchPublisherNames_2: 
  switchPublisherNames_3: 
  switchPublisherNames_4: 
  switchPublisherNames_5: 
  switchPublisherNames_6: 
  switchPublisherNames_7: 
  switchPublisherNames_8: 
  switchPublisherNames_9: 
  switchPublisherNames_10: 
  switchPublisherNames_11: 
  switchPublisherNames_12: 
  switchPublisherNames_13: 
  switchPublisherNames_14: 
  switchPublisherNames_15: 
  switchIcons_0: {fileID: 0}
  switchIcons_1: {fileID: 0}
  switchIcons_2: {fileID: 0}
  switchIcons_3: {fileID: 0}
  switchIcons_4: {fileID: 0}
  switchIcons_5: {fileID: 0}
  switchIcons_6: {fileID: 0}
  switchIcons_7: {fileID: 0}
  switchIcons_8: {fileID: 0}
  switchIcons_9: {fileID: 0}
  switchIcons_10: {fileID: 0}
  switchIcons_11: {fileID: 0}
  switchIcons_12: {fileID: 0}
  switchIcons_13: {fileID: 0}
  switchIcons_14: {fileID: 0}
  switchIcons_15: {fileID: 0}
  switchSmallIcons_0: {fileID: 0}
  switchSmallIcons_1: {fileID: 0}
  switchSmallIcons_2: {fileID: 0}
  switchSmallIcons_3: {fileID: 0}
  switchSmallIcons_4: {fileID: 0}
  switchSmallIcons_5: {fileID: 0}
  switchSmallIcons_6: {fileID: 0}
  switchSmallIcons_7: {fileID: 0}
  switchSmallIcons_8: {fileID: 0}
  switchSmallIcons_9: {fileID: 0}
  switchSmallIcons_10: {fileID: 0}
  switchSmallIcons_11: {fileID: 0}
  switchSmallIcons_12: {fileID: 0}
  switchSmallIcons_13: {fileID: 0}
  switchSmallIcons_14: {fileID: 0}
  switchSmallIcons_15: {fileID: 0}
  switchManualHTML: 
  switchAccessibleURLs: 
  switchLegalInformation: 
  switchMainThreadStackSize: 1048576
  switchPresenceGroupId: 
  switchLogoHandling: 0
  switchReleaseVersion: 0
  switchDisplayVersion: 1.0.0
  switchStartupUserAccount: 0
  switchSupportedLanguagesMask: 0
  switchLogoType: 0
  switchApplicationErrorCodeCategory: 
  switchUserAccountSaveDataSize: 0
  switchUserAccountSaveDataJournalSize: 0
  switchApplicationAttribute: 0
  switchCardSpecSize: -1
  switchCardSpecClock: -1
  switchRatingsMask: 0
  switchRatingsInt_0: 0
  switchRatingsInt_1: 0
  switchRatingsInt_2: 0
  switchRatingsInt_3: 0
  switchRatingsInt_4: 0
  switchRatingsInt_5: 0
  switchRatingsInt_6: 0
  switchRatingsInt_7: 0
  switchRatingsInt_8: 0
  switchRatingsInt_9: 0
  switchRatingsInt_10: 0
  switchRatingsInt_11: 0
  switchRatingsInt_12: 0
  switchLocalCommunicationIds_0: 
  switchLocalCommunicationIds_1: 
  switchLocalCommunicationIds_2: 
  switchLocalCommunicationIds_3: 
  switchLocalCommunicationIds_4: 
  switchLocalCommunicationIds_5: 
  switchLocalCommunicationIds_6: 
  switchLocalCommunicationIds_7: 
  switchParentalControl: 0
  switchAllowsScreenshot: 1
  switchAllowsVideoCapturing: 1
  switchAllowsRuntimeAddOnContentInstall: 0
  switchDataLossConfirmation: 0
  switchUserAccountLockEnabled: 0
  switchSystemResourceMemory: 16777216
  switchSupportedNpadStyles: 22
  switchNativeFsCacheSize: 32
  switchIsHoldTypeHorizontal: 0
  switchSupportedNpadCount: 8
  switchEnableTouchScreen: 1
  switchSocketConfigEnabled: 0
  switchTcpInitialSendBufferSize: 32
  switchTcpInitialReceiveBufferSize: 64
  switchTcpAutoSendBufferSizeMax: 256
  switchTcpAutoReceiveBufferSizeMax: 256
  switchUdpSendBufferSize: 9
  switchUdpReceiveBufferSize: 42
  switchSocketBufferEfficiency: 4
  switchSocketInitializeEnabled: 1
  switchNetworkInterfaceManagerInitializeEnabled: 1
  switchUseNewStyleFilepaths: 0
  switchUseLegacyFmodPriorities: 0
  switchUseMicroSleepForYield: 1
  switchEnableRamDiskSupport: 0
  switchMicroSleepForYieldTime: 25
  switchRamDiskSpaceSize: 12
  ps4NPAgeRating: 12
  ps4NPTitleSecret: 
  ps4NPTrophyPackPath: 
  ps4ParentalLevel: 11
  ps4ContentID: ED1633-NPXX51362_00-0000000000000000
  ps4Category: 0
  ps4MasterVersion: 01.00
  ps4AppVersion: 01.00
  ps4AppType: 0
  ps4ParamSfxPath: 
  ps4VideoOutPixelFormat: 0
  ps4VideoOutInitialWidth: 1920
  ps4VideoOutBaseModeInitialWidth: 1920
  ps4VideoOutReprojectionRate: 60
  ps4PronunciationXMLPath: 
  ps4PronunciationSIGPath: 
  ps4BackgroundImagePath: 
  ps4StartupImagePath: 
  ps4StartupImagesFolder: 
  ps4IconImagesFolder: 
  ps4SaveDataImagePath: 
  ps4SdkOverride: 
  ps4BGMPath: 
  ps4ShareFilePath: 
  ps4ShareOverlayImagePath: 
  ps4PrivacyGuardImagePath: 
  ps4ExtraSceSysFile: 
  ps4NPtitleDatPath: 
  ps4RemotePlayKeyAssignment: -1
  ps4RemotePlayKeyMappingDir: 
  ps4PlayTogetherPlayerCount: 0
  ps4EnterButtonAssignment: 2
  ps4ApplicationParam1: 0
  ps4ApplicationParam2: 0
  ps4ApplicationParam3: 0
  ps4ApplicationParam4: 0
  ps4DownloadDataSize: 0
  ps4GarlicHeapSize: 2048
  ps4ProGarlicHeapSize: 2560
  playerPrefsMaxSize: 32768
  ps4Passcode: bi9UOuSpM2Tlh01vOzwvSikHFswuzleh
  ps4pnSessions: 1
  ps4pnPresence: 1
  ps4pnFriends: 1
  ps4pnGameCustomData: 1
  playerPrefsSupport: 0
  enableApplicationExit: 0
  resetTempFolder: 1
  restrictedAudioUsageRights: 0
  ps4UseResolutionFallback: 0
  ps4ReprojectionSupport: 0
  ps4UseAudio3dBackend: 0
  ps4UseLowGarlicFragmentationMode: 1
  ps4SocialScreenEnabled: 0
  ps4ScriptOptimizationLevel: 2
  ps4Audio3dVirtualSpeakerCount: 14
  ps4attribCpuUsage: 0
  ps4PatchPkgPath: 
  ps4PatchLatestPkgPath: 
  ps4PatchChangeinfoPath: 
  ps4PatchDayOne: 0
  ps4attribUserManagement: 0
  ps4attribMoveSupport: 0
  ps4attrib3DSupport: 0
  ps4attribShareSupport: 0
  ps4attribExclusiveVR: 0
  ps4disableAutoHideSplash: 0
  ps4videoRecordingFeaturesUsed: 0
  ps4contentSearchFeaturesUsed: 0
  ps4CompatibilityPS5: 0
  ps4AllowPS5Detection: 0
  ps4GPU800MHz: 1
  ps4attribEyeToEyeDistanceSettingVR: 0
  ps4IncludedModules: []
  ps4attribVROutputEnabled: 0
  monoEnv: 
  splashScreenBackgroundSourceLandscape: {fileID: 0}
  splashScreenBackgroundSourcePortrait: {fileID: 0}
  blurSplashScreenBackground: 1
  spritePackerPolicy: 
  webGLMemorySize: 32
  webGLExceptionSupport: 1
  webGLNameFilesAsHashes: 0
  webGLShowDiagnostics: 0
  webGLDataCaching: 1
  webGLDebugSymbols: 0
  webGLEmscriptenArgs: 
  webGLModulesDirectory: 
  webGLTemplate: APPLICATION:Default
  webGLAnalyzeBuildSize: 0
  webGLUseEmbeddedResources: 0
  webGLCompressionFormat: 0
  webGLWasmArithmeticExceptions: 0
  webGLLinkerTarget: 1
  webGLThreadsSupport: 0
  webGLDecompressionFallback: 0
  webGLInitialMemorySize: 32
  webGLMaximumMemorySize: 2048
  webGLMemoryGrowthMode: 2
  webGLMemoryLinearGrowthStep: 16
  webGLMemoryGeometricGrowthStep: 0.2
  webGLMemoryGeometricGrowthCap: 96
  webGLPowerPreference: 2
  scriptingDefineSymbols: {}
  additionalCompilerArguments:
    Standalone:
    - 
  platformArchitecture: {}
  scriptingBackend:
    Standalone: 0
  il2cppCompilerConfiguration: {}
  il2cppCodeGeneration:
    Standalone: 0
  managedStrippingLevel:
    EmbeddedLinux: 1
    GameCoreScarlett: 1
    GameCoreXboxOne: 1
    Nintendo Switch: 1
    PS4: 1
    PS5: 1
    QNX: 1
    Stadia: 1
    Standalone: 4
    VisionOS: 1
    WebGL: 1
    Windows Store Apps: 1
    XboxOne: 1
    iPhone: 1
    tvOS: 1
  incrementalIl2cppBuild: {}
  suppressCommonWarnings: 1
  allowUnsafeCode: 0
  useDeterministicCompilation: 1
  additionalIl2CppArgs: 
  scriptingRuntimeVersion: 1
  gcIncremental: 1
  gcWBarrierValidation: 0
  apiCompatibilityLevelPerPlatform: {}
  m_RenderingPath: 1
  m_MobileRenderingPath: 1
  metroPackageName: 2D_BuiltInRenderer
  metroPackageVersion: 
  metroCertificatePath: 
  metroCertificatePassword: 
  metroCertificateSubject: 
  metroCertificateIssuer: 
  metroCertificateNotAfter: 0000000000000000
  metroApplicationDescription: 2D_BuiltInRenderer
  wsaImages: {}
  metroTileShortName: 
  metroTileShowName: 0
  metroMediumTileShowName: 0
  metroLargeTileShowName: 0
  metroWideTileShowName: 0
  metroSupportStreamingInstall: 0
  metroLastRequiredScene: 0
  metroDefaultTileSize: 1
  metroTileForegroundText: 2
  metroTileBackgroundColor: {r: 0.13333334, g: 0.17254902, b: 0.21568628, a: 0}
  metroSplashScreenBackgroundColor: {r: 0.12941177, g: 0.17254902, b: 0.21568628, a: 1}
  metroSplashScreenUseBackgroundColor: 0
  syncCapabilities: 0
  platformCapabilities: {}
  metroTargetDeviceFamilies: {}
  metroFTAName: 
  metroFTAFileTypes: []
  metroProtocolName: 
  vcxProjDefaultLanguage: 
  XboxOneProductId: 
  XboxOneUpdateKey: 
  XboxOneSandboxId: 
  XboxOneContentId: 
  XboxOneTitleId: 
  XboxOneSCId: 
  XboxOneGameOsOverridePath: 
  XboxOnePackagingOverridePath: 
  XboxOneAppManifestOverridePath: 
  XboxOneVersion: 1.0.0.0
  XboxOnePackageEncryption: 0
  XboxOnePackageUpdateGranularity: 2
  XboxOneDescription: 
  XboxOneLanguage:
  - enus
  XboxOneCapability: []
  XboxOneGameRating: {}
  XboxOneIsContentPackage: 0
  XboxOneEnhancedXboxCompatibilityMode: 0
  XboxOneEnableGPUVariability: 1
  XboxOneSockets: {}
  XboxOneSplashScreen: {fileID: 0}
  XboxOneAllowedProductIds: []
  XboxOnePersistentLocalStorageSize: 0
  XboxOneXTitleMemory: 8
  XboxOneOverrideIdentityName: 
  XboxOneOverrideIdentityPublisher: 
  vrEditorSettings: {}
  cloudServicesEnabled: {}
  luminIcon:
    m_Name: 
    m_ModelFolderPath: 
    m_PortalFolderPath: 
  luminCert:
    m_CertPath: 
    m_SignPackage: 1
  luminIsChannelApp: 0
  luminVersion:
    m_VersionCode: 1
    m_VersionName: 
  hmiPlayerDataPath: 
  hmiForceSRGBBlit: 1
  embeddedLinuxEnableGamepadInput: 1
  hmiLogStartupTiming: 0
  hmiCpuConfiguration: 
  apiCompatibilityLevel: 6
  activeInputHandler: 0
  windowsGamepadBackendHint: 0
  cloudProjectId: 
  framebufferDepthMemorylessMode: 0
  qualitySettingsNames: []
  projectName: 
  organizationId: 
  cloudEnabled: 0
  legacyClampBlendShapeWeights: 0
  hmiLoadingImage: {fileID: 0}
  platformRequiresReadableAssets: 0
  virtualTexturingSupportEnabled: 0
  insecureHttpOption: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/ProjectVersion.txt
================================================
m_EditorVersion: 2022.3.39f1
m_EditorVersionWithRevision: 2022.3.39f1 (4e1b0f82c39a)



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/QualitySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!47 &1
QualitySettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_CurrentQuality: 5
  m_QualitySettings:
  - serializedVersion: 2
    name: Very Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 15
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 1
    textureQuality: 1
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.3
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.4
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 16
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Medium
    pixelLightCount: 1
    shadows: 1
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 0.7
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 64
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: High
    pixelLightCount: 2
    shadows: 2
    shadowResolution: 1
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 40
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 256
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Very High
    pixelLightCount: 3
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 70
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 4
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1.5
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 1024
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Ultra
    pixelLightCount: 4
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 4
    shadowDistance: 150
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 255
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 2
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  m_PerPlatformDefaultQuality:
    Android: 2
    Lumin: 5
    GameCoreScarlett: 5
    GameCoreXboxOne: 5
    Nintendo Switch: 5
    PS4: 5
    PS5: 5
    Stadia: 5
    Standalone: 5
    WebGL: 3
    Windows Store Apps: 5
    XboxOne: 5
    iPhone: 2
    tvOS: 2



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/SceneTemplateSettings.json
================================================
{
    "templatePinStates": [],
    "dependencyTypeInfos": [
        {
            "userAdded": false,
            "type": "UnityEngine.AnimationClip",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Animations.AnimatorController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.AnimatorOverrideController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Audio.AudioMixerController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ComputeShader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Cubemap",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.GameObject",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.LightingDataAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.LightingSettings",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Material",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.MonoScript",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicMaterial",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicsMaterial2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessResources",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.VolumeProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.SceneAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Shader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ShaderVariantCollection",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Timeline.TimelineAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        }
    ],
    "defaultDependencyTypeInfo": {
        "userAdded": false,
        "type": "<default_scene_template_dependencies>",
        "ignore": false,
        "defaultInstantiationMode": 1,
        "supportsModification": true
    },
    "newSceneOverride": 0
}


================================================
FILE: src/MemoryPack.Unity/ProjectSettings/TagManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!78 &1
TagManager:
  serializedVersion: 2
  tags: []
  layers:
  - Default
  - TransparentFX
  - Ignore Raycast
  - 
  - Water
  - UI
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  m_SortingLayers:
  - name: Default
    uniqueID: 0
    locked: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/TimeManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!5 &1
TimeManager:
  m_ObjectHideFlags: 0
  Fixed Timestep: 0.02
  Maximum Allowed Timestep: 0.33333334
  m_TimeScale: 1
  Maximum Particle Timestep: 0.03



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/UnityConnectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!310 &1
UnityConnectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 1
  m_Enabled: 0
  m_TestMode: 0
  m_EventOldUrl: https://api.uca.cloud.unity3d.com/v1/events
  m_EventUrl: https://cdp.cloud.unity3d.com/v1/events
  m_ConfigUrl: https://config.uca.cloud.unity3d.com
  m_DashboardUrl: https://dashboard.unity3d.com
  m_TestInitMode: 0
  CrashReportingSettings:
    m_EventUrl: https://perf-events.cloud.unity3d.com
    m_Enabled: 0
    m_LogBufferSize: 10
    m_CaptureEditorExceptions: 1
  UnityPurchasingSettings:
    m_Enabled: 0
    m_TestMode: 0
  UnityAnalyticsSettings:
    m_Enabled: 0
    m_TestMode: 0
    m_InitializeOnStartup: 1
  UnityAdsSettings:
    m_Enabled: 0
    m_InitializeOnStartup: 1
    m_TestMode: 0
    m_IosGameId: 
    m_AndroidGameId: 
    m_GameIds: {}
    m_GameId: 
  PerformanceReportingSettings:
    m_Enabled: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/VersionControlSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!890905787 &1
VersionControlSettings:
  m_ObjectHideFlags: 0
  m_Mode: Visible Meta Files
  m_CollabEditorSettings:
    inProgressEnabled: 1



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/VFXManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!937362698 &1
VFXManager:
  m_ObjectHideFlags: 0
  m_IndirectShader: {fileID: 0}
  m_CopyBufferShader: {fileID: 0}
  m_SortShader: {fileID: 0}
  m_StripUpdateShader: {fileID: 0}
  m_RenderPipeSettingsPath: 
  m_FixedTimeStep: 0.016666668
  m_MaxDeltaTime: 0.05
  m_CompiledVersion: 0
  m_RuntimeVersion: 0



================================================
FILE: src/MemoryPack.Unity/ProjectSettings/XRSettings.asset
================================================
{
    "m_SettingKeys": [
        "VR Device Disabled",
        "VR Device User Alert"
    ],
    "m_SettingValues": [
        "False",
        "False"
    ]
}


================================================
FILE: src/MemoryPack.UnityShims/MemoryPack.UnityShims.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net7.0;net8.0;netstandard2.1</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
        <RootNamespace>UnityEngine</RootNamespace>
        <NoWarn>$(NoWarn);CS1591;CA2255</NoWarn>

		    <!-- NuGet -->
        <IsPackable>true</IsPackable>
        <PackageTags>serializer</PackageTags>
        <Description>Unity shims(Vector3, Color, etc) of MemoryPack.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
    </ItemGroup>

</Project>



================================================
FILE: src/MemoryPack.UnityShims/Shims.cs
================================================
﻿#pragma warning disable SA1307 // Field should begin with upper-case letter
#pragma warning disable SA1300 // Field should begin with upper-case letter
#pragma warning disable IDE1006 // Field should begin with upper-case letter
#pragma warning disable SA1649 // type name matches file name
#pragma warning disable SA1401 // Fields should be private (we need fields rather than auto-properties for .NET Native compilation to work).

using MemoryPack;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace UnityEngine;

[MemoryPackable]
public partial struct Vector2
{
    public float x;
    public float y;

    public Vector2(float x, float y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator +(Vector2 a, Vector2 b)
    {
        return new Vector2(a.x + b.x, a.y + b.y);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator -(Vector2 a, Vector2 b)
    {
        return new Vector2(a.x - b.x, a.y - b.y);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator *(Vector2 a, Vector2 b)
    {
        return new Vector2(a.x * b.x, a.y * b.y);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator /(Vector2 a, Vector2 b)
    {
        return new Vector2(a.x / b.x, a.y / b.y);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator -(Vector2 a)
    {
        return new Vector2(0f - a.x, 0f - a.y);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator *(Vector2 a, float d)
    {
        return new Vector2(a.x * d, a.y * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator *(float d, Vector2 a)
    {
        return new Vector2(a.x * d, a.y * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector2 operator /(Vector2 a, float d)
    {
        return new Vector2(a.x / d, a.y / d);
    }
}


[MemoryPackable]
public partial struct Vector3
{
    public float x;
    public float y;
    public float z;

    public Vector3(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator +(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator -(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator -(Vector3 a)
    {
        return new Vector3(0f - a.x, 0f - a.y, 0f - a.z);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator *(Vector3 a, float d)
    {
        return new Vector3(a.x * d, a.y * d, a.z * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator *(float d, Vector3 a)
    {
        return new Vector3(a.x * d, a.y * d, a.z * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector3 operator /(Vector3 a, float d)
    {
        return new Vector3(a.x / d, a.y / d, a.z / d);
    }
}

[MemoryPackable]
public partial struct Vector4
{
    public float x;
    public float y;
    public float z;
    public float w;

    public Vector4(float x, float y, float z, float w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator +(Vector4 a, Vector4 b)
    {
        return new Vector4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator -(Vector4 a, Vector4 b)
    {
        return new Vector4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator -(Vector4 a)
    {
        return new Vector4(0f - a.x, 0f - a.y, 0f - a.z, 0f - a.w);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator *(Vector4 a, float d)
    {
        return new Vector4(a.x * d, a.y * d, a.z * d, a.w * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator *(float d, Vector4 a)
    {
        return new Vector4(a.x * d, a.y * d, a.z * d, a.w * d);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector4 operator /(Vector4 a, float d)
    {
        return new Vector4(a.x / d, a.y / d, a.z / d, a.w / d);
    }
}

[MemoryPackable]
public partial struct Quaternion
{
    public float x;
    public float y;
    public float z;
    public float w;

    public Quaternion(float x, float y, float z, float w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
}

[MemoryPackable]
public partial struct Color
{
    public float r;
    public float g;
    public float b;
    public float a;

    public Color(float r, float g, float b)
        : this(r, g, b, 1.0f)
    {
    }

    public Color(float r, float g, float b, float a)
    {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
}

[MemoryPackable]
public partial struct Bounds
{
    public Vector3 center;
    public Vector3 extents;

    public Vector3 size
    {
        get
        {
            return this.extents * 2f;
        }

        set
        {
            this.extents = value * 0.5f;
        }
    }

    public Vector3 max
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return center + extents;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            SetMinMax(min, value);
        }
    }

    public Vector3 min
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return center - extents;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            SetMinMax(value, max);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetMinMax(Vector3 min, Vector3 max)
    {
        extents = (max - min) * 0.5f;
        center = min + extents;
    }
}

[MemoryPackable]
public partial struct Rect
{
    public float x;

    public float y;

    public float width;

    public float height;

    public Rect(float x, float y, float width, float height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public Rect(Vector2 position, Vector2 size)
    {
        this.x = position.x;
        this.y = position.y;
        this.width = size.x;
        this.height = size.y;
    }

    public Rect(Rect source)
    {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
    }
}

// same order as ReadMe's SerializableAnimationCurve
[MemoryPackable]
public sealed partial class AnimationCurve
{
    public WrapMode postWrapMode;
    public WrapMode preWrapMode;
    public Keyframe[] keys = default!;

    [MemoryPack.MemoryPackIgnore]
    public int length
    {
        get { return this.keys.Length; }
    }
}

[MemoryPackable]
public partial struct Keyframe
{
    public float time;

    public float value;

    public float inTangent;

    public float outTangent;

    public Keyframe(float time, float value)
    {
        this.time = time;
        this.value = value;
        this.inTangent = 0f;
        this.outTangent = 0f;
    }

    public Keyframe(float time, float value, float inTangent, float outTangent)
    {
        this.time = time;
        this.value = value;
        this.inTangent = inTangent;
        this.outTangent = outTangent;
    }
}

public enum WrapMode
{
    Once = 1,
    Loop,
    PingPong = 4,
    Default = 0,
    ClampForever = 8,
    Clamp = 1,
}

[MemoryPackable]
public partial struct Matrix4x4
{
    public float m00;
    public float m10;
    public float m20;
    public float m30;
    public float m01;
    public float m11;
    public float m21;
    public float m31;
    public float m02;
    public float m12;
    public float m22;
    public float m32;
    public float m03;
    public float m13;
    public float m23;
    public float m33;
}

[MemoryPackable]
public sealed partial class Gradient
{
    public GradientColorKey[] colorKeys = default!;

    public GradientAlphaKey[] alphaKeys = default!;

    public GradientMode mode;
}

public partial struct GradientColorKey
{
    public Color color;
    public float time;

    public GradientColorKey(Color col, float time)
    {
        this.color = col;
        this.time = time;
    }
}

[MemoryPackable]
public partial struct GradientAlphaKey
{
    public float alpha;
    public float time;

    public GradientAlphaKey(float alpha, float time)
    {
        this.alpha = alpha;
        this.time = time;
    }
}

public enum GradientMode
{
    Blend,
    Fixed,
}

[MemoryPackable]
[StructLayout(LayoutKind.Explicit)]
public partial struct Color32
{
    [FieldOffset(0)]
    private int rgba;

    [FieldOffset(0)]
    public byte r;

    [FieldOffset(1)]
    public byte g;

    [FieldOffset(2)]
    public byte b;

    [FieldOffset(3)]
    public byte a;

    public Color32(byte r, byte g, byte b, byte a)
    {
        this.rgba = 0;
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
}

[MemoryPackable]
public sealed partial class RectOffset
{
    public int left;

    public int right;

    public int top;

    public int bottom;

    public RectOffset()
    {
    }

    [MemoryPack.MemoryPackConstructor]
    public RectOffset(int left, int right, int top, int bottom)
    {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
    }
}

[MemoryPackable]
public partial struct LayerMask
{
    public int value;
}

[MemoryPackable]
public partial struct Vector2Int
{
    public int x;
    public int y;

    public Vector2Int(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

[MemoryPackable]
public partial struct Vector3Int
{
    public int x;
    public int y;
    public int z;

    public Vector3Int(int x, int y, int z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public static Vector3Int operator *(Vector3Int a, int d)
    {
        return new Vector3Int(a.x * d, a.y * d, a.z * d);
    }
}

[MemoryPackable]
public partial struct RangeInt
{
    public int start;
    public int length;

    public RangeInt(int start, int length)
    {
        this.start = start;
        this.length = length;
    }
}

[MemoryPackable]
public partial struct RectInt
{
    public int x;

    public int y;

    public int width;

    public int height;

    public RectInt(int x, int y, int width, int height)
    {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public RectInt(Vector2Int position, Vector2Int size)
    {
        this.x = position.x;
        this.y = position.y;
        this.width = size.x;
        this.height = size.y;
    }

    public RectInt(RectInt source)
    {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
    }
}


[MemoryPackable]
public partial struct BoundsInt
{
    public Vector3Int position;

    public Vector3Int size;

    public BoundsInt(Vector3Int position, Vector3Int size)
    {
        this.position = position;
        this.size = size;
    }
}



================================================
FILE: tests/MemoryPack.Tests/ArrayFormatterTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ArrayFormatterTest
{
    private T Convert<T>(T value)
    {
        return MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value))!;
    }

    [Fact]
    public void ArrayTes()
    {
        {
            var xs = new int[] { 1, 10, 100 };
            Convert(xs).Should().Equal(xs);
        }
        {
            var xs = new string[] { "foo", "bar", "baz" };
            Convert(xs).Should().Equal(xs);
        }
        {
            var xs = new ArraySegment<int>(new int[] { 1, 10, 100 });
            Convert(xs).Should().Equal(xs);
        }
        {
            var xs = new int[] { 1, 10, 100 }.AsMemory();
            Convert(xs).ToArray().Should().Equal(xs.ToArray());
        }
        {
            var xs = new ReadOnlyMemory<int>(new int[] { 1, 10, 100 });
            Convert(xs).ToArray().Should().Equal(xs.ToArray());
        }
        //{
        //    var xs = new ReadOnlySequence<int>(new int[] { 1, 10, 100 });
        //    Convert(xs).ToArray().Should().Equal(xs.ToArray());
        //}
        {
            var xs = ReadOnlySequenceBuilder.Create(
                new byte[] { 1, 2, 3 },
                new byte[] { 4, 5, 6, 7, 8 },
                new byte[] { 9, 10 });
            var bin = MemoryPackSerializer.Serialize(xs);
            var xs2 = MemoryPackSerializer.Deserialize<ReadOnlySequence<byte>>(bin);
            Convert(xs2).ToArray().Should().Equal(xs.ToArray());
        }
    }

    [Fact]
    public void CharArrayTest()
    {
        var input = new[] { 'a', 'b', 'c' };
        var bytes = MemoryPackSerializer.Serialize(input);
        var output = MemoryPackSerializer.Deserialize<char[]>(bytes)!;
        Assert.True(input.SequenceEqual(output));
    }

    [Theory]
    [InlineData(100, 100, 10, 5)]
    [InlineData(10, 20, 15, 5)]
    [InlineData(3, 5, 10, 15)]
    public void MultiDimensional(int dataI, int dataJ, int dataK, int dataL)
    {
        var two = new ValueTuple<int, int>[dataI, dataJ];
        var three = new ValueTuple<int, int, int>[dataI, dataJ, dataK];
        var four = new ValueTuple<int, int, int, int>[dataI, dataJ, dataK, dataL];

        for (int i = 0; i < dataI; i++)
        {
            for (int j = 0; j < dataJ; j++)
            {
                two[i, j] = (i, j);
                for (int k = 0; k < dataK; k++)
                {
                    three[i, j, k] = (i, j, k);
                    for (int l = 0; l < dataL; l++)
                    {
                        four[i, j, k, l] = (i, j, k, l);
                    }
                }
            }
        }

        (int, int)[,] cTwo = this.Convert(two);
        (int, int, int)[,,] cThree = this.Convert(three);
        (int, int, int, int)[,,,] cFour = this.Convert(four);

        cTwo.Length.Should().Be(two.Length);
        cThree.Length.Should().Be(three.Length);
        cFour.Length.Should().Be(four.Length);

        for (int i = 0; i < dataI; i++)
        {
            for (int j = 0; j < dataJ; j++)
            {
                cTwo[i, j].Should().Be(two[i, j]);
                for (int k = 0; k < dataK; k++)
                {
                    cThree[i, j, k].Should().Be(three[i, j, k]);
                    for (int l = 0; l < dataL; l++)
                    {
                        cFour[i, j, k, l].Should().Be(four[i, j, k, l]);
                    }
                }
            }
        }
    }

    [Theory]
    [InlineData(100, 100, 10, 5)]
    [InlineData(10, 20, 15, 5)]
    [InlineData(3, 5, 10, 15)]
    public void MultiDimensional2(int dataI, int dataJ, int dataK, int dataL)
    {
        var two = new ValueTuple<ObjectValue, ObjectValue>[dataI, dataJ];
        var three = new ValueTuple<ObjectValue, ObjectValue, ObjectValue>[dataI, dataJ, dataK];
        var four = new ValueTuple<ObjectValue, ObjectValue, ObjectValue, ObjectValue>[dataI, dataJ, dataK, dataL];

        for (int i = 0; i < dataI; i++)
        {
            for (int j = 0; j < dataJ; j++)
            {
                two[i, j] = (i, j);
                for (int k = 0; k < dataK; k++)
                {
                    three[i, j, k] = (i, j, k);
                    for (int l = 0; l < dataL; l++)
                    {
                        four[i, j, k, l] = (i, j, k, l);
                    }
                }
            }
        }

        (ObjectValue, ObjectValue)[,] cTwo = this.Convert(two);
        (ObjectValue, ObjectValue, ObjectValue)[,,] cThree = this.Convert(three);
        (ObjectValue, ObjectValue, ObjectValue, ObjectValue)[,,,] cFour = this.Convert(four);

        cTwo.Length.Should().Be(two.Length);
        cThree.Length.Should().Be(three.Length);
        cFour.Length.Should().Be(four.Length);

        for (int i = 0; i < dataI; i++)
        {
            for (int j = 0; j < dataJ; j++)
            {
                cTwo[i, j].Should().Be(two[i, j]);
                for (int k = 0; k < dataK; k++)
                {
                    cThree[i, j, k].Should().Be(three[i, j, k]);
                    for (int l = 0; l < dataL; l++)
                    {
                        cFour[i, j, k, l].Should().Be(four[i, j, k, l]);
                    }
                }
            }
        }
    }

    [Fact]
    public void MultiDimensionalOverwrite()
    {
        var two = new int[3, 3];
        two[0, 0] = 0;
        two[0, 1] = 1;
        two[0, 2] = 2;
        two[1, 0] = 3;
        two[1, 1] = 4;
        two[1, 2] = 5;
        two[2, 0] = 6;
        two[2, 1] = 7;
        two[2, 2] = 8;

        var bin = MemoryPackSerializer.Serialize(two);
        var refArray = two;

        Array.Clear(two);
        MemoryPackSerializer.Deserialize(bin, ref two);
        Debug.Assert(two != null);
        two.Should().BeSameAs(refArray);
        two[0, 0].Should().Be(0);
        two[0, 1].Should().Be(1);
        two[0, 2].Should().Be(2);
        two[1, 0].Should().Be(3);
        two[1, 1].Should().Be(4);
        two[1, 2].Should().Be(5);
        two[2, 0].Should().Be(6);
        two[2, 1].Should().Be(7);
        two[2, 2].Should().Be(8);
    }
}

[MemoryPackable]
public partial class ObjectValue : IEquatable<ObjectValue>
{
    public int Value { get; }

    public ObjectValue(int value)
    {
        this.Value = value;
    }

    public static implicit operator ObjectValue(int value) { return new ObjectValue(value); }
    public static implicit operator int(ObjectValue value) { return value.Value; }

    public override string ToString()
    {
        return Value.ToString();
    }

    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }

    public bool Equals(ObjectValue? other)
    {
        if (other == null) return false;
        return Value == other;
    }
}



================================================
FILE: tests/MemoryPack.Tests/ArrayTest.cs
================================================
﻿using MemoryPack.Tests.Models;
using Newtonsoft.Json;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ArrayTest
{
    [Fact]
    public void Check()
    {
        var checker = new ArrayCheck
        {
            Array1 = new[] { 1, 10, -1000, int.MaxValue, int.MinValue },
            Array2 = new int?[] { 300, null, -99999, null, 234242 },
            Array3 = new[] { "foo", "bar", "baz", "", "t" },
            Array4 = new[] { "zzzz", null, "", "あいうえお" }
        };

        var bin = MemoryPackSerializer.Serialize(checker);
        var v2 = MemoryPackSerializer.Deserialize<ArrayCheck>(bin);

        v2!.Array1.Should().Equal(checker.Array1);
        v2!.Array2.Should().Equal(checker.Array2);
        v2!.Array3.Should().Equal(checker.Array3);
        v2!.Array4.Should().Equal(checker.Array4);
    }

    [Fact]
    public void Check2()
    {
        var checker = new ArrayOptimizeCheck()
        {
            Array1 = new[] { new StandardTypeTwo { One = 9, Two = 2 }, new StandardTypeTwo { One = 999, Two = 444 } },
            List1 = new List<StandardTypeTwo?> { new StandardTypeTwo { One = 93, Two = 12 }, new StandardTypeTwo { One = 9499, Two = 45344 } }
        };

        var bin = MemoryPackSerializer.Serialize(checker);
        var v2 = MemoryPackSerializer.Deserialize<ArrayOptimizeCheck>(bin);
#pragma warning disable CS8602
        v2!.Array1[0].One.Should().Be(checker.Array1[0].One);
        v2!.Array1[0].Two.Should().Be(checker.Array1[0].Two);
        v2!.Array1[1].One.Should().Be(checker.Array1[1].One);
        v2!.Array1[1].Two.Should().Be(checker.Array1[1].Two);

        v2!.List1[0].One.Should().Be(checker.List1[0].One);
        v2!.List1[0].Two.Should().Be(checker.List1[0].Two);
        v2!.List1[1].One.Should().Be(checker.List1[1].One);
        v2!.List1[1].Two.Should().Be(checker.List1[1].Two);
    }

    [Fact]
    public void BoolArray()
    {
        var rand = new Random();
        for (int i = 0; i < 1000; i++)
        {
            var data = Enumerable.Range(0, i).Select(_ => rand.Next(0, 2) == 0).ToArray();
            var value = new BitPackSingleData { Data = data };

            var bin = MemoryPackSerializer.Serialize(value);
            var value2 = MemoryPackSerializer.Deserialize<BitPackSingleData>(bin);

            value2.Data.Should().Equal(data);
        }
        for (int i = 0; i < 1000; i++)
        {
            var data = Enumerable.Range(0, i).Select(_ => rand.Next(0, 2) == 0).ToArray();
            var value = new BitPackData { Data = data, AAA = i };

            var bin = MemoryPackSerializer.Serialize(value);
            var value2 = MemoryPackSerializer.Deserialize<BitPackData>(bin);

            value2.Data.Should().Equal(data);
            value2.AAA.Should().Be(i);
        }
    }

    //[Fact]
    //public void MemoryOwnerTest()
    //{
    //    var memow = MemoryPool<byte>.Shared.Rent(100);



    //    var bin = MemoryPackSerializer.Serialize(memow);
    //    var value2 = MemoryPackSerializer.Deserialize<IMemoryOwner<byte>>(bin);



    //}
}





[MemoryPackable]
public partial class BitPackData
{
    [BitPackFormatter]
    public bool[]? Data { get; set; }
    public int AAA { get; set; }
}

[MemoryPackable]
public partial class BitPackSingleData
{
    [BitPackFormatter]
    public bool[]? Data { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/BrotliTest.cs
================================================
﻿using MemoryPack.Compression;
using System;
using System.Buffers;
using System.IO.Compression;

namespace MemoryPack.Tests;

public class BrotliTest
{
    [Fact]
    public void LargeByteArray()
    {
        var data = new SaveData();

        var bin = data.MemCmpSerialize();
        data.MemDecmpDeserialize(bin);
    }

    [Fact]
    public void EncodeEmptyCntent()
    {
        var buffer = new ArrayBufferWriter<byte>();
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);

        using var compressor = new BrotliCompressor(CompressionLevel.Fastest);
        compressor.CopyTo(ref writer);

        using var decompressor = new BrotliDecompressor();
        decompressor.Decompress(compressor.ToArray()).ToArray().Should().BeEmpty();
    }

    [Fact]
    public void EncodeEmptyFinalBlock()
    {
        using var state = MemoryPackWriterOptionalStatePool.Rent(null);

        var compressor = new BrotliCompressor(CompressionLevel.Fastest);
        var coWriter = new MemoryPackWriter<BrotliCompressor>(ref compressor, state);

        var bytes = new byte[248];
        Random.Shared.NextBytes(bytes);
        coWriter.WriteUnmanagedArray(bytes);
        coWriter.Flush();

        var buffer = new ArrayBufferWriter<byte>();
        compressor.CopyTo(buffer);

        using var readerState = MemoryPackReaderOptionalStatePool.Rent(null);
        using var decompressor = new BrotliDecompressor();
        var decompressed = decompressor.Decompress(compressor.ToArray());
        var reader = new MemoryPackReader(in decompressed, readerState);

        reader.ReadArray<byte>().Should().BeEquivalentTo(bytes);
        compressor.Dispose();
    }
}

[MemoryPackable]
public partial class SaveData
{
    public byte[] Areas = new byte[10000000];

    public SaveData()
    {
        var rnd = new Random(1000);
        for (int i = 0; i < Areas.Length; ++i)
        {
            // if (rnd.Next() % 2 != 0) continue;
            Areas[i] = (byte)(rnd.Next() % 256);
        }
    }

    public byte[] MemCmpSerialize()
    {
        using var cp = new BrotliCompressor();
        MemoryPackSerializer.Serialize(cp, this);
        return cp.ToArray();
    }

    public bool MemDecmpDeserialize(byte[] bin)
    {
        try
        {
            using var dcp = new BrotliDecompressor();
            var buffer = dcp.Decompress(bin);
            var data = MemoryPackSerializer.Deserialize<SaveData>(buffer);
            if (data is null) return false;
            Array.Copy(data.Areas, this.Areas, data.Areas.Length);
        }
        catch
        {
            return false;
        }
        return true;
    }
}



================================================
FILE: tests/MemoryPack.Tests/CircularReferenceTest.cs
================================================
﻿#pragma warning disable CS8602

using MemoryPack.Tests.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.Json;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class CircularReferenceTest
{
    [Fact]
    public void MicrosoftExample()
    {
        // https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0

        Employee tyler = new()
        {
            Name = "Tyler Stein"
        };

        Employee adrian = new()
        {
            Name = "Adrian King"
        };

        tyler.DirectReports = new List<Employee> { adrian };
        adrian.Manager = tyler;

        var bin = MemoryPackSerializer.Serialize(tyler);
        Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);

        tylerDeserialized?.DirectReports?[0].Manager.Should().BeSameAs(tylerDeserialized);
    }

    [Fact]
    public void NodeTest()
    {
        var parent = new Node();
        var a1 = new Node();
        var a2 = new Node();
        var a3 = new Node();
        a1.Parent = parent;
        a2.Parent = parent;
        a3.Parent = parent;
        parent.Children = new[] { a1, a2, a3 };

        var bin = MemoryPackSerializer.Serialize(parent);
        var value2 = MemoryPackSerializer.Deserialize<Node>(bin);

        foreach (var item in value2!.Children)
        {
            item.Parent.Should().BeSameAs(value2);
        }
    }

    [Fact]
    public void PureNodeTest()
    {
        var node = new PureNode() { Id = 10, Id2 = 1000 };

        var bin = MemoryPackSerializer.Serialize(node);
        var value2 = MemoryPackSerializer.Deserialize<PureNode>(bin);

        value2.Id.Should().Be(10);
        value2.Id2.Should().Be(1000);
    }

    [Fact]
    public void InHolder()
    {
        var holder = new CircularHolder();
        holder.List = new List<Node>();
        holder.ListPure = new List<PureNode>();

        {
            var parent = new Node();
            var a1 = new Node();
            var a2 = new Node();
            var a3 = new Node();
            a1.Parent = parent;
            a2.Parent = parent;
            a3.Parent = parent;
            parent.Children = new[] { a1, a2, a3 };

            var parent2 = new Node();
            parent2.Children = new[] { parent, a2 };

            holder.List.AddRange(new[] { parent, parent, parent2, parent, parent2 });
        }
        {
            var pure1 = new PureNode() { Id = 10, Id2 = 1000 };
            var pure2 = new PureNode() { Id = 100, Id2 = 100000 };

            holder.ListPure.Add(pure1);
            holder.ListPure.Add(pure1);
            holder.ListPure.Add(pure2);
            holder.ListPure.Add(pure2);
            holder.ListPure.Add(pure1);
        }


        var bin = MemoryPackSerializer.Serialize(holder);
        var value2 = MemoryPackSerializer.Deserialize<CircularHolder>(bin);

        {
            var parent = value2.List[0];
            var parent2 = value2.List[2];
            var a1 = parent.Children[0];
            var a2 = parent.Children[1];
            var a3 = parent.Children[2];

            parent.Should().NotBeSameAs(parent2);
            parent2.Children[0].Should().BeSameAs(parent);
            parent2.Children[1].Should().BeSameAs(a2);
        }
        {
            var pure1 = value2.ListPure[0];
            var pure2 = value2.ListPure[2];

            pure1.Should().NotBeSameAs(pure2);
            pure1.Should().BeSameAs(value2.ListPure[1]);
            pure1.Should().BeSameAs(value2.ListPure[4]);
            pure2.Should().BeSameAs(value2.ListPure[3]);
        }
    }

    [Fact]
    public void Sequential()
    {
        SequentialCircularReference tyler = new()
        {
            Name = "Tyler Stein"
        };

        SequentialCircularReference adrian = new()
        {
            Name = "Adrian King"
        };

        tyler.DirectReports = new List<SequentialCircularReference> { adrian };
        adrian.Manager = tyler;

        var bin = MemoryPackSerializer.Serialize(tyler);
        SequentialCircularReference? tylerDeserialized = MemoryPackSerializer.Deserialize<SequentialCircularReference>(bin);

        tylerDeserialized?.DirectReports?[0].Manager.Should().BeSameAs(tylerDeserialized);
    }

}



================================================
FILE: tests/MemoryPack.Tests/CollectionFormatterTest.cs
================================================
﻿using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using Xunit.Sdk;

namespace MemoryPack.Tests;

public class CollectionFormatterTest
{
    void CollectionEqual<T>(T value)
        where T : IEnumerable<int>
    {
        var bin = MemoryPackSerializer.Serialize(value);
        var value2 = MemoryPackSerializer.Deserialize<T>(bin);
        value2.Should().Equal(value);
    }

    void CollectionEqualReference<T>(ref T? value, Action<T?> clear)
        where T : class, IEnumerable<int>
    {
        var bin = MemoryPackSerializer.Serialize(value);
        var original = value;
        clear(value);
        var expected = MemoryPackSerializer.Deserialize<T>(bin);
        MemoryPackSerializer.Deserialize<T>(bin, ref value);
        value.Should().Equal(expected);
        value.Should().BeSameAs(original);
    }

    [Fact]
    public void List()
    {
        var list = new List<int>() { 1, 2, 3, 4, 5 };
        var bin = MemoryPackSerializer.Serialize(list);

        // no ref
        MemoryPackSerializer.Deserialize<List<int>>(bin).Should().Equal(list);

        // ref and same length
        var list2 = new List<int>() { 10, 20, 30, 40, 50 };
        MemoryPackSerializer.Deserialize(bin, ref list2);
        list2.Should().Equal(list);

        // ref and differenct length
        var list3 = new List<int>() { 99, 98, 97 };
        MemoryPackSerializer.Deserialize(bin, ref list3);
        list3.Should().Equal(list);
    }

    [Fact]
    public void Stack()
    {
        void Push(Stack<int> stack, params int[] values)
        {
            foreach (var item in values)
            {
                stack.Push(item);
            }
        }

        var stack = new Stack<int>();
        Push(stack, 1, 2, 3, 4, 5);
        var bin = MemoryPackSerializer.Serialize(stack);

        // no ref
        MemoryPackSerializer.Deserialize<Stack<int>>(bin).Should().Equal(stack);

        // ref and same length
        var stack2 = new Stack<int>();
        Push(stack2, 10, 20, 30, 40, 50);
        MemoryPackSerializer.Deserialize(bin, ref stack2);
        stack2.Should().Equal(stack);

        // ref and differenct length
        var stack3 = new Stack<int>();
        Push(stack3, 99, 98, 97);
        MemoryPackSerializer.Deserialize(bin, ref stack3);
        stack3.Should().Equal(stack);
    }

    [Fact]
    public void Queue()
    {
        var q = new Queue<int>();
        q.Enqueue(1);
        q.Enqueue(2);
        q.Enqueue(3);
        q.Enqueue(4);
        q.Enqueue(5);

        CollectionEqual(q);
        CollectionEqualReference(ref q, x => x!.Clear());
    }

    [Fact]
    public void LinkedList()
    {
        var list = new LinkedList<int>();
        list.AddLast(1);
        list.AddLast(2);
        list.AddLast(3);
        list.AddLast(4);
        list.AddLast(5);

        CollectionEqual(list);
        CollectionEqualReference(ref list, x => list!.Clear());
    }

    [Fact]
    public void HashSet()
    {
        var collection = new HashSet<int>();
        collection.Add(1);
        collection.Add(2);
        collection.Add(3);
        collection.Add(4);
        collection.Add(5);

        CollectionEqual(collection);
        CollectionEqualReference(ref collection, x => collection!.Clear());
    }

#if NET7_0_OR_GREATER

    [Fact]
    public void PriorityQueue()
    {
        var collection = new PriorityQueue<int, int>();
        collection.Enqueue(1, 10);
        collection.Enqueue(2, 4);
        collection.Enqueue(3, 1231);
        collection.Enqueue(4, 5);
        collection.Enqueue(5, 7);

        var bin = MemoryPackSerializer.Serialize(collection);
        var v2 = MemoryPackSerializer.Deserialize<PriorityQueue<int, int>>(bin);

        Debug.Assert(v2 != null);
        collection.Dequeue().Should().Be(v2.Dequeue());
        collection.Dequeue().Should().Be(v2.Dequeue());
        collection.Dequeue().Should().Be(v2.Dequeue());
        collection.Dequeue().Should().Be(v2.Dequeue());
        collection.Dequeue().Should().Be(v2.Dequeue());
    }

#endif

    [Fact]
    public void Collection()
    {
        {
            var collection = new ObservableCollection<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection);
            CollectionEqualReference(ref collection, x => collection!.Clear());
        }
        {
            var collection = new Collection<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection);
            CollectionEqualReference(ref collection, x => collection!.Clear());
        }
        {
            var collection = new ConcurrentQueue<int>();
            collection.Enqueue(1);
            collection.Enqueue(2);
            collection.Enqueue(3);
            collection.Enqueue(4);
            collection.Enqueue(5);
            CollectionEqual(collection);
            CollectionEqualReference(ref collection, x => collection!.Clear());
        }
        {
            var collection = new ConcurrentStack<int>();
            collection.Push(1);
            collection.Push(2);
            collection.Push(3);
            collection.Push(4);
            collection.Push(5);
            CollectionEqual(collection);
            CollectionEqualReference(ref collection, x => collection!.Clear());
        }
        {
            var collection = new ConcurrentBag<int> { 1, 2, 3, 4, 5 };

            var bin = MemoryPackSerializer.Serialize(collection);
            // not gurantees order
            MemoryPackSerializer.Deserialize<Stack<int>>(bin).Should().BeEquivalentTo(collection);
        }
        {
            var collection = new ReadOnlyCollection<int>(new[] { 1, 2, 3, 4, 5 });
            CollectionEqual(collection);
        }
        {
            var collection = new ReadOnlyObservableCollection<int>(new ObservableCollection<int> { 1, 2, 3, 4, 5 });
            CollectionEqual(collection);
        }
        {
            var collection = new BlockingCollection<int>() { 1, 2, 3, 4, 5 };
            CollectionEqual(collection);
        }
    }

    [Fact]
    public void Dictionary()
    {
        {
            var dict = new Dictionary<int, int>()
            {
                { 1, 2 }, { 3, 4 }, { 4, 5 }, { 6, 7 }, { 8, 9 }
            };

            var bin = MemoryPackSerializer.Serialize(dict);
            MemoryPackSerializer.Deserialize<Dictionary<int, int>>(bin).Should().BeEquivalentTo(dict);
        }
        {
            var dict = new SortedDictionary<int, int>()
            {
                { 1, 2 }, { 3, 4 }, { 4, 5 }, { 6, 7 }, { 8, 9 }
            };

            var bin = MemoryPackSerializer.Serialize(dict);
            MemoryPackSerializer.Deserialize<SortedDictionary<int, int>>(bin).Should().BeEquivalentTo(dict);
        }
        {
            var dict = new SortedList<int, int>()
            {
                { 1, 2 }, { 3, 4 }, { 4, 5 }, { 6, 7 }, { 8, 9 }
            };

            var bin = MemoryPackSerializer.Serialize(dict);
            MemoryPackSerializer.Deserialize<SortedList<int, int>>(bin).Should().BeEquivalentTo(dict);
        }
        {
            var dict = new ConcurrentDictionary<int, int>();
            dict.TryAdd(1, 2);
            dict.TryAdd(2, 4);
            dict.TryAdd(30, 5);
            dict.TryAdd(4, 8);

            var bin = MemoryPackSerializer.Serialize(dict);
            MemoryPackSerializer.Deserialize<ConcurrentDictionary<int, int>>(bin).Should().BeEquivalentTo(dict);
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/CompressionTest.cs
================================================
﻿using MemoryPack.Compression;
using MemoryPack.Tests.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class CompressionTest
{
    [Fact]
    public async Task CompressDecompress()
    {
        // pattern1, huge compression
        var pattern1 = Enumerable.Range(1, 1000).Select(_ => string.Concat(Enumerable.Repeat("http://", 1000)))
            .Prepend("hogehogehugahugahugahugahogehoge!")
            .ToArray();

        // pattern2, small compression
        var pattern2 = new string[] { "a", "b", "c" };

        var texts = new[] { pattern1, pattern2 };
        foreach (var text in texts)
        {
#if NET7_0_OR_GREATER
            using var brotli = new BrotliCompressor();
#else
            using var brotli = new BrotliCompressor(CompressionLevel.Fastest);
#endif

            MemoryPackSerializer.Serialize(brotli, text);

            var originalSerialized = MemoryPackSerializer.Serialize(text);

            var array1 = brotli.ToArray();

            var arrayWriter = new ArrayBufferWriter<byte>();
            brotli.CopyTo(arrayWriter);

            var array2 = arrayWriter.WrittenMemory;

            // check BrotliCompressor ToArray()/CopyTo returns same result.
            array1.AsSpan().SequenceEqual(array2.Span).Should().BeTrue();

            var stream = new MemoryStream();
            await brotli.CopyToAsync(stream);
            stream.ToArray().AsSpan().SequenceEqual(array2.Span).Should().BeTrue();

            using var decompressor = new BrotliDecompressor();

            var decompressed = decompressor.Decompress(array1);

            var referenceDecompress = ReferenceDecompress(array1);
            var decompressedArray = decompressed.ToArray();

            // check decompress results correct
            referenceDecompress.SequenceEqual(decompressedArray).Should().BeTrue();

            originalSerialized.AsSpan().SequenceEqual(decompressed.ToArray()).Should().BeTrue();

            // deserialized check
            var more = MemoryPackSerializer.Deserialize<string[]>(decompressed);

            text.Length.Should().Be(more!.Length);
            foreach (var (first, second) in text.Zip(more))
            {
                first.AsSpan().SequenceEqual(second).Should().BeTrue();
            }
        }
    }

    [Fact]
    public void AttributeCompression()
    {

        // pattern1, huge compression
        var pattern1 = Enumerable.Range(1, 1000).Select(_ => string.Concat(Enumerable.Repeat("http://", 1000)))
            .Prepend("hogehogehugahugahugahugahogehoge!")
            .ToArray();

        // pattern2, small compression
        var pattern2 = new string[] { "a", "b", "c" };

        foreach (var pattern in new[] { pattern1, pattern2 })
        {
            var data = new CompressionAttrData()
            {
                Id1 = 14141,
                Data = Encoding.UTF8.GetBytes(string.Concat(pattern)),
                String = string.Concat(pattern),
                Id2 = 99999
            };

            var bin = MemoryPackSerializer.Serialize(data);
            var v2 = MemoryPackSerializer.Deserialize<CompressionAttrData>(bin)!;

            v2.Id1.Should().Be(data.Id1);
            v2.Id2.Should().Be(data.Id2);
            v2.Data.Should().Equal(data.Data);
            v2.String.Should().Be(data.String);
        }
    }

#if NET7_0_OR_GREATER

    [Fact]
    public void AttributeCompression2()
    {

        // pattern1, huge compression
        var pattern1 = Enumerable.Range(1, 1000).Select(_ => string.Concat(Enumerable.Repeat("http://", 1000)))
            .Prepend("hogehogehugahugahugahugahogehoge!")
            .ToArray();

        // pattern2, small compression
        var pattern2 = new string[] { "a", "b", "c" };

        foreach (var pattern in new[] { pattern1, pattern2 })
        {
            var data = new CompressionAttrData2()
            {
                Id1 = 14141,
                Data = Encoding.UTF8.GetBytes(string.Concat(pattern)),
                Two = new StandardTypeTwo { One = 9999, Two = 1111 },
                String = string.Concat(pattern),
                Id2 = 99999
            };

            var bin = MemoryPackSerializer.Serialize(data);

            {
                var v2 = MemoryPackSerializer.Deserialize<CompressionAttrData2>(bin)!;

                v2.Id1.Should().Be(data.Id1);
                v2.Id2.Should().Be(data.Id2);
                v2.Data.Should().Equal(data.Data);
                v2.String.Should().Be(data.String);

                v2.Two.One.Should().Be(data.Two.One);
                v2.Two.Two.Should().Be(data.Two.Two);
            }
            {
                var seq = ReadOnlySequenceBuilder.Create(bin.Chunk(bin.Length / 5).ToArray());

                var v2 = MemoryPackSerializer.Deserialize<CompressionAttrData2>(seq)!;

                v2.Id1.Should().Be(data.Id1);
                v2.Id2.Should().Be(data.Id2);
                v2.Data.Should().Equal(data.Data);
                v2.String.Should().Be(data.String);

                v2.Two.One.Should().Be(data.Two.One);
                v2.Two.Two.Should().Be(data.Two.Two);
            }
        }
    }

#endif

    byte[] ReferenceDecompress(byte[] bytes)
    {
        using (var ms = new MemoryStream(bytes))
        using (var brotli = new BrotliStream(ms, CompressionMode.Decompress))
        {
            var dest = new MemoryStream();
            brotli.CopyTo(dest);
            return dest.ToArray();
        }
    }
}


[MemoryPackable]
public partial class CompressionAttrData
{
    public int Id1 { get; set; }

    [BrotliFormatter]
    public byte[] Data { get; set; } = default!;

    [BrotliStringFormatter]
    public string String { get; set; } = default!;

    public int Id2 { get; set; }
}

#if NET7_0_OR_GREATER

[MemoryPackable]
public partial class CompressionAttrData2
{
    public int Id1 { get; set; }

    [BrotliFormatter]
    public byte[] Data { get; set; } = default!;

    [BrotliStringFormatter]
    public string String { get; set; } = default!;

    [BrotliFormatter<StandardTypeTwo>]
    public StandardTypeTwo Two { get; set; } = default!;

    public int Id2 { get; set; }
}

#endif



================================================
FILE: tests/MemoryPack.Tests/ConstructorTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;
public class ConstructorTest
{
    [Fact]
    public void SkipOrder()
    {
        var a = new Alpha { B1 = new Beta(10) };
        var bin = MemoryPackSerializer.Serialize(a);
        var v2 = MemoryPackSerializer.Deserialize<Alpha>(bin);
        v2!.B1!.Value1.Should().Be(10);
    }
}


[MemoryPackable(GenerateType.CircularReference)]
public partial class Alpha
{
    [MemoryPackOrder(1)]
    public Beta? B1 { get; set; }

    public Alpha()
    {

    }

}

// ctor for VersionTolerant, Skipped order

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class Beta
{
    [MemoryPackOrder(1)]
    public int Value1 { get; set; }

    public Beta(int value1)
    {
        this.Value1 = value1;
    }
}

// support underscore private/internal convention

[MemoryPackable]
public partial class Gamma
{
    [MemoryPackInclude]
    private readonly string _test;

    public Gamma(string test)
    {
        _test = test;
    }
}



================================================
FILE: tests/MemoryPack.Tests/CustomCollectionTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class CustomCollectionTest
{
    T Convert<T>(T value)
    {
        var bin = MemoryPackSerializer.Serialize(value);
        return MemoryPackSerializer.Deserialize<T>(bin)!;
    }

    [Fact]
    public void NonGenerics()
    {
        var l = new ListInt { 1, 2, 3, 4, 5, 6, 7 };
        Convert(l).Should().Equal(l);

        var s = new SetInt { 1, 10, 20, 30 };
        Convert(s).Should().Equal(s);

        var d = new DictionaryIntInt { { 1, 10 }, { 2, 30 }, { 65, 2342 } };
        Convert(d).Should().Equal(d);
    }

    [Fact]
    public void Generics()
    {
        var l = new ListGenerics<int> { 1, 2, 3, 4, 5, 6, 7 };
        Convert(l).Should().Equal(l);

        var s = new SetGenerics<int> { 1, 10, 20, 30 };
        Convert(s).Should().Equal(s);

        var d = new DictionaryGenerics<int, int> { { 1, 10 }, { 2, 30 }, { 65, 2342 } };
        Convert(d).Should().Equal(d);
    }

}

[MemoryPackable(GenerateType.Collection)]
public partial class ListInt : List<int>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class SetInt : HashSet<int>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class DictionaryIntInt : Dictionary<int, int>
{
}


[MemoryPackable(GenerateType.Collection)]
public partial class ListGenerics<T> : List<T>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class SetGenerics<T> : HashSet<T>
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class DictionaryGenerics<TK, TV> : Dictionary<TK, TV>
    where TK : notnull
{
}



================================================
FILE: tests/MemoryPack.Tests/CustomFormatterTest.cs
================================================
﻿#pragma warning disable CS8602

using MemoryPack.Tests.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.X86;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class CustomFormatterTest
{
    [Fact]
    public void Check()
    {
        var value = new CustomFormatterCheck()
        {
            NoMarkField = "aaaa",
            Field1 = "aaaa",
            Prop1 = "bbbb",
            NoMarkProp = "bbbb",
            PropDict = new Dictionary<string, int> { { "ZooM", 999 }, { "DdddN", 10000 } },
            FieldDict = new Dictionary<string, string> { { "hOGe", "hugahuga" }, { "HagE", "nanonano" } },
        };


        var bin1 = MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf8);
        var bin2 = MemoryPackSerializer.Serialize(value, MemoryPackSerializerOptions.Utf16);

        var v1 = MemoryPackSerializer.Deserialize<CustomFormatterCheck>(bin1);
        var v2 = MemoryPackSerializer.Deserialize<CustomFormatterCheck>(bin2);

#if NET7_0_OR_GREATER
        v1.PropDict["zoom"].Should().Be(999);
        v1.PropDict["DDDDN"].Should().Be(10000);
        v1.FieldDict["HOGE"].Should().Be("hugahuga");
        v1.FieldDict["hage"].Should().Be("nanonano");
#endif

        v1.Prop1.Should().Be(value.Prop1);
        v1.Field1.Should().Be(value.Field1);
        v2.Prop1.Should().Be(value.Prop1);
        v2.Field1.Should().Be(value.Field1);
    }

#if NET7_0_OR_GREATER

    [Fact]
    public void Pool()
    {
        var forPool = new MemoryPoolModel(
            new[] { 1, 10, 100, 100, 10000 },
            Encoding.UTF8.GetBytes("あいうえおかきくけこさしすせそ"),
            new[] { "aaa", "bbb", "DDDDDDDDDDDDDD", "あいうえおか" },
            new[] { new StdData { MyProperty = 10 }, new StdData { MyProperty = 99 } }
        );

        var bin = MemoryPackSerializer.Serialize(forPool);
        var v2 = MemoryPackSerializer.Deserialize<MemoryPoolModel>(bin);

        //v2.Pool1.Length
        MemoryMarshal.TryGetArray<int>(v2.Pool1, out var seg1).Should().BeTrue();
        MemoryMarshal.TryGetArray<byte>(v2.Pool2, out var seg2).Should().BeTrue();
        MemoryMarshal.TryGetArray(v2.Pool3, out var seg3).Should().BeTrue();
        MemoryMarshal.TryGetArray(v2.Pool4, out var seg4).Should().BeTrue();

        seg1.Array.Length.Should().Be(PoolSize(forPool.Pool1.Length));
        seg2.Array.Length.Should().Be(PoolSize(forPool.Pool2.Length));
        seg3.Array.Length.Should().Be(PoolSize(forPool.Pool3.Length));
        seg4.Array.Length.Should().Be(PoolSize(forPool.Pool4.Length));

        v2.Pool1.ToArray().Should().Equal(forPool.Pool1.ToArray());
        v2.Pool2.ToArray().Should().Equal(forPool.Pool2.ToArray());
        v2.Pool3.ToArray().Should().Equal(forPool.Pool3.ToArray());

        v2.Pool4.Span[0].MyProperty.Should().Be(forPool.Pool4.Span[0].MyProperty);
        v2.Pool4.Span[1].MyProperty.Should().Be(forPool.Pool4.Span[1].MyProperty);

        v2.Dispose();
        v2.Dispose();
    }

    int PoolSize(int size)
    {
        size = BitOperations.Log2((uint)size - 1 | 15) - 3;
        return 16 << size;
    }

#endif
}
#if NET7_0_OR_GREATER

[MemoryPackable]
public partial class MemoryPoolModel : IDisposable
{
    [MemoryPoolFormatter<int>]
    public Memory<int> Pool1 { get; private set; }
    [MemoryPoolFormatter<byte>]
    public Memory<byte> Pool2 { get; private set; }
    [ReadOnlyMemoryPoolFormatter<string>]
    public ReadOnlyMemory<string> Pool3 { get; private set; }
    [ReadOnlyMemoryPoolFormatter<StdData>]
    public ReadOnlyMemory<StdData> Pool4 { get; private set; }

    bool usePool;

    public MemoryPoolModel(Memory<int> pool1, Memory<byte> pool2, ReadOnlyMemory<string> pool3, ReadOnlyMemory<StdData> pool4)
    {
        Pool1 = pool1;
        Pool2 = pool2;
        Pool3 = pool3;
        Pool4 = pool4;
    }

    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }

    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);

    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }

    public void Dispose()
    {
        if (!usePool) return;

        Return(Pool1); Pool1 = default;
        Return(Pool2); Pool2 = default;
        Return(Pool3); Pool3 = default;
        Return(Pool4); Pool4 = default;
    }
}

[MemoryPackable]
public partial class StdData
{
    public int MyProperty { get; set; }
}

#endif



================================================
FILE: tests/MemoryPack.Tests/DefaultValueTest.cs
================================================
﻿using MemoryPack.Tests.Models;

namespace MemoryPack.Tests;

public class DefaultValueTest
{
    [Fact]
    public void SuppressDefaultInitialization()
    {
        var bin = MemoryPackSerializer.Serialize(new DefaultValuePlaceholder { X = 1 });
        var expected = new HasDefaultValue();
        var deserializedValue = MemoryPackSerializer.Deserialize<HasDefaultValue>(bin)!;
        deserializedValue.Y.Should().Be(default);
        deserializedValue.Z.Should().Be(default);
        deserializedValue.Y2.Should().Be(expected.Y2);
        deserializedValue.Z2.Should().Be(expected.Z2);
    }

    [Fact]
    public void SuppressDefaultInitialization_VersionTolerant()
    {
        var bin = MemoryPackSerializer.Serialize(new DefaultValuePlaceholderWithVersionTolerant { X = 1 });
        var expected = new HasDefaultValueWithVersionTolerant();
        var deserializedValue = MemoryPackSerializer.Deserialize<HasDefaultValueWithVersionTolerant>(bin)!;
        deserializedValue.Y.Should().Be(default);
        deserializedValue.Z.Should().Be(default);
        deserializedValue.Y2.Should().Be(expected.Y2);
        deserializedValue.Z2.Should().Be(expected.Z2);
    }
}



================================================
FILE: tests/MemoryPack.Tests/DeserializeTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public partial class DeserializeTest
{
    [Fact]
    public async Task StreamTest()
    {
        var expected = Enumerable.Range(1, 1000).ToArray();
        var bytes = MemoryPackSerializer.Serialize(expected);

        var stream = new RandomStream(bytes);

        var result = await MemoryPackSerializer.DeserializeAsync<int[]>(stream);
        result.Should().Equal(expected);

        // large size
        expected = Enumerable.Range(1, 100000).ToArray();
        bytes = MemoryPackSerializer.Serialize(expected);

        stream = new RandomStream(bytes);
        result = await MemoryPackSerializer.DeserializeAsync<int[]>(stream);
        result.Should().Equal(expected);
    }

    [Fact]
    public void GenericValueStructTest()
    {
        GenericStruct<int> value = new() { Id = 75, Value = 23 };

        RunMultiSegmentTest(value);
    }

    [Fact]
    public void LargeGenericValueStructTest()
    {
        GenericStruct<PrePaddedInt> value = new() { Id = 75, Value = new PrePaddedInt() { Value = 23 } };

        RunMultiSegmentTest(value);
    }

    [Fact]
    public void GenericReferenceStructTest()
    {
        GenericStruct<string> value = new GenericStruct<string>() { Id = 75, Value = "Hello World!" };

        RunMultiSegmentTest(value);
    }

    [Fact]
    public void LargeGenericReferenceStructTest()
    {
        GenericStruct<PrePaddedString> value = new() { Id = 75, Value = new PrePaddedString() { Value = "Hello World!" } };

        RunMultiSegmentTest(value);
    }

    private void RunMultiSegmentTest<T>(T value)
    {
        byte[] bytes = MemoryPackSerializer.Serialize(value);

        byte[] firstHalf = new byte[bytes.Length / 2];
        Array.Copy(bytes, 0, firstHalf, 0, firstHalf.Length);

        int secondHalfLength = bytes.Length / 2;
        if (bytes.Length % 2 != 0)
        {
            secondHalfLength++;
        }

        byte[] secondHalf = new byte[secondHalfLength];

        Array.Copy(bytes, firstHalf.Length, secondHalf, 0, secondHalfLength);

        ReadOnlySequence<byte> sequence = ReadOnlySequenceBuilder.Create(firstHalf, secondHalf);

        T? result = MemoryPackSerializer.Deserialize<T>(sequence);
        result.Should().Be(value);
    }

    [MemoryPackable]
    public partial struct GenericStruct<T>
    {
        public int Id;
        public T Value;

        public override string ToString()
        {
            return $"{Id}, {Value}";
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 516)]
    struct PrePaddedInt
    {
        [FieldOffset(512)]
        public int Value;
    }

    [MemoryPackable]
    private partial class PrePaddedString : IEquatable<PrePaddedString>
    {
        private PrePaddedInt _padding;
        public string Value { get; set; } = "";

        public bool Equals(PrePaddedString? other)
        {
            if (other is null)
                return false;

            return Value.Equals(other.Value);
        }

        public override bool Equals(object? obj)
        {
            if (obj is PrePaddedString other)
                return Equals(other);
            return false;
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }
    }

    class RandomStream : Stream
    {
        readonly byte[] underlyingBuffer;
        int position;

        public RandomStream(byte[] buffer)
        {
            this.underlyingBuffer = buffer;
        }

        public override bool CanRead => true;

        public override bool CanSeek => false;

        public override bool CanWrite => false;

        public override long Length => underlyingBuffer.Length;

        public override long Position { get => position; set => throw new NotSupportedException(); }

        public override void Flush()
        {
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            var rest = underlyingBuffer.Length - position;
            if (rest == 0) return 0;
            var len = (count > 100) ? Random.Shared.Next(100, count) : count;
            len = Math.Min(len, rest);
            underlyingBuffer.AsSpan(position, len).CopyTo(buffer.AsSpan(offset, count));
            position += len;
            return len;
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/EnumTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class EnumTest
{
    private T Convert<T>(T value)
    {
        return MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value))!;
    }

    [Fact]
    public void EnumTes()
    {
        Convert(BEnum.B).Should().Be(BEnum.B);
        Convert(NormalEnum.A).Should().Be(NormalEnum.A);
        Convert(NotNotEnum.C).Should().Be(NotNotEnum.C);
    }

    public enum BEnum : byte
    {
        A, B, C
    }
    public enum NormalEnum
    {
        A, B, C
    }

    public enum NotNotEnum : long
    {
        A, B, C
    }
}



================================================
FILE: tests/MemoryPack.Tests/FrozenCollectionFormatterTest.cs
================================================
﻿#if NET8_0_OR_GREATER
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Frozen;

namespace MemoryPack.Tests;

public class FrozenCollectionFormatterTest
{
    [Fact]
    public void FrozenSet()
    {
        var set = new HashSet<int>();
        set.Add(1);
        set.Add(2);
        set.Add(3);
        set.Add(4);
        set.Add(5);

        var value = set.ToFrozenSet();
        var bin = MemoryPackSerializer.Serialize(value);
        var deserializedValue = MemoryPackSerializer.Deserialize<FrozenSet<int>>(bin);
        deserializedValue.Should().Equal(value);
    }

    [Fact]
    public void FrozenDictionary()
    {
        var dict = new Dictionary<int, int>()
        {
            { 1, 2 }, { 3, 4 }, { 4, 5 }, { 6, 7 }, { 8, 9 }
        };
        var value = dict.ToFrozenDictionary();
        var bin = MemoryPackSerializer.Serialize(value);
        MemoryPackSerializer.Deserialize<FrozenDictionary<int, int>>(bin).Should().BeEquivalentTo(value);
    }
}
#endif



================================================
FILE: tests/MemoryPack.Tests/Fuzz.cs
================================================
﻿using RandomFixtureKit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class Fuzz
{

    [Fact]
    public void Random()
    {
        var resolvers = new[] { StandardResolver.EdgeCase, StandardResolver.AllowNull, StandardResolver.NonNull, StandardResolver.RandomAll };
        foreach (var resolver in resolvers)
        {
            for (int i = 0; i < 100; i++)
            {
                var v = FixtureFactory.Create<Foo1>(resolver: resolver);
                var bin = MemoryPackSerializer.Serialize(v);
                var v2 = MemoryPackSerializer.Deserialize<Foo1>(bin);
                v.Should().BeEquivalentTo(v2);
            }
        }
    }
}

[MemoryPackable]
internal partial class Foo1
{
    public int MyProperty { get; set; }
#pragma warning disable CS8618
    public string MyProperty2 { get; set; }
    public Foo2 MyProperty3 { get; set; }
    public string MyProperty4 { get; set; }
    public List<Foo2> Foo22 { get; set; }
}

[MemoryPackable]
internal partial class Foo2
{
    public int MyProperty { get; set; }
    public string MyProperty2 { get; set; }
    public Foo3 MyProperty3 { get; set; }
    public string MyProperty4 { get; set; }
    public Dictionary<int, string> Dic { get; set; }
    public List<Foo3> Foo33 { get; set; }
}


[MemoryPackable]
internal partial class Foo3
{
    public int MyProperty { get; set; }
    public long MyPr3operty { get; set; }
    public bool MyProp42erty { get; set; }
    public string MyProperty2 { get; set; }
    public string MyProperty4 { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/GeneratorTest.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Tests.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class GeneratorTest
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    static void NoMember<T>(T? value)
    {
        var bin = MemoryPackSerializer.Serialize(value);
        T? value2 = MemoryPackSerializer.Deserialize<T>(bin);

        value2.Should().NotBeNull();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static T? VerifyEquivalent<T>(T? value)
    {
        var bin = MemoryPackSerializer.Serialize(value);
        T? value2 = MemoryPackSerializer.Deserialize<T>(bin);

        value.Should().BeEquivalentTo(value2);
        return value2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static T? Serdes<T>(T? value)
    {
        var bin = MemoryPackSerializer.Serialize(value);
        return MemoryPackSerializer.Deserialize<T>(bin);
    }

    [Fact]
    public void Standard()
    {
        NoMember(new StandardTypeZero());
        VerifyEquivalent(new StandardTypeOne() { One = 9999 });
        VerifyEquivalent(new StandardTypeTwo() { One = 9999, Two = 111 });
        VerifyEquivalent(new StandardUnmanagedStruct { MyProperty = 1111111 });
        VerifyEquivalent(new StandardStruct { MyProperty = "foobarbaz" });
        VerifyEquivalent(new GlobalNamespaceType() { MyProperty = 10000 });
    }

    [Fact]
    public void Nested()
    {
        VerifyEquivalent(new NestedContainer.StandardTypeNested() { One = 9999 });
        VerifyEquivalent(new DoublyNestedContainer.DoublyNestedContainerInner.StandardTypeDoublyNested() { One = 9999 });
    }

    [Fact]
    public void Null()
    {
        var bin = MemoryPackSerializer.Serialize<StandardTypeOne>(null);
        MemoryPackSerializer.Deserialize<StandardTypeOne>(bin).Should().BeNull();
    }

    [Fact]
    public void Private()
    {
        {
            var v = new NoInclude();
            v.SetAll(10, 20, "foo", "bar", "baz", 99);

            var v2 = Serdes(v);

            v2.Should().NotBeNull();
            v2!.GetAll().Should().Be((10, 20, "foo", "bar", (string?)null, 0));
        }

        {
            var v = new Include();
            v.SetAll(10, 20, "foo", "bar", "baz", 99);

            var v2 = Serdes(v);

            v2.Should().NotBeNull();
            v2!.GetAll().Should().Be((10, 20, "foo", "bar", "baz", 99));
        }
    }

    [Fact]
    public void Ctor()
    {
        VerifyEquivalent(new NoCtor { X = 10 });
        VerifyEquivalent(new OneCtor { X = 10 });
        VerifyEquivalent(new OneCtor2(10, 100));
        VerifyEquivalent(new ExplicitlyCtor(10, 100));

        var v = VerifyEquivalent(new ParameterCheck("foobarbaz") { MyProperty2 = "ttt" });
        v!.IsProp1SetCalled().Should().BeFalse();
    }

    [Fact]
    public void MethodInvoke()
    {
        var mc = new MethodCall();
        MethodCall.Log.Clear();
        var bin = MemoryPackSerializer.Serialize(mc);
        MethodCall.Log.Should().Equal("OnSerializing1", "OnSerializing2", "OnSerializing_M1", "OnSerializing_M2", "Get", "OnSerialized1", "OnSerialized2", "OnSerialized_M1", "OnSerialized_M2");

        MethodCall.Log.Clear();
        MemoryPackSerializer.Deserialize<MethodCall>(bin, ref mc);
        MethodCall.Log.Should().Equal("OnDeserializing1", "OnDeserializing2", "OnDeserializing_M1", "OnDeserializing_M2", "Get", "Set", "OnDeserialized1", "OnDeserialized2", "OnDeserialized_M1", "OnDeserialized_M2");

        MethodCall.Log.Clear();
        MemoryPackSerializer.Deserialize<MethodCall>(bin);
        MethodCall.Log.Should().Equal("OnDeserializing1", "OnDeserializing_M1", "Constructor", "Set", "OnDeserialized1", "OnDeserialized2", "OnDeserialized_M1", "OnDeserialized_M2");

        // allow null
        MethodCall.Log.Clear();
        var bin2 = MemoryPackSerializer.Serialize((MethodCall?)null);
        MethodCall.Log.Should().Equal("OnSerializing1", "OnSerializing_M1", "OnSerialized1", "OnSerialized_M1");

        MethodCall.Log.Clear();
        MemoryPackSerializer.Deserialize<MethodCall>(bin2);
        MethodCall.Log.Should().Equal("OnDeserializing1", "OnDeserializing_M1", "OnDeserialized1", "OnDeserialized_M1");
    }

    [Fact]
    public void Records()
    {
        VerifyEquivalent(new UnmanagedStruct { X = 9, Y = 3, Z = 2222 });
        VerifyEquivalent(new IncludesReferenceStruct { X = 9, Y = "foobarbaz" });
#if NET7_0_OR_GREATER
        VerifyEquivalent(new RequiredType { MyProperty1 = 10, MyProperty2 = "hogemogehuga" });
        VerifyEquivalent(new RequiredType2 { MyProperty1 = 10, MyProperty2 = "hogemogehuga" });
#endif
        VerifyEquivalent(new StructWithConstructor1("foo"));
        VerifyEquivalent(new MyRecord(10, 20, "haa"));
        VerifyEquivalent(new StructRecordUnmanaged(10, 20));
        VerifyEquivalent(new StructRecordWithReference(10, "zzz"));
    }

    [Fact]
    public void Derived()
    {
        VerifyEquivalent(new StandardBase { MyProperty1 = 1, MyProperty2 = 2 });
        VerifyEquivalent(new Derived1 { MyProperty1 = 1, MyProperty2 = 2, DerivedProp1 = 3, DerivedProp2 = 4 });
        VerifyEquivalent(new Derived2 { MyProperty1 = 1, MyProperty2 = 2, DerivedProp1 = 3, DerivedProp2 = 4, Derived2Prop1 = 5, Derived2Prop2 = 6 });
    }

    [Fact]
    public void Union()
    {
        // interface
        {
            IUnionInterface a = new Impl1 { MyProperty = 10, Foo = 999 };
            IUnionInterface b = new Impl2 { MyProperty = 1000, Bar = "foobarbaz" };
            {
                var bin = MemoryPackSerializer.Serialize(a);
                var a1 = MemoryPackSerializer.Deserialize<IUnionInterface>(bin);

                a1.Should().NotBeNull();
                a1!.MyProperty.Should().Be(10);
                (a1 as Impl1)!.Foo.Should().Be(999);
            }
            {
                var bin = MemoryPackSerializer.Serialize(b);
                var b1 = MemoryPackSerializer.Deserialize<IUnionInterface>(bin);

                b1.Should().NotBeNull();
                b1!.MyProperty.Should().Be(1000);
                (b1 as Impl2)!.Bar.Should().Be("foobarbaz");
            }
        }
        // abstract
        {
            UnionAbstractClass a = new ImplA1 { MyProperty = 10, Foo = 999 };
            UnionAbstractClass b = new ImplA2 { MyProperty = 1000, Bar = "foobarbaz" };
            {
                var bin = MemoryPackSerializer.Serialize(a);
                var a1 = MemoryPackSerializer.Deserialize<UnionAbstractClass>(bin);

                a1.Should().NotBeNull();
                a1!.MyProperty.Should().Be(10);
                (a1 as ImplA1)!.Foo.Should().Be(999);
            }
            {
                var bin = MemoryPackSerializer.Serialize(b);
                var b1 = MemoryPackSerializer.Deserialize<UnionAbstractClass>(bin);

                b1.Should().NotBeNull();
                b1!.MyProperty.Should().Be(1000);
                (b1 as ImplA2)!.Bar.Should().Be("foobarbaz");
            }
        }
    }

    [Fact]
    public void Versioning()
    {
        var v0 = new Versioning0();
        var v1 = new Versioning1() { MyProperty1 = 999 };
        var v2 = new Versioning2() { MyProperty1 = 10, MyProperty2 = 33333 };
        var v3 = new Versioning3() { MyProperty1 = 4, MyProperty2 = 55, MyProperty3 = 24442 };
        var v4 = new Versioning4() { MyProperty1 = 10000, MyProperty2 = 3, MyProperty3 = 4252, MyProperty4 = 99999 };

        var bin0 = MemoryPackSerializer.Serialize(v0);
        var bin1 = MemoryPackSerializer.Serialize(v1);
        var bin2 = MemoryPackSerializer.Serialize(v2);
        var bin3 = MemoryPackSerializer.Serialize(v3);
        var bin4 = MemoryPackSerializer.Serialize(v4);

        // small -> large is ok.
        var v0Tov4 = MemoryPackSerializer.Deserialize<Versioning4>(bin0);
        var v1Tov4 = MemoryPackSerializer.Deserialize<Versioning4>(bin1);
        var v2Tov4 = MemoryPackSerializer.Deserialize<Versioning4>(bin2);
        var v3Tov4 = MemoryPackSerializer.Deserialize<Versioning4>(bin3);
        var v4Tov4 = MemoryPackSerializer.Deserialize<Versioning4>(bin4);

        v0Tov4.Should().NotBeNull();
        v1Tov4.Should().BeEquivalentTo(v1);
        v2Tov4.Should().BeEquivalentTo(v2);
        v3Tov4.Should().BeEquivalentTo(v3);
        v4Tov4.Should().BeEquivalentTo(v4);

        // large -> small is ng
        Assert.Throws<MemoryPackSerializationException>(() => MemoryPackSerializer.Deserialize<Versioning2>(bin3));

        // check wrapped
        var w2 = new WrappedVersioning2 { Before = "BF", V2 = v2, After = "AF" };
        var binw2 = MemoryPackSerializer.Serialize(w2);

        var w4 = MemoryPackSerializer.Deserialize<WrappedVersioning4>(binw2);

        w4!.Before.Should().Be("BF");
        w4!.V4!.MyProperty1.Should().Be(v2.MyProperty1);
        w4!.V4!.MyProperty2.Should().Be(v2.MyProperty2);
        w4!.V4!.MyProperty3.Should().Be(0);
        w4!.V4!.MyProperty4.Should().Be(0);
        w4!.After.Should().Be("AF");
    }

    [Fact]
    public void Recursive()
    {
        var rec = new Recursive() { MyProperty = 99 };
        var rec2 = new Recursive() { MyProperty = 1000 };
        rec.Rec = rec2;

        // ok to serialize
        var bin = MemoryPackSerializer.Serialize(rec);
        var newRec = MemoryPackSerializer.Deserialize<Recursive>(bin);

        Debug.Assert(newRec != null);
        newRec.MyProperty.Should().Be(99);
        newRec.Rec!.MyProperty.Should().Be(1000);
        newRec.Rec!.Rec.Should().BeNull();

        //set rec
        rec.Rec = rec;
        Assert.Throws<MemoryPackSerializationException>(() => MemoryPackSerializer.Serialize(rec));
    }

    [Fact]
    public void ManyMemebrs()
    {
        MemoryPackSerializer.Serialize(new ManyMembers());
    }

    [Fact]
    public void Generics()
    {
        var gt = new GenericsType<string>()
        {
            MyProperty1 = 2,
            MyProperty2 = "hogehoge"
        };

        VerifyEquivalent(gt);

        var comp = new MoreComplecsGenerics<int, string>()
        {
            Dict = new Dictionary<int, GenericsType<string>>{
                { 3, new GenericsType<string>{ MyProperty1 = 10, MyProperty2 = "tako" } },
                { 9, new GenericsType<string>{ MyProperty1 = 99, MyProperty2 = "yaki" } },
            }
        };

        var bin = MemoryPackSerializer.Serialize(comp);
        var two = MemoryPackSerializer.Deserialize<MoreComplecsGenerics<int, string>>(bin);

        Debug.Assert(two != null);
        (two.Dict![3] is { MyProperty1: 10, MyProperty2: "tako" }).Should().BeTrue();
        (two.Dict![9] is { MyProperty1: 99, MyProperty2: "yaki" }).Should().BeTrue();

        // union
        var a = new GenricUnionA<long>() { Value = 9999999, MyProperty = 10000 };
        var b = new GenricUnionB<long>() { Value = 1111111, MyProperty = 99.9932 };

        var binA = MemoryPackSerializer.Serialize<IGenericUnion<long>>(a);
        var binB = MemoryPackSerializer.Serialize<IGenericUnion<long>>(b);

        var a2 = MemoryPackSerializer.Deserialize<IGenericUnion<long>>(binA);
        var b2 = MemoryPackSerializer.Deserialize<IGenericUnion<long>>(binB);

        a2.Should().BeOfType<GenricUnionA<long>>().Subject.Should().BeEquivalentTo(new { Value = (long)9999999, MyProperty = 10000 });
        b2.Should().BeOfType<GenricUnionB<long>>().Subject.Should().BeEquivalentTo(new { Value = (long)1111111, MyProperty = 99.9932 });
    }

    [Fact]
    public void Overwrite()
    {
        var v1 = new Overwrite()
        {
            MyProperty1 = 10,
            MyProperty2 = 100,
            MyProperty3 = "foo",
            MyProperty4 = "bar"
        };

        var v2 = new Overwrite2()
        {
            MyProperty1 = 11,
            MyProperty2 = 101,
            MyProperty3 = "foz",
            MyProperty4 = "baz"
        };

        var v3 = new Overwrite3(14, 130)
        {
            MyProperty3 = "fzo",
            MyProperty4 = "bzr"
        };

        var v4 = new Overwrite4()
        {
            MyProperty1 = 19,
            MyProperty2 = v1
        };

        var bin = MemoryPackSerializer.Serialize(v1);

        v1.MyProperty1 = 999;
        v1.MyProperty2 = 100000;
        v1.MyProperty3 = "foooooo";
        v1.MyProperty4 = "barrrrrrrrr";

        var v1_original = v1;
        MemoryPackSerializer.Deserialize(bin, ref v1);
        Debug.Assert(v1 != null);
        v1.MyProperty1.Should().Be(10);
        v1.MyProperty2.Should().Be(100);
        v1.MyProperty3.Should().Be("foo");
        v1.MyProperty4.Should().Be("bar");

        v1.Should().BeSameAs(v1_original);

        VerifyEquivalent(v2);
        VerifyEquivalent(v3).Should().NotBeSameAs(v3);

        var bin2 = MemoryPackSerializer.Serialize(v4);
        var v4_original = v4;
        v4.MyProperty1 = 9999;

        MemoryPackSerializer.Deserialize(bin2, ref v4);
        Debug.Assert(v4 != null);
        v4.MyProperty1.Should().Be(19);
        v4.MyProperty2.Should().BeSameAs(v1);

        v1.Should().BeSameAs(v1_original);

    }
}



================================================
FILE: tests/MemoryPack.Tests/ImmutableCollectionFormatterTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ImmutableCollectionFormatterTest
{
    T? Convert<T>(T? value)
    {
        var bin = MemoryPackSerializer.Serialize(value);
        return MemoryPackSerializer.Deserialize<T>(bin);
    }

    TAs? ConvertAs<T, TAs>(T? value, TAs dummy)
        where T : TAs
    {
        var bin = MemoryPackSerializer.Serialize<TAs>(value);
        return MemoryPackSerializer.Deserialize<TAs>(bin);
    }

    [Fact]
    public void Collection()
    {
        {
            var value = ImmutableArray.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
        }
        {
            var value = ImmutableList.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableList<int>)).Should().Equal(value);
        }
        {
            var value = ImmutableQueue.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableQueue<int>)).Should().Equal(value);
        }
        {
            var value = ImmutableStack.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableStack<int>)).Should().Equal(value);
        }
        {
            var value = ImmutableHashSet.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableSet<int>)).Should().Equal(value);
        }
        {
            var value = ImmutableSortedSet.Create(1, 10, 100, 2, 4, 530, 647, 73, 8, 42);
            Convert(value).Should().Equal(value);
        }
    }

    [Fact]
    public void Dictionary()
    {
        {
            var value = ImmutableDictionary.CreateRange(new KeyValuePair<int, int>[]
            {
                new(1, 10),
                new(2, 20),
                new(3, 30),
                new(5, 50),
            });

            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableDictionary<int,int>)).Should().Equal(value);
        }
        {
            var value = ImmutableSortedDictionary.CreateRange(new KeyValuePair<int, int>[]
            {
                new(1, 10),
                new(2, 20),
                new(3, 30),
                new(5, 50),
            });

            Convert(value).Should().Equal(value);
            ConvertAs(value, default(IImmutableDictionary<int, int>)).Should().Equal(value);
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/InterfaceFormatterTest.cs
================================================
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class InterfaceFormatterTest
{
    void CollectionEqual<T, TSerializeAs>(T value, TSerializeAs? dummy)
        where T : TSerializeAs
        where TSerializeAs : IEnumerable<int>
    {
        var bin = MemoryPackSerializer.Serialize<TSerializeAs>(value);
        var value2 = MemoryPackSerializer.Deserialize<TSerializeAs>(bin);
        value2.Should().Equal(value);
    }

    [Fact]
    public void EnumerableTest()
    {
        // Array
        {
            var collection = new[] { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(IEnumerable<int>));
        }

        // List
        {
            var collection = new List<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(IEnumerable<int>));
        }

        // Has Count
        {
            var collection = new ObservableCollection<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(IEnumerable<int>));
        }

        // No Count
        {
            var collection = Iterate(1, 5);
            CollectionEqual(collection, default(IEnumerable<int>));
        }
    }

    [Fact]
    public void CollectionTest()
    {
        // Array
        {
            var collection = new[] { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(ICollection<int>));
        }

        // List
        {
            var collection = new List<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(ICollection<int>));
        }

        // Has Count
        {
            var collection = new ObservableCollection<int> { 1, 2, 3, 4, 5 };
            CollectionEqual(collection, default(ICollection<int>));
        }
    }

    [Fact]
    public void Collections()
    {
        var collection = new ObservableCollection<int> { 1, 2, 3, 4, 5 };
        CollectionEqual(collection, default(IReadOnlyCollection<int>));
        CollectionEqual(collection, default(IList<int>));
        CollectionEqual(collection, default(IReadOnlyList<int>));
    }

    [Fact]
    public void Dictionaries()
    {
        var collection = new Dictionary<int, int> { { 1, 2 }, { 3, 4 }, { 5, 6 } };

        {
            var bin = MemoryPackSerializer.Serialize<IDictionary<int, int>>(collection);
            MemoryPackSerializer.Deserialize<IDictionary<int, int>>(bin)
                .Should().BeEquivalentTo(collection);
        }
        {
            var bin = MemoryPackSerializer.Serialize<IReadOnlyDictionary<int, int>>(collection);
            MemoryPackSerializer.Deserialize<IReadOnlyDictionary<int, int>>(bin)
                .Should().BeEquivalentTo(collection);
        }
    }

    [Fact]
    public void Lookup()
    {
        var seq = new[]
        {
            (1, 2), (1, 100), (3, 42), (45, 30), (3, 10)
        };

        var lookup = seq.ToLookup(x => x.Item1, x => x.Item2);
        {
            var bin = MemoryPackSerializer.Serialize(lookup);
            MemoryPackSerializer.Deserialize<ILookup<int, int>>(bin)
                .Should().BeEquivalentTo(lookup);
        }

        var grouping = lookup.First(x => x.Key == 3);
        {
            var bin = MemoryPackSerializer.Serialize(grouping);
            var g2 = MemoryPackSerializer.Deserialize<IGrouping<int, int>>(bin);
            g2!.Key.Should().Be(grouping.Key);
            g2.AsEnumerable().Should().BeEquivalentTo(grouping.AsEnumerable());
        }

        var emptyLookup = Array.Empty<int>().ToLookup(x => x, x => x);
        {
            var bin = MemoryPackSerializer.Serialize(emptyLookup);
            var deserialized = MemoryPackSerializer.Deserialize<ILookup<int, int>>(bin);
            deserialized![0].Should().BeEmpty();
        }
    }

    [Fact]
    public void Sets()
    {
        var collection = new HashSet<int> { 1, 10, 100, 1000, 10000, 20, 200 };

        {
            var bin = MemoryPackSerializer.Serialize<ISet<int>>(collection);
            MemoryPackSerializer.Deserialize<ISet<int>>(bin)
                .Should().BeEquivalentTo(collection);
        }
#if NET7_0_OR_GREATER
        {
            var bin = MemoryPackSerializer.Serialize<IReadOnlySet<int>>(collection);
            MemoryPackSerializer.Deserialize<IReadOnlySet<int>>(bin)
                .Should().BeEquivalentTo(collection);
        }

#endif
    }

    IEnumerable<int> Iterate(int from, int to)
    {
        for (int i = from; i <= to; i++)
        {
            yield return i;
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/MemoryLayoutTest.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace MemoryPack.Tests;

public class MemoryLayoutTest
{
#if NET7_0_OR_GREATER

    [Fact]
    public void Default()
    {
        Unsafe.SizeOf<DateTimeParamDefault>().Should().Be(32);

        var (offset1, offset2, offset3) = GetOffsets();

        offset1.Should().Be(0);
        offset2.Should().Be(16);
        offset3.Should().Be(24);
    }

    [Fact]
    public void Sequential()
    {
        Unsafe.SizeOf<DateTimeParamSequential>().Should().Be(32);

        var (offset1, offset2, offset3) = GetOffsetsSequential();

        offset1.Should().Be(0);
        offset2.Should().Be(16);
        offset3.Should().Be(24);
    }

#else

    // https://github.com/dotnet/runtime/issues/44579
    [Fact]
    public void SequentialLayoutPromotedToAutoInBeforeNet7()
    {
        var defaultOffsets = GetOffsets();
        var sequentialOffsets = GetOffsetsSequential();
        var autoOffsets = GetOffsetsAuto();

        defaultOffsets.Should().Be(sequentialOffsets);
        defaultOffsets.Should().Be(autoOffsets);
    }

#endif

    [Fact]
    public void Auto()
    {
        Unsafe.SizeOf<DateTimeParamAuto>().Should().Be(32);

        var (offset1, offset2, offset3) = GetOffsetsAuto();

        offset1.Should().Be(16);
        offset2.Should().Be(0);
        offset3.Should().Be(8);
    }

    [Fact]
    public void Explicit()
    {
        Unsafe.SizeOf<DateTimeParamExplicit>().Should().Be(25);

        var (offset1, offset2, offset3) = GetOffsetsExplicit();

        offset1.Should().Be(9);
        offset2.Should().Be(1);
        offset3.Should().Be(0);
    }

    [Fact]
    public void DateTimeOffsetLayout()
    {
        // if this tast fail, runtime auto layout was changed.
        var dto = new DateTimeOffset(2012, 11, 3, 4, 12, 8, TimeSpan.FromHours(9));
        var data = MemoryMarshal.AsBytes(MemoryMarshal.CreateSpan(ref dto, 1)).ToArray();
        data.Should().Equal(new byte[] { 28, 2, 0, 0, 0, 0, 0, 0, 0, 180, 89, 22, 69, 135, 207, 8 });
    }

    // can not use Marshal.OffsetOf because has AutoLayout field

    static unsafe (int, int, int) GetOffsets()
    {
        var value = default(DateTimeParamDefault);
        var basePointer = Unsafe.AsPointer(ref value);

        var dtPointer = Unsafe.AsPointer(ref value.DateTime);
        var timestampPointer = Unsafe.AsPointer(ref value.Timestamp);
        var isItInSecondsPointer = Unsafe.AsPointer(ref value.IsItInSeconds);

        var offset1 = (int)((nuint)dtPointer - (nuint)basePointer);
        var offset2 = (int)((nuint)timestampPointer - (nuint)basePointer);
        var offset3 = (int)((nuint)isItInSecondsPointer - (nuint)basePointer);
        return (offset1, offset2, offset3);
    }

    static unsafe (int, int, int) GetOffsetsSequential()
    {
        var value = default(DateTimeParamSequential);
        var basePointer = Unsafe.AsPointer(ref value);

        var dtPointer = Unsafe.AsPointer(ref value.DateTime);
        var timestampPointer = Unsafe.AsPointer(ref value.Timestamp);
        var isItInSecondsPointer = Unsafe.AsPointer(ref value.IsItInSeconds);

        var offset1 = (int)((nuint)dtPointer - (nuint)basePointer);
        var offset2 = (int)((nuint)timestampPointer - (nuint)basePointer);
        var offset3 = (int)((nuint)isItInSecondsPointer - (nuint)basePointer);
        return (offset1, offset2, offset3);
    }

    static unsafe (int, int, int) GetOffsetsAuto()
    {
        var value = default(DateTimeParamAuto);
        var basePointer = Unsafe.AsPointer(ref value);

        var dtPointer = Unsafe.AsPointer(ref value.DateTime);
        var timestampPointer = Unsafe.AsPointer(ref value.Timestamp);
        var isItInSecondsPointer = Unsafe.AsPointer(ref value.IsItInSeconds);

        var offset1 = (int)((nuint)dtPointer - (nuint)basePointer);
        var offset2 = (int)((nuint)timestampPointer - (nuint)basePointer);
        var offset3 = (int)((nuint)isItInSecondsPointer - (nuint)basePointer);
        return (offset1, offset2, offset3);
    }

    static unsafe (int, int, int) GetOffsetsExplicit()
    {
        var value = default(DateTimeParamExplicit);
        var basePointer = Unsafe.AsPointer(ref value);

        var dtPointer = Unsafe.AsPointer(ref value.DateTime);
        var timestampPointer = Unsafe.AsPointer(ref value.Timestamp);
        var isItInSecondsPointer = Unsafe.AsPointer(ref value.IsItInSeconds);

        var offset1 = (int)((nuint)dtPointer - (nuint)basePointer);
        var offset2 = (int)((nuint)timestampPointer - (nuint)basePointer);
        var offset3 = (int)((nuint)isItInSecondsPointer - (nuint)basePointer);
        return (offset1, offset2, offset3);
    }
}

public struct DateTimeParamDefault
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Sequential)]
public struct DateTimeParamSequential
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Auto)]
public struct DateTimeParamAuto
{
    public DateTimeOffset DateTime; // short offset(2+padding) + dateTime/ulong(8) = 16
    public long Timestamp;  // 8
    public bool IsItInSeconds; // 1(+padding7) = 8
}

[StructLayout(LayoutKind.Explicit, Size = 25)]
public struct DateTimeParamExplicit
{
    [FieldOffset(9)]
    public DateTimeOffset DateTime;
    [FieldOffset(1)]
    public long Timestamp;  // 8
    [FieldOffset(0)]
    public bool IsItInSeconds; // 1
}



================================================
FILE: tests/MemoryPack.Tests/MemoryPack.Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="FluentAssertions" Version="6.7.0" />
        <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.4.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.3.1" />
        <PackageReference Include="RandomFixtureKit" Version="1.0.1" />
        <PackageReference Include="xunit" Version="2.4.2" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\MemoryPack.Core\MemoryPack.Core.csproj" />
        <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj" />
            <ProjectReference Include="..\..\src\MemoryPack.Generator\MemoryPack.Generator.csproj">
            <OutputItemType>Analyzer</OutputItemType>
            <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
        </ProjectReference>
        <ProjectReference Include="..\..\src\MemoryPack.Streaming\MemoryPack.Streaming.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Using Include="Xunit" />
        <Using Include="Xunit.Abstractions" />
        <Using Include="FluentAssertions" />
        <Using Include="MemoryPack" />
        <Using Include="MemoryPack.Tests.Utils" />
    </ItemGroup>
</Project>



================================================
FILE: tests/MemoryPack.Tests/MethodRefTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
//using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class MethodRefTest
{
    [Fact]
    public void WriteId()
    {
        var data = new EmitIdData { MyProperty = 9999 };
        var bin = MemoryPackSerializer.Serialize(data);

        EmitIdData.privateData = Guid.Empty;
        var v2 = MemoryPackSerializer.Deserialize<EmitIdData>(bin);
        v2!.MyProperty.Should().Be(data.MyProperty);

        EmitIdData.privateData.Should().NotBe(Guid.Empty);
    }

    [Fact]
    public void ReadOther()
    {
        var data = new EmitFromOther();
        data.Set(9999);

        var reference = new EmitFromOther();
        EmitFromOther.other = reference;

        var bin = MemoryPackSerializer.Serialize(data);


        var v2 = MemoryPackSerializer.Deserialize<EmitFromOther>(bin);
        v2!.MyProperty.Should().Be(data.MyProperty);

        v2!.Should().BeSameAs(reference);
    }
}

[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }

    public static Guid privateData;

    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // emit GUID in header.
    }

    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // read custom header before deserialize
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
        privateData = guid;
    }
}


[MemoryPackable]
public partial class EmitFromOther
{
    public static EmitFromOther other;

    public int MyProperty { get; private set; }

    public void Set(int v)
    {
        MyProperty = v;
    }

    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitFromOther? value)
    {
        value = other!;
    }
}



================================================
FILE: tests/MemoryPack.Tests/NonGenerics.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class NonGenerics
{
    [Fact]
    public void StandardBin()
    {
        var mc = new[] { new MyClass<ForeE> { MyProperty = ForeE.C } };
        var bin = MemoryPackSerializer.Serialize(mc.GetType(), mc);


        var v2 = MemoryPackSerializer.Deserialize(mc.GetType(), bin) as MyClass<ForeE>[];
        var v3 = MemoryPackSerializer.Deserialize<MyClass<ForeE>[]>(bin);

        v2![0].MyProperty.Should().Be(ForeE.C);
        v3![0].MyProperty.Should().Be(ForeE.C);
    }

    // https://github.com/Cysharp/MemoryPack/issues/98
    [Fact]
    public async Task StreamCheck()
    {
        using var ms = new MemoryStream();

        // Generic version works
        await MemoryPackSerializer.SerializeAsync(ms, new Item());

        // Non generic version throws MemoryPackSerializationException: System.Object is not registered in this provider.
        await MemoryPackSerializer.SerializeAsync(typeof(Item), ms, new Item());

     
    }
}

[MemoryPackable]
public partial class MyClass<T>
{
    public T? MyProperty { get; set; }
}

[MemoryPackable]
public partial record Item
{
    public string Value { get; init; } = Guid.NewGuid().ToString();
}

public enum ForeE
{
    A, B, C
}



================================================
FILE: tests/MemoryPack.Tests/OverwriteTest.cs
================================================
﻿using MemoryPack.Tests.Models;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class OverwriteTest
{
    [Fact]
    public void Objects()
    {
        {
            var write = new Overwrite()
            {
                MyProperty1 = 10,
                MyProperty2 = 20,
                MyProperty3 = "foo",
                MyProperty4 = "bar"
            };

            var bin = MemoryPackSerializer.Serialize(write);

            write.MyProperty1 = 99;
            write.MyProperty2 = 9999;
            write.MyProperty3 = "hoahoahoa";
            write.MyProperty4 = "kukukukuku";

            var original = write;
            MemoryPackSerializer.Deserialize<Overwrite>(bin, ref write);

            Debug.Assert(write != null);
            write.MyProperty1.Should().Be(10);
            write.MyProperty2.Should().Be(20);
            write.MyProperty3.Should().Be("foo");
            write.MyProperty4.Should().Be("bar");

            // same reference
            original.Should().BeSameAs(write);
        }
        {
            var write = new Overwrite2()
            {
                MyProperty1 = 10,
                MyProperty2 = 20,
                MyProperty3 = "foo",
                MyProperty4 = "bar"
            };

            var bin = MemoryPackSerializer.Serialize(write);

            write.MyProperty1 = 99;
            write.MyProperty2 = 9999;
            write.MyProperty3 = "hoahoahoa";
            write.MyProperty4 = "kukukukuku";

            MemoryPackSerializer.Deserialize<Overwrite2>(bin, ref write);

            write.MyProperty1.Should().Be(10);
            write.MyProperty2.Should().Be(20);
            write.MyProperty3.Should().Be("foo");
            write.MyProperty4.Should().Be("bar");
        }
        {
            var write = new Overwrite3(10, 20)
            {
                MyProperty3 = "foo",
                MyProperty4 = "bar"
            };

            var bin = MemoryPackSerializer.Serialize(write);

            write.MyProperty1 = 99;
            write.MyProperty2 = 9999;
            write.MyProperty3 = "hoahoahoa";
            write.MyProperty4 = "kukukukuku";

            var original = write;
            MemoryPackSerializer.Deserialize<Overwrite3>(bin, ref write);

            Debug.Assert(write != null);
            write.MyProperty1.Should().Be(10);
            write.MyProperty2.Should().Be(20);
            write.MyProperty3.Should().Be("foo");
            write.MyProperty4.Should().Be("bar");

            // not same reference
            original.Should().NotBeSameAs(write);
        }
        {
            var write = new Overwrite4()
            {
                MyProperty1 = 4444,
                MyProperty2 = new Overwrite()
                {
                    MyProperty1 = 10,
                    MyProperty2 = 20,
                    MyProperty3 = "foo",
                    MyProperty4 = "bar"
                },
                MyProperty3 = new List<int> { 1, 5, 9 }
            };

            var bin = MemoryPackSerializer.Serialize(write);

            write.MyProperty1 = 5555;
            write.MyProperty2.MyProperty1 = 99;
            write.MyProperty2.MyProperty2 = 9999;
            write.MyProperty2.MyProperty3 = "hoahoahoa";
            write.MyProperty2.MyProperty4 = "kukukukuku";
            write.MyProperty3.Add(99999);

            var original = write;
            MemoryPackSerializer.Deserialize<Overwrite4>(bin, ref write);

            Debug.Assert(write != null);
            Debug.Assert(write.MyProperty2 != null);
            Debug.Assert(write.MyProperty3 != null);

            write.MyProperty1.Should().Be(4444);
            write.MyProperty2.MyProperty1.Should().Be(10);
            write.MyProperty2.MyProperty2.Should().Be(20);
            write.MyProperty2.MyProperty3.Should().Be("foo");
            write.MyProperty2.MyProperty4.Should().Be("bar");
            write.MyProperty3.Should().Equal(1, 5, 9);

            original.Should().BeSameAs(write);
            original.MyProperty2.Should().BeSameAs(write.MyProperty2);
            original.MyProperty3.Should().BeSameAs(write.MyProperty3);
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/PrimitiveTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class PrimitiveTest
{
    [Fact]
    public void ArrayWriterInt()
    {
        var buffer = new ArrayBufferWriter<byte>(1024);

        MemoryPackSerializer.Serialize(buffer, 123);

        buffer.WrittenCount.Should().Be(4);

        var i = MemoryPackSerializer.Deserialize<int>(buffer.WrittenSpan);
        i.Should().Be(123);
    }

    [Fact]
    public void NonGenericInt()
    {
        var bin = MemoryPackSerializer.Serialize(123);
        var i = MemoryPackSerializer.Deserialize<int>(bin);
        i.Should().Be(123);

        var j = (int)MemoryPackSerializer.Deserialize(typeof(int), bin)!;
        j.Should().Be(123);
    }
}



================================================
FILE: tests/MemoryPack.Tests/ProviderTest.cs
================================================
﻿#if NET7_0_OR_GREATER

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ProviderTest
{
    [Fact]
    public void AnonymousType()
    {
        Assert.Throws<MemoryPackSerializationException>(() =>
        MemoryPackSerializer.Serialize(new { foo = 10, bar = "tako" })).Message.Should().Contain("anonymous type");
    }

    [Fact]

    public void RegisterAs()
    {
        MemoryPackFormatterProvider.RegisterGenericType(typeof(CustomType<>), typeof(CustomTypeFormatter<>));

        var t = new CustomType<int>() { Value = 9999 };
        var bin = MemoryPackSerializer.Serialize(t);
        MemoryPackSerializer.Deserialize<CustomType<int>>(bin)!.Value.Should().Be(9999);
    }

    //[Fact]
    //public void RegisterGenericTest()
    //{
    //    MemoryPackFormatterProvider.RegisterCollection<MyList, int>();

    //    var list = new MyList { 1, 10, 100 };


    //    var bin = MemoryPackSerializer.Serialize(list);
    //    var foo = MemoryPackSerializer.Deserialize<MyList>(bin);
    //}

}

public class CustomType<T>
{
    public T? Value { get; set; }
}

public class CustomTypeFormatter<T> : MemoryPackFormatter<CustomType<T?>>
    where T : notnull
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref CustomType<T?>? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        writer.WriteObjectHeader(1);
        writer.WriteValue<T>(value.Value);
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref CustomType<T?>? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }
        if (count != 1) MemoryPackSerializationException.ThrowInvalidPropertyCount(1, count);

        value = new CustomType<T?> { Value = reader.ReadValue<T>() };
    }
}

public class MyList : List<int>
{
}

#endif



================================================
FILE: tests/MemoryPack.Tests/ReaderTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ReaderTest
{
    [Fact]
    public void ReadFromSequence()
    {
        var seq = ReadOnlySequenceBuilder.Create(
            new byte[] { 1, 2, 3 },
            new byte[] { 4, 5, 6, 7, 8 },
            new byte[] { 9, 10 });

        using var state = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(seq, state);

        reader.GetRemainingSource(out var single, out var multi);
        single.Length.Should().Be(0);
        multi.ToArray().Should().Equal(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        ref var spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(1, 2);
        reader.Advance(2);
        reader.GetRemainingSource(out single, out multi);
        single.Length.Should().Be(0);
        multi.ToArray().Should().Equal(3, 4, 5, 6, 7, 8, 9, 10);

        spanRef = ref reader.GetSpanReference(4);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 4).ToArray().Should().Equal(3, 4, 5, 6);
        reader.Advance(4);
        reader.GetRemainingSource(out single, out multi);
        single.Length.Should().Be(0);
        multi.ToArray().Should().Equal(7, 8, 9, 10);

        spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(7, 8);
        reader.Advance(2);
        reader.GetRemainingSource(out single, out multi);
        single.Length.Should().Be(2);
        single.ToArray().Should().Equal(9, 10);

        spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(9, 10);
        reader.Advance(2); // end
        reader.GetRemainingSource(out single, out multi);
        single.Length.Should().Be(0);
        multi.Length.Should().Be(0);

        bool error = false;
        try
        {
            reader.GetSpanReference(1);
        }
        catch (MemoryPackSerializationException)
        {
            error = true;
        }
        error.Should().BeTrue();
    }

    [Fact]
    public void ReadFromSpan()
    {
        using var state = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, state);

        ref var spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(1, 2);
        reader.Advance(2);

        spanRef = ref reader.GetSpanReference(4);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 4).ToArray().Should().Equal(3, 4, 5, 6);
        reader.Advance(4);

        spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(7, 8);
        reader.Advance(2);

        spanRef = ref reader.GetSpanReference(2);
        MemoryMarshal.CreateReadOnlySpan(ref spanRef, 2).ToArray().Should().Equal(9, 10);
        reader.Advance(2); // end

        bool error = false;
        try
        {
            reader.GetSpanReference(1);
        }
        catch (MemoryPackSerializationException)
        {
            error = true;
        }
        error.Should().BeTrue();
    }

    [Fact]
    public void OverAdvance()
    {
        using var state = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(new byte[] { 1, 2, 3 }, state);
        reader.Advance(2); // ok

        bool error = false;
        try
        {
            reader.Advance(10); // ng
        }
        catch (MemoryPackSerializationException)
        {
            error = true;
        }
        error.Should().BeTrue();
    }

    [Fact]
    public void ValidateInvalidLengthTest()
    {
        // int[] but invalid length
        // 2(len), 99, 9999
        var bytes = MemoryPackSerializer.Serialize(new[] { 99, 9999 });

        using var state = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(bytes, state);

        reader.TryReadCollectionHeader(out var len).Should().BeTrue();
        len.Should().Be(2);

        reader.ReadUnmanaged(out int v1, out int v2);
        v1.Should().Be(99);
        v2.Should().Be(9999);

        // inject invalid length
        BinaryPrimitives.WriteInt32LittleEndian(bytes, 1000); // 1000(len), 99, 9999
        using var state2 = MemoryPackReaderOptionalStatePool.Rent(null);
        reader = new MemoryPackReader(bytes, state2);

        try
        {
            reader.TryReadCollectionHeader(out var len2);
            Assert.Fail("should throw");
        }
        catch (MemoryPackSerializationException) { }

        // just
        bytes = MemoryPackSerializer.Serialize(new byte[] { 99 });
        using var state3 = MemoryPackReaderOptionalStatePool.Rent(null);
        reader = new MemoryPackReader(bytes, state3);
        reader.TryReadCollectionHeader(out var len3);
        len3.Should().Be(1);

        BinaryPrimitives.WriteInt32LittleEndian(bytes, 2);
        using var state4 = MemoryPackReaderOptionalStatePool.Rent(null);
        reader = new MemoryPackReader(bytes, state4);

        try
        {
            reader.TryReadCollectionHeader(out var len4);
            Assert.Fail("should throw");
        }
        catch (MemoryPackSerializationException) { }
    }

    [Fact]
    public void PeekIsNull()
    {
        var bin = MemoryPackSerializer.Serialize<string>(null);

        using var state = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(bin, state);

        var isNull = reader.PeekIsNull();
        isNull.Should().BeTrue();
    }
}



================================================
FILE: tests/MemoryPack.Tests/ReflectionTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class ReflectionTest
{
    [Fact]
    public void InvokeExplicitInterface()
    {
        var type = typeof(ReflecCheck);

#if NET7_0_OR_GREATER
        var m = type.GetMethod("MemoryPack.IMemoryPackFormatterRegister.RegisterFormatter", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
        m.Should().NotBeNull();

        var p = type.GetProperty("global::MemoryPack.IFixedSizeMemoryPackable.Size", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
        p.Should().NotBeNull();
#else
        var m = type.GetMethod("RegisterFormatter", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
        m.Should().NotBeNull();
#endif
    }
}

[MemoryPackable]
public partial class ReflecCheck
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/SerializerStructBufferWriterTest.cs
================================================
﻿using System;
using System.Buffers;
using MemoryPack.Tests.Models;

namespace MemoryPack.Tests;

public class SerializerStructBufferWriterTest
{
    [Fact]
    public void Serialize_ShouldSupportStructAsBufferWriter_WhenValueIsNotReferenceAndNotContainsReferences()
    {
        var writer = new TestBufferWriter();
        MemoryPackSerializer.Serialize(writer, 16);
        Assert.Equal(4, writer.WrittenSize);
    }

    [Fact]
    public void Serialize_ShouldSupportStructAsBufferWriter_WhenValueIsUnmanagedSZArray()
    {
        var writer = new TestBufferWriter();
        MemoryPackSerializer.Serialize(writer, new UnmanagedStruct[] { new() { X = 1, Y = 2, Z = 3 } });
        Assert.Equal(16, writer.WrittenSize);
    }

    [Fact]
    public void Serialize_ShouldSupportStructAsBufferWriter_WhenFormatterRequired()
    {
        var writer = new TestBufferWriter();
        MemoryPackSerializer.Serialize(writer, new TestData(1));
        Assert.Equal(5, writer.WrittenSize);
    }
}

[MemoryPackable]
public partial record TestData(int A);

public struct TestBufferWriter : IBufferWriter<byte>
{
    public int WrittenSize = 0;

    public TestBufferWriter()
    {
    }

    public void Advance(int count)
    {
        WrittenSize += count;
    }

    public Memory<byte> GetMemory(int sizeHint = 0)
    {
        throw new InvalidOperationException();
    }

    public Span<byte> GetSpan(int sizeHint = 0)
    {
        return new byte[sizeHint];
    }
}



================================================
FILE: tests/MemoryPack.Tests/StreamOptimizeTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class StreamOptimizeTest
{
    [Fact]
    public async Task MemoryStream()
    {
        var ms = new MemoryStream();
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 1, 2, 3 });
        var offset = ms.Position;
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 10, 20, 30 });
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 40, 50, 60 });

        ms.Position = offset;

        var data1 = await MemoryPackSerializer.DeserializeAsync<int[]>(ms);
        var data2 = await MemoryPackSerializer.DeserializeAsync<int[]>(ms);

        data1.Should().Equal(10, 20, 30);
        data2.Should().Equal(40, 50, 60);
    }

    [Fact]
    public async Task MemoryStreamNoGenerics()
    {
        var ms = new MemoryStream();
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 1, 2, 3 });
        var offset = ms.Position;
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 10, 20, 30 });
        await MemoryPackSerializer.SerializeAsync(ms, new[] { 40, 50, 60 });

        ms.Position = offset;

        var data1 = (int[]?)await MemoryPackSerializer.DeserializeAsync(typeof(int[]), ms);
        var data2 = (int[]?)await MemoryPackSerializer.DeserializeAsync(typeof(int[]), ms);

        data1.Should().Equal(10, 20, 30);
        data2.Should().Equal(40, 50, 60);
    }
}



================================================
FILE: tests/MemoryPack.Tests/StringTest.cs
================================================
[Binary file]


================================================
FILE: tests/MemoryPack.Tests/TupleTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class TupleTEst
{

    private void ConvertEqual<T>(T value)
    {
        MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value))
            .Should().Be(value);
    }

    [Fact]
    public void TupleT()
    {
        ConvertEqual(Tuple.Create(1));
        ConvertEqual(Tuple.Create(1, 2));
        ConvertEqual(Tuple.Create(1, 2, 3));
        ConvertEqual(Tuple.Create(1, 2, 3, 4));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6, 7));
        ConvertEqual(Tuple.Create(1, 2, 3, 4, 5, 6, 7, 8));
    }

    [Fact]
    public void ValueTupleT()
    {
        ConvertEqual(ValueTuple.Create(1));
        ConvertEqual(ValueTuple.Create(1, 2));
        ConvertEqual(ValueTuple.Create(1, 2, 3));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6, 7));
        ConvertEqual(ValueTuple.Create(1, 2, 3, 4, 5, 6, 7, 8));
    }
}



================================================
FILE: tests/MemoryPack.Tests/UnionTest.cs
================================================
﻿using MemoryPack.Formatters;
using MemoryPack.Tests.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class UnionTest
{
    [Fact]
    public void Foo()
    {
        {
            var one = new AForOne { BaseValue = 10, MyProperty = 99 };
            var two = new AForTwo { BaseValue = 99, MyProperty = 10000 };

            var bin1 = MemoryPackSerializer.Serialize((IForExternalUnion)one);
            var bin2 = MemoryPackSerializer.Serialize((IForExternalUnion)two);

            var one2 = MemoryPackSerializer.Deserialize<IForExternalUnion>(bin1);
            var two2 = MemoryPackSerializer.Deserialize<IForExternalUnion>(bin2);

            one2.Should().BeAssignableTo<AForOne>().Subject.Should().BeEquivalentTo(one);
            two2.Should().BeAssignableTo<AForTwo>().Subject.Should().BeEquivalentTo(two);
        }
        {
            var one = new BForOne<DateTime> { NoValue = DateTime.Now, MyProperty = 99 };
            var two = new BForTwo<string> { NoValue = "aaaa", MyProperty = 10000 };

            var bin1 = MemoryPackSerializer.Serialize((IGenericsUnion<DateTime>)one);
            var bin2 = MemoryPackSerializer.Serialize((IGenericsUnion<string>)two);

            var one2 = MemoryPackSerializer.Deserialize<IGenericsUnion<DateTime>>(bin1);
            var two2 = MemoryPackSerializer.Deserialize<IGenericsUnion<string>>(bin2);

            one2.Should().BeAssignableTo<BForOne<DateTime>>().Subject.Should().BeEquivalentTo(one);
            two2.Should().BeAssignableTo<BForTwo<string>>().Subject.Should().BeEquivalentTo(two);
        }
    }

    [Fact]
    public void Dynamic()
    {
        var f = new DynamicUnionFormatter<IDynamicBase>(
            (0, typeof(Gen1)),
            (1, typeof(Gen2)));

        MemoryPackFormatterProvider.Register(f);

        var one = new Gen1() { MyProperty = 999 };
        var two = new Gen2() { MyProperty = "aabbbC" };

        var bin1 = MemoryPackSerializer.Serialize<IDynamicBase>(one);
        var bin2 = MemoryPackSerializer.Serialize<IDynamicBase>(two);

        var d1 = MemoryPackSerializer.Deserialize<IDynamicBase>(bin1);
        var d2 = MemoryPackSerializer.Deserialize<IDynamicBase>(bin2);

        (d1 as Gen1)!.MyProperty.Should().Be(999);
        (d2 as Gen2)!.MyProperty.Should().Be("aabbbC");
    }
}

[MemoryPackable(GenerateType.NoGenerate)]
public partial class IDynamicBase
{
}


[MemoryPackable(GenerateType.Object)]
public partial class Gen1 : IDynamicBase
{
    public int MyProperty { get; set; }
}

[MemoryPackable(GenerateType.Object)]
public partial class Gen2 : IDynamicBase
{
    public string? MyProperty { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/VarIntTest.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class VarIntTest
{
    [Fact]
    public void ReadWrite()
    {
        var buffer = new ArrayBufferWriter<byte>();

        using var state = MemoryPackWriterOptionalStatePool.Rent(null);
        var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);

        writer.WriteVarInt(1);
        writer.WriteVarInt((byte)10);
        writer.WriteVarInt(100);
        writer.WriteVarInt((short)1000);
        writer.WriteVarInt((ushort)10000);
        writer.WriteVarInt(100000);
        writer.WriteVarInt((ulong)1000000);
        writer.WriteVarInt(10000000);
        writer.WriteVarInt(100000000);
        writer.WriteVarInt(1000000000);
        writer.WriteVarInt(10000000000);
        writer.WriteVarInt(100000000000);
        writer.WriteVarInt(-1);
        writer.WriteVarInt(-10);
        writer.WriteVarInt((sbyte)-100);
        writer.WriteVarInt(-1000);
        writer.WriteVarInt(-10000);
        writer.WriteVarInt((long)-100000);
        writer.WriteVarInt(-1000000);
        writer.WriteVarInt(-10000000);
        writer.WriteVarInt(-100000000);
        writer.WriteVarInt(-1000000000);
        writer.WriteVarInt(-10000000000);
        writer.WriteVarInt(-100000000000);

        writer.Flush();

        using var state2 = MemoryPackReaderOptionalStatePool.Rent(null);
        var reader = new MemoryPackReader(buffer.WrittenSpan, state2);

        var l = new long[24];
        for (int i = 0; i < l.Length; i++)
        {
            l[i] = reader.ReadVarIntInt64();
        }

        l[0].Should().Be(1);
        l[1].Should().Be((byte)10);
        l[2].Should().Be(100);
        l[3].Should().Be((short)1000);
        l[4].Should().Be((ushort)10000);
        l[5].Should().Be(100000);
        l[6].Should().Be((long)1000000);
        l[7].Should().Be(10000000);
        l[8].Should().Be(100000000);
        l[9].Should().Be(1000000000);
        l[10].Should().Be(10000000000);
        l[11].Should().Be(100000000000);
        l[12].Should().Be(-1);
        l[13].Should().Be(-10);
        l[14].Should().Be((sbyte)-100);
        l[15].Should().Be(-1000);
        l[16].Should().Be(-10000);
        l[17].Should().Be((long)-100000);
        l[18].Should().Be(-1000000);
        l[19].Should().Be(-10000000);
        l[20].Should().Be(-100000000);
        l[21].Should().Be(-1000000000);
        l[22].Should().Be(-10000000000);
        l[23].Should().Be(-100000000000);
    }


}



================================================
FILE: tests/MemoryPack.Tests/VersionTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;


public class VersionTest
{
    [Fact]
    public void V()
    {
        {
            var v = new Version();
            var bin = MemoryPackSerializer.Serialize(v);
            var v2 = MemoryPackSerializer.Deserialize<Version>(bin);
            v2.Should().Be(v);
        }
        {
            var v = new Version(10, 20);
            var bin = MemoryPackSerializer.Serialize(v);
            var v2 = MemoryPackSerializer.Deserialize<Version>(bin);
            v2.Should().Be(v);
        }
        {
            var v = new Version(10, 20, 30);
            var bin = MemoryPackSerializer.Serialize(v);
            var v2 = MemoryPackSerializer.Deserialize<Version>(bin);
            v2.Should().Be(v);
        }
        {
            var v = new Version(10, 20, 30, 40);
            var bin = MemoryPackSerializer.Serialize(v);
            var v2 = MemoryPackSerializer.Deserialize<Version>(bin);
            v2.Should().Be(v);
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/VersionTolerantTest.cs
================================================
﻿using MemoryPack.Tests.Models;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class VersionTolerantTest
{
    private void ConvertEqual<T>(T value)
    {
        MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value))
            .Should().BeEquivalentTo(value);
    }

    [Fact]
    public void Zero()
    {
        var zero = MemoryPackSerializer.Deserialize<VersionTolerant0>(MemoryPackSerializer.Serialize(new VersionTolerant0()));
        zero.Should().BeOfType<VersionTolerant0>();

        var wrapper = new VTWrapper<VersionTolerant0>()
        {
            Values = new[] { 1, 10, 100 },
            Versioned = new VersionTolerant0()
        };

        var v2 = MemoryPackSerializer.Deserialize<VTWrapper<VersionTolerant0>>(MemoryPackSerializer.Serialize(wrapper));
        v2!.Versioned!.Should().BeOfType<VersionTolerant0>();
        v2!.Values!.Should().Equal(1, 10, 100);
    }

    [Fact]
    public void Standard()
    {
        // ConvertEqual(new VersionTolerant0());
        ConvertEqual(new VersionTolerant1());
        ConvertEqual(new VersionTolerant2());
        ConvertEqual(new VersionTolerant3());
        ConvertEqual(new VersionTolerant4());
        ConvertEqual(new VersionTolerant5());
    }

    VTWrapper<T> MakeWrapper<T>(T v)
    {
        return new VTWrapper<T> { Versioned = v, Values = new[] { 1, 2, 10 } };
    }

    void CheckArray<T>(VTWrapper<T> value)
    {
        value.Values.Should().Equal(1, 2, 10);
    }
#pragma warning disable CS8602
#pragma warning disable CS8604

    [Fact]
    public void Version()
    {
        var v0 = new VersionTolerant0();
        var v1 = new VersionTolerant1() { MyProperty1 = 1000 };
        var v2 = new VersionTolerant2() { MyProperty1 = 3000, MyProperty2 = 9999 };
        var v3 = new VersionTolerant3() { MyProperty1 = 444, MyProperty2 = 2452, MyProperty3 = 32 };
        var v4 = new VersionTolerant4() { MyProperty1 = 99, MyProperty3 = 13 };
        var v5 = new VersionTolerant5() { MyProperty3 = 5000, MyProperty6 = new ushort[] { 1, 10, 100 } };

        var bin0 = MemoryPackSerializer.Serialize(MakeWrapper(v0));
        var bin1 = MemoryPackSerializer.Serialize(MakeWrapper(v1));
        var bin2 = MemoryPackSerializer.Serialize(MakeWrapper(v2));
        var bin3 = MemoryPackSerializer.Serialize(MakeWrapper(v3));
        var bin4 = MemoryPackSerializer.Serialize(MakeWrapper(v4));
        var bin5 = MemoryPackSerializer.Serialize(MakeWrapper(v5));


        var a = MemoryPackSerializer.Deserialize<VTWrapper<VersionTolerant2>>(bin1);
        CheckArray(a);

        a.Versioned.MyProperty1.Should().Be(1000);
        a.Versioned.MyProperty2.Should().Be(0);

        var b = MemoryPackSerializer.Deserialize<VTWrapper<VersionTolerant2>>(bin3);
        CheckArray(b);
        b.Versioned.MyProperty1.Should().Be(444);
        b.Versioned.MyProperty2.Should().Be(2452);

        var c = MemoryPackSerializer.Deserialize<VTWrapper<VersionTolerant4>>(bin3);
        CheckArray(c);

        c.Versioned.MyProperty1.Should().Be(444);
        c.Versioned.MyProperty3.Should().Be(32);

        var d = MemoryPackSerializer.Deserialize<VTWrapper<VersionTolerant5>>(bin3);
        CheckArray(d);
        d.Versioned.MyProperty3.Should().Be(32);
    }

    [Fact]
    public void More()
    {
        var v3 = new VersionTolerant3 { MyProperty1 = 1000, MyProperty2 = 2000, MyProperty3 = 3000 };
        var v4 = new VersionTolerant4 { MyProperty1 = 4000, MyProperty3 = 5000 };

        var bin3 = MemoryPackSerializer.Serialize(v3);
        var bin4 = MemoryPackSerializer.Serialize(v4);

        var r_v4 = MemoryPackSerializer.Deserialize<VersionTolerant4>(bin3);
        r_v4.MyProperty1.Should().Be(1000);
        r_v4.MyProperty3.Should().Be(3000);

        var r_v3 = MemoryPackSerializer.Deserialize<VersionTolerant3>(bin4);
        r_v3.MyProperty1.Should().Be(4000);
        r_v3.MyProperty2.Should().Be(0);
        r_v3.MyProperty3.Should().Be(5000);
    }

    [Fact]
    public void More2()
    {
        var v1 = new Version1 { Id = 99, Name = "foo" };
        var v2 = new Version2 { Id = 9999, FirstName = "a", LastName = "b" };

        var bin1 = MemoryPackSerializer.Serialize(v1);
        var bin2 = MemoryPackSerializer.Serialize(v2);

        var r = MemoryPackSerializer.Deserialize<Version1>(bin2);
        r.Id.Should().Be(9999);
    }



    [Fact]
    public void Version2()
    {
        var v1 = new MoreVersionTolerant1() { MyProperty1 = new Version(10, 20, 4, 6) };
        var v2 = new MoreVersionTolerant2() { MyProperty1 = new Version(4, 23, 3, 99), MyProperty2 = 9999 };
        var v3 = new MoreVersionTolerant3() { MyProperty1 = new Version(6, 32, 425, 53), MyProperty2 = 2452, MyProperty3 = 32 };
        var v4 = new MoreVersionTolerant4() { MyProperty1 = new Version(11, 12, 13, 14), MyProperty3 = 13 };
        var v5 = new MoreVersionTolerant5() { MyProperty3 = 5000, MyProperty6 = new Version(1, 10, 100) };

        var bin1 = MemoryPackSerializer.Serialize(MakeWrapper(v1));
        var bin2 = MemoryPackSerializer.Serialize(MakeWrapper(v2));
        var bin3 = MemoryPackSerializer.Serialize(MakeWrapper(v3));
        var bin4 = MemoryPackSerializer.Serialize(MakeWrapper(v4));
        var bin5 = MemoryPackSerializer.Serialize(MakeWrapper(v5));


        var a = MemoryPackSerializer.Deserialize<VTWrapper<MoreVersionTolerant2>>(bin1);
        CheckArray(a);

        a.Versioned.MyProperty1.Should().Be(new Version(10, 20, 4, 6));
        a.Versioned.MyProperty2.Should().Be(0);

        var b = MemoryPackSerializer.Deserialize<VTWrapper<MoreVersionTolerant2>>(bin3);
        CheckArray(b);
        b.Versioned.MyProperty1.Should().Be(new Version(6, 32, 425, 53));
        b.Versioned.MyProperty2.Should().Be(2452);

        var c = MemoryPackSerializer.Deserialize<VTWrapper<MoreVersionTolerant4>>(bin3);
        CheckArray(c);

        c.Versioned.MyProperty1.Should().Be(new Version(6, 32, 425, 53));
        c.Versioned.MyProperty3.Should().Be(32);

        var d = MemoryPackSerializer.Deserialize<VTWrapper<MoreVersionTolerant5>>(bin3);
        CheckArray(d);
        d.Versioned.MyProperty3.Should().Be(32);
    }

    [Fact]
    public void More21()
    {
        var v3 = new MoreVersionTolerant3 { MyProperty1 = new Version(4, 23, 3, 99), MyProperty2 = 2000, MyProperty3 = 3000 };
        var v4 = new MoreVersionTolerant4 { MyProperty1 = new Version(5, 1, 2, 6), MyProperty3 = 5000 };

        var bin3 = MemoryPackSerializer.Serialize(v3);
        var bin4 = MemoryPackSerializer.Serialize(v4);

        var r_v4 = MemoryPackSerializer.Deserialize<MoreVersionTolerant4>(bin3);
        r_v4.MyProperty1.Should().Be(new Version(4, 23, 3, 99));
        r_v4.MyProperty3.Should().Be(3000);

        var r_v3 = MemoryPackSerializer.Deserialize<MoreVersionTolerant3>(bin4);
        r_v3.MyProperty1.Should().Be(new Version(5, 1, 2, 6));
        r_v3.MyProperty2.Should().Be(0);
        r_v3.MyProperty3.Should().Be(5000);
    }

    [Fact]
    public void More22()
    {
        var v1 = new MoreVersion1 { Id = new Version(4, 23, 3), Name = "foo" };
        var v2 = new MoreVersion2 { Id = new Version(5, 1, 2, 6), FirstName = "a", LastName = "b" };

        var bin1 = MemoryPackSerializer.Serialize(v1);
        var bin2 = MemoryPackSerializer.Serialize(v2);

        var r = MemoryPackSerializer.Deserialize<MoreVersion1>(bin2);
        r.Id.Should().Be(new Version(5, 1, 2, 6));
    }
}



================================================
FILE: tests/MemoryPack.Tests/WellknownFormattersTest.cs
================================================
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class WellknownFormattersTest
{
    private T Convert<T>(T value)
    {
        return MemoryPackSerializer.Deserialize<T>(MemoryPackSerializer.Serialize(value))!;
    }

    private void ConvertEqual<T>(T value)
    {
        Convert(value).Should().Be(value);
    }

    [Fact]
    public void Geenrics()
    {
        ConvertEqual(new KeyValuePair<int, string>(100, "hoge"));
        Convert(new Lazy<int>(100)).Value.Should().Be(100);
    }

    [Fact]
    public void Nullable()
    {
        Convert(new Nullable<Sonota>(new Sonota { MyProperty = "9" })!)!.Value.MyProperty.Should().Be("9");
        Convert(default(Sonota?)).HasValue.Should().BeFalse();
    }


    [Fact]
    public void Others()
    {
        ConvertEqual(new Version(1, 3, 4, 5));
        ConvertEqual(new Uri("http://hoehoge.com/huu?q=takotako"));
        ConvertEqual(TimeZoneInfo.Utc);
        var sb = new StringBuilder(new string('a', 99999));
        Convert(sb).ToString().Should().Be(sb.ToString());
        ConvertEqual(typeof(WellknownFormattersTest));
        var bitArray = new BitArray(Enumerable.Range(1, 1000).Select(x => x % 3 == 0).ToArray());
        Convert(bitArray).OfType<bool>().ToArray().Should().Equal(bitArray.OfType<bool>().ToArray());
        ConvertEqual(CultureInfo.InvariantCulture);
        ConvertEqual(CultureInfo.GetCultureInfo("ja"));
        ConvertEqual(CultureInfo.GetCultureInfo("ja-JP"));
        ConvertEqual(CultureInfo.GetCultureInfo("en"));
    }
}

[MemoryPackable]
public partial struct Sonota
{
    public string MyProperty { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/WriterOptionalStateTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public class WriterOptionalStateTest
{
    [Fact]
    public void AddReference()
    {
        var state = MemoryPackWriterOptionalStatePool.Rent(null);

        var o0 = new object();
        var o1 = new object();
        var o2 = new object();

        var (exists, id) = state.GetOrAddReference(o0);
        exists.Should().BeFalse();
        id.Should().Be(0);

        (exists, id) = state.GetOrAddReference(o1);
        exists.Should().BeFalse();
        id.Should().Be(1);

        (exists, id) = state.GetOrAddReference(o0);
        exists.Should().BeTrue();
        id.Should().Be(0);

        (exists, id) = state.GetOrAddReference(o2);
        exists.Should().BeFalse();
        id.Should().Be(2);

        (exists, id) = state.GetOrAddReference(o1);
        exists.Should().BeTrue();
        id.Should().Be(1);

        (exists, id) = state.GetOrAddReference(o2);
        exists.Should().BeTrue();
        id.Should().Be(2);

        state.Reset();
    }
}



================================================
FILE: tests/MemoryPack.Tests/WriterTest.cs
================================================
﻿using System;
using System.Buffers;

namespace MemoryPack.Tests;

public class WriterTest
{
    [Fact]
    public void BufferManagementTest()
    {
        var buffer = new SpanControlWriter();

        var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
        try
        {
            var writer = new MemoryPackWriter<SpanControlWriter>(ref buffer, state);

            buffer.ProvideSpanLength = 5;

            writer.GetSpanReference(3);
            writer.Advance(3);

            buffer.SpanRequested.Should().Be(1);
            buffer.AdvancedLength.Should().Be(0);

            writer.GetSpanReference(2);
            writer.Advance(2);

            buffer.SpanRequested.Should().Be(1);
            buffer.AdvancedLength.Should().Be(0);

            // request more span
            writer.GetSpanReference(3);
            buffer.SpanRequested.Should().Be(2);
            buffer.AdvancedLength.Should().Be(5);

            // invalid advance
            var error = false;
            try
            {
                writer.Advance(9999);
            }
            catch (MemoryPackSerializationException)
            {
                error = true;
            }
            error.Should().BeTrue();
        }
        finally
        {
            state.Reset();
        }
    }

    [Fact]
    public void WriteObjectHeaderTest()
    {
        var buffer = new ArrayBufferWriter<byte>();

        {
            var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
            var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);

            writer.WriteNullObjectHeader();
            writer.Flush();

            buffer.WrittenSpan[0].Should().Be(MemoryPackCode.NullObject);
            buffer.Clear();
            state.Reset();
        }
        for (var i = 0; i < 250; i++)
        {
            var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
            var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
            writer.WriteObjectHeader((byte)i);
            writer.Flush();

            buffer.WrittenSpan[0].Should().Be((byte)i);
            buffer.Clear();
            state.Reset();
        }

        for (byte i = MemoryPackCode.Reserved1; i <= MemoryPackCode.NullObject; i++)
        {
            if (i == 0) break;
            var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default);
            var writer = new MemoryPackWriter<ArrayBufferWriter<byte>>(ref buffer, state);
            var error = false;
            try
            {
                writer.WriteObjectHeader((byte)i);
            }
            catch (MemoryPackSerializationException)
            {
                error = true;
            }
            finally
            {
                buffer.Clear();
            }
            error.Should().BeTrue();
            state.Reset();
        }
    }

    [Fact]
    public void CheckForReusableLinkedArrayBufferWriter()
    {
        // InitialBuffer = 262144
        // 1(object-header) + (4 + (array-header + buffer-size) * 5)
        var buffer = new BufferTest
        {
            Buffer1 = new byte[262139],
            Buffer2 = new byte[262135],
            Buffer3 = new byte[1],
            Buffer4 = new byte[262139],
            Buffer5 = new byte[262139],
        };

        Array.Fill(buffer.Buffer1!, (byte)14);
        Array.Fill(buffer.Buffer2, (byte)30);
        Array.Fill(buffer.Buffer3, (byte)50);
        Array.Fill(buffer.Buffer4, (byte)100);
        Array.Fill(buffer.Buffer5, (byte)250);

        var bin = MemoryPackSerializer.Serialize(buffer);
        var v2 = MemoryPackSerializer.Deserialize<BufferTest>(bin);

        buffer.Buffer1.AsSpan().SequenceEqual(v2!.Buffer1).Should().BeTrue();
        buffer.Buffer2.AsSpan().SequenceEqual(v2!.Buffer2).Should().BeTrue();
        buffer.Buffer3.AsSpan().SequenceEqual(v2.Buffer3).Should().BeTrue();
        buffer.Buffer4.AsSpan().SequenceEqual(v2!.Buffer4).Should().BeTrue();
        buffer.Buffer5.AsSpan().SequenceEqual(v2!.Buffer5).Should().BeTrue();
    }

    public class SpanControlWriter : IBufferWriter<byte>
    {
        public int ProvideSpanLength { get; set; }
        public int AdvancedLength { get; private set; }
        public int SpanRequested { get; private set; }

        public void Advance(int count)
        {
            AdvancedLength += count;
        }

        public Memory<byte> GetMemory(int sizeHint = 0)
        {
            throw new NotImplementedException();
        }

        public Span<byte> GetSpan(int sizeHint = 0)
        {
            SpanRequested++;
            return new byte[Math.Max(sizeHint, ProvideSpanLength)];
        }
    }
}


[MemoryPackable]
public partial class BufferTest
{
    public byte[]? Buffer1;
    public byte[]? Buffer2;
    public byte[]? Buffer3;
    public byte[]? Buffer4;
    public byte[]? Buffer5;
}



================================================
FILE: tests/MemoryPack.Tests/Models/Arrays.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;


[MemoryPackable]
public partial class ArrayCheck
{
    public int[]? Array1 { get; set; }
    public int?[]? Array2 { get; set; }
    public string[]? Array3 { get; set; }
    public string?[]? Array4 { get; set; }
}


[MemoryPackable]
public partial class ArrayOptimizeCheck
{
    public StandardTypeTwo?[]? Array1 { get; set; }
    public List<StandardTypeTwo?>? List1 { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/CircularReference.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}

[MemoryPackable(GenerateType.CircularReference)]
public partial class PureNode
{
    [MemoryPackOrder(0)]
    public int Id { get; set; }
    [MemoryPackOrder(1)]
    public ulong Id2 { get; set; }
}

[MemoryPackable]
public partial class CircularHolder
{
    public List<Node>? List { get; set; }
    public List<PureNode>? ListPure { get; set; }
}


// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}



[MemoryPackable(GenerateType.CircularReference, SerializeLayout.Sequential)]
public partial class SequentialCircularReference
{
    public string? Name { get; set; }
    public SequentialCircularReference? Manager { get; set; }
    public List<SequentialCircularReference>? DirectReports { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/Ctors.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class NoCtor
{
    public int X { get; set; }
}

[MemoryPackable]
public partial class OneCtor
{
    public int X { get; set; }


    public OneCtor()
    {

    }
}

[MemoryPackable]
public partial class OneCtor2
{
    public int X { get; }
    public int Y { get; }

    public OneCtor2(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}

//[MemoryPackable]
//public partial class TwoCtor
//{
//    public TwoCtor()
//    {

//    }

//    public TwoCtor(int x, int y)
//    {

//    }
//}

[MemoryPackable]
public partial class ExplicitlyCtor
{
    public int X { get; }
    public int Y { get; set; }

    public ExplicitlyCtor()
    {

    }

    [MemoryPackConstructor]
    public ExplicitlyCtor(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}



//[MemoryPackable]
//public partial class MultipleExplicitlyCtor
//{
//    [MemoryPackConstructor]
//    public MultipleExplicitlyCtor()
//    {

//    }

//    [MemoryPackConstructor]
//    public MultipleExplicitlyCtor(int x, int y)
//    {

//    }
//}


[MemoryPackable]
public partial class ParameterCheck
{
    bool prop1SetCalled;

    string mp;
    public string MyProperty1
    {
        get { return mp; }
        set
        {
            mp = value;
            prop1SetCalled = true;
        }
    }
    public string? MyProperty2;

    public ParameterCheck(string myProperty1)
    {
        this.mp = myProperty1;
    }

    public bool IsProp1SetCalled()
    {
        return prop1SetCalled;
    }
}



================================================
FILE: tests/MemoryPack.Tests/Models/CustomAttribute.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class CustomFormatterCheck
{
    public string? NoMarkField;
    public string? NoMarkProp { get; set; }

    [Utf8StringFormatter]
    public string? Field1;

    [Utf16StringFormatter]
    public string? Prop1 { get; set; }

#if NET7_0_OR_GREATER
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
#endif
    public Dictionary<string, int>? PropDict { get; set; }
#if NET7_0_OR_GREATER
    [OrdinalIgnoreCaseStringDictionaryFormatter<string>]
#endif
    public Dictionary<string, string>? FieldDict;

}



================================================
FILE: tests/MemoryPack.Tests/Models/DefaultValues.cs
================================================
namespace MemoryPack.Tests.Models;

[MemoryPackable]
partial class DefaultValuePlaceholder
{
    public int X { get; set; }
}

[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
partial class DefaultValuePlaceholderWithVersionTolerant
{
    public int X { get; set; }
}

[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
partial class HasDefaultValueWithVersionTolerant
{
    public int X;

    public int Y = 12345;
    public float Z { get; set; } = 678.9f;

    [SuppressDefaultInitialization]
    public int Y2 = 12345;

    [SuppressDefaultInitialization]
    public float Z2 { get; set; } = 678.9f;
}

[MemoryPackable]
partial class HasDefaultValue
{
    public int X;

    public int Y = 12345;
    public float Z { get; set; } = 678.9f;

    [SuppressDefaultInitialization]
    public int Y2 = 12345;

    [SuppressDefaultInitialization]
    public float Z2 { get; set; } = 678.9f;
}



================================================
FILE: tests/MemoryPack.Tests/Models/GenericsType.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;


[MemoryPackable]
public partial class GenericsType<T>
{
    public int MyProperty1 { get; set; }
    public T? MyProperty2 { get; set; }
}


[MemoryPackable]
public partial class MoreComplecsGenerics<T1, T2>
    where T1 : notnull
{
    public Dictionary<T1, GenericsType<T2>>? Dict { get; set; }
}

// Union

[MemoryPackable]
[MemoryPackUnion(0, typeof(GenricUnionA<>))]
[MemoryPackUnion(1, typeof(GenricUnionB<>))]
public partial interface IGenericUnion<ToaruHoge>
{
    ToaruHoge? Value { get; set; }
}


[MemoryPackable]
public partial class GenricUnionA<T> : IGenericUnion<T>
{
    public T? Value { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackable]
public partial class GenricUnionB<T> : IGenericUnion<T>
{
    public T? Value { get; set; }
    public double MyProperty { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/Include.cs
================================================
﻿#pragma warning disable IDE0044 // Add readonly modifier
#pragma warning disable IDE0051 // Remove unused private members
#pragma warning disable CS0169

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class Include
{
    public int PublicProp { get; set; }
    public int PublicField;

    [MemoryPackIgnore]
    public string? NoInclude { get; set; }

    public string? PrivateSet { get; private set; }
    public string? PrivateGet { private get; set; }

    [MemoryPackInclude]
    private string? PrivateProp { get; set; }
    [MemoryPackInclude]
    private int PrivateField;

    public void SetAll(int publicProp, int publicFIeld, string privateSet, string privateGet, string privateProp, int privateField)
    {
        this.PublicProp = publicProp;
        this.PublicField = publicFIeld;
        this.PrivateSet = privateSet;
        this.PrivateGet = privateGet;
        this.PrivateProp = privateProp;
        this.PrivateField = privateField;
    }

    public (int, int, string?, string?, string?, int) GetAll()
    {
        return (PublicProp, PublicField, PrivateSet, PrivateGet, PrivateProp, PrivateField);
    }
}

[MemoryPackable]
public partial class NoInclude
{
    public int PublicProp { get; set; }
    public int PublicField;

    public string? PrivateSet { get; private set; }
    public string? PrivateGet { private get; set; }

    private string? PrivateProp { get; set; }
    private int PrivateField;

    public void SetAll(int publicProp, int publicFIeld, string privateSet, string privateGet, string privateProp, int privateField)
    {
        this.PublicProp = publicProp;
        this.PublicField = publicFIeld;
        this.PrivateSet = privateSet;
        this.PrivateGet = privateGet;
        this.PrivateProp = privateProp;
        this.PrivateField = privateField;
    }

    public (int, int, string?, string?, string?, int) GetAll()
    {
        return (PublicProp, PublicField, PrivateSet, PrivateGet, PrivateProp, PrivateField);
    }
}



================================================
FILE: tests/MemoryPack.Tests/Models/KeywordIdentifier.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;


// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/verbatim

[MemoryPackable]
public partial class KeywordModel
{
    public int @int;
    public long @long;
    public string? @string { get; set; }

    public Version2? @for;

    [MemoryPackConstructor]
    public KeywordModel(int @int)
    {
        this.@int = @int;
    }
}



================================================
FILE: tests/MemoryPack.Tests/Models/ManyMembers.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class ManyMembers
{
    public int MyProperty1;
    public int MyProperty2;
    public int MyProperty3;
    public int MyProperty4;
    public int MyProperty5;
    public int MyProperty6;
    public int MyProperty7;
    public int MyProperty8;
    public int MyProperty9;
    public int MyProperty10;
    public int MyProperty11;
    public int MyProperty12;
    public int MyProperty13;
    public int MyProperty14;
    public int MyProperty15;
    public int MyProperty16;
    public int MyProperty17;
    public int MyProperty18;
    public int MyProperty19;
    public int MyProperty20;
    public int MyProperty21;
    public int MyProperty22;
    public int MyProperty23;
    public int MyProperty24;
    public int MyProperty25;
    public int MyProperty26;
    public int MyProperty27;
    public int MyProperty28;
    public int MyProperty29;
    public int MyProperty30;
    public int MyProperty31;
    public int MyProperty32;
    public int MyProperty33;
    public int MyProperty34;
    public int MyProperty35;
    public int MyProperty36;
    public int MyProperty37;
    public int MyProperty38;
    public int MyProperty39;
    public int MyProperty40;
    public int MyProperty41;
    public int MyProperty42;
    public int MyProperty43;
    public int MyProperty44;
    public int MyProperty45;
    public int MyProperty46;
    public int MyProperty47;
    public int MyProperty48;
    public int MyProperty49;
    public int MyProperty50;
    public int MyProperty51;
    public int MyProperty52;
    public int MyProperty53;
    public int MyProperty54;
    public int MyProperty55;
    public int MyProperty56;
    public int MyProperty57;
    public int MyProperty58;
    public int MyProperty59;
    public int MyProperty60;
    public int MyProperty61;
    public int MyProperty62;
    public int MyProperty63;
    public int MyProperty64;
    public int MyProperty65;
    public int MyProperty66;
    public int MyProperty67;
    public int MyProperty68;
    public int MyProperty69;
    public int MyProperty70;
    public int MyProperty71;
    public int MyProperty72;
    public int MyProperty73;
    public int MyProperty74;
    public int MyProperty75;
    public int MyProperty76;
    public int MyProperty77;
    public int MyProperty78;
    public int MyProperty79;
    public int MyProperty80;
    public int MyProperty81;
    public int MyProperty82;
    public int MyProperty83;
    public int MyProperty84;
    public int MyProperty85;
    public int MyProperty86;
    public int MyProperty87;
    public int MyProperty88;
    public int MyProperty89;
    public int MyProperty90;
    public int MyProperty91;
    public int MyProperty92;
    public int MyProperty93;
    public int MyProperty94;
    public int MyProperty95;
    public int MyProperty96;
    public int MyProperty97;
    public int MyProperty98;
    public int MyProperty99;
    public int MyProperty100;
    public int MyProperty101;
    public int MyProperty102;
    public int MyProperty103;
    public int MyProperty104;
    public int MyProperty105;
    public int MyProperty106;
    public int MyProperty107;
    public int MyProperty108;
    public int MyProperty109;
    public int MyProperty110;
    public int MyProperty111;
    public int MyProperty112;
    public int MyProperty113;
    public int MyProperty114;
    public int MyProperty115;
    public int MyProperty116;
    public int MyProperty117;
    public int MyProperty118;
    public int MyProperty119;
    public int MyProperty120;
    public int MyProperty121;
    public int MyProperty122;
    public int MyProperty123;
    public int MyProperty124;
    public int MyProperty125;
    public int MyProperty126;
    public int MyProperty127;
    public int MyProperty128;
    public int MyProperty129;
    public int MyProperty130;
    public int MyProperty131;
    public int MyProperty132;
    public int MyProperty133;
    public int MyProperty134;
    public int MyProperty135;
    public int MyProperty136;
    public int MyProperty137;
    public int MyProperty138;
    public int MyProperty139;
    public int MyProperty140;
    public int MyProperty141;
    public int MyProperty142;
    public int MyProperty143;
    public int MyProperty144;
    public int MyProperty145;
    public int MyProperty146;
    public int MyProperty147;
    public int MyProperty148;
    public int MyProperty149;
    public int MyProperty150;
    public int MyProperty151;
    public int MyProperty152;
    public int MyProperty153;
    public int MyProperty154;
    public int MyProperty155;
    public int MyProperty156;
    public int MyProperty157;
    public int MyProperty158;
    public int MyProperty159;
    public int MyProperty160;
    public int MyProperty161;
    public int MyProperty162;
    public int MyProperty163;
    public int MyProperty164;
    public int MyProperty165;
    public int MyProperty166;
    public int MyProperty167;
    public int MyProperty168;
    public int MyProperty169;
    public int MyProperty170;
    public int MyProperty171;
    public int MyProperty172;
    public int MyProperty173;
    public int MyProperty174;
    public int MyProperty175;
    public int MyProperty176;
    public int MyProperty177;
    public int MyProperty178;
    public int MyProperty179;
    public int MyProperty180;
    public int MyProperty181;
    public int MyProperty182;
    public int MyProperty183;
    public int MyProperty184;
    public int MyProperty185;
    public int MyProperty186;
    public int MyProperty187;
    public int MyProperty188;
    public int MyProperty189;
    public int MyProperty190;
    public int MyProperty191;
    public int MyProperty192;
    public int MyProperty193;
    public int MyProperty194;
    public int MyProperty195;
    public int MyProperty196;
    public int MyProperty197;
    public int MyProperty198;
    public int MyProperty199;
    public int MyProperty200;
    public int MyProperty201;
    public int MyProperty202;
    public int MyProperty203;
    public int MyProperty204;
    public int MyProperty205;
    public int MyProperty206;
    public int MyProperty207;
    public int MyProperty208;
    public int MyProperty209;
    public int MyProperty210;
    public int MyProperty211;
    public int MyProperty212;
    public int MyProperty213;
    public int MyProperty214;
    public int MyProperty215;
    public int MyProperty216;
    public int MyProperty217;
    public int MyProperty218;
    public int MyProperty219;
    public int MyProperty220;
    public int MyProperty221;
    public int MyProperty222;
    public int MyProperty223;
    public int MyProperty224;
    public int MyProperty225;
    public int MyProperty226;
    public int MyProperty227;
    public int MyProperty228;
    public int MyProperty229;
    public int MyProperty230;
    public int MyProperty231;
    public int MyProperty232;
    public int MyProperty233;
    public int MyProperty234;
    public int MyProperty235;
    public int MyProperty236;
    public int MyProperty237;
    public int MyProperty238;
    public int MyProperty239;
    public int MyProperty240;
    public int MyProperty241;
    public int MyProperty242;
    public int MyProperty243;
    public int MyProperty244;
    public int MyProperty245;
    public int MyProperty246;
    public int MyProperty247;
    public int MyProperty248;
    public int MyProperty249;
    //public int MyProperty250;
    //public int MyProperty251;
}



================================================
FILE: tests/MemoryPack.Tests/Models/MemberKinds.cs
================================================
﻿#pragma warning disable CS0649

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class MemberKindsAllUnmanaged
{
    public int A; // public field
    [MemoryPackInclude]
    private int B; // private field
    public readonly int C; // public readonly field
    [MemoryPackInclude]
    private readonly int D; // readonly field

    public int E { get; set; } // public property
    public int F { private get; set; } // private get
    public int G { get; private set; } // private set
    [MemoryPackInclude]
    private int H { get; set; } // private property

    int i;
    public int I1 => i; // get only
    public int I2 { set { i = value; } } // set only

    int j;
    [MemoryPackInclude]
    private int J1 => j; // private get only
    [MemoryPackInclude]
    private int J2 { set { j = value; } } // private set only

    int[] kArray = new int[1];

    public ref int K
    {
        get { return ref kArray[0]; }
    }

    public void SetH(int h)
    {
        this.H = h;
    }

    public int GetH()
    {
        return H;
    }

    public MemberKindsAllUnmanaged(int c, int d)
    {
        this.C = c;
        this.D = d;
    }
}



================================================
FILE: tests/MemoryPack.Tests/Models/MethodCall.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;


[MemoryPackable]
public partial struct Hoge
{
    public string MyProperty { get; set; }
}

[MemoryPackable]
public partial class MethodCall
{
    public static List<string> Log { get; } = new List<string>();

    int mp;
    public int MyProperty
    {
        get
        {
            Log.Add("Get");
            return mp;
        }
        set
        {
            Log.Add("Set");
            mp = value;
        }
    }

    public MethodCall()
    {
        Log.Add("Constructor");
    }

    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Log.Add(nameof(OnSerializing1));
    }

    // check allow private.
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Log.Add(nameof(OnSerializing2));
    }


    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Log.Add(nameof(OnSerialized1));
    }

    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Log.Add(nameof(OnSerialized2));
    }

    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Log.Add(nameof(OnDeserializing1));
    }

    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Log.Add(nameof(OnDeserializing2));
    }

    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Log.Add(nameof(OnDeserialized1));
    }

    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Log.Add(nameof(OnDeserialized2));
    }

    // allow more



    [MemoryPackOnSerializing]
    public static void OnSerializing_M1<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref MethodCall? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        Log.Add(nameof(OnSerializing_M1));
    }

    [MemoryPackOnSerializing]
    public void OnSerializing_M2<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref MethodCall? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        Log.Add(nameof(OnSerializing_M2));
    }

    [MemoryPackOnSerialized]
    public static void OnSerialized_M1<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref MethodCall? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        Log.Add(nameof(OnSerialized_M1));
    }


    [MemoryPackOnSerialized]
    public void OnSerialized_M2<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref MethodCall? value)
#if NET7_0_OR_GREATER
        where TBufferWriter : IBufferWriter<byte>
#else
        where TBufferWriter : class, IBufferWriter<byte>
#endif
    {
        Log.Add(nameof(OnSerialized_M2));
    }



    [MemoryPackOnDeserializing]
    public static void OnDeserializing_M1(ref MemoryPackReader reader, ref MethodCall? value)
    {
        Log.Add(nameof(OnDeserializing_M1));
    }

    [MemoryPackOnDeserializing]
    public void OnDeserializing_M2(ref MemoryPackReader reader, ref MethodCall? value)
    {
        Log.Add(nameof(OnDeserializing_M2));
    }

    [MemoryPackOnDeserialized]
    public static void OnDeserialized_M1(ref MemoryPackReader reader, ref MethodCall? value)
    {
        Log.Add(nameof(OnDeserialized_M1));
    }

    [MemoryPackOnDeserialized]
    public void OnDeserialized_M2(ref MemoryPackReader reader, ref MethodCall? value)
    {
        Log.Add(nameof(OnDeserialized_M2));
    }


    // not allow parameter exists.

    //[MemoryPackOnSerialized]
    //public void InvalidMethodThatHasParameter(int x)
    //{
    //}
}


// unmanaged type can't add attributes.
//[MemoryPackable]
//public partial struct UnmanagedStructMethod
//{
//    public int X;

//    [MemoryPackOnSerialized]
//    public void Foo()
//    {
//    }
//}



================================================
FILE: tests/MemoryPack.Tests/Models/NamespaceMempack.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.MemoryPack
{

    [MemoryPackable]
    public partial class MemModel1
    {
        public int MyProperty { get; set; }
    }

}

namespace MemoryPack.Tests.MemoryPack
{

    [MemoryPackable]
    public partial class MemModel2
    {
        public int MyProperty { get; set; }
    }

}


namespace MemoryPack.Tests.Models.MemoryPack
{

    [MemoryPackable]
    public partial class MemModel3
    {
        public int MyProperty { get; set; }
    }

}



================================================
FILE: tests/MemoryPack.Tests/Models/Overwrite.cs
================================================
﻿using System;
using System.Collections.Generic;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class Overwrite
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
    public String? MyProperty3 { get; set; }
    public string? MyProperty4 { get; set; }
}

[MemoryPackable]
public partial struct Overwrite2
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
    public String? MyProperty3 { get; set; }
    public string? MyProperty4 { get; set; }
}


[MemoryPackable]
public partial class Overwrite3
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
    public String? MyProperty3 { get; set; }
    public string? MyProperty4 { get; set; }

    public Overwrite3(int myProperty1, int myProperty2)
    {
        this.MyProperty1 = myProperty1;
        this.MyProperty2 = myProperty2;
    }
}

[MemoryPackable]
public partial class Overwrite4
{
    public int MyProperty1 { get; set; }
    public Overwrite? MyProperty2 { get; set; }
    public List<int>? MyProperty3 { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/Records.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial struct UnmanagedStruct
{
    public int X;
    public int Y;
    public int Z;
}

[MemoryPackable]
public partial struct IncludesReferenceStruct
{
    public int X;
    public string? Y;
}

#if NET7_0_OR_GREATER

[MemoryPackable]
public partial class RequiredType
{
    public required int MyProperty1 { get; set; }
    public required string MyProperty2 { get; set; }
}

[MemoryPackable]
public partial struct RequiredType2
{
    public required int MyProperty1 { get; set; }
    public required string MyProperty2 { get; set; }

    public void F()
    {
        // new MyRecord()
    }
}

#endif

[MemoryPackable]
public partial struct StructWithConstructor1
{
    public string MyProperty { get; set; }

    public StructWithConstructor1(string myProperty)
    {
        this.MyProperty = myProperty;
    }
}

[MemoryPackable]
public partial record MyRecord(int foo, int bar, string baz);

[MemoryPackable]
public partial record struct StructRecordUnmanaged(int foo, int bar);


[MemoryPackable]
public partial record struct StructRecordWithReference(int foo, string bar);



================================================
FILE: tests/MemoryPack.Tests/Models/Recursive.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class Recursive
{
    public int MyProperty { get; set; }
    public Recursive? Rec { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/StandardType.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// namespaced
namespace MemoryPack.Tests.Models
{
    // MEMPACK001 must be partial
    // [MemoryPackable]
    //public class Ng
    //{

    //}

    [MemoryPackable]
    public partial class StandardTypeZero
    {
    }

    [MemoryPackable]
    public partial class StandardTypeOne
    {
        public int One { get; set; }
    }


    [MemoryPackable]
    public partial class StandardTypeTwo
    {
        public int One { get; set; }
        public int Two { get; set; }

        public StandardTypeTwo()
        {
            // _ = new StandardTypeTwoFormatter();
        }

        // MEMPACK002 nested is not allowed
        //[MemoryPackable]
        //public partial class Nested
        //{
        //    public int One { get; set; }
        //}
    }

    [MemoryPackable]
    public partial struct StandardUnmanagedStruct
    {
        public int MyProperty { get; set; }
    }

    [MemoryPackable]
    public partial struct StandardStruct
    {
        public string MyProperty { get; set; }

        public StandardStruct()
        {
            MyProperty = default!;
        }
    }

    public partial class NestedContainer
    {
        [MemoryPackable]
        public partial class StandardTypeNested
        {
            public int One { get; set; }
        }
    }

    public partial class DoublyNestedContainer
    {
        public partial class DoublyNestedContainerInner
        {
            [MemoryPackable]
            public partial class StandardTypeDoublyNested
            {
                public int One { get; set; }
            }
        }
    }


    [MemoryPackable]
    public partial class WithArray
    {
        public StandardTypeOne[]? One { get; set; }
    }

}

// another namespace, same type name
namespace MemoryPack.Tests.Models.More
{

    [MemoryPackable]
    public partial class StandardTypeTwo
    {
        public string? One { get; set; }
        public string? Two { get; set; }

        public StandardTypeTwo()
        {
            // new StandardTypeTwoFormatter();
        }
    }
}

[MemoryPackable]
public partial class GlobalNamespaceType
{
    public int MyProperty { get; set; }

    public GlobalNamespaceType()
    {
        // _ = new GlobalNamespaceTypeFormatter();
    }
}



================================================
FILE: tests/MemoryPack.Tests/Models/Union.cs
================================================
﻿using Microsoft.CodeAnalysis.Operations;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;


[MemoryPackable]
public partial class StandardBase
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
}

[MemoryPackable]
public partial class Derived1 : StandardBase
{
    public int DerivedProp1 { get; set; }
    public int DerivedProp2 { get; set; }
}

[MemoryPackable]
public partial class Derived2 : Derived1
{
    public int Derived2Prop1 { get; set; }
    public int Derived2Prop2 { get; set; }
}


[MemoryPackable]
[MemoryPackUnion(0, typeof(Impl1))]
[MemoryPackUnion(253, typeof(Impl2))]
public partial interface IUnionInterface
{
    int MyProperty { get; }
}

[MemoryPackable]
public partial class Impl1 : IUnionInterface
{
    public int MyProperty { get; set; }
    public long Foo { get; set; }
}

[MemoryPackable]
public partial class Impl2 : IUnionInterface
{
    public int MyProperty { get; set; }
    public string? Bar { get; set; }
}

[MemoryPackable]
[MemoryPackUnion(0, typeof(ImplA1))]
[MemoryPackUnion(1, typeof(ImplA2))]
public abstract partial class UnionAbstractClass
{
    public virtual int MyProperty { get; set; }
}

[MemoryPackable]
public partial class ImplA1 : UnionAbstractClass
{
    public override int MyProperty { get; set; }
    public long Foo { get; set; }
}

[MemoryPackable]
public partial class ImplA2 : UnionAbstractClass
{
    public override int MyProperty { get; set; }
    public string? Bar { get; set; }
}


[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IForExternalUnion
{
    public int BaseValue { get; set; }
}

[MemoryPackable]
public partial class AForOne : IForExternalUnion
{
    public int BaseValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackable]
public partial class AForTwo : IForExternalUnion
{
    public int BaseValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackUnionFormatter(typeof(IForExternalUnion))]
[MemoryPackUnion(0, typeof(AForOne))]
[MemoryPackUnion(1, typeof(AForTwo))]
public partial class ForExternalUnionFormatter
{
}


[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IGenericsUnion<T>
{
    public T? NoValue { get; set; }
}

[MemoryPackable]
public partial class BForOne<T> : IGenericsUnion<T>
{
    public T? NoValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackable]
public partial class BForTwo<T> : IGenericsUnion<T>
{
    public T? NoValue { get; set; }
    public int MyProperty { get; set; }
}

[MemoryPackUnionFormatter(typeof(IGenericsUnion<>))]
[MemoryPackUnion(0, typeof(BForOne<>))]
[MemoryPackUnion(1, typeof(BForTwo<>))]
public partial class ForExternalUnionFormatter2<T>
{
}

[MemoryPackUnionFormatter(typeof(IGenericsUnion<string>))]
[MemoryPackUnion(0, typeof(BForOne<string>))]
[MemoryPackUnion(1, typeof(BForTwo<string>))]
public partial class ForExternalUnionFormatter3
{
}


[MemoryPackable]
public partial class NoraType
{
    public IForExternalUnion? ExtUnion { get; set; }
    public UnionAbstractClass? AbstractUnion { get; set; }
}

// Union for record
// https://github.com/Cysharp/MemoryPack/issues/86

[MemoryPackable(SerializeLayout.Explicit)]
public sealed partial record ChargingBookSubmittedEvent
    ([property: MemoryPackOrder(1)] string ChargingPlatform, [property: MemoryPackOrder(2)] decimal Amount) : AbstractAuditEvent;

[MemoryPackUnion(0, typeof(ChargingBookSubmittedEvent))]
[MemoryPackable(SerializeLayout.Explicit)]
public abstract partial record AbstractAuditEvent
{
    [MemoryPackOrder(0)]
    public DateTimeOffset EventDate { get; init; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/Versioning.cs
================================================
﻿using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class Versioning0
{
}

[MemoryPackable]
public partial class Versioning1
{
    public int MyProperty1 { get; set; }
}

[MemoryPackable]
public partial class Versioning2
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
}

[MemoryPackable]
public partial class Versioning3
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
    public int MyProperty3 { get; set; }
}

[MemoryPackable]
public partial class Versioning4
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
    public int MyProperty3 { get; set; }
    public int MyProperty4 { get; set; }
}

[MemoryPackable]
public partial class WrappedVersioning2
{
    public string? Before { get; set; }
    public Versioning2? V2 { get; set; }
    public string? After { get; set; }
}


[MemoryPackable]
public partial class WrappedVersioning4
{
    public string? Before { get; set; }
    public Versioning4? V4 { get; set; }
    public string? After { get; set; }
}



================================================
FILE: tests/MemoryPack.Tests/Models/VersionTolerant.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Models;

[MemoryPackable]
public partial class VTWrapper<T>
{
    public T? Versioned { get; set; }
    public int[]? Values { get; set; }
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant0
{
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant1
{
    [MemoryPackOrder(0)]
    public int MyProperty1 { get; set; } = default;
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant2
{
    [MemoryPackOrder(0)]
    public int MyProperty1 { get; set; } = default;

    [MemoryPackOrder(1)]
    public long MyProperty2 { get; set; } = default;
}



[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant3
{
    [MemoryPackOrder(0)]
    public int MyProperty1 { get; set; } = default;

    [MemoryPackOrder(1)]
    public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant4
{
    [MemoryPackOrder(0)]
    public int MyProperty1 { get; set; } = default;

    //[MemoryPackOrder(1)]
    //public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerant5
{
    //[MemoryPackOrder(0)]
    //public int MyProperty1 { get; set; } = default;

    //[MemoryPackOrder(1)]
    //public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;

    [MemoryPackOrder(5)]
    public ushort[] MyProperty6 { get; set; } = default!;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class Version1
{
    [MemoryPackOrder(0)]
    public int Id { get; set; }

    [MemoryPackOrder(1)]
    public string Name { get; set; } = default!;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class Version2
{
    [MemoryPackOrder(0)]
    public int Id { get; set; }

    //deleted
    //[MemoryPackOrder(1)] 
    //public string Name { get; set; } = default!;

    [MemoryPackOrder(2)]
    public string FirstName { get; set; } = default!;
    [MemoryPackOrder(3)]
    public string LastName { get; set; } = default!;
}





[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersionTolerant1
{
    [MemoryPackOrder(0)]
    public Version MyProperty1 { get; set; } = default!;
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersionTolerant2
{
    [MemoryPackOrder(0)]
    public Version MyProperty1 { get; set; } = default!;

    [MemoryPackOrder(1)]
    public long MyProperty2 { get; set; } = default;
}



[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersionTolerant3
{
    [MemoryPackOrder(0)]
    public Version MyProperty1 { get; set; } = default!;

    [MemoryPackOrder(1)]
    public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;
}


[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersionTolerant4
{
    [MemoryPackOrder(0)]
    public Version MyProperty1 { get; set; } = default!;

    //[MemoryPackOrder(1)]
    //public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersionTolerant5
{
    //[MemoryPackOrder(0)]
    //public int MyProperty1 { get; set; } = default;

    //[MemoryPackOrder(1)]
    //public long MyProperty2 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty3 { get; set; } = default;

    [MemoryPackOrder(5)]
    public Version MyProperty6 { get; set; } = default!;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersion1
{
    [MemoryPackOrder(0)]
    public Version? Id { get; set; }

    [MemoryPackOrder(1)]
    public string Name { get; set; } = default!;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class MoreVersion2
{
    [MemoryPackOrder(0)]
    public Version? Id { get; set; }

    //deleted
    //[MemoryPackOrder(1)] 
    //public string Name { get; set; } = default!;

    [MemoryPackOrder(2)]
    public string FirstName { get; set; } = default!;
    [MemoryPackOrder(3)]
    public string LastName { get; set; } = default!;
}



================================================
FILE: tests/MemoryPack.Tests/Models/WellknownTypes.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
using System.Globalization;

namespace MemoryPack.Tests.Models;

// no error generatable.
#pragma warning disable CS8618
[MemoryPackable]
public partial class HogeHoge
{
    public BigInteger P1;
    public Version P2;
    public Uri P3;
    public TimeZoneInfo P4;
    public BitArray P5;
    public StringBuilder P6;
    public Type P7;
    public int[,] P8;
    public int[,,] P9;
    public int[,,,] P10;
    // generics
    public KeyValuePair<int, int> P11;
    public Lazy<int> P12;
    public Nullable<int> P13;
    // collecition
    public ArraySegment<int> P14;
    public Memory<int> P15;
    public ReadOnlyMemory<int> P16;
    public ReadOnlySequence<int> P17;

    public List<int> P18;
    public Stack<int> P19;
    public Queue<int> P20;
    public LinkedList<int> P21;
    public HashSet<int> P22;
#if NET7_0_OR_GREATER
    public PriorityQueue<int, int> P23;
#endif
    public ObservableCollection<int> P24;
    public Collection<int> P25;
    public ConcurrentQueue<int> P26;
    public ConcurrentStack<int> P27;
    public ConcurrentBag<int> P28;
    public Dictionary<int, int> P29;
    public SortedDictionary<int, int> P30;
    public SortedList<int, int> P31;
    public ConcurrentDictionary<int, int> P32;
    public ReadOnlyCollection<int> P33;
    public ReadOnlyObservableCollection<int> P34;
    public BlockingCollection<int> P35;

    public ImmutableArray<int> P36;
    public ImmutableList<int> P37;
    public ImmutableQueue<int> P38;
    public ImmutableStack<int> P39;
    public ImmutableDictionary<int, int> P40;
    public ImmutableSortedDictionary<int, int> P41;
    public ImmutableSortedSet<int> P42;
    public ImmutableHashSet<int> P43;
    public IImmutableList<int> P44;
    public IImmutableQueue<int> P45;
    public IImmutableStack<int> P46;
    public IImmutableDictionary<int, int> P47;
    public IImmutableSet<int> P48;
    public IEnumerable<int> P49;
    public ICollection<int> P50;
    public IReadOnlyCollection<int> P51;
    public IList<int> P52;
    public IReadOnlyList<int> P53;
    public IDictionary<int, int> P54;
    public IReadOnlyDictionary<int, int> P55;
    public ILookup<int, int> P56;
    public IGrouping<int, int> P57;
    public ISet<int> P58;
#if NET7_0_OR_GREATER
    public IReadOnlySet<int> P59;
#endif
    public SortedSet<int> P60;
    public Nullable<MyStruct> P61;
    public KnownFruits P62;
    public Nullable<KnownFruits> P63;
    public string SEPARATOR1;
    public Nullable<int> P64;
    public CultureInfo P65;

    // tuples
    public Tuple<int, string, int> T3;
    public ValueTuple<int, string, int> VT3;
    // more
    public Nullable<MyStruct> N1;
    public KeyValuePair<string, string> N2;

    public IUnionType? U1;

    // IMemoryOwner support is removed
    //public IMemoryOwner<byte> MO1;
    //public IMemoryOwner<string> MO2;
}


[MemoryPackable]
public partial struct MyStruct
{
    public string? V;
}

[MemoryPackUnion(0, typeof(AUnion))]
public partial interface IUnionType
{

}



[MemoryPackable]
public partial class AUnion : IUnionType
{

}

public enum KnownFruits
{
    Orange, Grape
}



================================================
FILE: tests/MemoryPack.Tests/SourceGeneratorTests/GeneratorDiagnosticsTest.cs
================================================
﻿#if NET7_0_OR_GREATER

using MemoryPack.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public partial class GeneratorDiagnosticsTest
{
    void Compile(int id, string code, bool allowMultipleError = false)
    {
        var (_, diagnostics) = CSharpGeneratorRunner.RunGenerator(code);
        if (!allowMultipleError)
        {
            diagnostics.Length.Should().Be(1);
            diagnostics[0].Id.Should().Be("MEMPACK" + id.ToString("000"));
        }
        else
        {
            diagnostics.Select(x => x.Id).Should().Contain("MEMPACK" + id.ToString("000"));
        }
    }

    [Fact]
    public void MEMPACK001_MuestBePartial()
    {
        Compile(1, """
using MemoryPack;

[MemoryPackable]
public class Hoge
{
}
""");
    }

    [Fact]
    public void MEMPACK003_AbstractMustUnion()
    {
        Compile(3, """
using MemoryPack;

[MemoryPackable]
public abstract partial class Hoge
{
}
""");

        Compile(3, """
using MemoryPack;

[MemoryPackable]
public partial interface IHoge
{
}
""");
    }

    [Fact]
    public void MEMPACK004_MultipleCtorWithoutAttribute()
    {
        Compile(4, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public Hoge()
    {
    }

    public Hoge(int x)
    {
    }
}
""");
    }

    [Fact]
    public void MEMPACK005_MultipleCtorAttribute()
    {
        Compile(5, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    [MemoryPackConstructor]
    public Hoge()
    {
    }

    [MemoryPackConstructor]
    public Hoge(int x)
    {
    }
}
""");
    }

    [Fact]
    public void MEMPACK006_ConstructorHasNoMatchedParameter()
    {
        Compile(6, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public int Foo { get; set;}

    [MemoryPackConstructor]
    public Hoge(int hhogee)
    {
        this.Foo = hhogee;
    }
}
""");
    }

    [Fact]
    public void MEMPACK007_OnMethodHasParameter()
    {
        Compile(7, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    [MemoryPackOnSerializing]
    void Foo(int x)
    {
    }
}
""");
    }

    [Fact]
    public void MEMPACK008_OnMethodInUnamannagedType()
    {
        Compile(8, """
using MemoryPack;

[MemoryPackable]
public partial struct Hoge
{
    [MemoryPackOnSerializing]
    void Foo()
    {
    }
}
""");
    }

    [Fact]
    public void MEMPACK009_OverrideMemberCantAddAnnotation()
    {
        Compile(9, """
using MemoryPack;

public abstract class MyClass
{
    public abstract int MyProperty { get; set; }
}

[MemoryPackable]
public partial class MyClass2 : MyClass
{
    [MemoryPackIgnore]
    public override int MyProperty { get; set; }
}
""");

        Compile(9, """
using MemoryPack;

public abstract class MyClass
{
    public abstract int MyProperty { get; set; }
}

[MemoryPackable]
public partial class MyClass3 : MyClass
{
    [MemoryPackInclude]
    public override int MyProperty { get; set; }
}

""");
    }

    [Fact]
    public void MEMPACK010_016_Union()
    {
        Compile(10, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(0, typeof(string))]
public sealed partial class MyClass
{
}
""", allowMultipleError: true);

        Compile(11, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(0, typeof(string))]
public partial class MyClass
{
}
""", allowMultipleError: true);

        Compile(12, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(1, typeof(MyClass1))]
[MemoryPackUnion(1, typeof(MyClass2))]
public partial interface IMyClass
{
}

[MemoryPackable]
public partial class MyClass1 : IMyClass
{
}

[MemoryPackable]
public partial class MyClass2 : IMyClass
{
}
""", allowMultipleError: true);

        Compile(13, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(1, typeof(MyClass1))]
[MemoryPackUnion(2, typeof(MyClass2))]
public partial interface IMyClass
{
}

[MemoryPackable]
public partial class MyClass1 : IMyClass
{
}

[MemoryPackable]
public partial class MyClass2
{
}
""", allowMultipleError: true);

        Compile(14, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(1, typeof(MyClass1))]
[MemoryPackUnion(2, typeof(MyClass2))]
public abstract partial class MyClassBase
{
}

[MemoryPackable]
public partial class MyClass1 : MyClassBase
{
}

[MemoryPackable]
public partial class MyClass2
{
}
""", allowMultipleError: true);

        Compile(15, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(1, typeof(MyClass1))]
[MemoryPackUnion(2, typeof(MyClass2))]
public partial interface IMyClass
{
}

[MemoryPackable]
public partial class MyClass1 : IMyClass
{
}

[MemoryPackable]
public partial struct MyClass2 : IMyClass
{
}
""", allowMultipleError: true);

        Compile(16, """
using MemoryPack;

[MemoryPackable]
[MemoryPackUnion(1, typeof(MyClass1))]
[MemoryPackUnion(2, typeof(MyClass2))]
public partial interface IMyClass
{
}

[MemoryPackable]
public partial class MyClass1 : IMyClass
{
}

// [MemoryPackable]
public partial class MyClass2 : IMyClass
{
}
""", allowMultipleError: true);

    }



    [Fact]
    public void MEMPACK018_MemberCantSerializeType()
    {
        Compile(18, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public object Foo { get; set;}
}
""");

        Compile(18, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public System.Array Foo { get; set;}
}
""");

        Compile(18, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public System.Action Foo { get; set;}
}
""");
    }

    [Fact]
    public void MEMPACK019_MemberIsNotMemoryPackable()
    {
        Compile(19, """
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    public Foo Bar { get; set;}
}

public class Foo { }
""");
    }

    [Fact]
    public void MEMPACK020_TypeIsRefStruct()
    {
        Compile(20, """
using MemoryPack;

[MemoryPackable]
public ref partial struct Hoge
{
    public int Bar { get; set;}
}
""");
    }

    [Fact]
    public void MEMPACK021_MemberIsRefStruct()
    {
        Compile(21, """
using System;
using MemoryPack;

[MemoryPackable]
public partial class Hoge
{
    byte[] b = default!;
    public ReadOnlySpan<byte> SpanProp => b;
}
""");
    }

    [Fact]
    public void MEMPACK022_CollectionGenerateIsAbstract()
    {
        Compile(22, """
using System.Collections.Generic;
using MemoryPack;

[MemoryPackable(GenerateType.Collection)]
public abstract partial class MyList : List<int>
{
}
""");
    }

    [Fact]
    public void MEMPACK023_CollectionGenerateNotImplementedInterface()
    {
        Compile(23, """
using MemoryPack;

[MemoryPackable(GenerateType.Collection)]
public partial class Hoge
{
}
""");
    }

    [Fact]
    public void MEMPACK024_CollectionGenerateNoParameterlessConstructor()
    {
        Compile(24, """
using System.Collections.Generic;
using MemoryPack;

[MemoryPackable(GenerateType.Collection)]
public partial class Hoge : List<int>
{
    public Hoge(int x)
    {
        Add(x);
    }
}
""");
    }

    [Fact]
    public void MEMPACK025_AllMembersMustAnnotateOrder()
    {
        Compile(25, """
using MemoryPack;

[MemoryPackable(SerializeLayout.Explicit)]
public partial class Hoge
{
    [MemoryPackOrder(0)]
    public int Prop1 { get; set; }
    public int Prop2 { get; set; }
}
""");
    }

    [Fact]
    public void MEMPACK026_AllMembersMustBeContinuousNumber()
    {
        Compile(26, """
using MemoryPack;

[MemoryPackable(SerializeLayout.Explicit)]
public partial class Hoge
{
    [MemoryPackOrder(0)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(2)]
    public int Prop2 { get; set; }
}
""");
    }

    [Fact]
    public void MEMPACK033_CircularReferenceOnlyAllowsParameterlessConstructor()
    {
        Compile(33, """
using MemoryPack;

[MemoryPackable(GenerateType.CircularReference)]
public partial class Hoge
{
    [MemoryPackOrder(0)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(2)]
    public int Prop2 { get; set; }

    public Hoge(int prop1, int prop2)
    {
        this.Prop1 = prop1;
        this.Prop2 = prop2;
    }
}
""");
    }

    [Fact]
    public void MEMPACK034_UnamangedStructWithLayoutAutoField()
    {
        var code = """
using System;
using MemoryPack;

[MemoryPackable]
public partial struct Hoge
{
    public int X;
    public int Y;
    public DateTime DT;
}
""";

        {
            var (_, diagnostics) = CSharpGeneratorRunner.RunGenerator(code, preprocessorSymbols: new[] { "NET7_0_OR_GREATER" });
            diagnostics.Length.Should().Be(0);
        }
        {
            var (_, diagnostics) = CSharpGeneratorRunner.RunGenerator(code, preprocessorSymbols: new string[] { });
            diagnostics.Length.Should().Be(1);
            diagnostics[0].Id.Should().Be("MEMPACK034");
        }
    }

    [Fact]
    public void MEMPACK035_UnamangedStructMemoryPackCtor()
    {
        Compile(35, """
using MemoryPack;

[MemoryPackable]
public partial struct Hoge
{
    public int X;
    public int Y;

    [MemoryPackConstructor]
    public Hoge(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}
""");
    }


    [Fact]
    public void MEMPACK036_InheritTypeCanNotIncludeParentPrivateMember()
    {
        Compile(36, """
using MemoryPack;

[MemoryPackable(SerializeLayout.Explicit)]
public  partial class TestParent2
{
    [MemoryPackOrder(0)]
    public int A;

    [MemoryPackOrder(1), MemoryPackInclude]
    private int B;

    [MemoryPackOrder(2)]
    public int C;
}

[MemoryPackable(SerializeLayout.Explicit)]
public sealed partial class TestChild2 : TestParent2
{
    [MemoryPackOrder(3)]
    public int D;
}
""");
    }


    [Fact]
    public void MEMPACK037_ReadOnlyFieldMustBeConstructorMember()
    {
        Compile(37, """
using MemoryPack;

[MemoryPackable]
public partial class ReadOnlyTest
{
    public readonly int A;
}

""");
    }

    [Fact]
    public void MEMPACK038_()
    {
        Compile(38, """
using MemoryPack;

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class Tester
{
    [MemoryPackOrder(0)]
    public int I1 { get; set; }

    [MemoryPackOrder(0)]
    public string S1 { get; set; }

    [MemoryPackOrder(1)]
    public bool B1 { get; set; }
}

""");
    }

    [Fact]
    public void MEMPACK040_SuppressDefaultInitializationMustBeSettable()
    {
        Compile(40, """
using MemoryPack;

[MemoryPackable]
public partial class Tester
{
    [SuppressDefaultInitialization]
    public required int I1 { get; set; }
}

""");

        Compile(40, """
using MemoryPack;

[MemoryPackable]
public partial class Tester
{
    [SuppressDefaultInitialization]
    public int I1 { get; init; }
}

""");

        Compile(40, """
using MemoryPack;

[MemoryPackable]
public partial class Tester
{
    [SuppressDefaultInitialization]
    public readonly int I1;

    [MemoryPackConstructor]
    public Tester(int i1)
    {
        I1 = i1;
    }
}

""");
    }

    [Fact]
    public void MEMPACK041_UnmanagedStructCannotBeVersionTolerant()
    {
        Compile(41, """
using MemoryPack;

[MemoryPackable(GenerateType.VersionTolerant)]
public partial struct Tester
{
    [MemoryPackOrder(0)]
    public int I1 { get; init; }
}
""");
    }

    [Fact]
    public void MEMPACK042_NestedContainingTypesMustBePartial()
    {
        Compile(42, """
                    using MemoryPack;

                    public struct NestedContainer
                    {
                        [MemoryPackable]
                        public partial struct NestedStruct
                        {
                            public int I1 { get; init; }
                        }
                    }
                    """);
    }
}

#endif



================================================
FILE: tests/MemoryPack.Tests/SourceGeneratorTests/GeneratorDiagnosticsTest.ManyMembers.cs
================================================
﻿#if NET7_0_OR_GREATER

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

partial class GeneratorDiagnosticsTest
{
    [Fact]
    public void MEMPACK017_TooManyMembers()
    {
        Compile(17, """
using MemoryPack;

[MemoryPackable]
public partial class ManyMembers
{
    public int MyProperty1;
    public int MyProperty2;
    public int MyProperty3;
    public int MyProperty4;
    public int MyProperty5;
    public int MyProperty6;
    public int MyProperty7;
    public int MyProperty8;
    public int MyProperty9;
    public int MyProperty10;
    public int MyProperty11;
    public int MyProperty12;
    public int MyProperty13;
    public int MyProperty14;
    public int MyProperty15;
    public int MyProperty16;
    public int MyProperty17;
    public int MyProperty18;
    public int MyProperty19;
    public int MyProperty20;
    public int MyProperty21;
    public int MyProperty22;
    public int MyProperty23;
    public int MyProperty24;
    public int MyProperty25;
    public int MyProperty26;
    public int MyProperty27;
    public int MyProperty28;
    public int MyProperty29;
    public int MyProperty30;
    public int MyProperty31;
    public int MyProperty32;
    public int MyProperty33;
    public int MyProperty34;
    public int MyProperty35;
    public int MyProperty36;
    public int MyProperty37;
    public int MyProperty38;
    public int MyProperty39;
    public int MyProperty40;
    public int MyProperty41;
    public int MyProperty42;
    public int MyProperty43;
    public int MyProperty44;
    public int MyProperty45;
    public int MyProperty46;
    public int MyProperty47;
    public int MyProperty48;
    public int MyProperty49;
    public int MyProperty50;
    public int MyProperty51;
    public int MyProperty52;
    public int MyProperty53;
    public int MyProperty54;
    public int MyProperty55;
    public int MyProperty56;
    public int MyProperty57;
    public int MyProperty58;
    public int MyProperty59;
    public int MyProperty60;
    public int MyProperty61;
    public int MyProperty62;
    public int MyProperty63;
    public int MyProperty64;
    public int MyProperty65;
    public int MyProperty66;
    public int MyProperty67;
    public int MyProperty68;
    public int MyProperty69;
    public int MyProperty70;
    public int MyProperty71;
    public int MyProperty72;
    public int MyProperty73;
    public int MyProperty74;
    public int MyProperty75;
    public int MyProperty76;
    public int MyProperty77;
    public int MyProperty78;
    public int MyProperty79;
    public int MyProperty80;
    public int MyProperty81;
    public int MyProperty82;
    public int MyProperty83;
    public int MyProperty84;
    public int MyProperty85;
    public int MyProperty86;
    public int MyProperty87;
    public int MyProperty88;
    public int MyProperty89;
    public int MyProperty90;
    public int MyProperty91;
    public int MyProperty92;
    public int MyProperty93;
    public int MyProperty94;
    public int MyProperty95;
    public int MyProperty96;
    public int MyProperty97;
    public int MyProperty98;
    public int MyProperty99;
    public int MyProperty100;
    public int MyProperty101;
    public int MyProperty102;
    public int MyProperty103;
    public int MyProperty104;
    public int MyProperty105;
    public int MyProperty106;
    public int MyProperty107;
    public int MyProperty108;
    public int MyProperty109;
    public int MyProperty110;
    public int MyProperty111;
    public int MyProperty112;
    public int MyProperty113;
    public int MyProperty114;
    public int MyProperty115;
    public int MyProperty116;
    public int MyProperty117;
    public int MyProperty118;
    public int MyProperty119;
    public int MyProperty120;
    public int MyProperty121;
    public int MyProperty122;
    public int MyProperty123;
    public int MyProperty124;
    public int MyProperty125;
    public int MyProperty126;
    public int MyProperty127;
    public int MyProperty128;
    public int MyProperty129;
    public int MyProperty130;
    public int MyProperty131;
    public int MyProperty132;
    public int MyProperty133;
    public int MyProperty134;
    public int MyProperty135;
    public int MyProperty136;
    public int MyProperty137;
    public int MyProperty138;
    public int MyProperty139;
    public int MyProperty140;
    public int MyProperty141;
    public int MyProperty142;
    public int MyProperty143;
    public int MyProperty144;
    public int MyProperty145;
    public int MyProperty146;
    public int MyProperty147;
    public int MyProperty148;
    public int MyProperty149;
    public int MyProperty150;
    public int MyProperty151;
    public int MyProperty152;
    public int MyProperty153;
    public int MyProperty154;
    public int MyProperty155;
    public int MyProperty156;
    public int MyProperty157;
    public int MyProperty158;
    public int MyProperty159;
    public int MyProperty160;
    public int MyProperty161;
    public int MyProperty162;
    public int MyProperty163;
    public int MyProperty164;
    public int MyProperty165;
    public int MyProperty166;
    public int MyProperty167;
    public int MyProperty168;
    public int MyProperty169;
    public int MyProperty170;
    public int MyProperty171;
    public int MyProperty172;
    public int MyProperty173;
    public int MyProperty174;
    public int MyProperty175;
    public int MyProperty176;
    public int MyProperty177;
    public int MyProperty178;
    public int MyProperty179;
    public int MyProperty180;
    public int MyProperty181;
    public int MyProperty182;
    public int MyProperty183;
    public int MyProperty184;
    public int MyProperty185;
    public int MyProperty186;
    public int MyProperty187;
    public int MyProperty188;
    public int MyProperty189;
    public int MyProperty190;
    public int MyProperty191;
    public int MyProperty192;
    public int MyProperty193;
    public int MyProperty194;
    public int MyProperty195;
    public int MyProperty196;
    public int MyProperty197;
    public int MyProperty198;
    public int MyProperty199;
    public int MyProperty200;
    public int MyProperty201;
    public int MyProperty202;
    public int MyProperty203;
    public int MyProperty204;
    public int MyProperty205;
    public int MyProperty206;
    public int MyProperty207;
    public int MyProperty208;
    public int MyProperty209;
    public int MyProperty210;
    public int MyProperty211;
    public int MyProperty212;
    public int MyProperty213;
    public int MyProperty214;
    public int MyProperty215;
    public int MyProperty216;
    public int MyProperty217;
    public int MyProperty218;
    public int MyProperty219;
    public int MyProperty220;
    public int MyProperty221;
    public int MyProperty222;
    public int MyProperty223;
    public int MyProperty224;
    public int MyProperty225;
    public int MyProperty226;
    public int MyProperty227;
    public int MyProperty228;
    public int MyProperty229;
    public int MyProperty230;
    public int MyProperty231;
    public int MyProperty232;
    public int MyProperty233;
    public int MyProperty234;
    public int MyProperty235;
    public int MyProperty236;
    public int MyProperty237;
    public int MyProperty238;
    public int MyProperty239;
    public int MyProperty240;
    public int MyProperty241;
    public int MyProperty242;
    public int MyProperty243;
    public int MyProperty244;
    public int MyProperty245;
    public int MyProperty246;
    public int MyProperty247;
    public int MyProperty248;
    public int MyProperty249;
    public int MyProperty250;
}
""");
    }
}


#endif



================================================
FILE: tests/MemoryPack.Tests/SourceGeneratorTests/GeneratorDiagnosticsTest.TypeScript.cs
================================================
﻿#if NET7_0_OR_GREATER

using MemoryPack.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests;

public partial class GeneratorDiagnosticsTest
{
    void Compile2(int id, string code, bool allowMultipleError = false)
    {
        var (_, diagnostics) = CSharpGeneratorRunner.RunGenerator(code, options: new TypeScriptOptionProvider());
        if (!allowMultipleError)
        {
            diagnostics.Length.Should().Be(1);
            diagnostics[0].Id.Should().Be("MEMPACK" + id.ToString("000"));
        }
        else
        {
            diagnostics.Select(x => x.Id).Should().Contain("MEMPACK" + id.ToString("000"));
        }
    }

    string CompileAndRead(string code, string fileName, bool enableNullableTypes = true)
    {
        var outputDir = Path.GetTempPath();
        var optionProvider = new TypeScriptOptionProvider();

        optionProvider["build_property.MemoryPackGenerator_TypeScriptOutputDirectory"] = outputDir;
        optionProvider["build_property.MemoryPackGenerator_TypeScriptEnableNullableTypes"] = enableNullableTypes ? "true" : "false";

        CSharpGeneratorRunner.RunGenerator(code, options: optionProvider);

        var outputFilePath = Path.Combine(outputDir, fileName);

        return File.ReadAllText(outputFilePath);
    }

    [Fact]
    public void MEMPACK027_GenerateTypeScriptMustBeMemoryPackable()
    {
        Compile2(27, """
using MemoryPack;

[GenerateTypeScript]
public class Hoge
{
}
""");
    }

    [Fact]
    public void MEMPACK028_GenerateTypeScriptOnlyAllowsGenerateTypeObject()
    {
        Compile2(28, """
using MemoryPack;

[MemoryPackable(GenerateType.Collection)]
[GenerateTypeScript]
public partial class Hoge : System.Collections.Generic.List<int>
{
}
""");
    }

    [Fact]
    public void MEMPACK029_GenerateTypeScriptDoesNotAllowGenerics()
    {
        Compile2(29, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge<T>
{
}
""", true);
    }

    [Fact]
    public void MEMPACK030_GenerateTypeScriptDoesNotAllowLongEnum()
    {
        Compile2(30, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public LongEnum MyProperty { get; set; }
}

public enum LongEnum : long
{

}
""", true);

        Compile2(30, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public LongEnum[] MyProperty { get; set; }
}

public enum LongEnum : ulong
{

}
""", true);

        Compile2(30, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public LongEnum? MyProperty { get; set; }
}

public enum LongEnum : long
{

}
""", true);

        Compile2(30, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public System.Collections.Generic.List<LongEnum> MyProperty { get; set; }
}

public enum LongEnum : long
{

}
""", true);
    }

    [Fact]
    public void MEMPACK031_GenerateTypeScriptNotSupportedType()
    {
        Compile2(31, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public System.Version MyProperty { get; set; }
}
""", true);
    }

    [Fact]
    public void MEMPACK032_GenerateTypeScriptNotSupportedType()
    {
        Compile2(32, """
using MemoryPack;

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    [Utf8StringFormatter]
    public string MyProperty { get; set; }
}
""", true);
    }

    [Fact]
    public void GenerateTypeScriptNullableReferenceTypes()
    {
        var generatedCode = CompileAndRead(
            """
            using MemoryPack;

            [MemoryPackable]
            [GenerateTypeScript]
            public partial record FullName
            {
                public string FirstName { get; init; }
                public string? MiddleName { get; init; }
                public string LastName { get; init; }
            }
            """,
            "FullName.ts");

        generatedCode.Should().Contain(
            """
            export class FullName {
                firstName: string;
                middleName: string | null;
                lastName: string;

                constructor() {
                    this.firstName = "";
                    this.middleName = null;
                    this.lastName = "";
            """);
    }


    class TypeScriptOptionProvider : AnalyzerConfigOptionsProvider
    {
        readonly Dictionary<string, string> _values = new();

        public string this[string key]
        {
            get => _values[key];
            set => _values[key] = value;
        }

        public override AnalyzerConfigOptions GlobalOptions => new SimpleOptions(_values);

        public override AnalyzerConfigOptions GetOptions(SyntaxTree tree)
        {
            return new SimpleOptions(_values);
        }

        public override AnalyzerConfigOptions GetOptions(AdditionalText textFile)
        {
            return new SimpleOptions(_values);
        }

        public class SimpleOptions : AnalyzerConfigOptions
        {
            readonly Dictionary<string, string> _configValues;

            public SimpleOptions(Dictionary<string, string> configValues)
            {
                _configValues = configValues;
            }

            /// <inheritdoc />
            public override IEnumerable<string> Keys => _configValues.Keys;

            public override bool TryGetValue(string key, [NotNullWhen(true)] out string? value)
            {
                if (_configValues.ContainsKey(key))
                {
                    value = _configValues[key];

                    return true;
                }

                if (key == "build_property.MemoryPackGenerator_TypeScriptOutputDirectory")
                {
                    value = Path.GetTempPath();
                    return true;
                }

                value = null;
                return false;
            }
        }
    }
}

[MemoryPackable]
[GenerateTypeScript]
public partial class Hoge
{
    public LongEnum? MyProperty { get; set; }
}

public enum LongEnum : long
{

}

public enum ULongEnum : ulong
{

}

#endif



================================================
FILE: tests/MemoryPack.Tests/SourceGeneratorTests/IncrementalGeneratorTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.SourceGeneratorTests;

public class IncrementalGeneratorTest
{
    [Fact]
    public void Run()
    {
        // lang=C#-test
        var step1 = """
[MemoryPackable]
public partial class MyClass
{
    public int MyProperty { get; set; }
}
""";

        // lang=C#-test
        var step2 = """
[MemoryPackable]
public partial class MyClass
{
    public int MyProperty { get; set; }
    // unrelated line
}
""";

        var hoge = CSharpGeneratorRunner.GetIncrementalGeneratorTrackedStepsReasons("MemoryPack.MemoryPackable.", step1, step2);

    }
}





================================================
FILE: tests/MemoryPack.Tests/Streaming/StreamingSerializer.cs
================================================
﻿using MemoryPack.Streaming;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryPack.Tests.Streaming;

public class StreamingSerializer
{
    [Fact]
    public async Task Serialize()
    {
        var seq = Enumerable.Range(1, 10000).ToArray();

        {
            var ms = new MemoryStream();
            await MemoryPackStreamingSerializer.SerializeAsync(ms, seq.Length, seq);
            var v2 = MemoryPackSerializer.Deserialize<int[]>(ms.ToArray());

            v2.Should().Equal(seq);
        }

        {
            var pipe = new Pipe();

            await MemoryPackStreamingSerializer.SerializeAsync(pipe.Writer, seq.Length, seq);

            await pipe.Writer.CompleteAsync();

            pipe.Reader.TryRead(out var result);

            result.IsCompleted.Should().BeTrue();
            var v2 = MemoryPackSerializer.Deserialize<int[]>(result.Buffer);

            v2.Should().Equal(seq);
        }
    }

    [Fact]
    public async Task Deserialize()
    {
        var seq = Enumerable.Range(1, 10000).ToArray();
        var bin = MemoryPackSerializer.Serialize(seq);

        {
            var ms = new MemoryStream(bin);

            var list = new List<int>();
            await foreach (var item in MemoryPackStreamingSerializer.DeserializeAsync<int>(ms))
            {
                list.Add(item);
            }

            list.Should().Equal(seq);
        }




    }

}


[MemoryPackable]
public partial class SampleClassForMemoryPack
{
    public int Id { get; set; }
    public string Name { get; set; }



    public SampleClassForMemoryPack(int id, string name)
    {
        Id = id;
        Name = name;
    }

    public bool Equals(SampleClassForMemoryPack? other)
    {
        if (ReferenceEquals(null, other))
        {
            return false;
        }

        if (ReferenceEquals(this, other))
        {
            return true;
        }

        return Id == other.Id && Name == other.Name;
    }

    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj))
        {
            return false;
        }

        if (ReferenceEquals(this, obj))
        {
            return true;
        }

        if (obj.GetType() != GetType())
        {
            return false;
        }

        return Equals((SampleClassForMemoryPack)obj);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(Id, Name);
    }

    public override string ToString()
    {
        return $"{Id}-{Name}";
    }
}



================================================
FILE: tests/MemoryPack.Tests/Utils/CSharpGeneratorRunner.cs
================================================
﻿using MemoryPack.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;

namespace MemoryPack.Tests.Utils;

public static class CSharpGeneratorRunner
{
    static Compilation baseCompilation = default!;

    [ModuleInitializer]
    public static void InitializeCompilation()
    {
        var globalUsings = """
global using System;
global using System.Linq;
global using System.Collections;
global using System.Collections.Generic;
global using System.Threading;
global using System.Threading.Tasks;
global using System.ComponentModel.DataAnnotations;
global using MemoryPack;
""";

        var systemAssemblies = AppDomain.CurrentDomain.GetAssemblies()
            .Where(x => !x.IsDynamic && !string.IsNullOrWhiteSpace(x.Location));

        var references = systemAssemblies
            .Append(typeof(MemoryPackableAttribute).Assembly) // System Assemblies + MemoryPack.Core.dll
            .Select(x => MetadataReference.CreateFromFile(x.Location))
            .ToArray();

        var compilation = CSharpCompilation.Create("generatortest",
            references: references,
            syntaxTrees: [CSharpSyntaxTree.ParseText(globalUsings, path: "GlobalUsings.cs")],
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary, allowUnsafe: true));

        baseCompilation = compilation;
    }

    public static (Compilation, ImmutableArray<Diagnostic>) RunGenerator(string source, string[]? preprocessorSymbols = null, AnalyzerConfigOptionsProvider? options = null)
    {
        if (preprocessorSymbols == null)
        {
            preprocessorSymbols = new[] { "NET7_0_OR_GREATER" };
        }
        var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp11, preprocessorSymbols: preprocessorSymbols);

        var driver = CSharpGeneratorDriver.Create(new MemoryPackGenerator()).WithUpdatedParseOptions(parseOptions);
        if (options != null)
        {
            driver = (Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver)driver.WithUpdatedAnalyzerConfigOptions(options);
        }

        var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        return (newCompilation, diagnostics);
    }

    public static (string Key, string Reasons)[][] GetIncrementalGeneratorTrackedStepsReasons(string keyPrefixFilter, params string[] sources)
    {
        var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp11);
        var driver = CSharpGeneratorDriver.Create(
            [new MemoryPackGenerator().AsSourceGenerator()],
            driverOptions: new GeneratorDriverOptions(IncrementalGeneratorOutputKind.None, trackIncrementalGeneratorSteps: true))
            .WithUpdatedParseOptions(parseOptions);

        var generatorResults = sources
            .Select(source =>
            {
                var compilation = baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));
                driver = driver.RunGenerators(compilation);
                return driver.GetRunResult().Results[0];
            })
            .ToArray();

        var reasons = generatorResults
            .Select(x => x.TrackedSteps
                .Where(x => x.Key.StartsWith(keyPrefixFilter) || x.Key == "SourceOutput")
                .Select(x =>
                {
                    if (x.Key == "SourceOutput")
                    {
                        var values = x.Value.Where(x => x.Inputs[0].Source.Name?.StartsWith(keyPrefixFilter) ?? false);
                        return (
                            x.Key,
                            Reasons: string.Join(", ", values.SelectMany(x => x.Outputs).Select(x => x.Reason).ToArray())
                        );
                    }
                    else
                    {
                        return (
                            Key: x.Key.Substring(keyPrefixFilter.Length),
                            Reasons: string.Join(", ", x.Value.SelectMany(x => x.Outputs).Select(x => x.Reason).ToArray())
                        );
                    }
                })
                .OrderBy(x => x.Key)
                .ToArray())
            .ToArray();

        return reasons;
    }
}

public class VerifyHelper(ITestOutputHelper output, string idPrefix)
{
    // Diagnostics Verify

    public void Ok([StringSyntax("C#-test")] string code, [CallerArgumentExpression("code")] string? codeExpr = null)
    {
        output.WriteLine(codeExpr);

        var (compilation, diagnostics) = CSharpGeneratorRunner.RunGenerator(code);
        foreach (var item in diagnostics)
        {
            output.WriteLine(item.ToString());
        }
        OutputGeneratedCode(compilation);

        diagnostics.Length.Should().Be(0);
    }

    public void Verify(int id, [StringSyntax("C#-test")] string code, string diagnosticsCodeSpan, [CallerArgumentExpression("code")] string? codeExpr = null)
    {
        output.WriteLine(codeExpr);

        var (compilation, diagnostics) = CSharpGeneratorRunner.RunGenerator(code);
        foreach (var item in diagnostics)
        {
            output.WriteLine(item.ToString());
        }
        OutputGeneratedCode(compilation);

        diagnostics.Length.Should().Be(1);
        diagnostics[0].Id.Should().Be(idPrefix + id.ToString("000"));

        var text = GetLocationText(diagnostics[0], compilation.SyntaxTrees);
        text.Should().Be(diagnosticsCodeSpan);
    }

    public (string, string)[] Verify([StringSyntax("C#-test")] string code, [CallerArgumentExpression("code")] string? codeExpr = null)
    {
        output.WriteLine(codeExpr);

        var (compilation, diagnostics) = CSharpGeneratorRunner.RunGenerator(code);
        OutputGeneratedCode(compilation);
        return diagnostics.Select(x => (x.Id, GetLocationText(x, compilation.SyntaxTrees))).ToArray();
    }

    string GetLocationText(Diagnostic diagnostic, IEnumerable<SyntaxTree> syntaxTrees)
    {
        var location = diagnostic.Location;

        var textSpan = location.SourceSpan;
        var sourceTree = location.SourceTree;
        if (sourceTree == null)
        {
            var lineSpan = location.GetLineSpan();
            if (lineSpan.Path == null) return "";

            sourceTree = syntaxTrees.FirstOrDefault(x => x.FilePath == lineSpan.Path);
            if (sourceTree == null) return "";
        }

        var text = sourceTree.GetText().GetSubText(textSpan).ToString();
        return text;
    }

    void OutputGeneratedCode(Compilation compilation)
    {
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            // only shows ConsoleApp.Run/Builder generated code
            if (!syntaxTree.FilePath.Contains("g.cs")) continue;
            output.WriteLine(syntaxTree.ToString());
        }
    }
}



================================================
FILE: tests/MemoryPack.Tests/Utils/ReadOnlySequenceBuilder.cs
================================================
﻿using System;
using System.Buffers;
using System.Linq;

namespace MemoryPack.Tests.Utils;

public static class ReadOnlySequenceBuilder
{
    public static ReadOnlySequence<byte> Create(params byte[][] buffers)
    {
        var array = buffers.Select(x => new Segment(x)).ToArray();

        long running = 0;
        for (int i = 0; i < array.Length; i++)
        {
            var next = i < array.Length - 1 ? array[i + 1] : null;
            array[i].SetRunningIndexAndNext(running, next);
            running += array[i].Memory.Length;
        }

        var firstSegment = array[0];
        var lastSegment = array[array.Length - 1];
        var seq = new ReadOnlySequence<byte>(firstSegment, 0, lastSegment, lastSegment.Memory.Length);
        return seq;
    }

    class Segment : ReadOnlySequenceSegment<byte>
    {
        public Segment(Memory<byte> buffer)
        {
            Memory = buffer;
        }

        internal void SetRunningIndexAndNext(long runningIndex, Segment? nextSegment)
        {
            RunningIndex = runningIndex;
            Next = nextSegment;
        }
    }
}



================================================
FILE: .github/dependabot.yaml
================================================
# ref: https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly" # Check for updates to GitHub Actions every week
    cooldown:
      default-days: 14 # Wait 14 days before creating another PR for the same dependency. This will prevent vulnerability on the package impact.
    ignore:
      # I just want update action when major/minor version is updated. patch updates are too noisy.
      - dependency-name: "*"
        update-types:
          - version-update:semver-patch



================================================
FILE: .github/FUNDING.yml
================================================
github: [neuecc]



================================================
FILE: .github/workflows/build-debug.yaml
================================================
name: Build-Debug

on:
  workflow_dispatch:
  push:
    branches:
      - "main"
  pull_request:
    branches:
      - "main"

jobs:
  build-dotnet:
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - uses: Cysharp/Actions/.github/actions/checkout@main
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Release
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release --no-build  -p:IncludeSymbols=true -o $GITHUB_WORKSPACE/artifacts

  build-unity:
    if: ${{ ((github.event_name == 'push' && github.repository_owner == 'Cysharp') || startsWith(github.event.pull_request.head.label, 'Cysharp:')) && github.triggering_actor != 'dependabot[bot]' }}
    strategy:
      fail-fast: false
      matrix:
        unity: ["2022.3.39f1", "6000.0.12f1"] # Test with LTS
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - uses: Cysharp/Actions/.github/actions/checkout@main

      # Run SourceGenerater to generate serialization code
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Debug # require build before run
      - name: Make sure generated files are exists.
        run: ls -lR "src/MemoryPack/bin/Debug/netstandard2.1"

      # Execute Unittest
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend IL2CPP /BuildTarget StandaloneLinux64
      - name: Build UnitTest
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/MemoryPack.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: UnitTestBuilder.BuildUnitTest
          customParameters: "/headless /ScriptBackend IL2CPP"
      - name: Check UnitTest file is generated
        run: ls -lR ./src/MemoryPack.Unity/bin/UnitTest
      - name: Execute UnitTest
        run: ./src/MemoryPack.Unity/bin/UnitTest/StandaloneLinux64_IL2CPP/test

      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/MemoryPack.Unity



================================================
FILE: .github/workflows/build-release.yaml
================================================
name: Build-Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "tag: git tag you want create. (sample 1.0.0)"
        required: true
      dry-run:
        description: "dry-run: false = create release/nuget. true = never create release/nuget."
        required: true
        default: false
        type: boolean

jobs:
  update-packagejson:
    permissions:
      actions: read
      contents: write
    uses: Cysharp/Actions/.github/workflows/update-packagejson.yaml@main
    with:
      file-path: |
        ./src/MemoryPack.Unity/Assets/MemoryPack.Unity/package.json
      tag: ${{ inputs.tag }}
      dry-run: ${{ inputs.dry-run }}

  build-dotnet:
    needs: [update-packagejson]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - run: echo ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      # pack nuget
      - run: dotnet build -c Release -p:Version=${{ inputs.tag }}
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release --no-build -p:Version=${{ inputs.tag }} -o ./publish
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: nuget
          path: ./publish
          retention-days: 1

  build-unity:
    needs: [update-packagejson]
    strategy:
      matrix:
        unity: ["2022.3.39f1"]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - run: echo ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}

      # Run SourceGenerater to generate serialization code
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Debug # require build before run
      - name: Make sure generated files are exists.
        run: ls -lR "src/MemoryPack/bin/Debug/netstandard2.1"

      # Execute Unittest
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod UnitTestBuilder.BuildUnitTest /headless /ScriptBackend IL2CPP /BuildTarget StandaloneLinux64
      - name: Build UnitTest
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/MemoryPack.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: UnitTestBuilder.BuildUnitTest
          customParameters: "/headless /ScriptBackend IL2CPP"

      # check meta files
      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/MemoryPack.Unity

  # release
  create-release:
    needs: [update-packagejson, build-dotnet, build-unity]
    permissions:
      contents: write
      id-token: write # required for NuGet Trusted Publish
    uses: Cysharp/Actions/.github/workflows/create-release.yaml@main
    with:
      dry-run: ${{ inputs.dry-run }}
      commit-id: ${{ needs.update-packagejson.outputs.sha }}
      tag: ${{ inputs.tag }}
      nuget-push: true
      release-upload: false
    secrets: inherit

  cleanup:
    if: ${{ needs.update-packagejson.outputs.is-branch-created == 'true' }}
    needs: [update-packagejson, create-release]
    permissions:
      contents: write
    uses: Cysharp/Actions/.github/workflows/clean-packagejson-branch.yaml@main
    with:
      branch: ${{ needs.update-packagejson.outputs.branch-name }}



================================================
FILE: .github/workflows/stale.yaml
================================================
name: "Close stale issues"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

jobs:
  stale:
    permissions:
      contents: read
      pull-requests: write
      issues: write
    uses: Cysharp/Actions/.github/workflows/stale-issue.yaml@main


