Directory structure:
└── cysharp-r3/
    ├── Directory.Build.props
    ├── LICENSE
    ├── opensource.snk
    ├── R3.sln
    ├── .editorconfig
    ├── docs/
    │   ├── reference_factory.md
    │   └── reference_operator.md
    ├── sandbox/
    │   ├── AvaloniaApplication1/
    │   │   ├── App.axaml
    │   │   ├── App.axaml.cs
    │   │   ├── app.manifest
    │   │   ├── AvaloniaApplication1.csproj
    │   │   ├── MainWindow.axaml
    │   │   ├── MainWindow.axaml.cs
    │   │   └── Program.cs
    │   ├── Benchmark/
    │   │   ├── Benchmark.csproj
    │   │   └── Program.cs
    │   ├── BlazorApp1/
    │   │   ├── appsettings.Development.json
    │   │   ├── appsettings.json
    │   │   ├── BlazorApp1.csproj
    │   │   ├── Program.cs
    │   │   ├── Components/
    │   │   │   ├── _Imports.razor
    │   │   │   ├── App.razor
    │   │   │   ├── Routes.razor
    │   │   │   ├── Layout/
    │   │   │   │   ├── MainLayout.razor
    │   │   │   │   ├── MainLayout.razor.css
    │   │   │   │   ├── NavMenu.razor
    │   │   │   │   └── NavMenu.razor.css
    │   │   │   └── Pages/
    │   │   │       ├── Counter.razor
    │   │   │       ├── Counter.razor.cs
    │   │   │       ├── Error.razor
    │   │   │       ├── Home.razor
    │   │   │       └── Weather.razor
    │   │   ├── Properties/
    │   │   │   └── launchSettings.json
    │   │   └── wwwroot/
    │   │       └── app.css
    │   ├── BlazorWebAssemblyApp1/
    │   │   ├── _Imports.razor
    │   │   ├── App.razor
    │   │   ├── BlazorWebAssemblyApp1.csproj
    │   │   ├── Program.cs
    │   │   ├── Layout/
    │   │   │   ├── MainLayout.razor
    │   │   │   ├── MainLayout.razor.css
    │   │   │   ├── NavMenu.razor
    │   │   │   └── NavMenu.razor.css
    │   │   ├── Pages/
    │   │   │   ├── Counter.razor
    │   │   │   ├── Counter.razor.cs
    │   │   │   ├── Home.razor
    │   │   │   └── Weather.razor
    │   │   ├── Properties/
    │   │   │   └── launchSettings.json
    │   │   └── wwwroot/
    │   │       ├── index.html
    │   │       ├── css/
    │   │       │   └── app.css
    │   │       └── sample-data/
    │   │           └── weather.json
    │   ├── ConsoleApp1/
    │   │   ├── ConsoleApp1.csproj
    │   │   └── Program.cs
    │   ├── MauiApp1/
    │   │   ├── App.xaml
    │   │   ├── App.xaml.cs
    │   │   ├── AppShell.xaml
    │   │   ├── AppShell.xaml.cs
    │   │   ├── MainPage.xaml
    │   │   ├── MainPage.xaml.cs
    │   │   ├── MauiApp1.csproj
    │   │   ├── MauiProgram.cs
    │   │   ├── Platforms/
    │   │   │   ├── Android/
    │   │   │   │   ├── AndroidManifest.xml
    │   │   │   │   ├── MainActivity.cs
    │   │   │   │   ├── MainApplication.cs
    │   │   │   │   └── Resources/
    │   │   │   │       └── values/
    │   │   │   │           └── colors.xml
    │   │   │   ├── iOS/
    │   │   │   │   ├── AppDelegate.cs
    │   │   │   │   ├── Info.plist
    │   │   │   │   └── Program.cs
    │   │   │   ├── MacCatalyst/
    │   │   │   │   ├── AppDelegate.cs
    │   │   │   │   ├── Entitlements.plist
    │   │   │   │   ├── Info.plist
    │   │   │   │   └── Program.cs
    │   │   │   ├── Tizen/
    │   │   │   │   ├── Main.cs
    │   │   │   │   └── tizen-manifest.xml
    │   │   │   └── Windows/
    │   │   │       ├── app.manifest
    │   │   │       ├── App.xaml
    │   │   │       ├── App.xaml.cs
    │   │   │       └── Package.appxmanifest
    │   │   ├── Properties/
    │   │   │   └── launchSettings.json
    │   │   └── Resources/
    │   │       ├── Raw/
    │   │       │   └── AboutAssets.txt
    │   │       └── Styles/
    │   │           ├── Colors.xaml
    │   │           └── Styles.xaml
    │   ├── MonoGameApplication1/
    │   │   ├── app.manifest
    │   │   ├── Game1.cs
    │   │   ├── MonoGameApplication1.csproj
    │   │   ├── Program.cs
    │   │   ├── Content/
    │   │   │   └── Content.mgcb
    │   │   └── .config/
    │   │       └── dotnet-tools.json
    │   ├── R3.Stride.Sandbox/
    │   │   ├── Directory.Build.props
    │   │   ├── R3.Stride.Sandbox.sln
    │   │   ├── R3.Stride.Sandbox/
    │   │   │   ├── AdditionalFrameProviderTest.cs
    │   │   │   ├── BasicCameraController.cs
    │   │   │   ├── CubeCollisionTest.cs
    │   │   │   ├── EventKeyReceiverTest.cs
    │   │   │   ├── ObservableTestScript.cs
    │   │   │   ├── R3.Stride.Sandbox.csproj
    │   │   │   ├── R3.Stride.Sandbox.sdpkg
    │   │   │   ├── UIExtensionTest.cs
    │   │   │   └── Assets/
    │   │   │       ├── Cube.sdpromodel
    │   │   │       ├── GameSettings.sdgamesettings
    │   │   │       ├── GraphicsCompositor.sdgfxcomp
    │   │   │       ├── Ground Material.sdmat
    │   │   │       ├── Ground.sdpromodel
    │   │   │       ├── MainScene.sdscene
    │   │   │       ├── Page.sduipage
    │   │   │       ├── Skybox texture.sdtex
    │   │   │       ├── Skybox.sdsky
    │   │   │       ├── Sphere Material.sdmat
    │   │   │       └── Sphere.sdpromodel
    │   │   └── R3.Stride.Sandbox.Windows/
    │   │       ├── R3.Stride.Sandbox.Windows.csproj
    │   │       ├── R3.Stride.Sandbox.Windows.sdpkg
    │   │       └── R3_Stride_SandboxApp.cs
    │   ├── ReferenceBuilder/
    │   │   ├── Program.cs
    │   │   ├── ReferenceBuilder.csproj
    │   │   └── MarkdownGenerator/
    │   │       ├── Beautifier.cs
    │   │       ├── MarkdownBuilder.cs
    │   │       ├── MarkdownGenerator.cs
    │   │       └── VSDocParser.cs
    │   ├── UnoSampleApp/
    │   │   ├── Directory.Build.props
    │   │   ├── Directory.Build.targets
    │   │   ├── Directory.Packages.props
    │   │   ├── global.json
    │   │   ├── UnoSampleApp.sln
    │   │   ├── .editorconfig
    │   │   ├── .vsconfig
    │   │   ├── UnoSampleApp/
    │   │   │   ├── ReadMe.md
    │   │   │   ├── app.manifest
    │   │   │   ├── App.xaml
    │   │   │   ├── App.xaml.cs
    │   │   │   ├── appsettings.development.json
    │   │   │   ├── appsettings.json
    │   │   │   ├── GlobalUsings.cs
    │   │   │   ├── Package.appxmanifest
    │   │   │   ├── UnoSampleApp.csproj
    │   │   │   ├── Assets/
    │   │   │   │   └── SharedAssets.md
    │   │   │   ├── Models/
    │   │   │   │   ├── AppConfig.cs
    │   │   │   │   ├── Entity.cs
    │   │   │   │   └── WeatherForecast.cs
    │   │   │   ├── Platforms/
    │   │   │   │   ├── Android/
    │   │   │   │   │   ├── AndroidManifest.xml
    │   │   │   │   │   ├── environment.conf
    │   │   │   │   │   ├── Main.Android.cs
    │   │   │   │   │   ├── MainActivity.Android.cs
    │   │   │   │   │   ├── Assets/
    │   │   │   │   │   │   └── AboutAssets.txt
    │   │   │   │   │   └── Resources/
    │   │   │   │   │       ├── AboutResources.txt
    │   │   │   │   │       └── values/
    │   │   │   │   │           ├── Strings.xml
    │   │   │   │   │           └── Styles.xml
    │   │   │   │   ├── Desktop/
    │   │   │   │   │   └── Program.cs
    │   │   │   │   ├── iOS/
    │   │   │   │   │   ├── Entitlements.plist
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── Main.iOS.cs
    │   │   │   │   │   ├── PrivacyInfo.xcprivacy
    │   │   │   │   │   └── Media.xcassets/
    │   │   │   │   │       └── LaunchImages.launchimage/
    │   │   │   │   │           └── Contents.json
    │   │   │   │   ├── MacCatalyst/
    │   │   │   │   │   ├── Entitlements.plist
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── Main.maccatalyst.cs
    │   │   │   │   │   └── Media.xcassets/
    │   │   │   │   │       └── LaunchImages.launchimage/
    │   │   │   │   │           └── Contents.json
    │   │   │   │   └── WebAssembly/
    │   │   │   │       ├── LinkerConfig.xml
    │   │   │   │       ├── manifest.webmanifest
    │   │   │   │       ├── Program.cs
    │   │   │   │       ├── WasmCSS/
    │   │   │   │       │   └── Fonts.css
    │   │   │   │       ├── WasmScripts/
    │   │   │   │       │   └── AppManifest.js
    │   │   │   │       └── wwwroot/
    │   │   │   │           ├── staticwebapp.config.json
    │   │   │   │           └── web.config
    │   │   │   ├── Presentation/
    │   │   │   │   ├── MainPage.xaml
    │   │   │   │   ├── MainPage.xaml.cs
    │   │   │   │   ├── MainViewModel.cs
    │   │   │   │   ├── SecondPage.xaml
    │   │   │   │   ├── SecondPage.xaml.cs
    │   │   │   │   ├── SecondViewModel.cs
    │   │   │   │   ├── Shell.xaml
    │   │   │   │   ├── Shell.xaml.cs
    │   │   │   │   └── ShellViewModel.cs
    │   │   │   ├── Properties/
    │   │   │   │   ├── launchSettings.json
    │   │   │   │   └── PublishProfiles/
    │   │   │   │       ├── win-arm64.pubxml
    │   │   │   │       ├── win-x64.pubxml
    │   │   │   │       └── win-x86.pubxml
    │   │   │   ├── Serialization/
    │   │   │   │   └── WeatherForecastContext.cs
    │   │   │   ├── Services/
    │   │   │   │   ├── Caching/
    │   │   │   │   │   ├── IWeatherCache.cs
    │   │   │   │   │   └── WeatherCache.cs
    │   │   │   │   └── Endpoints/
    │   │   │   │       ├── DebugHandler.cs
    │   │   │   │       └── IApiClient.cs
    │   │   │   ├── Strings/
    │   │   │   │   ├── en/
    │   │   │   │   │   └── Resources.resw
    │   │   │   │   ├── es/
    │   │   │   │   │   └── Resources.resw
    │   │   │   │   ├── fr/
    │   │   │   │   │   └── Resources.resw
    │   │   │   │   └── pt-BR/
    │   │   │   │       └── Resources.resw
    │   │   │   └── Styles/
    │   │   │       ├── ColorPaletteOverride.json
    │   │   │       └── ColorPaletteOverride.xaml
    │   │   └── .run/
    │   │       ├── Readme.md
    │   │       └── UnoSampleApp.run.xml
    │   ├── WinFormsApp1/
    │   │   ├── Form1.cs
    │   │   ├── Form1.Designer.cs
    │   │   ├── Form1.resx
    │   │   ├── Program.cs
    │   │   └── WinFormsApp1.csproj
    │   ├── WinUI3App1/
    │   │   ├── app.manifest
    │   │   ├── App.xaml
    │   │   ├── App.xaml.cs
    │   │   ├── MainWindow.xaml
    │   │   ├── MainWindow.xaml.cs
    │   │   ├── Package.appxmanifest
    │   │   ├── WinUI3App1.csproj
    │   │   └── Properties/
    │   │       ├── launchSettings.json
    │   │       └── PublishProfiles/
    │   │           ├── win10-arm64.pubxml
    │   │           ├── win10-x64.pubxml
    │   │           └── win10-x86.pubxml
    │   └── WpfApp1/
    │       ├── App.xaml
    │       ├── App.xaml.cs
    │       ├── AssemblyInfo.cs
    │       ├── MainWindow.xaml
    │       ├── MainWindow.xaml.cs
    │       └── WpfApp1.csproj
    ├── src/
    │   ├── R3/
    │   │   ├── AwaitOperation.cs
    │   │   ├── BehaviorSubject.cs
    │   │   ├── BindableReactiveProperty.cs
    │   │   ├── BooleanDisposable.cs
    │   │   ├── CancellationDisposable.cs
    │   │   ├── CompositeDisposable.cs
    │   │   ├── ConnectableObservable.cs
    │   │   ├── Disposable.cs
    │   │   ├── DisposableBag.cs
    │   │   ├── FrameProvider.cs
    │   │   ├── ISubject.cs
    │   │   ├── NewThreadSleepFrameProvider.cs
    │   │   ├── Notification.cs
    │   │   ├── Observable.cs
    │   │   ├── ObservableSubscribeExtensions.cs
    │   │   ├── ObservableSystem.cs
    │   │   ├── ObservableTracker.cs
    │   │   ├── ObserverExtensions.cs
    │   │   ├── R3.csproj
    │   │   ├── ReactiveCommand.cs
    │   │   ├── ReactiveProperty.cs
    │   │   ├── ReactivePropertyExtensions.cs
    │   │   ├── ReplayFrameSubject.cs
    │   │   ├── ReplaySubject.cs
    │   │   ├── Result.cs
    │   │   ├── SerialDisposable.cs
    │   │   ├── SingleAssignmentDisposable.cs
    │   │   ├── SingleAssignmentSubject.cs
    │   │   ├── Subject.cs
    │   │   ├── SynchronizationContextTimeProvider.cs
    │   │   ├── SynchronizedReactiveProperty.cs
    │   │   ├── TimerFrameProvider.cs
    │   │   ├── Unit.cs
    │   │   ├── Collections/
    │   │   │   ├── FreeListCore.cs
    │   │   │   ├── LiveList.cs
    │   │   │   └── SwapListCore.cs
    │   │   ├── Factories/
    │   │   │   ├── CombineLatest.cs
    │   │   │   ├── Concat.cs
    │   │   │   ├── Create.cs
    │   │   │   ├── Defer.cs
    │   │   │   ├── Empty.cs
    │   │   │   ├── EveryUpdate.cs
    │   │   │   ├── EveryValueChanged.cs
    │   │   │   ├── FromAsync.cs
    │   │   │   ├── FromEvent.cs
    │   │   │   ├── Merge.cs
    │   │   │   ├── Never.cs
    │   │   │   ├── ObserveProperty.cs
    │   │   │   ├── Race.cs
    │   │   │   ├── Range.cs
    │   │   │   ├── Repeat.cs
    │   │   │   ├── Return.cs
    │   │   │   ├── ReturnFrame.cs
    │   │   │   ├── ReturnOnCompleted.cs
    │   │   │   ├── Throw.cs
    │   │   │   ├── Timer.cs
    │   │   │   ├── TimerFrame.cs
    │   │   │   ├── ToObservable.cs
    │   │   │   ├── Zip.cs
    │   │   │   └── ZipLatest.cs
    │   │   ├── Internal/
    │   │   │   ├── CancellableFrameRunnerWorkItemBase.cs
    │   │   │   ├── ChannelUtility.cs
    │   │   │   ├── FrameCountExtensions.cs
    │   │   │   ├── ListDisposableCore.cs
    │   │   │   ├── RingBuffer.cs
    │   │   │   ├── Stubs.cs
    │   │   │   ├── TaskObserverBase.cs
    │   │   │   ├── ThrowHelper.cs
    │   │   │   ├── TimeProviderExtensions.cs
    │   │   │   ├── TimeSpanExtensions.cs
    │   │   │   ├── WeakDictionary.cs
    │   │   │   └── Shims/
    │   │   │       ├── CancellationTokenExtensions.cs
    │   │   │       ├── CollectionsMarshal.cs
    │   │   │       ├── EnumerableExtensions.cs
    │   │   │       ├── QueueExtensions.cs
    │   │   │       ├── StackTraceHidden.cs
    │   │   │       ├── TaskExtensions.cs
    │   │   │       └── ThreadPool.cs
    │   │   └── Operators/
    │   │       ├── AggregateAsync.cs
    │   │       ├── AggregateByAsync.cs
    │   │       ├── AllAnyIsEmptyAsync.cs
    │   │       ├── AppendPrepend.cs
    │   │       ├── AsObservable.cs
    │   │       ├── AsUnitObservable.cs
    │   │       ├── AverageAsync.cs
    │   │       ├── AverageAsync.tt
    │   │       ├── Cast.cs
    │   │       ├── Catch.cs
    │   │       ├── Chunk.cs
    │   │       ├── ChunkFrame.cs
    │   │       ├── ChunkUntil.cs
    │   │       ├── CombineLatest.tt
    │   │       ├── Concat.cs
    │   │       ├── ContainsAsync.cs
    │   │       ├── CountAsync.cs
    │   │       ├── Debounce.cs
    │   │       ├── DebounceFrame.cs
    │   │       ├── DefaultIfEmpty.cs
    │   │       ├── Delay.cs
    │   │       ├── DelayFrame.cs
    │   │       ├── DelaySubscription.cs
    │   │       ├── DelaySubscriptionFrame.cs
    │   │       ├── Distinct.cs
    │   │       ├── DistinctUntilChanged.cs
    │   │       ├── Do.cs
    │   │       ├── ElementAtAsync.cs
    │   │       ├── FirstLastSingle.cs
    │   │       ├── ForEachAsync.cs
    │   │       ├── FrameCount.cs
    │   │       ├── FrameInterval.cs
    │   │       ├── IgnoreElements.cs
    │   │       ├── IgnoreOnErrorResume.cs
    │   │       ├── Index.cs
    │   │       ├── Materialize.cs
    │   │       ├── MaxAsync.cs
    │   │       ├── MaxByMinByAsync.cs
    │   │       ├── Merge.cs
    │   │       ├── MinAsync.cs
    │   │       ├── MinMaxAsync.cs
    │   │       ├── Multicast.cs
    │   │       ├── ObserveOn.cs
    │   │       ├── OfType.cs
    │   │       ├── OnErrorResumeAsFailure.cs
    │   │       ├── Pairwise.cs
    │   │       ├── RefCount.cs
    │   │       ├── Scan.cs
    │   │       ├── Select.cs
    │   │       ├── SelectAwait.cs
    │   │       ├── SelectMany.cs
    │   │       ├── SequenceEqualAsync.cs
    │   │       ├── Skip.cs
    │   │       ├── SkipLast.cs
    │   │       ├── SkipUntil.cs
    │   │       ├── SkipWhile.cs
    │   │       ├── SubscribeAwait.cs
    │   │       ├── SubscribeOn.cs
    │   │       ├── SumAsync.cs
    │   │       ├── SumAsync.tt
    │   │       ├── Switch.cs
    │   │       ├── Synchronize.cs
    │   │       ├── Take.cs
    │   │       ├── TakeLast.cs
    │   │       ├── TakeUntil.cs
    │   │       ├── TakeWhile.cs
    │   │       ├── ThrottleFirst.cs
    │   │       ├── ThrottleFirstFrame.cs
    │   │       ├── ThrottleFirstLast.cs
    │   │       ├── ThrottleFirstLastFrame.cs
    │   │       ├── ThrottleLast.cs
    │   │       ├── ThrottleLastFrame.cs
    │   │       ├── TimeInterval.cs
    │   │       ├── Timeout.cs
    │   │       ├── TimeoutFrame.cs
    │   │       ├── Timestamp.cs
    │   │       ├── ToArrayAsync.cs
    │   │       ├── ToAsyncEnumerable.cs
    │   │       ├── ToDictionaryAsync.cs
    │   │       ├── ToHashSetAsync.cs
    │   │       ├── ToListAsync.cs
    │   │       ├── ToLookupAsync.cs
    │   │       ├── Trampoline.cs
    │   │       ├── WaitAsync.cs
    │   │       ├── Where.cs
    │   │       ├── WhereAwait.cs
    │   │       ├── WhereNotNull.cs
    │   │       ├── WithLatestFrom.cs
    │   │       ├── Zip.tt
    │   │       └── ZipLatest.tt
    │   ├── R3.Avalonia/
    │   │   ├── AppBuilderR3InitializeExtensions.cs
    │   │   ├── AvaloniaDispatcherFrameProvider.cs
    │   │   ├── AvaloniaDispatcherTimeProvider.cs
    │   │   ├── AvaloniaProviderInitializer.cs
    │   │   ├── AvaloniaRenderingFrameProvider.cs
    │   │   ├── ObserveOnExtensions.cs
    │   │   └── R3.Avalonia.csproj
    │   ├── R3.Blazor/
    │   │   ├── ObservableSystemInitializationService.cs
    │   │   ├── R3.Blazor.csproj
    │   │   └── Properties/
    │   │       └── launchSettings.json
    │   ├── R3.BlazorWebAssembly/
    │   │   ├── ObservableSystemInitializationService.cs
    │   │   └── R3.BlazorWebAssembly.csproj
    │   ├── R3.Godot/
    │   │   ├── R3.Godot.csproj
    │   │   └── addons/
    │   │       └── R3.Godot/
    │   │           ├── FrameProviderDispatcher.cs
    │   │           ├── GodotFrameProvider.cs
    │   │           ├── GodotNodeExtensions.cs
    │   │           ├── GodotObservableExtensions.cs
    │   │           ├── GodotProviderInitializer.cs
    │   │           ├── GodotR3Plugin.cs
    │   │           ├── GodotSignalMapper.cs
    │   │           ├── GodotTimeProvider.cs
    │   │           ├── GodotUINodeExtensions.cs
    │   │           ├── ObservableTrackerDebuggerPlugin.cs
    │   │           ├── ObservableTrackerRuntimeHook.cs
    │   │           ├── ObservableTrackerTab.cs
    │   │           ├── ObservableTrackerTree.cs
    │   │           └── plugin.cfg
    │   ├── R3.LogicLooper/
    │   │   ├── LogicLooperFrameProvider.cs
    │   │   ├── LogicLooperTimeProvider.cs
    │   │   └── R3.LogicLooper.csproj
    │   ├── R3.Maui/
    │   │   ├── MauiAppBuilderExtensions.cs
    │   │   ├── MauiDispatcherTimeProvider.cs
    │   │   ├── MauiTickerFrameProvider.cs
    │   │   ├── ObserveOnExtensions.cs
    │   │   ├── R3.Maui.csproj
    │   │   ├── R3MauiExceptionHandler.cs
    │   │   └── R3MauiInitializeService.cs
    │   ├── R3.MonoGame/
    │   │   ├── MonoGameFrameProvider.cs
    │   │   ├── MonoGameObservableExtensions.cs
    │   │   ├── MonoGameTimeProvider.cs
    │   │   ├── ObservableSystemComponent.cs
    │   │   └── R3.MonoGame.csproj
    │   ├── R3.Stride/
    │   │   ├── README.md
    │   │   ├── AdditionalR3FrameDispatcherComponent.cs
    │   │   ├── Directory.Build.props
    │   │   ├── Module.cs
    │   │   ├── R3.Stride.csproj
    │   │   ├── R3.Stride.sdpkg
    │   │   ├── R3FrameDispatcherComponent.cs
    │   │   ├── R3StrideCollectionExtension.cs
    │   │   ├── R3StrideEventExtension.cs
    │   │   ├── R3StrideUIExtension.cs
    │   │   ├── StrideFrameProvider.cs
    │   │   ├── StrideInitializer.cs
    │   │   └── StrideTimeProvider.cs
    │   ├── R3.Unity/
    │   │   ├── .vsconfig
    │   │   ├── Assets/
    │   │   │   ├── NuGet.config
    │   │   │   ├── NuGet.config.meta
    │   │   │   ├── packages.config
    │   │   │   ├── packages.config.meta
    │   │   │   ├── Packages.meta
    │   │   │   ├── R3.Unity.meta
    │   │   │   ├── Scenes.meta
    │   │   │   ├── XRI.meta
    │   │   │   ├── Packages/
    │   │   │   │   ├── Microsoft.Bcl.AsyncInterfaces.6.0.0.meta
    │   │   │   │   ├── Microsoft.Bcl.TimeProvider.8.0.0.meta
    │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.6.0.0.meta
    │   │   │   │   ├── System.Threading.Channels.8.0.0.meta
    │   │   │   │   ├── Microsoft.Bcl.AsyncInterfaces.6.0.0/
    │   │   │   │   │   ├── Icon.png.meta
    │   │   │   │   │   ├── lib.meta
    │   │   │   │   │   ├── LICENSE.TXT
    │   │   │   │   │   ├── LICENSE.TXT.meta
    │   │   │   │   │   ├── Microsoft.Bcl.AsyncInterfaces.nuspec
    │   │   │   │   │   ├── Microsoft.Bcl.AsyncInterfaces.nuspec.meta
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │   │   ├── useSharedDesignerContext.txt
    │   │   │   │   │   ├── useSharedDesignerContext.txt.meta
    │   │   │   │   │   ├── .signature.p7s
    │   │   │   │   │   └── lib/
    │   │   │   │   │       ├── netstandard2.1.meta
    │   │   │   │   │       └── netstandard2.1/
    │   │   │   │   │           ├── Microsoft.Bcl.AsyncInterfaces.dll.meta
    │   │   │   │   │           ├── Microsoft.Bcl.AsyncInterfaces.xml
    │   │   │   │   │           └── Microsoft.Bcl.AsyncInterfaces.xml.meta
    │   │   │   │   ├── Microsoft.Bcl.TimeProvider.8.0.0/
    │   │   │   │   │   ├── buildTransitive.meta
    │   │   │   │   │   ├── Icon.png.meta
    │   │   │   │   │   ├── lib.meta
    │   │   │   │   │   ├── LICENSE.TXT
    │   │   │   │   │   ├── LICENSE.TXT.meta
    │   │   │   │   │   ├── Microsoft.Bcl.TimeProvider.nuspec
    │   │   │   │   │   ├── Microsoft.Bcl.TimeProvider.nuspec.meta
    │   │   │   │   │   ├── PACKAGE.md
    │   │   │   │   │   ├── PACKAGE.md.meta
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │   │   ├── useSharedDesignerContext.txt
    │   │   │   │   │   ├── useSharedDesignerContext.txt.meta
    │   │   │   │   │   ├── .signature.p7s
    │   │   │   │   │   ├── buildTransitive/
    │   │   │   │   │   │   ├── net461.meta
    │   │   │   │   │   │   ├── net462.meta
    │   │   │   │   │   │   ├── net6.0.meta
    │   │   │   │   │   │   ├── netcoreapp2.0.meta
    │   │   │   │   │   │   ├── net461/
    │   │   │   │   │   │   │   ├── Microsoft.Bcl.TimeProvider.targets
    │   │   │   │   │   │   │   └── Microsoft.Bcl.TimeProvider.targets.meta
    │   │   │   │   │   │   ├── net462/
    │   │   │   │   │   │   │   ├── _._
    │   │   │   │   │   │   │   └── _._.meta
    │   │   │   │   │   │   ├── net6.0/
    │   │   │   │   │   │   │   ├── _._
    │   │   │   │   │   │   │   └── _._.meta
    │   │   │   │   │   │   └── netcoreapp2.0/
    │   │   │   │   │   │       ├── Microsoft.Bcl.TimeProvider.targets
    │   │   │   │   │   │       └── Microsoft.Bcl.TimeProvider.targets.meta
    │   │   │   │   │   └── lib/
    │   │   │   │   │       ├── netstandard2.0.meta
    │   │   │   │   │       └── netstandard2.0/
    │   │   │   │   │           ├── Microsoft.Bcl.TimeProvider.dll.meta
    │   │   │   │   │           ├── Microsoft.Bcl.TimeProvider.xml
    │   │   │   │   │           └── Microsoft.Bcl.TimeProvider.xml.meta
    │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.6.0.0/
    │   │   │   │   │   ├── buildTransitive.meta
    │   │   │   │   │   ├── Icon.png.meta
    │   │   │   │   │   ├── lib.meta
    │   │   │   │   │   ├── LICENSE.TXT
    │   │   │   │   │   ├── LICENSE.TXT.meta
    │   │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.nuspec
    │   │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.nuspec.meta
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT
    │   │   │   │   │   ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │   │   ├── useSharedDesignerContext.txt
    │   │   │   │   │   ├── useSharedDesignerContext.txt.meta
    │   │   │   │   │   ├── .signature.p7s
    │   │   │   │   │   ├── buildTransitive/
    │   │   │   │   │   │   ├── netcoreapp2.0.meta
    │   │   │   │   │   │   ├── netcoreapp3.1.meta
    │   │   │   │   │   │   ├── netcoreapp2.0/
    │   │   │   │   │   │   │   ├── System.Runtime.CompilerServices.Unsafe.targets
    │   │   │   │   │   │   │   └── System.Runtime.CompilerServices.Unsafe.targets.meta
    │   │   │   │   │   │   └── netcoreapp3.1/
    │   │   │   │   │   │       ├── _._
    │   │   │   │   │   │       └── _._.meta
    │   │   │   │   │   └── lib/
    │   │   │   │   │       ├── netstandard2.0.meta
    │   │   │   │   │       └── netstandard2.0/
    │   │   │   │   │           ├── System.Runtime.CompilerServices.Unsafe.dll.meta
    │   │   │   │   │           ├── System.Runtime.CompilerServices.Unsafe.xml
    │   │   │   │   │           └── System.Runtime.CompilerServices.Unsafe.xml.meta
    │   │   │   │   └── System.Threading.Channels.8.0.0/
    │   │   │   │       ├── buildTransitive.meta
    │   │   │   │       ├── Icon.png.meta
    │   │   │   │       ├── lib.meta
    │   │   │   │       ├── LICENSE.TXT
    │   │   │   │       ├── LICENSE.TXT.meta
    │   │   │   │       ├── PACKAGE.md
    │   │   │   │       ├── PACKAGE.md.meta
    │   │   │   │       ├── System.Threading.Channels.nuspec
    │   │   │   │       ├── System.Threading.Channels.nuspec.meta
    │   │   │   │       ├── THIRD-PARTY-NOTICES.TXT.meta
    │   │   │   │       ├── useSharedDesignerContext.txt
    │   │   │   │       ├── useSharedDesignerContext.txt.meta
    │   │   │   │       ├── .signature.p7s
    │   │   │   │       ├── buildTransitive/
    │   │   │   │       │   ├── net461.meta
    │   │   │   │       │   ├── net462.meta
    │   │   │   │       │   ├── net6.0.meta
    │   │   │   │       │   ├── netcoreapp2.0.meta
    │   │   │   │       │   ├── net461/
    │   │   │   │       │   │   ├── System.Threading.Channels.targets
    │   │   │   │       │   │   └── System.Threading.Channels.targets.meta
    │   │   │   │       │   ├── net462/
    │   │   │   │       │   │   ├── _._
    │   │   │   │       │   │   └── _._.meta
    │   │   │   │       │   ├── net6.0/
    │   │   │   │       │   │   ├── _._
    │   │   │   │       │   │   └── _._.meta
    │   │   │   │       │   └── netcoreapp2.0/
    │   │   │   │       │       ├── System.Threading.Channels.targets
    │   │   │   │       │       └── System.Threading.Channels.targets.meta
    │   │   │   │       └── lib/
    │   │   │   │           ├── netstandard2.1.meta
    │   │   │   │           └── netstandard2.1/
    │   │   │   │               ├── System.Threading.Channels.dll.meta
    │   │   │   │               ├── System.Threading.Channels.xml
    │   │   │   │               └── System.Threading.Channels.xml.meta
    │   │   │   ├── R3.Unity/
    │   │   │   │   ├── Editor.meta
    │   │   │   │   ├── package.json
    │   │   │   │   ├── package.json.meta
    │   │   │   │   ├── Runtime.meta
    │   │   │   │   ├── Editor/
    │   │   │   │   │   ├── EditorEnableState.cs
    │   │   │   │   │   ├── EditorEnableState.cs.meta
    │   │   │   │   │   ├── ObservableTrackerTreeView.cs
    │   │   │   │   │   ├── ObservableTrackerTreeView.cs.meta
    │   │   │   │   │   ├── ObservableTrackerWindow.cs
    │   │   │   │   │   ├── ObservableTrackerWindow.cs.meta
    │   │   │   │   │   ├── R3.Unity.Editor.asmdef
    │   │   │   │   │   ├── R3.Unity.Editor.asmdef.meta
    │   │   │   │   │   ├── SplitterGUILayout.cs
    │   │   │   │   │   └── SplitterGUILayout.cs.meta
    │   │   │   │   └── Runtime/
    │   │   │   │       ├── _InternalVisibleTo.cs
    │   │   │   │       ├── _InternalVisibleTo.cs.meta
    │   │   │   │       ├── External.meta
    │   │   │   │       ├── MonoBehaviourExtensions.cs
    │   │   │   │       ├── MonoBehaviourExtensions.cs.meta
    │   │   │   │       ├── ObserveOnExtensions.cs
    │   │   │   │       ├── ObserveOnExtensions.cs.meta
    │   │   │   │       ├── PlayerLoopHelper.cs
    │   │   │   │       ├── PlayerLoopHelper.cs.meta
    │   │   │   │       ├── R3.Unity.asmdef
    │   │   │   │       ├── R3.Unity.asmdef.meta
    │   │   │   │       ├── SerializableReactiveProperty.cs
    │   │   │   │       ├── SerializableReactiveProperty.cs.meta
    │   │   │   │       ├── Triggers.meta
    │   │   │   │       ├── UnityEventExtensions.cs
    │   │   │   │       ├── UnityEventExtensions.cs.meta
    │   │   │   │       ├── UnityFrameProvider.cs
    │   │   │   │       ├── UnityFrameProvider.cs.meta
    │   │   │   │       ├── UnityProviderInitializer.cs
    │   │   │   │       ├── UnityProviderInitializer.cs.meta
    │   │   │   │       ├── UnityTimeProvider.cs
    │   │   │   │       ├── UnityTimeProvider.cs.meta
    │   │   │   │       ├── UnityUIComponentExtensions.cs
    │   │   │   │       ├── UnityUIComponentExtensions.cs.meta
    │   │   │   │       ├── External/
    │   │   │   │       │   ├── TextMeshPro.meta
    │   │   │   │       │   ├── XRInteractionToolkit.meta
    │   │   │   │       │   ├── TextMeshPro/
    │   │   │   │       │   │   ├── R3.Unity.TextMeshPro.asmdef
    │   │   │   │       │   │   ├── R3.Unity.TextMeshPro.asmdef.meta
    │   │   │   │       │   │   ├── TextMeshProExtensions.cs
    │   │   │   │       │   │   └── TextMeshProExtensions.cs.meta
    │   │   │   │       │   └── XRInteractionToolkit/
    │   │   │   │       │       ├── R3.Unity.XRInteractionToolkit.asmdef
    │   │   │   │       │       ├── R3.Unity.XRInteractionToolkit.asmdef.meta
    │   │   │   │       │       ├── UnityXRBaseInteractableExtensions.cs
    │   │   │   │       │       └── UnityXRBaseInteractableExtensions.cs.meta
    │   │   │   │       └── Triggers/
    │   │   │   │           ├── ObservableAnimatorTrigger.cs
    │   │   │   │           ├── ObservableAnimatorTrigger.cs.meta
    │   │   │   │           ├── ObservableBeginDragTrigger.cs
    │   │   │   │           ├── ObservableBeginDragTrigger.cs.meta
    │   │   │   │           ├── ObservableCancelTrigger.cs
    │   │   │   │           ├── ObservableCancelTrigger.cs.meta
    │   │   │   │           ├── ObservableCanvasGroupChangedTrigger.cs
    │   │   │   │           ├── ObservableCanvasGroupChangedTrigger.cs.meta
    │   │   │   │           ├── ObservableCollision2DTrigger.cs
    │   │   │   │           ├── ObservableCollision2DTrigger.cs.meta
    │   │   │   │           ├── ObservableCollisionTrigger.cs
    │   │   │   │           ├── ObservableCollisionTrigger.cs.meta
    │   │   │   │           ├── ObservableDeselectTrigger.cs
    │   │   │   │           ├── ObservableDeselectTrigger.cs.meta
    │   │   │   │           ├── ObservableDestroyTrigger.cs
    │   │   │   │           ├── ObservableDestroyTrigger.cs.meta
    │   │   │   │           ├── ObservableDragTrigger.cs
    │   │   │   │           ├── ObservableDragTrigger.cs.meta
    │   │   │   │           ├── ObservableDropTrigger.cs
    │   │   │   │           ├── ObservableDropTrigger.cs.meta
    │   │   │   │           ├── ObservableEnableTrigger.cs
    │   │   │   │           ├── ObservableEnableTrigger.cs.meta
    │   │   │   │           ├── ObservableEndDragTrigger.cs
    │   │   │   │           ├── ObservableEndDragTrigger.cs.meta
    │   │   │   │           ├── ObservableEventTrigger.cs
    │   │   │   │           ├── ObservableEventTrigger.cs.meta
    │   │   │   │           ├── ObservableFixedUpdateTrigger.cs
    │   │   │   │           ├── ObservableFixedUpdateTrigger.cs.meta
    │   │   │   │           ├── ObservableInitializePotentialDragTrigger.cs
    │   │   │   │           ├── ObservableInitializePotentialDragTrigger.cs.meta
    │   │   │   │           ├── ObservableJointTrigger.cs
    │   │   │   │           ├── ObservableJointTrigger.cs.meta
    │   │   │   │           ├── ObservableLateUpdateTrigger.cs
    │   │   │   │           ├── ObservableLateUpdateTrigger.cs.meta
    │   │   │   │           ├── ObservableMouseTrigger.cs
    │   │   │   │           ├── ObservableMouseTrigger.cs.meta
    │   │   │   │           ├── ObservableMoveTrigger.cs
    │   │   │   │           ├── ObservableMoveTrigger.cs.meta
    │   │   │   │           ├── ObservableParticleTrigger.cs
    │   │   │   │           ├── ObservableParticleTrigger.cs.meta
    │   │   │   │           ├── ObservablePointerClickTrigger.cs
    │   │   │   │           ├── ObservablePointerClickTrigger.cs.meta
    │   │   │   │           ├── ObservablePointerDownTrigger.cs
    │   │   │   │           ├── ObservablePointerDownTrigger.cs.meta
    │   │   │   │           ├── ObservablePointerEnterTrigger.cs
    │   │   │   │           ├── ObservablePointerEnterTrigger.cs.meta
    │   │   │   │           ├── ObservablePointerExitTrigger.cs
    │   │   │   │           ├── ObservablePointerExitTrigger.cs.meta
    │   │   │   │           ├── ObservablePointerUpTrigger.cs
    │   │   │   │           ├── ObservablePointerUpTrigger.cs.meta
    │   │   │   │           ├── ObservableRectTransformTrigger.cs
    │   │   │   │           ├── ObservableRectTransformTrigger.cs.meta
    │   │   │   │           ├── ObservableScrollTrigger.cs
    │   │   │   │           ├── ObservableScrollTrigger.cs.meta
    │   │   │   │           ├── ObservableSelectTrigger.cs
    │   │   │   │           ├── ObservableSelectTrigger.cs.meta
    │   │   │   │           ├── ObservableStateMachineTrigger.cs
    │   │   │   │           ├── ObservableStateMachineTrigger.cs.meta
    │   │   │   │           ├── ObservableSubmitTrigger.cs
    │   │   │   │           ├── ObservableSubmitTrigger.cs.meta
    │   │   │   │           ├── ObservableTransformChangedTrigger.cs
    │   │   │   │           ├── ObservableTransformChangedTrigger.cs.meta
    │   │   │   │           ├── ObservableTrigger2DTrigger.cs
    │   │   │   │           ├── ObservableTrigger2DTrigger.cs.meta
    │   │   │   │           ├── ObservableTriggerBase.cs
    │   │   │   │           ├── ObservableTriggerBase.cs.meta
    │   │   │   │           ├── ObservableTriggerExtensions.Component.cs
    │   │   │   │           ├── ObservableTriggerExtensions.Component.cs.meta
    │   │   │   │           ├── ObservableTriggerExtensions.cs
    │   │   │   │           ├── ObservableTriggerExtensions.cs.meta
    │   │   │   │           ├── ObservableTriggerTrigger.cs
    │   │   │   │           ├── ObservableTriggerTrigger.cs.meta
    │   │   │   │           ├── ObservableUpdateSelectedTrigger.cs
    │   │   │   │           ├── ObservableUpdateSelectedTrigger.cs.meta
    │   │   │   │           ├── ObservableUpdateTrigger.cs
    │   │   │   │           ├── ObservableUpdateTrigger.cs.meta
    │   │   │   │           ├── ObservableVisibleTrigger.cs
    │   │   │   │           └── ObservableVisibleTrigger.cs.meta
    │   │   │   ├── Scenes/
    │   │   │   │   ├── NewBehaviourScript.cs
    │   │   │   │   ├── NewBehaviourScript.cs.meta
    │   │   │   │   ├── NoAwakeTest.cs
    │   │   │   │   ├── NoAwakeTest.cs.meta
    │   │   │   │   ├── SampleScene.unity
    │   │   │   │   ├── SampleScene.unity.meta
    │   │   │   │   ├── SubjectBench.cs
    │   │   │   │   └── SubjectBench.cs.meta
    │   │   │   └── XRI/
    │   │   │       ├── Settings.meta
    │   │   │       └── Settings/
    │   │   │           ├── Resources.meta
    │   │   │           ├── XRInteractionEditorSettings.asset
    │   │   │           ├── XRInteractionEditorSettings.asset.meta
    │   │   │           └── Resources/
    │   │   │               ├── InteractionLayerSettings.asset
    │   │   │               ├── InteractionLayerSettings.asset.meta
    │   │   │               ├── XRDeviceSimulatorSettings.asset
    │   │   │               └── XRDeviceSimulatorSettings.asset.meta
    │   │   ├── Packages/
    │   │   │   ├── manifest.json
    │   │   │   └── packages-lock.json
    │   │   └── ProjectSettings/
    │   │       ├── AudioManager.asset
    │   │       ├── BurstAotSettings_StandaloneWindows.json
    │   │       ├── ClusterInputManager.asset
    │   │       ├── CommonBurstAotSettings.json
    │   │       ├── DynamicsManager.asset
    │   │       ├── EditorBuildSettings.asset
    │   │       ├── EditorSettings.asset
    │   │       ├── GraphicsSettings.asset
    │   │       ├── InputManager.asset
    │   │       ├── MemorySettings.asset
    │   │       ├── NavMeshAreas.asset
    │   │       ├── NetworkManager.asset
    │   │       ├── PackageManagerSettings.asset
    │   │       ├── Physics2DSettings.asset
    │   │       ├── PresetManager.asset
    │   │       ├── ProjectSettings.asset
    │   │       ├── ProjectVersion.txt
    │   │       ├── QualitySettings.asset
    │   │       ├── SceneTemplateSettings.json
    │   │       ├── TagManager.asset
    │   │       ├── TimeManager.asset
    │   │       ├── UnityConnectSettings.asset
    │   │       ├── VersionControlSettings.asset
    │   │       ├── VFXManager.asset
    │   │       └── XRSettings.asset
    │   ├── R3.Uno/
    │   │   ├── IApplicationBuilderR3InitializeExtensions.cs
    │   │   ├── ObserveOnExtensions.cs
    │   │   ├── R3.Uno.csproj
    │   │   ├── UnoDispatcherFrameProvider.cs
    │   │   ├── UnoDispatcherTimeProvider.cs
    │   │   └── UnoProviderInitializer.cs
    │   ├── R3.WinForms/
    │   │   ├── DisposableExtensions.cs
    │   │   ├── Polyfills.cs
    │   │   ├── R3.WinForms.csproj
    │   │   ├── WinFormsFrameProvider.cs
    │   │   ├── WinFormsProviderInitializer.cs
    │   │   └── WinFormsTimeProvider.cs
    │   ├── R3.WinUI3/
    │   │   ├── R3.WinUI3.csproj
    │   │   ├── WinUI3DispatcherTimeProvider.cs
    │   │   ├── WinUI3ProviderInitializer.cs
    │   │   └── WinUI3RenderingFrameProvider.cs
    │   └── R3.WPF/
    │       ├── ObserveOnExtensions.cs
    │       ├── R3.WPF.csproj
    │       ├── WpfDispatcherTimeProvider.cs
    │       ├── WpfProviderInitializer.cs
    │       └── WpfRenderingFrameProvider.cs
    ├── tests/
    │   └── R3.Tests/
    │       ├── _TestHelper.cs
    │       ├── AwaitOperationCancelOnCompleted.cs
    │       ├── BehaviorSubjectTest.cs
    │       ├── CompositeDisposableTest.cs
    │       ├── DisposableBagTest.cs
    │       ├── DisposableBuilderTest.cs
    │       ├── LiveListTest.cs
    │       ├── R3.Tests.csproj
    │       ├── ReactivePropertyTest.cs
    │       ├── ReplayFrameSubjectTest .cs
    │       ├── ReplaySubjectTest.cs
    │       ├── SerialDisposableTest.cs
    │       ├── SubjectTest.cs
    │       ├── FactoryTests/
    │       │   ├── CreateTest.cs
    │       │   ├── DeferTest.cs
    │       │   ├── EmptyTest.cs
    │       │   ├── EveryUpdateTest.cs
    │       │   ├── EveryValueChangedTest.cs
    │       │   ├── FromAsyncTest.cs
    │       │   ├── FromEventTest.cs
    │       │   ├── NeverTest.cs
    │       │   ├── ObservePropertyTest.cs
    │       │   ├── RangeTest.cs
    │       │   ├── RepeatTest.cs
    │       │   ├── ReturnFrameTest.cs
    │       │   ├── ReturnOnCompletedTest.cs
    │       │   ├── ReturnTest.cs
    │       │   ├── ThrowTest.cs
    │       │   ├── TimerFrameTest.cs
    │       │   ├── TimerTest.cs
    │       │   └── ToObservableTest.cs
    │       └── OperatorTests/
    │           ├── AggregateByTest.cs
    │           ├── AggregateTest.cs
    │           ├── AllTest.cs
    │           ├── AnyTest.cs
    │           ├── AsObservableTest.cs
    │           ├── AsUnitObservableTest.cs
    │           ├── AverageTest.cs
    │           ├── CastTest.cs
    │           ├── CatchTest.cs
    │           ├── ChunkTest.cs
    │           ├── CombineLatestTest.cs
    │           ├── ConcatAppendPrependTest.cs
    │           ├── ContainsTest.cs
    │           ├── CountTest.cs
    │           ├── DebounceThrottleFirstThrottleLastTest.cs
    │           ├── DefaultIfEmptyTest.cs
    │           ├── DelaySubscriptionTest.cs
    │           ├── DelayTest.cs
    │           ├── DistinctByTest.cs
    │           ├── DistinctTest.cs
    │           ├── DistinctUntilChangedByTest.cs
    │           ├── DistinctUntilChangedTest.cs
    │           ├── DoTest.cs
    │           ├── ElementAtTest.cs
    │           ├── FirstLastSingleTest.cs
    │           ├── ForEachAsyncTest.cs
    │           ├── IgnoreElementsTest.cs
    │           ├── IndexTest.cs
    │           ├── IsEmptyTest.cs
    │           ├── MaterializeTest.cs
    │           ├── MaxByTest.cs
    │           ├── MaxTest.cs
    │           ├── MergeTest.cs
    │           ├── MinByTest.cs
    │           ├── MinMaxTest.cs
    │           ├── MinTest.cs
    │           ├── MulticastTest.cs
    │           ├── ObserveOnTest.cs
    │           ├── OfTypeTest.cs
    │           ├── OnErrorResumeAsFailureTest.cs
    │           ├── PairwiseTest.cs
    │           ├── RaceTest.cs
    │           ├── RefCountTest.cs
    │           ├── ScanTest.cs
    │           ├── SelectAwaitTest.cs
    │           ├── SelectManyTest.cs
    │           ├── SelectTest.cs
    │           ├── SequenceEqualTest.cs
    │           ├── SkipLastTest.cs
    │           ├── SkipTest.cs
    │           ├── SkipUntilTest.cs
    │           ├── SkipWhileTest.cs
    │           ├── SubscribeAwaitTest.cs
    │           ├── SubscribeOnTest.cs
    │           ├── SumTest.cs
    │           ├── SwitchTest.cs
    │           ├── SynchronizationTest.cs
    │           ├── TakeLastTest.cs
    │           ├── TakeTest.cs
    │           ├── TakeUntilTest.cs
    │           ├── TakeWhileTest.cs
    │           ├── ThrottleFirstLastTest.cs
    │           ├── TimeIntervalFrameIntervalTimestampFrameCountTest.cs
    │           ├── TimeoutTest.cs
    │           ├── ToArrayTest.cs
    │           ├── ToAsyncEnumerableTest.cs
    │           ├── ToDictionaryTest.cs
    │           ├── ToHashSetTest.cs
    │           ├── ToListTest.cs
    │           ├── ToLookupTest.cs
    │           ├── TrampolineTest.cs
    │           ├── WaitTest.cs
    │           ├── WhereAwaitTest.cs
    │           ├── WhereNotNullTest.cs
    │           ├── WhereTest.cs
    │           ├── WithLatestFromTest.cs
    │           ├── ZipLatestTest.cs
    │           └── ZipTest.cs
    └── .github/
        ├── dependabot.yaml
        ├── FUNDING.yml
        └── workflows/
            ├── build-debug.yaml
            ├── build-release.yaml
            └── stale.yaml

================================================
FILE: Directory.Build.props
================================================
<Project>

  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)opensource.snk</AssemblyOriginatorKeyFile>

    <!-- NuGet Packaging -->
    <IsPackable>false</IsPackable>
    <PackageVersion>$(Version)</PackageVersion>
    <Company>Cysharp</Company>
    <Authors>Cysharp</Authors>
    <Copyright>© Cysharp, Inc.</Copyright>
    <PackageProjectUrl>https://github.com/Cysharp/R3</PackageProjectUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageIcon>Icon.png</PackageIcon>
  </PropertyGroup>

  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)Icon.png" Pack="true" PackagePath="\" />
    <None Include="$(MSBuildThisFileDirectory)README.md" Pack="true" PackagePath="\" />
    <EmbeddedResource Include="$(MSBuildThisFileDirectory)LICENSE" />
  </ItemGroup>

</Project>



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Cysharp, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: opensource.snk
================================================
[Binary file]


================================================
FILE: R3.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34309.116
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3", "src\R3\R3.csproj", "{17F32115-0300-4842-8328-395AB56F6BD7}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{9FA6D327-728B-4436-AE3A-9E46D8FEF591}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "sandbox", "sandbox", "{FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ConsoleApp1", "sandbox\ConsoleApp1\ConsoleApp1.csproj", "{72DE3CB9-195E-4740-9416-5960D75ED795}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{0544806B-3BB4-43CF-8277-BC612F32208D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Tests", "tests\R3.Tests\R3.Tests.csproj", "{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "docs", "docs", "{C7327A31-448F-4A7D-9AC6-C06F5AA03D02}"
	ProjectSection(SolutionItems) = preProject
		.gitignore = .gitignore
		Directory.Build.props = Directory.Build.props
		README.md = README.md
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.WPF", "src\R3.WPF\R3.WPF.csproj", "{57AC0130-0D5F-489A-A565-B41EF9928085}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WpfApp1", "sandbox\WpfApp1\WpfApp1.csproj", "{BA40E541-3BCD-438A-B966-2FC7BE80AB80}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Avalonia", "src\R3.Avalonia\R3.Avalonia.csproj", "{C492C048-732F-4F0D-AC09-03F3187ABB17}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AvaloniaApplication1", "sandbox\AvaloniaApplication1\AvaloniaApplication1.csproj", "{978BECEF-5217-4531-B0B7-45BC8D820A28}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Godot", "src\R3.Godot\R3.Godot.csproj", "{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Benchmark", "sandbox\Benchmark\Benchmark.csproj", "{EBC13ACA-717D-4635-920A-5E0E211B0CF4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WinFormsApp1", "sandbox\WinFormsApp1\WinFormsApp1.csproj", "{E6418D3D-01AA-4176-A7CA-6878FA6E4238}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.WinForms", "src\R3.WinForms\R3.WinForms.csproj", "{6598690F-B65B-4C49-824B-7474E735AE92}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ReferenceBuilder", "sandbox\ReferenceBuilder\ReferenceBuilder.csproj", "{4298FE47-5434-4A0B-9793-6B771E6FC4CA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Stride", "src\R3.Stride\R3.Stride.csproj", "{A6554704-FE57-4473-BB46-8586F22472AA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.LogicLooper", "src\R3.LogicLooper\R3.LogicLooper.csproj", "{B95D732A-7538-4795-AC42-6F595ECB8DB8}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MauiApp1", "sandbox\MauiApp1\MauiApp1.csproj", "{2CD257D7-DF21-4D60-AC05-747D83236E5A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Maui", "src\R3.Maui\R3.Maui.csproj", "{F1D6609C-AA33-4099-8932-BADBCB935FBD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MonoGameApplication1", "sandbox\MonoGameApplication1\MonoGameApplication1.csproj", "{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.MonoGame", "src\R3.MonoGame\R3.MonoGame.csproj", "{D754069D-C912-4D71-97CB-9B2DDD2380B4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.WinUI3", "src\R3.WinUI3\R3.WinUI3.csproj", "{87F12DBB-E32B-49B8-B5F1-5B53B711989B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WinUI3App1", "sandbox\WinUI3App1\WinUI3App1.csproj", "{CDC17599-81AD-44B9-B4E5-38241147CDA2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BlazorApp1", "sandbox\BlazorApp1\BlazorApp1.csproj", "{F55F3891-FD11-4C69-9DB6-0CC24B591F59}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Blazor", "src\R3.Blazor\R3.Blazor.csproj", "{EC0E35F9-9362-41CB-8F8F-797547803892}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.BlazorWebAssembly", "src\R3.BlazorWebAssembly\R3.BlazorWebAssembly.csproj", "{3C77C89F-AA56-4C0A-9635-C0795F41C65C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BlazorWebAssemblyApp1", "sandbox\BlazorWebAssemblyApp1\BlazorWebAssemblyApp1.csproj", "{C55C88AE-1C1E-469A-A34A-AE508885D616}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "R3.Uno", "src\R3.Uno\R3.Uno.csproj", "{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|ARM64.Build.0 = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x64.ActiveCfg = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x64.Build.0 = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x86.ActiveCfg = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Debug|x86.Build.0 = Debug|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|Any CPU.Build.0 = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|ARM64.ActiveCfg = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|ARM64.Build.0 = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x64.ActiveCfg = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x64.Build.0 = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x86.ActiveCfg = Release|Any CPU
		{17F32115-0300-4842-8328-395AB56F6BD7}.Release|x86.Build.0 = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|ARM64.Build.0 = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x64.ActiveCfg = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x64.Build.0 = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x86.ActiveCfg = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Debug|x86.Build.0 = Debug|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|Any CPU.Build.0 = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|ARM64.ActiveCfg = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|ARM64.Build.0 = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x64.ActiveCfg = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x64.Build.0 = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x86.ActiveCfg = Release|Any CPU
		{72DE3CB9-195E-4740-9416-5960D75ED795}.Release|x86.Build.0 = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|ARM64.Build.0 = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x64.Build.0 = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Debug|x86.Build.0 = Debug|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|Any CPU.Build.0 = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|ARM64.ActiveCfg = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|ARM64.Build.0 = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x64.ActiveCfg = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x64.Build.0 = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x86.ActiveCfg = Release|Any CPU
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B}.Release|x86.Build.0 = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|ARM64.Build.0 = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x64.ActiveCfg = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x64.Build.0 = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x86.ActiveCfg = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Debug|x86.Build.0 = Debug|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|Any CPU.Build.0 = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|ARM64.ActiveCfg = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|ARM64.Build.0 = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x64.ActiveCfg = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x64.Build.0 = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x86.ActiveCfg = Release|Any CPU
		{57AC0130-0D5F-489A-A565-B41EF9928085}.Release|x86.Build.0 = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|ARM64.Build.0 = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x64.ActiveCfg = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x64.Build.0 = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x86.ActiveCfg = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Debug|x86.Build.0 = Debug|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|Any CPU.Build.0 = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|ARM64.ActiveCfg = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|ARM64.Build.0 = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x64.ActiveCfg = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x64.Build.0 = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x86.ActiveCfg = Release|Any CPU
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80}.Release|x86.Build.0 = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|ARM64.Build.0 = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x64.ActiveCfg = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x64.Build.0 = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Debug|x86.Build.0 = Debug|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|Any CPU.Build.0 = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|ARM64.ActiveCfg = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|ARM64.Build.0 = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x64.ActiveCfg = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x64.Build.0 = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x86.ActiveCfg = Release|Any CPU
		{C492C048-732F-4F0D-AC09-03F3187ABB17}.Release|x86.Build.0 = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|ARM64.Build.0 = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x64.ActiveCfg = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x64.Build.0 = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x86.ActiveCfg = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Debug|x86.Build.0 = Debug|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|Any CPU.Build.0 = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|ARM64.ActiveCfg = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|ARM64.Build.0 = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x64.ActiveCfg = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x64.Build.0 = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x86.ActiveCfg = Release|Any CPU
		{978BECEF-5217-4531-B0B7-45BC8D820A28}.Release|x86.Build.0 = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|ARM64.Build.0 = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x64.Build.0 = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Debug|x86.Build.0 = Debug|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|Any CPU.Build.0 = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|ARM64.ActiveCfg = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|ARM64.Build.0 = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x64.ActiveCfg = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x64.Build.0 = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x86.ActiveCfg = Release|Any CPU
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30}.Release|x86.Build.0 = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|ARM64.Build.0 = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x64.Build.0 = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Debug|x86.Build.0 = Debug|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|Any CPU.Build.0 = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|ARM64.ActiveCfg = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|ARM64.Build.0 = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x64.ActiveCfg = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x64.Build.0 = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x86.ActiveCfg = Release|Any CPU
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4}.Release|x86.Build.0 = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|ARM64.Build.0 = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x64.Build.0 = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Debug|x86.Build.0 = Debug|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|Any CPU.Build.0 = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|ARM64.ActiveCfg = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|ARM64.Build.0 = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x64.ActiveCfg = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x64.Build.0 = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x86.ActiveCfg = Release|Any CPU
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238}.Release|x86.Build.0 = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|ARM64.Build.0 = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x64.Build.0 = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Debug|x86.Build.0 = Debug|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|Any CPU.Build.0 = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|ARM64.ActiveCfg = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|ARM64.Build.0 = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x64.ActiveCfg = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x64.Build.0 = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x86.ActiveCfg = Release|Any CPU
		{6598690F-B65B-4C49-824B-7474E735AE92}.Release|x86.Build.0 = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|ARM64.Build.0 = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x64.Build.0 = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Debug|x86.Build.0 = Debug|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|Any CPU.Build.0 = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|ARM64.ActiveCfg = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|ARM64.Build.0 = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x64.ActiveCfg = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x64.Build.0 = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x86.ActiveCfg = Release|Any CPU
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA}.Release|x86.Build.0 = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|ARM64.Build.0 = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x64.Build.0 = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Debug|x86.Build.0 = Debug|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|Any CPU.Build.0 = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|ARM64.ActiveCfg = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|ARM64.Build.0 = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x64.ActiveCfg = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x64.Build.0 = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x86.ActiveCfg = Release|Any CPU
		{A6554704-FE57-4473-BB46-8586F22472AA}.Release|x86.Build.0 = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|ARM64.Build.0 = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x64.Build.0 = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Debug|x86.Build.0 = Debug|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|Any CPU.Build.0 = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|ARM64.ActiveCfg = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|ARM64.Build.0 = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x64.ActiveCfg = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x64.Build.0 = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x86.ActiveCfg = Release|Any CPU
		{B95D732A-7538-4795-AC42-6F595ECB8DB8}.Release|x86.Build.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.Build.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|ARM64.Deploy.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.Build.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x64.Deploy.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.Build.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Debug|x86.Deploy.0 = Debug|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.ActiveCfg = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.Build.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|ARM64.Deploy.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.ActiveCfg = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.Build.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x64.Deploy.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.ActiveCfg = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.Build.0 = Release|Any CPU
		{2CD257D7-DF21-4D60-AC05-747D83236E5A}.Release|x86.Deploy.0 = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|ARM64.Build.0 = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x64.Build.0 = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Debug|x86.Build.0 = Debug|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|Any CPU.Build.0 = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|ARM64.ActiveCfg = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|ARM64.Build.0 = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x64.ActiveCfg = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x64.Build.0 = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x86.ActiveCfg = Release|Any CPU
		{F1D6609C-AA33-4099-8932-BADBCB935FBD}.Release|x86.Build.0 = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|ARM64.Build.0 = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x64.ActiveCfg = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x64.Build.0 = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x86.ActiveCfg = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Debug|x86.Build.0 = Debug|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|Any CPU.Build.0 = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|ARM64.ActiveCfg = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|ARM64.Build.0 = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x64.ActiveCfg = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x64.Build.0 = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x86.ActiveCfg = Release|Any CPU
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF}.Release|x86.Build.0 = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|ARM64.Build.0 = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x64.Build.0 = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Debug|x86.Build.0 = Debug|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|Any CPU.Build.0 = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|ARM64.ActiveCfg = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|ARM64.Build.0 = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x64.ActiveCfg = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x64.Build.0 = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x86.ActiveCfg = Release|Any CPU
		{D754069D-C912-4D71-97CB-9B2DDD2380B4}.Release|x86.Build.0 = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|ARM64.Build.0 = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x64.Build.0 = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Debug|x86.Build.0 = Debug|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|Any CPU.Build.0 = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|ARM64.ActiveCfg = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|ARM64.Build.0 = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x64.ActiveCfg = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x64.Build.0 = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x86.ActiveCfg = Release|Any CPU
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B}.Release|x86.Build.0 = Release|Any CPU
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|Any CPU.ActiveCfg = Debug|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|Any CPU.Deploy.0 = Debug|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.Build.0 = Debug|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.ActiveCfg = Debug|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.Build.0 = Debug|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x64.Deploy.0 = Debug|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.ActiveCfg = Debug|x86
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.Build.0 = Debug|x86
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Debug|x86.Deploy.0 = Debug|x86
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|Any CPU.ActiveCfg = Release|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.ActiveCfg = Release|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.Build.0 = Release|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|ARM64.Deploy.0 = Release|ARM64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.ActiveCfg = Release|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.Build.0 = Release|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x64.Deploy.0 = Release|x64
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.ActiveCfg = Release|x86
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.Build.0 = Release|x86
		{CDC17599-81AD-44B9-B4E5-38241147CDA2}.Release|x86.Deploy.0 = Release|x86
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|ARM64.Build.0 = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x64.Build.0 = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Debug|x86.Build.0 = Debug|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|Any CPU.Build.0 = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|ARM64.ActiveCfg = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|ARM64.Build.0 = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x64.ActiveCfg = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x64.Build.0 = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x86.ActiveCfg = Release|Any CPU
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59}.Release|x86.Build.0 = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|ARM64.Build.0 = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x64.Build.0 = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Debug|x86.Build.0 = Debug|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|Any CPU.Build.0 = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|ARM64.ActiveCfg = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|ARM64.Build.0 = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x64.ActiveCfg = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x64.Build.0 = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x86.ActiveCfg = Release|Any CPU
		{EC0E35F9-9362-41CB-8F8F-797547803892}.Release|x86.Build.0 = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|ARM64.Build.0 = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x64.Build.0 = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Debug|x86.Build.0 = Debug|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|Any CPU.Build.0 = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|ARM64.ActiveCfg = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|ARM64.Build.0 = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x64.ActiveCfg = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x64.Build.0 = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x86.ActiveCfg = Release|Any CPU
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C}.Release|x86.Build.0 = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|ARM64.Build.0 = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x64.ActiveCfg = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x64.Build.0 = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Debug|x86.Build.0 = Debug|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|Any CPU.Build.0 = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|ARM64.ActiveCfg = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|ARM64.Build.0 = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x64.ActiveCfg = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x64.Build.0 = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x86.ActiveCfg = Release|Any CPU
		{C55C88AE-1C1E-469A-A34A-AE508885D616}.Release|x86.Build.0 = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|ARM64.Build.0 = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|x64.Build.0 = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Debug|x86.Build.0 = Debug|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|Any CPU.Build.0 = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|ARM64.ActiveCfg = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|ARM64.Build.0 = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|x64.ActiveCfg = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|x64.Build.0 = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|x86.ActiveCfg = Release|Any CPU
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{17F32115-0300-4842-8328-395AB56F6BD7} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{72DE3CB9-195E-4740-9416-5960D75ED795} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{42F7C4F7-3BB3-4DC8-8285-9DFF7E93BC4B} = {0544806B-3BB4-43CF-8277-BC612F32208D}
		{57AC0130-0D5F-489A-A565-B41EF9928085} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{BA40E541-3BCD-438A-B966-2FC7BE80AB80} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{C492C048-732F-4F0D-AC09-03F3187ABB17} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{978BECEF-5217-4531-B0B7-45BC8D820A28} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{B7A5DDB0-5F43-49D0-A047-D0D26626BE30} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{EBC13ACA-717D-4635-920A-5E0E211B0CF4} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{E6418D3D-01AA-4176-A7CA-6878FA6E4238} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{6598690F-B65B-4C49-824B-7474E735AE92} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{4298FE47-5434-4A0B-9793-6B771E6FC4CA} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{A6554704-FE57-4473-BB46-8586F22472AA} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{B95D732A-7538-4795-AC42-6F595ECB8DB8} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{2CD257D7-DF21-4D60-AC05-747D83236E5A} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{F1D6609C-AA33-4099-8932-BADBCB935FBD} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{BEF76A77-E2F9-4113-8DC2-DB825964D6EF} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{D754069D-C912-4D71-97CB-9B2DDD2380B4} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{87F12DBB-E32B-49B8-B5F1-5B53B711989B} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{CDC17599-81AD-44B9-B4E5-38241147CDA2} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{F55F3891-FD11-4C69-9DB6-0CC24B591F59} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{EC0E35F9-9362-41CB-8F8F-797547803892} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{3C77C89F-AA56-4C0A-9635-C0795F41C65C} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
		{C55C88AE-1C1E-469A-A34A-AE508885D616} = {FAB2137C-1DBA-4F2F-8E22-DF3521C9B365}
		{DC15EDFB-C5B0-4B5B-B486-5AC01F522163} = {9FA6D327-728B-4436-AE3A-9E46D8FEF591}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {84B77761-6B9E-46BA-B132-6C77B0B6E4FA}
	EndGlobalSection
EndGlobal



================================================
FILE: .editorconfig
================================================
# top-most EditorConfig file
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

# Visual Studio Spell checker configs (https://learn.microsoft.com/en-us/visualstudio/ide/text-spell-checker?view=vs-2022#how-to-customize-the-spell-checker)
spelling_exclusion_path  = ./exclusion.dic

[*.cs]
indent_size = 4
charset = utf-8-bom
end_of_line = unset

# Solution files
[*.{sln,slnx}]
end_of_line = unset

# MSBuild project files
[*.{csproj,props,targets}]
end_of_line = unset

# Xml config files
[*.{ruleset,config,nuspec,resx,runsettings,DotSettings}]
end_of_line = unset

[*{_AssemblyInfo.cs,.notsupported.cs}]
generated_code = true

# C# code style settings
[*.{cs}]
dotnet_style_operator_placement_when_wrapping = beginning_of_line
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_auto_properties = true:suggestion
dotnet_style_object_initializer = true:suggestion
dotnet_style_prefer_collection_expression = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_compound_assignment = true:suggestion
dotnet_style_prefer_simplified_interpolation = true:suggestion
dotnet_style_namespace_match_folder = true:suggestion
dotnet_style_readonly_field = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_require_accessibility_modifiers = for_non_interface_members:silent
dotnet_style_allow_statement_immediately_after_block_experimental = true:silent
dotnet_style_allow_multiple_blank_lines_experimental = true:silent
dotnet_code_quality_unused_parameters = non_public:suggestion
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent
dotnet_style_qualification_for_method = false:none
dotnet_style_qualification_for_property = false:none
dotnet_style_qualification_for_field = false:none
dotnet_style_qualification_for_event = false:none

# New line preferences
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_between_query_expression_clauses = true

# Indentation preferences
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = true
csharp_indent_switch_labels = true
csharp_indent_labels = one_less_than_current

# Modifier preferences
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:suggestion

# avoid this. unless absolutely necessary
dotnet_style_qualification_for_field = false:none
dotnet_style_qualification_for_property = false:none
dotnet_style_qualification_for_method = false:none
dotnet_style_qualification_for_event = false:none

# Types: use keywords instead of BCL types, and permit var only when the type is clear
csharp_style_var_for_built_in_types = false:none
csharp_style_var_when_type_is_apparent = false:none
csharp_style_var_elsewhere = false:none
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion

# name all constant fields using PascalCase
dotnet_naming_rule.constant_fields_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.constant_fields_should_be_pascal_case.symbols  = constant_fields
dotnet_naming_rule.constant_fields_should_be_pascal_case.style = pascal_case_style
dotnet_naming_symbols.constant_fields.applicable_kinds   = field
dotnet_naming_symbols.constant_fields.required_modifiers = const
dotnet_naming_style.pascal_case_style.capitalization = pascal_case

# static fields
dotnet_naming_rule.static_fields_should_have_prefix.severity = none
dotnet_naming_rule.static_fields_should_have_prefix.symbols  = static_fields
dotnet_naming_rule.static_fields_should_have_prefix.style = static_prefix_style
dotnet_naming_symbols.static_fields.applicable_kinds   = field
dotnet_naming_symbols.static_fields.required_modifiers = static
dotnet_naming_symbols.static_fields.applicable_accessibilities = private, internal, private_protected
dotnet_naming_style.static_prefix_style.required_prefix = s_
dotnet_naming_style.static_prefix_style.capitalization = camel_case

# internal and private fields
dotnet_naming_rule.camel_case_for_private_internal_fields.severity = none
dotnet_naming_rule.camel_case_for_private_internal_fields.symbols  = private_internal_fields
dotnet_naming_rule.camel_case_for_private_internal_fields.style = camel_case_underscore_style
dotnet_naming_symbols.private_internal_fields.applicable_kinds = field
dotnet_naming_symbols.private_internal_fields.applicable_accessibilities = private, internal
dotnet_naming_style.camel_case_underscore_style.required_prefix = _
dotnet_naming_style.camel_case_underscore_style.capitalization = camel_case

# Code style defaults
csharp_using_directive_placement = outside_namespace:suggestion
csharp_prefer_braces = true:silent
csharp_preserve_single_line_blocks = true:none
csharp_preserve_single_line_statements = false:none
csharp_prefer_static_local_function = true:suggestion
csharp_prefer_simple_using_statement = false:none
csharp_style_prefer_switch_expression = true:suggestion

# Code quality
dotnet_style_readonly_field = true:suggestion
dotnet_code_quality_unused_parameters = non_public:suggestion

# Expression-level preferences
dotnet_style_object_initializer = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_auto_properties = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
csharp_prefer_simple_default_expression = true:suggestion

# Expression-bodied members
csharp_style_expression_bodied_methods = true:silent
csharp_style_expression_bodied_constructors = true:silent
csharp_style_expression_bodied_operators = true:silent
csharp_style_expression_bodied_properties = true:silent
csharp_style_expression_bodied_indexers = true:silent
csharp_style_expression_bodied_accessors = true:silent
csharp_style_expression_bodied_lambdas = true:silent
csharp_style_expression_bodied_local_functions = true:silent

# Pattern matching
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion

# Null checking preferences
csharp_style_throw_expression = true:suggestion
csharp_style_conditional_delegate_call = true:suggestion

# Other features
csharp_style_prefer_index_operator = false:none
csharp_style_prefer_range_operator = false:none
csharp_style_pattern_local_over_anonymous_function = false:none

# Space preferences
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = do_not_ignore
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses = false
csharp_space_between_square_brackets = false

# Analyzers
dotnet_code_quality.CA1052.api_surface = private, internal
dotnet_code_quality.CA1802.api_surface = private, internal
dotnet_code_quality.CA1822.api_surface = private, internal
dotnet_code_quality.CA2208.api_surface = public

# IDE0008: Use explicit type
dotnet_diagnostic.IDE0008.severity = none

# IDE0090: Use 'new(...)'
dotnet_diagnostic.IDE0090.severity = none

# IDE0040: Add accessibility modifiers
dotnet_diagnostic.IDE0040.severity = none

# Nullability in reference types of interface implemented by the base type doesn't match
dotnet_diagnostic.CS8644.severity = none

dotnet_diagnostic.CA1816.severity = none

dotnet_diagnostic.IDE1006.severity = none

#Remove unnecessary suppression
dotnet_diagnostic.IDE0079.severity = none

dotnet_diagnostic.IDE0130.severity = none

dotnet_diagnostic.CA1822.severity = none

csharp_style_prefer_switch_expression = false:suggestion

csharp_style_pattern_matching_over_as_with_null_check = false:suggestion

dotnet_naming_symbols.functional_symbols.applicable_kinds           = property,method,event,delegate
dotnet_naming_style.pascal_case_style.capitalization = pascal_case
dotnet_naming_rule.functional_symbols_must_be_capitalized.symbols   = functional_symbols
dotnet_naming_rule.functional_symbols_must_be_capitalized.style = pascal_case_style
dotnet_naming_rule.functional_symbols_must_be_capitalized.severity = warning

dotnet_naming_symbols.public_symbols.applicable_kinds           = property,method,field,event,delegate
dotnet_naming_symbols.public_symbols.applicable_accessibilities = public
dotnet_naming_symbols.public_symbols.required_modifiers         = readonly
dotnet_naming_style.first_word_upper_case_style.capitalization = first_word_upper
dotnet_naming_rule.public_members_must_be_capitalized.symbols   = public_symbols
dotnet_naming_rule.public_members_must_be_capitalized.style = first_word_upper_case_style
dotnet_naming_rule.public_members_must_be_capitalized.severity = warning

csharp_style_expression_bodied_methods = false:silent
csharp_style_expression_bodied_constructors = false:silent
csharp_style_expression_bodied_operators = false:silent
csharp_style_namespace_declarations = file_scoped:suggestion
csharp_style_prefer_method_group_conversion = true:silent
csharp_style_prefer_top_level_statements = true:silent
csharp_style_prefer_primary_constructors = true:suggestion
csharp_style_prefer_null_check_over_type_check = true:suggestion
csharp_style_prefer_local_over_anonymous_function = true:suggestion
csharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion
csharp_style_prefer_tuple_swap = true:suggestion
csharp_style_prefer_utf8_string_literals = true:suggestion
csharp_style_deconstructed_variable_declaration = true:suggestion
csharp_style_unused_value_assignment_preference = discard_variable:suggestion
csharp_style_unused_value_expression_statement_preference = discard_variable:silent
csharp_style_prefer_readonly_struct_member = true:suggestion
csharp_style_prefer_readonly_struct = true:suggestion
csharp_style_allow_embedded_statements_on_same_line_experimental = true:silent
csharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true:silent
csharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true:silent
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent
csharp_style_prefer_pattern_matching = true:silent
csharp_style_prefer_extended_property_pattern = true:suggestion
csharp_style_prefer_not_pattern = true:suggestion



================================================
FILE: docs/reference_factory.md
================================================
| Name(Parameter) | ReturnType | 
| --- | --- | 
| **CombineLatest**(params `Observable<T>[]` sources) | `Observable<T[]>` | 
| **CombineLatest**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | 
| **CombineLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | 
| **Concat**(params `Observable<T>[]` sources) | `Observable<T>` | 
| **Concat**(`IEnumerable<Observable<T>>` sources) | `Observable<T>` | 
| **Concat**(this `Observable<Observable<T>>` sources) | `Observable<T>` | 
| **Create**(`Func<Observer<T>, IDisposable>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | 
| **Create**(`TState` state, `Func<Observer<T>, TState, IDisposable>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | 
| **Create**(`Func<Observer<T>, CancellationToken, ValueTask>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | 
| **Create**(`TState` state, `Func<Observer<T>, TState, CancellationToken, ValueTask>` subscribe, `Boolean` rawObserver = false) | `Observable<T>` | 
| **CreateFrom**(`Func<CancellationToken, IAsyncEnumerable<T>>` factory) | `Observable<T>` | 
| **CreateFrom**(`TState` state, `Func<CancellationToken, TState, IAsyncEnumerable<T>>` factory) | `Observable<T>` | 
| **Defer**(`Func<Observable<T>>` observableFactory, `Boolean` rawObserver = false) | `Observable<T>` | 
| **Empty**() | `Observable<T>` | 
| **Empty**(`TimeProvider` timeProvider) | `Observable<T>` | 
| **Empty**(`TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **EveryUpdate**() | `Observable<Unit>` | 
| **EveryUpdate**(`CancellationToken` cancellationToken) | `Observable<Unit>` | 
| **EveryUpdate**(`FrameProvider` frameProvider) | `Observable<Unit>` | 
| **EveryUpdate**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken) | `Observable<Unit>` | 
| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | 
| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | 
| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `EqualityComparer<TProperty>` equalityComparer, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | 
| **EveryValueChanged**(`TSource` source, `Func<TSource, TProperty>` propertySelector, `FrameProvider` frameProvider, `EqualityComparer<TProperty>` equalityComparer, `CancellationToken` cancellationToken = default) | `Observable<TProperty>` | 
| **FromAsync**(`Func<CancellationToken, ValueTask>` asyncFactory, `Boolean` configureAwait = true) | `Observable<Unit>` | 
| **FromAsync**(`Func<CancellationToken, ValueTask<T>>` asyncFactory, `Boolean` configureAwait = true) | `Observable<T>` | 
| **FromEvent**(`Action<Action>` addHandler, `Action<Action>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **FromEvent**(`Action<Action<T>>` addHandler, `Action<Action<T>>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **FromEvent**(`Func<Action, TDelegate>` conversion, `Action<TDelegate>` addHandler, `Action<TDelegate>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **FromEvent**(`Func<Action<T>, TDelegate>` conversion, `Action<TDelegate>` addHandler, `Action<TDelegate>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **FromEventHandler**(`Action<EventHandler>` addHandler, `Action<EventHandler>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<ValueTuple<Object, EventArgs>>` | 
| **FromEventHandler**(`Action<EventHandler<TEventArgs>>` addHandler, `Action<EventHandler<TEventArgs>>` removeHandler, `CancellationToken` cancellationToken = default) | `Observable<ValueTuple<Object, TEventArgs>>` | 
| **Interval**(`TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Interval**(`TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **IntervalFrame**(`Int32` periodFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **IntervalFrame**(`Int32` periodFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Merge**(params `Observable<T>[]` sources) | `Observable<T>` | 
| **Merge**(this `IEnumerable<Observable<T>>` sources) | `Observable<T>` | 
| **Merge**(this `Observable<Observable<T>>` sources) | `Observable<T>` | 
| **Never**() | `Observable<T>` | 
| **NextFrame**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **NextFrame**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty>` propertySelector, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` expr = default) | `Observable<TProperty>` | 
| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default) | `Observable<TProperty2>` | 
| **ObservePropertyChanged**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Func<TProperty2, TProperty3>` propertySelector3, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default, `String` propertySelector3Expr = default) | `Observable<TProperty3>` | 
| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty>` propertySelector, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` expr = default) | `Observable<TProperty>` | 
| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default) | `Observable<TProperty2>` | 
| **ObservePropertyChanging**(this `T` value, `Func<T, TProperty1>` propertySelector1, `Func<TProperty1, TProperty2>` propertySelector2, `Func<TProperty2, TProperty3>` propertySelector3, `Boolean` pushCurrentValueOnSubscribe = true, `CancellationToken` cancellationToken = default, `String` propertySelector1Expr = default, `String` propertySelector2Expr = default, `String` propertySelector3Expr = default) | `Observable<TProperty3>` | 
| **Race**(params `Observable<T>[]` sources) | `Observable<T>` | 
| **Race**(`IEnumerable<Observable<T>>` sources) | `Observable<T>` | 
| **Range**(`Int32` start, `Int32` count) | `Observable<Int32>` | 
| **Range**(`Int32` start, `Int32` count, `CancellationToken` cancellationToken) | `Observable<Int32>` | 
| **Repeat**(`T` value, `Int32` count) | `Observable<T>` | 
| **Repeat**(`T` value, `Int32` count, `CancellationToken` cancellationToken) | `Observable<T>` | 
| **Return**(`T` value) | `Observable<T>` | 
| **Return**(`T` value, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **Return**(`T` value, `TimeSpan` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **Return**(`Unit` value) | `Observable<Unit>` | 
| **Return**(`Boolean` value) | `Observable<Boolean>` | 
| **Return**(`Int32` value) | `Observable<Int32>` | 
| **ReturnFrame**(`T` value, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **ReturnFrame**(`T` value, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **ReturnFrame**(`T` value, `Int32` dueTimeFrame, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **ReturnFrame**(`T` value, `Int32` dueTimeFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **ReturnOnCompleted**(`Result` result) | `Observable<T>` | 
| **ReturnOnCompleted**(`Result` result, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ReturnOnCompleted**(`Result` result, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ReturnUnit**() | `Observable<Unit>` | 
| **Throw**(`Exception` exception) | `Observable<T>` | 
| **Throw**(`Exception` exception, `TimeProvider` timeProvider) | `Observable<T>` | 
| **Throw**(`Exception` exception, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **Timer**(`TimeSpan` dueTime, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`DateTimeOffset` dueTime, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`TimeSpan` dueTime, `TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`DateTimeOffset` dueTime, `TimeSpan` period, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`TimeSpan` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`DateTimeOffset` dueTime, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`TimeSpan` dueTime, `TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Timer**(`DateTimeOffset` dueTime, `TimeSpan` period, `TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **TimerFrame**(`Int32` dueTimeFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **TimerFrame**(`Int32` dueTimeFrame, `Int32` periodFrame, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **TimerFrame**(`Int32` dueTimeFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **TimerFrame**(`Int32` dueTimeFrame, `Int32` periodFrame, `FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **ToObservable**(this `Task` task, `Boolean` configureAwait = true) | `Observable<Unit>` | 
| **ToObservable**(this `Task<T>` task, `Boolean` configureAwait = true) | `Observable<T>` | 
| **ToObservable**(this `ValueTask` task, `Boolean` configureAwait = true) | `Observable<Unit>` | 
| **ToObservable**(this `ValueTask<T>` task, `Boolean` configureAwait = true) | `Observable<T>` | 
| **ToObservable**(this `IEnumerable<T>` source, `CancellationToken` cancellationToken = default) | `Observable<T>` | 
| **ToObservable**(this `IAsyncEnumerable<T>` source) | `Observable<T>` | 
| **ToObservable**(this `IObservable<T>` source) | `Observable<T>` | 
| **Yield**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Yield**(`TimeProvider` timeProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **YieldFrame**(`CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **YieldFrame**(`FrameProvider` frameProvider, `CancellationToken` cancellationToken = default) | `Observable<Unit>` | 
| **Zip**(params `Observable<T>[]` sources) | `Observable<T[]>` | 
| **Zip**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | 
| **Zip**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(params `Observable<T>[]` sources) | `Observable<T[]>` | 
| **ZipLatest**(`IEnumerable<Observable<T>>` sources) | `Observable<T[]>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Func<T1, T2, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Func<T1, T2, T3, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Func<T1, T2, T3, T4, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Func<T1, T2, T3, T4, T5, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Func<T1, T2, T3, T4, T5, T6, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Func<T1, T2, T3, T4, T5, T6, T7, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>` resultSelector) | `Observable<TResult>` | 
| **ZipLatest**(this `Observable<T1>` source1, `Observable<T2>` source2, `Observable<T3>` source3, `Observable<T4>` source4, `Observable<T5>` source5, `Observable<T6>` source6, `Observable<T7>` source7, `Observable<T8>` source8, `Observable<T9>` source9, `Observable<T10>` source10, `Observable<T11>` source11, `Observable<T12>` source12, `Observable<T13>` source13, `Observable<T14>` source14, `Observable<T15>` source15, `Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>` resultSelector) | `Observable<TResult>` | 





================================================
FILE: docs/reference_operator.md
================================================
| Name(Parameter) | ReturnType | 
| --- | --- | 
| **AggregateAsync**(this `Observable<T>` source, `Func<T, T, T>` func, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **AggregateAsync**(this `Observable<T>` source, `TResult` seed, `Func<TResult, T, TResult>` func, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **AggregateAsync**(this `Observable<T>` source, `TAccumulate` seed, `Func<TAccumulate, T, TAccumulate>` func, `Func<TAccumulate, TResult>` resultSelector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **AggregateByAsync**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `TAccumulate` seed, `Func<TAccumulate, TSource, TAccumulate>` func, `IEqualityComparer<TKey>` keyComparer = default, `CancellationToken` cancellationToken = default) | `Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>>` | 
| **AggregateByAsync**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `Func<TKey, TAccumulate>` seedSelector, `Func<TAccumulate, TSource, TAccumulate>` func, `IEqualityComparer<TKey>` keyComparer = default, `CancellationToken` cancellationToken = default) | `Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>>` | 
| **AllAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **AnyAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **AnyAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **Append**(this `Observable<T>` source, `T` value) | `Observable<T>` | 
| **Append**(this `Observable<T>` source, `IEnumerable<T>` values) | `Observable<T>` | 
| **Append**(this `Observable<T>` source, `Func<T>` valueFactory) | `Observable<T>` | 
| **Append**(this `Observable<T>` source, `TState` state, `Func<TState, T>` valueFactory) | `Observable<T>` | 
| **AsObservable**(this `Observable<T>` source) | `Observable<T>` | 
| **AsSystemObservable**(this `Observable<T>` source) | `IObservable<T>` | 
| **AsUnitObservable**(this `Observable<T>` source) | `Observable<Unit>` | 
| **AverageAsync**(this `Observable<Int32>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `Func<T, Int32>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<Int64>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `Func<T, Int64>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<Single>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `Func<T, Single>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<Double>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `Func<T, Double>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<Decimal>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `Func<T, Decimal>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **AverageAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **Cast**(this `Observable<T>` source) | `Observable<TResult>` | 
| **Catch**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | 
| **Catch**(this `Observable<T>` source, `Func<TException, Observable<T>>` errorHandler) | `Observable<T>` | 
| **Chunk**(this `Observable<T>` source, `Int32` count) | `Observable<T[]>` | 
| **Chunk**(this `Observable<T>` source, `Int32` count, `Int32` skip) | `Observable<T[]>` | 
| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T[]>` | 
| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T[]>` | 
| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `Int32` count) | `Observable<T[]>` | 
| **Chunk**(this `Observable<T>` source, `TimeSpan` timeSpan, `Int32` count, `TimeProvider` timeProvider) | `Observable<T[]>` | 
| **Chunk**(this `Observable<TSource>` source, `Observable<TWindowBoundary>` windowBoundaries) | `Observable<TSource[]>` | 
| **Chunk**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncWindow, `Boolean` configureAwait = true) | `Observable<T[]>` | 
| **ChunkFrame**(this `Observable<T>` source) | `Observable<T[]>` | 
| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T[]>` | 
| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T[]>` | 
| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `Int32` count) | `Observable<T[]>` | 
| **ChunkFrame**(this `Observable<T>` source, `Int32` frameCount, `Int32` count, `FrameProvider` frameProvider) | `Observable<T[]>` | 
| **ChunkUntil**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T[]>` | 
| **ChunkUntil**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T[]>` | 
| **Concat**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | 
| **ContainsAsync**(this `Observable<T>` source, `T` value, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **ContainsAsync**(this `Observable<T>` source, `T` value, `IEqualityComparer<T>` equalityComparer, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **CountAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Int32>` | 
| **CountAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Int32>` | 
| **Debounce**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | 
| **Debounce**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | 
| **Debounce**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` throttleDurationSelector, `Boolean` configureAwait = true) | `Observable<T>` | 
| **DebounceFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **DebounceFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **DefaultIfEmpty**(this `Observable<T>` source) | `Observable<T>` | 
| **DefaultIfEmpty**(this `Observable<T>` source, `T` defaultValue) | `Observable<T>` | 
| **Delay**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | 
| **Delay**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **DelayFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **DelayFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **DelaySubscription**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | 
| **DelaySubscription**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **DelaySubscriptionFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **DelaySubscriptionFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **Dematerialize**(this `Observable<Notification<T>>` source) | `Observable<T>` | 
| **Distinct**(this `Observable<T>` source) | `Observable<T>` | 
| **Distinct**(this `Observable<T>` source, `IEqualityComparer<T>` comparer) | `Observable<T>` | 
| **DistinctBy**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector) | `Observable<TSource>` | 
| **DistinctBy**(this `Observable<TSource>` source, `Func<TSource, TKey>` keySelector, `IEqualityComparer<TKey>` comparer) | `Observable<TSource>` | 
| **DistinctUntilChanged**(this `Observable<T>` source) | `Observable<T>` | 
| **DistinctUntilChanged**(this `Observable<T>` source, `IEqualityComparer<T>` comparer) | `Observable<T>` | 
| **DistinctUntilChangedBy**(this `Observable<T>` source, `Func<T, TKey>` keySelector) | `Observable<T>` | 
| **DistinctUntilChangedBy**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` comparer) | `Observable<T>` | 
| **Do**(this `Observable<T>` source, `Action<T>` onNext = default, `Action<Exception>` onErrorResume = default, `Action<Result>` onCompleted = default, `Action` onDispose = default, `Action` onSubscribe = default) | `Observable<T>` | 
| **Do**(this `Observable<T>` source, `TState` state, `Action<T, TState>` onNext = default, `Action<Exception, TState>` onErrorResume = default, `Action<Result, TState>` onCompleted = default, `Action<TState>` onDispose = default, `Action<TState>` onSubscribe = default) | `Observable<T>` | 
| **DoCancelOnCompleted**(this `Observable<T>` source, `CancellationTokenSource` cancellationTokenSource) | `Observable<T>` | 
| **ElementAtAsync**(this `Observable<T>` source, `Int32` index, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **ElementAtAsync**(this `Observable<T>` source, `Index` index, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **ElementAtOrDefaultAsync**(this `Observable<T>` source, `Int32` index, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **ElementAtOrDefaultAsync**(this `Observable<T>` source, `Index` index, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **FirstAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **FirstAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **FirstOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **FirstOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **ForEachAsync**(this `Observable<T>` source, `Action<T>` action, `CancellationToken` cancellationToken = default) | `Task` | 
| **ForEachAsync**(this `Observable<T>` source, `Action<T, Int32>` action, `CancellationToken` cancellationToken = default) | `Task` | 
| **FrameCount**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | 
| **FrameCount**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<ValueTuple<Int64, T>>` | 
| **FrameInterval**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | 
| **FrameInterval**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<ValueTuple<Int64, T>>` | 
| **IgnoreElements**(this `Observable<T>` source) | `Observable<T>` | 
| **IgnoreElements**(this `Observable<T>` source, `Action<T>` doOnNext) | `Observable<T>` | 
| **IgnoreOnErrorResume**(this `Observable<T>` source) | `Observable<T>` | 
| **IgnoreOnErrorResume**(this `Observable<T>` source, `Action<Exception>` doOnErrorResume) | `Observable<T>` | 
| **Index**(this `Observable<Unit>` source) | `Observable<Int32>` | 
| **Index**(this `Observable<T>` source) | `Observable<ValueTuple<Int32, T>>` | 
| **IsEmptyAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **LastAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **LastAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **LastOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **LastOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **LongCountAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<Int64>` | 
| **LongCountAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<Int64>` | 
| **Materialize**(this `Observable<T>` source) | `Observable<Notification<T>>` | 
| **MaxAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MaxAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **MaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **MaxByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MaxByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IComparer<TKey>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **Merge**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | 
| **MinAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MinAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MinAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **MinAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **MinByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MinByAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IComparer<TKey>` comparer, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **MinMaxAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<T, T>>` | 
| **MinMaxAsync**(this `Observable<T>` source, `IComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<T, T>>` | 
| **MinMaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<TResult, TResult>>` | 
| **MinMaxAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `IComparer<TResult>` comparer, `CancellationToken` cancellationToken = default) | `Task<ValueTuple<TResult, TResult>>` | 
| **Multicast**(this `Observable<T>` source, `ISubject<T>` subject) | `ConnectableObservable<T>` | 
| **ObserveOn**(this `Observable<T>` source, `SynchronizationContext` synchronizationContext) | `Observable<T>` | 
| **ObserveOn**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ObserveOn**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<T>` | 
| **ObserveOnCurrentSynchronizationContext**(this `Observable<T>` source) | `Observable<T>` | 
| **ObserveOnThreadPool**(this `Observable<T>` source) | `Observable<T>` | 
| **OfType**(this `Observable<T>` source) | `Observable<TResult>` | 
| **OnErrorResumeAsFailure**(this `Observable<T>` source) | `Observable<T>` | 
| **Pairwise**(this `Observable<T>` source) | `Observable<ValueTuple<T, T>>` | 
| **Prepend**(this `Observable<T>` source, `T` value) | `Observable<T>` | 
| **Prepend**(this `Observable<T>` source, `IEnumerable<T>` values) | `Observable<T>` | 
| **Prepend**(this `Observable<T>` source, `Func<T>` valueFactory) | `Observable<T>` | 
| **Prepend**(this `Observable<T>` source, `TState` state, `Func<TState, T>` valueFactory) | `Observable<T>` | 
| **Publish**(this `Observable<T>` source) | `ConnectableObservable<T>` | 
| **Publish**(this `Observable<T>` source, `T` initialValue) | `ConnectableObservable<T>` | 
| **Race**(this `Observable<T>` source, `Observable<T>` second) | `Observable<T>` | 
| **RefCount**(this `ConnectableObservable<T>` source) | `Observable<T>` | 
| **Replay**(this `Observable<T>` source) | `ConnectableObservable<T>` | 
| **Replay**(this `Observable<T>` source, `Int32` bufferSize) | `ConnectableObservable<T>` | 
| **Replay**(this `Observable<T>` source, `TimeSpan` window) | `ConnectableObservable<T>` | 
| **Replay**(this `Observable<T>` source, `TimeSpan` window, `TimeProvider` timeProvider) | `ConnectableObservable<T>` | 
| **Replay**(this `Observable<T>` source, `Int32` bufferSize, `TimeSpan` window) | `ConnectableObservable<T>` | 
| **Replay**(this `Observable<T>` source, `Int32` bufferSize, `TimeSpan` window, `TimeProvider` timeProvider) | `ConnectableObservable<T>` | 
| **ReplayFrame**(this `Observable<T>` source, `Int32` window) | `ConnectableObservable<T>` | 
| **ReplayFrame**(this `Observable<T>` source, `Int32` window, `FrameProvider` frameProvider) | `ConnectableObservable<T>` | 
| **ReplayFrame**(this `Observable<T>` source, `Int32` bufferSize, `Int32` window) | `ConnectableObservable<T>` | 
| **ReplayFrame**(this `Observable<T>` source, `Int32` bufferSize, `Int32` window, `FrameProvider` frameProvider) | `ConnectableObservable<T>` | 
| **Scan**(this `Observable<TSource>` source, `Func<TSource, TSource, TSource>` accumulator) | `Observable<TSource>` | 
| **Scan**(this `Observable<TSource>` source, `TAccumulate` seed, `Func<TAccumulate, TSource, TAccumulate>` accumulator) | `Observable<TAccumulate>` | 
| **Select**(this `Observable<T>` source, `Func<T, TResult>` selector) | `Observable<TResult>` | 
| **Select**(this `Observable<T>` source, `Func<T, Int32, TResult>` selector) | `Observable<TResult>` | 
| **Select**(this `Observable<T>` source, `TState` state, `Func<T, TState, TResult>` selector) | `Observable<TResult>` | 
| **Select**(this `Observable<T>` source, `TState` state, `Func<T, Int32, TState, TResult>` selector) | `Observable<TResult>` | 
| **SelectAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<TResult>>` selector, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `Observable<TResult>` | 
| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Observable<TResult>>` selector) | `Observable<TResult>` | 
| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Observable<TCollection>>` collectionSelector, `Func<TSource, TCollection, TResult>` resultSelector) | `Observable<TResult>` | 
| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Int32, Observable<TResult>>` selector) | `Observable<TResult>` | 
| **SelectMany**(this `Observable<TSource>` source, `Func<TSource, Int32, Observable<TCollection>>` collectionSelector, `Func<TSource, Int32, TCollection, Int32, TResult>` resultSelector) | `Observable<TResult>` | 
| **SequenceEqualAsync**(this `Observable<T>` source, `Observable<T>` second, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **SequenceEqualAsync**(this `Observable<T>` source, `Observable<T>` second, `IEqualityComparer<T>` equalityComparer, `CancellationToken` cancellationToken = default) | `Task<Boolean>` | 
| **Share**(this `Observable<T>` source) | `Observable<T>` | 
| **SingleAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **SingleAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **SingleOrDefaultAsync**(this `Observable<T>` source, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **SingleOrDefaultAsync**(this `Observable<T>` source, `Func<T, Boolean>` predicate, `T` defaultValue = default, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **Skip**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | 
| **Skip**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | 
| **Skip**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | 
| **SkipFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **SkipFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **SkipLast**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | 
| **SkipLast**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | 
| **SkipLast**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | 
| **SkipLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **SkipLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **SkipUntil**(this `Observable<T>` source, `Observable<TOther>` other) | `Observable<T>` | 
| **SkipUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | 
| **SkipUntil**(this `Observable<T>` source, `Task` task, `Boolean` configureAwait = true) | `Observable<T>` | 
| **SkipUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | 
| **SkipWhile**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | 
| **SkipWhile**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | 
| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` onNextAsync, `Action<Exception>` onErrorResume, `Action<Result>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeAwait**(this `Observable<T>` source, `TState` state, `Func<T, TState, CancellationToken, ValueTask>` onNextAsync, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeAwait**(this `Observable<T>` source, `TState` state, `Func<T, TState, CancellationToken, ValueTask>` onNextAsync, `Action<Result, TState>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeAwait**(this `Observable<T>` source, `TState` state, `Func<T, TState, CancellationToken, ValueTask>` onNextAsync, `Action<Exception, TState>` onErrorResume, `Action<Result, TState>` onCompleted, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `IDisposable` | 
| **SubscribeOn**(this `Observable<T>` source, `SynchronizationContext` synchronizationContext) | `Observable<T>` | 
| **SubscribeOn**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<T>` | 
| **SubscribeOn**(this `Observable<T>` source, `FrameProvider` frameProvider) | `Observable<T>` | 
| **SubscribeOnCurrentSynchronizationContext**(this `Observable<T>` source) | `Observable<T>` | 
| **SubscribeOnSynchronize**(this `Observable<T>` source, `Object` gate, `Boolean` rawObserver = false) | `Observable<T>` | 
| **SubscribeOnThreadPool**(this `Observable<T>` source) | `Observable<T>` | 
| **SumAsync**(this `Observable<Int32>` source, `CancellationToken` cancellationToken = default) | `Task<Int32>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Int32>` selector, `CancellationToken` cancellationToken = default) | `Task<Int32>` | 
| **SumAsync**(this `Observable<Int64>` source, `CancellationToken` cancellationToken = default) | `Task<Int64>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Int64>` selector, `CancellationToken` cancellationToken = default) | `Task<Int64>` | 
| **SumAsync**(this `Observable<Single>` source, `CancellationToken` cancellationToken = default) | `Task<Single>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Single>` selector, `CancellationToken` cancellationToken = default) | `Task<Single>` | 
| **SumAsync**(this `Observable<Double>` source, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Double>` selector, `CancellationToken` cancellationToken = default) | `Task<Double>` | 
| **SumAsync**(this `Observable<Decimal>` source, `CancellationToken` cancellationToken = default) | `Task<Decimal>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, Decimal>` selector, `CancellationToken` cancellationToken = default) | `Task<Decimal>` | 
| **SumAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T>` | 
| **SumAsync**(this `Observable<TSource>` source, `Func<TSource, TResult>` selector, `CancellationToken` cancellationToken = default) | `Task<TResult>` | 
| **Switch**(this `Observable<Observable<T>>` sources) | `Observable<T>` | 
| **Synchronize**(this `Observable<T>` source) | `Observable<T>` | 
| **Synchronize**(this `Observable<T>` source, `Object` gate) | `Observable<T>` | 
| **Take**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | 
| **Take**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | 
| **Take**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | 
| **TakeFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **TakeFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **TakeLast**(this `Observable<T>` source, `Int32` count) | `Observable<T>` | 
| **TakeLast**(this `Observable<T>` source, `TimeSpan` duration) | `Observable<T>` | 
| **TakeLast**(this `Observable<T>` source, `TimeSpan` duration, `TimeProvider` timeProvider) | `Observable<T>` | 
| **TakeLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **TakeLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `Observable<TOther>` other) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `CancellationToken` cancellationToken) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `Task` task, `Boolean` configureAwait = true) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` asyncFunc, `Boolean` configureAwait = true) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | 
| **TakeUntil**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | 
| **TakeWhile**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | 
| **TakeWhile**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | 
| **ThrottleFirst**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | 
| **ThrottleFirst**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ThrottleFirst**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | 
| **ThrottleFirst**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | 
| **ThrottleFirstFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **ThrottleFirstFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **ThrottleFirstLast**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | 
| **ThrottleFirstLast**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ThrottleFirstLast**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | 
| **ThrottleFirstLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | 
| **ThrottleFirstLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **ThrottleFirstLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **ThrottleLast**(this `Observable<T>` source, `TimeSpan` timeSpan) | `Observable<T>` | 
| **ThrottleLast**(this `Observable<T>` source, `TimeSpan` timeSpan, `TimeProvider` timeProvider) | `Observable<T>` | 
| **ThrottleLast**(this `Observable<T>` source, `Observable<TSample>` sampler) | `Observable<T>` | 
| **ThrottleLast**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask>` sampler, `Boolean` configureAwait = true) | `Observable<T>` | 
| **ThrottleLastFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **ThrottleLastFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **TimeInterval**(this `Observable<T>` source) | `Observable<ValueTuple<TimeSpan, T>>` | 
| **TimeInterval**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<ValueTuple<TimeSpan, T>>` | 
| **Timeout**(this `Observable<T>` source, `TimeSpan` dueTime) | `Observable<T>` | 
| **Timeout**(this `Observable<T>` source, `TimeSpan` dueTime, `TimeProvider` timeProvider) | `Observable<T>` | 
| **TimeoutFrame**(this `Observable<T>` source, `Int32` frameCount) | `Observable<T>` | 
| **TimeoutFrame**(this `Observable<T>` source, `Int32` frameCount, `FrameProvider` frameProvider) | `Observable<T>` | 
| **Timestamp**(this `Observable<T>` source) | `Observable<ValueTuple<Int64, T>>` | 
| **Timestamp**(this `Observable<T>` source, `TimeProvider` timeProvider) | `Observable<ValueTuple<Int64, T>>` | 
| **ToArrayAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<T[]>` | 
| **ToAsyncEnumerable**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `IAsyncEnumerable<T>` | 
| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, T>>` | 
| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, T>>` | 
| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, TElement>>` | 
| **ToDictionaryAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<Dictionary<TKey, TElement>>` | 
| **ToHashSetAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<HashSet<T>>` | 
| **ToHashSetAsync**(this `Observable<T>` source, `IEqualityComparer<T>` comparer, `CancellationToken` cancellationToken = default) | `Task<HashSet<T>>` | 
| **ToListAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task<List<T>>` | 
| **ToLiveList**(this `Observable<T>` source) | `LiveList<T>` | 
| **ToLiveList**(this `Observable<T>` source, `Int32` bufferSize) | `LiveList<T>` | 
| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, T>>` | 
| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, T>>` | 
| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, TElement>>` | 
| **ToLookupAsync**(this `Observable<T>` source, `Func<T, TKey>` keySelector, `Func<T, TElement>` elementSelector, `IEqualityComparer<TKey>` keyComparer, `CancellationToken` cancellationToken = default) | `Task<ILookup<TKey, TElement>>` | 
| **Trampoline**(this `Observable<T>` source) | `Observable<T>` | 
| **WaitAsync**(this `Observable<T>` source, `CancellationToken` cancellationToken = default) | `Task` | 
| **Where**(this `Observable<T>` source, `Func<T, Boolean>` predicate) | `Observable<T>` | 
| **Where**(this `Observable<T>` source, `Func<T, Int32, Boolean>` predicate) | `Observable<T>` | 
| **Where**(this `Observable<T>` source, `TState` state, `Func<T, TState, Boolean>` predicate) | `Observable<T>` | 
| **Where**(this `Observable<T>` source, `TState` state, `Func<T, Int32, TState, Boolean>` predicate) | `Observable<T>` | 
| **WhereAwait**(this `Observable<T>` source, `Func<T, CancellationToken, ValueTask<Boolean>>` predicate, `AwaitOperation` awaitOperation = AwaitOperation.Sequential, `Boolean` configureAwait = true, `Boolean` cancelOnCompleted = false, `Int32` maxConcurrent = -1) | `Observable<T>` | 
| **WhereNotNull**(this `Observable<TResult>` source) | `Observable<TResult>` | 
| **WithLatestFrom**(this `Observable<TFirst>` first, `Observable<TSecond>` second, `Func<TFirst, TSecond, TResult>` resultSelector) | `Observable<TResult>` | 





================================================
FILE: sandbox/AvaloniaApplication1/App.axaml
================================================
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="AvaloniaApplication1.App"
             RequestedThemeVariant="Default">
             <!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. -->

    <Application.Styles>
        <FluentTheme />
    </Application.Styles>
</Application>


================================================
FILE: sandbox/AvaloniaApplication1/App.axaml.cs
================================================
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;

namespace AvaloniaApplication1;
public partial class App : Application
{
    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow();
        }

        base.OnFrameworkInitializationCompleted();
    }
}


================================================
FILE: sandbox/AvaloniaApplication1/app.manifest
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <!-- This manifest is used on Windows only.
       Don't remove it as it might cause problems with window transparency and embedded controls.
       For more details visit https://learn.microsoft.com/en-us/windows/win32/sbscs/application-manifests -->
  <assemblyIdentity version="1.0.0.0" name="AvaloniaApplication1.Desktop"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
</assembly>



================================================
FILE: sandbox/AvaloniaApplication1/AvaloniaApplication1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
        <ApplicationManifest>app.manifest</ApplicationManifest>
        <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Avalonia" Version="11.0.6" />
        <PackageReference Include="Avalonia.Desktop" Version="11.0.6" />
        <PackageReference Include="Avalonia.Themes.Fluent" Version="11.0.6" />
        <PackageReference Include="Avalonia.Fonts.Inter" Version="11.0.6" />
        <!--Condition below is needed to remove Avalonia.Diagnostics package from build output in Release configuration.-->
        <PackageReference Condition="'$(Configuration)' == 'Debug'" Include="Avalonia.Diagnostics" Version="11.0.6" />
    </ItemGroup>


    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.Avalonia\R3.Avalonia.csproj" />
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: sandbox/AvaloniaApplication1/MainWindow.axaml
================================================
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="AvaloniaApplication1.MainWindow"
        Title="AvaloniaApplication1">

    <TextBlock Name="textBlock" />

</Window>



================================================
FILE: sandbox/AvaloniaApplication1/MainWindow.axaml.cs
================================================
﻿using Avalonia.Controls;
using Avalonia.Logging;
using R3;
using System;
using System.Diagnostics;
using Avalonia.Interactivity;
using R3.Avalonia;

namespace AvaloniaApplication1;

public partial class MainWindow : Window
{
    AvaloniaRenderingFrameProvider frameProvider;

    public MainWindow()
    {
        InitializeComponent();

        // initialize RenderingFrameProvider
        var topLevel = TopLevel.GetTopLevel(this);
        this.frameProvider = new AvaloniaRenderingFrameProvider(topLevel!);
    }


    protected override void OnLoaded(RoutedEventArgs e)
    {
        // pass frameProvider
        Observable.EveryValueChanged(this, x => x.Width, frameProvider)
            .Subscribe(x => textBlock.Text = x.ToString());
    }

    protected override void OnClosed(EventArgs e)
    {
        frameProvider.Dispose();
    }
}



================================================
FILE: sandbox/AvaloniaApplication1/Program.cs
================================================
﻿using Avalonia;
using Avalonia.Logging;
using System;

namespace AvaloniaApplication1;

internal class Program
{
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
        .StartWithClassicDesktopLifetime(args);

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .WithInterFont()
            .LogToTrace()
            .UseR3(); // add this line
}



================================================
FILE: sandbox/Benchmark/Benchmark.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BenchmarkDotNet" Version="0.13.12" />
        <PackageReference Include="System.Reactive.Linq" Version="6.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/Benchmark/Program.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using R3;
using System.Reactive.Concurrency;
using System.Reflection;

BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()!).Run(args);

file class BenchmarkConfig : ManualConfig
{
    public BenchmarkConfig()
    {
        AddDiagnoser(MemoryDiagnoser.Default);
        AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1));
    }
}

[Config(typeof(BenchmarkConfig))]
public class RangeIterate
{
    [Benchmark]
    public IDisposable R3()
    {
        return global::R3.Observable.Range(1, 10000).Subscribe();
    }

    [Benchmark]
    public IDisposable DotnetReactive_Immediate()
    {
        return System.Reactive.Linq.Observable.Range(1, 10000, Scheduler.Immediate).Subscribe();
    }

    [Benchmark]
    public IDisposable DotnetReactive_CurrentThread()
    {
        return System.Reactive.Linq.Observable.Range(1, 10000, Scheduler.CurrentThread).Subscribe();
    }
}

[Config(typeof(BenchmarkConfig))]
public class SubjectSubscribeDispose
{
    const int C = 10000;

    IDisposable[] disposables = default!;

    [IterationSetup]
    public void Setup()
    {
        disposables = new IDisposable[C];
    }

    [Benchmark]
    public void R3()
    {
        var subject = new global::R3.Subject<int>();
        for (int i = 0; i < C; i++)
        {
            disposables[i] = subject.Subscribe();
        }
        for (int i = 0; i < C; i++)
        {
            disposables[i].Dispose();
        }
    }

    [Benchmark]
    public void DotnetReactive()
    {
        var subject = new System.Reactive.Subjects.Subject<int>();
        for (int i = 0; i < C; i++)
        {
            disposables[i] = subject.Subscribe();
        }
        for (int i = 0; i < C; i++)
        {
            disposables[i].Dispose();
        }
    }
}



//[Config(typeof(BenchmarkConfig))]
//public class SubjectVsSlim
//{
//    const int C = 100000;

//    Subject<int> subject = new();
//    SubjectSlim<int> subjectSlim = new();

//    [IterationSetup]
//    public void Setup()
//    {
//        for (int i = 0; i < C; i++)
//        {
//            subject.Subscribe();
//        }
//        for (int i = 0; i < C; i++)
//        {
//            subjectSlim.Subscribe();
//        }
//    }

//    [Benchmark]
//    public void Subject()
//    {
//        subject.OnNext(1);
//    }

//    [Benchmark]
//    public void SubjectSlim()
//    {
//        subjectSlim.OnNext(1);
//    }
//}


//[Config(typeof(BenchmarkConfig))]
//public class SubjectVsSlim2
//{
//    const int C = 100000;

//    IDisposable[] disposables = default!;

//    [IterationSetup]
//    public void Setup()
//    {
//        disposables = new IDisposable[C];
//    }

//    [Benchmark]
//    public void Subject()
//    {
//        var subject = new global::R3.Subject<int>();
//        for (int i = 0; i < C; i++)
//        {
//            disposables[i] = subject.Subscribe();
//        }
//        for (int i = 0; i < C; i++)
//        {
//            disposables[i].Dispose();
//        }
//    }

//    [Benchmark]
//    public void SubjectSlim()
//    {
//        var subject = new global::R3.SubjectSlim<int>();
//        for (int i = 0; i < C; i++)
//        {
//            disposables[i] = subject.Subscribe();
//        }
//        for (int i = 0; i < C; i++)
//        {
//            disposables[i].Dispose();
//        }
//    }
//}



================================================
FILE: sandbox/BlazorApp1/appsettings.Development.json
================================================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}



================================================
FILE: sandbox/BlazorApp1/appsettings.json
================================================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}



================================================
FILE: sandbox/BlazorApp1/BlazorApp1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.Blazor\R3.Blazor.csproj" />
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/BlazorApp1/Program.cs
================================================
﻿using BlazorApp1.Components;
using R3;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

// Add this line
builder.Services.AddBlazorR3();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
}

app.UseStaticFiles();
app.UseAntiforgery();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();



================================================
FILE: sandbox/BlazorApp1/Components/_Imports.razor
================================================
﻿@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using BlazorApp1
@using BlazorApp1.Components



================================================
FILE: sandbox/BlazorApp1/Components/App.razor
================================================
﻿<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link rel="stylesheet" href="bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="BlazorApp1.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
</body>

</html>



================================================
FILE: sandbox/BlazorApp1/Components/Routes.razor
================================================
﻿<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(Layout.MainLayout)" />
        <FocusOnNavigate RouteData="@routeData" Selector="h1" />
    </Found>
</Router>



================================================
FILE: sandbox/BlazorApp1/Components/Layout/MainLayout.razor
================================================
﻿@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>

<div id="blazor-error-ui">
    An unhandled error has occurred.
    <a href="" class="reload">Reload</a>
    <a class="dismiss">🗙</a>
</div>



================================================
FILE: sandbox/BlazorApp1/Components/Layout/MainLayout.razor.css
================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}

#blazor-error-ui {
    background: lightyellow;
    bottom: 0;
    box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.2);
    display: none;
    left: 0;
    padding: 0.6rem 1.25rem 0.7rem 1.25rem;
    position: fixed;
    width: 100%;
    z-index: 1000;
}

    #blazor-error-ui .dismiss {
        cursor: pointer;
        position: absolute;
        right: 0.75rem;
        top: 0.5rem;
    }



================================================
FILE: sandbox/BlazorApp1/Components/Layout/NavMenu.razor
================================================
﻿<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">BlazorApp1</a>
    </div>
</div>

<input type="checkbox" title="Navigation menu" class="navbar-toggler" />

<div class="nav-scrollable" onclick="document.querySelector('.navbar-toggler').click()">
    <nav class="flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="counter">
                <span class="bi bi-plus-square-fill-nav-menu" aria-hidden="true"></span> Counter
            </NavLink>
        </div>

        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
    </nav>
</div>




================================================
FILE: sandbox/BlazorApp1/Components/Layout/NavMenu.razor.css
================================================
.navbar-toggler {
    appearance: none;
    cursor: pointer;
    width: 3.5rem;
    height: 2.5rem;
    color: white;
    position: absolute;
    top: 0.5rem;
    right: 1rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.55%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e") no-repeat center/1.75rem rgba(255, 255, 255, 0.1);
}

.navbar-toggler:checked {
    background-color: rgba(255, 255, 255, 0.5);
}

.top-row {
    height: 3.5rem;
    background-color: rgba(0,0,0,0.4);
}

.navbar-brand {
    font-size: 1.1rem;
}

.bi {
    display: inline-block;
    position: relative;
    width: 1.25rem;
    height: 1.25rem;
    margin-right: 0.75rem;
    top: -1px;
    background-size: cover;
}

.bi-house-door-fill-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-house-door-fill' viewBox='0 0 16 16'%3E%3Cpath d='M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5Z'/%3E%3C/svg%3E");
}

.bi-plus-square-fill-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-plus-square-fill' viewBox='0 0 16 16'%3E%3Cpath d='M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm6.5 4.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3a.5.5 0 0 1 1 0z'/%3E%3C/svg%3E");
}

.bi-list-nested-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-list-nested' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z'/%3E%3C/svg%3E");
}

.nav-item {
    font-size: 0.9rem;
    padding-bottom: 0.5rem;
}

    .nav-item:first-of-type {
        padding-top: 1rem;
    }

    .nav-item:last-of-type {
        padding-bottom: 1rem;
    }

    .nav-item ::deep .nav-link {
        color: #d7d7d7;
        background: none;
        border: none;
        border-radius: 4px;
        height: 3rem;
        display: flex;
        align-items: center;
        line-height: 3rem;
        width: 100%;
    }

.nav-item ::deep a.active {
    background-color: rgba(255,255,255,0.37);
    color: white;
}

.nav-item ::deep .nav-link:hover {
    background-color: rgba(255,255,255,0.1);
    color: white;
}

.nav-scrollable {
    display: none;
}

.navbar-toggler:checked ~ .nav-scrollable {
    display: block;
}

@media (min-width: 641px) {
    .navbar-toggler {
        display: none;
    }

    .nav-scrollable {
        /* Never collapse the sidebar for wide screens */
        display: block;

        /* Allow sidebar to scroll for tall menus */
        height: calc(100vh - 3.5rem);
        overflow-y: auto;
    }
}



================================================
FILE: sandbox/BlazorApp1/Components/Pages/Counter.razor
================================================
﻿@page "/counter"
@rendermode InteractiveServer
@using System.Threading;

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

@* <button class="btn btn-primary" @onclick="IncrementCount">Click me</button> *@

@code {
    // private int currentCount = 0;

    // private void IncrementCount()
    // {
    //     currentCount++;
    // }
}



================================================
FILE: sandbox/BlazorApp1/Components/Pages/Counter.razor.cs
================================================
﻿using Microsoft.AspNetCore.Components;
using R3;

namespace BlazorApp1.Components.Pages;

public partial class Counter : IDisposable
{
    int currentCount = 0;
    IDisposable? subscription;

    protected override void OnInitialized()
    {
        subscription = Observable.Interval(TimeSpan.FromSeconds(1))
            .Subscribe(_ =>
            {
                currentCount++;
                StateHasChanged();
            });
    }

    public void Dispose()
    {
        subscription?.Dispose();
    }
}



================================================
FILE: sandbox/BlazorApp1/Components/Pages/Error.razor
================================================
﻿@page "/Error"
@using System.Diagnostics

<PageTitle>Error</PageTitle>

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to <strong>Development</strong> environment will display more detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>

@code{
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? RequestId { get; set; }
    private bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    protected override void OnInitialized() =>
        RequestId = Activity.Current?.Id ?? HttpContext?.TraceIdentifier;
}



================================================
FILE: sandbox/BlazorApp1/Components/Pages/Home.razor
================================================
﻿@page "/"

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.



================================================
FILE: sandbox/BlazorApp1/Components/Pages/Weather.razor
================================================
﻿@page "/weather"
@attribute [StreamRendering]

<PageTitle>Weather</PageTitle>

<h1>Weather</h1>

<p>This component demonstrates showing data.</p>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Temp. (C)</th>
                <th>Temp. (F)</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var forecast in forecasts)
            {
                <tr>
                    <td>@forecast.Date.ToShortDateString()</td>
                    <td>@forecast.TemperatureC</td>
                    <td>@forecast.TemperatureF</td>
                    <td>@forecast.Summary</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate streaming rendering
        await Task.Delay(500);

        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        forecasts = Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }

    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}



================================================
FILE: sandbox/BlazorApp1/Properties/launchSettings.json
================================================
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
    "iisSettings": {
      "windowsAuthentication": false,
      "anonymousAuthentication": true,
      "iisExpress": {
        "applicationUrl": "http://localhost:64298",
        "sslPort": 0
      }
    },
    "profiles": {
      "http": {
        "commandName": "Project",
        "dotnetRunMessages": true,
        "launchBrowser": true,
        "applicationUrl": "http://localhost:5092",
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      },
      "IIS Express": {
        "commandName": "IISExpress",
        "launchBrowser": true,
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      }
    }
  }



================================================
FILE: sandbox/BlazorApp1/wwwroot/app.css
================================================
html, body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

a, .btn-link {
    color: #006bb7;
}

.btn-primary {
    color: #fff;
    background-color: #1b6ec2;
    border-color: #1861ac;
}

.btn:focus, .btn:active:focus, .btn-link.nav-link:focus, .form-control:focus, .form-check-input:focus {
  box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

.content {
    padding-top: 1.1rem;
}

h1:focus {
    outline: none;
}

.valid.modified:not([type=checkbox]) {
    outline: 1px solid #26b050;
}

.invalid {
    outline: 1px solid #e50000;
}

.validation-message {
    color: #e50000;
}

.blazor-error-boundary {
    background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTYiIGhlaWdodD0iNDkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIG92ZXJmbG93PSJoaWRkZW4iPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDAiPjxyZWN0IHg9IjIzNSIgeT0iNTEiIHdpZHRoPSI1NiIgaGVpZ2h0PSI0OSIvPjwvY2xpcFBhdGg+PC9kZWZzPjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMCkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzUgLTUxKSI+PHBhdGggZD0iTTI2My41MDYgNTFDMjY0LjcxNyA1MSAyNjUuODEzIDUxLjQ4MzcgMjY2LjYwNiA1Mi4yNjU4TDI2Ny4wNTIgNTIuNzk4NyAyNjcuNTM5IDUzLjYyODMgMjkwLjE4NSA5Mi4xODMxIDI5MC41NDUgOTIuNzk1IDI5MC42NTYgOTIuOTk2QzI5MC44NzcgOTMuNTEzIDI5MSA5NC4wODE1IDI5MSA5NC42NzgyIDI5MSA5Ny4wNjUxIDI4OS4wMzggOTkgMjg2LjYxNyA5OUwyNDAuMzgzIDk5QzIzNy45NjMgOTkgMjM2IDk3LjA2NTEgMjM2IDk0LjY3ODIgMjM2IDk0LjM3OTkgMjM2LjAzMSA5NC4wODg2IDIzNi4wODkgOTMuODA3MkwyMzYuMzM4IDkzLjAxNjIgMjM2Ljg1OCA5Mi4xMzE0IDI1OS40NzMgNTMuNjI5NCAyNTkuOTYxIDUyLjc5ODUgMjYwLjQwNyA1Mi4yNjU4QzI2MS4yIDUxLjQ4MzcgMjYyLjI5NiA1MSAyNjMuNTA2IDUxWk0yNjMuNTg2IDY2LjAxODNDMjYwLjczNyA2Ni4wMTgzIDI1OS4zMTMgNjcuMTI0NSAyNTkuMzEzIDY5LjMzNyAyNTkuMzEzIDY5LjYxMDIgMjU5LjMzMiA2OS44NjA4IDI1OS4zNzEgNzAuMDg4N0wyNjEuNzk1IDg0LjAxNjEgMjY1LjM4IDg0LjAxNjEgMjY3LjgyMSA2OS43NDc1QzI2Ny44NiA2OS43MzA5IDI2Ny44NzkgNjkuNTg3NyAyNjcuODc5IDY5LjMxNzkgMjY3Ljg3OSA2Ny4xMTgyIDI2Ni40NDggNjYuMDE4MyAyNjMuNTg2IDY2LjAxODNaTTI2My41NzYgODYuMDU0N0MyNjEuMDQ5IDg2LjA1NDcgMjU5Ljc4NiA4Ny4zMDA1IDI1OS43ODYgODkuNzkyMSAyNTkuNzg2IDkyLjI4MzcgMjYxLjA0OSA5My41Mjk1IDI2My41NzYgOTMuNTI5NSAyNjYuMTE2IDkzLjUyOTUgMjY3LjM4NyA5Mi4yODM3IDI2Ny4zODcgODkuNzkyMSAyNjcuMzg3IDg3LjMwMDUgMjY2LjExNiA4Ni4wNTQ3IDI2My41NzYgODYuMDU0N1oiIGZpbGw9IiNGRkU1MDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48L3N2Zz4=) no-repeat 1rem/1.8rem, #b32121;
    padding: 1rem 1rem 1rem 3.7rem;
    color: white;
}

    .blazor-error-boundary::after {
        content: "An error has occurred."
    }

.darker-border-checkbox.form-check-input {
    border-color: #929292;
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/_Imports.razor
================================================
﻿@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.AspNetCore.Components.WebAssembly.Http
@using Microsoft.JSInterop
@using BlazorWebAssemblyApp1
@using BlazorWebAssemblyApp1.Layout



================================================
FILE: sandbox/BlazorWebAssemblyApp1/App.razor
================================================
﻿<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        <FocusOnNavigate RouteData="@routeData" Selector="h1" />
    </Found>
    <NotFound>
        <PageTitle>Not found</PageTitle>
        <LayoutView Layout="@typeof(MainLayout)">
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>



================================================
FILE: sandbox/BlazorWebAssemblyApp1/BlazorWebAssemblyApp1.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.5" />
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="8.0.5" PrivateAssets="all" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.BlazorWebAssembly\R3.BlazorWebAssembly.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Program.cs
================================================
﻿using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using R3;

namespace BlazorWebAssemblyApp1;
public class Program
{
    public static async Task Main(string[] args)
    {
        var builder = WebAssemblyHostBuilder.CreateDefault(args);
        builder.RootComponents.Add<App>("#app");
        builder.RootComponents.Add<HeadOutlet>("head::after");

        builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });

        // Add this line
        builder.Services.AddBlazorWebAssemblyR3();

        await builder.Build().RunAsync();
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Layout/MainLayout.razor
================================================
﻿@inherits LayoutComponentBase
<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://learn.microsoft.com/aspnet/core/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Layout/MainLayout.razor.css
================================================
.page {
    position: relative;
    display: flex;
    flex-direction: column;
}

main {
    flex: 1;
}

.sidebar {
    background-image: linear-gradient(180deg, rgb(5, 39, 103) 0%, #3a0647 70%);
}

.top-row {
    background-color: #f7f7f7;
    border-bottom: 1px solid #d6d5d5;
    justify-content: flex-end;
    height: 3.5rem;
    display: flex;
    align-items: center;
}

    .top-row ::deep a, .top-row ::deep .btn-link {
        white-space: nowrap;
        margin-left: 1.5rem;
        text-decoration: none;
    }

    .top-row ::deep a:hover, .top-row ::deep .btn-link:hover {
        text-decoration: underline;
    }

    .top-row ::deep a:first-child {
        overflow: hidden;
        text-overflow: ellipsis;
    }

@media (max-width: 640.98px) {
    .top-row {
        justify-content: space-between;
    }

    .top-row ::deep a, .top-row ::deep .btn-link {
        margin-left: 0;
    }
}

@media (min-width: 641px) {
    .page {
        flex-direction: row;
    }

    .sidebar {
        width: 250px;
        height: 100vh;
        position: sticky;
        top: 0;
    }

    .top-row {
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .top-row.auth ::deep a:first-child {
        flex: 1;
        text-align: right;
        width: 0;
    }

    .top-row, article {
        padding-left: 2rem !important;
        padding-right: 1.5rem !important;
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Layout/NavMenu.razor
================================================
﻿<div class="top-row ps-3 navbar navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="">BlazorWebAssemblyApp1</a>
        <button title="Navigation menu" class="navbar-toggler" @onclick="ToggleNavMenu">
            <span class="navbar-toggler-icon"></span>
        </button>
    </div>
</div>

<div class="@NavMenuCssClass nav-scrollable" @onclick="ToggleNavMenu">
    <nav class="flex-column">
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="" Match="NavLinkMatch.All">
                <span class="bi bi-house-door-fill-nav-menu" aria-hidden="true"></span> Home
            </NavLink>
        </div>
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="counter">
                <span class="bi bi-plus-square-fill-nav-menu" aria-hidden="true"></span> Counter
            </NavLink>
        </div>
        <div class="nav-item px-3">
            <NavLink class="nav-link" href="weather">
                <span class="bi bi-list-nested-nav-menu" aria-hidden="true"></span> Weather
            </NavLink>
        </div>
    </nav>
</div>

@code {
    private bool collapseNavMenu = true;

    private string? NavMenuCssClass => collapseNavMenu ? "collapse" : null;

    private void ToggleNavMenu()
    {
        collapseNavMenu = !collapseNavMenu;
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Layout/NavMenu.razor.css
================================================
.navbar-toggler {
    background-color: rgba(255, 255, 255, 0.1);
}

.top-row {
    height: 3.5rem;
    background-color: rgba(0,0,0,0.4);
}

.navbar-brand {
    font-size: 1.1rem;
}

.bi {
    display: inline-block;
    position: relative;
    width: 1.25rem;
    height: 1.25rem;
    margin-right: 0.75rem;
    top: -1px;
    background-size: cover;
}

.bi-house-door-fill-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-house-door-fill' viewBox='0 0 16 16'%3E%3Cpath d='M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5Z'/%3E%3C/svg%3E");
}

.bi-plus-square-fill-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-plus-square-fill' viewBox='0 0 16 16'%3E%3Cpath d='M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm6.5 4.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3a.5.5 0 0 1 1 0z'/%3E%3C/svg%3E");
}

.bi-list-nested-nav-menu {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='white' class='bi bi-list-nested' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z'/%3E%3C/svg%3E");
}

.nav-item {
    font-size: 0.9rem;
    padding-bottom: 0.5rem;
}

    .nav-item:first-of-type {
        padding-top: 1rem;
    }

    .nav-item:last-of-type {
        padding-bottom: 1rem;
    }

    .nav-item ::deep a {
        color: #d7d7d7;
        border-radius: 4px;
        height: 3rem;
        display: flex;
        align-items: center;
        line-height: 3rem;
    }

.nav-item ::deep a.active {
    background-color: rgba(255,255,255,0.37);
    color: white;
}

.nav-item ::deep a:hover {
    background-color: rgba(255,255,255,0.1);
    color: white;
}

@media (min-width: 641px) {
    .navbar-toggler {
        display: none;
    }

    .collapse {
        /* Never collapse the sidebar for wide screens */
        display: block;
    }
    
    .nav-scrollable {
        /* Allow sidebar to scroll for tall menus */
        height: calc(100vh - 3.5rem);
        overflow-y: auto;
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Pages/Counter.razor
================================================
﻿@page "/counter"

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

@* <button class="btn btn-primary" @onclick="IncrementCount">Click me</button> *@

@code {
	// private int currentCount = 0;

	// private void IncrementCount()
	// {
	//     currentCount++;
		// }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Pages/Counter.razor.cs
================================================
﻿using R3;

namespace BlazorWebAssemblyApp1.Pages;

public partial class Counter : IDisposable
{
    int currentCount = 0;
    IDisposable? subscription;

    protected override void OnInitialized()
    {
        subscription = Observable.Interval(TimeSpan.FromSeconds(1))
            .Subscribe(_ =>
            {
                currentCount++;
                StateHasChanged();
            });
    }

    public void Dispose()
    {
        subscription?.Dispose();
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Pages/Home.razor
================================================
﻿@page "/"

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Pages/Weather.razor
================================================
﻿@page "/weather"
@inject HttpClient Http

<PageTitle>Weather</PageTitle>

<h1>Weather</h1>

<p>This component demonstrates fetching data from the server.</p>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Temp. (C)</th>
                <th>Temp. (F)</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var forecast in forecasts)
            {
                <tr>
                    <td>@forecast.Date.ToShortDateString()</td>
                    <td>@forecast.TemperatureC</td>
                    <td>@forecast.TemperatureF</td>
                    <td>@forecast.Summary</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        forecasts = await Http.GetFromJsonAsync<WeatherForecast[]>("sample-data/weather.json");
    }

    public class WeatherForecast
    {
        public DateOnly Date { get; set; }

        public int TemperatureC { get; set; }

        public string? Summary { get; set; }

        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/Properties/launchSettings.json
================================================
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:33901",
      "sslPort": 0
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "applicationUrl": "http://localhost:5055",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/wwwroot/index.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlazorWebAssemblyApp1</title>
    <base href="/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="BlazorWebAssemblyApp1.styles.css" rel="stylesheet" />
</head>

<body>
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>
    <script src="_framework/blazor.webassembly.js"></script>
</body>

</html>



================================================
FILE: sandbox/BlazorWebAssemblyApp1/wwwroot/css/app.css
================================================
html, body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

h1:focus {
    outline: none;
}

a, .btn-link {
    color: #0071c1;
}

.btn-primary {
    color: #fff;
    background-color: #1b6ec2;
    border-color: #1861ac;
}

.btn:focus, .btn:active:focus, .btn-link.nav-link:focus, .form-control:focus, .form-check-input:focus {
  box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

.content {
    padding-top: 1.1rem;
}

.valid.modified:not([type=checkbox]) {
    outline: 1px solid #26b050;
}

.invalid {
    outline: 1px solid red;
}

.validation-message {
    color: red;
}

#blazor-error-ui {
    background: lightyellow;
    bottom: 0;
    box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.2);
    display: none;
    left: 0;
    padding: 0.6rem 1.25rem 0.7rem 1.25rem;
    position: fixed;
    width: 100%;
    z-index: 1000;
}

    #blazor-error-ui .dismiss {
        cursor: pointer;
        position: absolute;
        right: 0.75rem;
        top: 0.5rem;
    }

.blazor-error-boundary {
    background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTYiIGhlaWdodD0iNDkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIG92ZXJmbG93PSJoaWRkZW4iPjxkZWZzPjxjbGlwUGF0aCBpZD0iY2xpcDAiPjxyZWN0IHg9IjIzNSIgeT0iNTEiIHdpZHRoPSI1NiIgaGVpZ2h0PSI0OSIvPjwvY2xpcFBhdGg+PC9kZWZzPjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMCkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMzUgLTUxKSI+PHBhdGggZD0iTTI2My41MDYgNTFDMjY0LjcxNyA1MSAyNjUuODEzIDUxLjQ4MzcgMjY2LjYwNiA1Mi4yNjU4TDI2Ny4wNTIgNTIuNzk4NyAyNjcuNTM5IDUzLjYyODMgMjkwLjE4NSA5Mi4xODMxIDI5MC41NDUgOTIuNzk1IDI5MC42NTYgOTIuOTk2QzI5MC44NzcgOTMuNTEzIDI5MSA5NC4wODE1IDI5MSA5NC42NzgyIDI5MSA5Ny4wNjUxIDI4OS4wMzggOTkgMjg2LjYxNyA5OUwyNDAuMzgzIDk5QzIzNy45NjMgOTkgMjM2IDk3LjA2NTEgMjM2IDk0LjY3ODIgMjM2IDk0LjM3OTkgMjM2LjAzMSA5NC4wODg2IDIzNi4wODkgOTMuODA3MkwyMzYuMzM4IDkzLjAxNjIgMjM2Ljg1OCA5Mi4xMzE0IDI1OS40NzMgNTMuNjI5NCAyNTkuOTYxIDUyLjc5ODUgMjYwLjQwNyA1Mi4yNjU4QzI2MS4yIDUxLjQ4MzcgMjYyLjI5NiA1MSAyNjMuNTA2IDUxWk0yNjMuNTg2IDY2LjAxODNDMjYwLjczNyA2Ni4wMTgzIDI1OS4zMTMgNjcuMTI0NSAyNTkuMzEzIDY5LjMzNyAyNTkuMzEzIDY5LjYxMDIgMjU5LjMzMiA2OS44NjA4IDI1OS4zNzEgNzAuMDg4N0wyNjEuNzk1IDg0LjAxNjEgMjY1LjM4IDg0LjAxNjEgMjY3LjgyMSA2OS43NDc1QzI2Ny44NiA2OS43MzA5IDI2Ny44NzkgNjkuNTg3NyAyNjcuODc5IDY5LjMxNzkgMjY3Ljg3OSA2Ny4xMTgyIDI2Ni40NDggNjYuMDE4MyAyNjMuNTg2IDY2LjAxODNaTTI2My41NzYgODYuMDU0N0MyNjEuMDQ5IDg2LjA1NDcgMjU5Ljc4NiA4Ny4zMDA1IDI1OS43ODYgODkuNzkyMSAyNTkuNzg2IDkyLjI4MzcgMjYxLjA0OSA5My41Mjk1IDI2My41NzYgOTMuNTI5NSAyNjYuMTE2IDkzLjUyOTUgMjY3LjM4NyA5Mi4yODM3IDI2Ny4zODcgODkuNzkyMSAyNjcuMzg3IDg3LjMwMDUgMjY2LjExNiA4Ni4wNTQ3IDI2My41NzYgODYuMDU0N1oiIGZpbGw9IiNGRkU1MDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48L3N2Zz4=) no-repeat 1rem/1.8rem, #b32121;
    padding: 1rem 1rem 1rem 3.7rem;
    color: white;
}

    .blazor-error-boundary::after {
        content: "An error has occurred."
    }

.loading-progress {
    position: relative;
    display: block;
    width: 8rem;
    height: 8rem;
    margin: 20vh auto 1rem auto;
}

    .loading-progress circle {
        fill: none;
        stroke: #e0e0e0;
        stroke-width: 0.6rem;
        transform-origin: 50% 50%;
        transform: rotate(-90deg);
    }

        .loading-progress circle:last-child {
            stroke: #1b6ec2;
            stroke-dasharray: calc(3.141 * var(--blazor-load-percentage, 0%) * 0.8), 500%;
            transition: stroke-dasharray 0.05s ease-in-out;
        }

.loading-progress-text {
    position: absolute;
    text-align: center;
    font-weight: bold;
    inset: calc(20vh + 3.25rem) 0 auto 0.2rem;
}

    .loading-progress-text:after {
        content: var(--blazor-load-percentage-text, "Loading");
    }

code {
    color: #c02d76;
}



================================================
FILE: sandbox/BlazorWebAssemblyApp1/wwwroot/sample-data/weather.json
================================================
﻿[
  {
    "date": "2022-01-06",
    "temperatureC": 1,
    "summary": "Freezing"
  },
  {
    "date": "2022-01-07",
    "temperatureC": 14,
    "summary": "Bracing"
  },
  {
    "date": "2022-01-08",
    "temperatureC": -13,
    "summary": "Freezing"
  },
  {
    "date": "2022-01-09",
    "temperatureC": -16,
    "summary": "Balmy"
  },
  {
    "date": "2022-01-10",
    "temperatureC": -2,
    "summary": "Chilly"
  }
]



================================================
FILE: sandbox/ConsoleApp1/ConsoleApp1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
        <PackageReference Include="Microsoft.Extensions.TimeProvider.Testing" Version="8.0.0" />
        <PackageReference Include="System.Linq.Async" Version="6.0.1" />
        <PackageReference Include="System.Reactive.Linq" Version="6.0.0" />
        <PackageReference Include="ZLogger" Version="2.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/ConsoleApp1/Program.cs
================================================
﻿//using R3;
//using System.Reactive.Linq;
using System.Diagnostics;
using System.Threading.Channels;
using System.Xml.Serialization;
using R3;


// Observable.Range(1,10).MinBy(
// Enumerable.Range(1,10).MinBy(

var subject = new Subject<string>();

var x = subject!.ToReadOnlyBindableReactiveProperty().EnableValidation(x =>
{
    return string.IsNullOrEmpty(x) ? new InvalidDataException("Invalid X") : null;
}).ForceValidate();

x.HasErrors.Dump("After initialized");  // (1) False

//x.Value = string.Empty;
//x.HasErrors.Dump("Assign empty");  // (2) True

//x.Value = "xx";
//x.HasErrors.Dump("Assign not null");  // (3) False


public static class Ext
{
    public static void Dump(this object o, string msg)
    {
        Console.WriteLine(o + ":" + msg);
    }
}



================================================
FILE: sandbox/MauiApp1/App.xaml
================================================
﻿<?xml version = "1.0" encoding = "UTF-8" ?>
<Application xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:local="clr-namespace:MauiApp1"
             x:Class="MauiApp1.App">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Resources/Styles/Colors.xaml" />
                <ResourceDictionary Source="Resources/Styles/Styles.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>



================================================
FILE: sandbox/MauiApp1/App.xaml.cs
================================================
﻿using R3;

namespace MauiApp1;

public partial class App : Application
{
    public App()
    {
        InitializeComponent();

        MainPage = new AppShell();
    }
}



================================================
FILE: sandbox/MauiApp1/AppShell.xaml
================================================
<?xml version="1.0" encoding="UTF-8" ?>
<Shell
    x:Class="MauiApp1.AppShell"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:local="clr-namespace:MauiApp1"
    Shell.FlyoutBehavior="Disabled"
    Title="MauiApp1">

    <ShellContent
        Title="Home"
        ContentTemplate="{DataTemplate local:MainPage}"
        Route="MainPage" />

</Shell>



================================================
FILE: sandbox/MauiApp1/AppShell.xaml.cs
================================================
﻿namespace MauiApp1;

public partial class AppShell : Shell
{
    public AppShell()
    {
        InitializeComponent();
    }
}



================================================
FILE: sandbox/MauiApp1/MainPage.xaml
================================================
﻿<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="MauiApp1.MainPage">

    <ScrollView>
        <VerticalStackLayout
            Padding="30,0"
            Spacing="25">
            <Image
                Source="dotnet_bot.png"
                HeightRequest="185"
                Aspect="AspectFit"
                SemanticProperties.Description="dot net bot in a race car number eight" />

            <Label
                x:Name="Label1"
                Text="Hello, World!"
                Style="{StaticResource Headline}"
                SemanticProperties.HeadingLevel="Level1" />

            <Label
                x:Name="Label2"
                Text="Welcome to &#10;.NET Multi-platform App UI"
                Style="{StaticResource SubHeadline}"
                SemanticProperties.HeadingLevel="Level2"
                SemanticProperties.Description="Welcome to dot net Multi platform App U I" />

            <Label Text="Input" />
            <Entry Text="{Binding Input.Value}" />

            <Label Text="Output" />
            <Entry Text="{Binding Output.Value}" />

            <Button
                x:Name="CounterBtn"
                Text="Click me"
                SemanticProperties.Hint="Counts the number of times you click"
                Clicked="OnCounterClicked"
                HorizontalOptions="Fill" />
        </VerticalStackLayout>
    </ScrollView>

</ContentPage>



================================================
FILE: sandbox/MauiApp1/MainPage.xaml.cs
================================================
﻿using R3;

namespace MauiApp1;

public class BasicUsagesViewModel : IDisposable
{
    public BindableReactiveProperty<string> Input { get; }
    public BindableReactiveProperty<string> Output { get; }

    public BasicUsagesViewModel()
    {
        Input = new BindableReactiveProperty<string>("");
        Output = Input.Select(x => x.ToUpper()).ToBindableReactiveProperty("");
    }

    public void Dispose()
    {
        Disposable.Dispose(Input, Output);
    }
}

public partial class MainPage : ContentPage
{
    int count = 0;

    public MainPage()
    {
        InitializeComponent();

        var startDate = DateTime.Now;
        Observable.Interval(TimeSpan.FromMilliseconds(500))
            .Subscribe(x =>
            {
                throw new InvalidOperationException("oppeke");
                // Label1.Text = $"Timer: {(DateTime.Now - startDate).TotalMilliseconds}";
            });

        var frameCount = 0;
        Observable.IntervalFrame(1)
            .Subscribe(x =>
            {
                Label2.Text = $"Frame: {frameCount++}";
            });

        this.Loaded += (sender, args) =>
        {
            var viewModel = new BasicUsagesViewModel();
            BindingContext = viewModel;
        };
    }

    void OnCounterClicked(object sender, EventArgs e)
    {
        count++;

        if (count == 1)
            CounterBtn.Text = $"Clicked {count} time";
        else
            CounterBtn.Text = $"Clicked {count} times";

        SemanticScreenReader.Announce(CounterBtn.Text);
    }
}



================================================
FILE: sandbox/MauiApp1/MauiApp1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <!--<TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('linux'))">$(TargetFrameworks);net8.0-android</TargetFrameworks>-->
        <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('macos'))">$(TargetFrameworks);net8.0-maccatalyst</TargetFrameworks>
        <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(TargetFrameworks);net8.0-windows10.0.19041.0</TargetFrameworks>
        <!-- Uncomment to also build the tizen app. You will need to install tizen by following this: https://github.com/Samsung/Tizen.NET -->
        <!-- <TargetFrameworks>$(TargetFrameworks);net8.0-tizen</TargetFrameworks> -->

        <!-- Note for MacCatalyst:
        The default runtime is maccatalyst-x64, except in Release config, in which case the default is maccatalyst-x64;maccatalyst-arm64.
        When specifying both architectures, use the plural <RuntimeIdentifiers> instead of the singular <RuntimeIdentifier>.
        The Mac App Store will NOT accept apps with ONLY maccatalyst-arm64 indicated;
        either BOTH runtimes must be indicated or ONLY macatalyst-x64. -->
        <!-- For example: <RuntimeIdentifiers>maccatalyst-x64;maccatalyst-arm64</RuntimeIdentifiers> -->

        <OutputType>Exe</OutputType>
        <RootNamespace>MauiApp1</RootNamespace>
        <UseMaui>true</UseMaui>
        <SingleProject>true</SingleProject>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <!-- Display name -->
        <ApplicationTitle>MauiApp1</ApplicationTitle>

        <!-- App Identifier -->
        <ApplicationId>com.companyname.mauiapp1</ApplicationId>

        <!-- Versions -->
        <ApplicationDisplayVersion>1.0</ApplicationDisplayVersion>
        <ApplicationVersion>1</ApplicationVersion>

        <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'ios'">11.0</SupportedOSPlatformVersion>
        <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'maccatalyst'">13.1</SupportedOSPlatformVersion>
        <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'android'">21.0</SupportedOSPlatformVersion>
        <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.17763.0</SupportedOSPlatformVersion>
        <TargetPlatformMinVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'windows'">10.0.17763.0</TargetPlatformMinVersion>
        <SupportedOSPlatformVersion Condition="$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)')) == 'tizen'">6.5</SupportedOSPlatformVersion>
    </PropertyGroup>

    <ItemGroup>
        <!-- App Icon -->
        <MauiIcon Include="Resources\AppIcon\appicon.svg" ForegroundFile="Resources\AppIcon\appiconfg.svg" Color="#512BD4"/>

        <!-- Splash Screen -->
        <MauiSplashScreen Include="Resources\Splash\splash.svg" Color="#512BD4" BaseSize="128,128"/>

        <!-- Images -->
        <MauiImage Include="Resources\Images\*"/>
        <MauiImage Update="Resources\Images\dotnet_bot.png" Resize="True" BaseSize="300,185"/>

        <!-- Custom Fonts -->
        <MauiFont Include="Resources\Fonts\*"/>

        <!-- Raw Assets (also remove the "Resources\Raw" prefix) -->
        <MauiAsset Include="Resources\Raw\**" LogicalName="%(RecursiveDir)%(Filename)%(Extension)"/>
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.Maui.Controls" Version="$(MauiVersion)"/>
        <PackageReference Include="Microsoft.Maui.Controls.Compatibility" Version="$(MauiVersion)"/>
        <PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.0"/>
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\src\R3.Maui\R3.Maui.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/MauiApp1/MauiProgram.cs
================================================
﻿using Microsoft.Extensions.Logging;
using R3.Maui;

namespace MauiApp1;

public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();
        builder
            .UseMauiApp<App>()
            .ConfigureFonts(fonts =>
            {
                fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
            })
            .UseR3();

#if DEBUG
        builder.Logging.AddDebug();
#endif

        return builder.Build();
    }
}



================================================
FILE: sandbox/MauiApp1/Platforms/Android/AndroidManifest.xml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
	<application android:allowBackup="true" android:icon="@mipmap/appicon" android:roundIcon="@mipmap/appicon_round" android:supportsRtl="true"></application>
	<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
	<uses-permission android:name="android.permission.INTERNET" />
</manifest>


================================================
FILE: sandbox/MauiApp1/Platforms/Android/MainActivity.cs
================================================
﻿using Android.App;
using Android.Content.PM;
using Android.OS;

namespace MauiApp1;

[Activity(Theme = "@style/Maui.SplashTheme", MainLauncher = true,
    ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation | ConfigChanges.UiMode |
                           ConfigChanges.ScreenLayout | ConfigChanges.SmallestScreenSize | ConfigChanges.Density)]
public class MainActivity : MauiAppCompatActivity
{
}



================================================
FILE: sandbox/MauiApp1/Platforms/Android/MainApplication.cs
================================================
﻿using Android.App;
using Android.Runtime;

namespace MauiApp1;

[Application]
public class MainApplication : MauiApplication
{
    public MainApplication(IntPtr handle, JniHandleOwnership ownership)
        : base(handle, ownership)
    {
    }

    protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}



================================================
FILE: sandbox/MauiApp1/Platforms/Android/Resources/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#512BD4</color>
    <color name="colorPrimaryDark">#2B0B98</color>
    <color name="colorAccent">#2B0B98</color>
</resources>


================================================
FILE: sandbox/MauiApp1/Platforms/iOS/AppDelegate.cs
================================================
﻿using Foundation;

namespace MauiApp1;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
    protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}



================================================
FILE: sandbox/MauiApp1/Platforms/iOS/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIDeviceFamily</key>
	<array>
		<integer>1</integer>
		<integer>2</integer>
	</array>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>XSAppIconAssets</key>
	<string>Assets.xcassets/appicon.appiconset</string>
</dict>
</plist>



================================================
FILE: sandbox/MauiApp1/Platforms/iOS/Program.cs
================================================
﻿using ObjCRuntime;
using UIKit;

namespace MauiApp1;

public class Program
{
    // This is the main entry point of the application.
    static void Main(string[] args)
    {
        // if you want to use a different Application Delegate class from "AppDelegate"
        // you can specify it here.
        UIApplication.Main(args, null, typeof(AppDelegate));
    }
}



================================================
FILE: sandbox/MauiApp1/Platforms/MacCatalyst/AppDelegate.cs
================================================
﻿using Foundation;

namespace MauiApp1;

[Register("AppDelegate")]
public class AppDelegate : MauiUIApplicationDelegate
{
    protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}



================================================
FILE: sandbox/MauiApp1/Platforms/MacCatalyst/Entitlements.plist
================================================
﻿<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <!-- See https://aka.ms/maui-publish-app-store#add-entitlements for more information about adding entitlements.-->
    <dict>
        <!-- App Sandbox must be enabled to distribute a MacCatalyst app through the Mac App Store. -->
        <key>com.apple.security.app-sandbox</key>
        <true/>
        <!-- When App Sandbox is enabled, this value is required to open outgoing network connections. -->
        <key>com.apple.security.network.client</key>
        <true/>
    </dict>
</plist>




================================================
FILE: sandbox/MauiApp1/Platforms/MacCatalyst/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- The Mac App Store requires you specify if the app uses encryption. -->
    <!-- Please consult https://developer.apple.com/documentation/bundleresources/information_property_list/itsappusesnonexemptencryption -->
    <!-- <key>ITSAppUsesNonExemptEncryption</key> -->
    <!-- Please indicate <true/> or <false/> here. -->

    <!-- Specify the category for your app here. -->
    <!-- Please consult https://developer.apple.com/documentation/bundleresources/information_property_list/lsapplicationcategorytype -->
    <!-- <key>LSApplicationCategoryType</key> -->
    <!-- <string>public.app-category.YOUR-CATEGORY-HERE</string> -->
	<key>UIDeviceFamily</key>
	<array>
		<integer>2</integer>
	</array>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>XSAppIconAssets</key>
	<string>Assets.xcassets/appicon.appiconset</string>
</dict>
</plist>



================================================
FILE: sandbox/MauiApp1/Platforms/MacCatalyst/Program.cs
================================================
﻿using ObjCRuntime;
using UIKit;

namespace MauiApp1;

public class Program
{
    // This is the main entry point of the application.
    static void Main(string[] args)
    {
        // if you want to use a different Application Delegate class from "AppDelegate"
        // you can specify it here.
        UIApplication.Main(args, null, typeof(AppDelegate));
    }
}



================================================
FILE: sandbox/MauiApp1/Platforms/Tizen/Main.cs
================================================
using System;
using Microsoft.Maui;
using Microsoft.Maui.Hosting;

namespace MauiApp1;

class Program : MauiApplication
{
    protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();

    static void Main(string[] args)
    {
        var app = new Program();
        app.Run(args);
    }
}



================================================
FILE: sandbox/MauiApp1/Platforms/Tizen/tizen-manifest.xml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<manifest package="maui-application-id-placeholder" version="0.0.0" api-version="7" xmlns="http://tizen.org/ns/packages">
  <profile name="common" />
  <ui-application appid="maui-application-id-placeholder" exec="MauiApp1.dll" multiple="false" nodisplay="false" taskmanage="true" type="dotnet" launch_mode="single">
    <label>maui-application-title-placeholder</label>
    <icon>maui-appicon-placeholder</icon>
    <metadata key="http://tizen.org/metadata/prefer_dotnet_aot" value="true" />
  </ui-application>
  <shortcut-list />
  <privileges>
    <privilege>http://tizen.org/privilege/internet</privilege>
  </privileges> 
  <dependencies />
  <provides-appdefined-privileges />
</manifest>


================================================
FILE: sandbox/MauiApp1/Platforms/Windows/app.manifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MauiApp1.WinUI.app"/>

  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <!-- The combination of below two tags have the following effect:
           1) Per-Monitor for >= Windows 10 Anniversary Update
           2) System < Windows 10 Anniversary Update
      -->
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/PM</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2, PerMonitor</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>



================================================
FILE: sandbox/MauiApp1/Platforms/Windows/App.xaml
================================================
﻿<maui:MauiWinUIApplication
    x:Class="MauiApp1.WinUI.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:maui="using:Microsoft.Maui"
    xmlns:local="using:MauiApp1.WinUI">

</maui:MauiWinUIApplication>



================================================
FILE: sandbox/MauiApp1/Platforms/Windows/App.xaml.cs
================================================
﻿using Microsoft.UI.Xaml;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace MauiApp1.WinUI;

/// <summary>
/// Provides application-specific behavior to supplement the default Application class.
/// </summary>
public partial class App : MauiWinUIApplication
{
    /// <summary>
    /// Initializes the singleton application object.  This is the first line of authored code
    /// executed, and as such is the logical equivalent of main() or WinMain().
    /// </summary>
    public App()
    {
        this.InitializeComponent();
    }

    protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
}



================================================
FILE: sandbox/MauiApp1/Platforms/Windows/Package.appxmanifest
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">

  <Identity Name="maui-package-name-placeholder" Publisher="CN=User Name" Version="0.0.0.0" />

  <mp:PhoneIdentity PhoneProductId="818CB067-5B2D-41F2-B6D3-516225772130" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>$placeholder$</DisplayName>
    <PublisherDisplayName>User Name</PublisherDisplayName>
    <Logo>$placeholder$.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate" />
  </Resources>

  <Applications>
    <Application Id="App" Executable="$targetnametoken$.exe" EntryPoint="$targetentrypoint$">
      <uap:VisualElements
        DisplayName="$placeholder$"
        Description="$placeholder$"
        Square150x150Logo="$placeholder$.png"
        Square44x44Logo="$placeholder$.png"
        BackgroundColor="transparent">
        <uap:DefaultTile Square71x71Logo="$placeholder$.png" Wide310x150Logo="$placeholder$.png" Square310x310Logo="$placeholder$.png" />
        <uap:SplashScreen Image="$placeholder$.png" />
      </uap:VisualElements>
    </Application>
  </Applications>

  <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>

</Package>



================================================
FILE: sandbox/MauiApp1/Properties/launchSettings.json
================================================
{
  "profiles": {
    "Windows Machine": {
      "commandName": "MsixPackage",
      "nativeDebugging": false
    }
  }
}


================================================
FILE: sandbox/MauiApp1/Resources/Raw/AboutAssets.txt
================================================
﻿Any raw assets you want to be deployed with your application can be placed in
this directory (and child directories). Deployment of the asset to your application
is automatically handled by the following `MauiAsset` Build Action within your `.csproj`.

	<MauiAsset Include="Resources\Raw\**" LogicalName="%(RecursiveDir)%(Filename)%(Extension)" />

These files will be deployed with you package and will be accessible using Essentials:

	async Task LoadMauiAsset()
	{
		using var stream = await FileSystem.OpenAppPackageFileAsync("AboutAssets.txt");
		using var reader = new StreamReader(stream);

		var contents = reader.ReadToEnd();
	}



================================================
FILE: sandbox/MauiApp1/Resources/Styles/Colors.xaml
================================================
﻿<?xml version="1.0" encoding="UTF-8" ?>
<?xaml-comp compile="true" ?>
<ResourceDictionary 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">

    <!-- Note: For Android please see also Platforms\Android\Resources\values\colors.xml -->

    <Color x:Key="Primary">#512BD4</Color>
    <Color x:Key="PrimaryDark">#ac99ea</Color>
    <Color x:Key="PrimaryDarkText">#242424</Color>
    <Color x:Key="Secondary">#DFD8F7</Color>
    <Color x:Key="SecondaryDarkText">#9880e5</Color>
    <Color x:Key="Tertiary">#2B0B98</Color>

    <Color x:Key="White">White</Color>
    <Color x:Key="Black">Black</Color>
    <Color x:Key="Magenta">#D600AA</Color>
    <Color x:Key="MidnightBlue">#190649</Color>
    <Color x:Key="OffBlack">#1f1f1f</Color>

    <Color x:Key="Gray100">#E1E1E1</Color>
    <Color x:Key="Gray200">#C8C8C8</Color>
    <Color x:Key="Gray300">#ACACAC</Color>
    <Color x:Key="Gray400">#919191</Color>
    <Color x:Key="Gray500">#6E6E6E</Color>
    <Color x:Key="Gray600">#404040</Color>
    <Color x:Key="Gray900">#212121</Color>
    <Color x:Key="Gray950">#141414</Color>

    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource Primary}"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="{StaticResource Secondary}"/>
    <SolidColorBrush x:Key="TertiaryBrush" Color="{StaticResource Tertiary}"/>
    <SolidColorBrush x:Key="WhiteBrush" Color="{StaticResource White}"/>
    <SolidColorBrush x:Key="BlackBrush" Color="{StaticResource Black}"/>

    <SolidColorBrush x:Key="Gray100Brush" Color="{StaticResource Gray100}"/>
    <SolidColorBrush x:Key="Gray200Brush" Color="{StaticResource Gray200}"/>
    <SolidColorBrush x:Key="Gray300Brush" Color="{StaticResource Gray300}"/>
    <SolidColorBrush x:Key="Gray400Brush" Color="{StaticResource Gray400}"/>
    <SolidColorBrush x:Key="Gray500Brush" Color="{StaticResource Gray500}"/>
    <SolidColorBrush x:Key="Gray600Brush" Color="{StaticResource Gray600}"/>
    <SolidColorBrush x:Key="Gray900Brush" Color="{StaticResource Gray900}"/>
    <SolidColorBrush x:Key="Gray950Brush" Color="{StaticResource Gray950}"/>
</ResourceDictionary>


================================================
FILE: sandbox/MauiApp1/Resources/Styles/Styles.xaml
================================================
﻿<?xml version="1.0" encoding="UTF-8" ?>
<?xaml-comp compile="true" ?>
<ResourceDictionary 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">

    <Style TargetType="ActivityIndicator">
        <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="IndicatorView">
        <Setter Property="IndicatorColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}"/>
        <Setter Property="SelectedIndicatorColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray100}}"/>
    </Style>

    <Style TargetType="Border">
        <Setter Property="Stroke" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="StrokeShape" Value="Rectangle"/>
        <Setter Property="StrokeThickness" Value="1"/>
    </Style>

    <Style TargetType="BoxView">
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="Button">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource PrimaryDarkText}}" />
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource PrimaryDark}}" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="BorderWidth" Value="0"/>
        <Setter Property="CornerRadius" Value="8"/>
        <Setter Property="Padding" Value="14,10"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
                            <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="PointerOver" />
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="CheckBox">
        <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="Color" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="DatePicker">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Editor">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14" />
        <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Entry">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14" />
        <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Frame">
        <Setter Property="HasShadow" Value="False" />
        <Setter Property="BorderColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="CornerRadius" Value="8" />
    </Style>

    <Style TargetType="ImageButton">
        <Setter Property="Opacity" Value="1" />
        <Setter Property="BorderColor" Value="Transparent"/>
        <Setter Property="BorderWidth" Value="0"/>
        <Setter Property="CornerRadius" Value="0"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="Opacity" Value="0.5" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="PointerOver" />
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Label">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Span">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="Label" x:Key="Headline">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource MidnightBlue}, Dark={StaticResource White}}" />
        <Setter Property="FontSize" Value="32" />
        <Setter Property="HorizontalOptions" Value="Center" />
        <Setter Property="HorizontalTextAlignment" Value="Center" />
    </Style>

    <Style TargetType="Label" x:Key="SubHeadline">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource MidnightBlue}, Dark={StaticResource White}}" />
        <Setter Property="FontSize" Value="24" />
        <Setter Property="HorizontalOptions" Value="Center" />
        <Setter Property="HorizontalTextAlignment" Value="Center" />
    </Style>

    <Style TargetType="ListView">
        <Setter Property="SeparatorColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray500}}" />
        <Setter Property="RefreshControlColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="Picker">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="TitleColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="TitleColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="ProgressBar">
        <Setter Property="ProgressColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="ProgressColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="RadioButton">
        <Setter Property="BackgroundColor" Value="Transparent"/>
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource White}}" />
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="RefreshView">
        <Setter Property="RefreshColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="SearchBar">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="PlaceholderColor" Value="{StaticResource Gray500}" />
        <Setter Property="CancelButtonColor" Value="{StaticResource Gray500}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="SearchHandler">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="PlaceholderColor" Value="{StaticResource Gray500}" />
        <Setter Property="BackgroundColor" Value="Transparent" />
        <Setter Property="FontFamily" Value="OpenSansRegular" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="PlaceholderColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Shadow">
        <Setter Property="Radius" Value="15" />
        <Setter Property="Opacity" Value="0.5" />
        <Setter Property="Brush" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource White}}" />
        <Setter Property="Offset" Value="10,10" />
    </Style>

    <Style TargetType="Slider">
        <Setter Property="MinimumTrackColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="MaximumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray600}}" />
        <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="MinimumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                            <Setter Property="MaximumTrackColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}"/>
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="SwipeItem">
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Black}}" />
    </Style>

    <Style TargetType="Switch">
        <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
        <Setter Property="ThumbColor" Value="{StaticResource White}" />
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="On">
                        <VisualState.Setters>
                            <Setter Property="OnColor" Value="{AppThemeBinding Light={StaticResource Secondary}, Dark={StaticResource Gray200}}" />
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource White}}" />
                        </VisualState.Setters>
                    </VisualState>
                    <VisualState x:Name="Off">
                        <VisualState.Setters>
                            <Setter Property="ThumbColor" Value="{AppThemeBinding Light={StaticResource Gray400}, Dark={StaticResource Gray500}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="TimePicker">
        <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource White}}" />
        <Setter Property="BackgroundColor" Value="Transparent"/>
        <Setter Property="FontFamily" Value="OpenSansRegular"/>
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="MinimumHeightRequest" Value="44"/>
        <Setter Property="MinimumWidthRequest" Value="44"/>
        <Setter Property="VisualStateManager.VisualStateGroups">
            <VisualStateGroupList>
                <VisualStateGroup x:Name="CommonStates">
                    <VisualState x:Name="Normal" />
                    <VisualState x:Name="Disabled">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="{AppThemeBinding Light={StaticResource Gray300}, Dark={StaticResource Gray600}}" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateGroupList>
        </Setter>
    </Style>

    <Style TargetType="Page" ApplyToDerivedTypes="True">
        <Setter Property="Padding" Value="0"/>
        <Setter Property="BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
    </Style>

    <Style TargetType="Shell" ApplyToDerivedTypes="True">
        <Setter Property="Shell.BackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
        <Setter Property="Shell.ForegroundColor" Value="{OnPlatform WinUI={StaticResource Primary}, Default={StaticResource White}}" />
        <Setter Property="Shell.TitleColor" Value="{AppThemeBinding Light={StaticResource Black}, Dark={StaticResource SecondaryDarkText}}" />
        <Setter Property="Shell.DisabledColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="Shell.UnselectedColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray200}}" />
        <Setter Property="Shell.NavBarHasShadow" Value="False" />
        <Setter Property="Shell.TabBarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Black}}" />
        <Setter Property="Shell.TabBarForegroundColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="Shell.TabBarTitleColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="Shell.TabBarUnselectedColor" Value="{AppThemeBinding Light={StaticResource Gray900}, Dark={StaticResource Gray200}}" />
    </Style>

    <Style TargetType="NavigationPage">
        <Setter Property="BarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource OffBlack}}" />
        <Setter Property="BarTextColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource White}}" />
        <Setter Property="IconColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource White}}" />
    </Style>

    <Style TargetType="TabbedPage">
        <Setter Property="BarBackgroundColor" Value="{AppThemeBinding Light={StaticResource White}, Dark={StaticResource Gray950}}" />
        <Setter Property="BarTextColor" Value="{AppThemeBinding Light={StaticResource Magenta}, Dark={StaticResource White}}" />
        <Setter Property="UnselectedTabColor" Value="{AppThemeBinding Light={StaticResource Gray200}, Dark={StaticResource Gray950}}" />
        <Setter Property="SelectedTabColor" Value="{AppThemeBinding Light={StaticResource Gray950}, Dark={StaticResource Gray200}}" />
    </Style>

</ResourceDictionary>



================================================
FILE: sandbox/MonoGameApplication1/app.manifest
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MonoGameApplication1"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on and is
           is designed to work with. Uncomment the appropriate elements and Windows will 
           automatically selected the most compatible environment. -->

      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />

      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />

      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />

      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />

      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />

    </application>
  </compatibility>

  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/pm</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">permonitorv2,permonitor</dpiAwareness>
    </windowsSettings>
  </application>

</assembly>



================================================
FILE: sandbox/MonoGameApplication1/Game1.cs
================================================
﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using R3;

namespace MonoGameApplication1;

class SampleComponent : GameComponent
{
    public SampleComponent(Game game) : base(game)
    {
    }

    public override void Initialize()
    {
        Observable.Interval(TimeSpan.FromMilliseconds(500))
            .GameTime()
            .Subscribe(x =>
            {
                Console.WriteLine($"ElapsedGameTime={x.ElapsedGameTime} TotalGameTime={x.TotalGameTime}");
            });

        Observable.IntervalFrame(10)
            .Subscribe(x =>
            {
                Console.WriteLine($"Frame: {ObservableSystem.DefaultFrameProvider.GetFrameCount()}");
            });
    }
}

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = "Content";
        IsMouseVisible = true;

        Components.Add(new ObservableSystemComponent(this));
        Components.Add(new SampleComponent(this));
    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        // TODO: use this.Content to load your game content here
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed ||
            Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // TODO: Add your drawing code here

        base.Draw(gameTime);
    }
}



================================================
FILE: sandbox/MonoGameApplication1/MonoGameApplication1.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <RollForward>Major</RollForward>
        <PublishReadyToRun>false</PublishReadyToRun>
        <TieredCompilation>false</TieredCompilation>
        <NoWarn>CS8002</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
        <ApplicationManifest>app.manifest</ApplicationManifest>
        <ApplicationIcon>Icon.ico</ApplicationIcon>
    </PropertyGroup>
    <ItemGroup>
        <None Remove="Icon.ico"/>
        <None Remove="Icon.bmp"/>
    </ItemGroup>
    <ItemGroup>
        <EmbeddedResource Include="Icon.ico"/>
        <EmbeddedResource Include="Icon.bmp"/>
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="MonoGame.Framework.DesktopGL" Version="3.8.1.303"/>
        <PackageReference Include="MonoGame.Content.Builder.Task" Version="3.8.1.303"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.MonoGame\R3.MonoGame.csproj" />
    </ItemGroup>
    <Target Name="RestoreDotnetTools" BeforeTargets="Restore">
        <Message Text="Restoring dotnet tools" Importance="High"/>
        <Exec Command="dotnet tool restore"/>
    </Target>
</Project>



================================================
FILE: sandbox/MonoGameApplication1/Program.cs
================================================
﻿using var game = new MonoGameApplication1.Game1();
game.Run();



================================================
FILE: sandbox/MonoGameApplication1/Content/Content.mgcb
================================================

#----------------------------- Global Properties ----------------------------#

/outputDir:bin/$(Platform)
/intermediateDir:obj/$(Platform)
/platform:DesktopGL
/config:
/profile:Reach
/compress:False

#-------------------------------- References --------------------------------#


#---------------------------------- Content ---------------------------------#




================================================
FILE: sandbox/MonoGameApplication1/.config/dotnet-tools.json
================================================
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-mgcb": {
      "version": "3.8.1.303",
      "commands": [
        "mgcb"
      ]
    },
    "dotnet-mgcb-editor": {
      "version": "3.8.1.303",
      "commands": [
        "mgcb-editor"
      ]
    },
    "dotnet-mgcb-editor-linux": {
      "version": "3.8.1.303",
      "commands": [
        "mgcb-editor-linux"
      ]
    },
    "dotnet-mgcb-editor-windows": {
      "version": "3.8.1.303",
      "commands": [
        "mgcb-editor-windows"
      ]
    },
    "dotnet-mgcb-editor-mac": {
      "version": "3.8.1.303",
      "commands": [
        "mgcb-editor-mac"
      ]
    }
  }
}


================================================
FILE: sandbox/R3.Stride.Sandbox/Directory.Build.props
================================================
<Project>
    <!-- See https://aka.ms/dotnet/msbuild/customize for more details on customizing your build -->
    <PropertyGroup>
      <!-- disable importing common project property for avoiding build failure related to Stride -->
    </PropertyGroup>
  </Project>



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.sln
================================================

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34408.163
MinimumVisualStudioVersion = 16.0.0.0
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Stride.Sandbox.Windows", "R3.Stride.Sandbox.Windows\R3.Stride.Sandbox.Windows.csproj", "{0BAFCDBB-38A5-4747-8004-FC8ABBEAFADA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Stride.Sandbox", "R3.Stride.Sandbox\R3.Stride.Sandbox.csproj", "{3E377A2E-2909-43E9-8052-019B38BB28C8}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3.Stride", "..\..\src\R3.Stride\R3.Stride.csproj", "{63C8CE6D-D4E7-4D6C-B359-8322F8605470}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "R3", "..\..\src\R3\R3.csproj", "{A8912064-A643-4CE8-A59C-DC3FBD43C68C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0BAFCDBB-38A5-4747-8004-FC8ABBEAFADA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0BAFCDBB-38A5-4747-8004-FC8ABBEAFADA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0BAFCDBB-38A5-4747-8004-FC8ABBEAFADA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0BAFCDBB-38A5-4747-8004-FC8ABBEAFADA}.Release|Any CPU.Build.0 = Release|Any CPU
		{3E377A2E-2909-43E9-8052-019B38BB28C8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3E377A2E-2909-43E9-8052-019B38BB28C8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3E377A2E-2909-43E9-8052-019B38BB28C8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3E377A2E-2909-43E9-8052-019B38BB28C8}.Release|Any CPU.Build.0 = Release|Any CPU
		{63C8CE6D-D4E7-4D6C-B359-8322F8605470}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{63C8CE6D-D4E7-4D6C-B359-8322F8605470}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{63C8CE6D-D4E7-4D6C-B359-8322F8605470}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{63C8CE6D-D4E7-4D6C-B359-8322F8605470}.Release|Any CPU.Build.0 = Release|Any CPU
		{A8912064-A643-4CE8-A59C-DC3FBD43C68C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A8912064-A643-4CE8-A59C-DC3FBD43C68C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A8912064-A643-4CE8-A59C-DC3FBD43C68C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A8912064-A643-4CE8-A59C-DC3FBD43C68C}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B510EE10-7E25-4002-B20B-8210D1E47BFC}
	EndGlobalSection
EndGlobal



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/AdditionalFrameProviderTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Engine;

namespace R3.Stride.Sandbox;
public class AdditionalFrameProviderTest: StartupScript
{
    IDisposable _Subscription;
    public override void Start()
    {
        var component = Entity.Get<AdditionalR3FrameDispatcherComponent>();
        _Subscription = Observable.IntervalFrame(24, component.FrameProvider)
            .Subscribe(_ =>
            {
                Log.Info($"additional frameprovider: {Game.UpdateTime.Total}");
            });
    }
    public override void Cancel()
    {
        _Subscription?.Dispose();
        _Subscription = null;
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/BasicCameraController.cs
================================================
﻿using System;
using Stride.Core;
using Stride.Core.Mathematics;
using Stride.Engine;
using Stride.Input;

namespace R3.Stride.Sandbox
{
    /// <summary>
    /// A script that allows to move and rotate an entity through keyboard, mouse and touch input to provide basic camera navigation.
    /// </summary>
    /// <remarks>
    /// The entity can be moved using W, A, S, D, Q and E, arrow keys, a gamepad's left stick or dragging/scaling using multi-touch.
    /// Rotation is achieved using the Numpad, the mouse while holding the right mouse button, a gamepad's right stick, or dragging using single-touch.
    /// </remarks>
    public class BasicCameraController : SyncScript
    {
        private const float MaximumPitch = MathUtil.PiOverTwo * 0.99f;

        private Vector3 upVector;
        private Vector3 translation;
        private float yaw;
        private float pitch;

        public bool Gamepad { get; set; } = false;

        public Vector3 KeyboardMovementSpeed { get; set; } = new Vector3(5.0f);

        public Vector3 TouchMovementSpeed { get; set; } = new Vector3(0.7f, 0.7f, 0.3f);

        public float SpeedFactor { get; set; } = 5.0f;

        public Vector2 KeyboardRotationSpeed { get; set; } = new Vector2(3.0f);

        public Vector2 MouseRotationSpeed { get; set; } = new Vector2(1.0f, 1.0f);

        public Vector2 TouchRotationSpeed { get; set; } = new Vector2(1.0f, 0.7f);

        public override void Start()
        {
            base.Start();

            // Default up-direction
            upVector = Vector3.UnitY;

            // Configure touch input
            if (!Platform.IsWindowsDesktop)
            {
                Input.Gestures.Add(new GestureConfigDrag());
                Input.Gestures.Add(new GestureConfigComposite());
            }
        }

        public override void Update()
        {
            ProcessInput();
            UpdateTransform();
        }

        private void ProcessInput()
        {
            float deltaTime = (float)Game.UpdateTime.Elapsed.TotalSeconds;
            translation = Vector3.Zero;
            yaw = 0f;
            pitch = 0f;

            // Keyboard and Gamepad based movement
            {
                // Our base speed is: one unit per second:
                //    deltaTime contains the duration of the previous frame, let's say that in this update
                //    or frame it is equal to 1/60, that means that the previous update ran 1/60 of a second ago
                //    and the next will, in most cases, run in around 1/60 of a second from now. Knowing that,
                //    we can move 1/60 of a unit on this frame so that in around 60 frames(1 second)
                //    we will have travelled one whole unit in a second.
                //    If you don't use deltaTime your speed will be dependant on the amount of frames rendered
                //    on screen which often are inconsistent, meaning that if the player has performance issues,
                //    this entity will move around slower.
                float speed = 1f * deltaTime;

                Vector3 dir = Vector3.Zero;

                if (Gamepad && Input.HasGamePad)
                {
                    GamePadState padState = Input.DefaultGamePad.State;
                    // LeftThumb can be positive or negative on both axis (pushed to the right or to the left)
                    dir.Z += padState.LeftThumb.Y;
                    dir.X += padState.LeftThumb.X;

                    // Triggers are always positive, in this case using one to increase and the other to decrease
                    dir.Y -= padState.LeftTrigger;
                    dir.Y += padState.RightTrigger;

                    // Increase speed when pressing A, LeftShoulder or RightShoulder
                    // Here:does the enum flag 'Buttons' has one of the flag ('A','LeftShoulder' or 'RightShoulder') set
                    if ((padState.Buttons & (GamePadButton.A | GamePadButton.LeftShoulder | GamePadButton.RightShoulder)) != 0)
                    {
                        speed *= SpeedFactor;
                    }
                }

                if (Input.HasKeyboard)
                {
                    // Move with keyboard
                    // Forward/Backward
                    if (Input.IsKeyDown(Keys.W) || Input.IsKeyDown(Keys.Up))
                    {
                        dir.Z += 1;
                    }
                    if (Input.IsKeyDown(Keys.S) || Input.IsKeyDown(Keys.Down))
                    {
                        dir.Z -= 1;
                    }

                    // Left/Right
                    if (Input.IsKeyDown(Keys.A) || Input.IsKeyDown(Keys.Left))
                    {
                        dir.X -= 1;
                    }
                    if (Input.IsKeyDown(Keys.D) || Input.IsKeyDown(Keys.Right))
                    {
                        dir.X += 1;
                    }

                    // Down/Up
                    if (Input.IsKeyDown(Keys.Q))
                    {
                        dir.Y -= 1;
                    }
                    if (Input.IsKeyDown(Keys.E))
                    {
                        dir.Y += 1;
                    }

                    // Increase speed when pressing shift
                    if (Input.IsKeyDown(Keys.LeftShift) || Input.IsKeyDown(Keys.RightShift))
                    {
                        speed *= SpeedFactor;
                    }

                    // If the player pushes down two or more buttons, the direction and ultimately the base speed
                    // will be greater than one (vector(1, 1) is farther away from zero than vector(0, 1)),
                    // normalizing the vector ensures that whichever direction the player chooses, that direction
                    // will always be at most one unit in length.
                    // We're keeping dir as is if isn't longer than one to retain sub unit movement:
                    // a stick not entirely pushed forward should make the entity move slower.
                    if (dir.Length() > 1f)
                    {
                        dir = Vector3.Normalize(dir);
                    }
                }

                // Finally, push all of that to the translation variable which will be used within UpdateTransform()
                translation += dir * KeyboardMovementSpeed * speed;
            }

            // Keyboard and Gamepad based Rotation
            {
                // See Keyboard & Gamepad translation's deltaTime usage
                float speed = 1f * deltaTime;
                Vector2 rotation = Vector2.Zero;
                if (Gamepad && Input.HasGamePad)
                {
                    GamePadState padState = Input.DefaultGamePad.State;
                    rotation.X += padState.RightThumb.Y;
                    rotation.Y += -padState.RightThumb.X;
                }

                if (Input.HasKeyboard)
                {
                    if (Input.IsKeyDown(Keys.NumPad2))
                    {
                        rotation.X += 1;
                    }
                    if (Input.IsKeyDown(Keys.NumPad8))
                    {
                        rotation.X -= 1;
                    }

                    if (Input.IsKeyDown(Keys.NumPad4))
                    {
                        rotation.Y += 1;
                    }
                    if (Input.IsKeyDown(Keys.NumPad6))
                    {
                        rotation.Y -= 1;
                    }

                    // See Keyboard & Gamepad translation's Normalize() usage
                    if (rotation.Length() > 1f)
                    {
                        rotation = Vector2.Normalize(rotation);
                    }
                }

                // Modulate by speed
                rotation *= KeyboardRotationSpeed * speed;

                // Finally, push all of that to pitch & yaw which are going to be used within UpdateTransform()
                pitch += rotation.X;
                yaw += rotation.Y;
            }

            // Mouse movement and gestures
            {
                // This type of input should not use delta time at all, they already are frame-rate independent.
                //    Lets say that you are going to move your finger/mouse for one second over 40 units, it doesn't matter
                //    the amount of frames occuring within that time frame, each frame will receive the right amount of delta:
                //    a quarter of a second -> 10 units, half a second -> 20 units, one second -> your 40 units.

                if (Input.HasMouse)
                {
                    // Rotate with mouse
                    if (Input.IsMouseButtonDown(MouseButton.Right))
                    {
                        Input.LockMousePosition();
                        Game.IsMouseVisible = false;

                        yaw -= Input.MouseDelta.X * MouseRotationSpeed.X;
                        pitch -= Input.MouseDelta.Y * MouseRotationSpeed.Y;
                    }
                    else
                    {
                        Input.UnlockMousePosition();
                        Game.IsMouseVisible = true;
                    }
                }

                // Handle gestures
                foreach (var gestureEvent in Input.GestureEvents)
                {
                    switch (gestureEvent.Type)
                    {
                        // Rotate by dragging
                        case GestureType.Drag:
                            var drag = (GestureEventDrag)gestureEvent;
                            var dragDistance = drag.DeltaTranslation;
                            yaw = -dragDistance.X * TouchRotationSpeed.X;
                            pitch = -dragDistance.Y * TouchRotationSpeed.Y;
                            break;

                        // Move along z-axis by scaling and in xy-plane by multi-touch dragging
                        case GestureType.Composite:
                            var composite = (GestureEventComposite)gestureEvent;
                            translation.X = -composite.DeltaTranslation.X * TouchMovementSpeed.X;
                            translation.Y = -composite.DeltaTranslation.Y * TouchMovementSpeed.Y;
                            translation.Z = MathF.Log(composite.DeltaScale + 1) * TouchMovementSpeed.Z;
                            break;
                    }
                }
            }
        }

        private void UpdateTransform()
        {
            // Get the local coordinate system
            var rotation = Matrix.RotationQuaternion(Entity.Transform.Rotation);

            // Enforce the global up-vector by adjusting the local x-axis
            var right = Vector3.Cross(rotation.Forward, upVector);
            var up = Vector3.Cross(right, rotation.Forward);

            // Stabilize
            right.Normalize();
            up.Normalize();

            // Adjust pitch. Prevent it from exceeding up and down facing. Stabilize edge cases.
            var currentPitch = MathUtil.PiOverTwo - MathF.Acos(Vector3.Dot(rotation.Forward, upVector));
            pitch = MathUtil.Clamp(currentPitch + pitch, -MaximumPitch, MaximumPitch) - currentPitch;

            Vector3 finalTranslation = translation;
            finalTranslation.Z = -finalTranslation.Z;
            finalTranslation = Vector3.TransformCoordinate(finalTranslation, rotation);

            // Move in local coordinates
            Entity.Transform.Position += finalTranslation;

            // Yaw around global up-vector, pitch and roll in local space
            Entity.Transform.Rotation *= Quaternion.RotationAxis(right, pitch) * Quaternion.RotationAxis(upVector, yaw);
        }
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/CubeCollisionTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Core.Mathematics;
using Stride.Input;
using Stride.Engine;
using Stride.Physics;
using Silk.NET.OpenGL;

namespace R3.Stride.Sandbox
{
    public class CubeCollisionTest : StartupScript
    {
        // Declared public member fields and properties will show in the game studio

        public override void Start()
        {
            // Initialization of the script.
            var component = Entity.Get<RigidbodyComponent>();
            component.AngularVelocity = Vector3.UnitZ;
            component.Collisions.CollectionChangedAsObservable()
                .Subscribe(x =>
                {
                    var (sender, arg) = x;
                    if(arg.Item is Collision collision)
                    {
                        Log.Info($"{sender}: {collision.ColliderA.Entity.Name}, {collision.ColliderB.Entity.Name}, {arg.Action}");
                    }
                    else
                    {
                        Log.Info($"{sender}: {arg.Item}, {arg.Key} {arg.Index}, {arg.OldItem}, {arg.Action}");
                    }
                    component.AngularVelocity = -component.AngularVelocity;
                    //component.UpdatePhysicsTransformation();
                });
            Observable.EveryUpdate()
                .Subscribe(Entity, (_, ent) =>
                {
                    var velocity = component.LinearVelocity;
                    velocity.Z = MathF.Cos((float)Game.UpdateTime.Total.TotalSeconds / 2);
                    component.LinearVelocity = velocity;
                    //component.UpdatePhysicsTransformation();
                    DebugText.Print($"{ent.Transform.Position}", new Int2(10, 300));
                });

        }
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/EventKeyReceiverTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Engine;
using Stride.Engine.Events;

namespace R3.Stride.Sandbox;
public class EventKeyReceiverTest : StartupScript
{
    EventKey<int> EventKey1 = new EventKey<int>("EventKeyTest", "Event1");
    EventKey EventKey2 = new EventKey("EventKeyTest", "Event2");
    public override void Start()
    {
        EventKey1.AsObservable()
            .Subscribe(x =>
            {
                Log.Info($"event1 published: {x}");
            });
        EventKey2.AsObservable()
            .Subscribe(_ =>
            {
                Log.Info("event2 published");
            });
        Observable.EveryUpdate()
            .ThrottleLastFrame(60)
            .Select((_, i) => i)
            .Subscribe(x =>
            {
                EventKey1.Broadcast(x);
                EventKey2.Broadcast();
            });
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/ObservableTestScript.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Core.Mathematics;
using Stride.Input;
using Stride.Engine;

namespace R3.Stride.Sandbox
{
    public class ObservableTestScript : SyncScript
    {
        // Declared public member fields and properties will show in the game studio
        public override void Start()
        {
            Observable.Interval(TimeSpan.FromSeconds(5))
                .Subscribe(_ =>
                {
                    Log.Info($"interval: {Game.UpdateTime.Total}");
                });
            Observable.EveryUpdate()
                .ThrottleLastFrame(60)
                .Subscribe(x =>
                {
                    Log.Info($"everyupdate - sampleframe(10): {Game.UpdateTime.Elapsed}");
                });
            Observable.EveryUpdate()
                .ThrottleLastFrame(60)
                .Subscribe(x =>
                {
                    //throw new Exception("test exception");
                });
        }

        public override void Update()
        {
        }
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net8.0-windows</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Stride.Engine" Version="4.2.0.2067" />

    <PackageReference Include="Stride.Video" Version="4.2.0.2067" />
    <PackageReference Include="Stride.Physics" Version="4.2.0.2067" />
    <PackageReference Include="Stride.Navigation" Version="4.2.0.2067" />
    <PackageReference Include="Stride.Particles" Version="4.2.0.2067" />
    <PackageReference Include="Stride.UI" Version="4.2.0.2067" />

    <PackageReference Include="Stride.Core.Assets.CompilerApp" Version="4.2.0.2067" IncludeAssets="build;buildTransitive" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\..\src\R3.Stride\R3.Stride.csproj" />
  </ItemGroup>
</Project>



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.sdpkg
================================================
!Package
SerializedVersion: {Assets: 3.1.0.0}
Meta:
    Name: R3.Stride.Sandbox
    Version: 1.0.0
    Authors: []
    Owners: []
    Dependencies: null
AssetFolders:
    -   Path: !dir Assets
    -   Path: !dir Effects
ResourceFolders:
    - !dir Resources
OutputGroupDirectories: {}
ExplicitFolders: []
Bundles: []
TemplateFolders: []
RootAssets: []



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/UIExtensionTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Core.Mathematics;
using Stride.Input;
using Stride.Engine;
using Stride.UI;
using Stride.UI.Controls;

namespace R3.Stride.Sandbox
{
    public class UIExtensionTest : StartupScript
    {
        // Declared public member fields and properties will show in the game studio

        public override void Start()
        {
            var page = Entity.Get<UIComponent>().Page;
            var button1 = page.RootElement.FindVisualChildOfType<Button>();
            var text1 = page.RootElement.FindVisualChildOfType<EditText>();
            var slider1 = page.RootElement.FindVisualChildOfType<Slider>();
            var toggle1 = page.RootElement.FindVisualChildOfType<ToggleButton>();
            button1.MouseOverStateChangedAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"button1 mouseover: old = {x.arg.OldValue}, new = {x.arg.NewValue}");
                });
            button1.ClickAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"button1 clicked: {x.arg.RoutedEvent.Name}");
                });
            text1.TextChangedAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"text1 changed: {text1.Text}, {x.arg.RoutedEvent.Name}");
                });
            slider1.ValueChangedAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"slider1 changed: {slider1.Value}, {x.arg.RoutedEvent.Name}");
                });
            toggle1.CheckedAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"toggle1 checked");
                });
            toggle1.UncheckedAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"toggle1 unchecked");
                });
            toggle1.IndeterminateAsObservable()
                .Subscribe(x =>
                {
                    Log.Info($"toggle1 indeterminate");
                });
        }
    }
}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Cube.sdpromodel
================================================
!ProceduralModelAsset
Id: b6a6bd83-1c1f-4d73-8cd8-bd8a66cbe3c5
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Type: !CubeProceduralModel
    Size: {X: 1.0, Y: 1.0, Z: 1.0}
    Scale: {X: 1.0, Y: 1.0, Z: 1.0}
    UvScale: {X: 1.0, Y: 1.0}
    LocalOffset: {X: 0.0, Y: 0.0, Z: 0.0}
    NumberOfTextureCoordinates: 10
    MaterialInstance:
        Material: 5b5781be-8137-4898-925e-5969eb8476a0:Sphere Material



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/GameSettings.sdgamesettings
================================================
!GameSettingsAsset
Id: 2f96de0a-498e-4890-b2d5-447edd9d1f72
SerializedVersion: {Stride: 3.1.0.1}
Tags: []
DefaultScene: 2936cac9-eb4d-4086-b649-e1a389066660:MainScene
GraphicsCompositor: f1cfd0a0-d94b-4724-8ebc-c6601deec438:GraphicsCompositor
Defaults:
    - !Stride.Audio.AudioEngineSettings,Stride.Audio
        HrtfSupport: false
    - !Stride.Assets.EditorSettings,Stride.Assets
        RenderingMode: HDR
    - !Stride.Graphics.RenderingSettings,Stride.Graphics
        DefaultBackBufferWidth: 1280
        DefaultBackBufferHeight: 720
        AdaptBackBufferToScreen: false
        DefaultGraphicsProfile: Level_10_0
        ColorSpace: Linear
        DisplayOrientation: LandscapeRight
    - !Stride.Streaming.StreamingSettings,Stride.Rendering
        ManagerUpdatesInterval: 0:00:00:00.0330000
        ResourceLiveTimeout: 0:00:00:08.0000000
    - !Stride.Assets.Textures.TextureSettings,Stride.Assets
        TextureQuality: Fast
Overrides: []
PlatformFilters:
    - PowerVR SGX 54[0-9]
    - Adreno \(TM\) 2[0-9][0-9]
    - Adreno (TM) 320
    - Adreno (TM) 330
    - Adreno \(TM\) 4[0-9][0-9]
    - NVIDIA Tegra
    - Intel(R) HD Graphics
    - ^Mali\-4
    - ^Mali\-T6
    - ^Mali\-T7
SplashScreenTexture: d26edb11-10bd-403c-b3c2-9c7fcccf25e5:StrideDefaultSplashScreen
SplashScreenColor: {R: 0, G: 0, B: 0, A: 255}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/GraphicsCompositor.sdgfxcomp
================================================
!GraphicsCompositorAsset
Id: f1cfd0a0-d94b-4724-8ebc-c6601deec438
SerializedVersion: {Stride: 3.1.0.1}
Tags: []
Archetype: 823a81bf-bac0-4552-9267-aeed499c40df:DefaultGraphicsCompositorLevel10
Cameras:
    de2e75c3b2b23e54162686363f3f138e:
        Id: e8506d2d-bdfb-468b-8d24-98a55b50c5bd
        Name: Main
RenderStages:
    47116750c1a5d449b4ad3625f71439b3:
        Id: 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
        Name: Opaque
        EffectSlotName: Main
        SortMode: !SortModeStateChange {}
    9105a30fee026d4893472b6aee83d035:
        Id: 2cc3a507-ad7f-4769-b014-b86e9d090f64
        Name: Transparent
        EffectSlotName: Main
        SortMode: !BackToFrontSortMode {}
    554e52c061404d4684dd7c4c70f70e0e:
        Id: 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
        Name: ShadowMapCaster
        EffectSlotName: ShadowMapCaster
        SortMode: !FrontToBackSortMode {}
    5a50638f5c514dc490c8c4f57cc88b57:
        Id: 8e96c815-55a3-4c65-879f-30ffe592c280
        Name: ShadowMapCasterParaboloid
        EffectSlotName: ShadowMapCasterParaboloid
        SortMode: !FrontToBackSortMode {}
    bc1a77d2ab254a6e920f86cff65cd75e:
        Id: 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
        Name: ShadowMapCasterCubeMap
        EffectSlotName: ShadowMapCasterCubeMap
        SortMode: !FrontToBackSortMode {}
    33d9d311a1a65601da9ef56775477f95:
        Id: e7e09b60-fb50-4283-ba46-a2e6e32c6c53
        Name: GBuffer
        EffectSlotName: GBuffer
        SortMode: !FrontToBackSortMode {}
RenderFeatures:
    d8fb80b0e7995140a46bca8dc36ee8a2: !Stride.Rendering.MeshRenderFeature,Stride.Rendering
        RenderStageSelectors:
            44cf4a95ef82544e9ce3c6507d5569a9: !Stride.Rendering.MeshTransparentRenderStageSelector,Stride.Rendering
                OpaqueRenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
                TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
                EffectName: StrideForwardShadingEffect
            6f7224048750e7260ea87c444f74b32c: !Stride.Rendering.Shadows.ShadowMapRenderStageSelector,Stride.Rendering
                ShadowMapRenderStage: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
                EffectName: StrideForwardShadingEffect.ShadowMapCaster
            b60663d7cb46417a94341a39c3bc1a12: !Stride.Rendering.Shadows.ShadowMapRenderStageSelector,Stride.Rendering
                ShadowMapRenderStage: ref!! 8e96c815-55a3-4c65-879f-30ffe592c280
                EffectName: StrideForwardShadingEffect.ShadowMapCasterParaboloid
            f5533b1249b942df8a8aba311cd79532: !Stride.Rendering.Shadows.ShadowMapRenderStageSelector,Stride.Rendering
                ShadowMapRenderStage: ref!! 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
                EffectName: StrideForwardShadingEffect.ShadowMapCasterCubeMap
            106341b76db9fcda6a033dad16aa708b: !Stride.Rendering.MeshTransparentRenderStageSelector,Stride.Rendering
                OpaqueRenderStage: ref!! e7e09b60-fb50-4283-ba46-a2e6e32c6c53
                EffectName: StrideForwardShadingEffect.ShadowMapCaster
        PipelineProcessors:
            d70f5aee0616e4ab25081ceaf643290c: !Stride.Rendering.MeshPipelineProcessor,Stride.Rendering
                TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
            26c899b17f88c21ab13bf60a7220ccd1: !Stride.Rendering.ShadowMeshPipelineProcessor,Stride.Rendering
                ShadowMapRenderStage: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
            ff51170a7d1a4761b73ef6a5c9f0cba2: !Stride.Rendering.ShadowMeshPipelineProcessor,Stride.Rendering
                ShadowMapRenderStage: ref!! 8e96c815-55a3-4c65-879f-30ffe592c280
                DepthClipping: true
            ae4336b0a9514e8488e8e0ccbcef25f4: !Stride.Rendering.ShadowMeshPipelineProcessor,Stride.Rendering
                ShadowMapRenderStage: ref!! 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
                DepthClipping: true
        RenderFeatures:
            86b959cbdf51a1438d4973177c77c627: !Stride.Rendering.TransformRenderFeature,Stride.Rendering {}
            8e0351fee9883922648a11016224b195: !Stride.Rendering.SkinningRenderFeature,Stride.Rendering {}
            f5a2017030ba4b28784e804807ce7628: !Stride.Rendering.Materials.MaterialRenderFeature,Stride.Rendering {}
            83fea7526ebe4893a5bad953d0502bfd: !Stride.Rendering.Shadows.ShadowCasterRenderFeature,Stride.Rendering {}
            65743b4380f4cc43b2b4bdc23cd0c07c: !Stride.Rendering.Lights.ForwardLightingRenderFeature,Stride.Rendering
                LightRenderers:
                    7ac2775468f53c4399b2f3f6357c85c9: !Stride.Rendering.Lights.LightAmbientRenderer,Stride.Rendering {}
                    7b68f9cd17404a4ba9e5f7df72e3b48d: !Stride.Rendering.Lights.LightDirectionalGroupRenderer,Stride.Rendering {}
                    411fdcfb9fc388449a0443173dfa3f27: !Stride.Rendering.Lights.LightSkyboxRenderer,Stride.Rendering {}
                    facdcd5b543cf1c6bdf2138aab6cc473: !Stride.Rendering.Lights.LightClusteredPointSpotGroupRenderer,Stride.Rendering {}
                    79582329a9cf466e960f8920f579de9b: !Stride.Rendering.Lights.LightPointGroupRenderer,Stride.Rendering {}
                    cf0c6bd4198b4cc4aaaab5b54870bdfd: !Stride.Rendering.Lights.LightSpotGroupRenderer,Stride.Rendering {}
                    451af18f3f5c4187cf3fe5f33feb46b1: !Stride.Rendering.LightProbes.LightProbeRenderer,Stride.Rendering {}
                ShadowMapRenderer: !Stride.Rendering.Shadows.ShadowMapRenderer,Stride.Rendering
                    Renderers:
                        7c3d3d4c86834c3551bacde2527b3836: !Stride.Rendering.Shadows.LightDirectionalShadowMapRenderer,Stride.Rendering
                            ShadowCasterRenderStage: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
                        1c204b09435636256a3fcfd6f9ddb347: !Stride.Rendering.Shadows.LightSpotShadowMapRenderer,Stride.Rendering
                            ShadowCasterRenderStage: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
                        7c8c69ce27034b4c8bbcab0bcdfe954b: !Stride.Rendering.Shadows.LightPointShadowMapRendererParaboloid,Stride.Rendering
                            ShadowCasterRenderStage: ref!! 8e96c815-55a3-4c65-879f-30ffe592c280
                        d59ef45dd99e49d3af3887763d153aa7: !Stride.Rendering.Shadows.LightPointShadowMapRendererCubeMap,Stride.Rendering
                            ShadowCasterRenderStage: ref!! 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
            42be209952db58294c9f06c58809b8ca: !Stride.Rendering.InstancingRenderFeature,Stride.Rendering {}
    28e9bf54a5adbe063f59fb17acb2723e: !Stride.Rendering.Sprites.SpriteRenderFeature,Stride.Rendering
        RenderStageSelectors:
            d74665cff080638a2439c4422e542d85: !Stride.Rendering.Sprites.SpriteTransparentRenderStageSelector,Stride.Rendering
                OpaqueRenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
                TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
                EffectName: Test
    60780391e205770513fdd53e07279a01: !Stride.Rendering.Background.BackgroundRenderFeature,Stride.Rendering
        RenderStageSelectors:
            11c8b8ccb522e3cd1dd6688016062a6d: !Stride.Rendering.SimpleGroupToRenderStageSelector,Stride.Rendering
                RenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
                EffectName: Test
    93933ad00d0c357d4915ad462cbfd04c: !Stride.Rendering.UI.UIRenderFeature,Stride.UI
        RenderStageSelectors:
            14a071694411235038a102ac3794bb4d: !Stride.Rendering.SimpleGroupToRenderStageSelector,Stride.Rendering
                RenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
                EffectName: Test
    9013eab3ea0ef6c98bf133b86c173d45: !Stride.Particles.Rendering.ParticleEmitterRenderFeature,Stride.Particles
        RenderStageSelectors:
            af1bd241305893ef8ff7952184e1cb0b: !Stride.Particles.Rendering.ParticleEmitterTransparentRenderStageSelector,Stride.Particles
                OpaqueRenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
                TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
                EffectName: null
        PipelineProcessors: {}
SharedRenderers:
    60459475d3a3adaf2d1ba5d99913ca75: !Stride.Rendering.Compositing.ForwardRenderer,Stride.Engine
        Id: 78b1739e-472b-4d28-b39d-34e222204d0c
        Clear:
            Id: 4bc4b2ca-027e-4e4a-94cb-2912709bef5f
            Color: {R: 0.40491876, G: 0.41189542, B: 0.43775, A: 1.0}
        LightProbes: true
        OpaqueRenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
        TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
        ShadowMapRenderStages:
            fc4d1e0de5c2b0bbc27bcf96e9a848fd: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
            87ff1d9cdd52418daf76385176a0e316: ref!! 8e96c815-55a3-4c65-879f-30ffe592c280
            5e059d4cc2db4ee8a1f28a40f4ac3ae8: ref!! 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
        GBufferRenderStage: ref!! e7e09b60-fb50-4283-ba46-a2e6e32c6c53
        PostEffects: !PostProcessingEffects ref!! e4b4f933-4ee8-4994-a0b2-1a8bd30fe731
        LightShafts: null
        VRSettings:
            Enabled: false
            RequiredApis: {}
            Overlays: {}
        SubsurfaceScatteringBlurEffect: null
        MSAALevel: None
        MSAAResolver: {}
    d5b2e71c088247e21556decdce138d96: !Stride.Rendering.Compositing.ForwardRenderer,Stride.Engine
        Id: 07a714f7-13a2-47f5-bf0c-e415293a5760
        Clear:
            Id: 66a42307-1985-4316-871a-768449238c11
            Color: {R: 0.40491876, G: 0.41189542, B: 0.43775, A: 1.0}
        LightProbes: true
        OpaqueRenderStage: ref!! 0ce3b9cb-bfab-4538-ae6e-56b441d937e0
        TransparentRenderStage: ref!! 2cc3a507-ad7f-4769-b014-b86e9d090f64
        ShadowMapRenderStages:
            2323a99a8a983e182f318e55604659b0: ref!! 4dbc1971-0dd7-4e23-9d4b-f48396e6b3ee
            61b557b74893400898c007d5ece5e87f: ref!! 8e96c815-55a3-4c65-879f-30ffe592c280
            5c382f66ee524c498d26d9aaf19fc9c3: ref!! 89c4315b-e9ed-47c0-adb5-7d5741eb61bc
        GBufferRenderStage: ref!! e7e09b60-fb50-4283-ba46-a2e6e32c6c53
        PostEffects: null
        LightShafts: null
        VRSettings:
            Enabled: false
            RequiredApis: {}
            Overlays: {}
        SubsurfaceScatteringBlurEffect: null
        MSAALevel: None
        MSAAResolver: {}
    34ecb9b2633eacfc439ba8744fe05102: !PostProcessingEffects
        Id: e4b4f933-4ee8-4994-a0b2-1a8bd30fe731
        Outline:
            Enabled: false
            NormalWeight: 2.0
            DepthWeight: 0.2
            NormalNearCutoff: 0.1
        Fog:
            Enabled: false
            Density: 0.1
            Color: {R: 1.0, G: 1.0, B: 1.0}
            FogStart: 10.0
            SkipBackground: false
        AmbientOcclusion:
            Enabled: false
        LocalReflections:
            Enabled: false
            ResolvePassResolution: Full
            DepthResolution: Half
        DepthOfField:
            Enabled: false
            DOFAreas: {X: 0.5, Y: 6.0, Z: 50.0, W: 200.0}
        BrightFilter:
            Color: {R: 1.0, G: 1.0, B: 1.0}
        Bloom:
            Distortion: {X: 1.0, Y: 1.0}
            Afterimage:
                Enabled: false
        LightStreak:
            Attenuation: 0.7
        LensFlare: {}
        ColorTransforms:
            Transforms:
                1e06f805f8b2e949a06c30d45fe413ef: !ToneMap
                    Operator: !ToneMapHejl2Operator {}
                c57351444609d14ea258b3f511ec8a74: !FilmGrain
                    Enabled: false
                e86e22e9a5d65545b8b55fca26e0afee: !Vignetting
                    Enabled: false
                    Color: {R: 0.0, G: 0.0, B: 0.0}
        Antialiasing: !FXAAEffect {}
    ee80a20a9bd99f2d70711114e15fe7ca: !Stride.Rendering.Compositing.DebugRenderer,Stride.Rendering
        Id: 7255865b-8468-404c-b32d-64a631190bfd
        DebugRenderStages: {}
Game: !Stride.Rendering.Compositing.SceneCameraRenderer,Stride.Engine
    Id: 76fe87cf-f574-4ad6-85b8-e9a9586be0e2
    Camera: ref!! e8506d2d-bdfb-468b-8d24-98a55b50c5bd
    Child: !Stride.Rendering.Compositing.SceneRendererCollection,Stride.Rendering
        Id: 82568e46-92e7-421a-8dca-114a74e0cd69
        Children:
            d39c5ddbf8b7d5ca02bafb6496b1cc3c: !Stride.Rendering.Compositing.ForwardRenderer,Stride.Engine ref!! 78b1739e-472b-4d28-b39d-34e222204d0c
            01d338078e9b21121ead0868932613dd: !Stride.Rendering.Compositing.DebugRenderer,Stride.Rendering ref!! 7255865b-8468-404c-b32d-64a631190bfd
    RenderMask: All
SingleView: !Stride.Rendering.Compositing.ForwardRenderer,Stride.Engine ref!! 07a714f7-13a2-47f5-bf0c-e415293a5760
Editor: !Stride.Rendering.Compositing.ForwardRenderer,Stride.Engine ref!! 78b1739e-472b-4d28-b39d-34e222204d0c
BlockPositions: {}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Ground Material.sdmat
================================================
!MaterialAsset
Id: 25d3d958-1f30-4b3e-aae3-fd19a7d0bda7
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Attributes:
    MicroSurface: !MaterialGlossinessMapFeature
        GlossinessMap: !ComputeFloat
            Value: 0.1
    Diffuse: !MaterialDiffuseMapFeature
        DiffuseMap: !ComputeColor
            Value: {R: 0.14117648, G: 0.14117648, B: 0.14117648, A: 1.0}
    DiffuseModel: !MaterialDiffuseLambertModelFeature {}
    Specular: !MaterialMetalnessMapFeature
        MetalnessMap: !ComputeFloat
            Value: 0.0
    SpecularModel: !MaterialSpecularMicrofacetModelFeature
        Fresnel: !MaterialSpecularMicrofacetFresnelSchlick {}
        Visibility: !MaterialSpecularMicrofacetVisibilitySmithSchlickGGX {}
        NormalDistribution: !MaterialSpecularMicrofacetNormalDistributionGGX {}
        Environment: !MaterialSpecularMicrofacetEnvironmentGGXLUT {}
    Overrides:
        UVScale: {X: 1.0, Y: 1.0}
Layers: {}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Ground.sdpromodel
================================================
!ProceduralModelAsset
Id: aff8da36-c1ef-43b3-8fc4-4212a0730901
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Type: !PlaneProceduralModel
    Size: {X: 10.0, Y: 10.0}
    Tessellation: {X: 1, Y: 1}
    Scale: {X: 1.0, Y: 1.0, Z: 1.0}
    UvScale: {X: 1.0, Y: 1.0}
    LocalOffset: {X: 0.0, Y: 0.0, Z: 0.0}
    NumberOfTextureCoordinates: 10
    MaterialInstance:
        Material: 25d3d958-1f30-4b3e-aae3-fd19a7d0bda7:Ground Material



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/MainScene.sdscene
================================================
!SceneAsset
Id: 2936cac9-eb4d-4086-b649-e1a389066660
SerializedVersion: {Stride: 3.1.0.1}
Tags: []
ChildrenIds: []
Offset: {X: 0.0, Y: 0.0, Z: 0.0}
Hierarchy:
    RootParts:
        - ref!! 2b300ec9-5416-4771-ab62-636a1ce25643
        - ref!! 016064cc-d022-441a-9402-adc01926f5c6
        - ref!! 5fe200ea-5597-4507-b15e-2a13ec790a29
        - ref!! 25485e52-f98a-4419-9f5e-959e03f849e2
        - ref!! 56cd9852-d94c-4646-a513-85195ea3fe9b
        - ref!! b7806d41-f54f-4e99-9ec7-f9906f10b006
        - ref!! 787562e5-0943-4493-85ce-6b0bd2abf47f
        - ref!! 9c0e2928-6cdc-4033-b5cc-06d2dfdb291d
    Parts:
        -   Entity:
                Id: 016064cc-d022-441a-9402-adc01926f5c6
                Name: Directional light
                Components:
                    78352b829a13dad8203d9b1989b9c70a: !TransformComponent
                        Id: ffd6ee00-4ef0-4a49-9d20-22d46aecc8d0
                        Position: {X: 0.0, Y: 2.0, Z: 0.0}
                        Rotation: {X: 1.131334E-08, Y: -0.9659258, Z: -0.25881904, W: -4.222196E-08}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    b675f0bf59b86f9ed2f706e537ece9ab: !LightComponent
                        Id: 2eecf0a3-6500-41a2-9cde-edabdd54ebbe
                        Type: !LightDirectional
                            Color: !ColorRgbProvider
                                Value: {R: 1.0, G: 1.0, B: 1.0}
                            Shadow: !LightDirectionalShadowMap
                                Enabled: true
                                Filter: !LightShadowMapFilterTypePcf
                                    FilterSize: Filter5x5
                                Size: Large
                                DepthRange: {}
                                PartitionMode: !LightDirectionalShadowMap.PartitionLogarithmic {}
                                ComputeTransmittance: false
                                BiasParameters: {}
                        Intensity: 20.0
        -   Entity:
                Id: 25485e52-f98a-4419-9f5e-959e03f849e2
                Name: Ground
                Components:
                    f1a700b7a4149056569e906450538a58: !TransformComponent
                        Id: a7eabcae-d1b3-4b53-9dc4-572fcdf5765e
                        Position: {X: 0.0, Y: 0.0, Z: 0.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    ae8e173a0a53f15ce0f842d78e790c08: !ModelComponent
                        Id: 1a9d3c62-9ef5-4bde-b8e2-71ed721c0d9b
                        Model: aff8da36-c1ef-43b3-8fc4-4212a0730901:Ground
                        Materials: {}
                    9cd507465eca3af487d41bf2b217d26d: !StaticColliderComponent
                        Id: 076e6b55-b3c6-4922-ae2d-298b28a31cf0
                        CanSleep: false
                        Restitution: 0.0
                        Friction: 0.5
                        RollingFriction: 0.0
                        CcdMotionThreshold: 0.0
                        CcdSweptSphereRadius: 0.0
                        IsTrigger: false
                        AlwaysUpdateNaviMeshCache: false
                        ColliderShapes:
                            153eee591f3997346bb2929e45ea6830: !StaticPlaneColliderShapeDesc
                                Normal: {X: 0.0, Y: 1.0, Z: 0.0}
                                Offset: 0.0
        -   Entity:
                Id: 2b300ec9-5416-4771-ab62-636a1ce25643
                Name: Camera
                Components:
                    b8b773f875648c0554f1d1f77a3e6982: !TransformComponent
                        Id: 6b2cd6ec-5617-4c0a-99f9-731f7a874820
                        Position: {X: 5.0, Y: 0.6, Z: -2.0}
                        Rotation: {X: 0.0, Y: 0.82903755, Z: 0.0, W: 0.5591929}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    acf95bf6cda74b2b7430833e4c9ffb4f: !CameraComponent
                        Id: 1e88b227-dd3b-48f1-8e3e-6eed209f0a6f
                        Name: null
                        Projection: Perspective
                        Slot: e8506d2d-bdfb-468b-8d24-98a55b50c5bd
        -   Entity:
                Id: 56cd9852-d94c-4646-a513-85195ea3fe9b
                Name: Sphere
                Components:
                    4323915997bb396965d78998bde95bd9: !TransformComponent
                        Id: ae56850c-71fb-4906-8227-d4ead3b480f7
                        Position: {X: 0.0, Y: 0.5, Z: 0.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    db974c49eba72e6068ebe5b9fa88f6a1: !ModelComponent
                        Id: 0b8a72b5-76a3-447c-92fb-93e5302f01b9
                        Model: c4063b2b-caff-4757-9bcd-47c34e9452cc:Sphere
                        Materials: {}
                    9ecd94ecc0e9386fbd0c327a059558bc: !RigidbodyComponent
                        Id: fbf3f6ba-4737-4788-b5e9-f1b7506c5e79
                        CanSleep: false
                        Restitution: 0.0
                        Friction: 0.5
                        RollingFriction: 0.0
                        CcdMotionThreshold: 0.0
                        CcdSweptSphereRadius: 0.0
                        IsTrigger: false
                        IsKinematic: false
                        Mass: 1.0
                        LinearDamping: 0.0
                        AngularDamping: 0.0
                        OverrideGravity: false
                        Gravity: {X: 0.0, Y: 0.0, Z: 0.0}
                        NodeName: null
                        ColliderShapes:
                            f07e140ad4c31956db525f8c23bc5f92: !SphereColliderShapeDesc
                                Is2D: false
                                LocalOffset: {X: 0.0, Y: 0.0, Z: 0.0}
        -   Entity:
                Id: 5fe200ea-5597-4507-b15e-2a13ec790a29
                Name: Skybox
                Components:
                    b508d802cdb402fa0508af773931272c: !TransformComponent
                        Id: 70aa6937-0674-418a-acf6-43ae7deb027c
                        Position: {X: 0.0, Y: 2.0, Z: -2.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    1d213c0f57b71c562f1cdf54f12b30c1: !BackgroundComponent
                        Id: 47192fdb-621d-4e61-88ea-a7c4d21ca490
                        Texture: bfecf813-ae24-42de-bf68-34cdb0f2e1a5:Skybox texture
                    f18268e0217e96f8fadb62b6e69c8dc4: !LightComponent
                        Id: 23038a97-6ad0-4e11-8712-50906e169a0c
                        Type: !LightSkybox
                            Skybox: cc072fe6-0abf-46fb-95bf-5540a7d4f27e:Skybox
        -   Entity:
                Id: 787562e5-0943-4493-85ce-6b0bd2abf47f
                Name: Page
                Components:
                    69688e41ad4fc6c8c7553ad9b3ae308d: !TransformComponent
                        Id: 582a84b3-3afc-4891-91dd-13e490fd3742
                        Position: {X: 0.0, Y: 0.0, Z: 0.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    0eaf59c11adc3bd9d5839f7e9fc16ba1: !UIComponent
                        Id: 5c15a432-0feb-4c90-acd1-53dfc198cd46
                        Page: 6130ab8f-e04d-4b0e-99c1-8fd197f5d1e7:Page
                        Resolution: {X: 1280.0, Y: 720.0, Z: 1000.0}
                        Size: {X: 1.28, Y: 0.72, Z: 1.0}
                    87d8cfc0f2480a8c80ec5245c6710d2f: !R3.Stride.Sandbox.UIExtensionTest,R3.Stride.Sandbox
                        Id: 65687212-b652-4f3f-a61a-f3320cc3e1e6
        -   Entity:
                Id: 9c0e2928-6cdc-4033-b5cc-06d2dfdb291d
                Name: Cube
                Components:
                    f3a9306cfab07ec9687f289ac04ebe44: !TransformComponent
                        Id: 6524d4a2-830b-4be5-96a4-e07c28761768
                        Position: {X: 0.0, Y: 0.5, Z: 2.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 0.5, Y: 0.5, Z: 0.5}
                        Children: {}
                    905fc01ae7567f30e72873cd6f9269ec: !ModelComponent
                        Id: b931a3a8-253e-4ad9-b4d9-1ef12891519d
                        Model: b6a6bd83-1c1f-4d73-8cd8-bd8a66cbe3c5:Cube
                        Materials: {}
                    7e202eb6e07ed1ff4366b2c6eff48b73: !RigidbodyComponent
                        Id: 76143390-3505-458b-8165-a00cb34abfa7
                        CanSleep: false
                        Restitution: 0.0
                        Friction: 0.5
                        RollingFriction: 0.0
                        CcdMotionThreshold: 0.0
                        CcdSweptSphereRadius: 0.0
                        IsTrigger: true
                        IsKinematic: false
                        Mass: 0.0
                        LinearDamping: 0.0
                        AngularDamping: 0.0
                        OverrideGravity: false
                        Gravity: {X: 0.0, Y: 0.0, Z: 0.0}
                        NodeName: null
                        ColliderShapes:
                            59522ecd008781a40fe910ce5729b87f: !BoxColliderShapeDesc
                                Is2D: false
                                Size: {X: 0.5, Y: 0.5, Z: 0.5}
                                LocalOffset: {X: 0.0, Y: 0.0, Z: 0.0}
                                LocalRotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                    f0e5f00a9db5203f5ec7e550b0e88491: !R3.Stride.Sandbox.CubeCollisionTest,R3.Stride.Sandbox
                        Id: 7ba17cb9-5eab-4c77-abd2-59f412561715
        -   Entity:
                Id: b7806d41-f54f-4e99-9ec7-f9906f10b006
                Name: Entity
                Components:
                    f8a1fef68667bfd6407c4ac7afae5305: !TransformComponent
                        Id: d7f0b92f-41b5-4b6b-b626-80800d1fdfeb
                        Position: {X: 0.0, Y: 0.0, Z: 0.0}
                        Rotation: {X: 0.0, Y: 0.0, Z: 0.0, W: 1.0}
                        Scale: {X: 1.0, Y: 1.0, Z: 1.0}
                        Children: {}
                    6f4023fe5b305442911adadcff8c385d: !R3.Stride.Sandbox.ObservableTestScript,R3.Stride.Sandbox
                        Id: 1d8eed70-d32b-4820-a015-98f6b0634f8e
                    d6c08302e8bc4cff4f75a1bef919f3ea: !R3.Stride.Sandbox.EventKeyReceiverTest,R3.Stride.Sandbox
                        Id: 340c3d80-da0d-4b6f-b7b7-4071e161d717
                    88beb326b15d1fdb09e60b18731e24bc: !R3FrameDispatcherComponent
                        Id: 1d2c5270-7ad5-4b36-864e-e89dfb285f4c
                        Priority: 10
                    6264e7db3f67ba5a4ba7a691a7c41c6f: !R3.Stride.Sandbox.AdditionalFrameProviderTest,R3.Stride.Sandbox
                        Id: 4a196c5f-4d7e-404b-b8cc-1b8af2d04f9d
                        Priority: -1
                    47ba47d08a35fad417c4876b133382dd: !AdditionalR3FrameDispatcherComponent
                        Id: bc8961f7-ecb8-46f4-8669-6ab1ef3a1865



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Page.sduipage
================================================
!UIPageAsset
Id: 6130ab8f-e04d-4b0e-99c1-8fd197f5d1e7
SerializedVersion: {Stride: 2.1.0.1}
Tags: []
Design:
    Resolution: {X: 1280.0, Y: 720.0, Z: 1000.0}
Hierarchy:
    RootParts:
        - !Grid ref!! db136504-953f-45b8-a3b3-649cc63a641a
    Parts:
        -   UIElement: !TextBlock
                Id: 34d10502-68a7-4414-9c43-502d5dc3b1fb
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                HorizontalAlignment: Center
                VerticalAlignment: Center
                Margin: {}
                Text: Click me!
                Font: c90f3988-0544-4cbe-993f-13af7d9c23c6:StrideDefaultFont
                TextSize: 20.0
                TextColor: {R: 240, G: 240, B: 240, A: 255}
        -   UIElement: !Slider
                Id: 37f0b3fa-29b4-44a7-8c4a-2931170e7ddb
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                DrawLayerNumber: 5
                Margin: {}
                Name: Slider1
                TrackBackgroundImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 9
                TrackForegroundImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 12
                TrackStartingOffsets: {X: 3.0, Y: 3.0}
                ThumbImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 7
                MouseOverThumbImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 6
                TickImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 8
                TickOffset: 13.0
        -   UIElement: !Button
                Id: 3dfd7467-8d0e-4c53-9674-45b0ddff2213
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                DrawLayerNumber: 2
                Margin: {}
                Name: Button1
                Content: !TextBlock ref!! bb09fbdb-7aac-43b7-b8b7-b6366ba31961
                PressedImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 2
                NotPressedImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 1
                MouseOverImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
        -   UIElement: !EditText
                Id: 40913c6d-195e-400e-a556-26230f5542e6
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                DrawLayerNumber: 5
                CanBeHitByUser: true
                Margin: {}
                Name: EditText1
                Padding: {Left: 8.0, Top: 4.0, Right: 8.0, Bottom: 8.0}
                Font: c90f3988-0544-4cbe-993f-13af7d9c23c6:StrideDefaultFont
                TextSize: 20.0
                TextColor: {R: 240, G: 240, B: 240, A: 255}
                ActiveImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 3
                InactiveImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 4
                MouseOverImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 5
                CaretColor: {R: 240, G: 240, B: 240, A: 255}
                CaretWidth: 1.0
                SelectionColor: {R: 240, G: 240, B: 240, A: 255}
                IMESelectionColor: {R: 240, G: 255, B: 240, A: 255}
                CaretFrequency: 1.0
        -   UIElement: !StackPanel
                Id: afdaf241-b5b8-4c20-aff5-bd27e7acd83a
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                Margin: {}
                Children:
                    dab3f7229c48892f7c1c21d69c7f25a7: !Button ref!! 3dfd7467-8d0e-4c53-9674-45b0ddff2213
                    00b5ffa11acc1ab6ffd37c1e86c3a2be: !EditText ref!! 40913c6d-195e-400e-a556-26230f5542e6
                    6b8d431d9e9e2ba2a8e56bbf27695e41: !Slider ref!! 37f0b3fa-29b4-44a7-8c4a-2931170e7ddb
                    573f128cb0886870cb2c0850fa2cd29c: !ToggleButton ref!! b5784372-8dbf-4511-9495-535b406528e4
        -   UIElement: !ToggleButton
                Id: b5784372-8dbf-4511-9495-535b406528e4
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                DrawLayerNumber: 2
                Margin: {}
                Name: Toggle1
                Content: !TextBlock ref!! 34d10502-68a7-4414-9c43-502d5dc3b1fb
                CheckedImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 11
                UncheckedImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 13
                IndeterminateImage: !SpriteFromSheet
                    Sheet: 1be3340c-b797-4557-bff7-d9be92dfdb42:StrideUIDesigns
                    CurrentFrame: 12
                IsThreeState: true
        -   UIElement: !TextBlock
                Id: bb09fbdb-7aac-43b7-b8b7-b6366ba31961
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                HorizontalAlignment: Center
                VerticalAlignment: Center
                Margin: {}
                Text: Click me!
                Font: c90f3988-0544-4cbe-993f-13af7d9c23c6:StrideDefaultFont
                TextSize: 20.0
                TextColor: {R: 240, G: 240, B: 240, A: 255}
        -   UIElement: !Grid
                Id: db136504-953f-45b8-a3b3-649cc63a641a
                DependencyProperties: {}
                BackgroundColor: {R: 0, G: 0, B: 0, A: 0}
                Margin: {}
                Children:
                    2ae638ef9bfaaca7985e76849d5f1084: !StackPanel ref!! afdaf241-b5b8-4c20-aff5-bd27e7acd83a
                RowDefinitions: {}
                ColumnDefinitions: {}
                LayerDefinitions: {}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Skybox texture.sdtex
================================================
!Texture
Id: bfecf813-ae24-42de-bf68-34cdb0f2e1a5
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Source: !file ../Resources/skybox_texture_hdr.dds
Type: !ColorTextureType
    UseSRgbSampling: false
    ColorKeyColor: {R: 255, G: 0, B: 255, A: 255}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Skybox.sdsky
================================================
!SkyboxAsset
Id: cc072fe6-0abf-46fb-95bf-5540a7d4f27e
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
CubeMap: bfecf813-ae24-42de-bf68-34cdb0f2e1a5:Skybox texture



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Sphere Material.sdmat
================================================
!MaterialAsset
Id: 5b5781be-8137-4898-925e-5969eb8476a0
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Attributes:
    MicroSurface: !MaterialGlossinessMapFeature
        GlossinessMap: !ComputeFloat
            Value: 0.65
    Diffuse: !MaterialDiffuseMapFeature
        DiffuseMap: !ComputeColor
            Value: {R: 0.54901963, G: 0.54901963, B: 0.54901963, A: 1.0}
    DiffuseModel: !MaterialDiffuseLambertModelFeature {}
    Specular: !MaterialMetalnessMapFeature
        MetalnessMap: !ComputeFloat
            Value: 1.0
    SpecularModel: !MaterialSpecularMicrofacetModelFeature
        Fresnel: !MaterialSpecularMicrofacetFresnelSchlick {}
        Visibility: !MaterialSpecularMicrofacetVisibilitySmithSchlickGGX {}
        NormalDistribution: !MaterialSpecularMicrofacetNormalDistributionGGX {}
        Environment: !MaterialSpecularMicrofacetEnvironmentGGXLUT {}
    Overrides:
        UVScale: {X: 1.0, Y: 1.0}
Layers: {}



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox/Assets/Sphere.sdpromodel
================================================
!ProceduralModelAsset
Id: c4063b2b-caff-4757-9bcd-47c34e9452cc
SerializedVersion: {Stride: 2.0.0.0}
Tags: []
Type: !SphereProceduralModel
    Tessellation: 30
    Scale: {X: 1.0, Y: 1.0, Z: 1.0}
    UvScale: {X: 1.0, Y: 1.0}
    LocalOffset: {X: 0.0, Y: 0.0, Z: 0.0}
    NumberOfTextureCoordinates: 10
    MaterialInstance:
        Material: 5b5781be-8137-4898-925e-5969eb8476a0:Sphere Material



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.Windows/R3.Stride.Sandbox.Windows.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0-windows</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <ApplicationIcon>Resources\Icon.ico</ApplicationIcon>
    <OutputType>WinExe</OutputType>
    <RootNamespace>R3.Stride.Sandbox</RootNamespace>

    <OutputPath>..\Bin\Windows\$(Configuration)\</OutputPath>
    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>

    <!-- Force msbuild to check to rebuild this assembly instead of letting VS IDE guess -->
    <DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\R3.Stride.Sandbox\R3.Stride.Sandbox.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.Windows/R3.Stride.Sandbox.Windows.sdpkg
================================================
!Package
SerializedVersion: {Assets: 3.1.0.0}
Meta:
    Name: R3.Stride.Sandbox.Windows
    Version: 1.0.0
    Authors: []
    Owners: []
    Dependencies: null
AssetFolders:
    -   Path: !dir Assets
ResourceFolders:
    - !dir Resources
OutputGroupDirectories: {}
ExplicitFolders: []
Bundles: []
TemplateFolders: []
RootAssets: []



================================================
FILE: sandbox/R3.Stride.Sandbox/R3.Stride.Sandbox.Windows/R3_Stride_SandboxApp.cs
================================================
using Stride.Engine;

namespace R3.Stride.Sandbox
{
    class R3_Stride_SandboxApp
    {
        static void Main(string[] args)
        {
            using (var game = new Game())
            {
                game.Run();
            }
        }
    }
}



================================================
FILE: sandbox/ReferenceBuilder/Program.cs
================================================
﻿using MarkdownGenerator;
using System.Reflection;

var f = Factory();
var o = Operator();

// Get absolute path of bin/Debug/TargetFramework/ReferenceBuilder.dll
// Location = /Foo/Bar/R3/sandbox/ReferenceBuilder/bin/Debug/net8.0/ReferenceBuilder.dll
var basePath = Assembly.GetAssembly(typeof(Program))!.Location;
File.WriteAllText(Path.Combine(basePath, "../../../../../../docs/reference_factory.md"), f);
File.WriteAllText(Path.Combine(basePath, "../../../../../../docs/reference_operator.md"), o);

// replace readme
var text = File.ReadAllLines(Path.Combine(basePath, "../../../../../../README.md"));

(int head, int tail)? factoryLines = null;
(int head, int tail)? operatorLines = null;

var searchTail = false;
var i1 = 0;
for (int i = 0; i < text.Length; i++)
{

    const string head = "| Name(Parameter) | ReturnType |";
    if (!searchTail)
    {
        // search head
        if (text[i].Trim() == head)
        {
            i1 = i;
            searchTail = true;
        }
    }
    else
    {
        if (text[i].Trim() == "")
        {
            if (factoryLines == null)
            {
                factoryLines = (i1, i);
            }
            else
            {
                operatorLines = (i1, i);
            }
            searchTail = false;
        }
    }
}

Console.WriteLine(factoryLines!);
Console.WriteLine(operatorLines!);

var newText = new List<string>();
for (int i = 0; i < text.Length; i++)
{
    if (i == factoryLines!.Value.head)
    {
        foreach (var line in f.Split(Environment.NewLine))
        {
            if (line.Trim().Length == 0) continue;
            newText.Add(line);
        }
        i = factoryLines!.Value.tail - 1; // when continue, +1
        while (text[i] == "")
        {
            i++;
        }
        continue;
    }

    if (i == operatorLines!.Value.head)
    {
        foreach (var line in o.Split(Environment.NewLine))
        {
            if (line.Trim().Length == 0) continue;
            newText.Add(line);
        }
        i = operatorLines!.Value.tail - 1;
        while (text[i] == "")
        {
            i++;
        }
        continue;
    }

    newText.Add(text[i]);
}

var nt = string.Join(Environment.NewLine, newText);
File.WriteAllText(Path.Combine(basePath, "../../../../../../README.md"), nt);

static string Factory()
{
    var emptyCommentTable = Enumerable.Empty<string>().ToLookup(x => x, _ => new XmlDocumentComment());
    var t = new MarkdownableType(typeof(R3.Observable), emptyCommentTable);
    return t.ToString();
}

static string Operator()
{
    var emptyCommentTable = Enumerable.Empty<string>().ToLookup(x => x, _ => new XmlDocumentComment());
    var t = new MarkdownableType(typeof(R3.ObservableExtensions), emptyCommentTable);
    return t.ToString();
}

//using System;
//using System.Collections.Generic;
//using System.IO;
//using System.Linq;
//using System.Text;
//using System.Text.RegularExpressions;
//using System.Threading.Tasks;

//namespace MarkdownWikiGenerator
//{
//    class Program
//    {
//        // 0 = dll src path, 1 = dest root
//        static void Main(string[] args)
//        {
//            // put dll & xml on same diretory.
//            var target = "UniRx.dll"; // :)
//            string dest = "md";
//            string namespaceMatch = string.Empty;
//            if (args.Length == 1)
//            {
//                target = args[0];
//            }
//            else if (args.Length == 2)
//            {
//                target = args[0];
//                dest = args[1];
//            }
//            else if (args.Length == 3)
//            {
//                target = args[0];
//                dest = args[1];
//                namespaceMatch = args[2];
//            }

//            var types = MarkdownGenerator.Load(target, namespaceMatch);

//            // Home Markdown Builder
//            var homeBuilder = new MarkdownBuilder();
//            homeBuilder.Header(1, "References");
//            homeBuilder.AppendLine();

//            foreach (var g in types.GroupBy(x => x.Namespace).OrderBy(x => x.Key))
//            {
//                if (!Directory.Exists(dest)) Directory.CreateDirectory(dest);

//                homeBuilder.HeaderWithLink(2, g.Key, g.Key);
//                homeBuilder.AppendLine();

//                var sb = new StringBuilder();
//                foreach (var item in g.OrderBy(x => x.Name))
//                {
//                    homeBuilder.ListLink(MarkdownBuilder.MarkdownCodeQuote(item.BeautifyName), g.Key + "#" + item.BeautifyName.Replace("<", "").Replace(">", "").Replace(",", "").Replace(" ", "-").ToLower());

//                    sb.Append(item.ToString());
//                }

//                File.WriteAllText(Path.Combine(dest, g.Key + ".md"), sb.ToString());
//                homeBuilder.AppendLine();
//            }

//            // Gen Home
//            File.WriteAllText(Path.Combine(dest, "Home.md"), homeBuilder.ToString());
//        }
//    }
//}



================================================
FILE: sandbox/ReferenceBuilder/ReferenceBuilder.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/ReferenceBuilder/MarkdownGenerator/Beautifier.cs
================================================
﻿#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace MarkdownGenerator;

public static class Beautifier
{
    public static string BeautifyType(Type t, bool isFull = false)
    {
        if (t == null) return "";
        if (t == typeof(void)) return "void";
        if (t.IsArray)
        {
            var innerFormat = BeautifyType(t.GetElementType(), isFull);
            return innerFormat + "[]";
        }

        if (!t.IsGenericType) return (isFull) ? t.FullName : t.Name;

        {
            var innerFormat = string.Join(", ", t.GetGenericArguments().Select(x => BeautifyType(x)));
            return Regex.Replace(isFull ? t.GetGenericTypeDefinition().FullName : t.GetGenericTypeDefinition().Name, @"`.+$", "") + "<" + innerFormat + ">";
        }
    }

    public static string ToMarkdownMethodInfo(MethodInfo methodInfo)
    {
        var isExtension = IsExtensionMethod(methodInfo);

        var seq = methodInfo.GetParameters().Select(x =>
        {
            var isParams = IsParamsParameter(x);
            var refKind = IsOutParameter(x) ? "out " : IsRefParameter(x) ? "ref " : IsInParameter(x) ? "in " : "";
            var prefix = isParams ? "params " : refKind;

            var defaultValue = "default";
            if (x.DefaultValue != null)
            {
                if (x.DefaultValue.GetType().IsEnum)
                {
                    defaultValue = x.DefaultValue.GetType().Name + "." + x.DefaultValue.ToString();
                }
                else
                {
                    defaultValue = x.DefaultValue.ToString().ToLower();
                }
            }
            var suffix = x.HasDefaultValue ? (" = " + defaultValue) : "";
            return prefix + "`" + BeautifyType(x.ParameterType) + "` " + x.Name + suffix;
        });

        // NOTE: modify **
        return "**" + methodInfo.Name + "**" + "(" + (isExtension ? "this " : "") + string.Join(", ", seq) + ")";
    }

    static bool IsExtensionMethod(MethodInfo method)
    {
        return method.IsDefined(typeof(System.Runtime.CompilerServices.ExtensionAttribute), false);
    }

    static bool IsParamsParameter(ParameterInfo parameter)
    {
        return parameter.IsDefined(typeof(ParamArrayAttribute), false);
    }

    static bool IsOutParameter(ParameterInfo parameter)
    {
        return parameter.IsOut;
    }

    static bool IsRefParameter(ParameterInfo parameter)
    {
        return parameter.ParameterType.IsByRef && !parameter.IsOut;
    }

    static bool IsInParameter(ParameterInfo parameter)
    {
        return parameter.IsIn && parameter.ParameterType.IsByRef;
    }
}



================================================
FILE: sandbox/ReferenceBuilder/MarkdownGenerator/MarkdownBuilder.cs
================================================
﻿#nullable disable

using System.Collections.Generic;
using System.Text;

namespace MarkdownGenerator;

public class MarkdownBuilder
{
    public static string MarkdownCodeQuote(string code)
    {
        return "`" + code + "`";
    }


    StringBuilder sb = new StringBuilder();

    public void Append(string text)
    {
        sb.Append(text);
    }

    public void AppendLine()
    {
        sb.AppendLine();
    }

    public void AppendLine(string text)
    {
        sb.AppendLine(text);
    }

    public void Header(int level, string text)
    {
        for (int i = 0; i < level; i++)
        {
            sb.Append("#");
        }
        sb.Append(" ");
        sb.AppendLine(text);
    }

    public void HeaderWithCode(int level, string code)
    {
        for (int i = 0; i < level; i++)
        {
            sb.Append("#");
        }
        sb.Append(" ");
        CodeQuote(code);
        sb.AppendLine();
    }

    public void HeaderWithLink(int level, string text, string url)
    {
        for (int i = 0; i < level; i++)
        {
            sb.Append("#");
        }
        sb.Append(" ");
        Link(text, url);
        sb.AppendLine();
    }

    public void Link(string text, string url)
    {
        sb.Append("[");
        sb.Append(text);
        sb.Append("]");
        sb.Append("(");
        sb.Append(url);
        sb.Append(")");
    }

    public void Image(string altText, string imageUrl)
    {
        sb.Append("!");
        Link(altText, imageUrl);
    }

    public void Code(string language, string code)
    {
        sb.Append("```");
        sb.AppendLine(language);
        sb.AppendLine(code);
        sb.AppendLine("```");
    }

    public void CodeQuote(string code)
    {
        sb.Append("`");
        sb.Append(code);
        sb.Append("`");
    }

    public void Table(string[] headers, IEnumerable<string[]> items)
    {
        sb.Append("| ");
        foreach (var item in headers)
        {
            sb.Append(item);
            sb.Append(" | ");
        }
        sb.AppendLine();

        sb.Append("| ");
        foreach (var item in headers)
        {
            sb.Append("---");
            sb.Append(" | ");
        }
        sb.AppendLine();


        foreach (var item in items)
        {
            sb.Append("| ");
            foreach (var item2 in item)
            {
                sb.Append(item2);
                sb.Append(" | ");
            }
            sb.AppendLine();
        }
        sb.AppendLine();
    }

    public void List(string text) // nest zero
    {
        sb.Append("- ");
        sb.AppendLine(text);
    }

    public void ListLink(string text, string url) // nest zero
    {
        sb.Append("- ");
        Link(text, url);
        sb.AppendLine();
    }

    public override string ToString()
    {
        return sb.ToString();
    }
}



================================================
FILE: sandbox/ReferenceBuilder/MarkdownGenerator/MarkdownGenerator.cs
================================================
﻿#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace MarkdownGenerator;

public class MarkdownableType
{
    readonly Type type;
    readonly ILookup<string, XmlDocumentComment> commentLookup;

    public string Namespace => type.Namespace;
    public string Name => type.Name;
    public string BeautifyName => Beautifier.BeautifyType(type);

    public MarkdownableType(Type type, ILookup<string, XmlDocumentComment> commentLookup)
    {
        this.type = type;
        this.commentLookup = commentLookup;
    }

    MethodInfo[] GetMethods()
    {
        return type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.InvokeMethod)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any() && !x.IsPrivate)
            .ToArray();
    }

    PropertyInfo[] GetProperties()
    {
        return type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.GetProperty | BindingFlags.SetProperty)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any())
            .Where(y =>
            {
                var get = y.GetGetMethod(true);
                var set = y.GetSetMethod(true);
                if (get != null && set != null)
                {
                    return !(get.IsPrivate && set.IsPrivate);
                }
                else if (get != null)
                {
                    return !get.IsPrivate;
                }
                else if (set != null)
                {
                    return !set.IsPrivate;
                }
                else
                {
                    return false;
                }
            })
            .ToArray();
    }

    FieldInfo[] GetFields()
    {
        return type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.GetField | BindingFlags.SetField)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any() && !x.IsPrivate)
            .ToArray();
    }

    EventInfo[] GetEvents()
    {
        return type.GetEvents(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any())
            .ToArray();
    }

    FieldInfo[] GetStaticFields()
    {
        return type.GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.GetField | BindingFlags.SetField)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any() && !x.IsPrivate)
            .ToArray();
    }

    PropertyInfo[] GetStaticProperties()
    {
        return type.GetProperties(BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.GetProperty | BindingFlags.SetProperty)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any())
            .Where(y =>
            {
                var get = y.GetGetMethod(true);
                var set = y.GetSetMethod(true);
                if (get != null && set != null)
                {
                    return !(get.IsPrivate && set.IsPrivate);
                }
                else if (get != null)
                {
                    return !get.IsPrivate;
                }
                else if (set != null)
                {
                    return !set.IsPrivate;
                }
                else
                {
                    return false;
                }
            })
            .ToArray();
    }

    MethodInfo[] GetStaticMethods()
    {
        return type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.InvokeMethod)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any() && !x.IsPrivate)
            .ToArray();
    }

    EventInfo[] GetStaticEvents()
    {
        return type.GetEvents(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly)
            .Where(x => !x.IsSpecialName && !x.GetCustomAttributes<ObsoleteAttribute>().Any())
            .ToArray();
    }
    void BuildTable<T>(MarkdownBuilder mb, string label, T[] array, IEnumerable<XmlDocumentComment> docs, Func<T, string> type, Func<T, string> name, Func<T, string> finalName)
    {
        if (array.Any())
        {
            if (!string.IsNullOrEmpty(label))
            {
                mb.AppendLine(label);
                mb.AppendLine();
            }


            // NOTE: configure, no summary, return is right
            //string[] head = (this.type.IsEnum)
            //    ? new[] { "Value", "Name", "Summary" }
            //    : new[] { "Type", "Name", "Summary" };

            string[] head = (this.type.IsEnum)
                ? new[] { "Name", "Value" }
                : new[] { "Name(Parameter)", "ReturnType" };

            IEnumerable<T> seq = array;
            if (!this.type.IsEnum)
            {
                seq = array.OrderBy(x => name(x));
            }

            var data = seq.Select(item2 =>
            {
                var summary = docs.FirstOrDefault(x => x.MemberName == name(item2) || x.MemberName.StartsWith(name(item2) + "`"))?.Summary ?? "";
                // NOTE: modify
                // return new[] { MarkdownBuilder.MarkdownCodeQuote(type(item2)), finalName(item2), summary };
                return new[] { finalName(item2), MarkdownBuilder.MarkdownCodeQuote(type(item2)) };
            });

            mb.Table(head, data);
            mb.AppendLine();
        }
    }

    public override string ToString()
    {
        var mb = new MarkdownBuilder();

        //mb.HeaderWithCode(2, Beautifier.BeautifyType(type, false));
        //mb.AppendLine();

        //var desc = commentLookup[type.FullName].FirstOrDefault(x => x.MemberType == MemberType.Type)?.Summary ?? "";
        //if (desc != "")
        //{
        //    mb.AppendLine(desc);
        //}
        //{
        //    var sb = new StringBuilder();

        //    var stat = (type.IsAbstract && type.IsSealed) ? "static " : "";
        //    var abst = (type.IsAbstract && !type.IsInterface && !type.IsSealed) ? "abstract " : "";
        //    var classOrStructOrEnumOrInterface = type.IsInterface ? "interface" : type.IsEnum ? "enum" : type.IsValueType ? "struct" : "class";

        //    sb.AppendLine($"public {stat}{abst}{classOrStructOrEnumOrInterface} {Beautifier.BeautifyType(type, true)}");
        //    var impl = string.Join(", ", new[] { type.BaseType }.Concat(type.GetInterfaces()).Where(x => x != null && x != typeof(object) && x != typeof(ValueType)).Select(x => Beautifier.BeautifyType(x)));
        //    if (impl != "")
        //    {
        //        sb.AppendLine("    : " + impl);
        //    }

        //    mb.Code("csharp", sb.ToString());
        //}

        //mb.AppendLine();

        if (type.IsEnum)
        {
            var underlyingEnumType = Enum.GetUnderlyingType(type);

            var enums = Enum.GetNames(type)
                .Select(x => new { Name = x, Value = (Convert.ChangeType(Enum.Parse(type, x), underlyingEnumType)) })
                .OrderBy(x => x.Value)
                .ToArray();

            BuildTable(mb, "Enum", enums, commentLookup[type.FullName], x => x.Value.ToString(), x => x.Name, x => x.Name);
        }
        else
        {
            BuildTable(mb, "Fields", GetFields(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.FieldType), x => x.Name, x => x.Name);
            BuildTable(mb, "Properties", GetProperties(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.PropertyType), x => x.Name, x => x.Name);
            BuildTable(mb, "Events", GetEvents(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.EventHandlerType), x => x.Name, x => x.Name);
            BuildTable(mb, "Methods", GetMethods(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.ReturnType), x => x.Name, x => Beautifier.ToMarkdownMethodInfo(x));
            BuildTable(mb, "Static Fields", GetStaticFields(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.FieldType), x => x.Name, x => x.Name);
            // BuildTable(mb, "Static Properties", GetStaticProperties(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.PropertyType), x => x.Name, x => x.Name);
            // BuildTable(mb, "Static Methods", GetStaticMethods(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.ReturnType), x => x.Name, x => Beautifier.ToMarkdownMethodInfo(x));

            BuildTable(mb, "", GetStaticMethods(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.ReturnType), x => x.Name, x => Beautifier.ToMarkdownMethodInfo(x));
            BuildTable(mb, "Static Events", GetStaticEvents(), commentLookup[type.FullName], x => Beautifier.BeautifyType(x.EventHandlerType), x => x.Name, x => x.Name);
        }

        return mb.ToString();
    }
}


public static class MarkdownGenerator
{
    public static MarkdownableType[] Load(string dllPath, string namespaceMatch)
    {
        var xmlPath = Path.Combine(Directory.GetParent(dllPath).FullName, Path.GetFileNameWithoutExtension(dllPath) + ".xml");

        XmlDocumentComment[] comments = new XmlDocumentComment[0];
        if (File.Exists(xmlPath))
        {
            comments = VSDocParser.ParseXmlComment(XDocument.Parse(File.ReadAllText(xmlPath)), namespaceMatch);
        }
        var commentsLookup = comments.ToLookup(x => x.ClassName);

        var namespaceRegex =
            !string.IsNullOrEmpty(namespaceMatch) ? new Regex(namespaceMatch) : null;

        var markdownableTypes = new[] { Assembly.LoadFrom(dllPath) }
            .SelectMany(x =>
            {
                try
                {
                    return x.GetTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    return ex.Types.Where(t => t != null);
                }
                catch
                {
                    return Type.EmptyTypes;
                }
            })
            .Where(x => x != null)
            .Where(x => x.IsPublic && !typeof(Delegate).IsAssignableFrom(x) && !x.GetCustomAttributes<ObsoleteAttribute>().Any())
            .Where(x => IsRequiredNamespace(x, namespaceRegex))
            .Select(x => new MarkdownableType(x, commentsLookup))
            .ToArray();


        return markdownableTypes;
    }

    static bool IsRequiredNamespace(Type type, Regex regex)
    {
        if (regex == null)
        {
            return true;
        }
        return regex.IsMatch(type.Namespace != null ? type.Namespace : string.Empty);
    }
}



================================================
FILE: sandbox/ReferenceBuilder/MarkdownGenerator/VSDocParser.cs
================================================
﻿#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace MarkdownGenerator;

public enum MemberType
{
    Field = 'F',
    Property = 'P',
    Type = 'T',
    Event = 'E',
    Method = 'M',
    None = 0
}

public class XmlDocumentComment
{
    public MemberType MemberType { get; set; }
    public string ClassName { get; set; }
    public string MemberName { get; set; }
    public string Summary { get; set; }
    public string Remarks { get; set; }
    public Dictionary<string, string> Parameters { get; set; }
    public string Returns { get; set; }

    public override string ToString()
    {
        return MemberType + ":" + ClassName + "." + MemberName;
    }
}

public static class VSDocParser
{
    public static XmlDocumentComment[] ParseXmlComment(XDocument xDocument) {
        return ParseXmlComment(xDocument, null);
    }

    // cheap, quick hack parser:)
    internal static XmlDocumentComment[] ParseXmlComment(XDocument xDocument, string namespaceMatch) {

        var assemblyName = xDocument.Descendants("assembly").First().Elements("name").First().Value;

        return xDocument.Descendants("member")
            .Select(x => {
                var match = Regex.Match(x.Attribute("name").Value, @"(.):(.+)\.([^.()]+)?(\(.+\)|$)");
                if (!match.Groups[1].Success) return null;

                var memberType = (MemberType)match.Groups[1].Value[0];
                if (memberType == MemberType.None) return null;

                var summaryXml = x.Elements("summary").FirstOrDefault()?.ToString()
                    ?? x.Element("summary")?.ToString()
                    ?? "";
                summaryXml = Regex.Replace(summaryXml, @"<\/?summary>", string.Empty);
                summaryXml = Regex.Replace(summaryXml, @"<para\s*/>", Environment.NewLine);
                summaryXml = Regex.Replace(summaryXml, @"<see cref=""\w:([^\""]*)""\s*\/>", m => ResolveSeeElement(m, assemblyName));

                var parsed = Regex.Replace(summaryXml, @"<(type)*paramref name=""([^\""]*)""\s*\/>", e => $"`{e.Groups[1].Value}`");

                var summary = parsed;

                if (summary != "") {
                    summary = string.Join("  ", summary.Split(new[] { "\r", "\n", "\t" }, StringSplitOptions.RemoveEmptyEntries).Select(y => y.Trim()));
                }

                var returns = ((string)x.Element("returns")) ?? "";
                var remarks = ((string)x.Element("remarks")) ?? "";
                var parameters = x.Elements("param")
                    .Select(e => Tuple.Create(e.Attribute("name").Value, e))
                    .Distinct(new Item1EqualityCompaerer<string, XElement>())
                    .ToDictionary(e => e.Item1, e => e.Item2.Value);

                var className = (memberType == MemberType.Type)
                    ? match.Groups[2].Value + "." + match.Groups[3].Value
                    : match.Groups[2].Value;

                return new XmlDocumentComment {
                    MemberType = memberType,
                    ClassName = className,
                    MemberName = match.Groups[3].Value,
                    Summary = summary.Trim(),
                    Remarks = remarks.Trim(),
                    Parameters = parameters,
                    Returns = returns.Trim()
                };
            })
            .Where(x => x != null)
            .ToArray();
    }

    private static string ResolveSeeElement(Match m, string ns) {
        var typeName = m.Groups[1].Value;
        if (!string.IsNullOrWhiteSpace(ns)) {
            if (typeName.StartsWith(ns)) {
                return $"[{typeName}]({Regex.Replace(typeName, $"\\.(?:.(?!\\.))+$", me => me.Groups[0].Value.Replace(".", "#").ToLower())})";
            }
        }
        return $"`{typeName}`";
    }

    class Item1EqualityCompaerer<T1, T2> : EqualityComparer<Tuple<T1, T2>>
    {
        public override bool Equals(Tuple<T1, T2> x, Tuple<T1, T2> y)
        {
            return x.Item1.Equals(y.Item1);
        }

        public override int GetHashCode(Tuple<T1, T2> obj)
        {
            return obj.Item1.GetHashCode();
        }
    }
}



================================================
FILE: sandbox/UnoSampleApp/Directory.Build.props
================================================
<Project>
  <PropertyGroup>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>

    <!--
      Adding NoWarn to remove build warnings
      NU1507: Warning when there are multiple package sources when using CPM with no source mapping
      NETSDK1201: Warning that specifying RID won't create self containing app
      PRI257: Ignore default language (en) not being one of the included resources (eg en-us, en-uk)
    -->
    <NoWarn>$(NoWarn);NU1507;NETSDK1201;PRI257</NoWarn>
  </PropertyGroup>
</Project>



================================================
FILE: sandbox/UnoSampleApp/Directory.Build.targets
================================================
﻿<Project>
</Project>



================================================
FILE: sandbox/UnoSampleApp/Directory.Packages.props
================================================
<Project ToolsVersion="15.0">
  <!--
    To update the version of Uno, you should instead update the Sdk version in the global.json file.

    See https://aka.platform.uno/using-uno-sdk for more information.
    See https://aka.platform.uno/using-uno-sdk#implicit-packages for more information regarding the Implicit Packages.
  -->
  <ItemGroup>
  </ItemGroup>
</Project>



================================================
FILE: sandbox/UnoSampleApp/global.json
================================================
{
  // To update the version of Uno please update the version of the Uno.Sdk here. See https://aka.platform.uno/upgrade-uno-packages for more information.
  "msbuild-sdks": {
    "Uno.Sdk": "5.6.22"
  },
  "sdk":{
    "allowPrerelease": false
  }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp.sln
================================================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32210.308
MinimumVisualStudioVersion = 15.0.26124.0

Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnoSampleApp", "UnoSampleApp\UnoSampleApp.csproj", "{7D17C365-0C80-41D0-909B-43F13C6879DE}"
EndProject

Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{BADA71DC-7FFD-4EDC-9F28-FB74AEADC713}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitignore = .gitignore
		.vsconfig = .vsconfig
		Directory.Build.props = Directory.Build.props
		Directory.Build.targets = Directory.Build.targets
		Directory.Packages.props = Directory.Packages.props
		global.json = global.json
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "R3.Uno", "..\..\src\R3.Uno\R3.Uno.csproj", "{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "R3", "..\..\src\R3\R3.csproj", "{12DB8246-B61A-4A47-A373-A771CDB12C65}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|iPhone = Debug|iPhone
		Debug|iPhoneSimulator = Debug|iPhoneSimulator
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|iPhone = Release|iPhone
		Release|iPhoneSimulator = Release|iPhoneSimulator
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|Any CPU.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM64.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|ARM64.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhone.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhone.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhone.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhoneSimulator.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhoneSimulator.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|iPhoneSimulator.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x64.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x64.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x64.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x86.ActiveCfg = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x86.Build.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Debug|x86.Deploy.0 = Debug|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|Any CPU.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|Any CPU.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM64.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM64.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|ARM64.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhone.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhone.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhone.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhoneSimulator.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhoneSimulator.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|iPhoneSimulator.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x64.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x64.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x64.Deploy.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x86.ActiveCfg = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x86.Build.0 = Release|Any CPU
		{7D17C365-0C80-41D0-909B-43F13C6879DE}.Release|x86.Deploy.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|ARM.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|ARM64.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|iPhone.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|iPhone.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|iPhoneSimulator.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|iPhoneSimulator.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|x64.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Debug|x86.Build.0 = Debug|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|Any CPU.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|ARM.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|ARM.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|ARM64.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|ARM64.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|iPhone.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|iPhone.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|iPhoneSimulator.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|iPhoneSimulator.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|x64.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|x64.Build.0 = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|x86.ActiveCfg = Release|Any CPU
		{D4C6AFC0-6571-4E6E-9B97-B3462BB54C29}.Release|x86.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|ARM.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|ARM64.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|iPhone.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|iPhone.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|iPhoneSimulator.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|iPhoneSimulator.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|x64.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|x64.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|x86.ActiveCfg = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Debug|x86.Build.0 = Debug|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|Any CPU.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|ARM.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|ARM.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|ARM64.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|ARM64.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|iPhone.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|iPhone.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|iPhoneSimulator.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|iPhoneSimulator.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|x64.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|x64.Build.0 = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|x86.ActiveCfg = Release|Any CPU
		{12DB8246-B61A-4A47-A373-A771CDB12C65}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {77113347-F8DC-400B-B487-7FB9679B7AB9}
	EndGlobalSection
EndGlobal



================================================
FILE: sandbox/UnoSampleApp/.editorconfig
================================================
; This file is for unifying the coding style for different editors and IDEs.
; More information at http://editorconfig.org

# This file is the top-most EditorConfig file
root = true

##########################################
# Common Settings
##########################################

[*]
indent_style = space
trim_trailing_whitespace = true
insert_final_newline = true
charset = utf-8

##########################################
# File Extension Settings
##########################################

[*.{yml,yaml}]
indent_size = 2

[.vsconfig]
indent_size = 2
end_of_line = lf

[*.sln]
indent_style = tab
indent_size = 2

[*.{csproj,proj,projitems,shproj}]
indent_size = 4

[*.{json,slnf}]
indent_size = 2
end_of_line = lf

[*.{props,targets}]
indent_size = 4

[*.xaml]
indent_size = 4
charset = utf-8-bom

[*.xml]
indent_size = 4
end_of_line = lf

[*.plist]
indent_size = 4
indent_style = tab
end_of_line = lf

[*.manifest]
indent_size = 4

[*.appxmanifest]
indent_size = 4

[*.{json,css,webmanifest}]
indent_size = 2
end_of_line = lf

[web.config]
indent_size = 4
end_of_line = lf

[*.sh]
indent_size = 2
end_of_line = lf

[*.cs]
# EOL should be normalized by Git. See https://github.com/dotnet/format/issues/1099
end_of_line = unset

# See https://github.com/dotnet/roslyn/issues/20356#issuecomment-310143926
trim_trailing_whitespace = false

tab_width = 4
indent_size = 4

# Sort using and Import directives with System.* appearing first
dotnet_sort_system_directives_first = true

# Avoid "this." and "Me." if not necessary
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion

#### Naming styles ####

# Naming rules

dotnet_naming_rule.interface_should_be_begins_with_i.severity = suggestion
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications

dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers =

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers =

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers =

# Naming styles

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix =
dotnet_naming_style.begins_with_i.word_separator =
dotnet_naming_style.begins_with_i.capitalization = pascal_case

dotnet_naming_style.pascal_case.required_prefix =
dotnet_naming_style.pascal_case.required_suffix =
dotnet_naming_style.pascal_case.word_separator =
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.pascal_case.required_prefix =
dotnet_naming_style.pascal_case.required_suffix =
dotnet_naming_style.pascal_case.word_separator =
dotnet_naming_style.pascal_case.capitalization = pascal_case
dotnet_style_operator_placement_when_wrapping = beginning_of_line
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_auto_properties = true:silent
dotnet_style_object_initializer = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion

csharp_indent_labels = one_less_than_current
csharp_using_directive_placement = outside_namespace:silent
csharp_prefer_simple_using_statement = true:suggestion
csharp_prefer_braces = true:silent
csharp_style_namespace_declarations = file_scoped:warning
csharp_style_prefer_method_group_conversion = true:silent
csharp_style_prefer_top_level_statements = true:silent
csharp_style_prefer_primary_constructors = true:suggestion
csharp_style_expression_bodied_methods = false:silent
csharp_style_expression_bodied_constructors = false:silent
csharp_style_expression_bodied_operators = false:silent
csharp_style_expression_bodied_properties = true:silent
csharp_style_expression_bodied_indexers = true:silent
csharp_style_expression_bodied_accessors = true:silent
csharp_style_expression_bodied_lambdas = true:silent
csharp_style_expression_bodied_local_functions = false:silent



================================================
FILE: sandbox/UnoSampleApp/.vsconfig
================================================
{
  "version": "1.0",
  "components": [
    "Microsoft.VisualStudio.Component.CoreEditor",
    "Microsoft.VisualStudio.Workload.CoreEditor",
    "Microsoft.NetCore.Component.SDK",
    "Microsoft.NetCore.Component.DevelopmentTools",
    "Microsoft.Net.ComponentGroup.DevelopmentPrerequisites",
    "Microsoft.VisualStudio.Component.TextTemplating",
    "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions",
    "Microsoft.NetCore.Component.Web",
    "Microsoft.VisualStudio.Component.IISExpress",
    "Component.Microsoft.Web.LibraryManager",
    "Microsoft.VisualStudio.ComponentGroup.Web",
    "Microsoft.VisualStudio.Component.Web",
    "Microsoft.VisualStudio.ComponentGroup.Web.Client",
    "Microsoft.VisualStudio.Workload.NetWeb",
    "Microsoft.VisualStudio.ComponentGroup.WebToolsExtensions.TemplateEngine",
    "Microsoft.VisualStudio.ComponentGroup.MSIX.Packaging",
    "Microsoft.VisualStudio.Component.ManagedDesktop.Prerequisites",
    "Microsoft.VisualStudio.Component.Debugger.JustInTime",
    "Microsoft.VisualStudio.Workload.ManagedDesktop",
    "Component.Xamarin.RemotedSimulator",
    "Microsoft.VisualStudio.Component.MonoDebugger",
    "Microsoft.VisualStudio.ComponentGroup.Maui.All",
    "Component.Android.SDK34",
    "Component.OpenJDK",
    "Microsoft.VisualStudio.Workload.NetCrossPlat",
    "Microsoft.VisualStudio.Workload.NetCoreTools"
  ]
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/ReadMe.md
================================================
# Getting Started

Welcome to the Uno Platform!

To discover how to get started with your new app: https://aka.platform.uno/get-started

For more information on how to use the Uno.Sdk or upgrade Uno Platform packages in your solution: https://aka.platform.uno/using-uno-sdk


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/app.manifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="UnoSampleApp.Windows.app"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!--The ID below informs the system that this application is compatible with OS features first introduced in Windows 8.
      For more info see https://docs.microsoft.com/windows/win32/sysinfo/targeting-your-application-at-windows-8-1

      It is also necessary to support features in unpackaged applications, for example the custom titlebar implementation.-->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />
    </application>
  </compatibility>

  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <!-- The combination of below two tags have the following effect:
           1) Per-Monitor for >= Windows 10 Anniversary Update
           2) System < Windows 10 Anniversary Update
      -->
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/PM</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2, PerMonitor</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/App.xaml
================================================
<Application x:Class="UnoSampleApp.App"
       xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
       xmlns:utum="using:Uno.Toolkit.UI.Material">

  <Application.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>
        <!-- Load WinUI resources -->
        <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
        <utum:MaterialToolkitTheme
          ColorOverrideSource="ms-appx:///Styles/ColorPaletteOverride.xaml">
          <!-- NOTE: You can override the default Roboto font by providing your font assets here. -->
          <!-- <utum:MaterialToolkitTheme.FontOverrideDictionary>
            <ResourceDictionary>
              <FontFamily x:Key="MaterialLightFontFamily">ms-appx:///Uno.Fonts.Roboto/Fonts/Roboto-Light.ttf#Roboto</FontFamily>
              <FontFamily x:Key="MaterialMediumFontFamily">ms-appx:///Uno.Fonts.Roboto/Fonts/Roboto-Medium.ttf#Roboto</FontFamily>
              <FontFamily x:Key="MaterialRegularFontFamily">ms-appx:///Uno.Fonts.Roboto/Fonts/Roboto-Regular.ttf#Roboto</FontFamily>
            </ResourceDictionary>
          </utum:MaterialToolkitTheme.FontOverrideDictionary> -->
        </utum:MaterialToolkitTheme>
      </ResourceDictionary.MergedDictionaries>

      <!-- Add resources here -->

    </ResourceDictionary>
  </Application.Resources>

</Application>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/App.xaml.cs
================================================
using Uno;
using Uno.Resizetizer;

namespace UnoSampleApp;

public partial class App : Application
{
    /// <summary>
    /// Initializes the singleton application object. This is the first line of authored code
    /// executed, and as such is the logical equivalent of main() or WinMain().
    /// </summary>
    public App()
    {
        this.InitializeComponent();
    }

    protected Window? MainWindow { get; private set; }
    protected IHost? Host { get; private set; }

    protected async override void OnLaunched(LaunchActivatedEventArgs args)
    {
        var builder = this.CreateBuilder(args)
            .UseR3()
            // Add navigation support for toolkit controls such as TabBar and NavigationView
            .UseToolkitNavigation()
            .Configure(host => host
#if DEBUG
                // Switch to Development environment when running in DEBUG
                .UseEnvironment(Environments.Development)
#endif
                .UseLogging(configure: (context, logBuilder) =>
                {
                    // Configure log levels for different categories of logging
                    logBuilder
                        .SetMinimumLevel(
                            context.HostingEnvironment.IsDevelopment() ? LogLevel.Information : LogLevel.Warning)

                        // Default filters for core Uno Platform namespaces
                        .CoreLogLevel(LogLevel.Warning);

                    // Uno Platform namespace filter groups
                    // Uncomment individual methods to see more detailed logging
                    //// Generic Xaml events
                    //logBuilder.XamlLogLevel(LogLevel.Debug);
                    //// Layout specific messages
                    //logBuilder.XamlLayoutLogLevel(LogLevel.Debug);
                    //// Storage messages
                    //logBuilder.StorageLogLevel(LogLevel.Debug);
                    //// Binding related messages
                    //logBuilder.XamlBindingLogLevel(LogLevel.Debug);
                    //// Binder memory references tracking
                    //logBuilder.BinderMemoryReferenceLogLevel(LogLevel.Debug);
                    //// DevServer and HotReload related
                    //logBuilder.HotReloadCoreLogLevel(LogLevel.Information);
                    //// Debug JS interop
                    //logBuilder.WebAssemblyLogLevel(LogLevel.Debug);
                }, enableUnoLogging: true)
                .UseConfiguration(configure: configBuilder =>
                    configBuilder
                        .EmbeddedSource<App>()
                        .Section<AppConfig>()
                )
                // Enable localization (see appsettings.json for supported languages)
                .UseLocalization()
                // Register Json serializers (ISerializer and ISerializer)
                .UseSerialization((context, services) => services
                    .AddContentSerializer(context)
                    .AddJsonTypeInfo(WeatherForecastContext.Default.IImmutableListWeatherForecast))
                .UseHttp((context, services) => services
                    // Register HttpClient
#if DEBUG
                    // DelegatingHandler will be automatically injected into Refit Client
                    .AddTransient<DelegatingHandler, DebugHttpHandler>()
#endif
                    .AddSingleton<IWeatherCache, WeatherCache>()
                    .AddRefitClient<IApiClient>(context))
                .ConfigureServices((context, services) =>
                {
                    // TODO: Register your services
                    //services.AddSingleton<IMyService, MyService>();
                })
                .UseNavigation(RegisterRoutes)
            );

        MainWindow = builder.Window;

#if DEBUG
        MainWindow.UseStudio();
#endif
        MainWindow.SetWindowIcon();

        Host = await builder.NavigateAsync<Shell>();
    }

    private static void RegisterRoutes(IViewRegistry views, IRouteRegistry routes)
    {
        views.Register(
            new ViewMap(ViewModel: typeof(ShellViewModel)),
            new ViewMap<MainPage, MainViewModel>(),
            new DataViewMap<SecondPage, SecondViewModel, Entity>()
        );

        routes.Register(
            new RouteMap("", View: views.FindByViewModel<ShellViewModel>(),
                Nested:
                [
                    new("Main", View: views.FindByViewModel<MainViewModel>(), IsDefault: true),
                    new("Second", View: views.FindByViewModel<SecondViewModel>()),
                ]
            )
        );
    }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/appsettings.development.json
================================================
﻿{
  "AppConfig": {
    "Environment": "Development"
  },
  "ApiClient": {
    "Url": "https://localhost:5002",
    "UseNativeHandler": true
  }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/appsettings.json
================================================
{
  "AppConfig": {
    "Environment": "Production"
  },
  "ApiClient": {
    "UseNativeHandler": true
  },
  "LocalizationConfiguration": {
    "Cultures": [
      "es",
      "fr",
      "pt-BR",
      "en"
    ]
  }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/GlobalUsings.cs
================================================
﻿global using System.Collections.Immutable;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Hosting;
global using Microsoft.Extensions.Localization;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Options;
global using UnoSampleApp.Models;
global using UnoSampleApp.Presentation;
global using UnoSampleApp.DataContracts;
global using UnoSampleApp.DataContracts.Serialization;
global using UnoSampleApp.Services.Caching;
global using UnoSampleApp.Services.Endpoints;
global using ApplicationExecutionState = Windows.ApplicationModel.Activation.ApplicationExecutionState;
global using CommunityToolkit.Mvvm.ComponentModel;
global using CommunityToolkit.Mvvm.Input;


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Package.appxmanifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">

  <Identity />
  <Properties />

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate"/>
  </Resources>

  <Applications>
    <Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="$targetentrypoint$">
      <uap:VisualElements />
    </Application>
  </Applications>

  <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/UnoSampleApp.csproj
================================================
<Project Sdk="Uno.Sdk">
    <PropertyGroup>
        <TargetFrameworks>net8.0-android;net8.0-ios;net8.0-browserwasm;net8.0-desktop</TargetFrameworks>
        <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('macos'))">$(TargetFrameworks);net8.0-maccatalyst</TargetFrameworks>
        <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(TargetFrameworks);net8.0-windows10.0.26100</TargetFrameworks>
        <OutputType>Exe</OutputType>
        <UnoSingleProject>true</UnoSingleProject>

        <!-- Display name -->
        <ApplicationTitle>UnoSampleApp</ApplicationTitle>
        <!-- App Identifier -->
        <ApplicationId>com.companyname.UnoSampleApp</ApplicationId>
        <!-- Versions -->
        <ApplicationDisplayVersion>1.0</ApplicationDisplayVersion>
        <ApplicationVersion>1</ApplicationVersion>
        <!-- Package Publisher -->
        <ApplicationPublisher>O=UnoSampleApp</ApplicationPublisher>
        <!-- Package Description -->
        <Description>UnoSampleApp powered by Uno Platform.</Description>
        <!--
          If you encounter this error message:
    
            error NETSDK1148: A referenced assembly was compiled using a newer version of Microsoft.Windows.SDK.NET.dll.
            Please update to a newer .NET SDK in order to reference this assembly.
    
          This means that the two packages below must be aligned with the "build" version number of
          the "Microsoft.Windows.SDK.BuildTools" package above, and the "revision" version number
          must be the highest found in https://www.nuget.org/packages/Microsoft.Windows.SDK.NET.Ref.
        -->
        <!-- <WindowsSdkPackageVersion>10.0.22621.28</WindowsSdkPackageVersion> -->

        <!--
          UnoFeatures let's you quickly add and manage implicit package references based on the features you want to use.
          https://aka.platform.uno/singleproject-features
        -->
        <UnoFeatures>
            Material;
            Dsp;
            Hosting;
            Toolkit;
            Logging;
            Mvvm;
            Configuration;
            Http;
            Serialization;
            Localization;
            Navigation;
            ThemeService;
        </UnoFeatures>
    </PropertyGroup>
    <ItemGroup>
      <ProjectReference Include="..\..\..\src\R3.Uno\R3.Uno.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Assets/SharedAssets.md
================================================
# Shared Assets

See documentation about assets here: https://github.com/unoplatform/uno/blob/master/doc/articles/features/working-with-assets.md

## Here is a cheat sheet

1. Add the image file to the `Assets` directory of a shared project.
2. Set the build action to `Content`.
3. (Recommended) Provide an asset for various scales/dpi

### Examples

```text
\Assets\Images\logo.scale-100.png
\Assets\Images\logo.scale-200.png
\Assets\Images\logo.scale-400.png

\Assets\Images\scale-100\logo.png
\Assets\Images\scale-200\logo.png
\Assets\Images\scale-400\logo.png
```

### Table of scales

| Scale | WinUI       | iOS/MacCatalyst | Android |
|-------|:-----------:|:---------------:|:-------:|
| `100` | scale-100   | @1x             | mdpi    |
| `125` | scale-125   | N/A             | N/A     |
| `150` | scale-150   | N/A             | hdpi    |
| `200` | scale-200   | @2x             | xhdpi   |
| `300` | scale-300   | @3x             | xxhdpi  |
| `400` | scale-400   | N/A             | xxxhdpi |



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Models/AppConfig.cs
================================================
namespace UnoSampleApp.Models;

public record AppConfig
{
    public string? Environment { get; init; }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Models/Entity.cs
================================================
namespace UnoSampleApp.Models;

public record Entity(string Name);


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Models/WeatherForecast.cs
================================================
namespace UnoSampleApp.DataContracts;

/// <summary>
/// A Weather Forecast for a specific date
/// </summary>
/// <param name="Date">Gets the Date of the Forecast.</param>
/// <param name="TemperatureC">Gets the Forecast Temperature in Celsius.</param>
/// <param name="Summary">Get a description of how the weather will feel.</param>
public record WeatherForecast(DateOnly Date, double TemperatureC, string? Summary)
{
    /// <summary>
    /// Gets the Forecast Temperature in Fahrenheit
    /// </summary>
    public double TemperatureF => 32 + (TemperatureC * 9 / 5);
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
  <application android:allowBackup="true" android:supportsRtl="true"></application>
</manifest>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/environment.conf
================================================
# See this for more details: http://developer.xamarin.com/guides/android/advanced_topics/garbage_collection/
MONO_GC_PARAMS=bridge-implementation=tarjan,nursery-size=32m,soft-heap-limit=256m


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/Main.Android.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Android.App;
using Android.Content;
using Android.OS;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using Com.Nostra13.Universalimageloader.Core;
using Microsoft.UI.Xaml.Media;

namespace UnoSampleApp.Droid;

[global::Android.App.ApplicationAttribute(
    Label = "@string/ApplicationName",
    Icon = "@mipmap/icon",
    LargeHeap = true,
    HardwareAccelerated = true,
    Theme = "@style/AppTheme"
)]
public class Application : Microsoft.UI.Xaml.NativeApplication
{
    public Application(IntPtr javaReference, JniHandleOwnership transfer)
        : base(() => new App(), javaReference, transfer)
    {
        ConfigureUniversalImageLoader();
    }

    private static void ConfigureUniversalImageLoader()
    {
        // Create global configuration and initialize ImageLoader with this config
        ImageLoaderConfiguration config = new ImageLoaderConfiguration
                .Builder(Context)
            .Build();

        ImageLoader.Instance.Init(config);

        ImageSource.DefaultImageLoader = ImageLoader.Instance.LoadImageAsync;
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/MainActivity.Android.cs
================================================
using Android.App;
using Android.Content.PM;
using Android.OS;
using Android.Views;
using Android.Widget;

namespace UnoSampleApp.Droid;

[Activity(
    MainLauncher = true,
    ConfigurationChanges = global::Uno.UI.ActivityHelper.AllConfigChanges,
    WindowSoftInputMode = SoftInput.AdjustNothing | SoftInput.StateHidden
)]
public class MainActivity : Microsoft.UI.Xaml.ApplicationActivity
{
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/Assets/AboutAssets.txt
================================================
To add cross-platform image assets for your Uno Platform app, use the Assets folder
in the shared project instead. Assets in this folder are Android-only assets.

Any raw assets you want to be deployed with your application can be placed in
this directory (and child directories) and given a Build Action of "AndroidAsset".

These files will be deployed with your package and will be accessible using Android's
AssetManager, like this:

public class ReadAsset : Activity
{
	protected override void OnCreate (Bundle bundle)
	{
		base.OnCreate (bundle);

		InputStream input = Assets.Open ("my_asset.txt");
	}
}

Additionally, some Android functions will automatically load asset files:

Typeface tf = Typeface.CreateFromAsset (Context.Assets, "fonts/samplefont.ttf");



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/Resources/AboutResources.txt
================================================
To add cross-platform image assets for your Uno Platform app, use the Assets folder
in the shared project instead. Resources in this folder are Android-only.

Images, layout descriptions, binary blobs and string dictionaries can be included 
in your application as resource files.  Various Android APIs are designed to 
operate on the resource IDs instead of dealing with images, strings or binary blobs 
directly.

For example, a sample Android app that contains a user interface layout (main.axml),
an internationalization string table (strings.xml) and some icons (drawable-XXX/icon.png) 
would keep its resources in the "Resources" directory of the application:

Resources/
    drawable/
        icon.png

    layout/
        main.axml

    values/
        strings.xml

In order to get the build system to recognize Android resources, set the build action to
"AndroidResource".  The native Android APIs do not operate directly with filenames, but 
instead operate on resource IDs.  When you compile an Android application that uses resources, 
the build system will package the resources for distribution and generate a class called "R" 
(this is an Android convention) that contains the tokens for each one of the resources 
included. For example, for the above Resources layout, this is what the R class would expose:

public class R {
    public class drawable {
        public const int icon = 0x123;
    }

    public class layout {
        public const int main = 0x456;
    }

    public class strings {
        public const int first_string = 0xabc;
        public const int second_string = 0xbcd;
    }
}

You would then use R.drawable.icon to reference the drawable/icon.png file, or R.layout.main 
to reference the layout/main.axml file, or R.strings.first_string to reference the first 
string in the dictionary file values/strings.xml.



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/Resources/values/Strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="Hello">Hello World, Click Me!</string>
	<string name="ApplicationName">UnoSampleApp</string>
</resources>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Android/Resources/values/Styles.xml
================================================
<?xml version="1.0" encoding="utf-8" ?>
<resources>
	<style name="AppTheme" parent="Theme.MaterialComponents.Light">

		<!-- This removes the ActionBar -->
		<item name="windowActionBar">false</item>
		<item name="android:windowActionBar">false</item>
		<item name="windowNoTitle">true</item>
		<item name="android:windowNoTitle">true</item>

		<!-- uno_splash_color and uno_splash_image are generated by Uno.Resizetizer -->
		<!-- This property is used for the splash screen -->
		<item name="android:windowSplashScreenBackground">@color/uno_splash_color</item>
		<item name="android:windowBackground">@drawable/uno_splash_image</item>
		<item name="android:windowSplashScreenAnimatedIcon">@drawable/uno_splash_image</item>
	</style>
	<style name="Theme.AppCompat.Translucent">
		<item name="android:windowIsTranslucent">true</item>
		<item name="android:windowAnimationStyle">@android:style/Animation</item>
	</style>

</resources>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/Desktop/Program.cs
================================================
using Uno.UI.Runtime.Skia;

namespace UnoSampleApp;

public class Program
{
    [STAThread]
    public static void Main(string[] args)
    {
        var host = SkiaHostBuilder.Create()
            .App(() => new App())
            .UseX11()
            .UseLinuxFrameBuffer()
            .UseMacOS()
            .UseWindows()
            .Build();

        host.Run();
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/iOS/Entitlements.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
	</dict>
</plist>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/iOS/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>UIDeviceFamily</key>
		<array>
			<integer>1</integer>
			<integer>2</integer>
		</array>
		<key>UIRequiredDeviceCapabilities</key>
		<array>
			<string>armv7</string>
			<string>arm64</string>
		</array>
		<key>UISupportedInterfaceOrientations</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>UISupportedInterfaceOrientations~ipad</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationPortraitUpsideDown</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>UIViewControllerBasedStatusBarAppearance</key>
		<false/>
		<key>XSAppIconAssets</key>
		<string>Assets.xcassets/icon.appiconset</string>
		<key>UIApplicationSupportsIndirectInputEvents</key>
		<true/>

		<!--
		Adjust this to your application's encryption usage.
		<key>ITSAppUsesNonExemptEncryption</key>
		<false/>
		-->
	</dict>
</plist>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/iOS/Main.iOS.cs
================================================
using UIKit;

namespace UnoSampleApp.iOS;

public class EntryPoint
{
    // This is the main entry point of the application.
    public static void Main(string[] args)
    {
        // if you want to use a different Application Delegate class from "AppDelegate"
        // you can specify it here.
        UIApplication.Main(args, null, typeof(App));
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/iOS/PrivacyInfo.xcprivacy
================================================
﻿<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<!-- see https://aka.platform/uno/apple-privacy-manifest for more information -->
	
	<!-- .NET Runtime/BCL -->
	<dict>
		<key>NSPrivacyAccessedAPIType</key>
		<string>NSPrivacyAccessedAPICategoryFileTimestamp</string>
		<key>NSPrivacyAccessedAPITypeReasons</key>
		<array>
			<string>C617.1</string>
		</array>
	</dict>
	<dict>
		<key>NSPrivacyAccessedAPIType</key>
		<string>NSPrivacyAccessedAPICategorySystemBootTime</string>
		<key>NSPrivacyAccessedAPITypeReasons</key>
		<array>
			<string>35F9.1</string>
		</array>
	</dict>
	<dict>
		<key>NSPrivacyAccessedAPIType</key>
		<string>NSPrivacyAccessedAPICategoryDiskSpace</string>
		<key>NSPrivacyAccessedAPITypeReasons</key>
		<array>
			<string>E174.1</string>
		</array>
	</dict>

	<!-- NSUserDefaults -->
	<dict>
		<key>NSPrivacyAccessedAPIType</key>
		<string>NSPrivacyAccessedAPICategoryUserDefaults</string>
		<key>NSPrivacyAccessedAPITypeReasons</key>
		<array>
			<string>CA92.1</string>
		</array>
	</dict>
</plist>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/iOS/Media.xcassets/LaunchImages.launchimage/Contents.json
================================================
{
  "images": [
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "640x960",
      "idiom": "iphone"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "subtype": "retina4",
      "scale": "2x",
      "size": "640x1136",
      "idiom": "iphone"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "1x",
      "size": "768x1024",
      "idiom": "ipad"
    },
    {
      "orientation": "landscape",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "1x",
      "size": "1024x768",
      "idiom": "ipad"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "1536x2048",
      "idiom": "ipad"
    },
    {
      "orientation": "landscape",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "2048x1536",
      "idiom": "ipad"
    }
  ],
  "properties": {},
  "info": {
    "version": 1,
    "author": ""
  }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/MacCatalyst/Entitlements.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
	</dict>
</plist>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/MacCatalyst/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>UIDeviceFamily</key>
		<array>
			<integer>2</integer>
		</array>
		<key>LSApplicationCategoryType</key>
		<string>public.app-category.utilities</string>
		<key>UISupportedInterfaceOrientations</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>XSAppIconAssets</key>
		<string>Assets.xcassets/icon.appiconset</string>

		<!--
		Adjust this to your application's encryption usage.
		<key>ITSAppUsesNonExemptEncryption</key>
		<false/>
		-->
	</dict>
</plist>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/MacCatalyst/Main.maccatalyst.cs
================================================
using UIKit;

namespace UnoSampleApp.MacCatalyst;

public class EntryPoint
{
    // This is the main entry point of the application.
    public static void Main(string[] args)
    {
        // if you want to use a different Application Delegate class from "AppDelegate"
        // you can specify it here.
        UIApplication.Main(args, null, typeof(App));
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/MacCatalyst/Media.xcassets/LaunchImages.launchimage/Contents.json
================================================
{
  "images": [
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "640x960",
      "idiom": "iphone"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "subtype": "retina4",
      "scale": "2x",
      "size": "640x1136",
      "idiom": "iphone"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "1x",
      "size": "768x1024",
      "idiom": "ipad"
    },
    {
      "orientation": "landscape",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "1x",
      "size": "1024x768",
      "idiom": "ipad"
    },
    {
      "orientation": "portrait",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "1536x2048",
      "idiom": "ipad"
    },
    {
      "orientation": "landscape",
      "extent": "full-screen",
      "minimum-system-version": "7.0",
      "scale": "2x",
      "size": "2048x1536",
      "idiom": "ipad"
    }
  ],
  "properties": {},
  "info": {
    "version": 1,
    "author": ""
  }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/LinkerConfig.xml
================================================
<linker>
  <assembly fullname="UnoSampleApp" />

  <!--
  Uncomment this section when using JSON.NET
  <assembly fullname="System.Core">
    <type fullname="System.Linq.Expressions*" />
  </assembly>
   -->
</linker>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/manifest.webmanifest
================================================
{
  "background_color": "#ffffff",
  "description": "UnoSampleApp",
  "display": "standalone",
  "name": "UnoSampleApp",
  "short_name": "UnoSampleApp",
  "start_url": "/index.html",
  "theme_color": "#ffffff",
  "scope": "/"
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/Program.cs
================================================
namespace UnoSampleApp;

public class Program
{
    private static App? _app;

    public static int Main(string[] args)
    {
        Microsoft.UI.Xaml.Application.Start(_ => _app = new App());

        return 0;
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/WasmCSS/Fonts.css
================================================
/**
  When adding fonts here, make sure to add them using a base64 data uri, otherwise
  fonts loading are delayed, and text may get displayed incorrectly.
*/

/* https://github.com/unoplatform/uno/issues/3954 */
@font-face {
  font-family: 'Segoe UI';
  src: local('Segoe UI'), local('-apple-system'), local('BlinkMacSystemFont'), local('Inter'), local('Cantarell'), local('Ubuntu'), local('Roboto'), local('Open Sans'), local('Noto Sans'), local('Helvetica Neue'), local('sans-serif');
}

@font-face {
  font-family: 'Roboto';
  src: url(./Uno.Fonts.Roboto/Fonts/Roboto-Light.ttf) format('truetype');
  font-weight: 300;
}

@font-face {
  font-family: 'Roboto';
  src: url(./Uno.Fonts.Roboto/Fonts/Roboto-Regular.ttf) format('truetype');
  font-weight: 400;
}

@font-face {
  font-family: 'Roboto';
  src: url(./Uno.Fonts.Roboto/Fonts/Roboto-Medium.ttf) format('truetype');
  font-weight: 500;
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/WasmScripts/AppManifest.js
================================================
var UnoAppManifest = {
    displayName: "UnoSampleApp"
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/wwwroot/staticwebapp.config.json
================================================
{
  "navigationFallback": {
    "rewrite": "/index.html",
    "exclude": [
      "*.{css,js}",
      "*.{png}",
      "*.{c,h,wasm,clr,pdb,dat,txt}"
    ]
  },
  "routes": [
    {
      "route": "/package_*",
      "headers": {
        "cache-control": "public, immutable, max-age=31536000"
      }
    },
    {
      "route": "/*.ttf",
      "headers": {
        "cache-control": "public, immutable, max-age=31536000"
      }
    },
    {
      "route": "/*",
      "headers": {
        "cache-control": "must-revalidate, max-age=3600"
      }
    }
  ]
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Platforms/WebAssembly/wwwroot/web.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.web>
    <customErrors mode="Off"/>
  </system.web>

  <system.webServer>

    <!-- Disable compression as we're doing it through pre-compressed files -->
    <urlCompression doStaticCompression="false" doDynamicCompression="false" dynamicCompressionBeforeCache="false" />

    <staticContent>
      <remove fileExtension=".dll" />
      <remove fileExtension=".wasm" />
      <remove fileExtension=".woff" />
      <remove fileExtension=".woff2" />
      <mimeMap fileExtension=".wasm" mimeType="application/wasm" />
      <mimeMap fileExtension=".clr" mimeType="application/octet-stream" />
      <mimeMap fileExtension=".pdb" mimeType="application/octet-stream" />
      <mimeMap fileExtension=".woff" mimeType="application/font-woff" />
      <mimeMap fileExtension=".woff2" mimeType="application/font-woff" />
      <mimeMap fileExtension=".dat" mimeType="application/octet-stream" />
      <!-- Required for PWAs -->
      <mimeMap fileExtension=".json" mimeType="application/octet-stream" />
    </staticContent>

    <rewrite>
      <rules>
        <rule name="Lookup for pre-compressed brotli file" stopProcessing="true">
          <match url="(.*)$"/>
          <conditions>
            <!-- Match brotli requests -->
            <add input="{HTTP_ACCEPT_ENCODING}" pattern="br" />
            
            <!-- Match all but pre-compressed files -->
            <add input="{REQUEST_URI}" pattern="^(?!/_compressed_br/)(.*)$" />

            <!-- Check if the pre-compressed file exists on the disk -->
            <add input="{DOCUMENT_ROOT}/_compressed_br/{C:0}" matchType="IsFile" negate="false" />
          </conditions>
          <action type="Rewrite" url="/_compressed_br{C:0}" />
        </rule>

        <rule name="Lookup for pre-compressed gzip file" stopProcessing="true">
          <match url="(.*)$"/>
          <conditions>
            <!-- Match gzip requests -->
            <add input="{HTTP_ACCEPT_ENCODING}" pattern="gzip" />
            
            <!-- Match all but pre-compressed files -->
            <add input="{REQUEST_URI}" pattern="^(?!/_compressed_gz/)(.*)$" />
            
            <!-- Check if the pre-compressed file exists on the disk -->
            <add input="{DOCUMENT_ROOT}/_compressed_gz/{C:0}" matchType="IsFile" negate="false" />
          </conditions>
          <action type="Rewrite" url="/_compressed_gz{C:0}" />
        </rule>
      </rules>

      <outboundRules>
        <rule name="Adjust content encoding for gzip pre-compressed files" enabled="true" stopProcessing="true">
          <match serverVariable="RESPONSE_CONTENT_ENCODING" pattern="" />
          <conditions>
            <add input="{REQUEST_URI}" pattern="/_compressed_gz/.*$" />
          </conditions>
          <action type="Rewrite" value="gzip"/>
        </rule>
        <rule name="Adjust content encoding for brotli pre-compressed files" enabled="true" stopProcessing="true">
          <match serverVariable="RESPONSE_CONTENT_ENCODING" pattern="" />
          <conditions>
            <add input="{REQUEST_URI}" pattern="/_compressed_br/.*$" />
          </conditions>
          <action type="Rewrite" value="br"/>
        </rule>
      </outboundRules>
    </rewrite>
  </system.webServer>
</configuration>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/MainPage.xaml
================================================
﻿<Page x:Class="UnoSampleApp.Presentation.MainPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:UnoSampleApp.Presentation"
      xmlns:uen="using:Uno.Extensions.Navigation.UI"
      xmlns:utu="using:Uno.Toolkit.UI"
      xmlns:um="using:Uno.Material"
      NavigationCacheMode="Required"
      Background="{ThemeResource BackgroundBrush}">
  <ScrollViewer>
    <Grid utu:SafeArea.Insets="VisibleBounds">
      <Grid.RowDefinitions>
        <RowDefinition Height="Auto" />
        <RowDefinition />
      </Grid.RowDefinitions>
      <utu:NavigationBar Content="{Binding Title}" />

      <StackPanel Grid.Row="1"
            HorizontalAlignment="Center"
            VerticalAlignment="Center"
            Spacing="16">
        <TextBox Name="Name" Text="{Binding Name, Mode=TwoWay}"
            PlaceholderText="Enter your name:" />
        <TextBlock Name="textBlock" />
        <TextBlock Name="update" />
        <Button Content="Go to Second Page"
            AutomationProperties.AutomationId="SecondPageButton"
            Command="{Binding GoToSecond}" />
      </StackPanel>
    </Grid>
  </ScrollViewer>
</Page>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/MainPage.xaml.cs
================================================
﻿using R3;

namespace UnoSampleApp.Presentation;

public sealed partial class MainPage : Page
{
    public MainPage()
    {
        this.InitializeComponent();
        
        Observable.EveryUpdate()
            .Index()
            .Subscribe(update, (index, state) =>
            {
                state.Text = $"Counter: {index}";
            });
        
        Observable
            .EveryValueChanged(this, x => x.ActualSize)
            .Subscribe(
                textBlock, 
                (size, state) =>
                {
                    state.Text = $"Size: {size.X} x {size.Y} y";
                });
    }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/MainViewModel.cs
================================================
namespace UnoSampleApp.Presentation;

public partial class MainViewModel : ObservableObject
{
    private INavigator _navigator;

    [ObservableProperty] private string? name;

    public MainViewModel(
        IStringLocalizer localizer,
        IOptions<AppConfig> appInfo,
        INavigator navigator)
    {
        _navigator = navigator;
        Title = "Main";
        Title += $" - {localizer["ApplicationName"]}";
        Title += $" - {appInfo?.Value?.Environment}";
        GoToSecond = new AsyncRelayCommand(GoToSecondView);
    }

    public string? Title { get; }

    public ICommand GoToSecond { get; }

    private async Task GoToSecondView()
    {
        await _navigator.NavigateViewModelAsync<SecondViewModel>(this, data: new Entity(Name!));
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/SecondPage.xaml
================================================
﻿<Page x:Class="UnoSampleApp.Presentation.SecondPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:UnoSampleApp.Presentation"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:uen="using:Uno.Extensions.Navigation.UI"
      xmlns:utu="using:Uno.Toolkit.UI"
      xmlns:um="using:Uno.Material"
      Background="{ThemeResource BackgroundBrush}">

  <Grid utu:SafeArea.Insets="VisibleBounds">
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto" />
      <RowDefinition />
    </Grid.RowDefinitions>
    <utu:NavigationBar Content="Second Page">
      <utu:NavigationBar.MainCommand>
        <AppBarButton>
          <AppBarButton.Icon>
            <BitmapIcon UriSource="ms-appx:///Assets/Images/back.png" />
          </AppBarButton.Icon>
        </AppBarButton>
      </utu:NavigationBar.MainCommand>
    </utu:NavigationBar>
    <StackPanel Grid.Row="1"
          HorizontalAlignment="Center"
          VerticalAlignment="Center">
      <TextBlock Text="{Binding Entity.Name}"
        HorizontalAlignment="Center"
        VerticalAlignment="Center"
        Margin="8" />
    </StackPanel>

  </Grid>
</Page>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/SecondPage.xaml.cs
================================================
﻿namespace UnoSampleApp.Presentation;

public sealed partial class SecondPage : Page
{
    public SecondPage()
    {
        this.InitializeComponent();
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/SecondViewModel.cs
================================================
namespace UnoSampleApp.Presentation;

public partial record SecondViewModel(Entity Entity)
{
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/Shell.xaml
================================================
﻿<UserControl x:Class="UnoSampleApp.Presentation.Shell"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:local="using:UnoSampleApp.Presentation"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:utu="using:Uno.Toolkit.UI"
      mc:Ignorable="d"
      d:DesignHeight="300"
      d:DesignWidth="400">
  <Border Background="{ThemeResource BackgroundBrush}">
    <utu:ExtendedSplashScreen x:Name="Splash"
                HorizontalAlignment="Stretch"
                VerticalAlignment="Stretch"
                HorizontalContentAlignment="Stretch"
                VerticalContentAlignment="Stretch">
      <utu:ExtendedSplashScreen.LoadingContentTemplate>
        <DataTemplate>
          <Grid>
            <Grid.RowDefinitions>
              <RowDefinition Height="2*" />
              <RowDefinition />
            </Grid.RowDefinitions>

            <ProgressRing IsActive="True"
                  Grid.Row="1"
                  VerticalAlignment="Center"
                  HorizontalAlignment="Center"
                  Height="100"
                  Width="100" />
          </Grid>
        </DataTemplate>
      </utu:ExtendedSplashScreen.LoadingContentTemplate>
    </utu:ExtendedSplashScreen>
  </Border>
</UserControl>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/Shell.xaml.cs
================================================
﻿namespace UnoSampleApp.Presentation;

public sealed partial class Shell : UserControl, IContentControlProvider
{
    public Shell()
    {
        this.InitializeComponent();
    }

    public ContentControl ContentControl => Splash;
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Presentation/ShellViewModel.cs
================================================
namespace UnoSampleApp.Presentation;

public class ShellViewModel
{
    private readonly INavigator _navigator;

    public ShellViewModel(
        INavigator navigator)
    {
        _navigator = navigator;
        // Add code here to initialize or attach event handlers to singleton services
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Properties/launchSettings.json
================================================
{
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:8080",
      "sslPort": 0
    }
  },
  "profiles": {
    // This profile is first in order for dotnet run to pick it up by default
    "UnoSampleApp (WebAssembly)": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5000",
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "UnoSampleApp (WebAssembly IIS Express)": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    // Note: In order to select this profile, you'll need to comment the `Packaged` profile below until this is fixed: https://aka.platform.uno/wasdk-maui-debug-profile-issue
    "UnoSampleApp (WinAppSDK Unpackaged)": {
      "commandName": "Project",
      "compatibleTargetFramework": "windows"
    },
    "UnoSampleApp (WinAppSDK Packaged)": {
      "commandName": "MsixPackage",
      "compatibleTargetFramework": "windows"
    },
    "UnoSampleApp (Desktop)": {
      "commandName": "Project",
      "compatibleTargetFramework": "desktop"
    },
    "UnoSampleApp (Desktop WSL2)": {
      "commandName": "WSL2",
      "commandLineArgs": "{ProjectDir}/bin/Debug/net8.0-desktop/UnoSampleApp.dll",
      "distributionName": "",
      "compatibleTargetFramework": "desktop"
    }
  }
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Properties/PublishProfiles/win-arm64.pubxml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<PublishProtocol>FileSystem</PublishProtocol>
		<Platform>arm64</Platform>
		<RuntimeIdentifier>win-arm64</RuntimeIdentifier>
		<PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
		<SelfContained>true</SelfContained>
		<PublishSingleFile>False</PublishSingleFile>
		<PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
		<PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
		<PublishTrimmed Condition="'$(Configuration)' == 'Debug'">False</PublishTrimmed>
		<PublishTrimmed Condition="'$(Configuration)' != 'Debug'">True</PublishTrimmed>
	</PropertyGroup>
</Project>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Properties/PublishProfiles/win-x64.pubxml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<PublishProtocol>FileSystem</PublishProtocol>
		<Platform>x64</Platform>
		<RuntimeIdentifier>win-x64</RuntimeIdentifier>
		<PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
		<SelfContained>true</SelfContained>
		<PublishSingleFile>False</PublishSingleFile>
		<PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
		<PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
		<PublishTrimmed Condition="'$(Configuration)' == 'Debug'">False</PublishTrimmed>
		<PublishTrimmed Condition="'$(Configuration)' != 'Debug'">True</PublishTrimmed>
	</PropertyGroup>
</Project>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Properties/PublishProfiles/win-x86.pubxml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<PublishProtocol>FileSystem</PublishProtocol>
		<Platform>x86</Platform>
		<RuntimeIdentifier>win-x86</RuntimeIdentifier>
		<PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
		<SelfContained>true</SelfContained>
		<PublishSingleFile>False</PublishSingleFile>
		<PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
		<PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
		<PublishTrimmed Condition="'$(Configuration)' == 'Debug'">False</PublishTrimmed>
		<PublishTrimmed Condition="'$(Configuration)' != 'Debug'">True</PublishTrimmed>
		<!-- 
		<PublishTrimmed Condition="'$(Configuration)' != 'Debug'">True</PublishTrimmed>
		<TrimMode>partial</TrimMode>
		<SuppressTrimAnalysisWarnings>true</SuppressTrimAnalysisWarnings> 
		-->
	</PropertyGroup>
</Project>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Serialization/WeatherForecastContext.cs
================================================
using System.Collections.Immutable;
using System.Text.Json.Serialization;

namespace UnoSampleApp.DataContracts.Serialization;

/// <summary>
/// Generated class for System.Text.Json Serialization
/// </summary>
/// <remarks>
/// When using the JsonSerializerContext you must add the JsonSerializableAttribute
/// for each type that you may need to serialize / deserialize including both the
/// concrete type and any interface that the concrete type implements.
/// For more information on the JsonSerializerContext see:
/// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation?WT.mc_id=DT-MVP-5002924
/// </remarks>
[JsonSerializable(typeof(WeatherForecast))]
[JsonSerializable(typeof(WeatherForecast[]))]
[JsonSerializable(typeof(IEnumerable<WeatherForecast>))]
[JsonSerializable(typeof(IImmutableList<WeatherForecast>))]
[JsonSerializable(typeof(ImmutableList<WeatherForecast>))]
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
public partial class WeatherForecastContext : JsonSerializerContext
{
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Services/Caching/IWeatherCache.cs
================================================
namespace UnoSampleApp.Services.Caching;

public interface IWeatherCache
{
    ValueTask<IImmutableList<WeatherForecast>> GetForecast(CancellationToken token);
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Services/Caching/WeatherCache.cs
================================================
using System.Net;

namespace UnoSampleApp.Services.Caching;

public sealed class WeatherCache : IWeatherCache
{
    private readonly IApiClient _api;
    private readonly ISerializer _serializer;
    private readonly ILogger _logger;

    public WeatherCache(IApiClient api, ISerializer serializer, ILogger<WeatherCache> logger)
    {
        _api = api;
        _serializer = serializer;
        _logger = logger;
    }

    private bool IsConnected => NetworkInformation.GetInternetConnectionProfile().GetNetworkConnectivityLevel() ==
                                NetworkConnectivityLevel.InternetAccess;

    public async ValueTask<IImmutableList<WeatherForecast>> GetForecast(CancellationToken token)
    {
        var weatherText = await GetCachedWeather(token);
        if (!string.IsNullOrWhiteSpace(weatherText))
        {
            return _serializer.FromString<ImmutableArray<WeatherForecast>>(weatherText);
        }

        if (!IsConnected)
        {
            _logger.LogWarning("App is offline and cannot connect to the API.");
            throw new WebException("No internet connection", WebExceptionStatus.ConnectFailure);
        }

        var response = await _api.GetWeather(token);

        if (response.IsSuccessStatusCode && response.Content is not null)
        {
            var weather = response.Content;
            await Save(weather, token);
            return weather;
        }
        else if (response.Error is not null)
        {
            _logger.LogError(response.Error, "An error occurred while retrieving the latest Forecast.");
            throw response.Error;
        }
        else
        {
            return ImmutableArray<WeatherForecast>.Empty;
        }
    }

    private static async ValueTask<StorageFile> GetFile(CreationCollisionOption option) =>
        await ApplicationData.Current.TemporaryFolder.CreateFileAsync("weather.json", option);

    private async ValueTask<string?> GetCachedWeather(CancellationToken token)
    {
        var file = await GetFile(CreationCollisionOption.OpenIfExists);
        var properties = await file.GetBasicPropertiesAsync();

        // Reuse latest cache file if offline
        // or if the file is less than 5 minutes old
        if (IsConnected || DateTimeOffset.Now.AddMinutes(-5) > properties.DateModified || token.IsCancellationRequested)
        {
            return null;
        }

        return await File.ReadAllTextAsync(file.Path, token);
    }

    private async ValueTask Save(IImmutableList<WeatherForecast> weather, CancellationToken token)
    {
        var weatherText = _serializer.ToString(weather);
        var file = await GetFile(CreationCollisionOption.ReplaceExisting);
        await File.WriteAllTextAsync(file.Path, weatherText, token);
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Services/Endpoints/DebugHandler.cs
================================================
namespace UnoSampleApp.Services.Endpoints;

internal class DebugHttpHandler : DelegatingHandler
{
    private readonly ILogger _logger;

    public DebugHttpHandler(ILogger<DebugHttpHandler> logger, HttpMessageHandler? innerHandler = null)
        : base(innerHandler ?? new HttpClientHandler())
    {
        _logger = logger;
    }

    protected async override Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        var response = await base.SendAsync(request, cancellationToken);
#if DEBUG
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogDebugMessage("Unsuccessful API Call");
            if (request.RequestUri is not null)
            {
                _logger.LogDebugMessage($"{request.RequestUri} ({request.Method})");
            }

            foreach ((var key, var values) in request.Headers.ToDictionary(x => x.Key, x => string.Join(", ", x.Value)))
            {
                _logger.LogDebugMessage($"{key}: {values}");
            }

            var content = request.Content is not null ? await request.Content.ReadAsStringAsync() : null;
            if (!string.IsNullOrEmpty(content))
            {
                _logger.LogDebugMessage(content);
            }

            // Uncomment to automatically break when an API call fails while debugging
            // System.Diagnostics.Debugger.Break();
        }
#endif
        return response;
    }
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Services/Endpoints/IApiClient.cs
================================================
using Refit;

namespace UnoSampleApp.Services.Endpoints;

[Headers("Content-Type: application/json")]
public interface IApiClient
{
    [Get("/api/weatherforecast")]
    Task<ApiResponse<IImmutableList<WeatherForecast>>> GetWeather(CancellationToken cancellationToken = default);
}


================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Strings/en/Resources.resw
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApplicationName" xml:space="preserve">
    <value>UnoSampleApp-en</value>
  </data>
</root>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Strings/es/Resources.resw
================================================
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApplicationName" xml:space="preserve">
    <value>UnoSampleApp-es</value>
  </data>
</root>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Strings/fr/Resources.resw
================================================
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApplicationName" xml:space="preserve">
    <value>UnoSampleApp-fr</value>
  </data>
</root>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Strings/pt-BR/Resources.resw
================================================
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApplicationName" xml:space="preserve">
    <value>UnoSampleApp-pt-BR</value>
  </data>
</root>



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Styles/ColorPaletteOverride.json
================================================
{
    "description": "Default Uno Material colors",
    "seed": "#5946d2",
    "coreColors": {
        "primary": "#5946d2",
        "secondary": "#6b4ea2"
    },
    "extendedColors": [],
    "schemes": {
        "light": {
            "primary": "#5946d2",
            "surfaceTint": "#5946d2",
            "onPrimary": "#ffffff",
            "primaryContainer": "#e5deff",
            "onPrimaryContainer": "#170065",
            "secondary": "#6b4ea2",
            "onSecondary": "#ffffff",
            "secondaryContainer": "#ebddff",
            "onSecondaryContainer": "#220555",
            "tertiary": "#0061a4",
            "onTertiary": "#ffffff",
            "tertiaryContainer": "#cfe4ff",
            "onTertiaryContainer": "#001d36",
            "error": "#b3261e",
            "onError": "#ffffff",
            "errorContainer": "#f9dedc",
            "onErrorContainer": "#410e0b",
            "background": "#fcfbff",
            "onBackground": "#1c1b1f",
            "surface": "#ffffff",
            "onSurface": "#1c1b1f",
            "surfaceVariant": "#f2eff5",
            "onSurfaceVariant": "#8b8494",
            "outline": "#79747e",
            "outlineVariant": "#c9c5d0",
            "shadow": "#000000",
            "scrim": "#000000",
            "inverseSurface": "#e6e1e5",
            "inverseOnSurface": "#1c1b1f",
            "inversePrimary": "#2a009f"
        },
        "dark": {
            "primary": "#c7bfff",
            "surfaceTint": "#c7bfff",
            "onPrimary": "#2a009f",
            "primaryContainer": "#4129ba",
            "onPrimaryContainer": "#e4dfff",
            "secondary": "#cdc2dc",
            "onSecondary": "#332d41",
            "secondaryContainer": "#433c52",
            "onSecondaryContainer": "#eddfff",
            "tertiary": "#9fcaff",
            "onTertiary": "#003258",
            "tertiaryContainer": "#00497d",
            "onTertiaryContainer": "#d1e4ff",
            "error": "#ffb4ab",
            "onError": "#690005",
            "errorContainer": "#93000a",
            "onErrorContainer": "#ffdad6",
            "background": "#1c1b1f",
            "onBackground": "#e5e1e6",
            "surface": "#302d37",
            "onSurface": "#e6e1e5",
            "surfaceVariant": "#47464f",
            "onSurfaceVariant": "#c9c5d0",
            "outline": "#928f99",
            "outlineVariant": "#57545d",
            "shadow": "#000000",
            "scrim": "#000000",
            "inverseSurface": "#e6e1e5",
            "inverseOnSurface": "#1c1b1f",
            "inversePrimary": "#2a009f"
        }
    },
    "palettes": {}
}



================================================
FILE: sandbox/UnoSampleApp/UnoSampleApp/Styles/ColorPaletteOverride.xaml
================================================
﻿<!-- This file is generated by a tool from the file ColorPaletteOverride.json - - YOU SHOULD NOT EDIT IT manually.-->
<ResourceDictionary xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
  <ResourceDictionary.ThemeDictionaries>
    <ResourceDictionary x:Key="Light">
      <Color x:Key="PrimaryColor">#5946D2</Color>
      <Color x:Key="SurfaceTintColor">#5946D2</Color>
      <Color x:Key="OnPrimaryColor">#FFFFFF</Color>
      <Color x:Key="PrimaryContainerColor">#E5DEFF</Color>
      <Color x:Key="OnPrimaryContainerColor">#170065</Color>
      <Color x:Key="SecondaryColor">#6B4EA2</Color>
      <Color x:Key="OnSecondaryColor">#FFFFFF</Color>
      <Color x:Key="SecondaryContainerColor">#EBDDFF</Color>
      <Color x:Key="OnSecondaryContainerColor">#220555</Color>
      <Color x:Key="TertiaryColor">#0061A4</Color>
      <Color x:Key="OnTertiaryColor">#FFFFFF</Color>
      <Color x:Key="TertiaryContainerColor">#CFE4FF</Color>
      <Color x:Key="OnTertiaryContainerColor">#001D36</Color>
      <Color x:Key="ErrorColor">#B3261E</Color>
      <Color x:Key="OnErrorColor">#FFFFFF</Color>
      <Color x:Key="ErrorContainerColor">#F9DEDC</Color>
      <Color x:Key="OnErrorContainerColor">#410E0B</Color>
      <Color x:Key="BackgroundColor">#FCFBFF</Color>
      <Color x:Key="OnBackgroundColor">#1C1B1F</Color>
      <Color x:Key="SurfaceColor">#FFFFFF</Color>
      <Color x:Key="OnSurfaceColor">#1C1B1F</Color>
      <Color x:Key="SurfaceVariantColor">#F2EFF5</Color>
      <Color x:Key="OnSurfaceVariantColor">#8B8494</Color>
      <Color x:Key="OutlineColor">#79747E</Color>
      <Color x:Key="OutlineVariantColor">#C9C5D0</Color>
      <Color x:Key="SurfaceInverseColor">#E6E1E5</Color>
      <Color x:Key="OnsurfaceInverseColor">#1C1B1F</Color>
      <Color x:Key="PrimaryInverseColor">#2A009F</Color>
    </ResourceDictionary>
    <ResourceDictionary x:Key="Dark">
      <Color x:Key="PrimaryColor">#C7BFFF</Color>
      <Color x:Key="SurfaceTintColor">#C7BFFF</Color>
      <Color x:Key="OnPrimaryColor">#2A009F</Color>
      <Color x:Key="PrimaryContainerColor">#4129BA</Color>
      <Color x:Key="OnPrimaryContainerColor">#E4DFFF</Color>
      <Color x:Key="SecondaryColor">#CDC2DC</Color>
      <Color x:Key="OnSecondaryColor">#332D41</Color>
      <Color x:Key="SecondaryContainerColor">#433C52</Color>
      <Color x:Key="OnSecondaryContainerColor">#EDDFFF</Color>
      <Color x:Key="TertiaryColor">#9FCAFF</Color>
      <Color x:Key="OnTertiaryColor">#003258</Color>
      <Color x:Key="TertiaryContainerColor">#00497D</Color>
      <Color x:Key="OnTertiaryContainerColor">#D1E4FF</Color>
      <Color x:Key="ErrorColor">#FFB4AB</Color>
      <Color x:Key="OnErrorColor">#690005</Color>
      <Color x:Key="ErrorContainerColor">#93000A</Color>
      <Color x:Key="OnErrorContainerColor">#FFDAD6</Color>
      <Color x:Key="BackgroundColor">#1C1B1F</Color>
      <Color x:Key="OnBackgroundColor">#E5E1E6</Color>
      <Color x:Key="SurfaceColor">#302D37</Color>
      <Color x:Key="OnSurfaceColor">#E6E1E5</Color>
      <Color x:Key="SurfaceVariantColor">#47464F</Color>
      <Color x:Key="OnSurfaceVariantColor">#C9C5D0</Color>
      <Color x:Key="OutlineColor">#928F99</Color>
      <Color x:Key="OutlineVariantColor">#57545D</Color>
      <Color x:Key="SurfaceInverseColor">#E6E1E5</Color>
      <Color x:Key="OnsurfaceInverseColor">#1C1B1F</Color>
      <Color x:Key="PrimaryInverseColor">#2A009F</Color>
    </ResourceDictionary>
  </ResourceDictionary.ThemeDictionaries>
</ResourceDictionary>


================================================
FILE: sandbox/UnoSampleApp/.run/Readme.md
================================================
# About the `.run` folder

This folder is present to add support for the [Rider IDE](https://aka.platform.uno/rider-getstarted). You can remove this folder safely if you're not using Rider.



================================================
FILE: sandbox/UnoSampleApp/.run/UnoSampleApp.run.xml
================================================
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="UnoSampleApp (Desktop)" type="LaunchSettings" factoryName=".NET Launch Settings Profile">
    <option name="LAUNCH_PROFILE_PROJECT_FILE_PATH" value="$PROJECT_DIR$/UnoSampleApp/UnoSampleApp.csproj" />
    <option name="LAUNCH_PROFILE_TFM" value="net8.0-desktop" />
    <option name="LAUNCH_PROFILE_NAME" value="UnoSampleApp (Desktop)" />
    <option name="USE_EXTERNAL_CONSOLE" value="0" />
    <option name="USE_MONO" value="0" />
    <option name="RUNTIME_ARGUMENTS" value="" />
    <option name="GENERATE_APPLICATIONHOST_CONFIG" value="1" />
    <option name="SHOW_IIS_EXPRESS_OUTPUT" value="0" />
    <option name="SEND_DEBUG_REQUEST" value="1" />
    <option name="ADDITIONAL_IIS_EXPRESS_ARGUMENTS" value="" />
    <method v="2">
      <option name="Build" />
    </method>
  </configuration>
  <configuration default="false" name="UnoSampleApp (WebAssembly IIS Express)" type="LaunchSettings" factoryName=".NET Launch Settings Profile">
    <option name="LAUNCH_PROFILE_PROJECT_FILE_PATH" value="$PROJECT_DIR$/UnoSampleApp/UnoSampleApp.csproj" />
    <option name="LAUNCH_PROFILE_TFM" value="net8.0-browserwasm" />
    <option name="LAUNCH_PROFILE_NAME" value="UnoSampleApp (WebAssembly IIS Express)" />
    <option name="USE_EXTERNAL_CONSOLE" value="0" />
    <option name="USE_MONO" value="0" />
    <option name="RUNTIME_ARGUMENTS" value="" />
    <option name="GENERATE_APPLICATIONHOST_CONFIG" value="1" />
    <option name="SHOW_IIS_EXPRESS_OUTPUT" value="0" />
    <option name="SEND_DEBUG_REQUEST" value="1" />
    <option name="ADDITIONAL_IIS_EXPRESS_ARGUMENTS" value="" />
    <method v="2">
      <option name="Build" />
    </method>
  </configuration>
  <configuration default="false" name="UnoSampleApp (WebAssembly)" type="LaunchSettings" factoryName=".NET Launch Settings Profile">
    <option name="LAUNCH_PROFILE_PROJECT_FILE_PATH" value="$PROJECT_DIR$/UnoSampleApp/UnoSampleApp.csproj" />
    <option name="LAUNCH_PROFILE_TFM" value="net8.0-browserwasm" />
    <option name="LAUNCH_PROFILE_NAME" value="UnoSampleApp (WebAssembly)" />
    <option name="USE_EXTERNAL_CONSOLE" value="0" />
    <option name="USE_MONO" value="0" />
    <option name="RUNTIME_ARGUMENTS" value="" />
    <option name="GENERATE_APPLICATIONHOST_CONFIG" value="1" />
    <option name="SHOW_IIS_EXPRESS_OUTPUT" value="0" />
    <option name="SEND_DEBUG_REQUEST" value="1" />
    <option name="ADDITIONAL_IIS_EXPRESS_ARGUMENTS" value="" />
    <method v="2">
      <option name="Build" />
    </method>
  </configuration>
  <configuration default="false" name="UnoSampleApp (WinAppSDK Unpackaged)" type="LaunchSettings" factoryName=".NET Launch Settings Profile">
    <option name="LAUNCH_PROFILE_PROJECT_FILE_PATH" value="$PROJECT_DIR$/UnoSampleApp/UnoSampleApp.csproj" />
    <option name="LAUNCH_PROFILE_TFM" value="net8.0-windows10.0.26100.0" />
    <option name="LAUNCH_PROFILE_NAME" value="UnoSampleApp (WinAppSDK Unpackaged)" />
    <option name="USE_EXTERNAL_CONSOLE" value="0" />
    <option name="USE_MONO" value="0" />
    <option name="RUNTIME_ARGUMENTS" value="" />
    <option name="GENERATE_APPLICATIONHOST_CONFIG" value="1" />
    <option name="SHOW_IIS_EXPRESS_OUTPUT" value="0" />
    <option name="SEND_DEBUG_REQUEST" value="1" />
    <option name="ADDITIONAL_IIS_EXPRESS_ARGUMENTS" value="" />
    <method v="2">
      <option name="Build" />
    </method>
  </configuration>
</component>



================================================
FILE: sandbox/WinFormsApp1/Form1.cs
================================================
﻿using R3;
using R3.WinForms;
using System.ComponentModel;
using System.Diagnostics;

namespace WinFormsApp1;

public partial class Form1 : Form
{
    private readonly BindableReactiveProperty<string> rp = new("");

    public Form1()
    {
        InitializeComponent();

        this.components ??= new System.ComponentModel.Container();


        // Bind label1.Text to rp.Value
        label1.DataBindings.Add("Text", rp, "Value");
    }

    protected override void OnCreateControl()
    {
        base.OnCreateControl();

        button1.Click += button1_Click;

        var prop = TypeDescriptor.GetProperties(rp).Find("Value", true);
        Debug.WriteLine((
            prop!.ComponentType.Name,    // "ReactiveProperty`1" (not Bindable)
            prop.SupportsChangeEvents   // false
        ));

        //Observable
        //    .EveryValueChanged(
        //        this,
        //        static form => form.Width)
        //    .Subscribe(x =>
        //    {
        //        this.Text = $"Width: {x:#,0}";
        //    })
        //    .AddTo(this.components);

        //Observable
        //    .FromEventHandler(
        //        handler => this.button1.Click += handler,
        //        handler => this.button1.Click -= handler)
        //    .Delay(TimeSpan.FromSeconds(1))
        //    .Subscribe(_ => this.label1.Text = ObservableSystem.DefaultTimeProvider.GetLocalNow().ToString())
        //    .AddTo(this.components);
    }

    public void button1_Click(object? sender, EventArgs e)
    {
        // This change won't be notified to label1
        rp.Value += "X";
    }
}



================================================
FILE: sandbox/WinFormsApp1/Form1.Designer.cs
================================================
﻿namespace WinFormsApp1;

partial class Form1
{
    /// <summary>
    ///  Required designer variable.
    /// </summary>
    private System.ComponentModel.IContainer components = null;

    /// <summary>
    ///  Clean up any resources being used.
    /// </summary>
    /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
    protected override void Dispose(bool disposing)
    {
        if (disposing && (components != null))
        {
            components.Dispose();
        }

        base.Dispose(disposing);
    }

    #region Windows Form Designer generated code

    /// <summary>
    ///  Required method for Designer support - do not modify
    ///  the contents of this method with the code editor.
    /// </summary>
    private void InitializeComponent()
    {
        components = new System.ComponentModel.Container();
        button1 = new Button();
        label1 = new Label();
        timer1 = new System.Windows.Forms.Timer(components);
        SuspendLayout();
        // 
        // button1
        // 
        button1.Location = new Point(101, 106);
        button1.Name = "button1";
        button1.Size = new Size(94, 29);
        button1.TabIndex = 0;
        button1.Text = "button1";
        button1.UseVisualStyleBackColor = true;
        // 
        // label1
        // 
        label1.AutoSize = true;
        label1.Location = new Point(283, 111);
        label1.Name = "label1";
        label1.Size = new Size(50, 20);
        label1.TabIndex = 1;
        label1.Text = "label1";
        // 
        // Form1
        // 
        AutoScaleDimensions = new SizeF(8F, 20F);
        AutoScaleMode = AutoScaleMode.Font;
        ClientSize = new Size(800, 450);
        Controls.Add(label1);
        Controls.Add(button1);
        Name = "Form1";
        Text = "Form1";
        ResumeLayout(false);
        PerformLayout();
    }

    #endregion

    private Button button1;
    private Label label1;
    private System.Windows.Forms.Timer timer1;
}



================================================
FILE: sandbox/WinFormsApp1/Form1.resx
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="timer1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
FILE: sandbox/WinFormsApp1/Program.cs
================================================
﻿using R3.WinForms;

namespace WinFormsApp1;

internal static class Program
{
    /// <summary>
    ///  The main entry point for the application.
    /// </summary>
    [STAThread]
    static void Main()
    {
        // To customize application configuration such as set high DPI settings or default font,
        // see https://aka.ms/applicationconfiguration.
        ApplicationConfiguration.Initialize();

        var form = new Form1();

        WinFormsProviderInitializer.SetDefaultObservableSystem(static exception =>
            MessageBox.Show(exception.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error),
            form);

        Application.Run(form);
    }
}



================================================
FILE: sandbox/WinFormsApp1/WinFormsApp1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net8.0-windows</TargetFramework>
        <Nullable>enable</Nullable>
        <UseWindowsForms>true</UseWindowsForms>
        <ImplicitUsings>enable</ImplicitUsings>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.WinForms\R3.WinForms.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: sandbox/WinUI3App1/app.manifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="WinUI3App1.app"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- The ID below informs the system that this application is compatible with OS features first introduced in Windows 10. 
      It is necessary to support features in unpackaged applications, for example the custom titlebar implementation.
      For more info see https://docs.microsoft.com/windows/apps/windows-app-sdk/use-windows-app-sdk-run-time#declare-os-compatibility-in-your-application-manifest -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
  
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
</assembly>


================================================
FILE: sandbox/WinUI3App1/App.xaml
================================================
<?xml version="1.0" encoding="utf-8"?>
<Application
    x:Class="WinUI3App1.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:WinUI3App1">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
                <!-- Other merged dictionaries here -->
            </ResourceDictionary.MergedDictionaries>
            <!-- Other app resources here -->
        </ResourceDictionary>
    </Application.Resources>
</Application>



================================================
FILE: sandbox/WinUI3App1/App.xaml.cs
================================================
﻿using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Controls.Primitives;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Navigation;
using Microsoft.UI.Xaml.Shapes;
using R3;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.ApplicationModel;
using Windows.ApplicationModel.Activation;
using Windows.Foundation;
using Windows.Foundation.Collections;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace WinUI3App1;
/// <summary>
/// Provides application-specific behavior to supplement the default Application class.
/// </summary>
public partial class App : Application
{
    /// <summary>
    /// Initializes the singleton application object.  This is the first line of authored code
    /// executed, and as such is the logical equivalent of main() or WinMain().
    /// </summary>
    public App()
    {
        this.InitializeComponent();

        WinUI3ProviderInitializer.SetDefaultObservableSystem(ex => Trace.WriteLine(ex.ToString()));
    }

    /// <summary>
    /// Invoked when the application is launched.
    /// </summary>
    /// <param name="args">Details about the launch request and process.</param>
    protected override void OnLaunched(Microsoft.UI.Xaml.LaunchActivatedEventArgs args)
    {
        m_window = new MainWindow();
        m_window.Activate();
    }

    private Window m_window;
}



================================================
FILE: sandbox/WinUI3App1/MainWindow.xaml
================================================
<?xml version="1.0" encoding="utf-8"?>
<Window
    x:Class="WinUI3App1.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:WinUI3App1"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">

    <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Center">
        <Button x:Name="myButton" Click="myButton_Click">Click Me</Button>
    </StackPanel>
</Window>



================================================
FILE: sandbox/WinUI3App1/MainWindow.xaml.cs
================================================
﻿using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Controls.Primitives;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Navigation;
using R3;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace WinUI3App1;
/// <summary>
/// An empty window that can be used on its own or navigated to within a Frame.
/// </summary>
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();


        //Observable.Interval(TimeSpan.FromSeconds(1))
        Observable.EveryUpdate()
            .Index()
            .Subscribe(x =>
            {
                myButton.Content = "Foo:" + x;
            });
    }

    private void myButton_Click(object sender, RoutedEventArgs e)
    {
        myButton.Content = "Clicked";
    }
}



================================================
FILE: sandbox/WinUI3App1/Package.appxmanifest
================================================
﻿<?xml version="1.0" encoding="utf-8"?>

<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
  IgnorableNamespaces="uap rescap">

  <Identity
    Name="2bae518b-a2c1-4112-a872-29b3af1c4aac"
    Publisher="CN=owner"
    Version="1.0.0.0" />

  <mp:PhoneIdentity PhoneProductId="2bae518b-a2c1-4112-a872-29b3af1c4aac" PhonePublisherId="00000000-0000-0000-0000-000000000000"/>

  <Properties>
    <DisplayName>WinUI3App1</DisplayName>
    <PublisherDisplayName>owner</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0" />
  </Dependencies>

  <Resources>
    <Resource Language="x-generate"/>
  </Resources>

  <Applications>
    <Application Id="App"
      Executable="$targetnametoken$.exe"
      EntryPoint="$targetentrypoint$">
      <uap:VisualElements
        DisplayName="WinUI3App1"
        Description="WinUI3App1"
        BackgroundColor="transparent"
        Square150x150Logo="Assets\Square150x150Logo.png"
        Square44x44Logo="Assets\Square44x44Logo.png">
        <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
        <uap:SplashScreen Image="Assets\SplashScreen.png" />
      </uap:VisualElements>
    </Application>
  </Applications>

  <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>



================================================
FILE: sandbox/WinUI3App1/WinUI3App1.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net6.0-windows10.0.19041.0</TargetFramework>
        <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
        <RootNamespace>WinUI3App1</RootNamespace>
        <ApplicationManifest>app.manifest</ApplicationManifest>
        <Platforms>x86;x64;ARM64</Platforms>
        <RuntimeIdentifiers>win10-x86;win10-x64;win10-arm64</RuntimeIdentifiers>
        <PublishProfile>win10-$(Platform).pubxml</PublishProfile>
        <UseWinUI>true</UseWinUI>
        <EnableMsixTooling>true</EnableMsixTooling>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>
    </PropertyGroup>

    <ItemGroup>
        <Content Include="Assets\SplashScreen.scale-200.png" />
        <Content Include="Assets\LockScreenLogo.scale-200.png" />
        <Content Include="Assets\Square150x150Logo.scale-200.png" />
        <Content Include="Assets\Square44x44Logo.scale-200.png" />
        <Content Include="Assets\Square44x44Logo.targetsize-24_altform-unplated.png" />
        <Content Include="Assets\StoreLogo.png" />
        <Content Include="Assets\Wide310x150Logo.scale-200.png" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.WindowsAppSDK" Version="1.4.230913002" />
        <PackageReference Include="Microsoft.Windows.SDK.BuildTools" Version="10.0.22621.755" />
        <Manifest Include="$(ApplicationManifest)" />
    </ItemGroup>

    <!--
    Defining the "Msix" ProjectCapability here allows the Single-project MSIX Packaging
    Tools extension to be activated for this project even if the Windows App SDK Nuget
    package has not yet been restored.
  -->
    <ItemGroup Condition="'$(DisableMsixProjectCapabilityAddedByProject)'!='true' and '$(EnableMsixTooling)'=='true'">
        <ProjectCapability Include="Msix" />
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.WinUI3\R3.WinUI3.csproj" />
    </ItemGroup>

    <!--
    Defining the "HasPackageAndPublishMenuAddedByProject" property here allows the Solution
    Explorer "Package and Publish" context menu entry to be enabled for this project even if
    the Windows App SDK Nuget package has not yet been restored.
  -->
    <PropertyGroup Condition="'$(DisableHasPackageAndPublishMenuAddedByProject)'!='true' and '$(EnableMsixTooling)'=='true'">
        <HasPackageAndPublishMenu>true</HasPackageAndPublishMenu>
    </PropertyGroup>
</Project>



================================================
FILE: sandbox/WinUI3App1/Properties/launchSettings.json
================================================
{
  "profiles": {
    "WinUI3App1 (Package)": {
      "commandName": "MsixPackage"
    },
    "WinUI3App1 (Unpackaged)": {
      "commandName": "Project"
    }
  }
}


================================================
FILE: sandbox/WinUI3App1/Properties/PublishProfiles/win10-arm64.pubxml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <PublishProtocol>FileSystem</PublishProtocol>
    <Platform>ARM64</Platform>
    <RuntimeIdentifier>win10-arm64</RuntimeIdentifier>
    <PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>False</PublishSingleFile>
    <PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
    <PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
   <!-- 
    See https://github.com/microsoft/CsWinRT/issues/373
    <PublishTrimmed>True</PublishTrimmed>
    -->
  </PropertyGroup>
</Project>


================================================
FILE: sandbox/WinUI3App1/Properties/PublishProfiles/win10-x64.pubxml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <PublishProtocol>FileSystem</PublishProtocol>
    <Platform>x64</Platform>
    <RuntimeIdentifier>win10-x64</RuntimeIdentifier>
    <PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>False</PublishSingleFile>
    <PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
    <PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
   <!-- 
    See https://github.com/microsoft/CsWinRT/issues/373
    <PublishTrimmed>True</PublishTrimmed>
    -->
  </PropertyGroup>
</Project>


================================================
FILE: sandbox/WinUI3App1/Properties/PublishProfiles/win10-x86.pubxml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121.
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <PublishProtocol>FileSystem</PublishProtocol>
    <Platform>x86</Platform>
    <RuntimeIdentifier>win10-x86</RuntimeIdentifier>
    <PublishDir>bin\$(Configuration)\$(TargetFramework)\$(RuntimeIdentifier)\publish\</PublishDir>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>False</PublishSingleFile>
    <PublishReadyToRun Condition="'$(Configuration)' == 'Debug'">False</PublishReadyToRun>
    <PublishReadyToRun Condition="'$(Configuration)' != 'Debug'">True</PublishReadyToRun>
   <!-- 
    See https://github.com/microsoft/CsWinRT/issues/373
    <PublishTrimmed>True</PublishTrimmed>
    -->
  </PropertyGroup>
</Project>


================================================
FILE: sandbox/WpfApp1/App.xaml
================================================
﻿<Application x:Class="WpfApp1.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WpfApp1"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>



================================================
FILE: sandbox/WpfApp1/App.xaml.cs
================================================
﻿using R3;
using System.Configuration;
using System.Data;
using System.Diagnostics;
using System.Windows;

namespace WpfApp1;
/// <summary>
/// Interaction logic for App.xaml
/// </summary>
public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        WpfProviderInitializer.SetDefaultObservableSystem(ex => Trace.WriteLine($"R3 UnhandledException:{ex}"));
    }
}




================================================
FILE: sandbox/WpfApp1/AssemblyInfo.cs
================================================
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]



================================================
FILE: sandbox/WpfApp1/MainWindow.xaml
================================================
﻿<Window x:Class="WpfApp1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp1"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Window.DataContext>
        <!--<local:BasicUsagesViewModel />-->
        <!--<local:ValidationViewModel />-->
        <local:CommandViewModel />
    </Window.DataContext>
    <!--<StackPanel>
        <TextBlock Text="Basic usages" FontSize="24" />
        <Label Content="Input" />
        <TextBox Text="{Binding Input.Value, UpdateSourceTrigger=PropertyChanged}" />
        <Label Content="Output" />
        <TextBlock Text="{Binding Output.Value}" />
    </StackPanel>-->

    <!--<StackPanel Margin="10">
        <Label Content="Validation" />
        <TextBox Text="{Binding Height.Value, UpdateSourceTrigger=PropertyChanged}"  />
        <TextBox  Text="{Binding Weight.Value, UpdateSourceTrigger=PropertyChanged}" />
        <TextBox  Text="{Binding CustomValidation1.Value, UpdateSourceTrigger=PropertyChanged}" />
        <TextBox  Text="{Binding CustomValidation2.Value, UpdateSourceTrigger=PropertyChanged}" />
    </StackPanel>-->


    <StackPanel Margin="10">
        <Label Content="Command" />
        <CheckBox IsChecked="{Binding OnCheck.Value}" />
        <Button Content="Btn" Command="{Binding ShowMessageBox}" />
    </StackPanel>
</Window>



================================================
FILE: sandbox/WpfApp1/MainWindow.xaml.cs
================================================
﻿using R3;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Windows;
using System.Windows.Media.Media3D;

namespace WpfApp1;
/// <summary>
/// Interaction logic for MainWindow.xaml
/// </summary>
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        //var vm = new BasicUsagesViewModel();
        //vm.Input.Value = "hogemogehugahuga";
        //this.DataContext = new BasicUsagesViewModel();


        //Dispatcher.Yield(DispatcherPriority.Input);





        //Observable.EveryValueChanged(this, x => x.Width).Subscribe(x => textBlock.Text = x.ToString());
        // this.ObserveEveryValueChanged(x => x.Height).Subscribe(x => HeightText.Text = x.ToString());

        // var sw = Stopwatch.StartNew();

        //System.Reactive.Linq.Observable.Timer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5)).Subscribe(_ =>
        //{
        //    textBlock.Text = "Hello World:" + sw.Elapsed;
        //});
        //Observable.Timer(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5))
        ////    // .ObserveOnCurrentDispatcher()
        //    .Subscribe(_ =>
        //    {
        //        textBlock.Text = "Hello World:" + sw.Elapsed;
        //    });

        //Observable.TimerFrame(50, 100).Subscribe(_ =>
        //{
        //    textBlock.Text = "Hello World:" + ObservableSystem.DefaultFrameProvider.GetFrameCount();
        //});
    }

    protected override void OnActivated(EventArgs e)
    {
        base.OnActivated(e);

        //Observable.Return(Unit.Default)
        //    .Delay(TimeSpan.FromSeconds(1), TimeProvider.System)
        //    .Subscribe(_ => Debug.WriteLine("This works fine"));

        Observable.Return(Unit.Default)
            .Delay(TimeSpan.FromSeconds(1), new SynchronizationContextTimeProvider())
            .Subscribe(_ => Debug.WriteLine("but here is not reached"));


    }

    protected override void OnClosed(EventArgs e)
    {
        (this.DataContext as IDisposable)?.Dispose();
    }
}

public class BasicUsagesViewModel : IDisposable
{
    public BindableReactiveProperty<string> Input { get; }
    public IReadOnlyBindableReactiveProperty<string> Output { get; }

    public BasicUsagesViewModel()
    {
        Input = new BindableReactiveProperty<string>("");
        Output = Input.Select(x => x.ToUpper()).ToReadOnlyBindableReactiveProperty("");
    }

    public void Dispose()
    {
        Disposable.Dispose(Input, Output);
    }
}

public class ValidationViewModel : IDisposable
{
    // Pattern 1. use EnableValidation<T> to enable DataAnnotation validation in field initializer
    [Range(0.0, 300.0)]
    public BindableReactiveProperty<double> Height { get; } = new BindableReactiveProperty<double>().EnableValidation<ValidationViewModel>();

    [Range(0.0, 300.0)]
    public BindableReactiveProperty<double> Weight { get; }

    IDisposable customValidation1Subscription;
    public BindableReactiveProperty<double> CustomValidation1 { get; set; }

    public BindableReactiveProperty<double> CustomValidation2 { get; set; }

    public ValidationViewModel()
    {
        // Pattern 2. use EnableValidation(Expression) to enable DataAnnotation validation
        Weight = new BindableReactiveProperty<double>().EnableValidation(() => Weight);

        // Pattern 3. EnableValidation() and call OnErrorResume to set custom error meessage
        CustomValidation1 = new BindableReactiveProperty<double>().EnableValidation();
        customValidation1Subscription = CustomValidation1.Subscribe(x =>
        {
            if (0.0 <= x && x <= 300.0) return;

            CustomValidation1.OnErrorResume(new Exception("value is not in range."));
        });

        // Pattern 4. simplified version of Pattern3, EnableValidation(Func<T, Exception?>)
        CustomValidation2 = new BindableReactiveProperty<double>().EnableValidation(x =>
        {
            if (0.0 <= x && x <= 300.0) return null; // null is no validate result
            return new Exception("value is not in range.");
        });
    }

    public void Dispose()
    {
        Disposable.Dispose(Height, Weight, CustomValidation1, customValidation1Subscription, CustomValidation2);
    }
}


public class CommandViewModel : IDisposable
{
    public BindableReactiveProperty<bool> OnCheck { get; }
    public ReactiveCommand ShowMessageBox { get; }

    public CommandViewModel()
    {
        OnCheck = new BindableReactiveProperty<bool>();
        ShowMessageBox = OnCheck.ToReactiveCommand(_ =>
        {
            MessageBox.Show("clicked");
        });
    }

    public void Dispose()
    {
        Disposable.Dispose(OnCheck, ShowMessageBox);
    }
}



================================================
FILE: sandbox/WpfApp1/WpfApp1.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net8.0-windows</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <UseWPF>true</UseWPF>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="System.Reactive.Linq" Version="6.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3.WPF\R3.WPF.csproj" />
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3/AwaitOperation.cs
================================================
﻿using System.Threading;
using System.Threading.Channels;

namespace R3;

public enum AwaitOperation
{
    /// <summary>All values are queued, and the next value waits for the completion of the asynchronous method.</summary>
    Sequential,
    /// <summary>Drop new value when async operation is running.</summary>
    Drop,
    /// <summary>If the previous asynchronous method is running, it is cancelled and the next asynchronous method is executed.</summary>
    Switch,
    /// <summary>All values are sent immediately to the asynchronous method.</summary>
    Parallel,
    /// <summary>All values are sent immediately to the asynchronous method, but the results are queued and passed to the next operator in order.</summary>
    SequentialParallel,
    /// <summary>Send the first value and the last value while the asynchronous method is running.</summary>
    ThrottleFirstLast,
}

internal abstract class AwaitOperationSequentialObserver<T> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    readonly Channel<T> channel;
    bool completed;

    protected override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationSequentialObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
        this.channel = ChannelUtility.CreateSingleReadeWriterUnbounded<T>();

        RunQueueWorker();
    }

    protected override sealed void OnNextCore(T value)
    {
        channel.Writer.TryWrite(value);
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            channel.Writer.TryComplete();
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        Volatile.Write(ref completed, true);
        channel.Writer.TryComplete();
    }

    protected override sealed void DisposeCore()
    {
        channel.Writer.TryComplete(); // complete writing
        cancellationTokenSource.Cancel(); // stop selector await.
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void RunQueueWorker() // don't(can't) wait so use async void
    {
        var reader = channel.Reader;
        var token = cancellationTokenSource.Token;

        try
        {
            while (await reader.WaitToReadAsync(/* don't pass CancellationToken, uses WriterComplete */).ConfigureAwait(configureAwait))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        if (token.IsCancellationRequested) return;

                        await OnNextAsync(item, token, configureAwait).ConfigureAwait(configureAwait);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException)
                        {
                            return;
                        }
                        OnErrorResume(ex);
                    }
                }
            }

            if (Volatile.Read(ref completed))
            {
                PublishOnCompleted(Result.Success);
                Dispose();
            }
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
    }
}

internal abstract class AwaitOperationDropObserver<T> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    int runningState; // 0 = stopped, 1 = running, 2 = complete

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationDropObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
    }

    protected override sealed void OnNextCore(T value)
    {
        if (Interlocked.CompareExchange(ref runningState, 1, 0) == 0)
        {
            StartAsync(value);
        }
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        if (Interlocked.Exchange(ref runningState, 2) == 0)
        {
            PublishOnCompleted(result);
            Dispose();
        }
    }

    protected override sealed void DisposeCore()
    {
        cancellationTokenSource.Cancel();
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void StartAsync(T value)
    {
        try
        {
            await OnNextAsync(value, cancellationTokenSource.Token, configureAwait).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                return;
            }
            OnErrorResume(ex);
        }
        finally
        {
            if (Interlocked.CompareExchange(ref runningState, 0, 1) == 2)
            {
                PublishOnCompleted(Result.Success);
                Dispose();
            }
        }
    }
}

internal abstract class AwaitOperationSwitchObserver<T> : Observer<T>
{
    CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    protected readonly object gate = new object();
    bool running;
    bool completed;

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationSwitchObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
    }

    protected override sealed void OnNextCore(T value)
    {
        CancellationToken token = cancellationTokenSource.Token;
        lock (gate)
        {
            if (running)
            {
                if (IsDisposed) return;
                cancellationTokenSource.Cancel();
                cancellationTokenSource = new CancellationTokenSource();
                token = cancellationTokenSource.Token;
            }
            running = true;
        }

        StartAsync(value, token);
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        lock (gate)
        {
            if (running)
            {
                completed = true;
            }
            else
            {
                PublishOnCompleted(result);
                Dispose();
                return;
            }
        }
    }

    protected override void DisposeCore()
    {
        lock (gate)
        {
            cancellationTokenSource.Cancel();
        }
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void StartAsync(T value, CancellationToken token)
    {
        try
        {
            await OnNextAsync(value, token, configureAwait).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                return;
            }
            OnErrorResume(ex);
        }
        finally
        {
            lock (gate)
            {
                if (!token.IsCancellationRequested)
                {
                    running = false;
                    if (completed)
                    {
                        PublishOnCompleted(Result.Success);
                        Dispose();
                    }
                }
            }
        }
    }
}

internal abstract class AwaitOperationParallelObserver<T> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    protected readonly object gate = new object(); // need to use gate.

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose
    int runningCount = 0;
    bool completed;

    public AwaitOperationParallelObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
    }

    protected override sealed void OnNextCore(T value)
    {
        Interlocked.Increment(ref runningCount);
        StartAsync(value);
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        Volatile.Write(ref completed, true);
        if (Volatile.Read(ref runningCount) == 0)
        {
            PublishOnCompleted(result);
            Dispose();
            return;
        }
    }

    protected override void DisposeCore()
    {
        cancellationTokenSource.Cancel();
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void StartAsync(T value)
    {
        try
        {
            await OnNextAsync(value, cancellationTokenSource.Token, configureAwait).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                return;
            }
            OnErrorResume(ex);
        }
        finally
        {
            if (Interlocked.Decrement(ref runningCount) == 0 && Volatile.Read(ref completed))
            {
                PublishOnCompleted(Result.Success);
                Dispose();
            }
        }
    }
}

internal abstract class AwaitOperationSequentialParallelObserver<T, TTaskValue> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    readonly Channel<(T, ValueTask<TTaskValue>)> channel;
    bool completed;

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationSequentialParallelObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
        this.channel = ChannelUtility.CreateSingleReadeWriterUnbounded<(T, ValueTask<TTaskValue>)>();

        RunQueueWorker();
    }

    protected override sealed void OnNextCore(T value)
    {
        var task = OnNextTaskAsync(value, cancellationTokenSource.Token, configureAwait);
        channel.Writer.TryWrite((value, task));
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            channel.Writer.TryComplete();
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        Volatile.Write(ref completed, true);
        channel.Writer.TryComplete(); // exit wait read loop
    }

    protected override sealed void DisposeCore()
    {
        channel.Writer.TryComplete(); // complete writing
        cancellationTokenSource.Cancel(); // stop selector await.
    }

    protected abstract ValueTask<TTaskValue> OnNextTaskAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnNext(T value, TTaskValue result);
    protected abstract void PublishOnCompleted(Result result);

    async void RunQueueWorker() // don't(can't) wait so use async void
    {
        var reader = channel.Reader;
        var token = cancellationTokenSource.Token;

        try
        {
            while (await reader.WaitToReadAsync(/* don't pass CancellationToken, uses WriterComplete */).ConfigureAwait(configureAwait))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        if (token.IsCancellationRequested) return;

                        var result = await item.Item2.ConfigureAwait(configureAwait);
                        PublishOnNext(item.Item1, result);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException)
                        {
                            return;
                        }
                        OnErrorResume(ex);
                    }
                }
            }

            if (Volatile.Read(ref completed))
            {
                PublishOnCompleted(Result.Success);
                Dispose();
            }
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
    }
}

internal abstract class AwaitOperationParallelConcurrentLimitObserver<T>(bool configureAwait, bool cancelOnCompleted, int maxConcurrent) : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource = new();
    protected readonly object gate = new object(); // need to use gate.

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    int runningCount = 0;
    bool completed;
    Queue<T> queue = new Queue<T>();

    protected override sealed void OnNextCore(T value)
    {
        lock (gate)
        {
            if (runningCount < maxConcurrent)
            {
                runningCount++;
                StartAsync(value);
            }
            else
            {
                queue.Enqueue(value);
            }
        }
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        lock (gate)
        {
            completed = true;
            if (runningCount == 0 && queue.Count == 0)
            {
                PublishOnCompleted(result);
                Dispose();
            }
        }
    }

    protected override void DisposeCore()
    {
        cancellationTokenSource.Cancel();
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void StartAsync(T value)
    {
        try
        {
            await OnNextAsync(value, cancellationTokenSource.Token, configureAwait).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                return;
            }
            OnErrorResume(ex);
        }
        finally
        {
            lock (gate)
            {
                runningCount--;
                if (runningCount == 0 && queue.Count == 0 && completed)
                {
                    PublishOnCompleted(Result.Success);
                    Dispose();
                }
                else
                {
                    if (runningCount < maxConcurrent && queue.Count != 0)
                    {
                        runningCount++;
                        StartAsync(queue.Dequeue());
                    }
                }
            }
        }
    }
}

internal abstract class AwaitOperationSequentialParallelConcurrentLimitObserver<T, TTaskValue> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    readonly int maxConcurrent;
    readonly object gate = new object();
    readonly Channel<(T, ValueTask<TTaskValue>)> channel;
    bool completed;
    int runningCount;
    Queue<T> queue = new();

    protected sealed override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationSequentialParallelConcurrentLimitObserver(bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
        this.maxConcurrent = maxConcurrent;
        this.channel = ChannelUtility.CreateSingleReadeWriterUnbounded<(T, ValueTask<TTaskValue>)>();

        RunQueueWorker();
    }

    protected override sealed void OnNextCore(T value)
    {
        lock (gate)
        {
            if (runningCount < maxConcurrent)
            {
                runningCount++;
                var task = OnNextTaskAsync(value);
                channel.Writer.TryWrite((value, task));
            }
            else
            {
                queue.Enqueue(value);
            }
        }
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            channel.Writer.TryComplete();
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        lock (gate)
        {
            completed = true;
            if (queue.Count == 0)
            {
                channel.Writer.TryComplete(); // exit wait read loop
            }
        }
    }

    protected override sealed void DisposeCore()
    {
        channel.Writer.TryComplete(); // complete writing
        cancellationTokenSource.Cancel(); // stop selector await.
    }

    protected abstract ValueTask<TTaskValue> OnNextTaskAsyncCore(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnNext(T value, TTaskValue result);
    protected abstract void PublishOnCompleted(Result result);

    async ValueTask<TTaskValue> OnNextTaskAsync(T value)
    {
        var task = await OnNextTaskAsyncCore(value, cancellationTokenSource.Token, configureAwait).ConfigureAwait(configureAwait);
        lock (gate)
        {
            runningCount--;
            if (runningCount < maxConcurrent && queue.Count != 0)
            {
                runningCount++;
                var v2 = queue.Dequeue();
                var task2 = OnNextTaskAsync(v2);
                channel.Writer.TryWrite((v2, task2));
            }
        }
        return task;
    }

    async void RunQueueWorker() // don't(can't) wait so use async void
    {
        var reader = channel.Reader;
        var token = cancellationTokenSource.Token;

        try
        {
            while (await reader.WaitToReadAsync(/* don't pass CancellationToken, uses WriterComplete */).ConfigureAwait(configureAwait))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        if (token.IsCancellationRequested) return;

                        var result = await item.Item2.ConfigureAwait(configureAwait);
                        PublishOnNext(item.Item1, result);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException)
                        {
                            return;
                        }
                        OnErrorResume(ex);
                    }
                }

                lock (gate)
                {
                    if (queue.Count == 0 && completed)
                    {
                        channel.Writer.TryComplete();
                    }
                }
            }

            lock (gate)
            {
                if (completed)
                {
                    PublishOnCompleted(Result.Success);
                    Dispose();
                }
            }
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
    }
}

internal abstract class AwaitOperationThrottleFirstLastObserver<T> : Observer<T>
{
    readonly CancellationTokenSource cancellationTokenSource;
    readonly bool configureAwait; // continueOnCapturedContext
    readonly bool cancelOnCompleted;
    readonly Channel<T> channel;
    bool completed;

    protected override bool AutoDisposeOnCompleted => false; // disable auto-dispose

    public AwaitOperationThrottleFirstLastObserver(bool configureAwait, bool cancelOnCompleted)
    {
        this.cancellationTokenSource = new CancellationTokenSource();
        this.configureAwait = configureAwait;
        this.cancelOnCompleted = cancelOnCompleted;
        this.channel = ChannelUtility.CreateSingleReadeWriterSingularBounded<T>();

        RunQueueWorker();
    }

    protected override sealed void OnNextCore(T value)
    {
        channel.Writer.TryWrite(value);
    }

    protected override sealed void OnCompletedCore(Result result)
    {
        if (cancelOnCompleted || result.IsFailure)
        {
            channel.Writer.TryComplete();
            cancellationTokenSource.Cancel();
            PublishOnCompleted(result);
            Dispose();
            return;
        }

        Volatile.Write(ref completed, true);
        channel.Writer.TryComplete(); // exit wait read loop
    }

    protected override sealed void DisposeCore()
    {
        channel.Writer.TryComplete(); // complete writing
        cancellationTokenSource.Cancel(); // stop selector await.
    }

    protected abstract ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait);
    protected abstract void PublishOnCompleted(Result result);

    async void RunQueueWorker() // don't(can't) wait so use async void
    {
        var reader = channel.Reader;
        var token = cancellationTokenSource.Token;

        try
        {
            while (await reader.WaitToReadAsync(/* don't pass CancellationToken, uses WriterComplete */).ConfigureAwait(configureAwait))
            {
                while (reader.TryRead(out var item))
                {
                    try
                    {
                        if (token.IsCancellationRequested) return;

                        await OnNextAsync(item, token, configureAwait).ConfigureAwait(configureAwait);
                    }
                    catch (Exception ex)
                    {
                        if (ex is OperationCanceledException)
                        {
                            return;
                        }
                        OnErrorResume(ex);
                    }
                }
            }

            if (Volatile.Read(ref completed))
            {
                PublishOnCompleted(Result.Success);
                Dispose();
            }
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
    }
}



================================================
FILE: src/R3/BehaviorSubject.cs
================================================
﻿using System.Runtime.ExceptionServices;

namespace R3;

public sealed class BehaviorSubject<T> : Observable<T>, ISubject<T>, IDisposable
{
    FreeListCore<Subscription> list; // struct(array, int)
    CompleteState completeState;     // struct(int, IntPtr)

    T latestValue;

    public BehaviorSubject(T initialValue)
    {
        this.list = new FreeListCore<Subscription>(this); // use self as gate(reduce memory usage), this is slightly dangerous so don't lock this in user.
        this.latestValue = initialValue;
    }

    public bool IsDisposed => completeState.IsDisposed;

    public T Value
    {
        get
        {
            var result = completeState.TryGetResult();
            if (result != null && result.Value.IsFailure)
            {
                ExceptionDispatchInfo.Capture(result.Value.Exception).Throw();
            }
            return latestValue;
        }
    }

    public void OnNext(T value)
    {
        if (completeState.IsCompleted) return;

        lock (this)
        {
            this.latestValue = value;
            foreach (var subscription in list.AsSpan())
            {
                subscription?.observer.OnNext(value);
            }
        }
    }

    public void OnErrorResume(Exception error)
    {
        if (completeState.IsCompleted) return;

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnErrorResume(error);
        }
    }

    public void OnCompleted(Result result)
    {
        var status = completeState.TrySetResult(result);
        if (status != CompleteState.ResultStatus.Done)
        {
            return; // already completed
        }

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnCompleted(result);
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        lock (this)
        {
            var result = completeState.TryGetResult();
            if (result != null)
            {
                observer.OnCompleted(result.Value);
                return Disposable.Empty;
            }

            observer.OnNext(latestValue);
            var subscription = new Subscription(this, observer); // create subscription and add observer to list.

            // need to check called completed during adding
            result = completeState.TryGetResult();
            if (result != null)
            {
                subscription.observer.OnCompleted(result.Value);
                subscription.Dispose();
                return Disposable.Empty;
            }

            return subscription;
        }
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (callOnCompleted && !alreadyCompleted)
            {
                // not yet disposed so can call list iteration
                foreach (var subscription in list.AsSpan())
                {
                    subscription?.observer.OnCompleted();
                }
            }

            list.Dispose();
            lock (this)
            {
                this.latestValue = default!;
            }
        }
    }

    sealed class Subscription : IDisposable
    {
        public readonly Observer<T> observer;
        readonly int removeKey;
        BehaviorSubject<T>? parent;

        public Subscription(BehaviorSubject<T> parent, Observer<T> observer)
        {
            this.parent = parent;
            this.observer = observer;
            parent.list.Add(this, out removeKey); // for the thread-safety, add and set removeKey in same lock.
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // removeKey is index, will reuse if remove completed so only allows to call from here and must not call twice.
            p.list.Remove(removeKey);
        }
    }
}



================================================
FILE: src/R3/BindableReactiveProperty.cs
================================================
﻿using System.Collections;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace R3;

// for binding(TriggerAction, Behavior) usage

public interface IReadOnlyBindableReactiveProperty : INotifyPropertyChanged, INotifyDataErrorInfo, IDisposable
{
    object? Value { get; }
    bool IsValidationEnabled { get; }
}

public interface IReadOnlyBindableReactiveProperty<T> : IReadOnlyBindableReactiveProperty
{
    new T Value { get; }
    IReadOnlyBindableReactiveProperty<T> EnableValidation();
    IReadOnlyBindableReactiveProperty<T> EnableValidation(Func<T, Exception?> validator);
    IReadOnlyBindableReactiveProperty<T> EnableValidation<TClass>([CallerMemberName] string? propertyName = null!);
    IReadOnlyBindableReactiveProperty<T> EnableValidation(Expression<Func<IReadOnlyBindableReactiveProperty<T>?>> selfSelector);
    Observable<T> AsObservable();
    IReadOnlyBindableReactiveProperty<T> ForceValidate();
}

public interface IBindableReactiveProperty : IReadOnlyBindableReactiveProperty
{
    new object? Value { get; set; }
    void OnNext(object? value);
}

public interface IBindableReactiveProperty<T> : IBindableReactiveProperty, IReadOnlyBindableReactiveProperty<T>
{
    new T Value { get; set; }
    void OnNext(T value);
    new IBindableReactiveProperty<T> EnableValidation();
    new IBindableReactiveProperty<T> EnableValidation(Func<T, Exception?> validator);
    new IBindableReactiveProperty<T> EnableValidation<TClass>([CallerMemberName] string? propertyName = null!);
    IBindableReactiveProperty<T> EnableValidation(Expression<Func<IBindableReactiveProperty<T>?>> selfSelector);
    new IBindableReactiveProperty<T> ForceValidate();
}

// all operators need to call from UI Thread(not thread-safe)

#if NET6_0_OR_GREATER
[System.Text.Json.Serialization.JsonConverter(typeof(BindableReactivePropertyJsonConverterFactory))]
#endif
public class BindableReactiveProperty<T> : ReactiveProperty<T>, IBindableReactiveProperty<T>
{
    IDisposable? subscription;

    // ctor

    public BindableReactiveProperty()
        : base()
    {
    }

    public BindableReactiveProperty(T value)
        : base(value)
    {
    }

    public BindableReactiveProperty(T value, IEqualityComparer<T>? equalityComparer)
        : base(value, equalityComparer)
    {
    }

    // WinForms reflection data binding require to impl Value in this type
    public new T Value
    {
        get => base.Value;
        set => base.Value = value;
    }

    // ToBindableReactiveProperty

    internal BindableReactiveProperty(Observable<T> source, T initialValue, IEqualityComparer<T>? equalityComparer)
        : base(initialValue, equalityComparer)
    {
        this.subscription = source.Subscribe(new Observer(this));
    }

    protected override void DisposeCore()
    {
        subscription?.Dispose();
    }

    class Observer(BindableReactiveProperty<T> parent) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            parent.Value = value;
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            parent.OnCompleted(result);
        }
    }

    // for INotifyPropertyChanged

    public event PropertyChangedEventHandler? PropertyChanged;

    protected override void OnValueChanged(T value)
    {
        Validate(value);
        PropertyChanged?.Invoke(this, ValueChangedEventArgs.PropertyChanged);
    }

    void Validate(T value)
    {
        if (IsValidationEnabled)
        {
            // comes new value, require to clear error.
            var previouslyHasErrors = (errors != null && errors.Count != 0);
            errors?.Clear();

            if (validationContext != null)
            {
                if (errors == null)
                {
                    errors = new List<ValidationResult>(validationContext.ValidatorCount);
                }

                if (!validationContext.TryValidateValue(value, errors))
                {
                    ErrorsChanged?.Invoke(this, ValueChangedEventArgs.DataErrorsChanged);
                }
                else if (previouslyHasErrors)
                {
                    ErrorsChanged?.Invoke(this, ValueChangedEventArgs.DataErrorsChanged);
                }
            }
            else if (validator != null)
            {
                var error = validator.Invoke(value);
                if (error != null)
                {
                    OnReceiveError(error);
                }
                else if (previouslyHasErrors)
                {
                    ErrorsChanged?.Invoke(this, ValueChangedEventArgs.DataErrorsChanged);
                }
            }
            else
            {
                if (previouslyHasErrors)
                {
                    // notify error was cleared.
                    ErrorsChanged?.Invoke(this, ValueChangedEventArgs.DataErrorsChanged);
                }
            }
        }
    }

    // for INotifyDataErrorInfo

    PropertyValidationContext? validationContext;
    Func<T, Exception?>? validator;
    public bool IsValidationEnabled { get; private set; } = false; // default is false
    List<ValidationResult>? errors;

    public event EventHandler<DataErrorsChangedEventArgs>? ErrorsChanged;

    public bool HasErrors
    {
        get
        {
            if (errors == null) return false;
            return errors.Count != 0;
        }
    }

    public IEnumerable GetErrors(string? propertyName)
    {
        if (errors == null) return Enumerable.Empty<Exception>();
        return errors;
    }

    protected override void OnReceiveError(Exception exception)
    {
        if (!IsValidationEnabled) return;

        var aggregateException = exception as AggregateException;

        if (errors == null)
        {
            if (aggregateException != null)
            {
                errors = new List<ValidationResult>(aggregateException.InnerExceptions.Count);
            }
            else
            {
                errors = new List<ValidationResult>(1);
            }
        }
        errors.Clear();

        if (aggregateException != null)
        {
            foreach (var item in aggregateException.InnerExceptions)
            {
                errors.Add(new ValidationResult(item.Message));
            }
        }
        else
        {
            errors.Add(new ValidationResult(exception.Message));
        }

        ErrorsChanged?.Invoke(this, ValueChangedEventArgs.DataErrorsChanged);
    }

    public BindableReactiveProperty<T> EnableValidation()
    {
        IsValidationEnabled = true;
        return this;
    }

    public BindableReactiveProperty<T> EnableValidation(Func<T, Exception?> validator)
    {
        this.validator = validator;

        IsValidationEnabled = true;
        return this;
    }

    public BindableReactiveProperty<T> EnableValidation<TClass>([CallerMemberName] string? propertyName = null!)
    {
        var propertyInfo = typeof(TClass).GetProperty(propertyName!, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        SetValidationContext(propertyInfo!);

        IsValidationEnabled = true;
        return this;
    }

    public BindableReactiveProperty<T> EnableValidation(Expression<Func<BindableReactiveProperty<T>?>> selfSelector)
    {
        var memberExpression = (MemberExpression)selfSelector.Body;
        var propertyInfo = (PropertyInfo)memberExpression.Member;
        SetValidationContext(propertyInfo);

        IsValidationEnabled = true;
        return this;
    }

    void SetValidationContext(PropertyInfo propertyInfo)
    {
        var display = propertyInfo.GetCustomAttribute<DisplayAttribute>();
        var attrs = AsArray(propertyInfo.GetCustomAttributes<ValidationAttribute>());

        if (attrs.Length != 0)
        {
            var context = new ValidationContext(this)
            {
                DisplayName = display?.GetName() ?? propertyInfo.Name,
                MemberName = nameof(Value),
            };

            this.validationContext = new PropertyValidationContext(context, attrs);
        }
    }

    ValidationAttribute[] AsArray(IEnumerable<ValidationAttribute> validationAttributes)
    {
        if (validationAttributes is ValidationAttribute[] array)
        {
            return array;
        }
        return validationAttributes.ToArray();
    }

    // IBindableReactiveProperty

    object? IBindableReactiveProperty.Value
    {
        get => Value;
        set => Value = (T)value!;
    }

    void IBindableReactiveProperty.OnNext(object? value)
    {
        OnNext((T)value!);
    }

    IBindableReactiveProperty<T> IBindableReactiveProperty<T>.EnableValidation() => EnableValidation();

    IBindableReactiveProperty<T> IBindableReactiveProperty<T>.EnableValidation(Func<T, Exception?> validator) => EnableValidation(validator);

    IBindableReactiveProperty<T> IBindableReactiveProperty<T>.EnableValidation<TClass>(string? propertyName) => EnableValidation<TClass>(propertyName);

    IBindableReactiveProperty<T> IBindableReactiveProperty<T>.EnableValidation(Expression<Func<IBindableReactiveProperty<T>?>> selfSelector)
    {
        var memberExpression = (MemberExpression)selfSelector.Body;
        var propertyInfo = (PropertyInfo)memberExpression.Member;
        SetValidationContext(propertyInfo);

        IsValidationEnabled = true;
        return this;
    }

    // IReadOnlyBindableReactiveProperty

    object? IReadOnlyBindableReactiveProperty.Value
    {
        get => Value;
    }

    IReadOnlyBindableReactiveProperty<T> IReadOnlyBindableReactiveProperty<T>.EnableValidation() => EnableValidation();

    IReadOnlyBindableReactiveProperty<T> IReadOnlyBindableReactiveProperty<T>.EnableValidation(Func<T, Exception?> validator) => EnableValidation(validator);

    IReadOnlyBindableReactiveProperty<T> IReadOnlyBindableReactiveProperty<T>.EnableValidation<TClass>(string? propertyName) => EnableValidation<TClass>(propertyName);

    IReadOnlyBindableReactiveProperty<T> IReadOnlyBindableReactiveProperty<T>.EnableValidation(Expression<Func<IReadOnlyBindableReactiveProperty<T>?>> selfSelector)
    {
        var memberExpression = (MemberExpression)selfSelector.Body;
        var propertyInfo = (PropertyInfo)memberExpression.Member;
        SetValidationContext(propertyInfo);

        IsValidationEnabled = true;
        return this;
    }

    public Observable<T> AsObservable()
    {
        return this;
    }

    public IBindableReactiveProperty<T> ForceValidate()
    {
        Validate(Value);
        return this;
    }

    IReadOnlyBindableReactiveProperty<T> IReadOnlyBindableReactiveProperty<T>.ForceValidate()
    {
        return ForceValidate();
    }
}

internal sealed class PropertyValidationContext(ValidationContext context, ValidationAttribute[] attributes)
{
    public int ValidatorCount => attributes.Length;

    public bool TryValidateValue(object? value, ICollection<ValidationResult> validationResults)
    {
        return Validator.TryValidateValue(value!, context, validationResults, attributes);
    }
}


internal static class ValueChangedEventArgs
{
    internal static readonly PropertyChangedEventArgs PropertyChanged = new PropertyChangedEventArgs("Value");
    internal static readonly DataErrorsChangedEventArgs DataErrorsChanged = new DataErrorsChangedEventArgs("Value");
}



================================================
FILE: src/R3/BooleanDisposable.cs
================================================
﻿namespace R3;

public sealed class BooleanDisposable : IDisposable
{
    BooleanDisposableCore core;

    public bool IsDisposed => core.IsDisposed;

    public void Dispose()
    {
        core.Dispose();
    }
}

public struct BooleanDisposableCore
{
    int isDisposed;

    public bool IsDisposed => Volatile.Read(ref isDisposed) == 1;

    public void Dispose()
    {
        Volatile.Write(ref isDisposed, 1);
    }
}



================================================
FILE: src/R3/CancellationDisposable.cs
================================================
﻿namespace R3;

public sealed class CancellationDisposable(CancellationTokenSource cancellationTokenSource) : IDisposable
{
    public CancellationDisposable()
        : this(new CancellationTokenSource())
    {
    }

    public CancellationToken Token => cancellationTokenSource.Token;

    public bool IsDisposed => cancellationTokenSource.IsCancellationRequested;

    public void Dispose() => cancellationTokenSource.Cancel();
}



================================================
FILE: src/R3/CompositeDisposable.cs
================================================
﻿using System.Buffers;
using System.Collections;
using System.Runtime.InteropServices;

namespace R3;

public sealed class CompositeDisposable : ICollection<IDisposable>, IDisposable
{
    List<IDisposable?> list; // when removed, set null
    readonly object gate = new object();
    bool isDisposed;
    int count;

    const int ShrinkThreshold = 64;

    public bool IsDisposed => Volatile.Read(ref isDisposed);

    public CompositeDisposable()
    {
        this.list = new();
    }

    public CompositeDisposable(int capacity)
    {
        if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
        this.list = new(capacity);
    }

    public CompositeDisposable(params IDisposable[] disposables)
    {
        this.list = new(disposables);
        this.count = list.Count;
    }

    public CompositeDisposable(IEnumerable<IDisposable> disposables)
    {
        this.list = new(disposables);
        this.count = list.Count;
    }

    public int Count
    {
        get
        {
            lock (gate)
            {
                return count;
            }
        }
    }

    public bool IsReadOnly => false;

    public void Add(IDisposable item)
    {
        lock (gate)
        {
            if (!isDisposed)
            {
                count += 1;
                list.Add(item);
                return;
            }
        }

        // CompositeDisposable is Disposed.
        item.Dispose();
    }

    public bool Remove(IDisposable item)
    {
        lock (gate)
        {
            // CompositeDisposable is Disposed, do nothing.
            if (isDisposed) return false;

            var current = list;

            var index = current.IndexOf(item);
            if (index == -1)
            {
                // not found
                return false;
            }

            // don't do RemoveAt(avoid Array Copy)
            current[index] = null;

            // Do shrink
            if (current.Capacity > ShrinkThreshold && count < current.Capacity / 2)
            {
                var fresh = new List<IDisposable?>(current.Capacity / 2);

                foreach (var d in current)
                {
                    if (d != null)
                    {
                        fresh.Add(d);
                    }
                }

                list = fresh;
            }

            count -= 1;
        }

        // Dispose outside of lock
        item.Dispose();
        return true;
    }

    public void Clear()
    {
        IDisposable?[] targetDisposables;
        int clearCount;
        lock (gate)
        {
            // CompositeDisposable is Disposed, do nothing.
            if (isDisposed) return;
            if (count == 0) return;

            targetDisposables = ArrayPool<IDisposable?>.Shared.Rent(list.Count);
            clearCount = list.Count;

            list.CopyTo(targetDisposables);

            list.Clear();
            count = 0;
        }

        // Dispose outside of lock
        try
        {
            foreach (var item in targetDisposables.AsSpan(0, clearCount))
            {
                item?.Dispose();
            }
        }
        finally
        {
            ArrayPool<IDisposable?>.Shared.Return(targetDisposables, clearArray: true);
        }
    }

    public bool Contains(IDisposable item)
    {
        lock (gate)
        {
            if (isDisposed) return false;
            return list.Contains(item);
        }
    }

    public void CopyTo(IDisposable[] array, int arrayIndex)
    {
        if (arrayIndex < 0 || arrayIndex >= array.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(arrayIndex));
        }

        lock (gate)
        {
            if (isDisposed) return;

            if (arrayIndex + count > array.Length)
            {
                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
            }

            var i = 0;
            foreach (var item in CollectionsMarshal.AsSpan(list))
            {
                if (item != null)
                {
                    array[arrayIndex + i++] = item;
                }
            }
        }
    }

    public void Dispose()
    {
        List<IDisposable?> disposables;

        lock (gate)
        {
            if (isDisposed) return;

            count = 0;
            isDisposed = true;
            disposables = list;
            list = null!; // dereference.
        }

        foreach (var item in disposables)
        {
            item?.Dispose();
        }
        disposables.Clear();
    }

    public IEnumerator<IDisposable> GetEnumerator()
    {
        lock (gate)
        {
            // make snapshot
            return EnumerateAndClear(list.ToArray()).GetEnumerator();
        }
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        lock (gate)
        {
            // make snapshot
            return EnumerateAndClear(list.ToArray()).GetEnumerator();
        }
    }

    static IEnumerable<IDisposable> EnumerateAndClear(IDisposable?[] disposables)
    {
        try
        {
            foreach (var item in disposables)
            {
                if (item != null)
                {
                    yield return item;
                }
            }
        }
        finally
        {
            disposables.AsSpan().Clear();
        }
    }
}



================================================
FILE: src/R3/ConnectableObservable.cs
================================================
﻿namespace R3;

public abstract class ConnectableObservable<T> : Observable<T>
{
    public abstract IDisposable Connect();
}



================================================
FILE: src/R3/Disposable.cs
================================================
﻿using System;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace R3;

public static class Disposable
{
    public static readonly IDisposable Empty = new EmptyDisposable();

    public static DisposableBuilder CreateBuilder()
    {
        return new DisposableBuilder();
    }

    public static T AddTo<T>(this T disposable, ref DisposableBuilder builder)
        where T : IDisposable
    {
        builder.Add(disposable);
        return disposable;
    }

    public static T AddTo<T>(this T disposable, ref DisposableBag bag)
        where T : IDisposable
    {
        bag.Add(disposable);
        return disposable;
    }

    public static T AddTo<T>(this T disposable, ICollection<IDisposable> disposables)
        where T : IDisposable
    {
        disposables.Add(disposable);
        return disposable;
    }

    // AddTo is already used in UniTask so avoid name conflict...

    public static CancellationTokenRegistration RegisterTo(this IDisposable disposable, CancellationToken cancellationToken)
    {
        if (!cancellationToken.CanBeCanceled) throw new ArgumentException("Require CancellationToken CanBeCanceled");

        if (cancellationToken.IsCancellationRequested)
        {
            disposable.Dispose();
            return default;
        }

        return cancellationToken.UnsafeRegister(state =>
        {
            var d = ((IDisposable)state!);
            d.Dispose();
        }, disposable);
    }

    public static IDisposable Create(Action onDisposed)
    {
        return new AnonymousDisposable(onDisposed);
    }

    public static IDisposable Create<T>(T state, Action<T> onDisposed)
    {
        return new AnonymousDisposable<T>(state, onDisposed);
    }

    public static IDisposable Combine(IDisposable disposable1, IDisposable disposable2)
    {
        return new CombinedDisposable2(disposable1, disposable2);
    }

    public static IDisposable Combine(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
    {
        return new CombinedDisposable3(disposable1, disposable2, disposable3);
    }

    public static IDisposable Combine(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4
        )
    {
        return new CombinedDisposable4(
            disposable1,
            disposable2,
            disposable3,
            disposable4
            );
    }

    public static IDisposable Combine(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5
        )
    {
        return new CombinedDisposable5(
            disposable1,
            disposable2,
            disposable3,
            disposable4,
            disposable5
            );
    }

    public static IDisposable Combine(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6
        )
    {
        return new CombinedDisposable6(
            disposable1,
            disposable2,
            disposable3,
            disposable4,
            disposable5,
            disposable6
            );
    }

    public static IDisposable Combine(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6,
        IDisposable disposable7
        )
    {
        return new CombinedDisposable7(
            disposable1,
            disposable2,
            disposable3,
            disposable4,
            disposable5,
            disposable6,
            disposable7
            );
    }

    public static IDisposable Combine(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6,
        IDisposable disposable7,
        IDisposable disposable8
        )
    {
        return new CombinedDisposable8(
            disposable1,
            disposable2,
            disposable3,
            disposable4,
            disposable5,
            disposable6,
            disposable7,
            disposable8
            );
    }

    public static IDisposable Combine(params IDisposable[] disposables)
    {
        return new CombinedDisposable(disposables);
    }

    public static void Dispose(IDisposable disposable1, IDisposable disposable2)
    {
        disposable1.Dispose();
        disposable2.Dispose();
    }

    public static void Dispose(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3)
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();

    }

    public static void Dispose(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4
        )
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
    }

    public static void Dispose(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5
        )
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
    }

    public static void Dispose(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6
        )
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
    }

    public static void Dispose(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6,
        IDisposable disposable7
        )
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
        disposable7.Dispose();
    }

    public static void Dispose(
        IDisposable disposable1,
        IDisposable disposable2,
        IDisposable disposable3,
        IDisposable disposable4,
        IDisposable disposable5,
        IDisposable disposable6,
        IDisposable disposable7,
        IDisposable disposable8
        )
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
        disposable7.Dispose();
        disposable8.Dispose();
    }

    public static void Dispose(params IDisposable[] disposables)
    {
        foreach (var item in disposables)
        {
            item.Dispose();
        }
    }
}

internal sealed class EmptyDisposable : IDisposable
{
    public void Dispose()
    {
    }
}

internal sealed class CombinedDisposable2(IDisposable disposable1, IDisposable disposable2) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
    }
}

internal sealed class CombinedDisposable3(IDisposable disposable1, IDisposable disposable2, IDisposable disposable3) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
    }
}

internal sealed class CombinedDisposable4(
    IDisposable disposable1,
    IDisposable disposable2,
    IDisposable disposable3,
    IDisposable disposable4) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
    }
}


internal sealed class CombinedDisposable5(
    IDisposable disposable1,
    IDisposable disposable2,
    IDisposable disposable3,
    IDisposable disposable4,
    IDisposable disposable5) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
    }
}


internal sealed class CombinedDisposable6(
    IDisposable disposable1,
    IDisposable disposable2,
    IDisposable disposable3,
    IDisposable disposable4,
    IDisposable disposable5,
    IDisposable disposable6) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
    }
}

internal sealed class CombinedDisposable7(
    IDisposable disposable1,
    IDisposable disposable2,
    IDisposable disposable3,
    IDisposable disposable4,
    IDisposable disposable5,
    IDisposable disposable6,
    IDisposable disposable7) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
        disposable7.Dispose();
    }
}

internal sealed class CombinedDisposable8(
    IDisposable disposable1,
    IDisposable disposable2,
    IDisposable disposable3,
    IDisposable disposable4,
    IDisposable disposable5,
    IDisposable disposable6,
    IDisposable disposable7,
    IDisposable disposable8) : IDisposable
{
    public void Dispose()
    {
        disposable1.Dispose();
        disposable2.Dispose();
        disposable3.Dispose();
        disposable4.Dispose();
        disposable5.Dispose();
        disposable6.Dispose();
        disposable7.Dispose();
        disposable8.Dispose();
    }
}

internal sealed class CombinedDisposable(IDisposable[] disposables) : IDisposable
{
    public void Dispose()
    {
        foreach (var disposable in disposables)
        {
            disposable.Dispose();
        }
    }
}

public ref struct DisposableBuilder()
{
    IDisposable? disposable1;
    IDisposable? disposable2;
    IDisposable? disposable3;
    IDisposable? disposable4;
    IDisposable? disposable5;
    IDisposable? disposable6;
    IDisposable? disposable7;
    IDisposable? disposable8;
    IDisposable[]? disposables;

    int count;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Add(IDisposable disposable)
    {
        ThrowHelper.ThrowArgumentNullIfNull(disposable);
        ThrowHelper.ThrowObjectDisposedIf(count == -1, typeof(DisposableBuilder));

        switch (count)
        {
            case 0:
                disposable1 = disposable;
                break;
            case 1:
                disposable2 = disposable;
                break;
            case 2:
                disposable3 = disposable;
                break;
            case 3:
                disposable4 = disposable;
                break;
            case 4:
                disposable5 = disposable;
                break;
            case 5:
                disposable6 = disposable;
                break;
            case 6:
                disposable7 = disposable;
                break;
            case 7:
                disposable8 = disposable;
                break;
            default:
                AddToArray(disposable);
                break;
        }

        count++;
    }

    void AddToArray(IDisposable disposable)
    {
        if (count == 8)
        {
            var newDisposables = ArrayPool<IDisposable>.Shared.Rent(16);
            newDisposables[8] = disposable; // JIT optimize
            newDisposables[0] = disposable1!;
            newDisposables[1] = disposable2!;
            newDisposables[2] = disposable3!;
            newDisposables[3] = disposable4!;
            newDisposables[4] = disposable5!;
            newDisposables[5] = disposable6!;
            newDisposables[6] = disposable7!;
            newDisposables[7] = disposable8!;
            disposable1 = disposable2 = disposable3 = disposable4 = disposable5 = disposable6 = disposable7 = disposable8 = null;
            disposables = newDisposables; // assign
        }
        else
        {
            if (disposables!.Length == count)
            {
                var newDisposables = ArrayPool<IDisposable>.Shared.Rent(count * 2);
                Array.Copy(disposables, newDisposables, disposables.Length);
                ArrayPool<IDisposable>.Shared.Return(disposables, clearArray: true);
                disposables = newDisposables;
            }
            disposables[count] = disposable;
        }
    }

    public IDisposable Build()
    {
        ThrowHelper.ThrowObjectDisposedIf(count == -1, typeof(DisposableBuilder));

        IDisposable result;
        switch (count)
        {
            case 0:
                result = Disposable.Empty;
                break;
            case 1:
                result = disposable1!;
                break;
            case 2:
                result = new CombinedDisposable2(
                    disposable1!,
                    disposable2!
                );
                break;
            case 3:
                result = new CombinedDisposable3(
                    disposable1!,
                    disposable2!,
                    disposable3!
                );
                break;
            case 4:
                result = new CombinedDisposable4(
                    disposable1!,
                    disposable2!,
                    disposable3!,
                    disposable4!
                );
                break;
            case 5:
                result = new CombinedDisposable5(
                    disposable1!,
                    disposable2!,
                    disposable3!,
                    disposable4!,
                    disposable5!
                );
                break;
            case 6:
                result = new CombinedDisposable6(
                    disposable1!,
                    disposable2!,
                    disposable3!,
                    disposable4!,
                    disposable5!,
                    disposable6!
                );
                break;
            case 7:
                result = new CombinedDisposable7(
                    disposable1!,
                    disposable2!,
                    disposable3!,
                    disposable4!,
                    disposable5!,
                    disposable6!,
                    disposable7!
                );
                break;
            case 8:
                result = new CombinedDisposable8(
                    disposable1!,
                    disposable2!,
                    disposable3!,
                    disposable4!,
                    disposable5!,
                    disposable6!,
                    disposable7!,
                    disposable8!
                );
                break;
            default:
                result = new CombinedDisposable(disposables!.AsSpan(0, count).ToArray());
                break;
        }

        Dispose();
        return result;
    }

    public CancellationTokenRegistration RegisterTo(CancellationToken cancellationToken)
    {
        return Build().RegisterTo(cancellationToken);
    }

    public void Dispose()
    {
        if (count != -1)
        {
            disposable1 = disposable2 = disposable3 = disposable4 = disposable5 = disposable6 = disposable7 = disposable8 = null;
            if (disposables != null)
            {
                ArrayPool<IDisposable>.Shared.Return(disposables, clearArray: true);
            }
            count = -1;
        }
    }
}

internal sealed class AnonymousDisposable : IDisposable
{
    volatile Action? onDisposed;

    // public bool IsDisposed => onDisposed == null;

    public AnonymousDisposable(Action onDisposed)
    {
        this.onDisposed = onDisposed;
    }

    public void Dispose()
    {
        Interlocked.Exchange(ref onDisposed, null)?.Invoke();
    }
}

internal sealed class AnonymousDisposable<T> : IDisposable
{
    T state;
    volatile Action<T>? onDisposed;

    // public bool IsDisposed => onDisposed == null;

    public AnonymousDisposable(T state, Action<T> onDisposed)
    {
        this.state = state;
        this.onDisposed = onDisposed;
    }

    public void Dispose()
    {
        Interlocked.Exchange(ref onDisposed, null)?.Invoke(state);
        state = default!;
    }
}



================================================
FILE: src/R3/DisposableBag.cs
================================================
﻿namespace R3;

public struct DisposableBag : IDisposable
{
    IDisposable[]? items;
    bool isDisposed;
    int count;

    public DisposableBag(int capacity)
    {
        items = new IDisposable[capacity];
    }

    public void Add(IDisposable item)
    {
        if (isDisposed)
        {
            item.Dispose();
            return;
        }

        if (items == null)
        {
            items = new IDisposable[4];
        }
        else if (count == items.Length)
        {
            Array.Resize(ref items, count * 2);
        }

        items[count++] = item;
    }

    public void Clear()
    {
        if (items != null)
        {
            for (int i = 0; i < count; i++)
            {
                items[i]?.Dispose();
            }

            items = null;
            count = 0;
        }
    }

    public void Dispose()
    {
        Clear();
        isDisposed = true;
    }
}



================================================
FILE: src/R3/FrameProvider.cs
================================================
﻿namespace R3;

public abstract class FrameProvider
{
    public abstract long GetFrameCount();
    public abstract void Register(IFrameRunnerWorkItem callback);
}

public interface IFrameRunnerWorkItem
{
    // true, continue
    bool MoveNext(long frameCount);
}

public sealed class FakeFrameProvider : FrameProvider
{
    long frameCount;
    readonly object gate = new object();
    FreeListCore<IFrameRunnerWorkItem> list;

    public FakeFrameProvider()
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        this.frameCount = 0;
    }

    public FakeFrameProvider(long frameCount)
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        this.frameCount = frameCount;
    }

    public override long GetFrameCount()
    {
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        list.Add(callback, out _);
    }

    public void Advance()
    {
        Advance(1);
    }

    public void Advance(int advanceCount)
    {
        for (int i = 0; i < advanceCount; i++)
        {
            RunLoop();
        }
    }

    public int GetRegisteredCount()
    {
        var span = list.AsSpan();
        var count = 0;
        foreach (ref readonly var item in span)
        {
            if (item != null) count++;
        }
        return count;
    }

    void RunLoop()
    {
        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
        frameCount++;
    }
}



================================================
FILE: src/R3/ISubject.cs
================================================
﻿namespace R3;

// NOTE: implement type must inherit from Observable<T>
// Subject<T>, ReactiveProperty<T>(as BehaviorSubject<T>), ReplaySubject<T>, ReplayFrameSubject<T>.
// All subjects, when disposed, call OnCompleted().
public interface ISubject<T>
{
    // Observable
    IDisposable Subscribe(Observer<T> observer);

    // Observer
    void OnNext(T value);
    void OnErrorResume(Exception error);
    void OnCompleted(Result complete);
}

public static class SubjectExtensions
{
    public static Observer<T> AsObserver<T>(this ISubject<T> subject)
    {
        return new SubjectToObserver<T>(subject);
    }

    public static void OnCompleted<T>(this ISubject<T> subject)
    {
        subject.OnCompleted(default);
    }

    public static void OnCompleted<T>(this ISubject<T> subject, Exception exception)
    {
        subject.OnCompleted(Result.Failure(exception));
    }
}

internal sealed class SubjectToObserver<T>(ISubject<T> subject) : Observer<T>
{
    protected override void OnNextCore(T value)
    {
        subject.OnNext(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        subject.OnErrorResume(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        subject.OnCompleted(result);
    }
}



================================================
FILE: src/R3/NewThreadSleepFrameProvider.cs
================================================
﻿namespace R3;

public sealed class NewThreadSleepFrameProvider : FrameProvider, IDisposable
{
    readonly int sleepMilliseconds;
    bool disposed;

    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    Thread thread;

    public NewThreadSleepFrameProvider()
        : this(1)
    {
    }

    public NewThreadSleepFrameProvider(int sleepMilliseconds)
    {
        this.sleepMilliseconds = sleepMilliseconds;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(this);
        this.thread = new Thread(Run) { IsBackground = true }; // IsBackground = true, when main thread is terminated, this thread is also terminated.
        this.thread.Start();
    }

    public override long GetFrameCount()
    {
        ThrowHelper.ThrowObjectDisposedIf(disposed, typeof(NewThreadSleepFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowHelper.ThrowObjectDisposedIf(disposed, typeof(NewThreadSleepFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        disposed = true;
    }

    void Run()
    {
        while (!disposed)
        {
            frameCount++;

            var span = list.AsSpan();
            for (int i = 0; i < span.Length; i++)
            {
                ref readonly var item = ref span[i];
                if (item != null)
                {
                    try
                    {
                        if (!item.MoveNext(frameCount))
                        {
                            list.Remove(i);
                        }
                    }
                    catch (Exception ex)
                    {
                        list.Remove(i);
                        try
                        {
                            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                        }
                        catch { }
                    }
                }
            }

            Thread.Sleep(sleepMilliseconds);
        }
        list.Dispose();
    }
}



================================================
FILE: src/R3/Notification.cs
================================================
﻿using System.Runtime.InteropServices;

namespace R3;

public enum NotificationKind : byte
{
    OnNext,
    OnErrorResume,
    OnCompleted
}

[StructLayout(LayoutKind.Auto)]
public readonly struct Notification<T>
{
    readonly NotificationKind kind;
    readonly T? value;
    readonly Exception? errorOrResultFailure;

    public NotificationKind Kind => kind;
    public T Value => value!;
    public Exception Error => errorOrResultFailure!;
    public Result Result => errorOrResultFailure == null ? R3.Result.Success : R3.Result.Failure(errorOrResultFailure);

    public Notification(T value)
    {
        this.kind = NotificationKind.OnNext;
        this.value = value;
        this.errorOrResultFailure = null;
    }

    public Notification(Exception error)
    {
        this.kind = NotificationKind.OnErrorResume;
        this.value = default;
        this.errorOrResultFailure = error;
    }

    public Notification(Result result)
    {
        this.kind = NotificationKind.OnCompleted;
        this.value = default;
        this.errorOrResultFailure = result.Exception;
    }

    public override string? ToString()
    {
        switch (kind)
        {
            case NotificationKind.OnNext:
                return value!.ToString();
            case NotificationKind.OnErrorResume:
                return Error!.ToString();
            case NotificationKind.OnCompleted:
                return Result.ToString();
            default:
                return "";
        }
    }
}



================================================
FILE: src/R3/Observable.cs
================================================
﻿#pragma warning disable CS0618

using System.Diagnostics;

namespace R3;

public abstract class Observable<T>
{
    [StackTraceHidden, DebuggerStepThrough]
    public IDisposable Subscribe(Observer<T> observer)
    {
        try
        {
            var subscription = SubscribeCore(observer);

            if (ObservableTracker.TryTrackActiveSubscription(subscription, 2, out var trackableDisposable))
            {
                subscription = trackableDisposable;
            }

            observer.SourceSubscription.Disposable = subscription;
            return observer; // return observer to make subscription chain.
        }
        catch
        {
            observer.Dispose(); // when SubscribeCore failed, auto detach caller observer
            throw;
        }
    }

    protected abstract IDisposable SubscribeCore(Observer<T> observer);
}

public abstract class Observer<T> : IDisposable
{
#if DEBUG
    [Obsolete("Only allow in Observable<T>.")]
#endif
    internal SingleAssignmentDisposableCore SourceSubscription;

    int calledOnCompleted;
    int disposed;

    public bool IsDisposed => disposed != 0;
    bool IsCalledCompleted => calledOnCompleted != 0;

    // enable/disable auto dispose on completed.
    protected virtual bool AutoDisposeOnCompleted => true;

    [StackTraceHidden, DebuggerStepThrough]
    public void OnNext(T value)
    {
        if (IsDisposed || IsCalledCompleted) return;

        try
        {
            OnNextCore(value);
        }
        catch (Exception ex)
        {
            OnErrorResume(ex);
        }
    }

    protected abstract void OnNextCore(T value);

    [StackTraceHidden, DebuggerStepThrough]
    public void OnErrorResume(Exception error)
    {
        if (IsDisposed || IsCalledCompleted) return;

        try
        {
            OnErrorResumeCore(error);
        }
        catch (Exception ex)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
    }

    protected abstract void OnErrorResumeCore(Exception error);

    [StackTraceHidden, DebuggerStepThrough]
    public void OnCompleted(Result result)
    {
        if (Interlocked.Exchange(ref calledOnCompleted, 1) != 0)
        {
            return;
        }
        if (IsDisposed) return;

        var disposeOnFinally = AutoDisposeOnCompleted;
        try
        {
            OnCompletedCore(result);
        }
        catch (Exception ex)
        {
            disposeOnFinally = true;
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
        }
        finally
        {
            if (disposeOnFinally)
            {
                Dispose();
            }
        }
    }

    protected abstract void OnCompletedCore(Result result);

    [StackTraceHidden, DebuggerStepThrough]
    public void Dispose()
    {
        if (Interlocked.Exchange(ref disposed, 1) != 0)
        {
            return;
        }

        DisposeCore();                // Dispose self
        SourceSubscription.Dispose(); // Dispose attached parent
    }

    [StackTraceHidden, DebuggerStepThrough]
    protected virtual void DisposeCore() { }
}



================================================
FILE: src/R3/ObservableSubscribeExtensions.cs
================================================
﻿using System.Diagnostics;

namespace R3;

public static class ObservableSubscribeExtensions
{
    [DebuggerStepThrough]
    public static IDisposable Subscribe<T>(this Observable<T> source)
    {
        return source.Subscribe(new NopObserver<T>());
    }

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T>(this Observable<T> source, Action<T> onNext)
    {
        return source.Subscribe(new AnonymousObserver<T>(onNext, ObservableSystem.GetUnhandledExceptionHandler(), Stubs.HandleResult));
    }

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T>(this Observable<T> source, Action<T> onNext, Action<Result> onCompleted)
    {
        return source.Subscribe(new AnonymousObserver<T>(onNext, ObservableSystem.GetUnhandledExceptionHandler(), onCompleted));
    }

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T>(this Observable<T> source, Action<T> onNext, Action<Exception> onErrorResume, Action<Result> onCompleted)
    {
        return source.Subscribe(new AnonymousObserver<T>(onNext, onErrorResume, onCompleted));
    }

    // with state

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T, TState>(this Observable<T> source, TState state, Action<T, TState> onNext)
    {
        return source.Subscribe(new AnonymousObserver<T, TState>(onNext, Stubs<TState>.HandleException, Stubs<TState>.HandleResult, state));
    }

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T, TState>(this Observable<T> source, TState state, Action<T, TState> onNext, Action<Result, TState> onCompleted)
    {
        return source.Subscribe(new AnonymousObserver<T, TState>(onNext, Stubs<TState>.HandleException, onCompleted, state));
    }

    [DebuggerStepThrough]
    public static IDisposable Subscribe<T, TState>(this Observable<T> source, TState state, Action<T, TState> onNext, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted)
    {
        return source.Subscribe(new AnonymousObserver<T, TState>(onNext, onErrorResume, onCompleted, state));
    }
}

[DebuggerStepThrough]
internal sealed class NopObserver<T> : Observer<T>
{
    public NopObserver()
    {
    }

    [DebuggerStepThrough]
    protected override void OnNextCore(T value)
    {
    }

    [DebuggerStepThrough]
    protected override void OnErrorResumeCore(Exception error)
    {
        ObservableSystem.GetUnhandledExceptionHandler().Invoke(error);
    }

    [DebuggerStepThrough]
    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(result.Exception);
        }
    }
}

[DebuggerStepThrough]
internal sealed class AnonymousRObserver<T>(Action<T> onNext, Action<Exception> onErrorResume) : Observer<T>
{
    [DebuggerStepThrough]
    protected override void OnNextCore(T value)
    {
        onNext(value);
    }

    [DebuggerStepThrough]
    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error);
    }

    [DebuggerStepThrough]
    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(result.Exception);
        }
    }
}

[DebuggerStepThrough]
internal sealed class AnonymousObserver<T>(Action<T> onNext, Action<Exception> onErrorResume, Action<Result> onCompleted) : Observer<T>
{
    [DebuggerStepThrough]
    protected override void OnNextCore(T value)
    {
        onNext(value);
    }

    [DebuggerStepThrough]
    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error);
    }

    [DebuggerStepThrough]
    protected override void OnCompletedCore(Result complete)
    {
        onCompleted(complete);
    }
}

[DebuggerStepThrough]
internal sealed class AnonymousObserver<T, TState>(Action<T, TState> onNext, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, TState state) : Observer<T>
{
    [DebuggerStepThrough]
    protected override void OnNextCore(T value)
    {
        onNext(value, state);
    }

    [DebuggerStepThrough]
    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error, state);
    }

    [DebuggerStepThrough]
    protected override void OnCompletedCore(Result complete)
    {
        onCompleted(complete, state);
    }
}



================================================
FILE: src/R3/ObservableSystem.cs
================================================
﻿using System;

namespace R3;

public static class ObservableSystem
{
    static IServiceProvider? serviceProvider;
    static Func<IServiceProvider>? serviceProviderFactory;

    static TimeProvider defaultTimeProvider = TimeProvider.System;
    static FrameProvider defaultFrameProvider = new NotSupportedFrameProvider();
    static Action<Exception> unhandledException = DefaultUnhandledExceptionHandler;

    public static TimeProvider DefaultTimeProvider
    {
        get
        {
            var services = serviceProvider;
            if (serviceProviderFactory != null)
            {
                services = serviceProviderFactory();
            }

            if (services != null)
            {
                var provider = services.GetService(typeof(TimeProvider));
                if (provider != null)
                {
                    return (TimeProvider)provider;
                }
            }
            return defaultTimeProvider;
        }
        set
        {
            defaultTimeProvider = value;
        }
    }

    public static FrameProvider DefaultFrameProvider
    {
        get
        {
            var services = serviceProvider;
            if (serviceProviderFactory != null)
            {
                services = serviceProviderFactory();
            }

            if (services != null)
            {
                var provider = services.GetService(typeof(FrameProvider));
                if (provider != null)
                {
                    return (FrameProvider)provider;
                }
            }
            return defaultFrameProvider;
        }
        set
        {
            defaultFrameProvider = value;
        }
    }

    public static void RegisterServiceProvider(IServiceProvider? serviceProvider)
    {
        ObservableSystem.serviceProvider = serviceProvider;
        ObservableSystem.serviceProviderFactory = null;
    }

    public static void RegisterServiceProvider(Func<IServiceProvider> serviceProviderFactory)
    {
        ObservableSystem.serviceProvider = null;
        ObservableSystem.serviceProviderFactory = serviceProviderFactory;
    }

    // Prevent +=, use Set and Get method.
    public static void RegisterUnhandledExceptionHandler(Action<Exception> unhandledExceptionHandler)
    {
        unhandledException = unhandledExceptionHandler;
    }

    public static Action<Exception> GetUnhandledExceptionHandler()
    {
        return unhandledException;
    }

    static void DefaultUnhandledExceptionHandler(Exception exception)
    {
        Console.WriteLine("R3 UnhandleException: " + exception.ToString());
    }
}

internal sealed class NotSupportedFrameProvider : FrameProvider
{
    public override long GetFrameCount()
    {
        throw new NotSupportedException("ObservableSystem.DefaultFrameProvider is not set. Please set ObservableSystem.DefaultFrameProvider to a valid FrameProvider(ThreadSleepFrameProvider, etc...).");
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        throw new NotSupportedException("ObservableSystem.DefaultFrameProvider is not set. Please set ObservableSystem.DefaultFrameProvider to a valid FrameProvider(ThreadSleepFrameProvider, etc...).");
    }
}



================================================
FILE: src/R3/ObservableTracker.cs
================================================
﻿using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;

namespace R3;

public static class ObservableTracker
{
    static int trackingIdCounter = 0;

    public static bool EnableTracking = false;
    public static bool EnableStackTrace = false;

    static readonly WeakDictionary<TrackableDisposable, TrackingState> tracking = new();

    // for iterationg
    static List<TrackingState> iterateCache = new();

    // flag for polling performance
    static bool dirty;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [DebuggerStepThrough]
    internal static bool TryTrackActiveSubscription(IDisposable subscription, int skipFrame, [NotNullWhen(true)] out TrackableDisposable? trackableDisposable)
    {
        if (!EnableTracking)
        {
            trackableDisposable = default;
            return false;
        }
        return TryTrackActiveSubscriptionCore(subscription, skipFrame, out trackableDisposable);
    }

    [DebuggerStepThrough]
    internal static bool TryTrackActiveSubscriptionCore(IDisposable subscription, int skipFrame, [NotNullWhen(true)] out TrackableDisposable? trackableDisposable)
    {
        dirty = true;

        string stackTrace = "";
        if (EnableStackTrace)
        {
            var trace = new StackTrace(skipFrame, true);
            stackTrace = trace.ToString();
        }

        var unwrappedSubscription = UnwrapTrackableDisposable(subscription);
        string typeName;
        if (EnableStackTrace)
        {
            var sb = new StringBuilder();
            TypeBeautify(unwrappedSubscription.GetType(), sb);
            typeName = sb.ToString();
        }
        else
        {
            typeName = unwrappedSubscription.GetType().Name;
        }

        var id = Interlocked.Increment(ref trackingIdCounter);
        trackableDisposable = new TrackableDisposable(subscription, id);
        tracking.TryAdd(trackableDisposable, new TrackingState(id, typeName, DateTime.Now, stackTrace)); // use local now.

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static void RemoveTracking(TrackableDisposable subscription)
    {
        if (!EnableTracking) return;

        dirty = true;
        tracking.TryRemove(subscription);
    }

    public static bool CheckAndResetDirty()
    {
        var current = dirty;
        dirty = false;
        return current;
    }

    public static void ForEachActiveTask(Action<TrackingState> action)
    {
        lock (iterateCache)
        {
            var count = tracking.CaptureSnapshot(ref iterateCache, clear: false);
            iterateCache.Sort(0, count, Comparer<TrackingState>.Default);
            try
            {
                for (int i = 0; i < count; i++)
                {
                    action(iterateCache[i]);
                }
            }
            finally
            {
                iterateCache.Clear();
            }
        }
    }

    static void TypeBeautify(Type type, StringBuilder sb)
    {
        if (type.IsNested)
        {
            // TypeBeautify(type.DeclaringType, sb);
            sb.Append(type.DeclaringType!.Name.ToString());
            sb.Append(".");
        }

        if (type.IsGenericType)
        {
            var genericsStart = type.Name.IndexOf("`");
            if (genericsStart != -1)
            {
                sb.Append(type.Name.Substring(0, genericsStart));
            }
            else
            {
                sb.Append(type.Name);
            }
            sb.Append("<");
            var first = true;
            foreach (var item in type.GetGenericArguments())
            {
                if (!first)
                {
                    sb.Append(", ");
                }
                first = false;
                TypeBeautify(item, sb);
            }
            sb.Append(">");
        }
        else
        {
            sb.Append(type.Name);
        }
    }

    static IDisposable UnwrapTrackableDisposable(IDisposable disposable)
    {
        while (disposable is TrackableDisposable t)
        {
            disposable = t.Disposable;
        }
        return disposable;
    }
}

internal sealed class TrackableDisposable(IDisposable disposable, int trackingId) : IDisposable
{
    public IDisposable Disposable => disposable;
    public int TrackingId => trackingId;
    int disposed;

    public void Dispose()
    {
        var field = Interlocked.CompareExchange(ref disposed, 1, 0);
        if (field == 0)
        {
            ObservableTracker.RemoveTracking(this);
        }

        disposable.Dispose();
    }

    public override string? ToString()
    {
        return disposable.ToString();
    }
}

public record struct TrackingState(int TrackingId, string FormattedType, DateTime AddTime, string StackTrace) : IComparable<TrackingState>
{
    public int CompareTo(TrackingState other)
    {
        return TrackingId.CompareTo(other.TrackingId);
    }
}



================================================
FILE: src/R3/ObserverExtensions.cs
================================================
﻿namespace R3;

public static class ObserverExtensions
{
    public static void OnCompleted<T>(this Observer<T> observer)
    {
        observer.OnCompleted(Result.Success);
    }

    public static void OnCompleted<T>(this Observer<T> observer, Exception exception)
    {
        observer.OnCompleted(Result.Failure(exception));
    }

    public static Observer<T> Wrap<T>(this Observer<T> observer)
    {
        return new WrappedObserver<T>(observer);
    }


    public static Observer<T> ToObserver<T>(this IObserver<T> observer)
    {
        return new IObserverToObserver<T>(observer);
    }
}

internal sealed class IObserverToObserver<T>(IObserver<T> observer) : Observer<T>
{
    protected override void OnNextCore(T value)
    {
        observer.OnNext(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        observer.OnError(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            observer.OnError(result.Exception);
        }
        else
        {
            observer.OnCompleted();
        }
    }
}

internal sealed class WrappedObserver<T>(Observer<T> observer) : Observer<T>
{
    protected override void OnNextCore(T value)
    {
        observer.OnNext(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        observer.OnErrorResume(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        observer.OnCompleted(result);
    }

    protected override void DisposeCore()
    {
        observer.Dispose();
    }
}



================================================
FILE: src/R3/R3.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>netstandard2.0;netstandard2.1;net6.0;net8.0</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>

        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageTags>rx</PackageTags>
        <Description>The evolution of dotnet/reactive and UniRx.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="PolySharp" Version="1.14.1">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup Condition="$(TargetFramework) == 'net6.0'">
        <PackageReference Include="Microsoft.Bcl.TimeProvider" Version="8.0.0" />
    </ItemGroup>

    <ItemGroup Condition="$(TargetFramework) == 'netstandard2.0'">
        <PackageReference Include="System.Buffers" Version="4.5.1" />
        <PackageReference Include="System.Memory" Version="4.5.5" />

    </ItemGroup>

    <ItemGroup Condition="$(TargetFramework) == 'netstandard2.0' Or $(TargetFramework) == 'netstandard2.1'">
        <PackageReference Include="Microsoft.Bcl.TimeProvider" Version="8.0.0" />
        <PackageReference Include="System.Threading.Channels" Version="8.0.0" />
        <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
        <PackageReference Include="System.ComponentModel.Annotations" Version="5.0.0" />
    </ItemGroup>

    <ItemGroup>
        <Using Include="R3" />
        <Using Include="R3.Internal" />
        <Using Include="R3.Collections" />
    </ItemGroup>

    <ItemGroup>
        <None Update="Operators\CombineLatest.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>CombineLatest.cs</LastGenOutput>
        </None>
        <None Update="Operators\Zip.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>Zip.cs</LastGenOutput>
        </None>
        <None Update="Operators\ZipLatest.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>ZipLatest.cs</LastGenOutput>
        </None>
        <None Update="Operators\AverageAsync.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>AverageAsync.cs</LastGenOutput>
        </None>
        <None Update="Operators\SumAsync.tt">
            <Generator>TextTemplatingFileGenerator</Generator>
            <LastGenOutput>SumAsync.cs</LastGenOutput>
        </None>
    </ItemGroup>

    <ItemGroup>
        <Service Include="{508349b6-6b84-4df5-91f0-309beebad82d}" />
    </ItemGroup>

    <ItemGroup>
        <Compile Update="Operators\CombineLatest.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>CombineLatest.tt</DependentUpon>
        </Compile>
        <Compile Update="Operators\Zip.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>Zip.tt</DependentUpon>
        </Compile>
        <Compile Update="Operators\ZipLatest.cs">
            <DesignTime>True</DesignTime>
            <AutoGen>True</AutoGen>
            <DependentUpon>ZipLatest.tt</DependentUpon>
        </Compile>
        <Compile Update="Operators\AverageAsync.cs">
          <AutoGen>True</AutoGen>
          <DesignTime>True</DesignTime>
          <DependentUpon>AverageAsync.tt</DependentUpon>
        </Compile>
        <Compile Update="Operators\SumAsync.cs">
          <DependentUpon>SumAsync.tt</DependentUpon>
          <DesignTime>True</DesignTime>
          <AutoGen>True</AutoGen>
        </Compile>
    </ItemGroup>

</Project>



================================================
FILE: src/R3/ReactiveCommand.cs
================================================
﻿using System.Runtime.CompilerServices;
using System.Windows.Input; // for XAML binding

namespace R3;

public class ReactiveCommand<T> : Observable<T>, ICommand, IDisposable
{
    FreeListCore<Subscription> list; // struct(array, int)
    CompleteState completeState;     // struct(int, IntPtr)
    IDisposable subscription; // from canExecuteSource (and onNext).
    bool canExecute; // set from observable sequence

    public event EventHandler? CanExecuteChanged;

    public ReactiveCommand()
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = true;
        this.subscription = Disposable.Empty;
    }

    public ReactiveCommand(Action<T> execute)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = true;
        this.subscription = this.Subscribe(execute);
    }

    public ReactiveCommand(Func<T, CancellationToken, ValueTask> executeAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxSequential = -1)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = true;
        this.subscription = this.SubscribeAwait(executeAsync, awaitOperation, configureAwait, cancelOnCompleted, maxSequential);
    }

    public ReactiveCommand(Observable<bool> canExecuteSource, bool initialCanExecute)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = initialCanExecute;
        this.subscription = canExecuteSource.Subscribe(this, static (newCanExecute, state) =>
        {
            state.ChangeCanExecute(newCanExecute);
        });
    }

    bool ICommand.CanExecute(object? _) // parameter is ignored
    {
        return CanExecute();
    }

    void ICommand.Execute(object? parameter)
    {
        if (typeof(T) == typeof(Unit))
        {
            Execute(Unsafe.As<Unit, T>(ref Unsafe.AsRef(in Unit.Default)));
        }
        else
        {
            Execute((T)parameter!);
        }
    }

    public void ChangeCanExecute(bool canExecute)
    {
        if (this.canExecute == canExecute) return;
        this.canExecute = canExecute;
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public bool IsDisabled => !CanExecute();

    public bool CanExecute()
    {
        return canExecute;
    }

    public void Execute(T parameter)
    {
        if (completeState.IsCompleted) return;

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnNext(parameter);
        }
    }

    internal void CombineSubscription(IDisposable disposable)
    {
        this.subscription = Disposable.Combine(this.subscription, disposable);
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var result = completeState.TryGetResult();
        if (result != null)
        {
            observer.OnCompleted(result.Value);
            return Disposable.Empty;
        }

        var subscription = new Subscription(this, observer); // create subscription and add observer to list.

        // need to check called completed during adding
        result = completeState.TryGetResult();
        if (result != null)
        {
            subscription.observer.OnCompleted(result.Value);
            subscription.Dispose();
            return Disposable.Empty;
        }

        return subscription;
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (callOnCompleted && !alreadyCompleted)
            {
                // not yet disposed so can call list iteration
                foreach (var subscription in list.AsSpan())
                {
                    subscription?.observer.OnCompleted();
                }
            }

            list.Dispose();
            subscription.Dispose();
        }
    }


    sealed class Subscription : IDisposable
    {
        public readonly Observer<T> observer;
        readonly int removeKey;
        ReactiveCommand<T>? parent;

        public Subscription(ReactiveCommand<T> parent, Observer<T> observer)
        {
            this.parent = parent;
            this.observer = observer;
            parent.list.Add(this, out removeKey); // for the thread-safety, add and set removeKey in same lock.
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // removeKey is index, will reuse if remove completed so only allows to call from here and must not call twice.
            p.list.Remove(removeKey);
        }
    }
}

public class ReactiveCommand<TInput, TOutput> : Observable<TOutput>, ICommand, IDisposable
{
    FreeListCore<Subscription> list; // struct(array, int)
    CompleteState completeState;     // struct(int, IntPtr)
    bool canExecute; // set from observable sequence
    IDisposable subscription;

    readonly Func<TInput, TOutput>? convert;     // for sync
    SingleAssignmentSubject<TInput>? asyncInput; // for async

    public event EventHandler? CanExecuteChanged;

    public ReactiveCommand(Func<TInput, TOutput> convert)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = true;
        this.convert = convert;
        this.subscription = Disposable.Empty;
    }

    public ReactiveCommand(Func<TInput, CancellationToken, ValueTask<TOutput>> convertAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxSequential = -1)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = true;
        this.asyncInput = new SingleAssignmentSubject<TInput>();
        this.subscription = asyncInput.SelectAwait(convertAsync, awaitOperation, configureAwait, cancelOnCompleted, maxSequential).Subscribe(this, static (x, state) =>
        {
            if (state.completeState.IsCompleted) return;

            foreach (var subscription in state.list.AsSpan())
            {
                subscription?.observer.OnNext(x);
            }
        });
    }

    public ReactiveCommand(Observable<bool> canExecuteSource, bool initialCanExecute, Func<TInput, TOutput> convert)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = initialCanExecute;
        this.convert = convert;
        this.subscription = canExecuteSource.Subscribe(this, static (newCanExecute, state) =>
        {
            state.ChangeCanExecute(newCanExecute);
        });
    }

    public ReactiveCommand(Observable<bool> canExecuteSource, bool initialCanExecute, Func<TInput, CancellationToken, ValueTask<TOutput>> convertAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxSequential = -1)
    {
        this.list = new FreeListCore<Subscription>(this);
        this.canExecute = initialCanExecute;
        var subscription1 = canExecuteSource.Subscribe(this, static (newCanExecute, state) =>
        {
            state.ChangeCanExecute(newCanExecute);
        });

        this.asyncInput = new SingleAssignmentSubject<TInput>();
        var subscription2 = asyncInput.SelectAwait(convertAsync, awaitOperation, configureAwait, cancelOnCompleted, maxSequential).Subscribe(this, static (x, state) =>
        {
            if (state.completeState.IsCompleted) return;

            foreach (var subscription in state.list.AsSpan())
            {
                subscription?.observer.OnNext(x);
            }
        });

        this.subscription = Disposable.Combine(subscription1, subscription2);
    }

    bool ICommand.CanExecute(object? _) // parameter is ignored
    {
        return CanExecute();
    }

    void ICommand.Execute(object? parameter)
    {
        if (typeof(TInput) == typeof(Unit))
        {
            Execute(Unsafe.As<Unit, TInput>(ref Unsafe.AsRef(in Unit.Default)));
        }
        else
        {
            Execute((TInput)parameter!);
        }
    }

    public void ChangeCanExecute(bool canExecute)
    {
        if (this.canExecute == canExecute) return;
        this.canExecute = canExecute;
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public bool IsDisabled => !CanExecute();

    public bool CanExecute()
    {
        return canExecute;
    }

    public void Execute(TInput parameter)
    {
        if (completeState.IsCompleted) return;

        if (convert != null)
        {
            // sync
            foreach (var subscription in list.AsSpan())
            {
                subscription?.observer.OnNext(convert(parameter));
            }
        }
        else if (asyncInput != null)
        {
            // async
            asyncInput.OnNext(parameter);
        }
    }

    protected override IDisposable SubscribeCore(Observer<TOutput> observer)
    {
        var result = completeState.TryGetResult();
        if (result != null)
        {
            observer.OnCompleted(result.Value);
            return Disposable.Empty;
        }

        var subscription = new Subscription(this, observer); // create subscription and add observer to list.

        // need to check called completed during adding
        result = completeState.TryGetResult();
        if (result != null)
        {
            subscription.observer.OnCompleted(result.Value);
            subscription.Dispose();
            return Disposable.Empty;
        }

        return subscription;
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (callOnCompleted && !alreadyCompleted)
            {
                // not yet disposed so can call list iteration
                foreach (var subscription in list.AsSpan())
                {
                    subscription?.observer.OnCompleted();
                }
            }

            list.Dispose();
            subscription?.Dispose();
            asyncInput?.Dispose();
        }
    }

    sealed class Subscription : IDisposable
    {
        public readonly Observer<TOutput> observer;
        readonly int removeKey;
        ReactiveCommand<TInput, TOutput>? parent;

        public Subscription(ReactiveCommand<TInput, TOutput> parent, Observer<TOutput> observer)
        {
            this.parent = parent;
            this.observer = observer;
            parent.list.Add(this, out removeKey); // for the thread-safety, add and set removeKey in same lock.
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // removeKey is index, will reuse if remove completed so only allows to call from here and must not call twice.
            p.list.Remove(removeKey);
        }
    }
}

public class ReactiveCommand : ReactiveCommand<Unit>
{
    public ReactiveCommand() : base()
    {
    }

    public ReactiveCommand(Action<Unit> execute) : base(execute)
    {
    }

    public ReactiveCommand(Func<Unit, CancellationToken, ValueTask> executeAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxSequential = -1)
        : base(executeAsync, awaitOperation, configureAwait, cancelOnCompleted, maxSequential)
    {
    }

    public ReactiveCommand(Observable<bool> canExecuteSource, bool initialCanExecute)
        : base(canExecuteSource, initialCanExecute)
    {
    }
}

public static class ReactiveCommandExtensions
{
    public static ReactiveCommand<T> ToReactiveCommand<T>(this Observable<bool> canExecuteSource, bool initialCanExecute = true)
    {
        var command = new ReactiveCommand<T>(canExecuteSource, initialCanExecute);
        return command;
    }

    public static ReactiveCommand<T> ToReactiveCommand<T>(this Observable<bool> canExecuteSource, Action<T> execute, bool initialCanExecute = true)
    {
        var command = new ReactiveCommand<T>(canExecuteSource, initialCanExecute);

        var subscription = command.Subscribe(execute);
        command.CombineSubscription(subscription);

        return command;
    }

    public static ReactiveCommand<TInput, TOutput> ToReactiveCommand<TInput, TOutput>(this Observable<bool> canExecuteSource, Func<TInput, TOutput> convert, bool initialCanExecute = true)
    {
        var command = new ReactiveCommand<TInput, TOutput>(canExecuteSource, initialCanExecute, convert);
        return command;
    }

    public static ReactiveCommand ToReactiveCommand(this Observable<bool> canExecuteSource, bool initialCanExecute = true)
    {
        var command = new ReactiveCommand(canExecuteSource, initialCanExecute);
        return command;
    }

    public static ReactiveCommand ToReactiveCommand(this Observable<bool> canExecuteSource, Action<Unit> execute, bool initialCanExecute = true)
    {
        var command = new ReactiveCommand(canExecuteSource, initialCanExecute);

        var subscription = command.Subscribe(execute);
        command.CombineSubscription(subscription);

        return command;
    }

    public static ReactiveCommand<T> ToReactiveCommand<T>(
        this Observable<bool> canExecuteSource, Func<T, CancellationToken, ValueTask> executeAsync,
        bool initialCanExecute = true,
        AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true,
        bool cancelOnCompleted = false, int maxSequential = -1)
    {
        var command = new ReactiveCommand<T>(canExecuteSource, initialCanExecute);

        var subscription = command.SubscribeAwait(async (x, ct) => await executeAsync(x, ct), awaitOperation, configureAwait, cancelOnCompleted, maxSequential);
        command.CombineSubscription(subscription);

        return command;
    }

    public static ReactiveCommand<TInput, TOutput> ToReactiveCommand<TInput, TOutput>(
        this Observable<bool> canExecuteSource, Func<TInput, CancellationToken, ValueTask<TOutput>> convertAsync,
        bool initialCanExecute = true,
        AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true,
        bool cancelOnCompleted = false, int maxSequential = -1)
    {
        var command = new ReactiveCommand<TInput, TOutput>(canExecuteSource, initialCanExecute, convertAsync, awaitOperation, configureAwait, cancelOnCompleted, maxSequential);
        return command;
    }
}



================================================
FILE: src/R3/ReactiveProperty.cs
================================================
﻿#if NET6_0_OR_GREATER
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

namespace R3;

public abstract class ReadOnlyReactiveProperty<T> : Observable<T>, IDisposable
{
    public abstract T CurrentValue { get; }
    protected virtual void OnValueChanged(T value) { }
    protected virtual void OnReceiveError(Exception exception) { }
    public ReadOnlyReactiveProperty<T> ToReadOnlyReactiveProperty() => this;
    public abstract void Dispose();
}

// allow inherit

#if NET6_0_OR_GREATER
[JsonConverter(typeof(ReactivePropertyJsonConverterFactory))]
#endif
public class ReactiveProperty<T> : ReadOnlyReactiveProperty<T>, ISubject<T>
{
    const byte NotCompleted = 0;
    const byte CompletedSuccess = 1;
    const byte CompletedFailure = 2;
    const byte Disposed = 3;

    // Memory Size: 1(byte) + 8(IntPtr) + sizeof(T) + 8(IntPtr) and subscriptions(nodes).
    byte completeState;
    Exception? error;
    T currentValue;
    IEqualityComparer<T>? equalityComparer; // allow null for no-compare

    // For reduce memory usage, ReactiveProperty<T> itself is LinkedList and subscription represents LinkedListNode.
    // The last of node is root.Previous(if null, single list).
    ObserverNode? root;

    public IEqualityComparer<T>? EqualityComparer => equalityComparer;

    public override T CurrentValue => currentValue;

    public bool HasObservers => root != null;
    public bool IsCompleted => completeState == CompletedSuccess || completeState == CompletedFailure;
    public bool IsDisposed => completeState == Disposed;
    public bool IsCompletedOrDisposed => IsCompleted || IsDisposed;

    public virtual T Value
    {
        get => this.currentValue;
        set
        {
            OnValueChanging(ref value);

            if (EqualityComparer != null)
            {
                if (EqualityComparer.Equals(this.currentValue, value))
                {
                    return;
                }
            }

            this.currentValue = value;
            OnValueChanged(value);

            OnNextCore(value);
        }
    }

    public ReactiveProperty() : this(default!)
    {
    }

    public ReactiveProperty(T value)
        : this(value, EqualityComparer<T>.Default)
    {
    }

    public ReactiveProperty(T value, IEqualityComparer<T>? equalityComparer)
    {
        this.equalityComparer = equalityComparer;
        OnValueChanging(ref value);
        this.currentValue = value;
        OnValueChanged(value);
    }

    protected ReactiveProperty(T value, IEqualityComparer<T>? equalityComparer, bool callOnValueChangeInBaseConstructor)
    {
        this.equalityComparer = equalityComparer;

        if (callOnValueChangeInBaseConstructor)
        {
            OnValueChanging(ref value);
        }

        this.currentValue = value;

        if (callOnValueChangeInBaseConstructor)
        {
            OnValueChanged(value);
        }
    }

    protected virtual void OnValueChanging(ref T value) { }
    protected ref T GetValueRef() => ref currentValue; // dangerous

    public virtual void ForceNotify()
    {
        OnNext(Value);
    }

    public virtual void OnNext(T value)
    {
        OnValueChanging(ref value);
        this.currentValue = value; // different from Subject<T>; set value before raise OnNext
        OnValueChanged(value);  // for inheritance types.

        OnNextCore(value);
    }

    protected virtual void OnNextCore(T value)
    {
        ThrowIfDisposed();
        if (IsCompleted) return;

        var node = root;
        var last = node?.Previous;
        while (node != null)
        {
            node.Observer.OnNext(value);
            if (node == last) return;
            node = node.Next;
        }
    }

    public void OnErrorResume(Exception error)
    {
        ThrowIfDisposed();
        if (IsCompleted) return;

        OnReceiveError(error);

        var node = Volatile.Read(ref root);
        var last = node?.Previous;
        while (node != null)
        {
            node.Observer.OnErrorResume(error);
            if (node == last) return;
            node = node.Next;
        }
    }

    public void OnCompleted(Result result)
    {
        ThrowIfDisposed();
        if (IsCompleted) return;

        ObserverNode? node = null;
        lock (this) // I know lock(this) is dangerous.
        {
            if (completeState == NotCompleted)
            {
                completeState = result.IsSuccess ? CompletedSuccess : CompletedFailure;
                error = result.Exception;
                node = Volatile.Read(ref root);
                Volatile.Write(ref root, null); // when complete, List is clear.
            }
            else
            {
                // IsCompleted = do-nothing, IsDisposed = throw
                ThrowIfDisposed();
                return;
            }
        }

        if (result.IsFailure)
        {
            OnReceiveError(result.Exception);
        }

        var last = node?.Previous;
        while (node != null)
        {
            node.Observer.OnCompleted(result);
            if (node == last) return;
            node = node.Next;
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        Result? completedResult;
        lock (this)
        {
            ThrowIfDisposed();
            if (IsCompleted)
            {
                completedResult = (error == null) ? Result.Success : Result.Failure(error);
            }
            else
            {
                completedResult = null;
            }
        }

        if (completedResult != null)
        {
            goto PUBLISH_CURRENT_AND_RESULT;
        }

        // raise latest value on subscribe(before add observer to list)
        observer.OnNext(currentValue);

        lock (this)
        {
            ThrowIfDisposed();
            if (IsCompleted)
            {
                completedResult = (error == null) ? Result.Success : Result.Failure(error);
                goto PUBLISH_RESULT;
            }

            // create subscription and add to list in lock.
            var subscription = new ObserverNode(this, observer);
            return subscription;
        }

    PUBLISH_CURRENT_AND_RESULT:
        if (completedResult != null)
        {
            if (completedResult.Value.IsSuccess)
            {
                observer.OnNext(currentValue);
            }
            observer.OnCompleted(completedResult.Value);
            return Disposable.Empty;
        }

    PUBLISH_RESULT:
        if (completedResult != null)
        {
            observer.OnCompleted(completedResult.Value);
        }
        return Disposable.Empty;
    }

    void ThrowIfDisposed()
    {
        if (IsDisposed) throw new ObjectDisposedException("");
    }

    public override void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        ObserverNode? node = null;
        lock (this)
        {
            if (completeState == Disposed)
            {
                return;
            }

            // not yet disposed so can call list iteration
            if (callOnCompleted && !IsCompleted)
            {
                node = Volatile.Read(ref root);
            }

            Volatile.Write(ref root, null);
            completeState = Disposed;
        }

        while (node != null)
        {
            node.Observer.OnCompleted();
            node = node.Next;
        }

        DisposeCore();
    }

    protected virtual void DisposeCore() { }

    public override string? ToString()
    {
        return (currentValue == null) ? "(null)" : currentValue.ToString();
    }

    // debugging property

#if DEBUG

    public int NodeCount
    {
        get
        {
            var count = 0;
            var node = root;
            while (node != null)
            {
                count++;
                node = node.Next;
            }
            return count;
        }
    }

    ObserverNode[] Nodes
    {
        get
        {
            var list = new List<ObserverNode>();
            var node = root;
            while (node != null)
            {
                list.Add(node);
                node = node.Next;
            }
            return list.ToArray();
        }
    }

#endif

    sealed class ObserverNode : IDisposable
    {
        public readonly Observer<T> Observer;

        ReactiveProperty<T>? parent;

        public ObserverNode? Previous { get; set; } // Previous is last node or root(null).
        public ObserverNode? Next { get; set; }


        // for debugging field/property
#if DEBUG
        static int idGenerator;
        public int Id = Interlocked.Increment(ref idGenerator);
        public bool IsRootNode => parent?.root == this;
        public bool IsSingleRootNode => IsRootNode && Previous == null;

        public override string ToString()
        {
            return $"{Previous?.Id} -> ({Id}) -> {Next?.Id}";
        }
#endif

        public ObserverNode(ReactiveProperty<T> parent, Observer<T> observer)
        {
            this.parent = parent;
            this.Observer = observer;

            // Add node(self) to list(ReactiveProperty), called in lock
            if (parent.root == null)
            {
                // Single list(both previous and next is null)
                Volatile.Write(ref parent.root, this);
            }
            else
            {
                // previous is last, null then root is last.
                var lastNode = parent.root.Previous ?? parent.root;

                lastNode.Next = this;
                this.Previous = lastNode;
                parent.root.Previous = this;
            }
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // keep this.Next for dispose on iterating
            // Remove node(self) from list(ReactiveProperty)
            lock (p)
            {
                if (p.IsCompletedOrDisposed) return;

                if (this == p.root)
                {
                    if (this.Previous == null || this.Next == null)
                    {
                        // case of single list
                        p.root = null;
                    }
                    else
                    {
                        // otherwise, root is next node.
                        var root = this.Next;

                        // single list.
                        if (root.Next == null)
                        {
                            root.Previous = null;
                        }
                        else
                        {
                            root.Previous = this.Previous; // as last.
                        }

                        p.root = root;
                    }
                }
                else
                {
                    // node is not root, previous must exists
                    this.Previous!.Next = this.Next;
                    if (this.Next != null)
                    {
                        this.Next.Previous = this.Previous;
                    }
                    else
                    {
                        // next does not exists, previous is last node so modify root
                        p.root!.Previous = this.Previous;
                    }
                }
            }
        }
    }
}

#if NET6_0_OR_GREATER

public class ReactivePropertyJsonConverterFactory : JsonConverterFactory
{
    public override bool CanConvert(Type typeToConvert)
    {
        return GetReactivePropertyType(typeToConvert) != null;
    }

    public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)
    {
        var t = GetReactivePropertyType(typeToConvert);
        if (t != null)
        {
            var rt = GenericConverterType.MakeGenericType(t.GetGenericArguments()[0]);
            return (JsonConverter?)Activator.CreateInstance(rt, false);
        }
        else
        {
            return null;
        }
    }

    Type? GetReactivePropertyType(Type? type)
    {
        while (type != null)
        {
            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ReactiveProperty<>))
            {
                return type;
            }

            type = type.BaseType;
        }
        return null;
    }

    // allow customize
    protected virtual Type GenericConverterType => typeof(ReactivePropertyJsonConverter<>);
}

public class ReactivePropertyJsonConverter<T> : JsonConverter<ReactiveProperty<T>>
{
    public override void Write(Utf8JsonWriter writer, ReactiveProperty<T> value, JsonSerializerOptions options)
    {
        JsonSerializer.Serialize(writer, value.Value, options);
    }

    public override ReactiveProperty<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var v = JsonSerializer.Deserialize<T>(ref reader, options);
        return CreateReactiveProperty(v!);
    }

    // allow customize
    protected virtual ReactiveProperty<T> CreateReactiveProperty(T value)
    {
        return new ReactiveProperty<T>(value);
    }

    public override bool CanConvert(Type typeToConvert)
    {
        return GetReactivePropertyType(typeToConvert) != null;
    }

    Type? GetReactivePropertyType(Type? type)
    {
        while (type != null)
        {
            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ReactiveProperty<>))
            {
                return type;
            }

            type = type.BaseType;
        }
        return null;
    }
}

// for BindableReactiveProperty

internal class BindableReactivePropertyJsonConverterFactory : ReactivePropertyJsonConverterFactory
{
    protected override Type GenericConverterType => typeof(BindableReactivePropertyJsonConverter<>);
}

internal class BindableReactivePropertyJsonConverter<T> : ReactivePropertyJsonConverter<T>
{
    protected override ReactiveProperty<T> CreateReactiveProperty(T value)
    {
        return new BindableReactiveProperty<T>(value);
    }
}

// for SynchronizedReactiveProperty

internal class SynchronizedReactivePropertyJsonConverterFactory : ReactivePropertyJsonConverterFactory
{
    protected override Type GenericConverterType => typeof(SynchronizedReactivePropertyJsonConverter<>);
}

internal class SynchronizedReactivePropertyJsonConverter<T> : ReactivePropertyJsonConverter<T>
{
    protected override ReactiveProperty<T> CreateReactiveProperty(T value)
    {
        return new SynchronizedReactiveProperty<T>(value);
    }
}

#endif



================================================
FILE: src/R3/ReactivePropertyExtensions.cs
================================================
﻿using System.Collections;
using System.ComponentModel;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;

namespace R3;

public static class ReactivePropertyExtensions
{
    public static ReadOnlyReactiveProperty<T> ToReadOnlyReactiveProperty<T>(this Observable<T> source, T initialValue = default!)
    {
        return source.ToReadOnlyReactiveProperty(EqualityComparer<T>.Default, initialValue);
    }

    public static ReadOnlyReactiveProperty<T> ToReadOnlyReactiveProperty<T>(this Observable<T> source, IEqualityComparer<T>? equalityComparer, T initialValue = default!)
    {
        // allow to cast ReactiveProperty<T>
        return new ConnectedReactiveProperty<T>(source, initialValue, equalityComparer);
    }

    // ToBindable

    public static BindableReactiveProperty<T> ToBindableReactiveProperty<T>(this Observable<T> source, T initialValue = default!)
    {
        return new BindableReactiveProperty<T>(source, initialValue, EqualityComparer<T>.Default);
    }

    public static BindableReactiveProperty<T> ToBindableReactiveProperty<T>(this Observable<T> source, IEqualityComparer<T>? equalityComparer, T initialValue = default!)
    {
        return new BindableReactiveProperty<T>(source, initialValue, equalityComparer);
    }

    public static IReadOnlyBindableReactiveProperty<T> ToReadOnlyBindableReactiveProperty<T>(this Observable<T> source, T initialValue = default!)
    {
        return new ReadOnlyBindableReactiveProperty<T>(new BindableReactiveProperty<T>(source, initialValue, EqualityComparer<T>.Default));
    }

    public static IReadOnlyBindableReactiveProperty<T> ToReadOnlyBindableReactiveProperty<T>(this Observable<T> source, IEqualityComparer<T>? equalityComparer, T initialValue = default!)
    {
        return new ReadOnlyBindableReactiveProperty<T>(new BindableReactiveProperty<T>(source, initialValue, equalityComparer));
    }
}

internal sealed class ConnectedReactiveProperty<T> : ReactiveProperty<T>
{
    readonly IDisposable sourceSubscription;

    public ConnectedReactiveProperty(Observable<T> source, T initialValue, IEqualityComparer<T>? equalityComparer)
        : base(initialValue, equalityComparer)
    {
        this.sourceSubscription = source.Subscribe(new Observer(this));
    }

    protected override void DisposeCore()
    {
        sourceSubscription.Dispose();
    }

    class Observer(ConnectedReactiveProperty<T> parent) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            parent.Value = value;
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            parent.OnCompleted(result);
        }
    }
}

internal sealed class ReadOnlyBindableReactiveProperty<T>(BindableReactiveProperty<T> property) : IReadOnlyBindableReactiveProperty<T>
{
    public T Value => ((IReadOnlyBindableReactiveProperty<T>)property).Value;
    public bool IsValidationEnabled => ((IReadOnlyBindableReactiveProperty<T>)property).IsValidationEnabled;

    public bool HasErrors => ((INotifyDataErrorInfo)property).HasErrors;

    object? IReadOnlyBindableReactiveProperty.Value => ((IReadOnlyBindableReactiveProperty)property).Value;

    PropertyChangedEventHandler? propertyChangedCore;

    public event PropertyChangedEventHandler? PropertyChanged
    {
        add
        {
            propertyChangedCore += value;
            ((INotifyPropertyChanged)property).PropertyChanged += PropertyChangedEventHandler;
        }

        remove
        {
            propertyChangedCore -= value;
            ((INotifyPropertyChanged)property).PropertyChanged -= PropertyChangedEventHandler;
        }
    }

    EventHandler<DataErrorsChangedEventArgs>? errorsChangedCore;

    public event EventHandler<DataErrorsChangedEventArgs>? ErrorsChanged
    {
        add
        {
            errorsChangedCore += value;
            ((INotifyDataErrorInfo)property).ErrorsChanged += ErrorsChangedEventHandler;
        }

        remove
        {
            errorsChangedCore -= value;
            ((INotifyDataErrorInfo)property).ErrorsChanged -= ErrorsChangedEventHandler;
        }
    }

    void PropertyChangedEventHandler(object? sender, PropertyChangedEventArgs e)
    {
        // parent sender is BindableReactiveProperty<T>, change to self.
        propertyChangedCore?.Invoke(this, e);
    }

    void ErrorsChangedEventHandler(object? sender, DataErrorsChangedEventArgs e)
    {
        errorsChangedCore?.Invoke(this, e);
    }

    public Observable<T> AsObservable()
    {
        return ((IReadOnlyBindableReactiveProperty<T>)property).AsObservable();
    }

    public void Dispose()
    {
        ((IDisposable)property).Dispose();
    }

    public IReadOnlyBindableReactiveProperty<T> EnableValidation()
    {
        return ((IReadOnlyBindableReactiveProperty<T>)property).EnableValidation();
    }

    public IReadOnlyBindableReactiveProperty<T> EnableValidation(Func<T, Exception?> validator)
    {
        return ((IReadOnlyBindableReactiveProperty<T>)property).EnableValidation(validator);
    }

    public IReadOnlyBindableReactiveProperty<T> EnableValidation<TClass>([CallerMemberName] string? propertyName = null)
    {
        return ((IReadOnlyBindableReactiveProperty<T>)property).EnableValidation<TClass>(propertyName);
    }

    public IReadOnlyBindableReactiveProperty<T> EnableValidation(Expression<Func<IReadOnlyBindableReactiveProperty<T>?>> selfSelector)
    {
        return ((IReadOnlyBindableReactiveProperty<T>)property).EnableValidation(selfSelector);
    }

    public IEnumerable GetErrors(string? propertyName)
    {
        return ((INotifyDataErrorInfo)property).GetErrors(propertyName);
    }

    public override string? ToString()
    {
        return property.ToString();
    }

    public IReadOnlyBindableReactiveProperty<T> ForceValidate()
    {
        return property.ForceValidate();
    }
}



================================================
FILE: src/R3/ReplayFrameSubject.cs
================================================
﻿namespace R3;

public sealed class ReplayFrameSubject<T> : Observable<T>, ISubject<T>, IDisposable
{
    readonly int bufferSize;
    readonly int window;
    readonly FrameProvider frameProvider;
    readonly RingBuffer<(long timestamp, T value)> replayBuffer; // lock object

    // Subject
    FreeListCore<Subscription> list;
    CompleteState completeState;

    public ReplayFrameSubject(int window)
        : this(int.MaxValue, int.MaxValue, ObservableSystem.DefaultFrameProvider)
    {
    }

    public ReplayFrameSubject(int window, FrameProvider frameProvider)
        : this(int.MaxValue, window, frameProvider)
    {
    }

    public ReplayFrameSubject(int bufferSize, int window)
        : this(bufferSize, window, ObservableSystem.DefaultFrameProvider)
    {
    }

    // full constructor
    public ReplayFrameSubject(int bufferSize, int window, FrameProvider frameProvider)
    {
        this.bufferSize = bufferSize;
        this.window = window;
        this.frameProvider = frameProvider;
        this.replayBuffer = new RingBuffer<(long, T)>(bufferSize < 8 ? bufferSize : 8);
        this.list = new FreeListCore<Subscription>(replayBuffer);
    }

    public bool IsDisposed => completeState.IsDisposed;

    public void OnNext(T value)
    {
        if (completeState.IsCompleted) return;

        lock (replayBuffer)
        {
            Trim();
            replayBuffer.AddLast((frameProvider?.GetFrameCount() ?? 0, value));
        }

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnNext(value);
        }
    }

    public void OnErrorResume(Exception error)
    {
        if (completeState.IsCompleted) return;

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnErrorResume(error);
        }
    }

    public void OnCompleted(Result result)
    {
        var status = completeState.TrySetResult(result);
        if (status != CompleteState.ResultStatus.Done)
        {
            return; // already completed
        }

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnCompleted(result);
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        // raise latest value on subscribe(before check completed add observer to list)
        lock (replayBuffer)
        {
            Trim(); // Trim before get span
            var dualSpan = replayBuffer.GetSpan();
            foreach (ref readonly var item in dualSpan.First)
            {
                observer.OnNext(item.value);
            }
            foreach (ref readonly var item in dualSpan.Second)
            {
                observer.OnNext(item.value);
            }
        }

        var result = completeState.TryGetResult();
        if (result != null)
        {
            observer.OnCompleted(result.Value);
            return Disposable.Empty;
        }

        var subscription = new Subscription(this, observer); // create subscription and add observer to list.

        // need to check called completed during adding
        result = completeState.TryGetResult();
        if (result != null)
        {
            subscription.observer.OnCompleted(result.Value);
            subscription.Dispose();
            return Disposable.Empty;
        }

        return subscription;
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (callOnCompleted && !alreadyCompleted)
            {
                // not yet disposed so can call list iteration
                foreach (var subscription in list.AsSpan())
                {
                    subscription?.observer.OnCompleted();
                }
            }

            list.Dispose();
            lock (replayBuffer)
            {
                replayBuffer.Clear();
            }
        }
    }

    void Trim()
    {
        // Trim by Count
        while (replayBuffer.Count > bufferSize)
        {
            replayBuffer.RemoveFirst();
        }

        // Trim by Time
        var now = frameProvider.GetFrameCount();
        while (replayBuffer.Count > 0)
        {
            var value = replayBuffer[0]; // peek first
            var elapsed = now - value.timestamp;
            if (elapsed >= window)
            {
                replayBuffer.RemoveFirst();
            }
            else
            {
                break;
            }
        }
    }

    sealed class Subscription : IDisposable
    {
        public readonly Observer<T> observer;
        readonly int removeKey;
        ReplayFrameSubject<T>? parent;

        public Subscription(ReplayFrameSubject<T> parent, Observer<T> observer)
        {
            this.parent = parent;
            this.observer = observer;
            parent.list.Add(this, out removeKey); // for the thread-safety, add and set removeKey in same lock.
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // removeKey is index, will reuse if remove completed so only allows to call from here and must not call twice.
            p.list.Remove(removeKey);
        }
    }
}



================================================
FILE: src/R3/ReplaySubject.cs
================================================
﻿namespace R3;

public sealed class ReplaySubject<T> : Observable<T>, ISubject<T>, IDisposable
{
    readonly int bufferSize;
    readonly TimeSpan window;
    readonly TimeProvider? timeProvider;
    readonly RingBuffer<(long timestamp, T value)> replayBuffer; // lock object

    // Subject
    FreeListCore<Subscription> list;
    CompleteState completeState;

    public ReplaySubject()
         : this(int.MaxValue, TimeSpan.MaxValue, null!) // allow null internally
    {
    }

    public ReplaySubject(int bufferSize)
        : this(bufferSize, TimeSpan.MaxValue, null!)
    {
    }

    public ReplaySubject(TimeSpan window)
        : this(int.MaxValue, window, ObservableSystem.DefaultTimeProvider)
    {
    }

    public ReplaySubject(TimeSpan window, TimeProvider timeProvider)
        : this(int.MaxValue, window, timeProvider)
    {
    }

    public ReplaySubject(int bufferSize, TimeSpan window)
        : this(bufferSize, window, ObservableSystem.DefaultTimeProvider)
    {
    }

    // full constructor
    public ReplaySubject(int bufferSize, TimeSpan window, TimeProvider timeProvider)
    {
        this.bufferSize = bufferSize;
        this.window = window;
        this.timeProvider = timeProvider;
        this.replayBuffer = new RingBuffer<(long, T)>(bufferSize < 8 ? bufferSize : 8);
        this.list = new FreeListCore<Subscription>(replayBuffer);
    }

    public bool IsDisposed => completeState.IsDisposed;

    public void OnNext(T value)
    {
        if (completeState.IsCompleted) return;

        lock (replayBuffer)
        {
            Trim();
            replayBuffer.AddLast((timeProvider?.GetTimestamp() ?? 0, value));

            foreach (var subscription in list.AsSpan())
            {
                subscription?.observer.OnNext(value);
            }
        }
    }

    public void OnErrorResume(Exception error)
    {
        if (completeState.IsCompleted) return;

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnErrorResume(error);
        }
    }

    public void OnCompleted(Result result)
    {
        var status = completeState.TrySetResult(result);
        if (status != CompleteState.ResultStatus.Done)
        {
            return; // already completed
        }

        foreach (var subscription in list.AsSpan())
        {
            subscription?.observer.OnCompleted(result);
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        // raise latest value on subscribe(before check completed add observer to list)
        lock (replayBuffer)
        {
            Trim(); // Trim before get span
            var dualSpan = replayBuffer.GetSpan();
            foreach (ref readonly var item in dualSpan.First)
            {
                observer.OnNext(item.value);
            }
            foreach (ref readonly var item in dualSpan.Second)
            {
                observer.OnNext(item.value);
            }

            var result = completeState.TryGetResult();
            if (result != null)
            {
                observer.OnCompleted(result.Value);
                return Disposable.Empty;
            }

            var subscription = new Subscription(this, observer); // create subscription and add observer to list.

            // need to check called completed during adding
            result = completeState.TryGetResult();
            if (result != null)
            {
                subscription.observer.OnCompleted(result.Value);
                subscription.Dispose();
                return Disposable.Empty;
            }

            return subscription;
        }
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (callOnCompleted && !alreadyCompleted)
            {
                // not yet disposed so can call list iteration
                foreach (var subscription in list.AsSpan())
                {
                    subscription?.observer.OnCompleted();
                }
            }

            list.Dispose();
            lock (replayBuffer)
            {
                replayBuffer.Clear();
            }
        }
    }

    void Trim()
    {
        // Trim by Count
        while (replayBuffer.Count > bufferSize)
        {
            replayBuffer.RemoveFirst();
        }

        // Trim by Time
        if (timeProvider != null)
        {
            var now = timeProvider.GetTimestamp();
            while (replayBuffer.Count > 0)
            {
                var value = replayBuffer[0]; // peek first
                var elapsed = timeProvider.GetElapsedTime(value.timestamp, now);
                if (elapsed >= window)
                {
                    replayBuffer.RemoveFirst();
                }
                else
                {
                    break;
                }
            }
        }
    }

    sealed class Subscription : IDisposable
    {
        public readonly Observer<T> observer;
        readonly int removeKey;
        ReplaySubject<T>? parent;

        public Subscription(ReplaySubject<T> parent, Observer<T> observer)
        {
            this.parent = parent;
            this.observer = observer;
            parent.list.Add(this, out removeKey); // for the thread-safety, add and set removeKey in same lock.
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // removeKey is index, will reuse if remove completed so only allows to call from here and must not call twice.
            p.list.Remove(removeKey);
        }
    }
}



================================================
FILE: src/R3/Result.cs
================================================
﻿using System.Diagnostics.CodeAnalysis;
using System.Runtime.ExceptionServices;

namespace R3;

// default(Result) is Succeeded
public readonly struct Result
{
    public static Result Success => default;
    public static Result Failure(Exception exception) => new(exception);

    public Exception? Exception { get; }

    [MemberNotNullWhen(false, nameof(Exception))]
    public bool IsSuccess => Exception == null;

    [MemberNotNullWhen(true, nameof(Exception))]
    public bool IsFailure => Exception != null;

    public Result(Exception exception)
    {
        if (exception == null) throw new ArgumentNullException(nameof(exception));
        this.Exception = exception;
    }

    public void TryThrow()
    {
        if (IsFailure)
        {
            ExceptionDispatchInfo.Capture(Exception).Throw();
        }
    }

    public override string ToString()
    {
        if (IsSuccess)
        {
            return $"Success";
        }
        else
        {
            return $"Failure{{{Exception.Message}}}";
        }
    }
}



================================================
FILE: src/R3/SerialDisposable.cs
================================================
﻿namespace R3;

public sealed class SerialDisposable : IDisposable
{
    SerialDisposableCore core;

    public bool IsDisposed => core.IsDisposed;

    public IDisposable? Disposable
    {
        get => core.Disposable;
        set => core.Disposable = value;
    }

    public void Dispose()
    {
        core.Dispose();
    }
}

// struct, be carefult to use
public struct SerialDisposableCore
{
    IDisposable? current;

    public bool IsDisposed => Volatile.Read(ref current) == DisposedSentinel.Instance;

    public IDisposable? Disposable
    {
        get
        {
            var field = Volatile.Read(ref current);
            if (field == DisposedSentinel.Instance)
            {
                return R3.Disposable.Empty; // don't expose sentinel
            }
            return field;
        }
        set
        {
            var field = Volatile.Read(ref current);
            while (true)
            {
                if (field == DisposedSentinel.Instance)
                {
                    // We've already been disposed, so dispose the value we've just been given.
                    value?.Dispose();
                    return;
                }

                var exchangedCurrent = Interlocked.CompareExchange(ref current, value, field);
                if (exchangedCurrent == field)
                {
                    exchangedCurrent?.Dispose();
                    return;
                }

                field = exchangedCurrent;
            }
        }
    }

    public void Dispose()
    {
        var field = Interlocked.Exchange(ref current, DisposedSentinel.Instance);
        if (field != DisposedSentinel.Instance)
        {
            field?.Dispose();
        }
    }

    sealed class DisposedSentinel : IDisposable
    {
        public static readonly DisposedSentinel Instance = new();

        DisposedSentinel()
        {
        }

        public void Dispose()
        {
        }
    }
}



================================================
FILE: src/R3/SingleAssignmentDisposable.cs
================================================
﻿namespace R3;

public sealed class SingleAssignmentDisposable : IDisposable
{
    SingleAssignmentDisposableCore core;

    public bool IsDisposed => core.IsDisposed;

    public IDisposable? Disposable
    {
        get => core.Disposable;
        set => core.Disposable = value;
    }

    public void Dispose()
    {
        core.Dispose();
    }
}

// struct, be carefult to use
public struct SingleAssignmentDisposableCore
{
    IDisposable? current;

    public bool IsDisposed => Volatile.Read(ref current) == DisposedSentinel.Instance;

    public IDisposable? Disposable
    {
        get
        {
            var field = Volatile.Read(ref current);
            if (field == DisposedSentinel.Instance)
            {
                return R3.Disposable.Empty; // don't expose sentinel
            }
            return field;
        }
        set
        {
            var field = Interlocked.CompareExchange(ref current, value, null);
            if (field == null)
            {
                // ok to set.
                return;
            }

            if (field == DisposedSentinel.Instance)
            {
                // We've already been disposed, so dispose the value we've just been given.
                value?.Dispose();
                return;
            }

            // otherwise, invalid assignment
            ThrowAlreadyAssignment();
        }
    }

    public void Dispose()
    {
        var field = Interlocked.Exchange(ref current, DisposedSentinel.Instance);
        if (field != DisposedSentinel.Instance)
        {
            field?.Dispose();
        }
    }

    static void ThrowAlreadyAssignment()
    {
        throw new InvalidOperationException("Disposable is already assigned.");
    }

    sealed class DisposedSentinel : IDisposable
    {
        public static readonly DisposedSentinel Instance = new();

        DisposedSentinel()
        {
        }

        public void Dispose()
        {
        }
    }
}



================================================
FILE: src/R3/SingleAssignmentSubject.cs
================================================
﻿namespace R3;

public sealed class SingleAssignmentSubject<T> : Observable<T>, ISubject<T>, IDisposable
{
    Observer<T>? singleObserver;
    Result completed;

    public bool IsDisposed => singleObserver == DisposedObserver.Instance;

    public void OnNext(T value)
    {
        var observer = singleObserver;
        if (observer == CompletedObserver.Instance || observer == null)
        {
            // do nothing
        }
        else if (observer == DisposedObserver.Instance)
        {
            ThrowAlreadyDisposed();
        }
        else
        {
            observer.OnNext(value);
        }
    }

    public void OnErrorResume(Exception error)
    {
        var observer = singleObserver;
        if (observer == CompletedObserver.Instance || observer == null)
        {
            // do nothing
        }
        else if (observer == DisposedObserver.Instance)
        {
            ThrowAlreadyDisposed();
        }
        else
        {
            observer.OnErrorResume(error);
        }
    }

    public void OnCompleted(Result complete)
    {
        while (true)
        {
            var observer = Volatile.Read(ref singleObserver);
            if (observer == CompletedObserver.Instance)
            {
                // do nothing
                return;
            }
            else if (observer == DisposedObserver.Instance)
            {
                ThrowAlreadyDisposed();
                return;
            }
            else
            {
                this.completed = complete;
                if (Interlocked.CompareExchange(ref singleObserver, CompletedObserver.Instance, observer) == observer)
                {
                    observer?.OnCompleted(complete);
                    return;
                }
            }
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var field = Interlocked.CompareExchange(ref singleObserver, observer, null);
        if (field == null)
        {
            // ok to set.
            return new Subscription(this);
        }

        if (field == DisposedObserver.Instance)
        {
            ThrowAlreadyDisposed();
        }
        else if (field == CompletedObserver.Instance)
        {
            observer.OnCompleted(completed);
        }
        else
        {
            ThrowAlreadyAssignment();
        }
        return Disposable.Empty;
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        var observer = Interlocked.Exchange(ref singleObserver, DisposedObserver.Instance);
        if (observer != DisposedObserver.Instance && observer != null && callOnCompleted)
        {
            observer.OnCompleted();
        }
    }

    static void ThrowAlreadyAssignment()
    {
        throw new InvalidOperationException("Observer is already assigned.");
    }

    void ThrowAlreadyDisposed()
    {
        throw new ObjectDisposedException("");
    }

    class Subscription(SingleAssignmentSubject<T> parent) : IDisposable
    {
        public void Dispose()
        {
            while (true)
            {
                var observer = Volatile.Read(ref parent.singleObserver);
                if (observer == CompletedObserver.Instance || observer == DisposedObserver.Instance || observer == null)
                {
                    // do nothing
                    return;
                }
                else
                {
                    // reset to null(allow multiple assignment after first subscription is disposed)
                    if (Interlocked.CompareExchange(ref parent.singleObserver, null, observer) == observer)
                    {
                        return;
                    }
                }
            }
        }
    }

    sealed class CompletedObserver : Observer<T>
    {
        public static readonly CompletedObserver Instance = new();

        protected override void OnCompletedCore(Result result)
        {
        }

        protected override void OnErrorResumeCore(Exception error)
        {
        }

        protected override void OnNextCore(T value)
        {
        }
    }

    sealed class DisposedObserver : Observer<T>
    {
        public static readonly DisposedObserver Instance = new();

        protected override void OnCompletedCore(Result result)
        {
        }

        protected override void OnErrorResumeCore(Exception error)
        {
        }

        protected override void OnNextCore(T value)
        {
        }
    }
}



================================================
FILE: src/R3/Subject.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3;

// thread-safety state for Subject.
internal struct CompleteState
{
    internal enum ResultStatus
    {
        Done,
        AlreadySuccess,
        AlreadyFailed
    }

    const int NotCompleted = 0;
    const int CompletedSuccess = 1;
    const int CompletedFailure = 2;
    const int Disposed = 3;

    int completeState;
    Exception? error;

    public ResultStatus TrySetResult(Result result)
    {
        int field;
        if (result.IsSuccess)
        {
            field = Interlocked.CompareExchange(ref completeState, CompletedSuccess, NotCompleted); // try set success
        }
        else
        {
            field = Interlocked.CompareExchange(ref completeState, CompletedFailure, NotCompleted); // try set failure
            Volatile.Write(ref error, result.Exception);      // set failure immmediately(but not locked).
        }

        switch (field)
        {
            case NotCompleted:
                return ResultStatus.Done;
            case CompletedSuccess:
                return ResultStatus.AlreadySuccess;
            case CompletedFailure:
                return ResultStatus.AlreadyFailed;
            case Disposed:
                ThrowObjectDiposedException();
                break;
        }

        return ResultStatus.Done; // not here.
    }

    public bool TrySetDisposed(out bool alreadyCompleted)
    {
        var field = Interlocked.Exchange(ref completeState, Disposed);
        switch (field)
        {
            case NotCompleted:
                alreadyCompleted = false;
                return true;
            case CompletedSuccess:
            case CompletedFailure:
                alreadyCompleted = true;
                return true;
            case Disposed:
                break;
        }

        alreadyCompleted = false;
        return false;
    }

    // throws exception when state is disposed
    public bool IsCompleted
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            switch (completeState)
            {
                case NotCompleted:
                    return false;
                case CompletedSuccess:
                    return true;
                case CompletedFailure:
                    return true;
                case Disposed:
                    ThrowObjectDiposedException();
                    break;
            }

            return false; // not here.
        }
    }

    public bool IsDisposed => Volatile.Read(ref completeState) == Disposed;

    public bool IsCompletedOrDisposed
    {
        get
        {
            var state = Volatile.Read(ref completeState);
            return state == Disposed || state == CompletedSuccess || state == CompletedFailure;
        }
    }

    public Result? TryGetResult()
    {
        var currentState = Volatile.Read(ref completeState);

        switch (currentState)
        {
            case NotCompleted:
                return null;
            case CompletedSuccess:
                return Result.Success;
            case CompletedFailure:
                return Result.Failure(GetException());
            case Disposed:
                ThrowObjectDiposedException();
                break;
        }

        return null; // not here.
    }

    // be careful to use, this method need to call after ResultStatus.AlreadyFailed.
    Exception GetException()
    {
        Exception? error = Volatile.Read(ref this.error);
        if (error != null) return error;

        var spinner = new SpinWait();
        do
        {
            spinner.SpinOnce();
            error = Volatile.Read(ref this.error);
        } while (error == null);

        return error;
    }

    static void ThrowObjectDiposedException()
    {
        throw new ObjectDisposedException("");
    }
}

public class Subject<T> : Observable<T>, ISubject<T>, IDisposable
{
    // similar implementation to ReactiveProperty

    CompleteState completeState;
    ObserverNode? root;
    ulong version = 1;

    public bool IsDisposed => completeState.IsDisposed;
    internal bool IsCompletedOrDisposed => completeState.IsCompletedOrDisposed;

    public void OnNext(T value)
    {
        if (completeState.IsCompleted) return;

        var currentVersion = GetVersion();
        var node = root;
        while (node != null)
        {
            if (node.Version > currentVersion) break;
            node.Observer.OnNext(value);
            node = node.Next;
        }
    }

    public void OnErrorResume(Exception error)
    {
        if (completeState.IsCompleted) return;

        var currentVersion = GetVersion();
        var node = root;
        while (node != null)
        {
            if (node.Version > currentVersion) break;
            node.Observer.OnErrorResume(error);
            node = node.Next;
        }
    }

    public void OnCompleted(Result result)
    {
        var status = completeState.TrySetResult(result);
        if (status != CompleteState.ResultStatus.Done)
        {
            return; // already completed
        }

        var currentVersion = GetVersion();
        var node = root;
        while (node != null)
        {
            if (node.Version > currentVersion) break;
            node.Observer.OnCompleted(result);
            node = node.Next;
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var result = completeState.TryGetResult();
        if (result != null)
        {
            observer.OnCompleted(result.Value);
            return Disposable.Empty;
        }

        var subscription = new ObserverNode(this, observer, version);

        // need to check called completed during adding
        result = completeState.TryGetResult();
        if (result != null)
        {
            subscription.Observer.OnCompleted(result.Value);
            subscription.Dispose();
            return Disposable.Empty;
        }

        return subscription;
    }

    void ThrowIfDisposed()
    {
        if (IsDisposed) throw new ObjectDisposedException("");
    }

    public void Dispose()
    {
        Dispose(true);
    }

    public void Dispose(bool callOnCompleted)
    {
        if (completeState.TrySetDisposed(out var alreadyCompleted))
        {
            if (!alreadyCompleted && callOnCompleted)
            {
                var currentVersion = GetVersion();
                var node = root;
                Volatile.Write(ref root, null);
                while (node != null)
                {
                    if (node.Version > currentVersion) break;
                    node.Observer.OnCompleted();
                    node = node.Next;
                }
            }
            else
            {
                Volatile.Write(ref root, null);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    ulong GetVersion()
    {
        ulong currentVersion;
        if (version == ulong.MaxValue)
        {
            ResetAllObserverVersion();
            currentVersion = 0;
        }
        else
        {
            currentVersion = version++;
        }
        return currentVersion;

        void ResetAllObserverVersion()
        {
            lock (this)
            {
                var node = root;
                while (node != null)
                {
                    node.Version = 0;
                    node = node.Next;
                }

                version = 1; // also reset version
            }
        }
    }

    sealed class ObserverNode : IDisposable
    {
        public readonly Observer<T> Observer;

        Subject<T>? parent;

        public ObserverNode? Previous { get; set; } // Previous is last node or root(null).
        public ObserverNode? Next { get; set; }
        public ulong Version; // internal use, allow reset

        public ObserverNode(Subject<T> parent, Observer<T> observer, ulong version)
        {
            this.parent = parent;
            this.Observer = observer;
            this.Version = version;

            lock (parent)
            {
                if (parent.root == null)
                {
                    // Single list(both previous and next is null)
                    Volatile.Write(ref parent.root, this);
                }
                else
                {
                    // previous is last, null then root is last.
                    var lastNode = parent.root.Previous ?? parent.root;

                    lastNode.Next = this;
                    this.Previous = lastNode;
                    parent.root.Previous = this;
                }
            }
        }

        public void Dispose()
        {
            var p = Interlocked.Exchange(ref parent, null);
            if (p == null) return;

            // keep this.Next for dispose on iterating
            // Remove node(self) from list
            lock (p)
            {
                if (p.IsCompletedOrDisposed) return;

                if (this == p.root)
                {
                    if (this.Previous == null || this.Next == null)
                    {
                        // case of single list
                        p.root = null;
                    }
                    else
                    {
                        // otherwise, root is next node.
                        var root = this.Next;

                        // single list.
                        if (root.Next == null)
                        {
                            root.Previous = null;
                        }
                        else
                        {
                            root.Previous = this.Previous; // as last.
                        }

                        p.root = root;
                    }
                }
                else
                {
                    // node is not root, previous must exists
                    this.Previous!.Next = this.Next;
                    if (this.Next != null)
                    {
                        this.Next.Previous = this.Previous;
                    }
                    else
                    {
                        // next does not exists, previous is last node so modify root
                        p.root!.Previous = this.Previous;
                    }
                }
            }
        }
    }
}



================================================
FILE: src/R3/SynchronizationContextTimeProvider.cs
================================================
﻿namespace R3;

public sealed class SynchronizationContextTimeProvider : TimeProvider
{
    readonly Func<SynchronizationContext?> synchronizationContextAccessor;
    readonly TimeProvider timeProvider;

    public SynchronizationContextTimeProvider()
        : this(SynchronizationContext.Current)
    {
    }

    public SynchronizationContextTimeProvider(SynchronizationContext? synchronizationContext)
        : this(synchronizationContext, TimeProvider.System)
    {
    }

    public SynchronizationContextTimeProvider(Func<SynchronizationContext?> synchronizationContextAccessor)
        : this(synchronizationContextAccessor, TimeProvider.System)
    {
    }

    public SynchronizationContextTimeProvider(SynchronizationContext? synchronizationContext, TimeProvider timeProvider)
    {
        this.synchronizationContextAccessor = () => synchronizationContext;
        this.timeProvider = timeProvider;
    }

    public SynchronizationContextTimeProvider(Func<SynchronizationContext?> synchronizationContextAccessor, TimeProvider timeProvider)
    {
        this.synchronizationContextAccessor = synchronizationContextAccessor;
        this.timeProvider = timeProvider;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new SynchronizationContextTimer(timeProvider, synchronizationContextAccessor(), callback, state, dueTime, period);
    }
}

internal sealed class SynchronizationContextTimer : ITimer
{
    static readonly TimerCallback wrappedCallback = InvokeCallback;
    static readonly SendOrPostCallback postCallback = PostCallback;

    readonly ITimer timer;
    readonly SynchronizationContext? synchronizationContext;
    readonly TimerCallback callback;
    readonly object? state;

    public SynchronizationContextTimer(TimeProvider timeProvider, SynchronizationContext? synchronizationContext, TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.synchronizationContext = synchronizationContext;
        this.callback = callback;
        this.state = state;

        // CreateTimer call after all private field set
        this.timer = timeProvider.CreateTimer(wrappedCallback, this, dueTime, period);
    }

    static void InvokeCallback(object? state)
    {
        var self = (SynchronizationContextTimer)state!;

        if (self.synchronizationContext == null)
        {
            self.callback.Invoke(self.state);
        }
        else
        {
            self.synchronizationContext.Post(postCallback, self);
        }
    }

    static void PostCallback(object? state)
    {
        var self = (SynchronizationContextTimer)state!;
        self.callback.Invoke(self.state);
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        return this.timer.Change(dueTime, period);
    }

    public void Dispose()
    {
        this.timer.Dispose();
    }

    public ValueTask DisposeAsync()
    {
        this.timer.Dispose();
        return default;
    }
}



================================================
FILE: src/R3/SynchronizedReactiveProperty.cs
================================================
﻿namespace R3;

public class SynchronizedReactiveProperty<T> : ReactiveProperty<T>
{
    public SynchronizedReactiveProperty()
        : base()
    {
    }

    public SynchronizedReactiveProperty(T value)
        : base(value)
    {
    }

    public SynchronizedReactiveProperty(T value, IEqualityComparer<T>? equalityComparer)
        : base(value, equalityComparer)
    {
    }

    public override T Value
    {
        get
        {
            lock (this)
            {
                return base.Value;
            }
        }
        set
        {
            lock (this)
            {
                base.Value = value;
            }
        }
    }

    public override void OnNext(T value)
    {
        lock (this)
        {
            base.OnNext(value);
        }
    }

    public override void ForceNotify()
    {
        lock (this)
        {
            base.ForceNotify();
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        lock (this)
        {
            return base.SubscribeCore(observer);
        }
    }
}



================================================
FILE: src/R3/TimerFrameProvider.cs
================================================
﻿namespace R3;

public sealed class TimerFrameProvider : FrameProvider, IDisposable
{
    static readonly TimerCallback timerCallback = Run;

    readonly object gate = new object();
    long frameCount;
    bool disposed;
    FreeListCore<IFrameRunnerWorkItem> list;
    ITimer timer;

    public TimerFrameProvider(TimeSpan period)
        : this(period, period, TimeProvider.System)
    {
    }

    public TimerFrameProvider(TimeSpan dueTime, TimeSpan period)
        : this(dueTime, period, TimeProvider.System)
    {
    }

    public TimerFrameProvider(TimeSpan dueTime, TimeSpan period, TimeProvider timeProvider)
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);

        // start timer
        this.timer.Change(dueTime, period);
    }

    public override long GetFrameCount()
    {
        ThrowHelper.ThrowObjectDisposedIf(disposed, typeof(TimerFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowHelper.ThrowObjectDisposedIf(disposed, typeof(TimerFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        if (!disposed)
        {
            disposed = true;
            lock (gate)
            {
                timer.Dispose();
                list.Dispose();
            }
        }
    }

    static void Run(object? state)
    {
        var self = (TimerFrameProvider)state!;
        if (self.disposed)
        {
            return;
        }

        lock (self.gate)
        {
            self.frameCount++;

            var span = self.list.AsSpan();
            for (int i = 0; i < span.Length; i++)
            {
                ref readonly var item = ref span[i];
                if (item != null)
                {
                    try
                    {
                        if (!item.MoveNext(self.frameCount))
                        {
                            self.list.Remove(i);
                        }
                    }
                    catch (Exception ex)
                    {
                        self.list.Remove(i);
                        try
                        {
                            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                        }
                        catch { }
                    }
                }
            }
        }
    }
}



================================================
FILE: src/R3/Unit.cs
================================================
﻿namespace R3;

public readonly struct Unit : IEquatable<Unit>
{
    public static readonly Unit Default = default;
    public static readonly object Box = default(Unit);

    public static bool operator ==(Unit first, Unit second)
    {
        return true;
    }

    public static bool operator !=(Unit first, Unit second)
    {
        return false;
    }

    public bool Equals(Unit other)
    {
        return true;
    }
    public override bool Equals(object? obj)
    {
        return obj is Unit;
    }

    public override int GetHashCode()
    {
        return 0;
    }

    public override string ToString()
    {
        return "()";
    }
}



================================================
FILE: src/R3/Collections/FreeListCore.cs
================================================
﻿using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace R3.Collections;

[StructLayout(LayoutKind.Auto)]
public struct FreeListCore<T>
    where T : class
{
    readonly object gate;
    T?[]? values = null;
    int lastIndex;

    public FreeListCore(object gate)
    {
        // don't create values at initialize
        this.gate = gate;
        this.lastIndex = -1;
    }

    public bool IsDisposed => lastIndex == -2;

    public ReadOnlySpan<T?> AsSpan()
    {
        var last = Volatile.Read(ref lastIndex);
        var xs = Volatile.Read(ref values);
        if (xs == null) return ReadOnlySpan<T?>.Empty;
        return xs.AsSpan(0, last + 1);
    }

    public void Add(T item, out int removeKey)
    {
        lock (gate)
        {
            ThrowHelper.ThrowObjectDisposedIf(IsDisposed, typeof(FreeListCore<T>));

            if (values == null)
            {
                values = new T[1]; // initial size is 1.
            }

            // try find blank
            var index = FindNullIndex(values);
            if (index == -1)
            {
                // full, 1, 4, 6,...resize(x1.5)
                var len = values.Length;
                var newValues = len == 1 ? new T[4] : new T[len + len / 2];
                Array.Copy(values, newValues, len);
                Volatile.Write(ref values, newValues);
                index = len;
            }

            values[index] = item;
            if (lastIndex < index)
            {
                Volatile.Write(ref lastIndex, index);
            }

            removeKey = index; // index is remove key.
        }
    }

    public void Remove(int index)
    {
        lock (gate)
        {
            if (values == null) return;

            if (index < values.Length)
            {
                ref var v = ref values[index];
                if (v == null) throw new KeyNotFoundException($"key index {index} is not found.");

                v = null;
                if (index == lastIndex)
                {
                    Volatile.Write(ref lastIndex, FindLastNonNullIndex(values, index));
                }
            }
        }
    }

    public bool RemoveSlow(T value)
    {
        lock (gate)
        {
            if (values == null) return false;
            if (lastIndex < 0) return false;

            var index = -1;
            var span = values.AsSpan(0, lastIndex + 1);
            for (int i = 0; i < span.Length; i++)
            {
                if (span[i] == value)
                {
                    index = i;
                    break;
                }
            }

            if (index != -1)
            {
                Remove(index);
                return true;
            }
        }
        return false;
    }

    public void Clear(bool removeArray)
    {
        lock (gate)
        {
            if (lastIndex >= 0)
            {
                values.AsSpan(0, lastIndex + 1).Clear();
            }
            if (removeArray)
            {
                values = null;
            }
            if (lastIndex != -2)
            {
                lastIndex = -1;
            }
        }
    }

    public void Dispose()
    {
        lock (gate)
        {
            values = null;
            lastIndex = -2; // -2 is disposed.
        }
    }

#if NET6_0_OR_GREATER

    static int FindNullIndex(T?[] target)
    {
        var span = MemoryMarshal.CreateReadOnlySpan(
            ref Unsafe.As<T?, IntPtr>(ref MemoryMarshal.GetArrayDataReference(target)), target.Length);
        return span.IndexOf(IntPtr.Zero);
    }

#else

    static unsafe int FindNullIndex(T?[] target)
    {
        ref var head = ref Unsafe.As<T?, IntPtr>(ref MemoryMarshal.GetReference(target.AsSpan()));
        fixed (void* p = &head)
        {
            var span = new ReadOnlySpan<IntPtr>(p, target.Length);

#if NETSTANDARD2_1
            return span.IndexOf(IntPtr.Zero);
#else
            for (int i = 0; i < span.Length; i++)
            {
                if (span[i] == IntPtr.Zero) return i;
            }
            return -1;
#endif
        }
    }

#endif

#if NET8_0_OR_GREATER

    static int FindLastNonNullIndex(T?[] target, int lastIndex)
    {
        var span = MemoryMarshal.CreateReadOnlySpan(
            ref Unsafe.As<T?, IntPtr>(ref MemoryMarshal.GetArrayDataReference(target)), lastIndex); // without lastIndexed value.
        var index = span.LastIndexOfAnyExcept(IntPtr.Zero);
        return index; // return -1 is ok(means empty)
    }

#else

    static unsafe int FindLastNonNullIndex(T?[] target, int lastIndex)
    {
        ref var head = ref Unsafe.As<T?, IntPtr>(ref MemoryMarshal.GetReference(target.AsSpan()));
        fixed (void* p = &head)
        {
            var span = new ReadOnlySpan<IntPtr>(p, lastIndex); // without lastIndexed value.

            for (var i = span.Length - 1; i >= 0; i--)
            {
                if (span[i] != IntPtr.Zero) return i;
            }

            return -1;
        }
    }

#endif
}



================================================
FILE: src/R3/Collections/LiveList.cs
================================================
﻿using System.Collections;
using System.Runtime.InteropServices;

namespace R3
{
    public static partial class ObservableExtensions
    {
        public static LiveList<T> ToLiveList<T>(this Observable<T> source)
        {
            return new LiveList<T>(source);
        }

        public static LiveList<T> ToLiveList<T>(this Observable<T> source, int bufferSize)
        {
            return new LiveList<T>(source, bufferSize);
        }
    }
}

namespace R3.Collections
{
    public sealed class LiveList<T> : IReadOnlyList<T>, IDisposable
    {
        readonly IReadOnlyList<T> list; // RingBuffer<T> or List<T>
        readonly IDisposable sourceSubscription;
        readonly int bufferSize;

        bool isCompleted;
        Result completedValue;

        public bool IsCompleted => isCompleted;

        public Result Result
        {
            get
            {
                lock (list)
                {
                    if (!isCompleted) throw new InvalidOperationException("LiveList is not completed, you should check IsCompleted.");
                    return completedValue;
                }
            }
        }

        public LiveList(Observable<T> source)
        {
            if (bufferSize == 0) bufferSize = 1;
            this.bufferSize = -1;
            this.list = new List<T>();
            this.sourceSubscription = source.Subscribe(new ListObserver(this));
        }

        public LiveList(Observable<T> source, int bufferSize)
        {
            if (bufferSize == 0) bufferSize = 1;
            this.bufferSize = bufferSize; // bufferSize must set before Subscribe(sometimes Subscribe run immediately)
            this.list = new RingBuffer<T>(bufferSize);
            this.sourceSubscription = source.Subscribe(new ListObserver(this));
        }

        public T this[int index]
        {
            get
            {
                lock (list)
                {
                    return list[index];
                }
            }
        }

        public int Count
        {
            get
            {
                lock (list)
                {
                    return list.Count;
                }
            }
        }

        public void Clear()
        {
            lock (list)
            {
                list.Clear();
            }
        }

        public void Dispose()
        {
            sourceSubscription.Dispose();
        }

        public void ForEach(Action<T> action)
        {
            lock (list)
            {
                var span = list.GetSpan();
                foreach (ref readonly var item in span)
                {
                    action(item);
                }
            }
        }

        public void ForEach<TState>(TState state, Action<T, TState> action)
        {
            lock (list)
            {
                var span = list.GetSpan();
                foreach (ref readonly var item in span)
                {
                    action(item, state);
                }
            }
        }

        public T[] ToArray()
        {
            lock (list)
            {
                return list.ToArray();
            }
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            lock (list)
            {
                // snapshot
                return ToArray().AsEnumerable().GetEnumerator();
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            lock (list)
            {
                // snapshot
                return ToArray().AsEnumerable().GetEnumerator();
            }
        }

        sealed class ListObserver(LiveList<T> parent) : Observer<T>
        {
            protected override void OnNextCore(T message)
            {
                lock (parent.list)
                {
                    if (parent.bufferSize == -1)
                    {
                        ((List<T>)parent.list).Add(message);
                    }
                    else
                    {
                        var ring = (RingBuffer<T>)parent.list;

                        if (ring.Count == parent.bufferSize)
                        {
                            ring.RemoveFirst();
                        }
                        ring.AddLast(message);
                    }
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                ObservableSystem.GetUnhandledExceptionHandler().Invoke(error);
            }

            protected override void OnCompletedCore(Result complete)
            {
                lock (parent.list)
                {
                    parent.completedValue = complete;
                    parent.isCompleted = true;
                }
            }
        }
    }

    file static class RingBufferOrListExtensions
    {
        public static RingBufferSpan<T> GetSpan<T>(this IReadOnlyList<T> list)
        {
            if (list is RingBuffer<T> r)
            {
                return r.GetSpan();
            }
            else if (list is List<T> l)
            {
                var span1 = CollectionsMarshal.AsSpan(l);
                return new RingBufferSpan<T>(span1, default, span1.Length);
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        public static void Clear<T>(this IReadOnlyList<T> list)
        {
            if (list is RingBuffer<T> r)
            {
                r.Clear();
            }
            else if (list is List<T> l)
            {
                l.Clear();
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        public static T[] ToArray<T>(this IReadOnlyList<T> list)
        {
            if (list is RingBuffer<T> r)
            {
                return r.ToArray();
            }
            else if (list is List<T> l)
            {
                return CollectionsMarshal.AsSpan(l).ToArray();
            }
            else
            {
                throw new NotSupportedException();
            }
        }
    }
}



================================================
FILE: src/R3/Collections/SwapListCore.cs
================================================
﻿namespace R3.Collections;

public struct SwapListCore<T>
{
    const int InitialArraySize = 4;

    T[]? arrayA;
    int lengthA;

    T[]? arrayB;
    int lengthB;

    bool useA;

    public bool HasValue
    {
        get
        {
            return lengthA > 0 || lengthB > 0;
        }
    }

    public void Add(T value)
    {
        if (useA)
        {
            if (arrayA == null)
            {
                arrayA = new T[InitialArraySize];
            }
            else if (lengthA == arrayA.Length)
            {
                var tmp = new T[arrayA.Length * 2];
                Array.Copy(arrayA, tmp, arrayA.Length);
                arrayA = tmp;
            }
            arrayA[lengthA++] = value;
        }
        else
        {
            if (arrayB == null)
            {
                arrayB = new T[InitialArraySize];
            }
            else if (lengthB == arrayB.Length)
            {
                var tmp = new T[arrayB.Length * 2];
                Array.Copy(arrayB, tmp, arrayB.Length);
                arrayB = tmp;
            }
            arrayB[lengthB++] = value;
        }
    }

    public ReadOnlySpan<T> Swap(out bool token)
    {
        if (useA)
        {
            useA = false;
            if (arrayA == null)
            {
                token = true;
                return ReadOnlySpan<T>.Empty;
            }
            else
            {
                token = true;
                return arrayA.AsSpan(0, lengthA);
            }
        }
        else
        {
            useA = true;
            if (arrayB == null)
            {
                token = false;
                return ReadOnlySpan<T>.Empty;
            }
            else
            {
                token = false;
                return arrayB.AsSpan(0, lengthB);
            }
        }
    }

    public void Clear(bool token)
    {
        if (token) // token means useA
        {
            if (arrayA != null)
            {
                Array.Clear(arrayA, 0, lengthA);
                lengthA = 0;
            }
        }
        else
        {
            if (arrayB != null)
            {
                Array.Clear(arrayB, 0, lengthB);
                lengthB = 0;
            }
        }

        if (lengthB == 0)
        {
            useA = true;
        }
    }

    public void Dispose()
    {
        if (arrayA != null)
        {
            Array.Clear(arrayA, 0, lengthA);
            arrayA = null;
            lengthA = 0;
        }

        if (arrayB != null)
        {
            Array.Clear(arrayB, 0, lengthB);
            arrayB = null;
            lengthB = 0;
        }
    }
}



================================================
FILE: src/R3/Factories/CombineLatest.cs
================================================
﻿using System.Diagnostics.CodeAnalysis;

namespace R3;

public static partial class Observable
{
    public static Observable<T[]> CombineLatest<T>(params Observable<T>[] sources)
    {
        return new CombineLatest<T>(sources);
    }

    public static Observable<T[]> CombineLatest<T>(IEnumerable<Observable<T>> sources)
    {
        return new CombineLatest<T>(sources);
    }
}

internal sealed class CombineLatest<T>(IEnumerable<Observable<T>> sources) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return new _CombineLatest(observer, sources).Run();
    }

    sealed class _CombineLatest : IDisposable
    {
        readonly Observer<T[]> observer;
        readonly Observable<T>[] sources;
        readonly CombineLatestObserver[] observers;
        bool hasValueAll;
        int completedCount;

        public _CombineLatest(Observer<T[]> observer, IEnumerable<Observable<T>> sources)
        {
            this.observer = observer;
            if (sources is Observable<T>[] array)
            {
                this.sources = array;
            }
            else
            {
                this.sources = sources.ToArray();
            }

            // empty should return as Empty.
            if (this.sources.Length == 0)
            {
                this.observers = [];
                return;
            }

            var observers = new CombineLatestObserver[this.sources.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                observers[i] = new CombineLatestObserver(this);
            }
            this.observers = observers;
        }

        public IDisposable Run()
        {
            if (observers.Length == 0)
            {
                observer.OnCompleted();
                return Disposable.Empty;
            }

            try
            {
                for (int i = 0; i < sources.Length; i++)
                {
                    sources[i].Subscribe(observers[i]);
                }
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            if (!hasValueAll)
            {
                foreach (var item in observers)
                {
                    if (!item.HasValue) return;
                }
                hasValueAll = true;
            }

            var values = new T[observers.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                values[i] = observers[i].Value!;
            }
            observer.OnNext(values);
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                completedCount += 1;
                if (empty || completedCount == sources.Length)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void Dispose()
        {
            foreach (var observer in observers)
            {
                observer.Dispose();
            }
        }

        sealed class CombineLatestObserver(_CombineLatest parent) : Observer<T>
        {
            public T? Value { get; private set; }

            [MemberNotNullWhen(true, nameof(Value))]
            public bool HasValue { get; private set; }

            protected override void OnNextCore(T value)
            {
                lock (parent.observers)
                {
                    this.Value = value;
                    this.HasValue = true;
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.observers)
                {
                    parent.TryPublishOnCompleted(result, !HasValue);
                }
            }
        }
    }
}



================================================
FILE: src/R3/Factories/Concat.cs
================================================
﻿using System;

namespace R3;

public static partial class Observable
{
    public static Observable<T> Concat<T>(params Observable<T>[] sources)
    {
        return new Concat<T>(sources);
    }

    public static Observable<T> Concat<T>(IEnumerable<Observable<T>> sources)
    {
        return new Concat<T>(sources);
    }
}

public static partial class ObservableExtensions
{
    public static Observable<T> Concat<T>(this Observable<T> source, Observable<T> second)
    {
        return new Concat<T>(new[] { source, second });
    }
}

internal sealed class Concat<T>(IEnumerable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _Concat(observer, sources).Run();
    }

    sealed class _Concat : IDisposable
    {
        public Observer<T> observer;
        public IEnumerator<Observable<T>> enumerator;

        public SerialDisposableCore disposable;
        int id = 0;
        readonly object gate = new object();

        public _Concat(Observer<T> observer, IEnumerable<Observable<T>> sources)
        {
            this.observer = observer;
            this.enumerator = sources.GetEnumerator();
        }

        public IDisposable Run()
        {
            if (!enumerator.MoveNext())
            {
                observer.OnCompleted();
                enumerator.Dispose();
                return Disposable.Empty;
            }
            else
            {
                SubscribeNext();
                return this;
            }
        }

        public void Dispose()
        {
            enumerator.Dispose();
            disposable.Dispose();
        }

        public void SubscribeNext()
        {
            lock (gate)
            {
                id++;
                var currentId = id;
                var d = enumerator.Current.Subscribe(new _ConcatObserver(this));
                // if already invoked next observable(called oncompleted), no need to set disapoble(oncompleted calls dispose self)
                if (currentId == id)
                {
                    disposable.Disposable = d;
                }
            }
        }
    }

    sealed class _ConcatObserver(_Concat parent) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            parent.observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                try
                {
                    parent.observer.OnCompleted(result);
                }
                finally
                {
                    Dispose();
                }
            }
            else
            {
                if (parent.enumerator.MoveNext())
                {
                    parent.SubscribeNext();
                }
                else
                {
                    parent.observer.OnCompleted();
                }
            }
        }
    }
}



================================================
FILE: src/R3/Factories/Create.cs
================================================
namespace R3;

public static partial class Observable
{
    public static Observable<T> Create<T>(Func<Observer<T>, IDisposable> subscribe, bool rawObserver = false)
    {
        return new AnonymousObservable<T>(subscribe, rawObserver);
    }

    public static Observable<T> Create<T, TState>(TState state, Func<Observer<T>, TState, IDisposable> subscribe, bool rawObserver = false)
    {
        return new AnonymousObservable<T, TState>(state, subscribe, rawObserver);
    }

    public static Observable<T> Create<T>(Func<Observer<T>, CancellationToken, ValueTask> subscribe, bool rawObserver = false)
    {
        return new AsyncAnonymousObservable<T>(subscribe, rawObserver);
    }

    public static Observable<T> Create<T, TState>(TState state, Func<Observer<T>, TState, CancellationToken, ValueTask> subscribe, bool rawObserver = false)
    {
        return new AsyncAnonymousObservable<T, TState>(state, subscribe, rawObserver);
    }

    public static Observable<T> CreateFrom<T>(Func<CancellationToken, IAsyncEnumerable<T>> factory)
    {
        return new CreateFrom<T>(factory);
    }

    public static Observable<T> CreateFrom<T, TState>(TState state, Func<CancellationToken, TState, IAsyncEnumerable<T>> factory)
    {
        return new CreateFrom<T, TState>(state, factory);
    }
}

internal sealed class AnonymousObservable<T>(Func<Observer<T>, IDisposable> subscribe, bool rawObserver) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return subscribe(rawObserver ? observer : observer.Wrap());
    }
}

internal sealed class AnonymousObservable<T, TState>(TState state, Func<Observer<T>, TState, IDisposable> subscribe, bool rawObserver) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return subscribe(rawObserver ? observer : observer.Wrap(), state);
    }
}

internal sealed class AsyncAnonymousObservable<T>(Func<Observer<T>, CancellationToken, ValueTask> subscribe, bool rawObserver)
    : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();
        subscribe(rawObserver ? observer : observer.Wrap(), cancellationDisposable.Token);
        return cancellationDisposable;
    }
}

internal sealed class AsyncAnonymousObservable<T, TState>(TState state, Func<Observer<T>, TState, CancellationToken, ValueTask> subscribe, bool rawObserver)
    : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();
        subscribe(rawObserver ? observer : observer.Wrap(), state, cancellationDisposable.Token);
        return cancellationDisposable;
    }
}

internal sealed class CreateFrom<T>(Func<CancellationToken, IAsyncEnumerable<T>> factory) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();
        RunAsync(observer, cancellationDisposable.Token);
        return cancellationDisposable;
    }

    async void RunAsync(Observer<T> observer, CancellationToken cancellationToken)
    {
        try
        {
            await foreach (var message in factory(cancellationToken))
            {
                observer.OnNext(message);
            }
            observer.OnCompleted();
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken) // disposed.
            {
                return;
            }

            observer.OnCompleted(Result.Failure(ex));
        }
    }
}

internal sealed class CreateFrom<T, TState>(TState state, Func<CancellationToken, TState, IAsyncEnumerable<T>> factory) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();
        RunAsync(observer, cancellationDisposable.Token);
        return cancellationDisposable;
    }

    async void RunAsync(Observer<T> observer, CancellationToken cancellationToken)
    {
        try
        {
            await foreach (var message in factory(cancellationToken, state))
            {
                observer.OnNext(message);
            }
            observer.OnCompleted();
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken) // disposed.
            {
                return;
            }

            observer.OnCompleted(Result.Failure(ex));
        }
    }
}



================================================
FILE: src/R3/Factories/Defer.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Defer<T>(Func<Observable<T>> observableFactory, bool rawObserver = false)
    {
        return new Defer<T>(observableFactory, rawObserver);
    }
}

internal sealed class Defer<T>(Func<Observable<T>> observableFactory, bool rawObserver) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var observable = default(Observable<T>);
        try
        {
            observable = observableFactory();
        }
        catch (Exception ex)
        {
            observer.OnCompleted(ex); // when failed, return Completed(Error)
            return Disposable.Empty;
        }

        return observable.Subscribe(rawObserver ? observer : observer.Wrap());
    }
}



================================================
FILE: src/R3/Factories/Empty.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Empty<T>()
    {
        return R3.Empty<T>.Instance;
    }

    public static Observable<T> Empty<T>(TimeProvider timeProvider)
    {
        return ReturnOnCompleted<T>(Result.Success, timeProvider);
    }

    public static Observable<T> Empty<T>(TimeSpan dueTime, TimeProvider timeProvider)
    {
        return ReturnOnCompleted<T>(Result.Success, dueTime, timeProvider);
    }
}

internal sealed class Empty<T> : Observable<T>
{
    // singleton
    public static readonly Empty<T> Instance = new Empty<T>();

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        observer.OnCompleted();
        return Disposable.Empty;
    }

    Empty()
    {

    }
}



================================================
FILE: src/R3/Factories/EveryUpdate.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<Unit> EveryUpdate()
    {
        return new EveryUpdate(ObservableSystem.DefaultFrameProvider, CancellationToken.None);
    }

    public static Observable<Unit> EveryUpdate(CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested) return Empty<Unit>();
        return new EveryUpdate(ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<Unit> EveryUpdate(FrameProvider frameProvider)
    {
        return new EveryUpdate(frameProvider, CancellationToken.None);
    }

    public static Observable<Unit> EveryUpdate(FrameProvider frameProvider, CancellationToken cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested) return Empty<Unit>();

        return new EveryUpdate(frameProvider, cancellationToken);
    }
}

internal sealed class EveryUpdate(FrameProvider frameProvider, CancellationToken cancellationToken) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        var runner = new EveryUpdateRunnerWorkItem(observer, cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class EveryUpdateRunnerWorkItem(Observer<Unit> observer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<Unit>(observer, cancellationToken)
    {
        protected override bool MoveNextCore(long _)
        {
            PublishOnNext(default);
            return true;
        }
    }
}



================================================
FILE: src/R3/Factories/EveryValueChanged.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<TProperty> EveryValueChanged<TSource, TProperty>(TSource source, Func<TSource, TProperty> propertySelector, CancellationToken cancellationToken = default)
        where TSource : class
    {
        return EveryValueChanged(source, propertySelector, ObservableSystem.DefaultFrameProvider, EqualityComparer<TProperty>.Default, cancellationToken);
    }

    public static Observable<TProperty> EveryValueChanged<TSource, TProperty>(TSource source, Func<TSource, TProperty> propertySelector, FrameProvider frameProvider, CancellationToken cancellationToken = default)
        where TSource : class
    {
        return EveryValueChanged(source, propertySelector, frameProvider, EqualityComparer<TProperty>.Default, cancellationToken);
    }

    public static Observable<TProperty> EveryValueChanged<TSource, TProperty>(TSource source, Func<TSource, TProperty> propertySelector, EqualityComparer<TProperty> equalityComparer, CancellationToken cancellationToken = default)
        where TSource : class
    {
        return EveryValueChanged(source, propertySelector, ObservableSystem.DefaultFrameProvider, equalityComparer, cancellationToken);
    }

    public static Observable<TProperty> EveryValueChanged<TSource, TProperty>(TSource source, Func<TSource, TProperty> propertySelector, FrameProvider frameProvider, EqualityComparer<TProperty> equalityComparer, CancellationToken cancellationToken = default)
        where TSource : class
    {
        return new EveryValueChanged<TSource, TProperty>(source, propertySelector, frameProvider, equalityComparer, cancellationToken);
    }
}

internal sealed class EveryValueChanged<TSource, TProperty>(TSource source, Func<TSource, TProperty> propertySelector, FrameProvider frameProvider, EqualityComparer<TProperty> equalityComparer, CancellationToken cancellationToken) : Observable<TProperty>
    where TSource : class
{
    protected override IDisposable SubscribeCore(Observer<TProperty> observer)
    {
        // raise latest value on subscribe
        var value = propertySelector(source);
        observer.OnNext(value);
        if (observer.IsDisposed)
        {
            return Disposable.Empty;
        }

        var runner = new EveryValueChangedRunnerWorkItem(observer, source, value, propertySelector, equalityComparer, cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class EveryValueChangedRunnerWorkItem(Observer<TProperty> observer, TSource source, TProperty previousValue, Func<TSource, TProperty> propertySelector, EqualityComparer<TProperty> equalityComparer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<TProperty>(observer, cancellationToken)
    {
        protected override bool MoveNextCore(long _)
        {
            TProperty currentValue;
            try
            {
                currentValue = propertySelector(source);
            }
            catch (Exception ex)
            { 
                PublishOnCompleted(ex); // when error, stop.
                return false;
            }

            if (equalityComparer.Equals(previousValue, currentValue))
            {
                // don't emit but continue.
                return true;
            }

            previousValue = currentValue;
            PublishOnNext(currentValue); // emit latest
            return true;
        }
    }
}





================================================
FILE: src/R3/Factories/FromAsync.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<Unit> FromAsync(Func<CancellationToken, ValueTask> asyncFactory, bool configureAwait = true)
    {
        return new FromAsync(asyncFactory, configureAwait);
    }

    public static Observable<T> FromAsync<T>(Func<CancellationToken, ValueTask<T>> asyncFactory, bool configureAwait = true)
    {
        return new FromAsync<T>(asyncFactory, configureAwait);
    }
}

internal sealed class FromAsync(Func<CancellationToken, ValueTask> asyncFactory, bool configureAwait) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        var cancellationDisposable = new CancellationDisposable();

        SubscribeTask(observer, cancellationDisposable.Token);

        return cancellationDisposable;
    }

    async void SubscribeTask(Observer<Unit> observer, CancellationToken cancellationToken)
    {
        try
        {
            await asyncFactory(cancellationToken).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken)
            {
                return;
            }

            if (!cancellationToken.IsCancellationRequested)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!cancellationToken.IsCancellationRequested)
        {
            observer.OnNext(default);
            observer.OnCompleted();
        }
    }
}

internal sealed class FromAsync<T>(Func<CancellationToken, ValueTask<T>> asyncFactory, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();

        SubscribeTask(observer, cancellationDisposable.Token);

        return cancellationDisposable;
    }

    async void SubscribeTask(Observer<T> observer, CancellationToken cancellationToken)
    {
        T? result;
        try
        {
            result = await asyncFactory(cancellationToken).ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken)
            {
                return;
            }

            if (!cancellationToken.IsCancellationRequested)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!cancellationToken.IsCancellationRequested)
        {
            observer.OnNext(result);
            observer.OnCompleted();
        }
    }
}



================================================
FILE: src/R3/Factories/FromEvent.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<(object? sender, EventArgs e)> FromEventHandler(Action<EventHandler> addHandler, Action<EventHandler> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<EventHandler, (object? sender, EventArgs e)>(h => (sender, e) => h((sender, e)), addHandler, removeHandler, cancellationToken);
    }

    public static Observable<(object? sender, TEventArgs e)> FromEventHandler<TEventArgs>(Action<EventHandler<TEventArgs>> addHandler, Action<EventHandler<TEventArgs>> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<EventHandler<TEventArgs>, (object? sender, TEventArgs e)>(h => (sender, e) => h((sender, e)), addHandler, removeHandler, cancellationToken);
    }

    public static Observable<Unit> FromEvent(Action<Action> addHandler, Action<Action> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<Action>(static h => h, addHandler, removeHandler, cancellationToken);
    }

    public static Observable<T> FromEvent<T>(Action<Action<T>> addHandler, Action<Action<T>> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<Action<T>, T>(static h => h, addHandler, removeHandler, cancellationToken);
    }

    public static Observable<Unit> FromEvent<TDelegate>(Func<Action, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<TDelegate>(conversion, addHandler, removeHandler, cancellationToken);
    }

    public static Observable<T> FromEvent<TDelegate, T>(Func<Action<T>, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, CancellationToken cancellationToken = default)
    {
        return new FromEvent<TDelegate, T>(conversion, addHandler, removeHandler, cancellationToken);
    }
}

internal sealed class FromEvent<TDelegate>(Func<Action, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, CancellationToken cancellationToken)
    : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        return new _FromEventPattern(conversion, addHandler, removeHandler, observer, cancellationToken);
    }

    sealed class _FromEventPattern : IDisposable
    {
        Observer<Unit>? observer;
        Action<TDelegate>? removeHandler;
        TDelegate registeredHandler;
        CancellationTokenRegistration cancellationTokenRegistration;

        public _FromEventPattern(Func<Action, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, Observer<Unit> observer, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.removeHandler = removeHandler;
            this.registeredHandler = conversion(OnNext);
            addHandler(this.registeredHandler);

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
                {
                    var s = (_FromEventPattern)state!;
                    s.CompleteDispose();
                }, this);
            }
        }

        void OnNext()
        {
            observer?.OnNext(default);
        }

        void CompleteDispose()
        {
            observer?.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            var handler = Interlocked.Exchange(ref removeHandler, null);
            if (handler != null)
            {
                observer = null;
                removeHandler = null;
                cancellationTokenRegistration.Dispose();
                handler(this.registeredHandler);
            }
        }
    }
}

internal sealed class FromEvent<TDelegate, T>(Func<Action<T>, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, CancellationToken cancellationToken)
    : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _FromEventPattern(conversion, addHandler, removeHandler, observer, cancellationToken);
    }

    sealed class _FromEventPattern : IDisposable
    {
        Observer<T>? observer;
        Action<TDelegate>? removeHandler;
        TDelegate registeredHandler;
        CancellationTokenRegistration cancellationTokenRegistration;

        public _FromEventPattern(Func<Action<T>, TDelegate> conversion, Action<TDelegate> addHandler, Action<TDelegate> removeHandler, Observer<T> observer, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.removeHandler = removeHandler;
            this.registeredHandler = conversion(OnNext);
            addHandler(this.registeredHandler);

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
                {
                    var s = (_FromEventPattern)state!;
                    s.CompleteDispose();
                }, this);
            }
        }

        void OnNext(T value)
        {
            observer?.OnNext(value);
        }

        void CompleteDispose()
        {
            observer?.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            var handler = Interlocked.Exchange(ref removeHandler, null);
            if (handler != null)
            {
                observer = null;
                removeHandler = null;
                cancellationTokenRegistration.Dispose();
                handler(this.registeredHandler);
            }
        }
    }
}



================================================
FILE: src/R3/Factories/Merge.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Merge<T>(params Observable<T>[] sources)
    {
        return new Merge<T>(sources);
    }

    public static Observable<T> Merge<T>(this IEnumerable<Observable<T>> sources)
    {
        return new Merge<T>(sources);
    }
}

public static partial class ObservableExtensions
{
    public static Observable<T> Merge<T>(this Observable<T> source, Observable<T> second)
    {
        return new Merge<T>(new[] { source, second });
    }
}

internal sealed class Merge<T>(IEnumerable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var merge = new _Merge(observer);
        var builder = Disposable.CreateBuilder();

        var count = 0;
        foreach (var item in sources)
        {
            item.Subscribe(new _MergeObserver(merge)).AddTo(ref builder);
            count++;
        }

        merge.disposable.Disposable = builder.Build();

        merge.SetSourceCount(count);

        return merge;
    }

    sealed class _Merge(Observer<T> observer) : IDisposable
    {
        public Observer<T> observer = observer;
        public SingleAssignmentDisposableCore disposable;
        public readonly object gate = new object();

        int sourceCount = -1; // not set yet.
        int completeCount;

        public void SetSourceCount(int count)
        {
            lock (gate)
            {
                sourceCount = count;
                if (sourceCount == completeCount)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        // when all sources are completed, then this observer is completed
        public void TryPublishCompleted()
        {
            lock (gate)
            {
                completeCount++;
                if (completeCount == sourceCount)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void Dispose()
        {
            disposable.Dispose();
        }
    }

    sealed class _MergeObserver(_Merge parent) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            lock (parent.gate)
            {
                parent.observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (parent.gate)
            {
                parent.observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                // when error, publish OnCompleted immediately
                lock (parent.gate)
                {
                    parent.observer.OnCompleted(result);
                }
            }
            else
            {
                parent.TryPublishCompleted();
            }
        }
    }
}



================================================
FILE: src/R3/Factories/Never.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    // Never
    public static Observable<T> Never<T>()
    {
        return R3.Never<T>.Instance;
    }
}

internal sealed class Never<T> : Observable<T>
{
    // singleton
    public static readonly Never<T> Instance = new Never<T>();

    Never()
    {

    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return Disposable.Empty;
    }
}



================================================
FILE: src/R3/Factories/ObserveProperty.cs
================================================
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace R3;

public static partial class Observable
{
    /// <summary>
    /// Convert INotifyPropertyChanged to Observable.
    /// `propertySelector` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty> ObservePropertyChanged<T, TProperty>(this T value,
        Func<T, TProperty> propertySelector,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector))] string? expr = null)
        where T : INotifyPropertyChanged
    {
        if (expr == null) throw new ArgumentNullException(expr);

        var propertyName = expr!.Substring(expr.LastIndexOf('.') + 1);
        return new ObservePropertyChanged<T, TProperty>(value, propertySelector, propertyName, pushCurrentValueOnSubscribe, cancellationToken);
    }

    /// <summary>
    /// Convert INotifyPropertyChanged to Observable.
    /// `propertySelector1` and `propertySelector2` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty2> ObservePropertyChanged<T, TProperty1, TProperty2>(this T value,
        Func<T, TProperty1?> propertySelector1,
        Func<TProperty1, TProperty2> propertySelector2,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector1))] string? propertySelector1Expr = null,
        [CallerArgumentExpression(nameof(propertySelector2))] string? propertySelector2Expr = null)
        where T : INotifyPropertyChanged
        where TProperty1 : INotifyPropertyChanged
    {
        if (propertySelector1Expr == null) throw new ArgumentNullException(propertySelector1Expr);
        if (propertySelector2Expr == null) throw new ArgumentNullException(propertySelector2Expr);

        var property1Name = propertySelector1Expr!.Substring(propertySelector1Expr.LastIndexOf('.') + 1);
        var property2Name = propertySelector2Expr!.Substring(propertySelector2Expr.LastIndexOf('.') + 1);

        return new ObservePropertyChanged<T, TProperty1?>(value, propertySelector1, property1Name, true, cancellationToken)
            .Select(
                (propertySelector2, property2Name, pushCurrentValueOnSubscribe, cancellationToken),
                (firstPropertyValue, state) =>
                    firstPropertyValue is not null
                        ? new ObservePropertyChanged<TProperty1, TProperty2>(firstPropertyValue,
                            state.propertySelector2, state.property2Name, state.pushCurrentValueOnSubscribe,
                            state.cancellationToken)
                        : Empty<TProperty2>())
            .Switch();
    }

    /// <summary>
    /// Convert INotifyPropertyChanged to Observable.
    /// `propertySelector1`, `propertySelector2`, and `propertySelector3` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty3> ObservePropertyChanged<T, TProperty1, TProperty2, TProperty3>(this T value,
        Func<T, TProperty1?> propertySelector1,
        Func<TProperty1, TProperty2?> propertySelector2,
        Func<TProperty2, TProperty3> propertySelector3,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector1))] string? propertySelector1Expr = null,
        [CallerArgumentExpression(nameof(propertySelector2))] string? propertySelector2Expr = null,
        [CallerArgumentExpression(nameof(propertySelector3))] string? propertySelector3Expr = null)
        where T : INotifyPropertyChanged
        where TProperty1 : INotifyPropertyChanged
        where TProperty2 : INotifyPropertyChanged
    {
        if (propertySelector1Expr == null) throw new ArgumentNullException(propertySelector1Expr);
        if (propertySelector2Expr == null) throw new ArgumentNullException(propertySelector2Expr);
        if (propertySelector3Expr == null) throw new ArgumentNullException(propertySelector3Expr);

        var property1Name = propertySelector1Expr!.Substring(propertySelector1Expr.LastIndexOf('.') + 1);
        var property2Name = propertySelector2Expr!.Substring(propertySelector2Expr.LastIndexOf('.') + 1);
        var property3Name = propertySelector3Expr!.Substring(propertySelector3Expr.LastIndexOf('.') + 1);

        return new ObservePropertyChanged<T, TProperty1?>(value, propertySelector1, property1Name, true, cancellationToken)
            .Select(
                (propertySelector2, property2Name, propertySelector3, property3Name, pushCurrentValueOnSubscribe, cancellationToken),
                (firstPropertyValue, state) =>
                    firstPropertyValue is not null
                        ? new ObservePropertyChanged<TProperty1, TProperty2?>(firstPropertyValue, state.propertySelector2, state.property2Name, true, state.cancellationToken)
                            .Select(
                                (state.propertySelector3, state.property3Name, pushCurrentValueOnSubscribe, cancellationToken),
                                (secondPropertyValue, state2) =>
                                    secondPropertyValue is not null
                                        ? new ObservePropertyChanged<TProperty2, TProperty3>(secondPropertyValue,
                                            state2.propertySelector3, state2.property3Name, state2.pushCurrentValueOnSubscribe,
                                            state2.cancellationToken)
                                        : Empty<TProperty3>())
                            .Switch()
                        : Empty<TProperty3>())
            .Switch();
    }

    /// <summary>
    /// Convert INotifyPropertyChanging to Observable.
    /// `propertySelector` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty> ObservePropertyChanging<T, TProperty>(this T value,
        Func<T, TProperty> propertySelector,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector))] string? expr = null)
        where T : INotifyPropertyChanging
    {
        if (expr == null) throw new ArgumentNullException(expr);

        var propertyName = expr!.Substring(expr.LastIndexOf('.') + 1);
        return new ObservePropertyChanging<T, TProperty>(value, propertySelector, propertyName,
            pushCurrentValueOnSubscribe, cancellationToken);
    }

    /// <summary>
    /// Convert INotifyPropertyChanging to Observable.
    /// `propertySelector1` and `propertySelector2` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty2> ObservePropertyChanging<T, TProperty1, TProperty2>(this T value,
        Func<T, TProperty1?> propertySelector1,
        Func<TProperty1, TProperty2> propertySelector2,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector1))] string? propertySelector1Expr = null,
        [CallerArgumentExpression(nameof(propertySelector2))] string? propertySelector2Expr = null)
        where T : INotifyPropertyChanged
        where TProperty1 : INotifyPropertyChanging
    {
        if (propertySelector2Expr == null) throw new ArgumentNullException(propertySelector2Expr);

        var property2Name = propertySelector2Expr!.Substring(propertySelector2Expr.LastIndexOf('.') + 1);

        return ObservePropertyChanged(value, propertySelector1, true, cancellationToken, propertySelector1Expr)
            .Select(
                (propertySelector2, property2Name, pushCurrentValueOnSubscribe, cancellationToken),
                (firstPropertyValue, state) =>
                    firstPropertyValue is not null
                        ? new ObservePropertyChanging<TProperty1, TProperty2>(firstPropertyValue,
                            state.propertySelector2, state.property2Name, state.pushCurrentValueOnSubscribe,
                            state.cancellationToken)
                        : Empty<TProperty2>())
            .Switch();
    }

    /// <summary>
    /// Convert INotifyPropertyChanging to Observable.
    /// `propertySelector1`, `propertySelector2`, and `propertySelector3` must be a Func specifying a simple property. For example, it extracts "Foo" from `x => x.Foo`.
    /// </summary>
    public static Observable<TProperty3> ObservePropertyChanging<T, TProperty1, TProperty2, TProperty3>(this T value,
        Func<T, TProperty1?> propertySelector1,
        Func<TProperty1, TProperty2?> propertySelector2,
        Func<TProperty2, TProperty3> propertySelector3,
        bool pushCurrentValueOnSubscribe = true,
        CancellationToken cancellationToken = default,
        [CallerArgumentExpression(nameof(propertySelector1))] string? propertySelector1Expr = null,
        [CallerArgumentExpression(nameof(propertySelector2))] string? propertySelector2Expr = null,
        [CallerArgumentExpression(nameof(propertySelector3))] string? propertySelector3Expr = null)
        where T : INotifyPropertyChanged
        where TProperty1 : INotifyPropertyChanged
        where TProperty2 : INotifyPropertyChanging
    {
        if (propertySelector3Expr == null) throw new ArgumentNullException(propertySelector3Expr);

        var property3Name = propertySelector3Expr!.Substring(propertySelector3Expr.LastIndexOf('.') + 1);

        return ObservePropertyChanged(value, propertySelector1, propertySelector2, true, cancellationToken, propertySelector1Expr, propertySelector2Expr)
            .Select(
                (propertySelector3, property3Name, pushCurrentValueOnSubscribe, cancellationToken),
                (secondPropertyValue, state) =>
                    secondPropertyValue is not null
                        ? new ObservePropertyChanging<TProperty2, TProperty3>(secondPropertyValue,
                            state.propertySelector3, state.property3Name, state.pushCurrentValueOnSubscribe,
                            state.cancellationToken)
                        : Empty<TProperty3>())
            .Switch();
    }
}

internal sealed class ObservePropertyChanged<T, TProperty>(
    T value,
    Func<T, TProperty> propertySelector,
    string propertyName,
    bool pushCurrentValueOnSubscribe,
    CancellationToken cancellationToken)
    : Observable<TProperty> where T : INotifyPropertyChanged
{
    protected override IDisposable SubscribeCore(Observer<TProperty> observer)
    {
        if (pushCurrentValueOnSubscribe)
        {
            observer.OnNext(propertySelector(value));
        }

        return new _ObservePropertyChanged(observer, value, propertySelector, propertyName, cancellationToken);
    }

    sealed class _ObservePropertyChanged : IDisposable
    {
        readonly Observer<TProperty> observer;
        readonly T value;
        readonly Func<T, TProperty> propertySelector;
        readonly string propertyName;
        PropertyChangedEventHandler? eventHandler;
        CancellationTokenRegistration cancellationTokenRegistration;

        public _ObservePropertyChanged(Observer<TProperty> observer, T value, Func<T, TProperty> propertySelector, string propertyName, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.value = value;
            this.propertySelector = propertySelector;
            this.propertyName = propertyName;
            this.eventHandler = PublishOnNext;

            value.PropertyChanged += eventHandler;

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
                {
                    var s = (_ObservePropertyChanged)state!;
                    s.CompleteDispose();
                }, this);
            }
        }

        void PublishOnNext(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == propertyName)
            {
                TProperty prop;
                try
                {
                    prop = propertySelector(value);
                }
                catch (Exception ex)
                {
                    observer.OnErrorResume(ex);
                    return;
                }

                observer.OnNext(prop);
            }
        }

        void CompleteDispose()
        {
            observer.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            var handler = Interlocked.Exchange(ref eventHandler, null);
            if (handler != null)
            {
                cancellationTokenRegistration.Dispose();
                value.PropertyChanged -= eventHandler;
            }
        }
    }
}

internal sealed class ObservePropertyChanging<T, TProperty>(
    T value,
    Func<T, TProperty> propertySelector,
    string propertyName,
    bool pushCurrentValueOnSubscribe,
    CancellationToken cancellationToken)
    : Observable<TProperty> where T : INotifyPropertyChanging
{
    protected override IDisposable SubscribeCore(Observer<TProperty> observer)
    {
        if (pushCurrentValueOnSubscribe)
        {
            observer.OnNext(propertySelector(value));
        }

        return new _ObservePropertyChanging(observer, value, propertySelector, propertyName, cancellationToken);
    }

    sealed class _ObservePropertyChanging : IDisposable
    {
        readonly Observer<TProperty> observer;
        readonly T value;
        readonly Func<T, TProperty> propertySelector;
        readonly string propertyName;
        PropertyChangingEventHandler? eventHandler;
        CancellationTokenRegistration cancellationTokenRegistration;

        public _ObservePropertyChanging(Observer<TProperty> observer, T value, Func<T, TProperty> propertySelector, string propertyName, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.value = value;
            this.propertySelector = propertySelector;
            this.propertyName = propertyName;
            this.eventHandler = PublishOnNext;

            value.PropertyChanging += eventHandler;

            if (cancellationToken.CanBeCanceled)
            {
                this.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
                {
                    var s = (_ObservePropertyChanging)state!;
                    s.CompleteDispose();
                }, this);
            }
        }

        void PublishOnNext(object? sender, PropertyChangingEventArgs e)
        {
            if (e.PropertyName == propertyName)
            {
                TProperty prop;
                try
                {
                    prop = propertySelector(value);
                }
                catch (Exception ex)
                {
                    observer.OnErrorResume(ex);
                    return;
                }

                observer.OnNext(prop);
            }
        }

        void CompleteDispose()
        {
            observer.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            var handler = Interlocked.Exchange(ref eventHandler, null);
            if (handler != null)
            {
                cancellationTokenRegistration.Dispose();
                value.PropertyChanging -= eventHandler;
            }
        }
    }
}



================================================
FILE: src/R3/Factories/Race.cs
================================================
﻿using System.ComponentModel;

namespace R3;

public static partial class Observable
{
    public static Observable<T> Race<T>(params Observable<T>[] sources)
    {
        return new Race<T>(sources);
    }

    public static Observable<T> Race<T>(IEnumerable<Observable<T>> sources)
    {
        return new Race<T>(sources);
    }

    [Obsolete("Amb is renamed to Race.")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static Observable<T> Amb<T>(params Observable<T>[] sources)
    {
        return Race(sources);
    }

    [Obsolete("Amb is renamed to Race.")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static Observable<T> Amb<T>(IEnumerable<Observable<T>> sources)
    {
        return Race(sources);
    }
}

public static partial class ObservableExtensions
{
    public static Observable<T> Race<T>(this Observable<T> source, Observable<T> second)
    {
        return Observable.Race(source, second);
    }

    [Obsolete("Amb is renamed to Race.")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static Observable<T> Amb<T>(this Observable<T> source, Observable<T> second)
    {
        return Race(source, second);
    }
}

internal sealed class Race<T>(IEnumerable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        if (!sources.TryGetNonEnumeratedCount(out var count))
        {
            count = 4;
        }

        var race = new _Race(observer, count);
        var index = 0;
        foreach (var item in sources)
        {
            var d = item.Subscribe(new _RaceObserver(race, index++));
            race.disposables.Add(d);
        }
        return race;
    }

    sealed class _Race : IDisposable
    {
        public Observer<T> observer;
        public ListDisposableCore disposables;

        public _RaceObserver? winner;

        public _Race(Observer<T> observer, int initialCount)
        {
            this.observer = observer;
            this.disposables = new ListDisposableCore(initialCount, this);
        }

        public void Dispose()
        {
            disposables.Dispose();
        }
    }

    sealed class _RaceObserver(_Race parent, int index) : Observer<T>
    {
        bool won;

        protected override void OnNextCore(T value)
        {
            if (won)
            {
                parent.observer.OnNext(value);
                return;
            }

            var field = Interlocked.CompareExchange(ref parent.winner, this, null);
            if (field == null)
            {
                // first, dispose others.
                won = true;
                parent.disposables.RemoveAllExceptAt(index);
                parent.observer.OnNext(value);
            }
            else if (field == this)
            {
                parent.observer.OnNext(value);
            }
            else
            {
                // dispose self.
                Dispose();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            if (won)
            {
                parent.observer.OnErrorResume(error);
                return;
            }

            var field = Interlocked.CompareExchange(ref parent.winner, this, null);
            if (field == null)
            {
                // first, dispose others.
                won = true;
                parent.disposables.RemoveAllExceptAt(index);
                parent.observer.OnErrorResume(error);
            }
            else if (field == this)
            {
                parent.observer.OnErrorResume(error);
            }
            else
            {
                // dispose self.
                Dispose();
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            if (won)
            {
                parent.observer.OnCompleted(result);
                return;
            }

            var field = Interlocked.CompareExchange(ref parent.winner, this, null);
            if (field == null)
            {
                // first, dispose others.
                won = true;
                parent.disposables.RemoveAllExceptAt(index);
                parent.observer.OnCompleted(result);
            }
            else if (field == this)
            {
                parent.observer.OnCompleted(result);
            }
            else
            {
                // dispose self.
                Dispose();
            }
        }

        protected override void DisposeCore()
        {
            parent.disposables.RemoveAt(index);
        }
    }
}



================================================
FILE: src/R3/Factories/Range.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    // no scheduler(TimeProvider) overload

    public static Observable<int> Range(int start, int count)
    {
        long max = ((long)start) + count - 1;
        if (count < 0 || max > int.MaxValue)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }

        if (count == 0)
        {
            return Empty<int>();
        }

        return new Range(start, count);
    }

    public static Observable<int> Range(int start, int count, CancellationToken cancellationToken)
    {
        long max = ((long)start) + count - 1;
        if (count < 0 || max > int.MaxValue)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }

        if (count == 0)
        {
            return Empty<int>();
        }

        return new RangeC(start, count, cancellationToken);
    }
}

internal sealed class Range(int start, int count) : Observable<int>
{
    protected override IDisposable SubscribeCore(Observer<int> observer)
    {
        for (int i = 0; i < count; i++)
        {
            observer.OnNext(start + i);
        }
        observer.OnCompleted(default);
        return Disposable.Empty;
    }
}

internal sealed class RangeC(int start, int count, CancellationToken cancellationToken) : Observable<int>
{
    protected override IDisposable SubscribeCore(Observer<int> observer)
    {
        for (int i = 0; i < count; i++)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                observer.OnCompleted();
                return Disposable.Empty;
            }
            observer.OnNext(start + i);
        }
        observer.OnCompleted();
        return Disposable.Empty;
    }
}



================================================
FILE: src/R3/Factories/Repeat.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    // no scheduler(TimeProvider) overload
    // no infinitely overload

    public static Observable<T> Repeat<T>(T value, int count)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }

        if (count == 0)
        {
            return Empty<T>();
        }

        return new Repeat<T>(value, count);
    }

    public static Observable<T> Repeat<T>(T value, int count, CancellationToken cancellationToken)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }

        if (count == 0)
        {
            return Empty<T>();
        }

        return new RepeatC<T>(value, count, cancellationToken);
    }
}

internal sealed class Repeat<T>(T value, int count) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        for (int i = 0; i < count; i++)
        {
            observer.OnNext(value);
        }
        observer.OnCompleted(default);
        return Disposable.Empty;
    }
}

internal sealed class RepeatC<T>(T value, int count, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        for (int i = 0; i < count; i++)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                observer.OnCompleted();
                return Disposable.Empty;
            }
            observer.OnNext(value);
        }
        observer.OnCompleted(default);
        return Disposable.Empty;
    }
}



================================================
FILE: src/R3/Factories/Return.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Return<T>(T value)
    {
        return new ImmediateScheduleReturn<T>(value); // immediate
    }

    public static Observable<T> Return<T>(T value, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        return Return(value, TimeSpan.Zero, timeProvider, cancellationToken);
    }

    public static Observable<T> Return<T>(T value, TimeSpan dueTime, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        if (dueTime == TimeSpan.Zero)
        {
            if (timeProvider == TimeProvider.System)
            {
                return new ThreadPoolScheduleReturn<T>(value, cancellationToken); // optimize for SystemTimeProvidr, use ThreadPool.UnsafeQueueUserWorkItem
            }
        }

        return new Return<T>(value, dueTime.Normalize(), timeProvider, cancellationToken); // use ITimer
    }

    // Optimized case

    public static Observable<Unit> ReturnUnit()
    {
        return R3.ReturnUnit.Instance; // singleton
    }

    public static Observable<Unit> Return(Unit value)
    {
        return R3.ReturnUnit.Instance;
    }

    public static Observable<bool> Return(bool value)
    {
        return value ? ReturnBoolean.True : ReturnBoolean.False; // singleton
    }

    public static Observable<int> Return(int value)
    {
        return ReturnInt32.GetObservable(value); // -1~9 singleton
    }

    // util

    public static Observable<Unit> Yield(CancellationToken cancellationToken = default)
    {
        return new ThreadPoolScheduleReturn<Unit>(default, cancellationToken);
    }

    public static Observable<Unit> Yield(TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        if (timeProvider == TimeProvider.System)
        {
            return new ThreadPoolScheduleReturn<Unit>(default, cancellationToken);
        }
        return new Return<Unit>(default, TimeSpan.Zero, timeProvider, cancellationToken);
    }
}

internal sealed class Return<T>(T value, TimeSpan dueTime, TimeProvider timeProvider, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var method = new _Return(value, observer);
        method.Timer = timeProvider.CreateStoppedTimer(_Return.timerCallback, method);

        if (cancellationToken.CanBeCanceled)
        {
            method.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
            {
                var s = (_Return)state!;
                s.CompleteDispose();
            }, method);
        }

        method.Timer.InvokeOnce(dueTime);
        return method;
    }

    sealed class _Return(T value, Observer<T> observer) : IDisposable
    {
        public static readonly TimerCallback timerCallback = NextTick;

        internal CancellationTokenRegistration cancellationTokenRegistration;

        readonly T value = value;
        readonly Observer<T> observer = observer;

        public ITimer? Timer { get; set; }

        static void NextTick(object? state)
        {
            var self = (_Return)state!;
            self.observer.OnNext(self.value);
            self.observer.OnCompleted();
        }

        public void CompleteDispose()
        {
            observer.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            cancellationTokenRegistration.Dispose();
            Timer?.Dispose();
            Timer = null;
        }
    }
}

internal sealed class ImmediateScheduleReturn<T>(T value) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        observer.OnNext(value);
        observer.OnCompleted();
        return Disposable.Empty;
    }
}

internal sealed class ThreadPoolScheduleReturn<T>(T value, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var method = new _Return(value, observer);

        if (cancellationToken.CanBeCanceled)
        {
            method.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
            {
                var s = (_Return)state!;
                s.CompleteDispose();
            }, method);
        }

        ThreadPool.UnsafeQueueUserWorkItem(method, preferLocal: false);
        return method;
    }

    sealed class _Return(T value, Observer<T> observer) : IDisposable, IThreadPoolWorkItem
    {
        bool stop;

        internal CancellationTokenRegistration cancellationTokenRegistration;

        public void Execute()
        {
            if (stop) return;

            observer.OnNext(value);
            observer.OnCompleted();
        }

        public void CompleteDispose()
        {
            observer.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            cancellationTokenRegistration.Dispose();
            stop = true;
        }
    }
}

// Optimized case

internal sealed class ReturnUnit : Observable<Unit>
{
    internal static readonly Observable<Unit> Instance = new ReturnUnit();

    ReturnUnit()
    {
    }

    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        observer.OnNext(default);
        observer.OnCompleted();
        return Disposable.Empty;
    }
}

internal sealed class ReturnBoolean : Observable<bool>
{
    internal static readonly Observable<bool> True = new ReturnBoolean(true);
    internal static readonly Observable<bool> False = new ReturnBoolean(false);

    bool value;

    ReturnBoolean(bool value)
    {
        this.value = value;
    }

    protected override IDisposable SubscribeCore(Observer<bool> observer)
    {
        observer.OnNext(value);
        observer.OnCompleted();
        return Disposable.Empty;
    }
}

internal sealed class ReturnInt32 : Observable<int>
{
    internal static readonly Observable<int> _m1 = new ReturnInt32(-1);
    internal static readonly Observable<int> _0 = new ReturnInt32(0);
    internal static readonly Observable<int> _1 = new ReturnInt32(1);
    internal static readonly Observable<int> _2 = new ReturnInt32(2);
    internal static readonly Observable<int> _3 = new ReturnInt32(3);
    internal static readonly Observable<int> _4 = new ReturnInt32(4);
    internal static readonly Observable<int> _5 = new ReturnInt32(5);
    internal static readonly Observable<int> _6 = new ReturnInt32(6);
    internal static readonly Observable<int> _7 = new ReturnInt32(7);
    internal static readonly Observable<int> _8 = new ReturnInt32(8);
    internal static readonly Observable<int> _9 = new ReturnInt32(9);

    public static Observable<int> GetObservable(int value)
    {
        switch (value)
        {
            case -1: return _m1;
            case 0: return _0;
            case 1: return _1;
            case 2: return _2;
            case 3: return _3;
            case 4: return _4;
            case 5: return _5;
            case 6: return _6;
            case 7: return _7;
            case 8: return _8;
            case 9: return _9;
            default: return new ReturnInt32(value);
        }
    }

    int value;

    ReturnInt32(int value)
    {
        this.value = value;
    }

    protected override IDisposable SubscribeCore(Observer<int> observer)
    {
        observer.OnNext(value);
        observer.OnCompleted();
        return Disposable.Empty;
    }
}



================================================
FILE: src/R3/Factories/ReturnFrame.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> ReturnFrame<T>(T value, CancellationToken cancellationToken = default)
    {
        return ReturnFrame(value, ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<T> ReturnFrame<T>(T value, FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return new ReturnFrame<T>(value, frameProvider, cancellationToken);
    }

    public static Observable<T> ReturnFrame<T>(T value, int dueTimeFrame, CancellationToken cancellationToken = default)
    {
        return ReturnFrame(value, dueTimeFrame, ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<T> ReturnFrame<T>(T value, int dueTimeFrame, FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return new ReturnFrameTime<T>(value, dueTimeFrame, frameProvider, cancellationToken);
    }

    public static Observable<Unit> NextFrame(CancellationToken cancellationToken = default)
    {
        return NextFrame(ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<Unit> NextFrame(FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return new NextFrame(frameProvider, cancellationToken);
    }

    // util

    public static Observable<Unit> YieldFrame(CancellationToken cancellationToken = default)
    {
        return ReturnFrame(Unit.Default, ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<Unit> YieldFrame(FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return ReturnFrame(Unit.Default, frameProvider, cancellationToken);
    }
}

internal sealed class ReturnFrame<T>(T value, FrameProvider frameProvider, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var runner = new ReturnFrameRunnerWorkItem(value, observer, cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class ReturnFrameRunnerWorkItem(T value, Observer<T> observer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<T>(observer, cancellationToken)
    {
        protected override bool MoveNextCore(long frameCount)
        {
            PublishOnNext(value);
            PublishOnCompleted();
            return false;
        }
    }
}

internal sealed class ReturnFrameTime<T>(T value, int dueTimeFrame, FrameProvider frameProvider, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var runner = new ReturnFrameTimeRunnerWorkItem(value, dueTimeFrame.NormalizeFrame(), observer, cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class ReturnFrameTimeRunnerWorkItem(T value, int dueTimeFrame, Observer<T> observer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<T>(observer, cancellationToken)
    {
        int currentFrame;

        protected override bool MoveNextCore(long frameCount)
        {
            if (++currentFrame == dueTimeFrame)
            {
                PublishOnNext(value);
                PublishOnCompleted();
                return false;
            }

            return true;
        }
    }
}

internal sealed class NextFrame(FrameProvider frameProvider, CancellationToken cancellationToken) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        var runner = new NextFrameRunnerWorkItem(observer, frameProvider.GetFrameCount(), cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class NextFrameRunnerWorkItem(Observer<Unit> observer, long startFrameCount, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<Unit>(observer, cancellationToken)
    {
        protected override bool MoveNextCore(long frameCount)
        {
            // same frame, skip
            if (startFrameCount == frameCount)
            {
                return true;
            }

            PublishOnNext(default);
            PublishOnCompleted();
            return false;
        }
    }
}



================================================
FILE: src/R3/Factories/ReturnOnCompleted.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> ReturnOnCompleted<T>(Result result)
    {
        if (result.IsSuccess)
        {
            return ImmediateScheduleReturnOnCompletedSuccess<T>.Instance; // singleton
        }
        else
        {
            return new ImmediateScheduleReturnOnCompleted<T>(result); // immediate
        }
    }

    public static Observable<T> ReturnOnCompleted<T>(Result result, TimeProvider timeProvider)
    {
        return ReturnOnCompleted<T>(result, TimeSpan.Zero, timeProvider);
    }

    public static Observable<T> ReturnOnCompleted<T>(Result result, TimeSpan dueTime, TimeProvider timeProvider)
    {
        if (dueTime == TimeSpan.Zero)
        {
            if (timeProvider == TimeProvider.System)
            {
                return new ThreadPoolScheduleReturnOnCompleted<T>(result); // optimize for SystemTimeProvidr, use ThreadPool.UnsafeQueueUserWorkItem
            }
        }

        return new ReturnOnCompleted<T>(result, dueTime, timeProvider); // use ITimer
    }
}

internal class ImmediateScheduleReturnOnCompletedSuccess<T> : Observable<T>
{
    public static readonly Observable<T> Instance = new ImmediateScheduleReturnOnCompletedSuccess<T>();

    ImmediateScheduleReturnOnCompletedSuccess()
    {

    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        observer.OnCompleted(Result.Success);
        return Disposable.Empty;
    }
}

internal class ImmediateScheduleReturnOnCompleted<T>(Result result) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        observer.OnCompleted(result);
        return Disposable.Empty;
    }
}

internal class ReturnOnCompleted<T>(Result complete, TimeSpan dueTime, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var method = new _ReturnOnCompleted(complete, observer);
        method.Timer = timeProvider.CreateStoppedTimer(_ReturnOnCompleted.timerCallback, method);
        method.Timer.InvokeOnce(dueTime);
        return method;
    }

    sealed class _ReturnOnCompleted(Result result, Observer<T> observer) : IDisposable
    {
        public static readonly TimerCallback timerCallback = NextTick;

        readonly Result result = result;
        readonly Observer<T> observer = observer;

        public ITimer? Timer { get; set; }

        static void NextTick(object? state)
        {
            var self = (_ReturnOnCompleted)state!;
            try
            {
                self.observer.OnCompleted(self.result);
            }
            finally
            {
                self.Dispose();
            }
        }

        public void Dispose()
        {
            Timer?.Dispose();
            Timer = null;
        }
    }
}

internal class ThreadPoolScheduleReturnOnCompleted<T>(Result result) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var method = new _ReturnOnCompleted(result, observer);
        ThreadPool.UnsafeQueueUserWorkItem(method, preferLocal: false);
        return method;
    }

    sealed class _ReturnOnCompleted(Result result, Observer<T> observer) : IDisposable, IThreadPoolWorkItem
    {
        bool stop;

        public void Execute()
        {
            if (stop) return;

            observer.OnCompleted(result);
        }

        public void Dispose()
        {
            stop = true;
        }
    }
}



================================================
FILE: src/R3/Factories/Throw.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Throw<T>(Exception exception)
    {
        return ReturnOnCompleted<T>(Result.Failure(exception));
    }

    public static Observable<T> Throw<T>(Exception exception, TimeProvider timeProvider)
    {
        return ReturnOnCompleted<T>(Result.Failure(exception), timeProvider);
    }

    public static Observable<T> Throw<T>(Exception exception, TimeSpan dueTime, TimeProvider timeProvider)
    {
        return ReturnOnCompleted<T>(Result.Failure(exception), dueTime, timeProvider);
    }
}





================================================
FILE: src/R3/Factories/Timer.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<Unit> Interval(TimeSpan period, CancellationToken cancellationToken = default)
    {
        return Timer(period, period, cancellationToken);
    }

    public static Observable<Unit> Interval(TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        return Timer(period, period, timeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(TimeSpan dueTime, CancellationToken cancellationToken = default)
    {
        return Timer(dueTime, ObservableSystem.DefaultTimeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(DateTimeOffset dueTime, CancellationToken cancellationToken = default)
    {
        return Timer(dueTime, ObservableSystem.DefaultTimeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(TimeSpan dueTime, TimeSpan period, CancellationToken cancellationToken = default)
    {
        if (period < TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(period));
        return Timer(dueTime, period, ObservableSystem.DefaultTimeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(DateTimeOffset dueTime, TimeSpan period, CancellationToken cancellationToken = default)
    {
        if (period < TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(period));
        return Timer(dueTime, period, ObservableSystem.DefaultTimeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(TimeSpan dueTime, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        return new Timer(dueTime, null, timeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(DateTimeOffset dueTime, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        return new Timer(dueTime, null, timeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(TimeSpan dueTime, TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        if (period < TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(period));
        return new Timer(dueTime, period, timeProvider, cancellationToken);
    }

    public static Observable<Unit> Timer(DateTimeOffset dueTime, TimeSpan period, TimeProvider timeProvider, CancellationToken cancellationToken = default)
    {
        if (period < TimeSpan.Zero) throw new ArgumentOutOfRangeException(nameof(period));
        return new Timer(dueTime, period, timeProvider, cancellationToken);
    }
}

internal sealed class Timer : Observable<Unit>
{
    readonly TimeSpan? dueTime1;
    readonly DateTimeOffset? dueTime2;
    readonly TimeSpan? period;
    readonly TimeProvider timeProvider;
    readonly CancellationToken cancellationToken;

    public Timer(TimeSpan dueTime, TimeSpan? period, TimeProvider timeProvider, CancellationToken cancellationToken)
    {
        this.dueTime1 = dueTime;
        this.period = period;
        this.timeProvider = timeProvider;
        this.cancellationToken = cancellationToken;
    }

    public Timer(DateTimeOffset dueTime, TimeSpan? period, TimeProvider timeProvider, CancellationToken cancellationToken)
    {
        this.dueTime2 = dueTime;
        this.period = period;
        this.timeProvider = timeProvider;
        this.cancellationToken = cancellationToken;
    }

    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        var callback = (period == null) ? _Timer.singleTimerCallback : _Timer.periodicTimerCallback;
        var method = new _Timer(observer);
        method.Timer = timeProvider.CreateStoppedTimer(callback, method);

        var dueTime = (dueTime1 != null)
            ? dueTime1.Value
            : dueTime2!.Value - timeProvider.GetUtcNow();

        if (cancellationToken.CanBeCanceled)
        {
            method.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
            {
                var s = (_Timer)state!;
                s.CompleteDispose();
            }, method);
        }

        if (period == null)
        {
            method.Timer.InvokeOnce(dueTime.Normalize());
        }
        else
        {
            method.Timer.Change(dueTime.Normalize(), period.Value);
        }

        return method;
    }

    sealed class _Timer(Observer<Unit> observer) : IDisposable
    {
        public static readonly TimerCallback singleTimerCallback = SingleTick;
        public static readonly TimerCallback periodicTimerCallback = PeriodicTick;

        internal CancellationTokenRegistration cancellationTokenRegistration;
        Observer<Unit> observer = observer;

        public ITimer? Timer { get; set; }

        static void SingleTick(object? state)
        {
            var self = (_Timer)state!;
            try
            {
                self.observer.OnNext(default);
                self.observer.OnCompleted();
            }
            finally
            {
                self.Dispose();
            }
        }

        static void PeriodicTick(object? state)
        {
            var self = (_Timer)state!;
            lock (self)
            {
                self.observer.OnNext(default);
            }
        }

        public void CompleteDispose()
        {
            observer.OnCompleted();
            Dispose();
        }

        public void Dispose()
        {
            cancellationTokenRegistration.Dispose();
            Timer?.Dispose();
            Timer = null;
        }
    }
}



================================================
FILE: src/R3/Factories/TimerFrame.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<Unit> IntervalFrame(int periodFrame, CancellationToken cancellationToken = default)
    {
        return TimerFrame(periodFrame, periodFrame, cancellationToken);
    }

    public static Observable<Unit> IntervalFrame(int periodFrame, FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return TimerFrame(periodFrame, periodFrame, frameProvider, cancellationToken);
    }

    public static Observable<Unit> TimerFrame(int dueTimeFrame, CancellationToken cancellationToken = default)
    {
        return new TimerFrame(dueTimeFrame, null, ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<Unit> TimerFrame(int dueTimeFrame, int periodFrame, CancellationToken cancellationToken = default)
    {
        return new TimerFrame(dueTimeFrame, periodFrame, ObservableSystem.DefaultFrameProvider, cancellationToken);
    }

    public static Observable<Unit> TimerFrame(int dueTimeFrame, FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return new TimerFrame(dueTimeFrame, null, frameProvider, cancellationToken);
    }

    public static Observable<Unit> TimerFrame(int dueTimeFrame, int periodFrame, FrameProvider frameProvider, CancellationToken cancellationToken = default)
    {
        return new TimerFrame(dueTimeFrame, periodFrame, frameProvider, cancellationToken);
    }
}

internal sealed class TimerFrame(int dueTimeFrame, int? periodFrame, FrameProvider frameProvider, CancellationToken cancellationToken) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        dueTimeFrame = dueTimeFrame.NormalizeFrame();
        periodFrame = periodFrame?.NormalizeFrame();

        CancellableFrameRunnerWorkItemBase<Unit> runner = (periodFrame == null)
            ? new SingleTimerFrameRunnerWorkItem(dueTimeFrame, observer, cancellationToken)
            : new MultiTimerFrameRunnerWorkItem(dueTimeFrame, periodFrame.Value, observer, cancellationToken);
        frameProvider.Register(runner);
        return runner;
    }

    sealed class SingleTimerFrameRunnerWorkItem(int dueTimeFrame, Observer<Unit> observer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<Unit>(observer, cancellationToken)
    {
        int currentFrame;

        protected override bool MoveNextCore(long _)
        {
            if (++currentFrame == dueTimeFrame)
            {
                PublishOnNext(default);
                PublishOnCompleted();
                return false;
            }

            return true;
        }
    }

    sealed class MultiTimerFrameRunnerWorkItem(int dueTimeFrame, int periodFrame, Observer<Unit> observer, CancellationToken cancellationToken)
        : CancellableFrameRunnerWorkItemBase<Unit>(observer, cancellationToken)
    {
        int currentFrame;
        bool isPeriodPhase;

        protected override bool MoveNextCore(long _)
        {
            // initial phase
            if (!isPeriodPhase)
            {
                if (++currentFrame == dueTimeFrame)
                {
                    PublishOnNext(default);
                    isPeriodPhase = true;
                    currentFrame = 0;
                }
                return true;
            }

            // period phase
            if (++currentFrame == periodFrame)
            {
                PublishOnNext(default);
                currentFrame = 0;
            }
            return true;
        }
    }
}



================================================
FILE: src/R3/Factories/ToObservable.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<Unit> ToObservable(this Task task, bool configureAwait = true)
    {
        return new TaskToObservable(task, configureAwait);
    }

    public static Observable<T> ToObservable<T>(this Task<T> task, bool configureAwait = true)
    {
        return new TaskToObservable<T>(task, configureAwait);
    }

    public static Observable<Unit> ToObservable(this ValueTask task, bool configureAwait = true)
    {
        return new ValueTaskToObservable(task, configureAwait);
    }

    public static Observable<T> ToObservable<T>(this ValueTask<T> task, bool configureAwait = true)
    {
        return new ValueTaskToObservable<T>(task, configureAwait);
    }

    public static Observable<T> ToObservable<T>(this IEnumerable<T> source, CancellationToken cancellationToken = default)
    {
        return new EnumerableToObservable<T>(source, cancellationToken);
    }

    public static Observable<T> ToObservable<T>(this IAsyncEnumerable<T> source)
    {
        return new AsyncEnumerableToObservable<T>(source);
    }

    public static Observable<T> ToObservable<T>(this IObservable<T> source)
    {
        return new IObservableToObservable<T>(source);
    }
}

internal sealed class TaskToObservable(Task task, bool configureAwait) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        SubscribeTask(observer);
        return Disposable.Empty; // no need to return subscription
    }

    async void SubscribeTask(Observer<Unit> observer)
    {
        try
        {
            await task.ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (!observer.IsDisposed)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!observer.IsDisposed)
        {
            observer.OnNext(Unit.Default);
            observer.OnCompleted();
        }
    }
}

internal sealed class TaskToObservable<T>(Task<T> task, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        SubscribeTask(observer);
        return Disposable.Empty; // no need to return subscription
    }

    async void SubscribeTask(Observer<T> observer)
    {
        T? result;
        try
        {
            result = await task.ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (!observer.IsDisposed)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!observer.IsDisposed)
        {
            observer.OnNext(result);
            observer.OnCompleted();
        }
    }
}

internal sealed class ValueTaskToObservable(ValueTask task, bool configureAwait) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        SubscribeTask(observer);
        return Disposable.Empty; // no need to return subscription
    }

    async void SubscribeTask(Observer<Unit> observer)
    {
        try
        {
            await task.ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (!observer.IsDisposed)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!observer.IsDisposed)
        {
            observer.OnNext(Unit.Default);
            observer.OnCompleted();
        }
    }
}

internal sealed class ValueTaskToObservable<T>(ValueTask<T> task, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        SubscribeTask(observer);
        return Disposable.Empty; // no need to return subscription
    }

    async void SubscribeTask(Observer<T> observer)
    {
        T? result;
        try
        {
            result = await task.ConfigureAwait(configureAwait);
        }
        catch (Exception ex)
        {
            if (!observer.IsDisposed)
            {
                observer.OnCompleted(ex);
            }
            return;
        }

        if (!observer.IsDisposed)
        {
            observer.OnNext(result);
            observer.OnCompleted();
        }
    }
}

internal sealed class EnumerableToObservable<T>(IEnumerable<T> source, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        foreach (var message in source)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                observer.OnCompleted();
                return Disposable.Empty;
            }
            observer.OnNext(message);
        }
        observer.OnCompleted();
        return Disposable.Empty;
    }
}

internal sealed class AsyncEnumerableToObservable<T>(IAsyncEnumerable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var cancellationDisposable = new CancellationDisposable();
        RunAsync(observer, cancellationDisposable.Token);
        return cancellationDisposable;
    }

    async void RunAsync(Observer<T> observer, CancellationToken cancellationToken)
    {
        try
        {
            await foreach (var message in source.WithCancellation(cancellationToken))
            {
                observer.OnNext(message);
            }
            observer.OnCompleted();
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken) // disposed.
            {
                return;
            }

            observer.OnCompleted(Result.Failure(ex));
        }
    }
}

internal sealed class IObservableToObservable<T>(IObservable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new ObserverToObserver(observer));
    }

    sealed class ObserverToObserver(Observer<T> observer) : IObserver<T>
    {
        public void OnNext(T value)
        {
            observer.OnNext(value);
        }

        public void OnError(Exception error)
        {
            observer.OnCompleted(error);
        }

        public void OnCompleted()
        {
            observer.OnCompleted();
        }
    }
}



================================================
FILE: src/R3/Factories/Zip.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T[]> Zip<T>(params Observable<T>[] sources)
    {
        return new Zip<T>(sources);
    }

    public static Observable<T[]> Zip<T>(IEnumerable<Observable<T>> sources)
    {
        return new Zip<T>(sources);
    }
}

internal sealed class Zip<T>(IEnumerable<Observable<T>> sources) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return new _Zip(observer, sources).Run();
    }

    sealed class _Zip : IDisposable
    {
        readonly Observer<T[]> observer;
        readonly Observable<T>[] sources;
        readonly ZipObserver[] observers; // as lock gate

        public _Zip(Observer<T[]> observer, IEnumerable<Observable<T>> sources)
        {
            this.observer = observer;
            if (sources is Observable<T>[] array)
            {
                this.sources = array;
            }
            else
            {
                this.sources = sources.ToArray();
            }

            var observers = new ZipObserver[this.sources.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                observers[i] = new ZipObserver(this);
            }
            this.observers = observers;
        }

        public IDisposable Run()
        {
            try
            {
                for (int i = 0; i < sources.Length; i++)
                {
                    sources[i].Subscribe(observers[i]);
                }
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            bool requireCallOnCompleted = false;
            foreach (var item in observers)
            {
                if (!item.HasValue(out var shouldComplete)) return;
                if (shouldComplete)
                {
                    requireCallOnCompleted = true;
                }
            }

            var values = new T[observers.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                values[i] = observers[i].Values.Dequeue();
            }
            observer.OnNext(values);

            if (requireCallOnCompleted)
            {
                observer.OnCompleted();
                Dispose();
            }
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                if (empty || AllObserverIsCompleted())
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        bool AllObserverIsCompleted()
        {
            foreach (var item in observers)
            {
                if (!item.IsCompleted) return false;
            }
            return true;
        }

        public void Dispose()
        {
            foreach (var observer in observers)
            {
                observer.Dispose();
            }
        }

        sealed class ZipObserver(_Zip parent) : Observer<T>
        {
            public Queue<T> Values { get; } = new Queue<T>();
            public bool IsCompleted { get; private set; }

            public bool HasValue(out bool shouldComplete)
            {
                var count = Values.Count;
                shouldComplete = IsCompleted && count == 1;
                return count != 0;
            }

            protected override void OnNextCore(T value)
            {
                lock (parent.observers)
                {
                    this.Values.Enqueue(value);
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.observers)
                {
                    IsCompleted = true;
                    parent.TryPublishOnCompleted(result, Values.Count == 0);
                }
            }
        }
    }
}



================================================
FILE: src/R3/Factories/ZipLatest.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T[]> ZipLatest<T>(params Observable<T>[] sources)
    {
        return new ZipLatest<T>(sources);
    }

    public static Observable<T[]> ZipLatest<T>(IEnumerable<Observable<T>> sources)
    {
        return new ZipLatest<T>(sources);
    }
}

internal sealed class ZipLatest<T>(IEnumerable<Observable<T>> sources) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return new _CombineLatest(observer, sources).Run();
    }

    sealed class _CombineLatest : IDisposable
    {
        readonly Observer<T[]> observer;
        readonly Observable<T>[] sources;
        readonly CombineLatestObserver[] observers;

        public _CombineLatest(Observer<T[]> observer, IEnumerable<Observable<T>> sources)
        {
            this.observer = observer;
            if (sources is Observable<T>[] array)
            {
                this.sources = array;
            }
            else
            {
                this.sources = sources.ToArray();
            }

            var observers = new CombineLatestObserver[this.sources.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                observers[i] = new CombineLatestObserver(this);
            }
            this.observers = observers;
        }

        public IDisposable Run()
        {
            try
            {
                for (int i = 0; i < sources.Length; i++)
                {
                    sources[i].Subscribe(observers[i]);
                }
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            var hasCompletedObserver = false;
            foreach (var item in observers)
            {
                if (!item.HasValue) return;
                if (item.IsCompleted)
                {
                    hasCompletedObserver = true;
                }
            }

            var values = new T[observers.Length];
            for (int i = 0; i < observers.Length; i++)
            {
                values[i] = observers[i].GetValue();
            }
            observer.OnNext(values);

            if (hasCompletedObserver)
            {
                observer.OnCompleted();
                Dispose();
            }
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                if (empty || AllObserverIsCompleted())
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        bool AllObserverIsCompleted()
        {
            foreach (var item in observers)
            {
                if (!item.IsCompleted) return false;
            }
            return true;
        }

        public void Dispose()
        {
            foreach (var observer in observers)
            {
                observer.Dispose();
            }
        }

        sealed class CombineLatestObserver(_CombineLatest parent) : Observer<T>
        {
            T? value;
            public bool HasValue { get; private set; }
            public bool IsCompleted { get; private set; }

            public T GetValue()
            {
                var v = this.value;
                this.value = default;
                this.HasValue = false;
                return v!;
            }

            protected override void OnNextCore(T value)
            {
                lock (parent.observers)
                {
                    this.value = value;
                    this.HasValue = true;
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.observer)
                {
                    IsCompleted = true;
                    parent.TryPublishOnCompleted(result, !HasValue);
                }
            }
        }
    }
}



================================================
FILE: src/R3/Internal/CancellableFrameRunnerWorkItemBase.cs
================================================
﻿namespace R3.Internal;

// when Canceled, publish OnCompleted.
internal abstract class CancellableFrameRunnerWorkItemBase<T> : IFrameRunnerWorkItem, IDisposable
{
    readonly Observer<T> observer;
    CancellationTokenRegistration cancellationTokenRegistration;
    bool isDisposed;

    public CancellableFrameRunnerWorkItemBase(Observer<T> observer, CancellationToken cancellationToken)
    {
        this.observer = observer;

        if (cancellationToken.CanBeCanceled)
        {
            this.cancellationTokenRegistration = cancellationToken.UnsafeRegister(static state =>
            {
                var s = (CancellableFrameRunnerWorkItemBase<T>)state!;
                s.observer.OnCompleted();
                s.Dispose();
            }, this);
        }
    }

    public bool MoveNext(long frameCount)
    {
        if (isDisposed)
        {
            return false;
        }

        if (observer.IsDisposed)
        {
            Dispose();
            return false;
        }

        return MoveNextCore(frameCount);
    }

    protected abstract bool MoveNextCore(long frameCount);

    public void Dispose()
    {
        if (!isDisposed)
        {
            isDisposed = true;
            cancellationTokenRegistration.Dispose();
            DisposeCore();
        }
    }

    protected virtual void DisposeCore() { }

    // Observer

    protected void PublishOnNext(T value)
    {
        observer.OnNext(value);
    }

    protected void PublishOnErrorResume(Exception error)
    {
        observer.OnErrorResume(error);
    }

    protected void PublishOnCompleted(Exception error)
    {
        observer.OnCompleted(error);
        Dispose();
    }

    protected void PublishOnCompleted()
    {
        observer.OnCompleted();
        Dispose();
    }
}



================================================
FILE: src/R3/Internal/ChannelUtility.cs
================================================
﻿using System.Threading.Channels;

namespace R3.Internal;

internal static class ChannelUtility
{
    static readonly UnboundedChannelOptions options = new UnboundedChannelOptions
    {
        SingleWriter = true, // in Rx operator, OnNext gurantees synchronous
        SingleReader = true, // almostly uses single reader loop
        AllowSynchronousContinuations = true // if false, uses TaskCreationOptions.RunContinuationsAsynchronously so avoid it.
    };

    static readonly BoundedChannelOptions singularBoundedOptions = new BoundedChannelOptions(1)
    {
        SingleWriter = true, // in Rx operator, OnNext gurantees synchronous
        SingleReader = true, // almostly uses single reader loop
        AllowSynchronousContinuations = true, // if false, uses TaskCreationOptions.RunContinuationsAsynchronously so avoid it.
        FullMode = BoundedChannelFullMode.DropOldest, // This will ensure that the latest item to come in is always added
    };

    internal static Channel<T> CreateSingleReadeWriterUnbounded<T>()
    {
        return Channel.CreateUnbounded<T>(options);
    }

    internal static Channel<T> CreateSingleReadeWriterSingularBounded<T>()
    {
        return Channel.CreateBounded<T>(singularBoundedOptions);
    }
}



================================================
FILE: src/R3/Internal/FrameCountExtensions.cs
================================================
﻿namespace R3.Internal;

internal static class FrameCountExtensions
{
    // 0 is invalid, 1 is valid.
    public static int NormalizeFrame(this int frameCount)
    {
        return frameCount > 0 ? frameCount : 1;
    }
}



================================================
FILE: src/R3/Internal/ListDisposableCore.cs
================================================
﻿namespace R3.Internal;

internal struct ListDisposableCore : IDisposable
{
    IDisposable?[] disposables;
    int count;
    object gate;

    public ListDisposableCore(int initialCount, object gate)
    {
        this.disposables = new IDisposable?[initialCount];
        this.gate = gate;
    }

    public void Add(IDisposable disposable)
    {
        lock (gate)
        {
            if (disposables.Length == count)
            {
                Array.Resize(ref disposables, count * 2);
            }

            disposables[count++] = disposable;
        }
    }

    public void RemoveAt(int index)
    {
        lock (gate)
        {
            if (index < 0 || index >= count)
            {
                return;
            }

            ref var d = ref disposables[index];
            if (d != null)
            {
                d.Dispose();
            }
            d = null;
        }
    }

    public void RemoveAllExceptAt(int index)
    {
        lock (gate)
        {
            if (index < 0 || index >= count)
            {
                return;
            }

            for (int i = 0; i < count; i++)
            {
                if (i == index) continue;

                ref var d = ref disposables[i];
                if (d != null)
                {
                    d.Dispose();
                }
                d = null;
            }
        }
    }

    public void Dispose()
    {
        lock (gate)
        {
            for (int i = 0; i < count; i++)
            {
                disposables[i]?.Dispose();
                disposables[i] = null;
            }
            count = 0;
        }
    }
}



================================================
FILE: src/R3/Internal/RingBuffer.cs
================================================
﻿using System.Collections;
using System.Diagnostics.CodeAnalysis;

namespace R3.Internal;

internal sealed class RingBuffer<T> : IList<T>, IReadOnlyList<T>
{
    T[] buffer;
    int head;
    int count;
    int mask;

    public RingBuffer()
    {
        this.buffer = new T[8];
        this.head = 0;
        this.count = 0;
        this.mask = buffer.Length - 1;
    }

    public RingBuffer(int capacity)
    {
        this.buffer = new T[CalculateCapacity(capacity)];
        this.head = 0;
        this.count = 0;
        this.mask = buffer.Length - 1;
    }

    public RingBuffer(IEnumerable<T> collection)
    {
        var array = collection.TryGetNonEnumeratedCount(out var count)
            ? new T[CalculateCapacity(count)]
            : new T[8];
        var i = 0;
        foreach (var item in collection)
        {
            if (i == array.Length)
            {
                Array.Resize(ref array, i * 2);
            }
            array[i++] = item;
        }

        this.buffer = array;
        this.head = 0;
        this.count = i;
        this.mask = buffer.Length - 1;
    }

    static int CalculateCapacity(int size)
    {
        size--;
        size |= size >> 1;
        size |= size >> 2;
        size |= size >> 4;
        size |= size >> 8;
        size |= size >> 16;
        size += 1;

        if (size < 8)
        {
            size = 8;
        }
        return size;
    }

    public T this[int index]
    {
        get
        {
            var i = (head + index) & mask;
            return buffer[i];
        }
        set
        {
            var i = (head + index) & mask;
            buffer[i] = value;
        }
    }

    public int Count => count;

    public bool IsReadOnly => false;

    public void AddLast(T item)
    {
        if (count == buffer.Length) EnsureCapacity();

        var index = (head + count) & mask;
        buffer[index] = item;
        count++;
    }

    public void AddFirst(T item)
    {
        if (count == buffer.Length) EnsureCapacity();

        head = (head - 1) & mask;
        buffer[head] = item;
        count++;
    }

    public T RemoveLast()
    {
        if (count == 0) ThrowForEmpty();

        var index = (head + count - 1) & mask;
        var v = buffer[index];
        buffer[index] = default!;
        count--;
        return v;
    }

    public T RemoveFirst()
    {
        if (count == 0) ThrowForEmpty();

        var index = head & mask;
        var v = buffer[index];
        buffer[index] = default!;
        head = head + 1;
        count--;
        return v;
    }

    void EnsureCapacity()
    {
        var newBuffer = new T[buffer.Length * 2];

        var i = head & mask;
        buffer.AsSpan(i).CopyTo(newBuffer);

        if (i != 0)
        {
            buffer.AsSpan(0, i).CopyTo(newBuffer.AsSpan(buffer.Length - i));
        }

        head = 0;
        buffer = newBuffer;
        mask = newBuffer.Length - 1;
    }

    void ICollection<T>.Add(T item)
    {
        AddLast(item);
    }

    public void Clear()
    {
        Array.Clear(buffer, 0, buffer.Length);
        head = 0;
        count = 0;
    }

    public RingBufferSpan<T> GetSpan()
    {
        if (count == 0)
        {
            return new RingBufferSpan<T>(Array.Empty<T>(), Array.Empty<T>(), 0);
        }

        var start = head & mask;
        var end = (head + count) & mask;

        if (end > start)
        {
            var first = buffer.AsSpan(start, count);
            var second = Array.Empty<T>().AsSpan();
            return new RingBufferSpan<T>(first, second, count);
        }
        else
        {
            var first = buffer.AsSpan(start, buffer.Length - start);
            var second = buffer.AsSpan(0, end);
            return new RingBufferSpan<T>(first, second, count);
        }
    }

    public IEnumerator<T> GetEnumerator()
    {
        if (count == 0) yield break;

        var start = head & mask;
        var end = (head + count) & mask;

        if (end > start)
        {
            // start...end
            for (int i = start; i < end; i++)
            {
                yield return buffer[i];
            }
        }
        else
        {
            // start...
            for (int i = start; i < buffer.Length; i++)
            {
                yield return buffer[i];
            }
            // 0...end
            for (int i = 0; i < end; i++)
            {
                yield return buffer[i];
            }
        }
    }

    public IEnumerable<T> Reverse()
    {
        if (count == 0) yield break;

        var start = head & mask;
        var end = (head + count) & mask;

        if (end > start)
        {
            // end...start
            for (int i = end - 1; i >= start; i--)
            {
                yield return buffer[i];
            }
        }
        else
        {
            // end...0
            for (int i = end - 1; i >= 0; i--)
            {
                yield return buffer[i];
            }

            // ...start
            for (int i = buffer.Length - 1; i >= start; i--)
            {
                yield return buffer[i];
            }
        }
    }

    public bool Contains(T item)
    {
        return IndexOf(item) != -1;
    }

    public void CopyTo(T[] array, int arrayIndex)
    {
        var span = GetSpan();
        var dest = array.AsSpan(arrayIndex);
        span.First.CopyTo(dest);
        span.Second.CopyTo(dest.Slice(span.First.Length));
    }

    public int IndexOf(T item)
    {
        var i = 0;
        foreach (var v in GetSpan())
        {
            if (EqualityComparer<T>.Default.Equals(item, v))
            {
                return i;
            }
            i++;
        }
        return -1;
    }

    public T[] ToArray()
    {
        return GetSpan().ToArray();
    }

    public int BinarySearch(T item)
    {
        return BinarySearch(item, Comparer<T>.Default);
    }

    public int BinarySearch(T item, IComparer<T> comparer)
    {
        var lo = 0;
        var hi = count - 1;

        while (lo <= hi)
        {
            var mid = (int)(((uint)hi + (uint)lo) >> 1);
            var found = comparer.Compare(this[mid], item);

            if (found == 0) return mid;
            if (found < 0)
            {
                lo = mid + 1;
            }
            else
            {
                hi = mid - 1;
            }
        }

        return ~lo;
    }

    void IList<T>.Insert(int index, T item)
    {
        throw new NotSupportedException();
    }

    bool ICollection<T>.Remove(T item)
    {
        throw new NotSupportedException();
    }

    void IList<T>.RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable<T>)this).GetEnumerator();
    }

    [DoesNotReturn]
    static void ThrowForEmpty()
    {
        throw new InvalidOperationException("RingBuffer is empty.");
    }
}

internal ref struct RingBufferSpan<T>
{
    public readonly ReadOnlySpan<T> First;
    public readonly ReadOnlySpan<T> Second;
    public readonly int Count;

    internal RingBufferSpan(ReadOnlySpan<T> first, ReadOnlySpan<T> second, int count)
    {
        First = first;
        Second = second;
        Count = count;
    }

    public Enumerator GetEnumerator()
    {
        return new Enumerator(this);
    }

    public T[] ToArray()
    {
        var array = new T[Count];
        var span = array.AsSpan();
        First.CopyTo(span);
        span = span.Slice(First.Length);
        Second.CopyTo(span);
        return array;
    }

    public ref struct Enumerator
    {
        ReadOnlySpan<T>.Enumerator firstEnumerator;
        ReadOnlySpan<T>.Enumerator secondEnumerator;
        bool useFirst;

        public Enumerator(RingBufferSpan<T> span)
        {
            this.firstEnumerator = span.First.GetEnumerator();
            this.secondEnumerator = span.Second.GetEnumerator();
            this.useFirst = true;
        }

        public bool MoveNext()
        {
            if (useFirst)
            {
                if (firstEnumerator.MoveNext())
                {
                    return true;
                }
                else
                {
                    useFirst = false;
                }
            }

            if (secondEnumerator.MoveNext())
            {
                return true;
            }
            return false;
        }

        public ref readonly T Current
        {
            get
            {
                if (useFirst)
                {
                    return ref firstEnumerator.Current;
                }
                else
                {
                    return ref secondEnumerator.Current;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Internal/Stubs.cs
================================================
﻿namespace R3.Internal;

internal static class Stubs
{
    internal static readonly Action<Result> HandleResult = static x =>
    {
        if (x.IsFailure)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(x.Exception);
        }
    };
}

internal static class Stubs<T>
{
    internal static readonly Func<T, T> ReturnSelf = static x => x;


    // TState

    internal static readonly Action<Exception, T> HandleException = static (x, _) =>
    {
        ObservableSystem.GetUnhandledExceptionHandler().Invoke(x);
    };


    internal static readonly Action<Result, T> HandleResult = static (x, _) =>
    {
        if (x.IsFailure)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(x.Exception);
        }
    };
}



================================================
FILE: src/R3/Internal/TaskObserverBase.cs
================================================
﻿using System.Threading;

namespace R3.Internal;

// for return Task(tcs.TrySet***)
// include proper Cancel registration

internal abstract class TaskObserverBase<T, TTask> : Observer<T>
{
    TaskCompletionSource<TTask> tcs; // use this field.

    CancellationToken cancellationToken;
    CancellationTokenRegistration tokenRegistration;

    public Task<TTask> Task => tcs.Task;

    public TaskObserverBase(CancellationToken cancellationToken)
    {
        this.tcs = new TaskCompletionSource<TTask>();
        this.cancellationToken = cancellationToken;

        if (cancellationToken.CanBeCanceled)
        {
            // register before call Subscribe
            this.tokenRegistration = cancellationToken.UnsafeRegister(static state =>
            {
                var s = (TaskObserverBase<T, TTask>)state!;

                s.Dispose(); // observer is subscription, dispose
                s.tcs.TrySetCanceled(s.cancellationToken);
            }, this);
        }
    }

    // if override, should call base.DisposeCore(), be careful.
    protected override void DisposeCore()
    {
        tokenRegistration.Dispose();
    }

    protected void TrySetResult(TTask result)
    {
        try
        {
            tcs.TrySetResult(result);
        }
        finally
        {
            Dispose();
        }
    }

    protected void TrySetException(Exception exception)
    {
        try
        {
            tcs.TrySetException(exception);
        }
        finally
        {
            Dispose();
        }
    }
}



================================================
FILE: src/R3/Internal/ThrowHelper.cs
================================================
﻿using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace R3.Internal;

internal static class ThrowHelper
{
    internal static void ThrowArgumentNullIfNull([NotNull] object? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
    {
        if (argument is null)
        {
            ThrowArgumentNullException(paramName);
        }
    }

    internal static void ThrowObjectDisposedIf([DoesNotReturnIf(true)] bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    [DoesNotReturn]
    internal static void ThrowArgumentNullException(string? paramName) => throw new ArgumentNullException(paramName);

    [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3/Internal/TimeProviderExtensions.cs
================================================
﻿namespace R3.Internal;

internal static class TimeProviderExtensions
{
    public static ITimer CreateStoppedTimer(this TimeProvider timeProvider, TimerCallback timerCallback, object? state)
    {
        return timeProvider.CreateTimer(timerCallback, state, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
    }

    public static void RestartImmediately(this ITimer timer)
    {
        timer.Change(TimeSpan.Zero, Timeout.InfiniteTimeSpan);
    }

    public static void InvokeOnce(this ITimer timer, TimeSpan dueTime)
    {
        timer.Change(dueTime, Timeout.InfiniteTimeSpan);
    }

    public static void Stop(this ITimer timer)
    {
        timer.Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
    }
}





================================================
FILE: src/R3/Internal/TimeSpanExtensions.cs
================================================
﻿namespace R3.Internal;

internal static class TimeSpanExtensions
{
    public static TimeSpan Normalize(this TimeSpan timeSpan)
    {
        return timeSpan >= TimeSpan.Zero ? timeSpan : TimeSpan.Zero;
    }
}



================================================
FILE: src/R3/Internal/WeakDictionary.cs
================================================
﻿#nullable disable

namespace R3.Internal;

// Add, Remove, Enumerate with sweep. All operations are thread safe(in spinlock).
internal class WeakDictionary<TKey, TValue>
    where TKey : class
{
    Entry[] buckets;
    int size;
    SpinLock gate; // mutable struct(not readonly)

    readonly float loadFactor;
    readonly IEqualityComparer<TKey> keyEqualityComparer;

    public WeakDictionary(int capacity = 4, float loadFactor = 0.75f, IEqualityComparer<TKey> keyComparer = null)
    {
        var tableSize = CalculateCapacity(capacity, loadFactor);
        this.buckets = new Entry[tableSize];
        this.loadFactor = loadFactor;
        this.gate = new SpinLock(false);
        this.keyEqualityComparer = keyComparer ?? EqualityComparer<TKey>.Default;
    }

    public bool TryAdd(TKey key, TValue value)
    {
        bool lockTaken = false;
        try
        {
            gate.Enter(ref lockTaken);
            return TryAddInternal(key, value);
        }
        finally
        {
            if (lockTaken) gate.Exit(false);
        }
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
        bool lockTaken = false;
        try
        {
            gate.Enter(ref lockTaken);
            if (TryGetEntry(key, out _, out var entry))
            {
                value = entry.Value;
                return true;
            }

            value = default(TValue);
            return false;
        }
        finally
        {
            if (lockTaken) gate.Exit(false);
        }
    }

    public bool TryRemove(TKey key)
    {
        bool lockTaken = false;
        try
        {
            gate.Enter(ref lockTaken);
            if (TryGetEntry(key, out var hashIndex, out var entry))
            {
                Remove(hashIndex, entry);
                return true;
            }

            return false;
        }
        finally
        {
            if (lockTaken) gate.Exit(false);
        }
    }

    bool TryAddInternal(TKey key, TValue value)
    {
        var nextCapacity = CalculateCapacity(size + 1, loadFactor);

    TRY_ADD_AGAIN:
        if (buckets.Length < nextCapacity)
        {
            // rehash
            var nextBucket = new Entry[nextCapacity];
            for (int i = 0; i < buckets.Length; i++)
            {
                var e = buckets[i];
                while (e != null)
                {
                    AddToBuckets(nextBucket, key, e.Value, e.Hash);
                    e = e.Next;
                }
            }

            buckets = nextBucket;
            goto TRY_ADD_AGAIN;
        }
        else
        {
            // add entry
            var successAdd = AddToBuckets(buckets, key, value, keyEqualityComparer.GetHashCode(key));
            if (successAdd) size++;
            return successAdd;
        }
    }

    bool AddToBuckets(Entry[] targetBuckets, TKey newKey, TValue value, int keyHash)
    {
        var h = keyHash;
        var hashIndex = h & (targetBuckets.Length - 1);

    TRY_ADD_AGAIN:
        if (targetBuckets[hashIndex] == null)
        {
            targetBuckets[hashIndex] = new Entry
            {
                Key = new WeakReference<TKey>(newKey, false),
                Value = value,
                Hash = h
            };

            return true;
        }
        else
        {
            // add to last.
            var entry = targetBuckets[hashIndex];
            while (entry != null)
            {
                if (entry.Key.TryGetTarget(out var target))
                {
                    if (keyEqualityComparer.Equals(newKey, target))
                    {
                        return false; // duplicate
                    }
                }
                else
                {
                    Remove(hashIndex, entry);
                    if (targetBuckets[hashIndex] == null) goto TRY_ADD_AGAIN; // add new entry
                }

                if (entry.Next != null)
                {
                    entry = entry.Next;
                }
                else
                {
                    // found last
                    entry.Next = new Entry
                    {
                        Key = new WeakReference<TKey>(newKey, false),
                        Value = value,
                        Hash = h
                    };
                    entry.Next.Prev = entry;
                }
            }

            return false;
        }
    }

    bool TryGetEntry(TKey key, out int hashIndex, out Entry entry)
    {
        var table = buckets;
        var hash = keyEqualityComparer.GetHashCode(key);
        hashIndex = hash & table.Length - 1;
        entry = table[hashIndex];

        while (entry != null)
        {
            if (entry.Key.TryGetTarget(out var target))
            {
                if (keyEqualityComparer.Equals(key, target))
                {
                    return true;
                }
            }
            else
            {
                // sweap
                Remove(hashIndex, entry);
            }

            entry = entry.Next;
        }

        return false;
    }

    void Remove(int hashIndex, Entry entry)
    {
        if (entry.Prev == null && entry.Next == null)
        {
            buckets[hashIndex] = null;
        }
        else
        {
            if (entry.Prev == null)
            {
                buckets[hashIndex] = entry.Next;
            }
            if (entry.Prev != null)
            {
                entry.Prev.Next = entry.Next;
            }
            if (entry.Next != null)
            {
                entry.Next.Prev = entry.Prev;
            }
        }
        size--;
    }

    // avoid allocate everytime.
    public int CaptureSnapshot(ref List<TValue> list, bool clear = true)
    {
        if (clear)
        {
            list.Clear();
        }

        var listIndex = 0;

        bool lockTaken = false;
        try
        {
            for (int i = 0; i < buckets.Length; i++)
            {
                var entry = buckets[i];
                while (entry != null)
                {
                    if (entry.Key.TryGetTarget(out var target))
                    {
                        var item = entry.Value;
                        if (listIndex < list.Count)
                        {
                            list[listIndex++] = item;
                        }
                        else
                        {
                            list.Add(item);
                            listIndex++;
                        }
                    }
                    else
                    {
                        // sweap
                        Remove(i, entry);
                    }

                    entry = entry.Next;
                }
            }
        }
        finally
        {
            if (lockTaken) gate.Exit(false);
        }

        return listIndex;
    }

    static int CalculateCapacity(int collectionSize, float loadFactor)
    {
        var size = (int)(((float)collectionSize) / loadFactor);

        size--;
        size |= size >> 1;
        size |= size >> 2;
        size |= size >> 4;
        size |= size >> 8;
        size |= size >> 16;
        size += 1;

        if (size < 8)
        {
            size = 8;
        }
        return size;
    }

    class Entry
    {
        public WeakReference<TKey> Key;
        public TValue Value;
        public int Hash;
        public Entry Prev;
        public Entry Next;

        // debug only
        public override string ToString()
        {
            if (Key.TryGetTarget(out var target))
            {
                return target + "(" + Count() + ")";
            }
            else
            {
                return "(Dead)";
            }
        }

        int Count()
        {
            var count = 1;
            var n = this;
            while (n.Next != null)
            {
                count++;
                n = n.Next;
            }
            return count;
        }
    }
}



================================================
FILE: src/R3/Internal/Shims/CancellationTokenExtensions.cs
================================================
﻿#if NETSTANDARD2_0 || NETSTANDARD2_1

namespace System.Threading;

internal static class CancellationTokenExtensions
{
    public static CancellationTokenRegistration UnsafeRegister(this CancellationToken cancellationToken, Action<object?> callback, object? state)
    {
        return cancellationToken.Register(callback, state, useSynchronizationContext: false);
    }
}

#endif



================================================
FILE: src/R3/Internal/Shims/CollectionsMarshal.cs
================================================
﻿using System.Runtime.CompilerServices;

#if !NET6_0_OR_GREATER
namespace System.Runtime.InteropServices;

internal static class CollectionsMarshal
{
#pragma warning disable CS8618
#pragma warning disable CS0169
#pragma warning disable CS0649

    class ListDummy<T>
    {
        public T[] Items;
        int size;
        int version;
    }

    internal static Span<T> AsSpan<T>(List<T> list)
    {
        return Unsafe.As<ListDummy<T>>(list).Items.AsSpan(0, list.Count);
    }
}
#endif



================================================
FILE: src/R3/Internal/Shims/EnumerableExtensions.cs
================================================
﻿#if NETSTANDARD2_0 || NETSTANDARD2_1

namespace R3.Internal;

internal static class EnumerableExtensions
{
    internal static bool TryGetNonEnumeratedCount<T>(this IEnumerable<T> source, out int count)
    {
        if (source is ICollection<T> collection)
        {
            count = collection.Count;
            return true;
        }
        if (source is IReadOnlyCollection<T> readOnlyCollection)
        {
            count = readOnlyCollection.Count;
            return true;
        }
        count = 0;
        return false;
    }
}

#endif



================================================
FILE: src/R3/Internal/Shims/QueueExtensions.cs
================================================
﻿#if NETSTANDARD2_0

namespace R3.Internal;

internal static class QueueExtensions
{
    internal static bool TryDequeue<T>(this Queue<T> queue, out T value)
    {
        if (queue.Count == 0)
        {
            value = default!;
            return false;
        }
        else
        {
            value = queue.Dequeue();
            return true;
        }
    }

    internal static bool TryPeek<T>(this Queue<T> queue, out T value)
    {
        if (queue.Count == 0)
        {
            value = default!;
            return false;
        }
        else
        {
            value = queue.Peek();
            return true;
        }
    }
}

#endif



================================================
FILE: src/R3/Internal/Shims/StackTraceHidden.cs
================================================
﻿#if NETSTANDARD2_0 || NETSTANDARD2_1

namespace System.Diagnostics
{
    /// <summary>
    /// Types and Methods attributed with StackTraceHidden will be omitted from the stack trace text shown in StackTrace.ToString()
    /// and Exception.StackTrace
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Struct, Inherited = false)]
    internal sealed class StackTraceHiddenAttribute : Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StackTraceHiddenAttribute"/> class.
        /// </summary>
        public StackTraceHiddenAttribute() { }
    }
}

#endif



================================================
FILE: src/R3/Internal/Shims/TaskExtensions.cs
================================================
﻿#if NETSTANDARD2_0 || NETSTANDARD2_1

namespace R3;

internal static class TaskExtensions
{
    internal static Task<T> WaitAsync<T>(this Task<T> task, CancellationToken cancellationToken)
    {
        var tcs = new TaskCompletionSource<T>();
        var registration = cancellationToken.Register(() => tcs.TrySetCanceled(cancellationToken));

        task.ContinueWith(t =>
        {
            registration.Dispose();
            if (t.IsFaulted)
            {
                tcs.TrySetException(t.Exception!.InnerExceptions);
            }
            else if (t.IsCanceled)
            {
                tcs.TrySetCanceled(cancellationToken);
            }
            else
            {
                tcs.TrySetResult(t.Result);
            }
        }, TaskScheduler.Default);

        return tcs.Task;
    }
}

#endif



================================================
FILE: src/R3/Internal/Shims/ThreadPool.cs
================================================
﻿#if NETSTANDARD2_0 || NETSTANDARD2_1

namespace R3 // namespace priority
{
    public interface IThreadPoolWorkItem
    {
        void Execute();
    }

    public static class ThreadPool
    {
        static readonly WaitCallback waitCallback = Execute;

        public static bool UnsafeQueueUserWorkItem(IThreadPoolWorkItem callBack, bool preferLocal)
        {
            return global::System.Threading.ThreadPool.UnsafeQueueUserWorkItem(waitCallback, callBack);
        }

        static void Execute(object? state)
        {
            var workItem = (IThreadPoolWorkItem)state!;
            workItem.Execute();
        }
    }
}

#endif



================================================
FILE: src/R3/Operators/AggregateAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T> AggregateAsync<T>(
        this Observable<T> source,
        Func<T, T, T> func,
        CancellationToken cancellationToken = default)
    {
        var observer = new AggregateAsync<T>(func, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task<TResult> AggregateAsync<T, TResult>(
        this Observable<T> source,
        TResult seed,
        Func<TResult, T, TResult> func,
        CancellationToken cancellationToken = default)
    {
        var observer = new AggregateAsync<T, TResult>(seed, func, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task<TResult> AggregateAsync<T, TAccumulate, TResult>
    (this Observable<T> source,
        TAccumulate seed,
        Func<TAccumulate, T, TAccumulate> func,
        Func<TAccumulate, TResult> resultSelector,
        CancellationToken cancellationToken = default)
    {
        var observer = new AggregateAsync<T, TAccumulate, TResult>(seed, func, resultSelector, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class AggregateAsync<T>(
    Func<T, T, T> func,
    CancellationToken cancellationToken)
    : TaskObserverBase<T, T>(cancellationToken)
{
    T currentResult = default!;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (hasValue)
        {
            currentResult = func(currentResult, value); // OnNext error is route to OnErrorResumeCore
        }
        else
        {
            currentResult = value;
            hasValue = true;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(currentResult);
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}

internal sealed class AggregateAsync<T, TResult>(
    TResult seed,
    Func<TResult, T, TResult> func,
    CancellationToken cancellationToken)
    : TaskObserverBase<T, TResult>(cancellationToken)
{
    TResult currentValue = seed;

    protected override void OnNextCore(T value)
    {
        currentValue = func(currentValue, value); // OnNext error is route to OnErrorResumeCore
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(currentValue);
    }
}

internal sealed class AggregateAsync<T, TAccumulate, TResult>(
    TAccumulate seed,
    Func<TAccumulate, T, TAccumulate> func,
    Func<TAccumulate, TResult> resultSelector,
    CancellationToken cancellationToken)
    : TaskObserverBase<T, TResult>(cancellationToken)
{
    TAccumulate value = seed;

    protected override void OnNextCore(T value)
    {
        this.value = func(this.value, value); // OnNext error is route to OnErrorResumeCore
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        try
        {
            var v = resultSelector(value); // trap this resultSelector exception
            TrySetResult(v);
        }
        catch (Exception ex)
        {
            TrySetException(ex);
        }
    }
}



================================================
FILE: src/R3/Operators/AggregateByAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>> AggregateByAsync<TSource, TKey, TAccumulate>(
        this Observable<TSource> source,
        Func<TSource, TKey> keySelector,
        TAccumulate seed,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer = null,
        CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var observer = new AggregateByAsync<TSource, TKey, TAccumulate>(keySelector, seed, func, keyComparer, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task<IEnumerable<KeyValuePair<TKey, TAccumulate>>> AggregateByAsync<TSource, TKey, TAccumulate>(
        this Observable<TSource> source,
        Func<TSource, TKey> keySelector,
        Func<TKey, TAccumulate> seedSelector,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer = null,
        CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var observer = new AggregateByAsyncSeedSelector<TSource, TKey, TAccumulate>(keySelector, seedSelector, func, keyComparer, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class AggregateByAsync<TSource, TKey, TAccumulate>(
    Func<TSource, TKey> keySelector,
    TAccumulate seed,
    Func<TAccumulate, TSource, TAccumulate> func,
    IEqualityComparer<TKey>? keyComparer,
    CancellationToken cancellationToken)
    : TaskObserverBase<TSource, IEnumerable<KeyValuePair<TKey, TAccumulate>>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, TAccumulate> dictionary = new(keyComparer);

    protected override void OnNextCore(TSource value)
    {
        var key = keySelector(value);
        if (!dictionary.TryGetValue(key, out var currentAccumulate))
        {
            currentAccumulate = seed;
        }
        dictionary[key] = func(currentAccumulate, value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(dictionary);
    }
}

internal sealed class AggregateByAsyncSeedSelector<TSource, TKey, TAccumulate>(
    Func<TSource, TKey> keySelector,
    Func<TKey, TAccumulate> seedSelector,
    Func<TAccumulate, TSource, TAccumulate> func,
    IEqualityComparer<TKey>? keyComparer,
    CancellationToken cancellationToken)
    : TaskObserverBase<TSource, IEnumerable<KeyValuePair<TKey, TAccumulate>>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, TAccumulate> dictionary = new(keyComparer);

    protected override void OnNextCore(TSource value)
    {
        var key = keySelector(value);
        if (!dictionary.TryGetValue(key, out var currentAccumulate))
        {
            currentAccumulate = seedSelector(key);
        }
        dictionary[key] = func(currentAccumulate, value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(dictionary);
    }
}




================================================
FILE: src/R3/Operators/AllAnyIsEmptyAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<bool> AllAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default)
    {
        var observer = new AllAsync<T>(predicate, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task<bool> AnyAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        return AnyAsync<T>(source, static x => true, cancellationToken);
    }

    public static Task<bool> AnyAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default)
    {
        var observer = new AnyAsync<T>(predicate, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task<bool> IsEmptyAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var observer = new IsEmptyAsync<T>(cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class AllAsync<T>(Func<T, bool> predicate, CancellationToken cancellationToken)
: TaskObserverBase<T, bool>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
        if (!predicate(value))
        {
            TrySetResult(false);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(true);
    }
}

// AnyAsync
internal sealed class AnyAsync<T>(Func<T, bool> predicate, CancellationToken cancellationToken)
    : TaskObserverBase<T, bool>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
        if (predicate(value))
        {
            TrySetResult(true);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(false);
    }
}

// IsEmptyAsync
internal sealed class IsEmptyAsync<T>(CancellationToken cancellationToken)
    : TaskObserverBase<T, bool>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
        TrySetResult(false);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(true);
    }
}



================================================
FILE: src/R3/Operators/AppendPrepend.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Append<T>(this Observable<T> source, T value)
    {
        return new AppendPrepend<T>(source, value, append: true);
    }

    public static Observable<T> Append<T>(this Observable<T> source, IEnumerable<T> values)
    {
        return new AppendPrependEnumerable<T>(source, values, append: true);
    }

    public static Observable<T> Append<T>(this Observable<T> source, Func<T> valueFactory)
    {
        return new AppendPrependFactory<T>(source, valueFactory, append: true);
    }

    public static Observable<T> Append<T, TState>(this Observable<T> source, TState state, Func<TState, T> valueFactory)
    {
        return new AppendPrependFactory<T, TState>(source, state, valueFactory, append: true);
    }

    public static Observable<T> Prepend<T>(this Observable<T> source, T value)
    {
        return new AppendPrepend<T>(source, value, append: false);
    }

    public static Observable<T> Prepend<T>(this Observable<T> source, IEnumerable<T> values)
    {
        return new AppendPrependEnumerable<T>(source, values, append: false);
    }

    public static Observable<T> Prepend<T>(this Observable<T> source, Func<T> valueFactory)
    {
        return new AppendPrependFactory<T>(source, valueFactory, append: false);
    }

    public static Observable<T> Prepend<T, TState>(this Observable<T> source, TState state, Func<TState, T> valueFactory)
    {
        return new AppendPrependFactory<T, TState>(source, state, valueFactory, append: false);
    }
}

internal sealed class AppendPrepend<T>(Observable<T> source, T value, bool append) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        if (!append) // prepend
        {
            observer.OnNext(value);
            return source.Subscribe(observer.Wrap());
        }

        return source.Subscribe(new _Append(observer, value));
    }

    sealed class _Append(Observer<T> observer, T value) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
            }
            else
            {
                observer.OnNext(value);
                observer.OnCompleted();
            }
        }
    }
}

internal sealed class AppendPrependEnumerable<T>(Observable<T> source, IEnumerable<T> values, bool append) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        if (!append) // prepend
        {
            if (values is T[] array)
            {
                foreach (var value in array)
                {
                    observer.OnNext(value);
                }
            }
            else
            {
                foreach (var value in values)
                {
                    observer.OnNext(value);
                }
            }

            return source.Subscribe(observer.Wrap());
        }

        return source.Subscribe(new _Append(observer, values));
    }

    sealed class _Append(Observer<T> observer, IEnumerable<T> values) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
            }
            else
            {
                if (values is T[] array)
                {
                    foreach (var value in array)
                    {
                        observer.OnNext(value);
                    }
                }
                else
                {
                    foreach (var value in values)
                    {
                        observer.OnNext(value);
                    }
                }

                observer.OnCompleted();
            }
        }
    }
}

internal sealed class AppendPrependFactory<T>(Observable<T> source, Func<T> valueFactory, bool append) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        if (!append) // prepend
        {
            observer.OnNext(valueFactory());
            return source.Subscribe(observer.Wrap());
        }

        return source.Subscribe(new _Append(observer, valueFactory));
    }

    sealed class _Append(Observer<T> observer, Func<T> valueFactory) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
            }
            else
            {
                observer.OnNext(valueFactory());
                observer.OnCompleted();
            }
        }
    }
}

internal sealed class AppendPrependFactory<T, TState>(Observable<T> source, TState state, Func<TState, T> valueFactory, bool append) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        if (!append) // prepend
        {
            observer.OnNext(valueFactory(state));
            return source.Subscribe(observer.Wrap());
        }

        return source.Subscribe(new _Append(observer, state, valueFactory));
    }

    sealed class _Append(Observer<T> observer, TState state, Func<TState, T> valueFactory) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
            }
            else
            {
                observer.OnNext(valueFactory(state));
                observer.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/AsObservable.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> AsObservable<T>(this Observable<T> source)
    {
        if (source is AsObservable<T>) // already hide
        {
            return source;
        }

        return new AsObservable<T>(source);
    }

    public static IObservable<T> AsSystemObservable<T>(this Observable<T> source)
    {
        return new AsSystemObservable<T>(source);
    }
}

internal sealed class AsObservable<T>(Observable<T> observable) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return observable.Subscribe(observer.Wrap());
    }
}

internal sealed class AsSystemObservable<T>(Observable<T> source) : IObservable<T>
{
    public IDisposable Subscribe(IObserver<T> observer)
    {
        return source.Subscribe(new ObserverToObserver(observer));
    }

    sealed class ObserverToObserver(IObserver<T> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnError(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnError(result.Exception);
            }
            else
            {
                observer.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/AsUnitObservable.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<Unit> AsUnitObservable<T>(this Observable<T> source)
    {
        if (source is Observable<Unit> unit)
        {
            return unit;
        }

        return new AsUnitObservable<T>(source);
    }
}

internal sealed class AsUnitObservable<T>(Observable<T> source) : Observable<Unit>
{
    protected override IDisposable SubscribeCore(Observer<Unit> observer)
    {
        return source.Subscribe(new _AsUnitObservable(observer));
    }

    sealed class _AsUnitObservable(Observer<Unit> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(default);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}




================================================
FILE: src/R3/Operators/AverageAsync.cs
================================================

using System.Numerics;

namespace R3;

public static partial class ObservableExtensions
{
    public static Task<double> AverageAsync(this Observable<int> source, CancellationToken cancellationToken = default)
    {
        var method = new AverageInt32Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, int> selector, CancellationToken cancellationToken = default)
    {
        var method = new AverageInt32Async<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync(this Observable<long> source, CancellationToken cancellationToken = default)
    {
        var method = new AverageInt64Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, long> selector, CancellationToken cancellationToken = default)
    {
        var method = new AverageInt64Async<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync(this Observable<float> source, CancellationToken cancellationToken = default)
    {
        var method = new AverageFloatAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, float> selector, CancellationToken cancellationToken = default)
    {
        var method = new AverageFloatAsync<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync(this Observable<double> source, CancellationToken cancellationToken = default)
    {
        var method = new AverageDoubleAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, double> selector, CancellationToken cancellationToken = default)
    {
        var method = new AverageDoubleAsync<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync(this Observable<decimal> source, CancellationToken cancellationToken = default)
    {
        var method = new AverageDecimalAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, decimal> selector, CancellationToken cancellationToken = default)
    {
        var method = new AverageDecimalAsync<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

#if NET8_0_OR_GREATER
    public static Task<double> AverageAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
        where T : INumberBase<T>
    {
        var method = new AverageNumberAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
        where TResult : INumberBase<TResult>
    {
        var method = new AverageNumberAsync<TSource, TResult>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
#endif
}

internal sealed class AverageInt32Async(CancellationToken cancellationToken) : TaskObserverBase<int, double>(cancellationToken)
{
    int sum;
    int count;

    protected override void OnNextCore(int value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}

internal sealed class AverageInt32Async<TSource>(Func<TSource, int> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    int sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}
internal sealed class AverageInt64Async(CancellationToken cancellationToken) : TaskObserverBase<long, double>(cancellationToken)
{
    long sum;
    int count;

    protected override void OnNextCore(long value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}

internal sealed class AverageInt64Async<TSource>(Func<TSource, long> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    long sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}
internal sealed class AverageFloatAsync(CancellationToken cancellationToken) : TaskObserverBase<float, double>(cancellationToken)
{
    float sum;
    int count;

    protected override void OnNextCore(float value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}

internal sealed class AverageFloatAsync<TSource>(Func<TSource, float> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    float sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}
internal sealed class AverageDoubleAsync(CancellationToken cancellationToken) : TaskObserverBase<double, double>(cancellationToken)
{
    double sum;
    int count;

    protected override void OnNextCore(double value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(sum / count);
    }
}

internal sealed class AverageDoubleAsync<TSource>(Func<TSource, double> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    double sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(sum / count);
    }
}
internal sealed class AverageDecimalAsync(CancellationToken cancellationToken) : TaskObserverBase<decimal, double>(cancellationToken)
{
    decimal sum;
    int count;

    protected override void OnNextCore(decimal value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}

internal sealed class AverageDecimalAsync<TSource>(Func<TSource, decimal> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    decimal sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        TrySetResult(checked((double)sum) / count);
    }
}

#if NET8_0_OR_GREATER
internal sealed class AverageNumberAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, double>(cancellationToken)
    where T : INumberBase<T>
{
    T sum = T.Zero;
    int count;

    protected override void OnNextCore(T value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        double numerator;
        try
        {
            numerator = double.CreateChecked(sum);
        }
        catch (Exception ex)
        {
            TrySetException(ex);
            return;
        }
        TrySetResult(numerator / count);
    }
}

internal sealed class AverageNumberAsync<TSource, TResult>(Func<TSource, TResult> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
    where TResult : INumberBase<TResult>
{
    TResult sum = TResult.Zero;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum = sum + selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        double numerator;
        try
        {
            numerator = double.CreateChecked(sum);
        }
        catch (Exception ex)
        {
            TrySetException(ex);
            return;
        }

        TrySetResult(numerator / count);
    }
}
#endif



================================================
FILE: src/R3/Operators/AverageAsync.tt
================================================
<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var typeNames = new[]
    {
        ("int", "Int32"),
        ("long", "Int64"),
        ("float", "Float"),
        ("double", "Double"),
        ("decimal", "Decimal")
    };
#>

using System.Numerics;

namespace R3;

public static partial class ObservableExtensions
{
<# foreach (var (t, typeSuffix) in typeNames) { #>
    public static Task<double> AverageAsync(this Observable<<#= t #>> source, CancellationToken cancellationToken = default)
    {
        var method = new Average<#= typeSuffix #>Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<T>(this Observable<T> source, Func<T, <#= t #>> selector, CancellationToken cancellationToken = default)
    {
        var method = new Average<#= typeSuffix #>Async<T>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

<# } #>
#if NET8_0_OR_GREATER
    public static Task<double> AverageAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
        where T : INumberBase<T>
    {
        var method = new AverageNumberAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> AverageAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
        where TResult : INumberBase<TResult>
    {
        var method = new AverageNumberAsync<TSource, TResult>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
#endif
}

<# foreach (var (t, typeSuffix) in typeNames) { #>
internal sealed class Average<#= typeSuffix #>Async(CancellationToken cancellationToken) : TaskObserverBase<<#= t #>, double>(cancellationToken)
{
    <#= t #> sum;
    int count;

    protected override void OnNextCore(<#= t #> value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

<# if (t == "double") { #>
        TrySetResult(sum / count);
<# } else { #>
        TrySetResult(checked((double)sum) / count);
<# } #>
    }
}

internal sealed class Average<#= typeSuffix #>Async<TSource>(Func<TSource, <#= t #>> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    <#= t #> sum;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum += selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

<# if (t == "double") { #>
        TrySetResult(sum / count);
<# } else { #>
        TrySetResult(checked((double)sum) / count);
<# } #>
    }
}
<# } #>

#if NET8_0_OR_GREATER
internal sealed class AverageNumberAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, double>(cancellationToken)
    where T : INumberBase<T>
{
    T sum = T.Zero;
    int count;

    protected override void OnNextCore(T value)
    {
        sum += value;
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        double numerator;
        try
        {
            numerator = double.CreateChecked(sum);
        }
        catch (Exception ex)
        {
            TrySetException(ex);
            return;
        }
        TrySetResult(numerator / count);
    }
}

internal sealed class AverageNumberAsync<TSource, TResult>(Func<TSource, TResult> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
    where TResult : INumberBase<TResult>
{
    TResult sum = TResult.Zero;
    int count;

    protected override void OnNextCore(TSource value)
    {
        sum = sum + selector(value);
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (count <= 0)
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
            return;
        }

        double numerator;
        try
        {
            numerator = double.CreateChecked(sum);
        }
        catch (Exception ex)
        {
            TrySetException(ex);
            return;
        }

        TrySetResult(numerator / count);
    }
}
#endif



================================================
FILE: src/R3/Operators/Cast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> Cast<T, TResult>(this Observable<T> source)
    {
        return new Cast<T, TResult>(source);
    }
}

internal sealed class Cast<T, TResult>(Observable<T> source) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _Cast(observer));
    }

    sealed class _Cast(Observer<TResult> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            var v = (TResult?)(object?)value;
            observer.OnNext(v!);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}




================================================
FILE: src/R3/Operators/Catch.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Catch<T>(this Observable<T> source, Observable<T> second)
    {
        return new Catch<T>(source, second);
    }

    public static Observable<T> Catch<T, TException>(this Observable<T> source, Func<TException, Observable<T>> errorHandler)
    {
        return new Catch<T, TException>(source, errorHandler);
    }
}

internal sealed class Catch<T>(Observable<T> source, Observable<T> second) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _Catch(observer, second).Run(source);
    }

    sealed class _Catch(Observer<T> observer, Observable<T> second) : IDisposable
    {
        readonly Observer<T> observer = observer;
        readonly Observable<T> second = second;
        SingleAssignmentDisposableCore firstSubscription;
        SingleAssignmentDisposableCore secondSubscription;

        public IDisposable Run(Observable<T> source)
        {
            return source.Subscribe(new FirstObserver(this));
        }

        public void Dispose()
        {
            firstSubscription.Dispose();
            secondSubscription.Dispose();
        }

        internal sealed class FirstObserver(_Catch parent) : Observer<T>
        {
            protected override void OnNextCore(T value)
            {
                parent.observer.OnNext(value);
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                if (result.IsFailure)
                {
                    parent.secondSubscription.Disposable = parent.second.Subscribe(new SecondObserver(parent));
                }
                else
                {
                    parent.observer.OnCompleted(result);
                }
            }
        }

        internal sealed class SecondObserver(_Catch parent) : Observer<T>
        {
            protected override void OnNextCore(T value)
            {
                parent.observer.OnNext(value);
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.observer.OnCompleted(result);
            }

            protected override void DisposeCore()
            {
                parent.Dispose();
            }
        }
    }
}

internal sealed class Catch<T, TException>(Observable<T> source, Func<TException, Observable<T>> errorHandler) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _Catch(observer, errorHandler).Run(source);
    }

    sealed class _Catch(Observer<T> observer, Func<TException, Observable<T>> errorHandler) : IDisposable
    {
        readonly Observer<T> observer = observer;
        readonly Func<TException, Observable<T>> errorHandler = errorHandler;
        SingleAssignmentDisposableCore firstSubscription;
        SingleAssignmentDisposableCore secondSubscription;

        public IDisposable Run(Observable<T> source)
        {
            return source.Subscribe(new FirstObserver(this));
        }

        public void Dispose()
        {
            firstSubscription.Dispose();
            secondSubscription.Dispose();
        }

        internal sealed class FirstObserver(_Catch parent) : Observer<T>
        {
            protected override void OnNextCore(T value)
            {
                parent.observer.OnNext(value);
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                if (result.IsFailure && result.Exception is TException error)
                {
                    parent.secondSubscription.Disposable = parent.errorHandler(error).Subscribe(new SecondObserver(parent));
                }
                else
                {
                    parent.observer.OnCompleted(result);
                }
            }
        }

        internal sealed class SecondObserver(_Catch parent) : Observer<T>
        {
            protected override void OnNextCore(T value)
            {
                parent.observer.OnNext(value);
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.observer.OnCompleted(result);
            }

            protected override void DisposeCore()
            {
                parent.Dispose();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Chunk.cs
================================================
﻿using System;

namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T[]> Chunk<T>(this Observable<T> source, int count)
    {
        if (count <= 0) throw new ArgumentOutOfRangeException("count <= 0");
        return new Chunk<T>(source, count);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, int count, int skip)
    {
        if (count <= 0) throw new ArgumentOutOfRangeException("count <= 0");
        if (skip <= 0) return Chunk(source, count);
        return new ChunkCountSkip<T>(source, count, skip);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, TimeSpan timeSpan)
    {
        return Chunk(source, timeSpan, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider)
    {
        return new ChunkTime<T>(source, timeSpan.Normalize(), timeProvider);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, TimeSpan timeSpan, int count)
    {
        return Chunk(source, timeSpan, count, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, TimeSpan timeSpan, int count, TimeProvider timeProvider)
    {
        return new ChunkTimeCount<T>(source, timeSpan.Normalize(), count, timeProvider);
    }

    public static Observable<TSource[]> Chunk<TSource, TWindowBoundary>(this Observable<TSource> source, Observable<TWindowBoundary> windowBoundaries)
    {
        return new ChunkWindow<TSource, TWindowBoundary>(source, windowBoundaries);
    }

    public static Observable<T[]> Chunk<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> asyncWindow, bool configureAwait = true)
    {
        return new ChunkAsync<T>(source, asyncWindow, configureAwait);
    }
}

// Count
internal sealed class Chunk<T>(Observable<T> source, int count) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, count));
    }

    sealed class _Chunk(Observer<T[]> observer, int count) : Observer<T>
    {
        T[] buffer = new T[count];
        int index;

        protected override void OnNextCore(T value)
        {
            buffer[index++] = value;
            if (index == count)
            {
                index = 0;
                observer.OnNext(buffer);
                buffer = new T[count];
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (index > 0)
            {
                observer.OnNext(buffer.AsSpan(0, index).ToArray());
            }

            observer.OnCompleted(result);
        }
    }
}

// count + skip
internal sealed class ChunkCountSkip<T>(Observable<T> source, int count, int skip) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, count, skip));
    }

    sealed class _Chunk(Observer<T[]> observer, int count, int skip) : Observer<T>
    {
        Queue<(int, T[])> q = new();
        int queueIndex = -1; // start is -1.

        protected override void OnNextCore(T value)
        {
            queueIndex++;

            if (queueIndex % skip == 0)
            {
                q.Enqueue((0, new T[count]));
            }

            var len = q.Count;
            for (int i = 0; i < len; i++)
            {
                var (index, array) = q.Dequeue();
                array[index] = value;
                index++;
                if (index == count)
                {
                    observer.OnNext(array);
                }
                else
                {
                    q.Enqueue((index, array));
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            foreach (var (index, array) in q)
            {
                observer.OnNext(array.AsSpan(0, index).ToArray());
            }
            q.Clear();

            observer.OnCompleted(result);
        }
    }
}

// Time
internal sealed class ChunkTime<T>(Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, timeSpan, timeProvider));
    }

    sealed class _Chunk : Observer<T>
    {
        static readonly TimerCallback timerCallback = TimerCallback;

        readonly Observer<T[]> observer;
        readonly List<T> list; // lock gate
        readonly TimeProvider timeProvider;
        readonly TimeSpan timeSpan;
        ITimer? timer;

        public _Chunk(Observer<T[]> observer, TimeSpan timeSpan, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeSpan = timeSpan;
            this.timeProvider = timeProvider;
            this.list = new List<T>();
        }

        protected override void OnNextCore(T value)
        {
            lock (list)
            {
                list.Add(value);
                if (timer == null)
                {
                    this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
                    this.timer.InvokeOnce(timeSpan);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (list)
            {
                if (list.Count > 0)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                }
            }
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            lock (list)
            {
                timer?.Dispose();
            }
        }

        static void TimerCallback(object? state)
        {
            var self = (_Chunk)state!;
            lock (self.list)
            {
                if (self.list.Count == 0)
                {
                    self.observer.OnNext(Array.Empty<T>());
                }
                else
                {
                    self.observer.OnNext(self.list.ToArray());
                    self.list.Clear();
                }
                self.timer = null;
            }
        }
    }
}

// Time + Count
internal sealed class ChunkTimeCount<T>(Observable<T> source, TimeSpan timeSpan, int count, TimeProvider timeProvider) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, timeSpan, count, timeProvider));
    }

    sealed class _Chunk : Observer<T>
    {
        static readonly TimerCallback timerCallback = TimerCallback;

        readonly Observer<T[]> observer;
        readonly int count;
        readonly TimeSpan timeSpan;
        readonly TimeProvider timeProvider;
        readonly object gate = new object();
        ITimer? timer;
        T[] buffer;
        int index;
        int timerId;

        public _Chunk(Observer<T[]> observer, TimeSpan timeSpan, int count, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.count = count;
            this.timeSpan = timeSpan;
            this.timeProvider = timeProvider;
            this.buffer = new T[count];
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                buffer[index++] = value;
                if (index == count)
                {
                    timer?.Stop(); // stop timer for restart
                    timer = null;

                    try
                    {
                        index = 0;
                        observer.OnNext(buffer);
                        buffer = new T[count];
                    }
                    finally
                    {
                        // increment timerId for restart
                        timerId = unchecked(timerId += 1);
                    }
                }
                else
                {
                    if (timer == null)
                    {
                        timer = timeProvider.CreateStoppedTimer(timerCallback, this);
                        timer.InvokeOnce(timeSpan);
                    }
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (index > 0)
                {
                    observer.OnNext(buffer.AsSpan(0, index).ToArray());
                }
            }
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer?.Dispose();
        }

        static void TimerCallback(object? state)
        {
            var self = (_Chunk)state!;
            var id = Volatile.Read(ref self.timerId);
            lock (self.gate)
            {
                if (Volatile.Read(ref self.timerId) != id) return; // check timer restarted

                if (self.index == 0)
                {
                    self.observer.OnNext(Array.Empty<T>());
                }
                else
                {
                    var span = self.buffer.AsSpan(0, self.index);
                    self.observer.OnNext(span.ToArray());
                    // reuse buffer
                    span.Clear();
                    self.index = 0;
                }
                self.timer = null;
            }
        }
    }
}

// Window
internal sealed class ChunkWindow<T, TWindowBoundary>(Observable<T> source, Observable<TWindowBoundary> windowBoundaries) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return new _Chunk(observer).Run(source, windowBoundaries);
    }

    sealed class _Chunk(Observer<T[]> observer) : Observer<T>
    {
        readonly Observer<T[]> observer = observer;
        readonly List<T> list = new List<T>();
        IDisposable? windowSubscription;

        public IDisposable Run(Observable<T> source, Observable<TWindowBoundary> windowBoundaries)
        {
            this.windowSubscription = windowBoundaries.Subscribe(new WindowBoundaryObserver(this));
            try
            {
                return source.Subscribe(this);
            }
            catch
            {
                windowSubscription.Dispose();
                throw;
            }
        }

        protected override void OnNextCore(T value)
        {
            lock (list)
            {
                list.Add(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (list)
            {
                if (list.Count > 0)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                }
            }
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            windowSubscription?.Dispose();
        }

        sealed class WindowBoundaryObserver(_Chunk parent) : Observer<TWindowBoundary>
        {
            protected override void OnNextCore(TWindowBoundary _)
            {
                lock (parent.list)
                {
                    if (parent.list.Count == 0)
                    {
                        parent.observer.OnNext(Array.Empty<T>());
                    }
                    else
                    {
                        parent.observer.OnNext(parent.list.ToArray());
                        parent.list.Clear();
                    }
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.OnCompleted();
            }
        }
    }
}

// Async
internal sealed class ChunkAsync<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> asyncWindow, bool configureAwait) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, asyncWindow, configureAwait));
    }

    sealed class _Chunk(Observer<T[]> observer, Func<T, CancellationToken, ValueTask> asyncWindow, bool configureAwait) : Observer<T>
    {
        readonly List<T> list = new List<T>();
        CancellationTokenSource cancellationTokenSource = new();
        bool isRunning;

        protected override void OnNextCore(T value)
        {
            lock (list)
            {
                list.Add(value);
                if (!isRunning)
                {
                    isRunning = true;
                    StartWindow(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel();

            lock (list)
            {
                if (list.Count > 0)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                }
            }

            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void StartWindow(T value)
        {
            try
            {
                await asyncWindow(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }
                OnErrorResume(ex);
            }
            finally
            {
                lock (list)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                    isRunning = false;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ChunkFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T[]> ChunkFrame<T>(this Observable<T> source)
    {
        return ChunkFrame(source, 0, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T[]> ChunkFrame<T>(this Observable<T> source, int frameCount)
    {
        return ChunkFrame(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T[]> ChunkFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        // allow frameCount == 0
        if (frameCount < 0) throw new ArgumentOutOfRangeException("frameCount < 0");
        return new ChunkFrame<T>(source, frameCount.NormalizeFrame(), frameProvider);
    }

    public static Observable<T[]> ChunkFrame<T>(this Observable<T> source, int frameCount, int count)
    {
        return ChunkFrame(source, frameCount, count, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T[]> ChunkFrame<T>(this Observable<T> source, int frameCount, int count, FrameProvider frameProvider)
    {
        // allow frameCount == 0
        if (frameCount < 0) throw new ArgumentOutOfRangeException("frameCount < 0");
        return new ChunkFrameCount<T>(source, frameCount.NormalizeFrame(), count, frameProvider);
    }
}

internal sealed class ChunkFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, frameCount, frameProvider));
    }

    sealed class _Chunk : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T[]> observer;
        readonly List<T> list; // lock gate
        readonly FrameProvider frameProvider;
        readonly int periodFrame;
        int currentFrame;
        bool running;

        public _Chunk(Observer<T[]> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.periodFrame = frameCount;
            this.frameProvider = frameProvider;
            this.list = new List<T>();
        }

        protected override void OnNextCore(T value)
        {
            lock (list)
            {
                list.Add(value);
                if (!running)
                {
                    currentFrame = 0;
                    running = true;
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (list)
            {
                if (list.Count > 0)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                }
            }
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (list)
            {
                if (++currentFrame == periodFrame)
                {
                    observer.OnNext(list.ToArray());
                    list.Clear();
                    running = false;
                    return false;
                }
            }
            return true;
        }
    }
}

internal sealed class ChunkFrameCount<T>(Observable<T> source, int frameCount, int count, FrameProvider frameProvider) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _Chunk(observer, frameCount, count, frameProvider));
    }

    sealed class _Chunk : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T[]> observer;
        readonly int periodFrame;
        readonly int count;
        readonly object gate = new object();
        readonly FrameProvider frameProvider;
        bool running;
        T[] buffer;
        int index;
        int currentFrame;

        public _Chunk(Observer<T[]> observer, int frameCount, int count, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.periodFrame = frameCount;
            this.count = count;
            this.buffer = new T[count];
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                buffer[index++] = value;
                if (index == count)
                {
                    currentFrame = 0;

                    index = 0;
                    observer.OnNext(buffer);
                    buffer = new T[count];
                }
                else if (!running)
                {
                    currentFrame = 0;
                    running = true;
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (index > 0)
                {
                    observer.OnNext(buffer.AsSpan(0, index).ToArray());
                }
            }
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (index == 0) // stop when count buffer is published
                {
                    running = false;
                    return false;
                }

                if (++currentFrame == periodFrame)
                {
                    var span = buffer.AsSpan(0, index);
                    observer.OnNext(span.ToArray());
                    // reuse buffer
                    span.Clear();
                    index = 0;

                    running = false;
                    return false;
                }
            }
            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/ChunkUntil.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T[]> ChunkUntil<T>(this Observable<T> source, Func<T, bool> predicate)
    {
        return new ChunkUntil<T>(source, predicate);
    }

    public static Observable<T[]> ChunkUntil<T>(this Observable<T> source, Func<T, int, bool> predicate)
    {
        return new ChunkUntilI<T>(source, predicate);
    }
}

internal sealed class ChunkUntil<T>(Observable<T> source, Func<T, bool> predicate) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _ChunkUntil(observer, predicate));
    }

    sealed class _ChunkUntil(Observer<T[]> observer, Func<T, bool> predicate) : Observer<T>, IDisposable
    {
        readonly List<T> list = new List<T>();

        protected override void OnNextCore(T value)
        {
            list.Add(value);
            if (predicate(value))
            {
                var array = list.ToArray();
                list.Clear();
                observer.OnNext(array);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (list.Count > 0)
            {
                observer.OnNext(list.ToArray());
            }

            observer.OnCompleted(result);
        }
    }
}

internal sealed class ChunkUntilI<T>(Observable<T> source, Func<T, int, bool> predicate) : Observable<T[]>
{
    protected override IDisposable SubscribeCore(Observer<T[]> observer)
    {
        return source.Subscribe(new _ChunkUntil(observer, predicate));
    }

    sealed class _ChunkUntil(Observer<T[]> observer, Func<T, int, bool> predicate) : Observer<T>, IDisposable
    {
        int count;
        readonly List<T> list = new List<T>();

        protected override void OnNextCore(T value)
        {
            list.Add(value);
            if (predicate(value, count++))
            {
                var array = list.ToArray();
                list.Clear();
                observer.OnNext(array);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (list.Count > 0)
            {
                observer.OnNext(list.ToArray());
            }

            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/CombineLatest.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var GenerateTCount = 15;

    var generateT = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"T{i}").ToArray());
    var generateSources = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"source{i}").ToArray());
    var generateHasValue = (int x) => string.Join(" && ", Enumerable.Range(1, x).Select(i => $"observer{i}.HasValue").ToArray());
    var generateValue = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"observer{i}.Value!").ToArray());
#>

using System.Diagnostics.CodeAnalysis;

namespace R3;

public static partial class Observable
{
<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
    public static Observable<TResult> CombineLatest<<#= generateT(i) #>, TResult>(
        this
<# for (var j = 1; j <= i; j++ ) { #>
        Observable<T<#= j #>> source<#= j #>,
<# } #>
        Func<<#= generateT(i) #>, TResult> resultSelector)
    {
        return new CombineLatest<<#= generateT(i) #>, TResult>(<#= generateSources(i) #>, resultSelector);
    }

<# } #>
}

<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
internal sealed class CombineLatest<<#= generateT(i) #>, TResult>(
<# for (var j = 1; j <= i; j++ ) { #>
    Observable<T<#= j #>> source<#= j #>,
<# } #>
    Func<<#= generateT(i) #>, TResult> resultSelector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return new _CombineLatest(observer, <#= generateSources(i) #>, resultSelector).Run();
    }

    sealed class _CombineLatest : IDisposable
    {
        const int SourceCount = <#= i #>;

        readonly Observer<TResult> observer;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly Observable<T<#= j #>> source<#= j #>;
<# } #>
        readonly Func<<#= generateT(i) #>, TResult> resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly CombineLatestObserver<T<#= j #>> observer<#= j #>;
<# } #>        
        readonly object gate = new object();
        bool hasValueAll;
        int completedCount;

        public _CombineLatest(
            Observer<TResult> observer,
<# for (var j = 1; j <= i; j++ ) { #>
            Observable<T<#= j #>> source<#= j #>,
<# } #>
            Func<<#= generateT(i) #>, TResult> resultSelector)
        {
            this.observer = observer;
<# for (var j = 1; j <= i; j++ ) { #>
            this.source<#= j #> = source<#= j #>;
<# } #>
            this.resultSelector = resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
            this.observer<#= j #> = new CombineLatestObserver<T<#= j #>>(this);
<# } #>
        }

        public IDisposable Run()
        {
            try
            {
<# for (var j = 1; j <= i; j++ ) { #>
                source<#= j #>.Subscribe(observer<#= j #>);
<# } #>
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            if (!hasValueAll)
            {
                if (<#= generateHasValue(i) #>)
                {
                    hasValueAll = true;
                }
                else
                {
                    return;
                }
            }

            var result = resultSelector(<#= generateValue(i) #>);
            observer.OnNext(result);
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                completedCount += 1;
                if (empty || completedCount == SourceCount)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void Dispose()
        {
<# for (var j = 1; j <= i; j++ ) { #>
            observer<#= j #>.Dispose();
<# } #>
        }

        sealed class CombineLatestObserver<T>(_CombineLatest parent) : Observer<T>
        {
            public T? Value { get; private set; }

            [MemberNotNullWhen(true, nameof(Value))]
            public bool HasValue { get; private set; }

            protected override void OnNextCore(T value)
            {
                lock (parent.gate)
                {
                    this.Value = value;
                    this.HasValue = true;
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.gate)
                {
                    parent.TryPublishOnCompleted(result, !HasValue);
                }
            }
        }
    }
}

<# } #>



================================================
FILE: src/R3/Operators/Concat.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Concat<T>(this Observable<Observable<T>> sources)
    {
        return new ConcatMany<T>(sources);
    }
}

internal sealed class ConcatMany<T>(Observable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return sources.Subscribe(new _ConcatMany(observer));
    }

    sealed class _ConcatMany(Observer<T> observer) : Observer<Observable<T>>
    {
        readonly Observer<T> observer = observer;
        readonly object gate = new();
        readonly Queue<Observable<T>> q = new();

        SerialDisposableCore serialDisposable;
        bool isStopped;
        int activeCount;

        // keep when inner is running
        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(Observable<T> value)
        {
            lock (gate)
            {
                if (activeCount < 1)
                {
                    activeCount++;
                    serialDisposable.Disposable = value.Subscribe(new ConcatInner(this));
                }
                else
                {
                    q.Enqueue(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                PublishCompleted(result);
            }
            else
            {
                lock (gate)
                {
                    isStopped = true;
                    if (activeCount == 0)
                    {
                        PublishCompleted(result);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            serialDisposable.Dispose();
        }

        void PublishCompleted(Result result)
        {
            try
            {
                lock (gate)
                {
                    observer.OnCompleted(result);
                }
            }
            finally
            {
                Dispose();
            }
        }

        sealed class ConcatInner(_ConcatMany parent) : Observer<T>
        {
            // Manual disposing by SerialDisposableCore
            protected override bool AutoDisposeOnCompleted => false;

            protected override void OnNextCore(T value)
            {
                lock (parent.gate)
                {
                    parent.observer.OnNext(value);
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                lock (parent.gate)
                {
                    parent.observer.OnErrorResume(error);
                }
            }

            protected override void OnCompletedCore(Result result)
            {
                if (result.IsFailure)
                {
                    parent.OnCompleted();
                }
                else
                {
                    lock (parent.gate)
                    {
                        if (parent.q.Count > 0)
                        {
                            var nextSource = parent.q.Dequeue();
                            parent.serialDisposable.Disposable = nextSource.Subscribe(new ConcatInner(parent));
                        }
                        else
                        {
                            parent.activeCount--;
                            if (parent is { isStopped: true, activeCount: 0 })
                            {
                                parent.PublishCompleted(result);
                            }
                        }
                    }
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ContainsAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<bool> ContainsAsync<T>(this Observable<T> source, T value, CancellationToken cancellationToken = default)
    {
        return ContainsAsync(source, value, EqualityComparer<T>.Default, cancellationToken);
    }

    public static Task<bool> ContainsAsync<T>(this Observable<T> source, T value, IEqualityComparer<T> equalityComparer, CancellationToken cancellationToken = default)
    {
        var observer = new ContainsAsync<T>(value, equalityComparer, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class ContainsAsync<T>(T compareValue, IEqualityComparer<T> equalityComparer, CancellationToken cancellationToken)
: TaskObserverBase<T, bool>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
        if (equalityComparer.Equals(value, compareValue))
        {
            TrySetResult(true);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(false);
    }
}




================================================
FILE: src/R3/Operators/CountAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<int> CountAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new CountAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<int> CountAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default)
    {
        var method = new CountFilterAsync<T>(predicate, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<long> LongCountAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new LongCountAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<long> LongCountAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default)
    {
        var method = new LongCountFilterAsync<T>(predicate, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class CountAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, int>(cancellationToken)
{
    int count;

    protected override void OnNextCore(T _)
    {
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(count);
    }
}

internal sealed class CountFilterAsync<T>(Func<T, bool> predicate, CancellationToken cancellationToken) : TaskObserverBase<T, int>(cancellationToken)
{
    int count;

    protected override void OnNextCore(T value)
    {
        if (predicate(value))
        {
            count = checked(count + 1);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(count);
    }
}

internal sealed class LongCountAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, long>(cancellationToken)
{
    long count;

    protected override void OnNextCore(T _)
    {
        count = checked(count + 1);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(count);
    }
}

internal sealed class LongCountFilterAsync<T>(Func<T, bool> predicate, CancellationToken cancellationToken) : TaskObserverBase<T, long>(cancellationToken)
{
    long count;

    protected override void OnNextCore(T value)
    {
        if (predicate(value))
        {
            count = checked(count + 1);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(count);
    }
}



================================================
FILE: src/R3/Operators/Debounce.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Debounce<T>(this Observable<T> source, TimeSpan timeSpan)
    {
        return new Debounce<T>(source, timeSpan, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> Debounce<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider)
    {
        return new Debounce<T>(source, timeSpan, timeProvider);
    }

    public static Observable<T> Debounce<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> throttleDurationSelector, bool configureAwait = true)
    {
        return new DebounceSelector<T>(source, throttleDurationSelector, configureAwait);
    }
}

internal sealed class Debounce<T>(Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Debounce(observer, timeSpan.Normalize(), timeProvider));
    }

    sealed class _Debounce : Observer<T>
    {
        static readonly TimerCallback timerCallback = RaiseOnNext;

        readonly Observer<T> observer;
        readonly TimeSpan timeSpan;
        readonly ITimer timer;
        readonly object gate = new object();
        T? latestValue;
        bool hasvalue;
        int timerId;

        public _Debounce(Observer<T> observer, TimeSpan timeSpan, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeSpan = timeSpan;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                latestValue = value;
                hasvalue = true;
                Volatile.Write(ref timerId, unchecked(timerId + 1));
                timer.InvokeOnce(timeSpan); // restart timer
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (hasvalue)
                {
                    observer.OnNext(latestValue!);
                    hasvalue = false;
                    latestValue = default;
                }
                observer.OnCompleted(result);
            }
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void RaiseOnNext(object? state)
        {
            var self = (_Debounce)state!;

            var timerId = Volatile.Read(ref self.timerId);
            lock (self.gate)
            {
                if (timerId != self.timerId) return;
                if (!self.hasvalue) return;

                self.observer.OnNext(self.latestValue!);
                self.hasvalue = false;
                self.latestValue = default;
            }
        }
    }
}

internal sealed class DebounceSelector<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> throttleDurationSelector, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Debounce(observer, throttleDurationSelector, configureAwait));
    }

    sealed class _Debounce(Observer<T> observer, Func<T, CancellationToken, ValueTask> throttleDurationSelector, bool configureAwait) : Observer<T>
    {
        readonly object gate = new object();
        T? latestValue;
        bool hasValue;
        bool isRunning;
        int taskId;
        CancellationTokenSource cancellationTokenSource = new();

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                latestValue = value;
                hasValue = true;

                if (isRunning)
                {
                    cancellationTokenSource.Cancel();
                    cancellationTokenSource = new CancellationTokenSource();
                }

                var newId = unchecked(taskId + 1);
                Volatile.Write(ref taskId, newId);

                isRunning = true;
                PublishOnNextAfterAsync(value, newId, cancellationTokenSource.Token);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                cancellationTokenSource.Cancel(); // cancel executing async process first

                if (hasValue)
                {
                    observer.OnNext(latestValue!);
                    hasValue = false;
                    latestValue = default;
                }
                observer.OnCompleted(result);
            }
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void PublishOnNextAfterAsync(T value, int id, CancellationToken cancellationToken)
        {
            try
            {
                await throttleDurationSelector(value, cancellationToken).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationToken)
                {
                    return;
                }
                OnErrorResume(ex);
            }
            finally
            {
                lock (gate)
                {
                    if (this.taskId != id) goto END;
                    if (!hasValue) goto END;

                    observer.OnNext(latestValue!);
                    hasValue = false;
                    latestValue = default;
                    isRunning = false;

                END:
                    { }
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/DebounceFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> DebounceFrame<T>(this Observable<T> source, int frameCount)
    {
        return new DebounceFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> DebounceFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new DebounceFrame<T>(source, frameCount, frameProvider);
    }
}

// DebounceFrame
internal sealed class DebounceFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _DebounceFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _DebounceFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly int frameCount;
        readonly object gate = new object();
        readonly FrameProvider frameProvider;
        T? latestValue;
        bool hasvalue;
        int currentFrame;
        bool isRunning;

        public _DebounceFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                latestValue = value;
                hasvalue = true;
                currentFrame = 0;

                if (!isRunning)
                {
                    isRunning = true;
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (hasvalue)
                {
                    observer.OnNext(latestValue!);
                    hasvalue = false;
                    latestValue = default;
                }
            }
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (hasvalue)
                {
                    if (++currentFrame == frameCount)
                    {
                        observer.OnNext(latestValue!);
                        hasvalue = false;
                        latestValue = default;
                        currentFrame = 0;
                        isRunning = false;
                        return false;
                    }
                }
                else
                {
                    currentFrame = 0;
                    isRunning = false;
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/DefaultIfEmpty.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T?> DefaultIfEmpty<T>(this Observable<T> source)
    {
        return DefaultIfEmpty(source, default!);
    }

    public static Observable<T?> DefaultIfEmpty<T>(this Observable<T> source, T? defaultValue)
    {
        return new DefaultIfEmpty<T>(source, defaultValue);
    }
}

internal sealed class DefaultIfEmpty<T>(Observable<T> source, T? defaultValue) : Observable<T?>
{
    protected override IDisposable SubscribeCore(Observer<T?> observer)
    {
        return source.Subscribe(new _DefaultIfEmpty(observer, defaultValue));
    }

    sealed class _DefaultIfEmpty(Observer<T?> observer, T? defaultValue) : Observer<T>
    {
        bool hasValue;

        protected override void OnNextCore(T value)
        {
            hasValue = true;
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (!hasValue)
            {
                observer.OnNext(defaultValue);
            }
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Delay.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Delay<T>(this Observable<T> source, TimeSpan dueTime)
    {
        return new Delay<T>(source, dueTime, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> Delay<T>(this Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider)
    {
        return new Delay<T>(source, dueTime, timeProvider);
    }
}

internal sealed class Delay<T>(Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Delay(observer, dueTime.Normalize(), timeProvider));
    }

    sealed class _Delay : Observer<T>
    {
        static readonly TimerCallback timerCallback = DrainMessages;

        readonly Observer<T> observer;
        readonly TimeSpan dueTime;
        readonly TimeProvider timeProvider;
        readonly Queue<(long timestamp, Notification<T> value)> queue = new(); // lock gate
        ITimer timer;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _Delay(Observer<T> observer, TimeSpan dueTime, TimeProvider timeProvider)
        {
            this.dueTime = dueTime;
            this.observer = observer;
            this.timeProvider = timeProvider;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (queue)
            {
                queue.Enqueue((timeProvider.GetTimestamp(), new(value)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (queue)
            {
                queue.Enqueue((timeProvider.GetTimestamp(), new(error)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (queue)
            {
                queue.Enqueue((timeProvider.GetTimestamp(), new(result)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (queue)
            {
                timer.Dispose(); // stop timer.
                queue.Clear();
            }
        }

        static void DrainMessages(object? state)
        {
            var self = (_Delay)state!;
            var queue = self.queue;

            Notification<T> value;
            while (true)
            {
                if (self.IsDisposed) return;

                lock (queue)
                {
                    if (!queue.TryPeek(out var msg))
                    {
                        self.running = false;
                        return;
                    }

                    // check timestamp
                    var elapsed = self.timeProvider.GetElapsedTime(msg.timestamp);
                    if (elapsed >= self.dueTime)
                    {
                        value = queue.Dequeue().value;
                    }
                    else
                    {
                        // invoke timer again
                        self.timer.InvokeOnce(self.dueTime - elapsed);
                        return;
                    }
                }

                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }

                    continue; // loop to drain all messages
                }
                catch (Exception ex)
                {
                    ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    continue;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/DelayFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> DelayFrame<T>(this Observable<T> source, int frameCount)
    {
        return new DelayFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> DelayFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new DelayFrame<T>(source, frameCount, frameProvider);
    }
}

internal sealed class DelayFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _DelayFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _DelayFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly int frameCount;
        readonly FrameProvider frameProvider;
        readonly Queue<(long timestamp, Notification<T> value)> queue = new(); // lock gate
        bool running;
        long currentFrame;

        protected override bool AutoDisposeOnCompleted => false;

        public _DelayFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.frameCount = frameCount;
            this.observer = observer;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (queue)
            {
                queue.Enqueue((frameProvider.GetFrameCount(), new(value)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    currentFrame = frameProvider.GetFrameCount();
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (queue)
            {
                queue.Enqueue((frameProvider.GetFrameCount(), new(error)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    currentFrame = frameProvider.GetFrameCount();
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (queue)
            {
                queue.Enqueue((frameProvider.GetFrameCount(), new(result)));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    currentFrame = frameProvider.GetFrameCount();
                    frameProvider.Register(this);
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (queue)
            {
                queue.Clear();
            }
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            currentFrame++; // incr frame manually in local queue

            Notification<T> value;
            while (true)
            {
                if (IsDisposed) return false;

                lock (queue)
                {
                    if (!queue.TryPeek(out var msg))
                    {
                        running = false;
                        return false;
                    }

                    // check timestamp
                    var elapsed = currentFrame - msg.timestamp;
                    if (elapsed >= frameCount)
                    {
                        value = queue.Dequeue().value;
                    }
                    else
                    {
                        // continue next frame
                        return true;
                    }
                }

                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                Dispose();
                            }
                            break;
                        default:
                            break;
                    }

                    continue; // loop to drain all messages
                }
                catch (Exception ex)
                {
                    ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    continue;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/DelaySubscription.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> DelaySubscription<T>(this Observable<T> source, TimeSpan dueTime)
    {
        return new DelaySubscription<T>(source, dueTime, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> DelaySubscription<T>(this Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider)
    {
        return new DelaySubscription<T>(source, dueTime, timeProvider);
    }
}

internal sealed class DelaySubscription<T>(Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _DelaySubscription(observer, source, dueTime.Normalize(), timeProvider).Run();
    }

    sealed class _DelaySubscription : Observer<T>
    {
        static readonly TimerCallback timerCallback = Subscribe;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly TimeSpan dueTime;
        readonly ITimer timer;

        public _DelaySubscription(Observer<T> observer, Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.source = source;
            this.dueTime = dueTime;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        public IDisposable Run()
        {
            timer.InvokeOnce(dueTime);
            return this;
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void Subscribe(object? state)
        {
            var self = (_DelaySubscription)state!;
            try
            {
                self.source.Subscribe(self); // subscribe self.
            }
            catch (Exception ex)
            {
                ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                self.Dispose();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/DelaySubscriptionFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> DelaySubscriptionFrame<T>(this Observable<T> source, int frameCount)
    {
        return new DelaySubscriptionFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> DelaySubscriptionFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new DelaySubscriptionFrame<T>(source, frameCount, frameProvider);
    }
}

internal sealed class DelaySubscriptionFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _DelaySubscription(observer, source, frameCount.NormalizeFrame(), frameProvider).Run();
    }

    sealed class _DelaySubscription : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly int frameCount;
        readonly FrameProvider frameProvider;
        int currentFrame;

        public _DelaySubscription(Observer<T> observer, Observable<T> source, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.source = source;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        public IDisposable Run()
        {
            frameProvider.Register(this);
            return this;
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (IsDisposed) return false;

            if (++currentFrame == frameCount)
            {
                try
                {
                    source.Subscribe(this); // subscribe self.
                }
                catch (Exception ex)
                {
                    ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    Dispose();
                }
                return false;
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/Distinct.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Distinct<T>(this Observable<T> source)
    {
        return Distinct(source, EqualityComparer<T>.Default);
    }

    public static Observable<T> Distinct<T>(this Observable<T> source, IEqualityComparer<T> comparer)
    {
        return new Distinct<T>(source, comparer);
    }

    public static Observable<TSource> DistinctBy<TSource, TKey>(this Observable<TSource> source, Func<TSource, TKey> keySelector)
    {
        return DistinctBy(source, keySelector, EqualityComparer<TKey>.Default);
    }

    public static Observable<TSource> DistinctBy<TSource, TKey>(this Observable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
    {
        return new DistinctBy<TSource, TKey>(source, keySelector, comparer);
    }
}

internal sealed class Distinct<T>(Observable<T> source, IEqualityComparer<T> comparer) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Distinct(observer, comparer));
    }

    sealed class _Distinct : Observer<T>
    {
        readonly Observer<T> observer;
        readonly HashSet<T> set;

        public _Distinct(Observer<T> observer, IEqualityComparer<T> comparer)
        {
            this.observer = observer;
            this.set = new HashSet<T>(comparer);
        }

        protected override void OnNextCore(T value)
        {
            if (set.Add(value))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class DistinctBy<T, TKey>(Observable<T> source, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _DistinctBy(observer, keySelector, comparer));
    }

    sealed class _DistinctBy : Observer<T>
    {
        readonly Observer<T> observer;
        readonly Func<T, TKey> keySelector;
        readonly HashSet<TKey> set;

        public _DistinctBy(Observer<T> observer, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer)
        {
            this.observer = observer;
            this.keySelector = keySelector;
            this.set = new HashSet<TKey>(comparer);
        }

        protected override void OnNextCore(T value)
        {
            var key = keySelector(value);
            if (set.Add(key))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/DistinctUntilChanged.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> DistinctUntilChanged<T>(this Observable<T> source)
    {
        return DistinctUntilChanged(source, EqualityComparer<T>.Default);
    }

    public static Observable<T> DistinctUntilChanged<T>(this Observable<T> source, IEqualityComparer<T> comparer)
    {
        return new DistinctUntilChanged<T>(source, comparer);
    }

    public static Observable<T> DistinctUntilChangedBy<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector)
    {
        return DistinctUntilChangedBy(source, keySelector, EqualityComparer<TKey>.Default);
    }

    public static Observable<T> DistinctUntilChangedBy<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer)
    {
        return new DistinctUntilChangedBy<T, TKey>(source, keySelector, comparer);
    }
}

internal sealed class DistinctUntilChanged<T>(Observable<T> source, IEqualityComparer<T> comparer) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _DistinctUntilChanged(observer, comparer));
    }

    sealed class _DistinctUntilChanged : Observer<T>
    {
        readonly Observer<T> observer;
        readonly IEqualityComparer<T> comparer;
        T? lastValue;
        bool hasValue;

        public _DistinctUntilChanged(Observer<T> observer, IEqualityComparer<T> comparer)
        {
            this.observer = observer;
            this.comparer = comparer;
        }

        protected override void OnNextCore(T value)
        {
            if (!hasValue || !comparer.Equals(lastValue!, value))
            {
                hasValue = true;
                lastValue = value;
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class DistinctUntilChangedBy<T, TKey>(Observable<T> source, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _DistinctUntilChangedBy(observer, keySelector, comparer));
    }

    sealed class _DistinctUntilChangedBy : Observer<T>
    {
        readonly Observer<T> observer;
        readonly Func<T, TKey> keySelector;
        readonly IEqualityComparer<TKey> comparer;
        TKey? lastKey;
        bool hasValue;

        public _DistinctUntilChangedBy(Observer<T> observer, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer)
        {
            this.observer = observer;
            this.keySelector = keySelector;
            this.comparer = comparer;
        }

        protected override void OnNextCore(T value)
        {
            var key = keySelector(value);
            if (!hasValue || !comparer.Equals(lastKey!, key))
            {
                hasValue = true;
                lastKey = key;
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Do.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Do<T>(this Observable<T> source, Action<T>? onNext = null, Action<Exception>? onErrorResume = null, Action<Result>? onCompleted = null, Action? onDispose = null, Action? onSubscribe = null)
    {
        return new Do<T>(source, onNext, onErrorResume, onCompleted, onDispose, onSubscribe);
    }

    public static Observable<T> Do<T, TState>(this Observable<T> source, TState state, Action<T, TState>? onNext = null, Action<Exception, TState>? onErrorResume = null, Action<Result, TState>? onCompleted = null, Action<TState>? onDispose = null, Action<TState>? onSubscribe = null)
    {
        return new Do<T, TState>(source, state, onNext, onErrorResume, onCompleted, onDispose, onSubscribe);
    }

    public static Observable<T> DoCancelOnCompleted<T>(this Observable<T> source, CancellationTokenSource cancellationTokenSource)
    {
        return Do(source, cancellationTokenSource, onCompleted: static (_, state) => state.Cancel());
    }
}

internal sealed class Do<T>(Observable<T> source, Action<T>? onNext, Action<Exception>? onErrorResume, Action<Result>? onCompleted, Action? onDispose, Action? onSubscribe) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        onSubscribe?.Invoke();
        return source.Subscribe(new _Do(observer, onNext, onErrorResume, onCompleted, onDispose));
    }

    internal sealed class _Do(Observer<T> observer, Action<T>? onNext, Action<Exception>? onErrorResume, Action<Result>? onCompleted, Action? onDispose) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            onNext?.Invoke(value);
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            onErrorResume?.Invoke(error);
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            onCompleted?.Invoke(result);
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            onDispose?.Invoke();
        }
    }
}

internal sealed class Do<T, TState>(Observable<T> source, TState state, Action<T, TState>? onNext, Action<Exception, TState>? onErrorResume, Action<Result, TState>? onCompleted, Action<TState>? onDispose, Action<TState>? onSubscribe) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        onSubscribe?.Invoke(state);
        return source.Subscribe(new _Do(observer, state, onNext, onErrorResume, onCompleted, onDispose));
    }

    internal sealed class _Do(Observer<T> observer, TState state, Action<T, TState>? onNext, Action<Exception, TState>? onErrorResume, Action<Result, TState>? onCompleted, Action<TState>? onDispose) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            onNext?.Invoke(value, state);
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            onErrorResume?.Invoke(error, state);
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            onCompleted?.Invoke(result, state);
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            onDispose?.Invoke(state);
        }
    }
}



================================================
FILE: src/R3/Operators/ElementAtAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T> ElementAtAsync<T>(this Observable<T> source, int index, CancellationToken cancellationToken = default)
    {
        if (index < 0) throw new ArgumentOutOfRangeException("index");

        var observer = new ElementAtAsync<T>(index, false, default, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

#if !NETSTANDARD2_0

    public static Task<T> ElementAtAsync<T>(this Observable<T> source, Index index, CancellationToken cancellationToken = default)
    {
        if (index.IsFromEnd)
        {
            if (index.Value <= 0) throw new ArgumentOutOfRangeException("index");
            var observer = new ElementAtFromEndAsync<T>(index.Value, false, default, cancellationToken);
            source.Subscribe(observer);
            return observer.Task;
        }
        else
        {
            return ElementAtAsync(source, index.Value, cancellationToken);
        }
    }

#endif

    public static Task<T> ElementAtOrDefaultAsync<T>(this Observable<T> source, int index, T? defaultValue = default, CancellationToken cancellationToken = default)
    {
        if (index < 0) throw new ArgumentOutOfRangeException("index");
        var observer = new ElementAtAsync<T>(index, true, defaultValue, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

#if !NETSTANDARD2_0

    public static Task<T> ElementAtOrDefaultAsync<T>(this Observable<T> source, Index index, T? defaultValue = default, CancellationToken cancellationToken = default)
    {
        if (index.IsFromEnd)
        {
            var observer = new ElementAtFromEndAsync<T>(index.Value, true, defaultValue, cancellationToken);
            source.Subscribe(observer);
            return observer.Task;
        }
        else
        {
            return ElementAtOrDefaultAsync(source, index.Value, defaultValue, cancellationToken);
        }
    }

#endif

}

internal sealed class ElementAtAsync<T>(int index, bool useDefaultValue, T? defaultValue, CancellationToken cancellationToken)
    : TaskObserverBase<T, T>(cancellationToken)
{
    int count = 0;

    protected override void OnNextCore(T value)
    {
        if (count++ == index)
        {
            TrySetResult(value);
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
        }
        else
        {
            if (useDefaultValue)
            {
                TrySetResult(defaultValue!);
            }
            else
            {
                TrySetException(new ArgumentOutOfRangeException("index"));
            }
        }
    }
}

// Index.IsFromEnd
internal sealed class ElementAtFromEndAsync<T>(int fromEndIndex, bool useDefaultValue, T? defaultValue, CancellationToken cancellationToken)
    : TaskObserverBase<T, T>(cancellationToken)
{
    Queue<T> queue = new Queue<T>(fromEndIndex);

    protected override void OnNextCore(T value)
    {
        if (queue.Count == fromEndIndex && queue.Count != 0)
        {
            queue.Dequeue();
        }

        queue.Enqueue(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (queue.Count == fromEndIndex)
        {
            var value = queue.Dequeue();
            TrySetResult(value);
            return;
        }

        if (useDefaultValue)
        {
            TrySetResult(defaultValue!);
            return;
        }

        TrySetException(new ArgumentOutOfRangeException("index"));
    }
}



================================================
FILE: src/R3/Operators/FirstLastSingle.cs
================================================
﻿namespace R3;

using static FirstLastSingleOperation;

public static partial class ObservableExtensions
{
    public static Task<T> FirstAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default) => FirstAsync(source, static _ => true, cancellationToken);
    public static Task<T> FirstOrDefaultAsync<T>(this Observable<T> source, T? defaultValue = default, CancellationToken cancellationToken = default) => FirstOrDefaultAsync(source, static _ => true, defaultValue, cancellationToken);
    public static Task<T> LastAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default) => LastAsync(source, static _ => true, cancellationToken);
    public static Task<T> LastOrDefaultAsync<T>(this Observable<T> source, T? defaultValue = default, CancellationToken cancellationToken = default) => LastOrDefaultAsync(source, static _ => true, defaultValue, cancellationToken);
    public static Task<T> SingleAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default) => SingleAsync(source, static _ => true, cancellationToken);
    public static Task<T> SingleOrDefaultAsync<T>(this Observable<T> source, T? defaultValue = default, CancellationToken cancellationToken = default) => SingleOrDefaultAsync(source, static _ => true, defaultValue, cancellationToken);

    // with predicate
    public static Task<T> FirstAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, First, false, default, predicate, cancellationToken);
    public static Task<T> FirstOrDefaultAsync<T>(this Observable<T> source, Func<T, bool> predicate, T? defaultValue = default, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, First, true, defaultValue, predicate, cancellationToken);
    public static Task<T> LastAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, Last, false, default, predicate, cancellationToken);
    public static Task<T> LastOrDefaultAsync<T>(this Observable<T> source, Func<T, bool> predicate, T? defaultValue = default, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, Last, true, defaultValue, predicate, cancellationToken);
    public static Task<T> SingleAsync<T>(this Observable<T> source, Func<T, bool> predicate, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, Single, false, default, predicate, cancellationToken);
    public static Task<T> SingleOrDefaultAsync<T>(this Observable<T> source, Func<T, bool> predicate, T? defaultValue = default, CancellationToken cancellationToken = default) => FirstLastSingleAsync(source, Single, true, defaultValue, predicate, cancellationToken);

    static Task<T> FirstLastSingleAsync<T>(this Observable<T> source, FirstLastSingleOperation operation, bool useDefaultIfEmpty, T? defaultValue, Func<T, bool> predicate, CancellationToken cancellationToken)
    {
        var observer = new FirstLastSingle<T>(operation, useDefaultIfEmpty, defaultValue, predicate, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class FirstLastSingle<T>(FirstLastSingleOperation operation, bool useDefaultIfEmpty, T? defaultValue, Func<T, bool> predicate, CancellationToken cancellationToken)
    : TaskObserverBase<T, T>(cancellationToken)
{
    bool hasValue;
    T? latestValue = defaultValue;

    protected override void OnNextCore(T value)
    {
        if (!predicate(value)) return;

        if (operation == FirstLastSingleOperation.Single && hasValue)
        {
            TrySetException(new InvalidOperationException("Sequence contains more than one element."));
            return;
        }

        hasValue = true;
        if (operation == FirstLastSingleOperation.First)
        {
            TrySetResult(value); // First / FirstOrDefault
        }
        else
        {
            latestValue = value;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue || useDefaultIfEmpty)
        {
            TrySetResult(latestValue!);
            return;
        }

        TrySetException(new InvalidOperationException("Sequence contains no elements."));
    }
}

internal enum FirstLastSingleOperation
{
    First,
    Last,
    Single
}



================================================
FILE: src/R3/Operators/ForEachAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task ForEachAsync<T>(this Observable<T> source, Action<T> action, CancellationToken cancellationToken = default)
    {
        var observer = new ForEachAsync<T>(action, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }

    public static Task ForEachAsync<T>(this Observable<T> source, Action<T, int> action, CancellationToken cancellationToken = default)
    {
        var observer = new ForEachAsyncWithIndex<T>(action, cancellationToken);
        source.Subscribe(observer);
        return observer.Task;
    }
}

internal sealed class ForEachAsync<T>(Action<T> action, CancellationToken cancellationToken)
    : TaskObserverBase<T, Unit>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
        action(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
        }
        else
        {
            TrySetResult(default);
        }
    }
}

internal sealed class ForEachAsyncWithIndex<T>(Action<T, int> action, CancellationToken cancellationToken)
    : TaskObserverBase<T, Unit>(cancellationToken)
{
    int index;

    protected override void OnNextCore(T value)
    {
        action(value, index++);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
        }
        else
        {
            TrySetResult(default);
        }
    }
}



================================================
FILE: src/R3/Operators/FrameCount.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<(long FrameCount, T Value)> FrameCount<T>(this Observable<T> source)
    {
        return new FrameCount<T>(source, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<(long FrameCount, T Value)> FrameCount<T>(this Observable<T> source, FrameProvider frameProvider)
    {
        return new FrameCount<T>(source, frameProvider);
    }
}

internal sealed class FrameCount<T>(Observable<T> source, FrameProvider frameProvider) : Observable<(long FrameCount, T Value)>
{
    protected override IDisposable SubscribeCore(Observer<(long FrameCount, T Value)> observer)
    {
        return source.Subscribe(new _FrameCount(observer, frameProvider));
    }

    sealed class _FrameCount(Observer<(long FrameCount, T Value)> observer, FrameProvider frameProvider) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext((frameProvider.GetFrameCount(), value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/FrameInterval.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<(long Interval, T Value)> FrameInterval<T>(this Observable<T> source)
    {
        return new FrameInterval<T>(source, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<(long Interval, T Value)> FrameInterval<T>(this Observable<T> source, FrameProvider frameProvider)
    {
        return new FrameInterval<T>(source, frameProvider);
    }
}

internal sealed class FrameInterval<T>(Observable<T> source, FrameProvider frameProvider) : Observable<(long Interval, T Value)>
{
    protected override IDisposable SubscribeCore(Observer<(long Interval, T Value)> observer)
    {
        return source.Subscribe(new _FrameInterval(observer, frameProvider));
    }

    sealed class _FrameInterval(Observer<(long Interval, T Value)> observer, FrameProvider frameProvider) : Observer<T>
    {
        long previousFrameCount = frameProvider.GetFrameCount();

        protected override void OnNextCore(T value)
        {
            var currentFrameCount = frameProvider.GetFrameCount();
            var elapsed = currentFrameCount - previousFrameCount;
            this.previousFrameCount = currentFrameCount;

            observer.OnNext((elapsed, value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/IgnoreElements.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> IgnoreElements<T>(this Observable<T> source)
    {
        return new IgnoreElements<T>(source, null);
    }

    public static Observable<T> IgnoreElements<T>(this Observable<T> source, Action<T> doOnNext)
    {
        return new IgnoreElements<T>(source, doOnNext);
    }
}

internal sealed class IgnoreElements<T>(Observable<T> source, Action<T>? doOnNext) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _IgnoreElements(observer, doOnNext));
    }

    sealed class _IgnoreElements(Observer<T> observer, Action<T>? doOnNext) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            doOnNext?.Invoke(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/IgnoreOnErrorResume.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> IgnoreOnErrorResume<T>(this Observable<T> source)
    {
        return new IgnoreOnErrorResume<T>(source, null);
    }

    public static Observable<T> IgnoreOnErrorResume<T>(this Observable<T> source, Action<Exception>? doOnErrorResume)
    {
        return new IgnoreOnErrorResume<T>(source, doOnErrorResume);
    }
}

internal sealed class IgnoreOnErrorResume<T>(Observable<T> source, Action<Exception>? doOnErrorResume) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _IgnoreOnErrorResume(observer, doOnErrorResume));
    }

    sealed class _IgnoreOnErrorResume(Observer<T> observer, Action<Exception>? doOnErrorResume) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            doOnErrorResume?.Invoke(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Index.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<int> Index(this Observable<Unit> source)
    {
        return new IndexObservable(source);
    }

    public static Observable<(int Index, T Item)> Index<T>(this Observable<T> source)
    {
        return new IndexObservable<T>(source);
    }
}

internal sealed class IndexObservable(Observable<Unit> source) : Observable<int>
{
    protected override IDisposable SubscribeCore(Observer<int> observer)
    {
        return source.Subscribe(new _Index(observer));
    }

    sealed class _Index(Observer<int> observer) : Observer<Unit>
    {
        int index = -1;

        protected override void OnNextCore(Unit value)
        {
            checked
            {
                index++;
            }
            observer.OnNext(index);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class IndexObservable<T>(Observable<T> source) : Observable<(int Index, T Item)>
{
    protected override IDisposable SubscribeCore(Observer<(int Index, T Item)> observer)
    {
        return source.Subscribe(new _Index(observer));
    }

    sealed class _Index(Observer<(int Index, T Item)> observer) : Observer<T>
    {
        int index = -1;

        protected override void OnNextCore(T value)
        {
            checked
            {
                index++;
            }
            observer.OnNext((index, value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Materialize.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<Notification<T>> Materialize<T>(this Observable<T> source)
    {
        return new Materialize<T>(source);
    }

    public static Observable<T> Dematerialize<T>(this Observable<Notification<T>> source)
    {
        return new Dematerialize<T>(source);
    }
}

internal sealed class Materialize<T>(Observable<T> source) : Observable<Notification<T>>
{
    protected override IDisposable SubscribeCore(Observer<Notification<T>> observer)
    {
        return source.Subscribe(new _Materialize(observer));
    }

    sealed class _Materialize(Observer<Notification<T>> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnNext(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            try
            {
                observer.OnNext(new(result));
            }
            finally
            {
                observer.OnCompleted();
            }
        }
    }
}

internal sealed class Dematerialize<T>(Observable<Notification<T>> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Dematerialize(observer));
    }

    sealed class _Dematerialize(Observer<T> observer) : Observer<Notification<T>>
    {
        protected override void OnNextCore(Notification<T> value)
        {
            switch (value.Kind)
            {
                case NotificationKind.OnNext:
                    observer.OnNext(value.Value!);
                    break;
                case NotificationKind.OnErrorResume:
                    OnErrorResume(value.Error!);
                    break;
                case NotificationKind.OnCompleted:
                    OnCompleted(value.Result!);
                    break;
                default:
                    break;
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}




================================================
FILE: src/R3/Operators/MaxAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T> MaxAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new MaxAsync<T>(Comparer<T>.Default, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<T> MaxAsync<T>(this Observable<T> source, IComparer<T> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MaxAsync<T>(comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> MaxAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
    {
        var method = new MaxAsync<TSource, TResult>(selector, Comparer<TResult>.Default, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> MaxAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MaxAsync<TSource, TResult>(selector, comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class MaxAsync<T>(IComparer<T> comparer, CancellationToken cancellation) : TaskObserverBase<T, T>(cancellation)
{
    T current = default!;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (!hasValue)
        {
            hasValue = true;
            current = value;
            return;
        }

        if (comparer.Compare(value, current) > 0)
        {
            current = value;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(current);
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}

internal sealed class MaxAsync<TSource, TResult>(Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellation) : TaskObserverBase<TSource, TResult>(cancellation)
{
    TResult current = default!;
    bool hasValue;

    protected override void OnNextCore(TSource value)
    {
        var nextValue = selector(value);
        if (!hasValue)
        {
            hasValue = true;
            current = nextValue;
            return;
        }

        if (comparer.Compare(nextValue, current) > 0)
        {
            current = nextValue;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(current);
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}



================================================
FILE: src/R3/Operators/MaxByMinByAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T> MaxByAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, CancellationToken cancellationToken = default)
    {
        return MaxByAsync(source, keySelector, Comparer<TKey>.Default, cancellationToken);
    }

    public static Task<T> MaxByAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, IComparer<TKey> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MaxByAsync<T, TKey>(keySelector, comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<T> MinByAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, CancellationToken cancellationToken = default)
    {
        return MinByAsync(source, keySelector, Comparer<TKey>.Default, cancellationToken);
    }

    public static Task<T> MinByAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, IComparer<TKey> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MinByAsync<T, TKey>(keySelector, comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

// MaxByAsync
internal sealed class MaxByAsync<T, TKey>(Func<T, TKey> keySelector, IComparer<TKey> comparer, CancellationToken cancellationToken)
: TaskObserverBase<T, T>(cancellationToken)
{
    T? latestValue;
    TKey? latestKey;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (!hasValue)
        {
            hasValue = true;
            latestValue = value;
            latestKey = keySelector(value);
            return;
        }

        var key = keySelector(value);
        if (comparer.Compare(key, latestKey!) > 0)
        {
            latestValue = value;
            latestKey = key;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(latestValue!);
        }
        else
        {
            TrySetException(new InvalidOperationException("no elements"));
        }
    }
}

// MinByAsync
internal sealed class MinByAsync<T, TKey>(Func<T, TKey> keySelector, IComparer<TKey> comparer, CancellationToken cancellationToken)
    : TaskObserverBase<T, T>(cancellationToken)
{
    T? latestValue;
    TKey? latestKey;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (!hasValue)
        {
            hasValue = true;
            latestValue = value;
            latestKey = keySelector(value);
            return;
        }

        var key = keySelector(value);
        if (comparer.Compare(key, latestKey!) < 0)
        {
            latestValue = value;
            latestKey = key;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(latestValue!);
        }
        else
        {
            TrySetException(new InvalidOperationException("no elements"));
        }
    }
}



================================================
FILE: src/R3/Operators/Merge.cs
================================================
﻿namespace R3;

public static partial class Observable
{
    public static Observable<T> Merge<T>(this Observable<Observable<T>> sources)
    {
        return new MergeMany<T>(sources);
    }
}

internal sealed class MergeMany<T>(Observable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return sources.Subscribe(new _MergeMany(observer));
    }

    sealed class _MergeMany(Observer<T> observer) : Observer<Observable<T>>
    {
        // keep when inner is running
        protected override bool AutoDisposeOnCompleted => false;

        readonly Observer<T> observer = observer;
        readonly object gate = new();
        readonly CompositeDisposable subscriptions = new();
        bool isStopped;

        protected override void OnNextCore(Observable<T> value)
        {
            var innerObserver = new MergeInner(this);
            lock (gate)
            {
                // add observer before subscribe
                subscriptions.Add(innerObserver);
            }
            value.Subscribe(innerObserver);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (result.IsFailure)
                {
                    PublishCompleted(result);
                }
                else
                {
                    isStopped = true;
                    // when no running inner
                    if (subscriptions.Count <= 0)
                    {
                        PublishCompleted(result);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            subscriptions.Dispose();
        }

        void PublishCompleted(Result result)
        {
            try
            {
                lock (gate)
                {
                    observer.OnCompleted(result);
                }
            }
            finally
            {
                Dispose();
            }
        }

        sealed class MergeInner(_MergeMany parent) : Observer<T>
        {
            protected override void OnNextCore(T value)
            {
                lock (parent.gate)
                {
                    parent.observer.OnNext(value);
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                lock (parent.gate)
                {
                    parent.observer.OnErrorResume(error);
                }
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.gate)
                {
                    if (result.IsFailure)
                    {
                        parent.observer.OnCompleted(result);
                    }
                    else
                    {
                        // when all sources are completed, then this observer is completed
                        if (parent is { isStopped: true, subscriptions.Count: 1 }) // only self
                        {
                            parent.PublishCompleted(result);
                        }
                    }
                }
            }

            protected override void DisposeCore()
            {
                parent.subscriptions.Remove(this);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/MinAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T> MinAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new MinAsync<T>(Comparer<T>.Default, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<T> MinAsync<T>(this Observable<T> source, IComparer<T> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MinAsync<T>(comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> MinAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
    {
        var method = new MinAsync<TSource, TResult>(selector, Comparer<TResult>.Default, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> MinAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MinAsync<TSource, TResult>(selector, comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class MinAsync<T>(IComparer<T> comparer, CancellationToken cancellation) : TaskObserverBase<T, T>(cancellation)
{
    T current = default!;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (!hasValue)
        {
            hasValue = true;
            current = value;
            return;
        }

        if (comparer.Compare(value, current) < 0)
        {
            current = value;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(current);
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}

internal sealed class MinAsync<TSource, TResult>(Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellation) : TaskObserverBase<TSource, TResult>(cancellation)
{
    TResult current = default!;
    bool hasValue;

    protected override void OnNextCore(TSource value)
    {
        var nextValue = selector(value);
        if (!hasValue)
        {
            hasValue = true;
            current = nextValue;
            return;
        }

        if (comparer.Compare(nextValue, current) < 0)
        {
            current = nextValue;
        }
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult(current);
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}



================================================
FILE: src/R3/Operators/MinMaxAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<(T Min, T Max)> MinMaxAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        return source.MinMaxAsync(Comparer<T>.Default, cancellationToken);
    }

    public static Task<(T Min, T Max)> MinMaxAsync<T>(this Observable<T> source, IComparer<T> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MinMaxAsync<T>(comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<(TResult Min, TResult Max)> MinMaxAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
    {
        return source.MinMaxAsync(selector, Comparer<TResult>.Default, cancellationToken);
    }

    public static Task<(TResult Min, TResult Max)> MinMaxAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellationToken = default)
    {
        var method = new MinMaxAsync<TSource, TResult>(selector, comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class MinMaxAsync<T>(IComparer<T> comparer, CancellationToken cancellationToken) : TaskObserverBase<T, (T, T)>(cancellationToken)
{
    T min = default!;
    T max = default!;
    bool hasValue;

    protected override void OnNextCore(T value)
    {
        if (!hasValue)
        {
            min = value;
            max = value;
            hasValue = true;
            return;
        }

        if (comparer.Compare(value, min) < 0)
        {
            min = value;
        }
        if (comparer.Compare(value, max) > 0)
        {
            max = value;
        }
        hasValue = true;
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult((min, max));
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}

internal sealed class MinMaxAsync<TSource, TResult>(Func<TSource, TResult> selector, IComparer<TResult> comparer, CancellationToken cancellationToken) : TaskObserverBase<TSource, (TResult, TResult)>(cancellationToken)
{
    TResult min = default!;
    TResult max = default!;
    bool hasValue;

    protected override void OnNextCore(TSource value)
    {
        var current = selector(value);
        if (!hasValue)
        {
            min = current;
            max = current;
            hasValue = true;
            return;
        }

        if (comparer.Compare(current, min) < 0)
        {
            min = current;
        }
        if (comparer.Compare(current, max) > 0)
        {
            max = current;
        }
        hasValue = true;
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        if (hasValue)
        {
            TrySetResult((min, max));
        }
        else
        {
            TrySetException(new InvalidOperationException("Sequence contains no elements"));
        }
    }
}



================================================
FILE: src/R3/Operators/Multicast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    // Multicast, Publish, Replay, ReplayFrame, Share

    public static ConnectableObservable<T> Multicast<T>(this Observable<T> source, ISubject<T> subject)
    {
        return new Multicast<T>(source, subject);
    }

    public static ConnectableObservable<T> Publish<T>(this Observable<T> source)
    {
        return source.Multicast(new Subject<T>());
    }

    public static ConnectableObservable<T> Publish<T>(this Observable<T> source, T initialValue)
    {
        return source.Multicast(new BehaviorSubject<T>(initialValue));
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source)
    {
        return source.Multicast(new ReplaySubject<T>());
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source, int bufferSize)
    {
        return source.Multicast(new ReplaySubject<T>(bufferSize));
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source, TimeSpan window)
    {
        return source.Multicast(new ReplaySubject<T>(window));
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source, TimeSpan window, TimeProvider timeProvider)
    {
        return source.Multicast(new ReplaySubject<T>(window, timeProvider));
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source, int bufferSize, TimeSpan window)
    {
        return source.Multicast(new ReplaySubject<T>(bufferSize, window));
    }

    public static ConnectableObservable<T> Replay<T>(this Observable<T> source, int bufferSize, TimeSpan window, TimeProvider timeProvider)
    {
        return source.Multicast(new ReplaySubject<T>(bufferSize, window, timeProvider));
    }

    public static ConnectableObservable<T> ReplayFrame<T>(this Observable<T> source, int window)
    {
        return source.Multicast(new ReplayFrameSubject<T>(window));
    }

    public static ConnectableObservable<T> ReplayFrame<T>(this Observable<T> source, int window, FrameProvider frameProvider)
    {
        return source.Multicast(new ReplayFrameSubject<T>(window, frameProvider));
    }

    public static ConnectableObservable<T> ReplayFrame<T>(this Observable<T> source, int bufferSize, int window)
    {
        return source.Multicast(new ReplayFrameSubject<T>(bufferSize, window));
    }

    public static ConnectableObservable<T> ReplayFrame<T>(this Observable<T> source, int bufferSize, int window, FrameProvider frameProvider)
    {
        return source.Multicast(new ReplayFrameSubject<T>(bufferSize, window, frameProvider));
    }

    public static Observable<T> Share<T>(this Observable<T> source)
    {
        return source.Publish().RefCount();
    }
}

internal sealed class Multicast<T>(Observable<T> source, ISubject<T> subject) : ConnectableObservable<T>
{
    readonly object gate = new object();
    Connection? connection;

    public override IDisposable Connect()
    {
        lock (gate)
        {
            if (connection == null)
            {
                var subscription = source.Subscribe(subject.AsObserver());
                connection = new Connection(this, subscription);
            }

            return connection;
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return subject.Subscribe(observer.Wrap());
    }

    sealed class Connection(Multicast<T> parent, IDisposable? subscription) : IDisposable
    {
        public void Dispose()
        {
            lock (parent.gate)
            {
                if (subscription != null)
                {
                    subscription.Dispose();
                    subscription = null;
                    parent.connection = null;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ObserveOn.cs
================================================
﻿using System.Collections.Concurrent;

namespace R3;

public static partial class ObservableExtensions
{
    /// <summary>ObserveOn SynchronizationContext.Current</summary>
    public static Observable<T> ObserveOnCurrentSynchronizationContext<T>(this Observable<T> source)
    {
        return ObserveOn<T>(source, SynchronizationContext.Current);
    }

    public static Observable<T> ObserveOnThreadPool<T>(this Observable<T> source)
    {
        return new ObserveOnThreadPool<T>(source);
    }

    public static Observable<T> ObserveOn<T>(this Observable<T> source, SynchronizationContext? synchronizationContext)
    {
        if (synchronizationContext == null)
        {
            return new ObserveOnThreadPool<T>(source); // use ThreadPool instead
        }

        return new ObserveOnSynchronizationContext<T>(source, synchronizationContext);
    }

    public static Observable<T> ObserveOn<T>(this Observable<T> source, TimeProvider timeProvider)
    {
        if (timeProvider == TimeProvider.System)
        {
            return new ObserveOnThreadPool<T>(source);
        }

        return new ObserveOnTimeProvider<T>(source, timeProvider);
    }

    public static Observable<T> ObserveOn<T>(this Observable<T> source, FrameProvider frameProvider)
    {
        return new ObserveOnFrameProvider<T>(source, frameProvider);
    }
}

internal sealed class ObserveOnSynchronizationContext<T>(Observable<T> source, SynchronizationContext synchronizationContext) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOn(observer, synchronizationContext));
    }

    sealed class _ObserveOn : Observer<T>
    {
        static readonly SendOrPostCallback postCallback = DrainMessages;

        readonly Observer<T> observer;
        readonly SynchronizationContext synchronizationContext;
        readonly object gate = new object();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOn(Observer<T> observer, SynchronizationContext synchronizationContext)
        {
            this.observer = observer;
            this.synchronizationContext = synchronizationContext;
        }


        protected override void OnNextCore(T value)
        {
            EnqueueValue(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    synchronizationContext.Post(postCallback, this);
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }

        static void DrainMessages(object? state)
        {
            var self = (_ObserveOn)state!;

            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (self.gate)
            {
                values = self.list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

        FINALIZE:
            lock (self.gate)
            {
                self.list.Clear(token);

                if (self.IsDisposed)
                {
                    self.running = false;
                    return;
                }

                if (self.list.HasValue)
                {
                    // post again
                    self.synchronizationContext.Post(postCallback, self);
                    return;
                }
                else
                {
                    self.running = false;
                    return;
                }
            }
        }
    }
}

internal sealed class ObserveOnThreadPool<T>(Observable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOn(observer));
    }

    sealed class _ObserveOn(Observer<T> observer) : Observer<T>, IThreadPoolWorkItem
    {
        Observer<T> observer = observer;
        ConcurrentQueue<Notification<T>> q = new();
        bool running = false;

        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(T value)
        {
            q.Enqueue(new(value));
            TryStartWorker();
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            q.Enqueue(new(error));
            TryStartWorker();
        }

        protected override void OnCompletedCore(Result result)
        {
            q.Enqueue(new(result));
            TryStartWorker();
        }

        void TryStartWorker()
        {
            lock (q)
            {
                if (!running)
                {
                    running = true;
                    ThreadPool.UnsafeQueueUserWorkItem(this, preferLocal: false);
                }
            }
        }

        void IThreadPoolWorkItem.Execute()
        {
        AGAIN:
            while (q.TryDequeue(out var item))
            {
                switch (item.Kind)
                {
                    case NotificationKind.OnNext:
                        observer.OnNext(item.Value!);
                        break;
                    case NotificationKind.OnErrorResume:
                        observer.OnErrorResume(item.Error!);
                        break;
                    case NotificationKind.OnCompleted:
                        try
                        {
                            observer.OnCompleted(item.Result!);
                        }
                        finally
                        {
                            Dispose();
                        }
                        break;
                }
            }

            lock (q)
            {
                if (q.Count != 0)
                {
                    goto AGAIN;
                }
                running = false;
                return;
            }
        }
    }
}

internal sealed class ObserveOnTimeProvider<T>(Observable<T> source, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOn(observer, timeProvider));
    }

    internal sealed class _ObserveOn : Observer<T>
    {
        static readonly TimerCallback timerCallback = DrainMessages;

        readonly Observer<T> observer;
        readonly TimeProvider timeProvider;
        readonly Queue<Notification<T>> queue; // local queue, lock gate
        ITimer? timer;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOn(Observer<T> observer, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeProvider = timeProvider;
            this.queue = new();
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (queue)
            {
                if (timer == null) return;
                queue.Enqueue(new(value));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (queue)
            {
                if (timer == null) return;
                queue.Enqueue(new(error));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (queue)
            {
                if (timer == null) return;
                queue.Enqueue(new(result));
                if (queue.Count == 1 && !running)
                {
                    running = true;
                    timer.RestartImmediately();
                }
            }
        }

        static void DrainMessages(object? state)
        {
            var self = (_ObserveOn)state!;
            var queue = self.queue;

            Notification<T> value = default;
            while (true)
            {
                lock (queue)
                {
                    if (self.timer == null || !queue.TryDequeue(out value))
                    {
                        self.running = false;
                        return;
                    }
                }

                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }

                    continue; // loop to drain all messages
                }
                catch (Exception ex)
                {
                    ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    continue;
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (queue)
            {
                if (timer != null)
                {
                    timer.Dispose(); // stop timer.
                    timer = null;
                }
                queue.Clear();
            }
        }
    }
}

internal sealed class ObserveOnFrameProvider<T>(Observable<T> source, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOn(observer, frameProvider));
    }

    internal sealed class _ObserveOn : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly FrameProvider frameProvider;
        readonly object gate = new object();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOn(Observer<T> observer, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameProvider = frameProvider;
            this.running = false;
            this.list = new SwapListCore<Notification<T>>();
        }

        protected override void OnNextCore(T value)
        {
            EnqueueValue(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    frameProvider.Register(this);
                }
            }
        }

        public bool MoveNext(long frameCount)
        {
            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (gate)
            {
                values = list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

        FINALIZE:
            lock (gate)
            {
                list.Clear(token);

                if (IsDisposed)
                {
                    running = false;
                    return false;
                }

                if (list.HasValue)
                {
                    return true;
                }
                else
                {
                    running = false;
                    return false;
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/OfType.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> OfType<T, TResult>(this Observable<T> source)
    {
        return new OfType<T, TResult>(source);
    }
}

internal sealed class OfType<T, TResult>(Observable<T> source) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _OfType(observer));
    }

    sealed class _OfType(Observer<TResult> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            if (value is TResult v)
            {
                observer.OnNext(v);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/OnErrorResumeAsFailure.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> OnErrorResumeAsFailure<T>(this Observable<T> source)
    {
        return new OnErrorResumeAsFailure<T>(source);
    }
}

internal class OnErrorResumeAsFailure<T>(Observable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _OnErrorAsComplete(observer));
    }

    sealed class _OnErrorAsComplete(Observer<T> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnCompleted(error);
        }

        protected override void OnCompletedCore(Result complete)
        {
            observer.OnCompleted(complete);
        }
    }
}



================================================
FILE: src/R3/Operators/Pairwise.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<(T Previous, T Current)> Pairwise<T>(this Observable<T> source)
    {
        return new Pairwise<T>(source);
    }
}

internal sealed class Pairwise<T>(Observable<T> source) : Observable<(T Previous, T Current)>
{
    protected override IDisposable SubscribeCore(Observer<(T Previous, T Current)> observer)
    {
        return source.Subscribe(new _Pairwise(observer));
    }

    sealed class _Pairwise(Observer<(T Previous, T Current)> observer) : Observer<T>
    {
        T? previous;
        bool isFirst = true;

        protected override void OnNextCore(T value)
        {
            if (isFirst)
            {
                isFirst = false;
                previous = value;
                return;
            }

            var pair = (previous!, value);
            previous = value;
            observer.OnNext(pair);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/RefCount.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> RefCount<T>(this ConnectableObservable<T> source)
    {
        return new RefCount<T>(source);
    }
}

internal sealed class RefCount<T>(ConnectableObservable<T> source) : Observable<T>
{
    readonly object gate = new object();
    int refCount = 0;
    IDisposable? connection;

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        lock (gate)
        {
            // incr refCount before Subscribe(completed source decrement refCount in Subscribe)
            ++refCount;
            bool needConnect = refCount == 1;
            var coObserver = new _RefCount(this, observer);
            var subcription = source.Subscribe(coObserver);
            if (needConnect && !coObserver.IsDisposed)
            {
                connection = source.Connect();
            }
            return subcription;
        }
    }

    sealed class _RefCount(RefCount<T> parent, Observer<T> observer) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            lock (parent.gate)
            {
                if (--parent.refCount == 0)
                {
                    parent.connection?.Dispose();
                    parent.connection = null;
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Scan.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TSource> Scan<TSource>(this Observable<TSource> source, Func<TSource, TSource, TSource> accumulator)
    {
        return new Scan<TSource>(source, accumulator);
    }

    public static Observable<TAccumulate> Scan<TSource, TAccumulate>(this Observable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> accumulator)
    {
        return new Scan<TSource, TAccumulate>(source, seed, accumulator);
    }
}

internal sealed class Scan<TSource>(Observable<TSource> source, Func<TSource, TSource, TSource> accumulator) : Observable<TSource>
{
    protected override IDisposable SubscribeCore(Observer<TSource> observer)
    {
        return source.Subscribe(new _Scan(observer, accumulator));
    }

    sealed class _Scan : Observer<TSource>
    {
        readonly Observer<TSource> observer;
        readonly Func<TSource, TSource, TSource> accumulator;
        TSource state;
        bool hasValue;

        public _Scan(Observer<TSource> observer, Func<TSource, TSource, TSource> accumulator)
        {
            this.observer = observer;
            this.state = default!;
            this.accumulator = accumulator;
        }

        protected override void OnNextCore(TSource value)
        {
            if (!hasValue)
            {
                hasValue = true;
                state = value;
                observer.OnNext(state);
                return;
            }

            state = accumulator(state, value);
            observer.OnNext(state);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class Scan<TSource, TAccumulate>(Observable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> accumulator) : Observable<TAccumulate>
{
    protected override IDisposable SubscribeCore(Observer<TAccumulate> observer)
    {
        return source.Subscribe(new _Scan(observer, seed, accumulator));
    }

    sealed class _Scan : Observer<TSource>
    {
        readonly Observer<TAccumulate> observer;
        readonly Func<TAccumulate, TSource, TAccumulate> accumulator;
        TAccumulate state;

        public _Scan(Observer<TAccumulate> observer, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> accumulator)
        {
            this.observer = observer;
            this.state = seed;
            this.accumulator = accumulator;
        }

        protected override void OnNextCore(TSource value)
        {
            state = accumulator(state, value);
            observer.OnNext(state);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Select.cs
================================================
﻿using System.Security.AccessControl;
using System.Threading;
using System.Threading.Channels;

namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> Select<T, TResult>(this Observable<T> source, Func<T, TResult> selector)
    {
        if (source is Where<T> where)
        {
            // Optimize for WhereSelect
            return new WhereSelect<T, TResult>(where.source, selector, where.predicate);
        }

        return new Select<T, TResult>(source, selector);
    }

    public static Observable<TResult> Select<T, TResult>(this Observable<T> source, Func<T, int, TResult> selector)
    {
        return new SelectIndexed<T, TResult>(source, selector);
    }

    // TState

    public static Observable<TResult> Select<T, TResult, TState>(this Observable<T> source, TState state, Func<T, TState, TResult> selector)
    {
        return new Select<T, TResult, TState>(source, selector, state);
    }

    public static Observable<TResult> Select<T, TResult, TState>(this Observable<T> source, TState state, Func<T, int, TState, TResult> selector)
    {
        return new SelectIndexed<T, TResult, TState>(source, selector, state);
    }
}

internal sealed class Select<T, TResult>(Observable<T> source, Func<T, TResult> selector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _Select(observer, selector));
    }

    sealed class _Select(Observer<TResult> observer, Func<T, TResult> selector) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(selector(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class Select<T, TResult, TState>(Observable<T> source, Func<T, TState, TResult> selector, TState state) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _Select(observer, selector, state));
    }

    sealed class _Select(Observer<TResult> observer, Func<T, TState, TResult> selector, TState state) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(selector(value, state));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class WhereSelect<T, TResult>(Observable<T> source, Func<T, TResult> selector, Func<T, bool> predicate) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _WhereSelect(observer, selector, predicate));
    }

    sealed class _WhereSelect(Observer<TResult> observer, Func<T, TResult> selector, Func<T, bool> predicate) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            if (predicate(value))
            {
                observer.OnNext(selector(value));
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class SelectIndexed<T, TResult>(Observable<T> source, Func<T, int, TResult> selector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _Select(observer, selector));
    }

    sealed class _Select(Observer<TResult> observer, Func<T, int, TResult> selector) : Observer<T>
    {
        int index = 0;

        protected override void OnNextCore(T value)
        {
            observer.OnNext(selector(value, index++));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class SelectIndexed<T, TResult, TState>(Observable<T> source, Func<T, int, TState, TResult> selector, TState state) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _Select(observer, selector, state));
    }

    sealed class _Select(Observer<TResult> observer, Func<T, int, TState, TResult> selector, TState state) : Observer<T>
    {
        int index = 0;

        protected override void OnNextCore(T value)
        {
            observer.OnNext(selector(value, index++, state));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/SelectAwait.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3;

public static partial class ObservableExtensions
{
    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static Observable<TResult> SelectAwait<T, TResult>(this Observable<T> source, Func<T, CancellationToken, ValueTask<TResult>> selector, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return new SelectAwait<T, TResult>(source, selector, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }
}

internal sealed class SelectAwait<T, TResult>(Observable<T> source, Func<T, CancellationToken, ValueTask<TResult>> selector, AwaitOperation awaitOperation, bool configureAwait, bool cancelOnCompleted, int maxConcurrent) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        switch (awaitOperation)
        {
            case AwaitOperation.Sequential:
                return source.Subscribe(new SelectAwaitSequential(observer, selector, configureAwait, cancelOnCompleted));
            case AwaitOperation.Drop:
                return source.Subscribe(new SelectAwaitDrop(observer, selector, configureAwait, cancelOnCompleted));
            case AwaitOperation.Switch:
                return source.Subscribe(new SelectAwaitSwitch(observer, selector, configureAwait, cancelOnCompleted));
            case AwaitOperation.Parallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new SelectAwaitParallel(observer, selector, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new SelectAwaitParallelConcurrentLimit(observer, selector, configureAwait, cancelOnCompleted, maxConcurrent));
                }
            case AwaitOperation.SequentialParallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new SelectAwaitSequentialParallel(observer, selector, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new SelectAwaitSequentialParallelConcurrentLimit(observer, selector, configureAwait, cancelOnCompleted, maxConcurrent));
                }
            case AwaitOperation.ThrottleFirstLast:
                return source.Subscribe(new SelectAwaitThrottleFirstLast(observer, selector, configureAwait, cancelOnCompleted));
            default:
                throw new ArgumentException();
        }
    }

    sealed class SelectAwaitSequential(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSequentialObserver<T>(configureAwait, cancelOnCompleted)
    {
#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            observer.OnNext(v);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class SelectAwaitDrop(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationDropObserver<T>(configureAwait, cancelOnCompleted)
    {
#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            observer.OnNext(v);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class SelectAwaitParallel(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationParallelObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            lock (gate)
            {
                observer.OnNext(v);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }


    sealed class SelectAwaitSwitch(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSwitchObserver<T>(configureAwait, cancelOnCompleted)
    {
        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            lock (gate)
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    observer.OnNext(v);
                }
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }

    sealed class SelectAwaitSequentialParallel(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSequentialParallelObserver<T, TResult>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override ValueTask<TResult> OnNextTaskAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            return selector(value, cancellationToken);
        }

        protected override void PublishOnNext(T _, TResult result)
        {
            observer.OnNext(result);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class SelectAwaitParallelConcurrentLimit(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
        : AwaitOperationParallelConcurrentLimitObserver<T>(configureAwait, cancelOnCompleted, maxConcurrent)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            lock (gate)
            {
                observer.OnNext(v);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }

    sealed class SelectAwaitSequentialParallelConcurrentLimit(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
        : AwaitOperationSequentialParallelConcurrentLimitObserver<T, TResult>(configureAwait, cancelOnCompleted, maxConcurrent)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override ValueTask<TResult> OnNextTaskAsyncCore(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            return selector(value, cancellationToken);
        }

        protected override void PublishOnNext(T _, TResult result)
        {
            observer.OnNext(result);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class SelectAwaitThrottleFirstLast(Observer<TResult> observer, Func<T, CancellationToken, ValueTask<TResult>> selector, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationThrottleFirstLastObserver<T>(configureAwait, cancelOnCompleted)
    {
#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            var v = await selector(value, cancellationToken).ConfigureAwait(configureAwait);
            observer.OnNext(v);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/SelectMany.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> SelectMany<TSource, TResult>(this Observable<TSource> source, Func<TSource, Observable<TResult>> selector)
    {
        return SelectMany(source, selector, static (sourceValue, collectionValue) => collectionValue);
    }


    public static Observable<TResult> SelectMany<TSource, TCollection, TResult>(this Observable<TSource> source, Func<TSource, Observable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
    {
        return new SelectMany<TSource, TCollection, TResult>(source, collectionSelector, resultSelector);
    }

    // with index

    public static Observable<TResult> SelectMany<TSource, TResult>(this Observable<TSource> source, Func<TSource, int, Observable<TResult>> selector)
    {
        return SelectMany(source, selector, static (sourceValue, sourceIndex, collectionValue, collectionIndex) => collectionValue);
    }

    public static Observable<TResult> SelectMany<TSource, TCollection, TResult>(this Observable<TSource> source, Func<TSource, int, Observable<TCollection>> collectionSelector, Func<TSource, int, TCollection, int, TResult> resultSelector)
    {
        return new SelectManyIndexed<TSource, TCollection, TResult>(source, collectionSelector, resultSelector);
    }
}

internal sealed class SelectMany<TSource, TCollection, TResult>(Observable<TSource> source, Func<TSource, Observable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
    : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _SelectMany(observer, collectionSelector, resultSelector));
    }

    sealed class _SelectMany(Observer<TResult> observer, Func<TSource, Observable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector) : Observer<TSource>
    {
        readonly Observer<TResult> observer = observer;
        readonly Func<TSource, Observable<TCollection>> collectionSelector = collectionSelector;
        readonly Func<TSource, TCollection, TResult> resultSelector = resultSelector;
        readonly CompositeDisposable compositeDisposable = new();
        readonly object gate = new object();
        bool isStopped;

        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(TSource value)
        {
            var nextSource = collectionSelector(value);

            var observer = new _SelectManyCollectionObserver(value, this);
            compositeDisposable.Add(observer); // Add observer before subscribe!
            nextSource.Subscribe(observer);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                PublishCompleted(result);
            }
            else
            {
                lock (gate)
                {
                    isStopped = true;
                    if (compositeDisposable.Count == 0)
                    {
                        PublishCompleted(result);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            compositeDisposable.Dispose();
        }

        void PublishCompleted(Result result)
        {
            try
            {
                lock (gate)
                {
                    observer.OnCompleted(result);
                }
            }
            finally
            {
                Dispose();
            }
        }

        sealed class _SelectManyCollectionObserver(TSource sourceValue, _SelectMany parent) : Observer<TCollection>
        {
            protected override void OnNextCore(TCollection value)
            {
                var result = parent.resultSelector(sourceValue, value);
                lock (parent.gate)
                {
                    parent.observer.OnNext(result);
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                lock (parent.gate)
                {
                    parent.observer.OnErrorResume(error);
                }
            }

            protected override void OnCompletedCore(Result result)
            {
                if (result.IsFailure)
                {
                    parent.OnCompleted(result);
                }
                else
                {
                    lock (parent.gate)
                    {
                        if (parent.isStopped && parent.compositeDisposable.Count == 1) // only self
                        {
                            parent.PublishCompleted(result);
                        }
                    }
                }
            }

            protected override void DisposeCore()
            {
                parent.compositeDisposable.Remove(this);
            }
        }
    }
}


internal sealed class SelectManyIndexed<TSource, TCollection, TResult>(Observable<TSource> source, Func<TSource, int, Observable<TCollection>> collectionSelector, Func<TSource, int, TCollection, int, TResult> resultSelector)
    : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return source.Subscribe(new _SelectMany(observer, collectionSelector, resultSelector));
    }

    sealed class _SelectMany(Observer<TResult> observer, Func<TSource, int, Observable<TCollection>> collectionSelector, Func<TSource, int, TCollection, int, TResult> resultSelector) : Observer<TSource>
    {
        readonly Observer<TResult> observer = observer;
        readonly Func<TSource, int, Observable<TCollection>> collectionSelector = collectionSelector;
        readonly Func<TSource, int, TCollection, int, TResult> resultSelector = resultSelector;
        readonly CompositeDisposable compositeDisposable = new();
        readonly object gate = new object();
        bool isStopped;
        int index = 0;

        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(TSource value)
        {
            var i = index++;
            var nextSource = collectionSelector(value, i);
            var observer = new _SelectManyCollectionObserver(value, this, i);
            compositeDisposable.Add(observer); // Add observer before subscribe!
            nextSource.Subscribe(observer);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                PublishCompleted(result);
            }
            else
            {
                lock (gate)
                {
                    isStopped = true;
                    if (compositeDisposable.Count == 0)
                    {
                        PublishCompleted(result);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            compositeDisposable.Dispose();
        }

        void PublishCompleted(Result result)
        {
            try
            {
                lock (gate)
                {
                    observer.OnCompleted(result);
                }
            }
            finally
            {
                Dispose();
            }
        }

        sealed class _SelectManyCollectionObserver(TSource sourceValue, _SelectMany parent, int sourceIndex) : Observer<TCollection>
        {
            int index = 0;

            protected override void OnNextCore(TCollection value)
            {
                var result = parent.resultSelector(sourceValue, sourceIndex, value, index++);
                lock (parent.gate)
                {
                    parent.observer.OnNext(result);
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                lock (parent.gate)
                {
                    parent.observer.OnErrorResume(error);
                }
            }

            protected override void OnCompletedCore(Result result)
            {
                if (result.IsFailure)
                {
                    parent.OnCompleted(result);
                }
                else
                {
                    lock (parent.gate)
                    {
                        if (parent.isStopped && parent.compositeDisposable.Count == 1) // only self
                        {
                            parent.PublishCompleted(result);
                        }
                    }
                }
            }

            protected override void DisposeCore()
            {
                parent.compositeDisposable.Remove(this);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/SequenceEqualAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<bool> SequenceEqualAsync<T>(this Observable<T> source, Observable<T> second, CancellationToken cancellationToken = default)
    {
        return SequenceEqualAsync(source, second, EqualityComparer<T>.Default, cancellationToken);
    }

    public static Task<bool> SequenceEqualAsync<T>(this Observable<T> source, Observable<T> second, IEqualityComparer<T> equalityComparer, CancellationToken cancellationToken = default)
    {
        var method = new SequenceEqualAsync<T>(equalityComparer, cancellationToken);
        try
        {
            source.Subscribe(method.leftObserver);
            second.Subscribe(method.rightObserver);
        }
        catch
        {
            method.Dispose();
            throw;
        }

        return method.Task;
    }
}

// SequenceEqualAsync
internal sealed class SequenceEqualAsync<T> : TaskObserverBase<T, bool>
{
    public readonly IEqualityComparer<T> equalityComparer;
    public SequenceEqualAsyncObserver leftObserver;
    public SequenceEqualAsyncObserver rightObserver;

    public SequenceEqualAsync(IEqualityComparer<T> equalityComparer, CancellationToken cancellationToken)
        : base(cancellationToken)
    {
        this.equalityComparer = equalityComparer;
        this.leftObserver = new SequenceEqualAsyncObserver(this);
        this.rightObserver = new SequenceEqualAsyncObserver(this);
    }

    protected override void OnNextCore(T value)
    {
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
        }
    }

    protected override void DisposeCore()
    {
        leftObserver.Dispose();
        rightObserver.Dispose();
    }

    // called in lock
    void CheckValues()
    {
        while (leftObserver.values.Count != 0 && rightObserver.values.Count != 0)
        {
            var left = leftObserver.values.Dequeue();
            var right = rightObserver.values.Dequeue();
            if (!equalityComparer.Equals(left, right))
            {
                TrySetResult(false);
                return;
            }
        }

        if (leftObserver.IsCompleted && rightObserver.IsCompleted)
        {
            if (leftObserver.values.Count == 0 && rightObserver.values.Count == 0)
            {
                TrySetResult(true);
            }
            else
            {
                TrySetResult(false);
            }
        }
    }

    internal sealed class SequenceEqualAsyncObserver(SequenceEqualAsync<T> parent) : Observer<T>
    {
        public Queue<T> values = new Queue<T>();
        public bool IsCompleted;

        protected override void OnNextCore(T value)
        {
            lock (parent)
            {
                values.Enqueue(value);
                parent.CheckValues();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                parent.OnCompleted(result);
            }
            else
            {
                lock (parent)
                {
                    IsCompleted = true;
                    parent.CheckValues();
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Skip.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Skip<T>(this Observable<T> source, int count)
    {
        if (count < 0) throw new ArgumentOutOfRangeException("count");

        return new Skip<T>(source, count);
    }

    // TimeBased

    public static Observable<T> Skip<T>(this Observable<T> source, TimeSpan duration)
    {
        return Skip(source, duration, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> Skip<T>(this Observable<T> source, TimeSpan duration, TimeProvider timeProvider)
    {
        return new SkipTime<T>(source, duration.Normalize(), timeProvider);
    }

    // SkipFrame

    public static Observable<T> SkipFrame<T>(this Observable<T> source, int frameCount)
    {
        return SkipFrame(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> SkipFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new SkipFrame<T>(source, frameCount.NormalizeFrame(), frameProvider);
    }
}

internal sealed class Skip<T>(Observable<T> source, int count) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Skip(observer, count));
    }

    sealed class _Skip(Observer<T> observer, int count) : Observer<T>, IDisposable
    {
        int remaining = count;

        protected override void OnNextCore(T value)
        {
            if (remaining > 0)
            {
                remaining--;
            }
            else
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class SkipTime<T>(Observable<T> source, TimeSpan duration, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipTime(observer, duration, timeProvider));
    }

    sealed class _SkipTime : Observer<T>, IDisposable
    {
        static readonly TimerCallback timerCallback = TimerStopped;

        readonly Observer<T> observer;
        ITimer? timer; // when null, the timer has been stopped

        public _SkipTime(Observer<T> observer, TimeSpan duration, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
            timer.InvokeOnce(duration);
        }

        protected override void OnNextCore(T value)
        {
            if (Volatile.Read(ref timer) != null) return;
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        static void TimerStopped(object? state)
        {
            var self = (_SkipTime)state!;
            Volatile.Read(ref self.timer)?.Dispose();
            Volatile.Write(ref self.timer, null);

        }

        protected override void DisposeCore()
        {
            Volatile.Read(ref timer)?.Dispose();
            Volatile.Write(ref timer, null);
        }
    }
}

internal sealed class SkipFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipFrame(observer, frameCount, frameProvider));
    }

    sealed class _SkipFrame : Observer<T>, IDisposable, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        long remaining;

        public _SkipFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.remaining = frameCount;
            frameProvider.Register(this);
        }

        protected override void OnNextCore(T value)
        {
            if (Volatile.Read(ref remaining) > 0) return;
            observer.OnNext(value);

        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            if (remaining > 0)
            {
                remaining--;
                return true;
            }

            return false;
        }
    }
}



================================================
FILE: src/R3/Operators/SkipLast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> SkipLast<T>(this Observable<T> source, int count)
    {
        if (count < 0) throw new ArgumentOutOfRangeException("count");
        return new SkipLast<T>(source, count);
    }

    // TimeBased

    public static Observable<T> SkipLast<T>(this Observable<T> source, TimeSpan duration)
    {
        return SkipLast(source, duration, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> SkipLast<T>(this Observable<T> source, TimeSpan duration, TimeProvider timeProvider)
    {
        return new SkipLastTime<T>(source, duration.Normalize(), timeProvider);
    }

    // SkipLastFrame

    public static Observable<T> SkipLastFrame<T>(this Observable<T> source, int frameCount)
    {
        return SkipLastFrame(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> SkipLastFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new SkipLastFrame<T>(source, frameCount.NormalizeFrame(), frameProvider);
    }
}

internal sealed class SkipLast<T>(Observable<T> source, int count) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipLast(observer, count));
    }

    sealed class _SkipLast(Observer<T> observer, int count) : Observer<T>, IDisposable
    {
        Queue<T> queue = new Queue<T>(count);

        protected override void OnNextCore(T value)
        {
            queue.Enqueue(value);
            if (queue.Count > count)
            {
                observer.OnNext(queue.Dequeue());
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            queue.Clear();
        }
    }
}

internal sealed class SkipLastTime<T>(Observable<T> source, TimeSpan duration, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipLastTime(observer, duration, timeProvider));
    }

    sealed class _SkipLastTime : Observer<T>, IDisposable
    {
        readonly Observer<T> observer;
        readonly Queue<(long timestamp, T value)> queue = new();
        readonly TimeSpan duration;
        readonly TimeProvider timeProvider;

        public _SkipLastTime(Observer<T> observer, TimeSpan duration, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeProvider = timeProvider;
            this.duration = duration;
        }

        protected override void OnNextCore(T value)
        {
            var current = timeProvider.GetTimestamp();
            queue.Enqueue((current, value));
            while (queue.Count > 0 && timeProvider.GetElapsedTime(queue.Peek().timestamp, current) >= duration)
            {
                observer.OnNext(queue.Dequeue().value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            var current = timeProvider.GetTimestamp();
            while (queue.Count > 0 && timeProvider.GetElapsedTime(queue.Peek().timestamp, current) >= duration)
            {
                observer.OnNext(queue.Dequeue().value);
            }
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            queue.Clear();
        }
    }
}

internal sealed class SkipLastFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipLastFrame(observer, frameCount, frameProvider));
    }

    sealed class _SkipLastFrame : Observer<T>, IDisposable
    {
        readonly Observer<T> observer;
        readonly Queue<(long frameCount, T value)> queue = new();
        readonly int frameCount;
        readonly FrameProvider frameProvider;

        public _SkipLastFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            var current = frameProvider.GetFrameCount();
            queue.Enqueue((current, value));
            while (queue.Count > 0 && current - queue.Peek().frameCount >= frameCount)
            {
                observer.OnNext(queue.Dequeue().value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            var current = frameProvider.GetFrameCount();
            while (queue.Count > 0 && current - queue.Peek().frameCount >= frameCount)
            {
                observer.OnNext(queue.Dequeue().value);
            }
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            queue.Clear();
        }
    }
}



================================================
FILE: src/R3/Operators/SkipUntil.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> SkipUntil<T, TOther>(this Observable<T> source, Observable<TOther> other)
    {
        return new SkipUntil<T, TOther>(source, other);
    }

    public static Observable<T> SkipUntil<T>(this Observable<T> source, CancellationToken cancellationToken)
    {
        if (!cancellationToken.CanBeCanceled) throw new ArgumentException("cancellationToken must be cancellable", nameof(cancellationToken));
        return new SkipUntilC<T>(source, cancellationToken);
    }

    public static Observable<T> SkipUntil<T>(this Observable<T> source, Task task, bool configureAwait = true)
    {
        return new SkipUntilT<T>(source, task, configureAwait);
    }

    public static Observable<T> SkipUntil<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait = true)
    {
        return new SkipUntilAsync<T>(source, asyncFunc, configureAwait);
    }
}

internal sealed class SkipUntil<T, TOther>(Observable<T> source, Observable<TOther> other) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var skipUntil = new _SkipUntil(observer);
        var otherSubscription = other.Subscribe(skipUntil.otherObserver);
        try
        {
            return source.Subscribe(skipUntil); // subscription contains self and other.
        }
        catch
        {
            otherSubscription.Dispose();
            throw;
        }
    }

    sealed class _SkipUntil : Observer<T>
    {
        readonly Observer<T> observer;
        internal readonly SkipUntilOtherObserver otherObserver;

        internal bool open;

        public _SkipUntil(Observer<T> observer)
        {
            this.observer = observer;
            this.otherObserver = new SkipUntilOtherObserver(this);
        }

        protected override void OnNextCore(T value)
        {
            if (Volatile.Read(ref open))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            otherObserver.Dispose();
        }
    }

    sealed class SkipUntilOtherObserver(_SkipUntil parent) : Observer<TOther>
    {
        protected override void OnNextCore(TOther value)
        {
            Volatile.Write(ref parent.open, true);
            Dispose();
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            parent.OnCompleted(result);
        }
    }
}

internal sealed class SkipUntilC<T>(Observable<T> source, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipUntil(observer, cancellationToken));
    }

    sealed class _SkipUntil : Observer<T>, IDisposable
    {
        static readonly Action<object?> cancellationCallback = CancellationCallback;

        readonly Observer<T> observer;
        CancellationTokenRegistration tokenRegistration;
        bool open;

        public _SkipUntil(Observer<T> observer, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.tokenRegistration = cancellationToken.Register(cancellationCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            if (Volatile.Read(ref open))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        static void CancellationCallback(object? state)
        {
            var self = (_SkipUntil)state!;
            Volatile.Write(ref self.open, true);
        }

        protected override void DisposeCore()
        {
            tokenRegistration.Dispose();
        }
    }
}

internal sealed class SkipUntilT<T>(Observable<T> source, Task task, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipUntil(observer, task, configureAwait));
    }

    sealed class _SkipUntil : Observer<T>, IDisposable
    {
        readonly bool configureAwait;
        readonly Observer<T> observer;
        bool open;

        public _SkipUntil(Observer<T> observer, Task task, bool configureAwait)
        {
            this.configureAwait = configureAwait;
            this.observer = observer;
            TaskAwait(task);
        }

        protected override void OnNextCore(T value)
        {
            if (Volatile.Read(ref open))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        async void TaskAwait(Task task)
        {
            try
            {
                await task.ConfigureAwait(configureAwait);
                Volatile.Write(ref open, true);
            }
            catch (Exception ex)
            {
                OnCompleted(Result.Failure(ex));
            }
        }
    }
}

internal sealed class SkipUntilAsync<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipUntil(observer, asyncFunc, configureAwait));
    }

    sealed class _SkipUntil(Observer<T> observer, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait) : Observer<T>, IDisposable
    {
        readonly CancellationTokenSource cancellationTokenSource = new();
        int isTaskRunning;
        bool open;

        protected override void OnNextCore(T value)
        {
            var isFirstValue = (Interlocked.Exchange(ref isTaskRunning, 1) == 0);
            if (isFirstValue)
            {
                TaskStart(value);
            }

            if (Volatile.Read(ref open))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel(); // cancel executing async process first
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void TaskStart(T value)
        {
            try
            {
                await asyncFunc(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }

                // error is Stop
                observer.OnCompleted(Result.Failure(ex));
                return;
            }

            Volatile.Write(ref open, true);
        }
    }
}




================================================
FILE: src/R3/Operators/SkipWhile.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> SkipWhile<T>(this Observable<T> source, Func<T, bool> predicate)
    {
        return new SkipWhile<T>(source, predicate);
    }

    public static Observable<T> SkipWhile<T>(this Observable<T> source, Func<T, int, bool> predicate)
    {
        return new SkipWhileI<T>(source, predicate);
    }
}

internal sealed class SkipWhile<T>(Observable<T> source, Func<T, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipWhile(observer, predicate));
    }

    sealed class _SkipWhile(Observer<T> observer, Func<T, bool> predicate) : Observer<T>, IDisposable
    {
        bool open;

        protected override void OnNextCore(T value)
        {
            if (open)
            {
                observer.OnNext(value);
            }
            else if (!predicate(value))
            {
                open = true;
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class SkipWhileI<T>(Observable<T> source, Func<T, int, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _SkipWhile(observer, predicate));
    }

    sealed class _SkipWhile(Observer<T> observer, Func<T, int, bool> predicate) : Observer<T>, IDisposable
    {
        int count;
        bool open;

        protected override void OnNextCore(T value)
        {
            if (open)
            {
                observer.OnNext(value);
            }
            else if (!predicate(value, count++))
            {
                open = true;
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/SubscribeAwait.cs
================================================
﻿using System;
using System.Threading.Channels;

namespace R3;

public static partial class ObservableExtensions
{
    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static IDisposable SubscribeAwait<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> onNextAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return SubscribeAwait(source, onNextAsync, ObservableSystem.GetUnhandledExceptionHandler(), Stubs.HandleResult, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }

    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static IDisposable SubscribeAwait<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> onNextAsync, Action<Result> onCompleted, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return SubscribeAwait(source, onNextAsync, ObservableSystem.GetUnhandledExceptionHandler(), onCompleted, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }

    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static IDisposable SubscribeAwait<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        switch (awaitOperation)
        {
            case AwaitOperation.Sequential:
                return source.Subscribe(new SubscribeAwaitSequential<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.Drop:
                return source.Subscribe(new SubscribeAwaitDrop<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.Parallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new SubscribeAwaitParallel<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new SubscribeAwaitParallelConcurrentLimit<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted, maxConcurrent));
                }
            case AwaitOperation.Switch:
                return source.Subscribe(new SubscribeAwaitSwitch<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.SequentialParallel:
                throw new ArgumentException("SubscribeAwait does not support SequentialParallel. Use Sequential for sequential operation, use parallel for parallel operation instead.");
            case AwaitOperation.ThrottleFirstLast:
                return source.Subscribe(new SubscribeAwaitThrottleFirstLast<T>(onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            default:
                throw new ArgumentException();
        }
    }

    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static IDisposable SubscribeAwait<T, TState>(this Observable<T> source, TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return SubscribeAwait(source, state, onNextAsync, Stubs<TState>.HandleException, Stubs<TState>.HandleResult, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }

    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static IDisposable SubscribeAwait<T, TState>(this Observable<T> source, TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Result, TState> onCompleted, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return SubscribeAwait(source, state, onNextAsync, Stubs<TState>.HandleException, onCompleted, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }

    public static IDisposable SubscribeAwait<T, TState>(this Observable<T> source, TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        switch (awaitOperation)
        {
            case AwaitOperation.Sequential:
                return source.Subscribe(new SubscribeAwaitSequential<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.Drop:
                return source.Subscribe(new SubscribeAwaitDrop<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.Parallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new SubscribeAwaitParallel<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new SubscribeAwaitParallelConcurrentLimit<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted, maxConcurrent));
                }
            case AwaitOperation.Switch:
                return source.Subscribe(new SubscribeAwaitSwitch<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            case AwaitOperation.SequentialParallel:
                throw new ArgumentException("SubscribeAwait does not support SequentialParallel. Use Sequential for sequential operation, use parallel for parallel operation instead.");
            case AwaitOperation.ThrottleFirstLast:
                return source.Subscribe(new SubscribeAwaitThrottleFirstLast<T, TState>(state, onNextAsync, onErrorResume, onCompleted, configureAwait, cancelOnCompleted));
            default:
                throw new ArgumentException();
        }
    }
}

internal sealed class SubscribeAwaitSequential<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationSequentialObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result);
    }
}

internal sealed class SubscribeAwaitSequential<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationSequentialObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error, state);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result, state);
    }
}

internal sealed class SubscribeAwaitDrop<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationDropObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result);
    }
}

internal sealed class SubscribeAwaitDrop<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationDropObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error, state);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result, state);
    }
}

sealed class SubscribeAwaitParallel<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationParallelObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result);
        }
    }
}

sealed class SubscribeAwaitParallel<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationParallelObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error, state);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result, state);
        }
    }
}

sealed class SubscribeAwaitSwitch<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationSwitchObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result);
        }
    }
}

sealed class SubscribeAwaitSwitch<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationSwitchObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error, state);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result, state);
        }
    }
}

sealed class SubscribeAwaitParallelConcurrentLimit<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
    : AwaitOperationParallelConcurrentLimitObserver<T>(configureAwait, cancelOnCompleted, maxConcurrent)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result);
        }
    }
}

sealed class SubscribeAwaitParallelConcurrentLimit<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
    : AwaitOperationParallelConcurrentLimitObserver<T>(configureAwait, cancelOnCompleted, maxConcurrent)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        lock (gate)
        {
            onErrorResume(error, state);
        }
    }

    protected override void PublishOnCompleted(Result result)
    {
        lock (gate)
        {
            onCompleted(result, state);
        }
    }
}

internal sealed class SubscribeAwaitThrottleFirstLast<T>(Func<T, CancellationToken, ValueTask> onNextAsync, Action<Exception> onErrorResume, Action<Result> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationThrottleFirstLastObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result);
    }
}

internal sealed class SubscribeAwaitThrottleFirstLast<T, TState>(TState state, Func<T, TState, CancellationToken, ValueTask> onNextAsync, Action<Exception, TState> onErrorResume, Action<Result, TState> onCompleted, bool configureAwait, bool cancelOnCompleted)
    : AwaitOperationThrottleFirstLastObserver<T>(configureAwait, cancelOnCompleted)
{
    protected override ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
    {
        return onNextAsync(value, state, cancellationToken);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        onErrorResume(error, state);
    }

    protected override void PublishOnCompleted(Result result)
    {
        onCompleted(result, state);
    }
}



================================================
FILE: src/R3/Operators/SubscribeOn.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> SubscribeOnCurrentSynchronizationContext<T>(this Observable<T> source)
    {
        return SubscribeOn<T>(source, SynchronizationContext.Current);
    }

    public static Observable<T> SubscribeOnThreadPool<T>(this Observable<T> source)
    {
        return new SubscribeOnThreadPool<T>(source);
    }

    public static Observable<T> SubscribeOnSynchronize<T>(this Observable<T> source, object gate, bool rawObserver = false)
    {
        return new SubscribeOnSynchronize<T>(source, gate, rawObserver);
    }

    public static Observable<T> SubscribeOn<T>(this Observable<T> source, SynchronizationContext? synchronizationContext)
    {
        if (synchronizationContext == null)
        {
            return new SubscribeOnThreadPool<T>(source); // use ThreadPool instead
        }

        return new SubscribeOnSynchronizationContext<T>(source, synchronizationContext);
    }

    public static Observable<T> SubscribeOn<T>(this Observable<T> source, TimeProvider timeProvider)
    {
        if (timeProvider == TimeProvider.System)
        {
            return new SubscribeOnThreadPool<T>(source);
        }

        return new SubscribeOnTimeProvider<T>(source, timeProvider);
    }

    public static Observable<T> SubscribeOn<T>(this Observable<T> source, FrameProvider frameProvider)
    {
        return new SubscribeOnFrameProvider<T>(source, frameProvider);
    }
}

internal sealed class SubscribeOnSynchronizationContext<T>(Observable<T> source, SynchronizationContext synchronizationContext) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOn(observer, source, synchronizationContext).Run();
    }

    sealed class _SubscribeOn : Observer<T>
    {
        static readonly SendOrPostCallback postCallback = Subscribe;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly SynchronizationContext synchronizationContext;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOn(Observer<T> observer, Observable<T> source, SynchronizationContext synchronizationContext)
        {
            this.observer = observer;
            this.source = source;
            this.synchronizationContext = synchronizationContext;
        }

        public IDisposable Run()
        {
            synchronizationContext.Post(postCallback, this);
            return this;
        }

        static void Subscribe(object? state)
        {
            var self = (_SubscribeOn)state!;
            self.disposable.Disposable = self.source.Subscribe(self);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}

internal sealed class SubscribeOnThreadPool<T>(Observable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOn(observer, source).Run();
    }

    sealed class _SubscribeOn : Observer<T>, IThreadPoolWorkItem
    {
        readonly Observer<T> observer;
        readonly Observable<T> source;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOn(Observer<T> observer, Observable<T> source)
        {
            this.observer = observer;
            this.source = source;
        }

        public IDisposable Run()
        {
            ThreadPool.UnsafeQueueUserWorkItem(this, preferLocal: false);
            return this;
        }

        public void Execute()
        {
            try
            {
                disposable.Disposable = source.Subscribe(this);
            }
            catch (Exception ex)
            {
                ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                Dispose();
            }
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}

internal sealed class SubscribeOnSynchronize<T>(Observable<T> source, object gate, bool rawObserver) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        observer = rawObserver ? observer : observer.Wrap();
        lock (gate)
        {
            return source.Subscribe(observer);
        }
    }
}

internal sealed class SubscribeOnTimeProvider<T>(Observable<T> source, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOn(observer, source, timeProvider).Run();
    }

    sealed class _SubscribeOn : Observer<T>
    {
        static readonly TimerCallback timerCallback = Subscribe;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly TimeProvider timeProvider;
        readonly ITimer timer;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOn(Observer<T> observer, Observable<T> source, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.source = source;
            this.timeProvider = timeProvider;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        public IDisposable Run()
        {
            timer.RestartImmediately();
            return this;
        }

        static void Subscribe(object? state)
        {
            var self = (_SubscribeOn)state!;
            self.disposable.Disposable = self.source.Subscribe(self);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
            disposable.Dispose();
        }
    }
}

internal sealed class SubscribeOnFrameProvider<T>(Observable<T> source, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOn(observer, source, frameProvider).Run();
    }

    sealed class _SubscribeOn : Observer<T>, IFrameRunnerWorkItem
    {
        static readonly SendOrPostCallback postCallback = Subscribe;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly FrameProvider frameProvider;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOn(Observer<T> observer, Observable<T> source, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.source = source;
            this.frameProvider = frameProvider;
        }

        public IDisposable Run()
        {
            frameProvider.Register(this);
            return this;
        }

        static void Subscribe(object? state)
        {
            var self = (_SubscribeOn)state!;
            self.disposable.Disposable = self.source.Subscribe(self);
        }

        bool IFrameRunnerWorkItem.MoveNext(long frameCount)
        {
            if (disposable.IsDisposed) return false;

            disposable.Disposable = source.Subscribe(this);
            return false;
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}



================================================
FILE: src/R3/Operators/SumAsync.cs
================================================

namespace R3;

using System.Numerics;

public static partial class ObservableExtensions
{
    public static Task<int> SumAsync(this Observable<int> source, CancellationToken cancellationToken = default)
    {
        var method = new SumInt32Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<int> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, int> selector, CancellationToken cancellationToken = default)
    {
        var method = new SumInt32Async<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<long> SumAsync(this Observable<long> source, CancellationToken cancellationToken = default)
    {
        var method = new SumInt64Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<long> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, long> selector, CancellationToken cancellationToken = default)
    {
        var method = new SumInt64Async<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<float> SumAsync(this Observable<float> source, CancellationToken cancellationToken = default)
    {
        var method = new SumFloatAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<float> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, float> selector, CancellationToken cancellationToken = default)
    {
        var method = new SumFloatAsync<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> SumAsync(this Observable<double> source, CancellationToken cancellationToken = default)
    {
        var method = new SumDoubleAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<double> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, double> selector, CancellationToken cancellationToken = default)
    {
        var method = new SumDoubleAsync<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<decimal> SumAsync(this Observable<decimal> source, CancellationToken cancellationToken = default)
    {
        var method = new SumDecimalAsync(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<decimal> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, decimal> selector, CancellationToken cancellationToken = default)
    {
        var method = new SumDecimalAsync<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }


#if NET8_0_OR_GREATER
    public static Task<T> SumAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
        where T : INumberBase<T>
    {
        var method = new SumNumberAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> SumAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
        where TResult : INumberBase<TResult>
    {
        var method = new SumNumberAsync<TSource, TResult>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
#endif
}

internal sealed class SumInt32Async(CancellationToken cancellationToken) : TaskObserverBase<int, int>(cancellationToken)
{
    int sum;

    protected override void OnNextCore(int value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class SumInt32Async<TSource>(Func<TSource, int> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, int>(cancellationToken)
{
    int sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
internal sealed class SumInt64Async(CancellationToken cancellationToken) : TaskObserverBase<long, long>(cancellationToken)
{
    long sum;

    protected override void OnNextCore(long value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class SumInt64Async<TSource>(Func<TSource, long> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, long>(cancellationToken)
{
    long sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
internal sealed class SumFloatAsync(CancellationToken cancellationToken) : TaskObserverBase<float, float>(cancellationToken)
{
    float sum;

    protected override void OnNextCore(float value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class SumFloatAsync<TSource>(Func<TSource, float> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, float>(cancellationToken)
{
    float sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
internal sealed class SumDoubleAsync(CancellationToken cancellationToken) : TaskObserverBase<double, double>(cancellationToken)
{
    double sum;

    protected override void OnNextCore(double value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class SumDoubleAsync<TSource>(Func<TSource, double> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, double>(cancellationToken)
{
    double sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
internal sealed class SumDecimalAsync(CancellationToken cancellationToken) : TaskObserverBase<decimal, decimal>(cancellationToken)
{
    decimal sum;

    protected override void OnNextCore(decimal value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class SumDecimalAsync<TSource>(Func<TSource, decimal> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, decimal>(cancellationToken)
{
    decimal sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}

#if NET8_0_OR_GREATER
internal sealed class SumNumberAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, T>(cancellationToken)
    where T : INumberBase<T>
{
    T sum = T.Zero;

    protected override void OnNextCore(T value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}

internal sealed class SumNumberAsync<TSource, TResult>(Func<TSource, TResult> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, TResult>(cancellationToken)
    where TResult : INumberBase<TResult>
{
    TResult sum = TResult.Zero;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
#endif



================================================
FILE: src/R3/Operators/SumAsync.tt
================================================
<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var typeNames = new[]
    {
        ("int", "Int32"),
        ("long", "Int64"),
        ("float", "Float"),
        ("double", "Double"),
        ("decimal", "Decimal")
    };
#>

namespace R3;

using System.Numerics;

public static partial class ObservableExtensions
{
<# foreach (var (t, typeSuffix) in typeNames) { #>
    public static Task<<#= t #>> SumAsync(this Observable<<#= t #>> source, CancellationToken cancellationToken = default)
    {
        var method = new Sum<#= typeSuffix #>Async(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<<#= t #>> SumAsync<TSource>(this Observable<TSource> source, Func<TSource, <#= t #>> selector, CancellationToken cancellationToken = default)
    {
        var method = new Sum<#= typeSuffix #>Async<TSource>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

<# } #>

#if NET8_0_OR_GREATER
    public static Task<T> SumAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
        where T : INumberBase<T>
    {
        var method = new SumNumberAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<TResult> SumAsync<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector, CancellationToken cancellationToken = default)
        where TResult : INumberBase<TResult>
    {
        var method = new SumNumberAsync<TSource, TResult>(selector, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
#endif
}

<# foreach (var (t, typeSuffix) in typeNames) { #>
internal sealed class Sum<#= typeSuffix #>Async(CancellationToken cancellationToken) : TaskObserverBase<<#= t #>, <#= t #>>(cancellationToken)
{
    <#= t #> sum;

    protected override void OnNextCore(<#= t #> value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(sum);
    }
}

internal sealed class Sum<#= typeSuffix #>Async<TSource>(Func<TSource, <#= t #>> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, <#= t #>>(cancellationToken)
{
    <#= t #> sum;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
<# } #>

#if NET8_0_OR_GREATER
internal sealed class SumNumberAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, T>(cancellationToken)
    where T : INumberBase<T>
{
    T sum = T.Zero;

    protected override void OnNextCore(T value)
    {
        sum = checked(sum + value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}

internal sealed class SumNumberAsync<TSource, TResult>(Func<TSource, TResult> selector, CancellationToken cancellationToken) : TaskObserverBase<TSource, TResult>(cancellationToken)
    where TResult : INumberBase<TResult>
{
    TResult sum = TResult.Zero;

    protected override void OnNextCore(TSource value)
    {
        var add = selector(value);
        sum = checked(sum + add);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(sum);
    }
}
#endif



================================================
FILE: src/R3/Operators/Switch.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Switch<T>(this Observable<Observable<T>> sources)
    {
        return new Switch<T>(sources);
    }
}

internal sealed class Switch<T>(Observable<Observable<T>> sources) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return sources.Subscribe(new _Switch(observer));
    }

    sealed class _Switch(Observer<T> observer) : Observer<Observable<T>>
    {
        public Observer<T> observer = observer;
        public readonly object gate = new object();

        SerialDisposableCore subscription;
        public ulong id;
        public bool runningInner;
        public bool stoppedOuter;

        // keep when inner is running
        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(Observable<T> value)
        {
            var innerId = default(ulong);
            lock (gate)
            {
                innerId = id = unchecked(id + 1);
                runningInner = true;
            }

            // subscribe new inner with id token
            var observer = new SwitchObserver(this, innerId);
            subscription.Disposable = observer; // dispose before observer first(set to SerialiDisposable).
            value.Subscribe(observer);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                if (result.IsFailure)
                {
                    try
                    {
                        observer.OnCompleted(result);
                    }
                    finally
                    {
                        Dispose();
                    }
                    return;
                }

                // stop both outer and inner, complete.
                stoppedOuter = true;
                if (!runningInner)
                {
                    try
                    {
                        observer.OnCompleted();
                    }
                    finally
                    {
                        Dispose();
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            subscription.Dispose();
        }
    }

    sealed class SwitchObserver(_Switch parent, ulong id) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            lock (parent.gate)
            {
                if (parent.id == id) // if not matched, subscribe new inner has been started
                {
                    parent.observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (parent.gate)
            {
                if (parent.id == id)
                {
                    parent.observer.OnErrorResume(error);
                }
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (parent.gate)
            {
                if (parent.id == id)
                {
                    if (result.IsFailure)
                    {
                        parent.observer.OnCompleted(result);
                    }
                    else
                    {
                        // if already outer is stopped, complete.
                        parent.runningInner = false;
                        if (parent.stoppedOuter)
                        {
                            parent.observer.OnCompleted(result);
                        }
                    }
                }
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Synchronize.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Synchronize<T>(this Observable<T> source)
    {
        return new Synchronize<T>(source, new object());
    }

    public static Observable<T> Synchronize<T>(this Observable<T> source, object gate)
    {
        return new Synchronize<T>(source, gate);
    }
}


internal sealed class Synchronize<T>(Observable<T> source, object gate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Synchronize(observer, gate));
    }

    sealed class _Synchronize(Observer<T> observer, object gate) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Take.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Take<T>(this Observable<T> source, int count)
    {
        if (count < 0) throw new ArgumentOutOfRangeException("count");

        if (count == 0)
        {
            return Observable.Empty<T>();
        }

        return new Take<T>(source, count);
    }

    // TimeBased

    public static Observable<T> Take<T>(this Observable<T> source, TimeSpan duration)
    {
        return Take(source, duration, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> Take<T>(this Observable<T> source, TimeSpan duration, TimeProvider timeProvider)
    {
        return new TakeTime<T>(source, duration.Normalize(), timeProvider);
    }

    // TakeFrame

    public static Observable<T> TakeFrame<T>(this Observable<T> source, int frameCount)
    {
        return TakeFrame(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> TakeFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new TakeFrame<T>(source, frameCount.NormalizeFrame(), frameProvider);
    }
}

internal sealed class Take<T>(Observable<T> source, int count) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Take(observer, count));
    }

    sealed class _Take(Observer<T> observer, int count) : Observer<T>, IDisposable
    {
        int remaining = count;

        protected override void OnNextCore(T value)
        {
            if (remaining > 0)
            {
                remaining--;
                observer.OnNext(value);
                if (remaining == 0)
                {
                    observer.OnCompleted();
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class TakeTime<T>(Observable<T> source, TimeSpan duration, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeTime(observer, duration, timeProvider));
    }

    sealed class _TakeTime : Observer<T>, IDisposable
    {
        static readonly TimerCallback timerCallback = TimerStopped;

        readonly Observer<T> observer;
        readonly ITimer timer;
        readonly object gate = new object();

        public _TakeTime(Observer<T> observer, TimeSpan duration, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
            timer.InvokeOnce(duration);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }

        static void TimerStopped(object? state)
        {
            var self = (_TakeTime)state!;
            self.OnCompleted();
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }
    }
}

internal sealed class TakeFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeFrame(observer, frameCount, frameProvider));
    }

    sealed class _TakeFrame : Observer<T>, IDisposable, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        long remaining;
        readonly object gate = new object();

        public _TakeFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.remaining = frameProvider.GetFrameCount() + frameCount;
            frameProvider.Register(this);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            if (remaining > 0)
            {
                remaining--;
                if (remaining == 0)
                {
                    OnCompleted(Result.Success);
                    return false;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }
    }
}



================================================
FILE: src/R3/Operators/TakeLast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> TakeLast<T>(this Observable<T> source, int count)
    {
        if (count < 0) throw new ArgumentOutOfRangeException("count");
        return new TakeLast<T>(source, count);
    }

    // TimeBased

    public static Observable<T> TakeLast<T>(this Observable<T> source, TimeSpan duration)
    {
        return TakeLast(source, duration, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> TakeLast<T>(this Observable<T> source, TimeSpan duration, TimeProvider timeProvider)
    {
        return new TakeLastTime<T>(source, duration.Normalize(), timeProvider);
    }

    // TakeLastFrame

    public static Observable<T> TakeLastFrame<T>(this Observable<T> source, int frameCount)
    {
        return TakeLastFrame(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> TakeLastFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new TakeLastFrame<T>(source, frameCount.NormalizeFrame(), frameProvider);
    }
}

internal sealed class TakeLast<T>(Observable<T> source, int count) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeLast(observer, count));
    }

    sealed class _TakeLast(Observer<T> observer, int count) : Observer<T>, IDisposable
    {
        Queue<T> queue = new Queue<T>(count);
        bool takeCompleted = false;

        protected override void OnNextCore(T value)
        {
            lock (queue)
            {
                if (takeCompleted) return;

                if (queue.Count == count && queue.Count != 0)
                {
                    queue.Dequeue();
                }
                queue.Enqueue(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                return;
            }

            lock (queue)
            {
                takeCompleted = true;

                foreach (var item in queue)
                {
                    observer.OnNext(item);
                    if (IsDisposed) return; // sometimes called Clear during iterating
                }
            }

            observer.OnCompleted();
        }

        protected override void DisposeCore()
        {
            lock (queue)
            {
                queue.Clear();
            }
        }
    }
}

internal sealed class TakeLastTime<T>(Observable<T> source, TimeSpan duration, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeLastTime(observer, duration, timeProvider));
    }

    sealed class _TakeLastTime : Observer<T>, IDisposable
    {
        readonly Observer<T> observer;
        readonly object gate = new object();
        readonly Queue<(long timestamp, T value)> queue = new();
        readonly TimeSpan duration;
        readonly TimeProvider timeProvider;
        bool takeCompleted = false;

        public _TakeLastTime(Observer<T> observer, TimeSpan duration, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeProvider = timeProvider;
            this.duration = duration;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if(takeCompleted) return;
                var current = timeProvider.GetTimestamp();
                queue.Enqueue((current, value));
                Trim(current);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                takeCompleted = true;

                if (result.IsFailure)
                {
                    observer.OnCompleted(result);
                    return;
                }

                Trim(timeProvider.GetTimestamp());
                foreach (var item in queue)
                {
                    observer.OnNext(item.value);
                    if (IsDisposed) return; // sometimes called Clear during iterating
                }
                observer.OnCompleted();
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                queue.Clear();
            }
        }

        void Trim(long currentTimestamp)
        {
            while (queue.Count > 0 && timeProvider.GetElapsedTime(queue.Peek().timestamp, currentTimestamp) > duration)
            {
                queue.Dequeue();
            }
        }
    }
}

internal sealed class TakeLastFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeLastFrame(observer, frameCount, frameProvider));
    }

    sealed class _TakeLastFrame : Observer<T>, IDisposable
    {
        readonly Observer<T> observer;
        readonly object gate = new object();
        readonly Queue<(long frameCount, T value)> queue = new();
        readonly int frameCount;
        readonly FrameProvider frameProvider;
        bool takeCompleted = false;

        public _TakeLastFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (takeCompleted) return;

                var current = frameProvider.GetFrameCount();
                queue.Enqueue((current, value));
                Trim(current);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void OnCompletedCore(Result result)
        {
            lock (gate)
            {
                takeCompleted = true;

                if (result.IsFailure)
                {
                    observer.OnCompleted(result);
                    return;
                }

                Trim(frameProvider.GetFrameCount());
                foreach (var item in queue)
                {
                    observer.OnNext(item.value);
                    if (IsDisposed) return; // sometimes called Clear during iterating
                }
                observer.OnCompleted();
            }
        }

        void Trim(long currentFrameCount)
        {
            while (queue.Count > 0 && currentFrameCount - queue.Peek().frameCount > frameCount)
            {
                queue.Dequeue();
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                queue.Clear();
            }
        }
    }
}



================================================
FILE: src/R3/Operators/TakeUntil.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> TakeUntil<T, TOther>(this Observable<T> source, Observable<TOther> other)
    {
        return new TakeUntil<T, TOther>(source, other);
    }

    public static Observable<T> TakeUntil<T>(this Observable<T> source, CancellationToken cancellationToken)
    {
        if (!cancellationToken.CanBeCanceled)
        {
            return source;
        }
        if (cancellationToken.IsCancellationRequested)
        {
            return Observable.Empty<T>();
        }

        return new TakeUntilC<T>(source, cancellationToken);
    }

    public static Observable<T> TakeUntil<T>(this Observable<T> source, Task task, bool configureAwait = true)
    {
        return new TakeUntilT<T>(source, task, configureAwait);
    }

    public static Observable<T> TakeUntil<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait = true)
    {
        return new TakeUntilAsync<T>(source, asyncFunc, configureAwait);
    }

    public static Observable<T> TakeUntil<T>(this Observable<T> source, Func<T, bool> predicate)
    {
        return new TakeUntil<T>(source, predicate);
    }

    public static Observable<T> TakeUntil<T>(this Observable<T> source, Func<T, int, bool> predicate)
    {
        return new TakeUntilI<T>(source, predicate);
    }
}

internal sealed class TakeUntil<T, TOther>(Observable<T> source, Observable<TOther> other) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        var takeUntil = new _TakeUntil(observer);
        var stopperSubscription = other.Subscribe(takeUntil.stopper);
        try
        {
            return source.Subscribe(takeUntil); // subscription contains self and stopper.
        }
        catch
        {
            stopperSubscription.Dispose();
            throw;
        }
    }

    sealed class _TakeUntil : Observer<T>
    {
        readonly Observer<T> observer;
        internal readonly TakeUntilStopperObserver stopper;

        public _TakeUntil(Observer<T> observer)
        {
            this.observer = observer;
            this.stopper = new TakeUntilStopperObserver(this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            stopper.Dispose();
        }
    }

    sealed class TakeUntilStopperObserver(_TakeUntil parent) : Observer<TOther>
    {
        protected override void OnNextCore(TOther value)
        {
            parent.OnCompleted(Result.Success);
            Dispose();
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            parent.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            parent.OnCompleted(result);
        }
    }
}

internal sealed class TakeUntilC<T>(Observable<T> source, CancellationToken cancellationToken) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeUntil(observer, cancellationToken));
    }

    sealed class _TakeUntil : Observer<T>, IDisposable
    {
        static readonly Action<object?> cancellationCallback = CancellationCallback;

        readonly Observer<T> observer;
        CancellationTokenRegistration tokenRegistration;

        public _TakeUntil(Observer<T> observer, CancellationToken cancellationToken)
        {
            this.observer = observer;
            this.tokenRegistration = cancellationToken.Register(cancellationCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        static void CancellationCallback(object? state)
        {
            var self = (_TakeUntil)state!;
            self.OnCompleted();
        }

        protected override void DisposeCore()
        {
            tokenRegistration.Dispose();
        }
    }
}

internal sealed class TakeUntilT<T>(Observable<T> source, Task task, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeUntil(observer, task, configureAwait));
    }

    sealed class _TakeUntil : Observer<T>, IDisposable
    {
        readonly Observer<T> observer;
        readonly bool configureAwait;

        public _TakeUntil(Observer<T> observer, Task task, bool configureAwait)
        {
            this.observer = observer;
            this.configureAwait = configureAwait;
            TaskAwait(task);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        async void TaskAwait(Task task)
        {
            try
            {
                await task.ConfigureAwait(configureAwait);
                OnCompleted(Result.Success);
            }
            catch (Exception ex)
            {
                OnCompleted(Result.Failure(ex));
            }
        }
    }
}

internal sealed class TakeUntilAsync<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeUntil(observer, asyncFunc, configureAwait));
    }

    sealed class _TakeUntil(Observer<T> observer, Func<T, CancellationToken, ValueTask> asyncFunc, bool configureAwait) : Observer<T>, IDisposable
    {
        readonly CancellationTokenSource cancellationTokenSource = new();
        int isTaskRunning;

        protected override void OnNextCore(T value)
        {
            var isFirstValue = (Interlocked.Exchange(ref isTaskRunning, 1) == 0);
            if (isFirstValue)
            {
                TaskStart(value);
            }

            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel(); // cancel executing async process first
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void TaskStart(T value)
        {

            try
            {
                await asyncFunc(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }

                // error is Stop
                observer.OnCompleted(Result.Failure(ex));
                return;
            }

            observer.OnCompleted();
        }
    }
}

internal sealed class TakeUntil<T>(Observable<T> source, Func<T, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeUntil(observer, predicate));
    }

    sealed class _TakeUntil(Observer<T> observer, Func<T, bool> predicate) : Observer<T>, IDisposable
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);

            if (predicate(value))
            {
                observer.OnCompleted();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class TakeUntilI<T>(Observable<T> source, Func<T, int, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeUntil(observer, predicate));
    }

    sealed class _TakeUntil(Observer<T> observer, Func<T, int, bool> predicate) : Observer<T>, IDisposable
    {
        int count;

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);

            if (predicate(value, count++))
            {
                observer.OnCompleted();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/TakeWhile.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> TakeWhile<T>(this Observable<T> source, Func<T, bool> predicate)
    {
        return new TakeWhile<T>(source, predicate);
    }

    public static Observable<T> TakeWhile<T>(this Observable<T> source, Func<T, int, bool> predicate)
    {
        return new TakeWhileI<T>(source, predicate);
    }
}

internal sealed class TakeWhile<T>(Observable<T> source, Func<T, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeWhile(observer, predicate));
    }

    sealed class _TakeWhile(Observer<T> observer, Func<T, bool> predicate) : Observer<T>, IDisposable
    {
        protected override void OnNextCore(T value)
        {
            if (predicate(value))
            {
                observer.OnNext(value);
            }
            else
            {
                observer.OnCompleted();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class TakeWhileI<T>(Observable<T> source, Func<T, int, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TakeWhile(observer, predicate));
    }

    sealed class _TakeWhile(Observer<T> observer, Func<T, int, bool> predicate) : Observer<T>, IDisposable
    {
        int count;

        protected override void OnNextCore(T value)
        {
            if (predicate(value, count++))
            {
                observer.OnNext(value);
            }
            else
            {
                observer.OnCompleted();
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleFirst.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleFirst<T>(this Observable<T> source, TimeSpan timeSpan)
    {
        return new ThrottleFirst<T>(source, timeSpan, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> ThrottleFirst<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider)
    {
        return new ThrottleFirst<T>(source, timeSpan, timeProvider);
    }

    public static Observable<T> ThrottleFirst<T, TSample>(this Observable<T> source, Observable<TSample> sampler)
    {
        return new ThrottleFirstObservableSampler<T, TSample>(source, sampler);
    }

    public static Observable<T> ThrottleFirst<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait = true)
    {
        return new ThrottleFirstAsyncSampler<T>(source, sampler, configureAwait);
    }
}

internal sealed class ThrottleFirst<T>(Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirst(observer, timeSpan.Normalize(), timeProvider));
    }

    sealed class _ThrottleFirst : Observer<T>
    {
        static readonly TimerCallback timerCallback = OpenGate;

        readonly Observer<T> observer;
        readonly ITimer timer;
        readonly TimeSpan timeSpan;
        readonly object gate = new object();
        bool closing;

        public _ThrottleFirst(Observer<T> observer, TimeSpan timeSpan, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
            this.timeSpan = timeSpan;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!closing)
                {
                    closing = true;
                    timer.InvokeOnce(timeSpan); // timer start before OnNext
                    observer.OnNext(value);     // call OnNext in lock
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void OpenGate(object? state)
        {
            var self = (_ThrottleFirst)state!;
            lock (self.gate)
            {
                self.closing = false;
            }
        }
    }
}

internal sealed class ThrottleFirstAsyncSampler<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirst(observer, sampler, configureAwait));
    }

    sealed class _ThrottleFirst(Observer<T> observer, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observer<T>
    {
        readonly object gate = new object();
        readonly CancellationTokenSource cancellationTokenSource = new();
        bool closing;

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!closing)
                {
                    closing = true;
                    StartOpenGate(value);
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel(); // cancel executing async process first
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void StartOpenGate(T value)
        {
            try
            {
                await sampler(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }
                OnErrorResume(ex);
            }
            finally
            {
                lock (gate)
                {
                    closing = false;
                }
            }
        }
    }
}

internal sealed class ThrottleFirstObservableSampler<T, TSample>(Observable<T> source, Observable<TSample> sampler) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirst(observer, sampler));
    }

    sealed class _ThrottleFirst : Observer<T>
    {
        readonly Observer<T> observer;
        readonly object gate = new object();
        readonly IDisposable samplerSubscription;
        bool closing;

        public _ThrottleFirst(Observer<T> observer, Observable<TSample> sampler)
        {
            this.observer = observer;
            var sampleObserver = new SamplerObserver(this);
            this.samplerSubscription = sampler.Subscribe(sampleObserver);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!closing)
                {
                    closing = true;
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            samplerSubscription.Dispose();
        }

        sealed class SamplerObserver(_ThrottleFirst parent) : Observer<TSample>
        {
            protected override void OnNextCore(TSample value)
            {
                lock (parent.gate)
                {
                    parent.closing = false; // open gate
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.OnCompleted(result);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleFirstFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleFirstFrame<T>(this Observable<T> source, int frameCount)
    {
        return new ThrottleFirstFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> ThrottleFirstFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new ThrottleFirstFrame<T>(source, frameCount, frameProvider);
    }
}

// ThrottleFirstFrame
internal sealed class ThrottleFirstFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirstFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _ThrottleFirstFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly int frameCount;
        readonly FrameProvider frameProvider;
        readonly object gate = new object();
        int currentFrame;
        bool closing;

        public _ThrottleFirstFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!closing)
                {
                    closing = true;
                    observer.OnNext(value);
                    currentFrame = 0;
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (++currentFrame == frameCount)
                {
                    closing = false;
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleFirstLast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleFirstLast<T>(this Observable<T> source, TimeSpan timeSpan)
    {
        return new ThrottleFirstLast<T>(source, timeSpan, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> ThrottleFirstLast<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider)
    {
        return new ThrottleFirstLast<T>(source, timeSpan, timeProvider);
    }

    public static Observable<T> ThrottleFirstLast<T, TSample>(this Observable<T> source, Observable<TSample> sampler)
    {
        return new ThrottleFirstLastObservableSampler<T, TSample>(source, sampler);
    }

    public static Observable<T> ThrottleFirstLast<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait = true)
    {
        return new ThrottleFirstLastAsyncSampler<T>(source, sampler, configureAwait);
    }
}

internal sealed class ThrottleFirstLast<T>(Observable<T> source, TimeSpan interval, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirstLast(observer, interval.Normalize(), timeProvider));
    }

    sealed class _ThrottleFirstLast : Observer<T>
    {
        static readonly TimerCallback timerCallback = RaiseOnNext;

        readonly Observer<T> observer;
        readonly TimeSpan interval;
        readonly ITimer timer;
        readonly object gate = new object();
        T? lastValue;
        bool hasValue;
        bool timerIsRunning;

        public _ThrottleFirstLast(Observer<T> observer, TimeSpan interval, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.interval = interval;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!timerIsRunning) // timer is stopping
                {
                    timerIsRunning = true;
                    timer.InvokeOnce(interval); // timer start before OnNext
                    observer.OnNext(value);     // call OnNext in lock
                    return;
                }
                else
                {
                    hasValue = true;
                    lastValue = value;
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void RaiseOnNext(object? state)
        {
            var self = (_ThrottleFirstLast)state!;
            lock (self.gate)
            {
                self.timerIsRunning = false;
                if (self.hasValue)
                {
                    self.observer.OnNext(self.lastValue!);
                    self.hasValue = false;
                    self.lastValue = default;
                }
            }
        }
    }
}

internal sealed class ThrottleFirstLastAsyncSampler<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirstLast(observer, sampler, configureAwait));
    }

    sealed class _ThrottleFirstLast(Observer<T> observer, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observer<T>
    {
        readonly object gate = new object();
        readonly CancellationTokenSource cancellationTokenSource = new();
        T? lastValue;
        bool hasValue;
        bool isRunning;

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!isRunning)
                {
                    isRunning = true;
                    RaiseOnNextAsync(value);
                    observer.OnNext(value);
                }
                else
                {
                    hasValue = true;
                    lastValue = value;
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel(); // cancel executing async process first
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void RaiseOnNextAsync(T value)
        {
            try
            {
                await sampler(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }
                OnErrorResume(ex);
            }
            finally
            {
                lock (gate)
                {
                    if (hasValue)
                    {
                        observer.OnNext(lastValue!);
                        lastValue = default;
                        hasValue = false;
                    }

                    isRunning = false;
                }
            }
        }
    }
}

internal sealed class ThrottleFirstLastObservableSampler<T, TSample>(Observable<T> source, Observable<TSample> sampler) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirstLast(observer, sampler));
    }

    sealed class _ThrottleFirstLast : Observer<T>
    {
        readonly Observer<T> observer;
        readonly object gate = new object();
        readonly IDisposable samplerSubscription;
        T? lastValue;
        bool hasValue;
        bool closing;

        public _ThrottleFirstLast(Observer<T> observer, Observable<TSample> sampler)
        {
            this.observer = observer;
            var sampleObserver = new SamplerObserver(this);
            this.samplerSubscription = sampler.Subscribe(sampleObserver);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!closing)
                {
                    closing = true;
                    observer.OnNext(value);
                }
                else
                {
                    lastValue = value;
                    hasValue = true;
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            samplerSubscription.Dispose();
        }

        void PublishOnNext()
        {
            lock (gate)
            {
                closing = false;
                if (hasValue)
                {
                    observer.OnNext(lastValue!);
                    hasValue = false;
                    lastValue = default;
                }
            }
        }

        sealed class SamplerObserver(_ThrottleFirstLast parent) : Observer<TSample>
        {
            protected override void OnNextCore(TSample value)
            {
                parent.PublishOnNext();
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.OnCompleted(result);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleFirstLastFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleFirstLastFrame<T>(this Observable<T> source, int frameCount)
    {
        return new ThrottleFirstLastFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> ThrottleFirstLastFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new ThrottleFirstLastFrame<T>(source, frameCount, frameProvider);
    }
}

internal sealed class ThrottleFirstLastFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleFirstLastFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _ThrottleFirstLastFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly FrameProvider frameProvider;
        readonly int frameCount;
        readonly object gate = new object();
        T? lastValue;
        bool hasValue;
        int currentFrame;
        bool running;

        public _ThrottleFirstLastFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!running)
                {
                    running = true;
                    currentFrame = 0;
                    frameProvider.Register(this);
                    observer.OnNext(value);
                }
                else
                {
                    hasValue = true;
                    lastValue = value;
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (++currentFrame == frameCount)
                {
                    if (hasValue)
                    {
                        observer.OnNext(lastValue!);
                        lastValue = default;
                    }
                    running = false;
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleLast.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleLast<T>(this Observable<T> source, TimeSpan timeSpan)
    {
        return new ThrottleLast<T>(source, timeSpan, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> ThrottleLast<T>(this Observable<T> source, TimeSpan timeSpan, TimeProvider timeProvider)
    {
        return new ThrottleLast<T>(source, timeSpan, timeProvider);
    }

    public static Observable<T> ThrottleLast<T, TSample>(this Observable<T> source, Observable<TSample> sampler)
    {
        return new ThrottleLastObservableSampler<T, TSample>(source, sampler);
    }

    public static Observable<T> ThrottleLast<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait = true)
    {
        return new ThrottleLastAsyncSampler<T>(source, sampler, configureAwait);
    }
}

internal sealed class ThrottleLast<T>(Observable<T> source, TimeSpan interval, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleLast(observer, interval.Normalize(), timeProvider));
    }

    sealed class _ThrottleLast : Observer<T>
    {
        static readonly TimerCallback timerCallback = RaiseOnNext;

        readonly Observer<T> observer;
        readonly TimeSpan interval;
        readonly ITimer timer;
        readonly object gate = new object();
        T? lastValue;
        bool hasValue;

        public _ThrottleLast(Observer<T> observer, TimeSpan interval, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.interval = interval;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!hasValue) // timer is stopping
                {
                    timer.InvokeOnce(interval);
                }

                hasValue = true;
                lastValue = value;
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void RaiseOnNext(object? state)
        {
            var self = (_ThrottleLast)state!;
            lock (self.gate)
            {
                if (self.hasValue)
                {
                    self.observer.OnNext(self.lastValue!);
                    self.hasValue = false;
                    self.lastValue = default;
                }
            }
        }
    }
}

internal sealed class ThrottleLastAsyncSampler<T>(Observable<T> source, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleLast(observer, sampler, configureAwait));
    }

    sealed class _ThrottleLast(Observer<T> observer, Func<T, CancellationToken, ValueTask> sampler, bool configureAwait) : Observer<T>
    {
        readonly object gate = new object();
        readonly CancellationTokenSource cancellationTokenSource = new();
        T? lastValue;
        bool isRunning;

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                lastValue = value;
                if (!isRunning)
                {
                    isRunning = true;
                    RaiseOnNextAsync(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            cancellationTokenSource.Cancel();
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            cancellationTokenSource.Cancel();
        }

        async void RaiseOnNextAsync(T value)
        {
            try
            {
                await sampler(value, cancellationTokenSource.Token).ConfigureAwait(configureAwait);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException oce && oce.CancellationToken == cancellationTokenSource.Token)
                {
                    return;
                }
                OnErrorResume(ex);
            }
            finally
            {
                lock (gate)
                {
                    observer.OnNext(lastValue!);
                    lastValue = default;
                    isRunning = false;
                }
            }
        }
    }
}

internal sealed class ThrottleLastObservableSampler<T, TSample>(Observable<T> source, Observable<TSample> sampler) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleLast(observer, sampler));
    }

    sealed class _ThrottleLast : Observer<T>
    {
        readonly Observer<T> observer;
        readonly object gate = new object();
        readonly IDisposable samplerSubscription;
        T? lastValue;
        bool hasValue;

        public _ThrottleLast(Observer<T> observer, Observable<TSample> sampler)
        {
            this.observer = observer;
            var sampleObserver = new SamplerObserver(this);
            this.samplerSubscription = sampler.Subscribe(sampleObserver);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                lastValue = value;
                hasValue = true;
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            samplerSubscription.Dispose();
        }

        void PublishOnNext()
        {
            lock (gate)
            {
                if (hasValue)
                {
                    observer.OnNext(lastValue!);
                    hasValue = false;
                    lastValue = default;
                }
            }
        }

        sealed class SamplerObserver(_ThrottleLast parent) : Observer<TSample>
        {
            protected override void OnNextCore(TSample value)
            {
                parent.PublishOnNext();
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                parent.OnCompleted(result);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/ThrottleLastFrame.cs
================================================
﻿using System.Runtime.InteropServices;

namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> ThrottleLastFrame<T>(this Observable<T> source, int frameCount)
    {
        return new ThrottleLastFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> ThrottleLastFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new ThrottleLastFrame<T>(source, frameCount, frameProvider);
    }
}

internal sealed class ThrottleLastFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ThrottleLastFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _ThrottleLastFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly FrameProvider frameProvider;
        readonly int frameCount;
        readonly object gate = new object();
        T? lastValue;
        int currentFrame;
        bool running;

        public _ThrottleLastFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.frameCount = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                if (!running)
                {
                    running = true;
                    currentFrame = 0;
                    frameProvider.Register(this);
                }

                lastValue = value;
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (++currentFrame == frameCount)
                {
                    observer.OnNext(lastValue!);
                    lastValue = default;
                    running = false;
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/TimeInterval.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<(TimeSpan Interval, T Value)> TimeInterval<T>(this Observable<T> source)
    {
        return new TimeInterval<T>(source, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<(TimeSpan Interval, T Value)> TimeInterval<T>(this Observable<T> source, TimeProvider timeProvider)
    {
        return new TimeInterval<T>(source, timeProvider);
    }
}

internal sealed class TimeInterval<T>(Observable<T> source, TimeProvider timeProvider) : Observable<(TimeSpan Interval, T Value)>
{
    protected override IDisposable SubscribeCore(Observer<(TimeSpan Interval, T Value)> observer)
    {
        return source.Subscribe(new _TimeInterval(observer, timeProvider));
    }

    sealed class _TimeInterval(Observer<(TimeSpan Interval, T Value)> observer, TimeProvider timeProvider) : Observer<T>
    {
        long previousTimestamp = timeProvider.GetTimestamp();

        protected override void OnNextCore(T value)
        {
            var currentTimestamp = timeProvider.GetTimestamp();
            var elapsed = timeProvider.GetElapsedTime(previousTimestamp, currentTimestamp);
            this.previousTimestamp = currentTimestamp;

            observer.OnNext((elapsed, value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/Timeout.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Timeout<T>(this Observable<T> source, TimeSpan dueTime)
    {
        return new Timeout<T>(source, dueTime, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<T> Timeout<T>(this Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider)
    {
        return new Timeout<T>(source, dueTime, timeProvider);
    }
}

internal sealed class Timeout<T>(Observable<T> source, TimeSpan dueTime, TimeProvider timeProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Timeout(observer, dueTime.Normalize(), timeProvider));
    }

    sealed class _Timeout : Observer<T>
    {
        static readonly TimerCallback timerCallback = PublishTimeoutError;

        readonly Observer<T> observer;
        readonly TimeSpan timeSpan;
        readonly ITimer timer;
        readonly object gate = new object();
        int timerId;

        public _Timeout(Observer<T> observer, TimeSpan timeSpan, TimeProvider timeProvider)
        {
            this.observer = observer;
            this.timeSpan = timeSpan;
            this.timer = timeProvider.CreateStoppedTimer(timerCallback, this);
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                Volatile.Write(ref timerId, unchecked(timerId + 1));
                observer.OnNext(value);
                timer.InvokeOnce(timeSpan); // restart timer
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            timer.Dispose();
        }

        static void PublishTimeoutError(object? state)
        {
            var self = (_Timeout)state!;

            var timerId = Volatile.Read(ref self.timerId);
            lock (self.gate)
            {
                if (timerId != self.timerId) return;
                self.OnCompleted(new TimeoutException());
            }
        }
    }
}



================================================
FILE: src/R3/Operators/TimeoutFrame.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> TimeoutFrame<T>(this Observable<T> source, int frameCount)
    {
        return new TimeoutFrame<T>(source, frameCount, ObservableSystem.DefaultFrameProvider);
    }

    public static Observable<T> TimeoutFrame<T>(this Observable<T> source, int frameCount, FrameProvider frameProvider)
    {
        return new TimeoutFrame<T>(source, frameCount, frameProvider);
    }
}

internal sealed class TimeoutFrame<T>(Observable<T> source, int frameCount, FrameProvider frameProvider) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _TimeoutFrame(observer, frameCount.NormalizeFrame(), frameProvider));
    }

    sealed class _TimeoutFrame : Observer<T>, IFrameRunnerWorkItem
    {
        readonly Observer<T> observer;
        readonly FrameProvider frameProvider;
        readonly int periodFrame;
        readonly object gate = new object();
        int currentFrame;
        bool running;

        public _TimeoutFrame(Observer<T> observer, int frameCount, FrameProvider frameProvider)
        {
            this.observer = observer;
            this.periodFrame = frameCount;
            this.frameProvider = frameProvider;
        }

        protected override void OnNextCore(T value)
        {
            lock (gate)
            {
                observer.OnNext(value);
                currentFrame = 0; // reset current frame
                if (!running)
                {
                    running = true;
                    frameProvider.Register(this);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        bool IFrameRunnerWorkItem.MoveNext(long _)
        {
            if (this.IsDisposed) return false;

            lock (gate)
            {
                if (++currentFrame == periodFrame)
                {
                    this.OnCompleted(new TimeoutException());
                    running = false;
                    return false;
                }
            }

            return true;
        }
    }
}



================================================
FILE: src/R3/Operators/Timestamp.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<(long Timestamp, T Value)> Timestamp<T>(this Observable<T> source)
    {
        return new Timestamp<T>(source, ObservableSystem.DefaultTimeProvider);
    }

    public static Observable<(long Timestamp, T Value)> Timestamp<T>(this Observable<T> source, TimeProvider timeProvider)
    {
        return new Timestamp<T>(source, timeProvider);
    }
}

internal sealed class Timestamp<T>(Observable<T> source, TimeProvider timeProvider) : Observable<(long Timestamp, T Value)>
{
    protected override IDisposable SubscribeCore(Observer<(long Timestamp, T Value)> observer)
    {
        return source.Subscribe(new _Timestamp(observer, timeProvider));
    }

    sealed class _Timestamp(Observer<(long Timestamp, T Value)> observer, TimeProvider timeProvider) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext((timeProvider.GetTimestamp(), value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/ToArrayAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<T[]> ToArrayAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new ToArrayAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class ToArrayAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, T[]>(cancellationToken)
{
    readonly List<T> buffer = [];

    protected override void OnNextCore(T value)
    {
        buffer.Add(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(buffer.ToArray());
    }
}



================================================
FILE: src/R3/Operators/ToAsyncEnumerable.cs
================================================
﻿#if !NETSTANDARD2_0

using System.Threading.Channels;

namespace R3;

public static partial class ObservableExtensions
{
    public static IAsyncEnumerable<T> ToAsyncEnumerable<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var channel = ChannelUtility.CreateSingleReadeWriterUnbounded<T>();

        var observer = new ToAsyncEnumerable<T>(channel.Writer);
        var disposable = source.Subscribe(observer);

        if (cancellationToken.CanBeCanceled)
        {
            observer.registration = cancellationToken.UnsafeRegister(state =>
            {
                ((IDisposable)state!).Dispose(); // cancel IAsyncEnumerable<T> may call from ReadAllAsync so don't care in here.
            }, disposable);
        }

        return channel.Reader.ReadAllAsync(cancellationToken);
    }
}

sealed class ToAsyncEnumerable<T>(ChannelWriter<T> writer) : Observer<T>
{
    public CancellationTokenRegistration registration;

    protected override void OnNextCore(T value)
    {
        writer.TryWrite(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        writer.TryComplete(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            writer.TryComplete(result.Exception);
        }
        else
        {
            writer.TryComplete();
        }
    }

    protected override void DisposeCore()
    {
        registration.Dispose();
    }
}

#endif



================================================
FILE: src/R3/Operators/ToDictionaryAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<Dictionary<TKey, T>> ToDictionaryAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        return ToDictionaryAsync(source, keySelector, null, cancellationToken);
    }

    public static Task<Dictionary<TKey, T>> ToDictionaryAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var method = new ToDictionaryAsync<T, TKey>(keySelector, keyComparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<Dictionary<TKey, TElement>> ToDictionaryAsync<T, TKey, TElement>(this Observable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        return ToDictionaryAsync(source, keySelector, elementSelector, null, cancellationToken);
    }

    public static Task<Dictionary<TKey, TElement>> ToDictionaryAsync<T, TKey, TElement>(this Observable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var method = new ToDictionaryAsync<T, TKey, TElement>(keySelector, elementSelector, keyComparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

// ToDictionaryAsync
internal sealed class ToDictionaryAsync<T, TKey>(Func<T, TKey> keySelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken)
    : TaskObserverBase<T, Dictionary<TKey, T>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, T> dictionary = new(keyComparer);

    protected override void OnNextCore(T value)
    {
        var key = keySelector(value);
        dictionary.Add(key, value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(dictionary);
    }
}

internal sealed class ToDictionaryAsync<T, TKey, TElement>(Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken)
    : TaskObserverBase<T, Dictionary<TKey, TElement>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, TElement> dictionary = new(keyComparer);

    protected override void OnNextCore(T value)
    {
        var key = keySelector(value);
        var element = elementSelector(value);
        dictionary.Add(key, element);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(dictionary);
    }
}



================================================
FILE: src/R3/Operators/ToHashSetAsync.cs
================================================
namespace R3;

public static partial class ObservableExtensions
{
    public static Task<HashSet<T>> ToHashSetAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        return ToHashSetAsync(source, null, cancellationToken);
    }

    public static Task<HashSet<T>> ToHashSetAsync<T>(this Observable<T> source, IEqualityComparer<T>? comparer, CancellationToken cancellationToken = default)
    {
        var method = new ToHashSetAsync<T>(comparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class ToHashSetAsync<T>(IEqualityComparer<T>? comparer, CancellationToken cancellationToken) : TaskObserverBase<T, HashSet<T>>(cancellationToken)
{
    readonly HashSet<T> hashSet = new(comparer);

    protected override void OnNextCore(T value)
    {
        hashSet.Add(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(hashSet);
    }
}



================================================
FILE: src/R3/Operators/ToListAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task<List<T>> ToListAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new ToListAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class ToListAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, List<T>>(cancellationToken)
{
    readonly List<T> list = [];

    protected override void OnNextCore(T value)
    {
        list.Add(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(list);
    }
}



================================================
FILE: src/R3/Operators/ToLookupAsync.cs
================================================
﻿using System.Collections;

namespace R3;

public static partial class ObservableExtensions
{
    public static Task<ILookup<TKey, T>> ToLookupAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        return ToLookupAsync(source, keySelector, null, cancellationToken);
    }

    public static Task<ILookup<TKey, T>> ToLookupAsync<T, TKey>(this Observable<T> source, Func<T, TKey> keySelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var method = new ToLookupAsync<T, TKey>(keySelector, keyComparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }

    public static Task<ILookup<TKey, TElement>> ToLookupAsync<T, TKey, TElement>(this Observable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        return ToLookupAsync(source, keySelector, elementSelector, null, cancellationToken);
    }

    public static Task<ILookup<TKey, TElement>> ToLookupAsync<T, TKey, TElement>(this Observable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var method = new ToLookupAsync<T, TKey, TElement>(keySelector, elementSelector, keyComparer, cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

// ToLookupAsync
internal sealed class ToLookupAsync<T, TKey>(Func<T, TKey> keySelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken)
    : TaskObserverBase<T, ILookup<TKey, T>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, List<T>> dictionary = new(keyComparer);

    protected override void OnNextCore(T value)
    {
        var key = keySelector(value);
        if (!dictionary.TryGetValue(key, out var list))
        {
            list = new List<T>();
            dictionary.Add(key, list);
        }
        list.Add(value);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(new Lookup<TKey, T>(dictionary));
    }
}


// ToLookpAsync with elementSelector
internal sealed class ToLookupAsync<T, TKey, TElement>(Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey>? keyComparer, CancellationToken cancellationToken)
    : TaskObserverBase<T, ILookup<TKey, TElement>>(cancellationToken)
    where TKey : notnull
{
    readonly Dictionary<TKey, List<TElement>> dictionary = new(keyComparer);

    protected override void OnNextCore(T value)
    {
        var key = keySelector(value);
        var element = elementSelector(value);
        if (!dictionary.TryGetValue(key, out var list))
        {
            list = new List<TElement>();
            dictionary.Add(key, list);
        }
        list.Add(element);
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }

        TrySetResult(new Lookup<TKey, TElement>(dictionary));
    }
}


internal sealed class Lookup<TKey, TElement>(Dictionary<TKey, List<TElement>> dictionary) : ILookup<TKey, TElement>
    where TKey : notnull
{
    public IEnumerable<TElement> this[TKey key]
    {
        get
        {
            if (dictionary.TryGetValue(key, out var list))
            {
                return list;
            }
            return Enumerable.Empty<TElement>();
        }
    }

    public int Count => dictionary.Count;

    public bool Contains(TKey key)
    {
        return dictionary.ContainsKey(key);
    }

    public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
    {
        foreach (var item in dictionary)
        {
            yield return new Grouping(item);
        }
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    sealed class Grouping(KeyValuePair<TKey, List<TElement>> kvp) : IGrouping<TKey, TElement>
    {
        public TKey Key => kvp.Key;

        public IEnumerator<TElement> GetEnumerator()
        {
            return kvp.Value.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}



================================================
FILE: src/R3/Operators/Trampoline.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    /// <summary>
    /// Similar as ObserveOn(CurrentThreadScheduler) in dotnet/reactive, place the execution order of recursive calls after the call is completed.
    /// </summary>
    public static Observable<T> Trampoline<T>(this Observable<T> source)
    {
        return new Trampoline<T>(source);
    }
}

internal sealed class Trampoline<T>(Observable<T> source) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Trampoline(observer));
    }

    sealed class _Trampoline(Observer<T> observer) : Observer<T>
    {
        readonly Queue<Notification<T>> queue = new();
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        protected override void OnNextCore(T value)
        {
            EnqueueMessage(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueMessage(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueMessage(new(result));
        }

        void EnqueueMessage(Notification<T> notification)
        {
            lock (queue)
            {
                queue.Enqueue(notification);
                if (!running)
                {
                    running = true;
                    DrainMessages();
                }
            }
        }

        void DrainMessages()
        {
        AGAIN:
            Notification<T> value;
            lock (queue)
            {
                if (IsDisposed)
                {
                    queue.Clear();
                    return;
                }

                if (!queue.TryDequeue(out value))
                {
                    running = false;
                    return;
                }
            }

            try
            {
                switch (value.Kind)
                {
                    case NotificationKind.OnNext:
                        observer.OnNext(value.Value);
                        break;
                    case NotificationKind.OnErrorResume:
                        observer.OnErrorResume(value.Error);
                        break;
                    case NotificationKind.OnCompleted:
                        try
                        {
                            observer.OnCompleted(value.Result);
                        }
                        finally
                        {
                            Dispose();
                        }
                        break;
                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                try
                {
                    ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                }
                catch { }
            }

            goto AGAIN;
        }
    }
}



================================================
FILE: src/R3/Operators/WaitAsync.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Task WaitAsync<T>(this Observable<T> source, CancellationToken cancellationToken = default)
    {
        var method = new WaitAsync<T>(cancellationToken);
        source.Subscribe(method);
        return method.Task;
    }
}

internal sealed class WaitAsync<T>(CancellationToken cancellationToken) : TaskObserverBase<T, Unit>(cancellationToken)
{
    protected override void OnNextCore(T value)
    {
    }

    protected override void OnErrorResumeCore(Exception error)
    {
        TrySetException(error);
    }

    protected override void OnCompletedCore(Result result)
    {
        if (result.IsFailure)
        {
            TrySetException(result.Exception);
            return;
        }
        TrySetResult(Unit.Default);
    }
}



================================================
FILE: src/R3/Operators/Where.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<T> Where<T>(this Observable<T> source, Func<T, bool> predicate)
    {
        if (source is Where<T> where)
        {
            // Optimize for Where.Where, create combined predicate.
            var p = where.predicate;
            return new Where<T>(where.source, x => p(x) && predicate(x)); // lambda captured but don't use TState to allow combine more Where
        }

        return new Where<T>(source, predicate);
    }

    public static Observable<T> Where<T>(this Observable<T> source, Func<T, int, bool> predicate)
    {
        return new WhereIndexed<T>(source, predicate);
    }

    // TState

    public static Observable<T> Where<T, TState>(this Observable<T> source, TState state, Func<T, TState, bool> predicate)
    {
        return new Where<T, TState>(source, predicate, state);
    }

    public static Observable<T> Where<T, TState>(this Observable<T> source, TState state, Func<T, int, TState, bool> predicate)
    {
        return new WhereIndexed<T, TState>(source, predicate, state);
    }
}

internal sealed class Where<T>(Observable<T> source, Func<T, bool> predicate) : Observable<T>
{
    internal Observable<T> source = source;
    internal Func<T, bool> predicate = predicate; // use in WhereWhere, WhereSelect(Select.cs)

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Where(observer, predicate));
    }

    class _Where(Observer<T> observer, Func<T, bool> predicate) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            if (predicate(value))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class WhereIndexed<T>(Observable<T> source, Func<T, int, bool> predicate) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Where(observer, predicate));
    }

    class _Where(Observer<T> observer, Func<T, int, bool> predicate) : Observer<T>
    {
        int index = 0;

        protected override void OnNextCore(T value)
        {
            if (predicate(value, index++))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class Where<T, TState>(Observable<T> source, Func<T, TState, bool> predicate, TState state) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Where(observer, predicate, state));
    }

    class _Where(Observer<T> observer, Func<T, TState, bool> predicate, TState state) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            if (predicate(value, state))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class WhereIndexed<T, TState>(Observable<T> source, Func<T, int, TState, bool> predicate, TState state) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _Where(observer, predicate, state));
    }

    class _Where(Observer<T> observer, Func<T, int, TState, bool> predicate, TState state) : Observer<T>
    {
        int index = 0;

        protected override void OnNextCore(T value)
        {
            if (predicate(value, index++, state))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3/Operators/WhereAwait.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3;

public static partial class ObservableExtensions
{
    /// <param name="maxConcurrent">This option is only valid for AwaitOperation.Parallel and AwaitOperation.SequentialParallel. It sets the number of concurrent executions. If set to -1, there is no limit.</param>
    public static Observable<T> WhereAwait<T>(this Observable<T> source, Func<T, CancellationToken, ValueTask<bool>> predicate, AwaitOperation awaitOperation = AwaitOperation.Sequential, bool configureAwait = true, bool cancelOnCompleted = false, int maxConcurrent = -1)
    {
        return new WhereAwait<T>(source, predicate, awaitOperation, configureAwait, cancelOnCompleted, maxConcurrent);
    }
}

internal sealed class WhereAwait<T>(Observable<T> source, Func<T, CancellationToken, ValueTask<bool>> predicate, AwaitOperation awaitOperation, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
    : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        switch (awaitOperation)
        {
            case AwaitOperation.Sequential:
                return source.Subscribe(new WhereAwaitSequential(observer, predicate, configureAwait, cancelOnCompleted));
            case AwaitOperation.Drop:
                return source.Subscribe(new WhereAwaitDrop(observer, predicate, configureAwait, cancelOnCompleted));
            case AwaitOperation.Switch:
                return source.Subscribe(new WhereAwaitSwitch(observer, predicate, configureAwait, cancelOnCompleted));
            case AwaitOperation.Parallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new WhereAwaitParallel(observer, predicate, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new WhereAwaitParallelConcurrentLimit(observer, predicate, configureAwait, cancelOnCompleted, maxConcurrent));
                }


            case AwaitOperation.SequentialParallel:
                if (maxConcurrent == -1)
                {
                    return source.Subscribe(new WhereAwaitSequentialParallel(observer, predicate, configureAwait, cancelOnCompleted));
                }
                else
                {
                    if (maxConcurrent == 0 || maxConcurrent < -1) throw new ArgumentException("maxConcurrent must be a -1 or greater than 1.");
                    return source.Subscribe(new WhereAwaitSequentialParallelConcurrentLimit(observer, predicate, configureAwait, cancelOnCompleted, maxConcurrent));
                }
            case AwaitOperation.ThrottleFirstLast:
                return source.Subscribe(new WhereAwaitThrottleFirstLast(observer, predicate, configureAwait, cancelOnCompleted));
            default:
                throw new ArgumentException();
        }
    }

    sealed class WhereAwaitSequential(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSequentialObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class WhereAwaitDrop(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationDropObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class WhereAwaitParallel(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationParallelObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                lock (gate)
                {
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }

    sealed class WhereAwaitSwitch(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSwitchObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                lock (gate)
                {
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }

    sealed class WhereAwaitSequentialParallel(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationSequentialParallelObserver<T, bool>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override ValueTask<bool> OnNextTaskAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            return predicate(value, cancellationToken);
        }

        protected override void PublishOnNext(T value, bool result)
        {
            if (result)
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class WhereAwaitParallelConcurrentLimit(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
        : AwaitOperationParallelConcurrentLimitObserver<T>(configureAwait, cancelOnCompleted, maxConcurrent)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                lock (gate)
                {
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            lock (gate)
            {
                observer.OnErrorResume(error);
            }
        }

        protected override void PublishOnCompleted(Result result)
        {
            lock (gate)
            {
                observer.OnCompleted(result);
            }
        }
    }

    sealed class WhereAwaitSequentialParallelConcurrentLimit(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted, int maxConcurrent)
        : AwaitOperationSequentialParallelConcurrentLimitObserver<T, bool>(configureAwait, cancelOnCompleted, maxConcurrent)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override ValueTask<bool> OnNextTaskAsyncCore(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            return predicate(value, cancellationToken);
        }

        protected override void PublishOnNext(T value, bool result)
        {
            if (result)
            {
                observer.OnNext(value);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

    sealed class WhereAwaitThrottleFirstLast(Observer<T> observer, Func<T, CancellationToken, ValueTask<bool>> predicate, bool configureAwait, bool cancelOnCompleted)
        : AwaitOperationThrottleFirstLastObserver<T>(configureAwait, cancelOnCompleted)
    {

#if NET6_0_OR_GREATER
        [AsyncMethodBuilderAttribute(typeof(PoolingAsyncValueTaskMethodBuilder))]
#endif
        protected override async ValueTask OnNextAsync(T value, CancellationToken cancellationToken, bool configureAwait)
        {
            if (await predicate(value, cancellationToken).ConfigureAwait(configureAwait))
            {
                if (!cancellationToken.IsCancellationRequested)
                {
                    observer.OnNext(value);
                }
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void PublishOnCompleted(Result result)
        {
            observer.OnCompleted(result);
        }
    }

}



================================================
FILE: src/R3/Operators/WhereNotNull.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> WhereNotNull<TResult>(this Observable<TResult?> source) where TResult : class
    {
        return new WhereSelect<TResult?, TResult>(
            source: source,
            selector: static item => item!,
            predicate: item => item is not null
        );
    }
}



================================================
FILE: src/R3/Operators/WithLatestFrom.cs
================================================
﻿namespace R3;

public static partial class ObservableExtensions
{
    public static Observable<TResult> WithLatestFrom<TFirst, TSecond, TResult>(this Observable<TFirst> first, Observable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
    {
        return new WithLatestFrom<TFirst, TSecond, TResult>(first, second, resultSelector);
    }
}

internal sealed class WithLatestFrom<TFirst, TSecond, TResult>(Observable<TFirst> first, Observable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        var firstObserver = new WithLatestFromFirstObserver(observer, resultSelector);
        var secondObserver = new WithLatestFromSecondObserver(firstObserver);
        firstObserver.secondDisposable.Disposable = secondObserver;

        // important: subscribe second first.
        second.Subscribe(secondObserver);
        try
        {
            first.Subscribe(firstObserver);
        }
        catch
        {
            secondObserver.Dispose();
            throw;
        }

        return firstObserver; // return first(first has secondDisposable)
    }

    sealed class WithLatestFromFirstObserver(Observer<TResult> observer, Func<TFirst, TSecond, TResult> resultSelector) : Observer<TFirst>
    {
        public Observer<TResult> observer = observer;
        public bool hasSecondValue;
        public TSecond? secondValue;
        public SingleAssignmentDisposableCore secondDisposable;

        protected override void OnNextCore(TFirst value)
        {
            // drop when second value is not available
            if (hasSecondValue)
            {
                var result = resultSelector(value, secondValue!);
                observer.OnNext(result);
            }
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            secondDisposable.Dispose();
        }
    }

    sealed class WithLatestFromSecondObserver(WithLatestFromFirstObserver left) : Observer<TSecond>
    {
        protected override void OnNextCore(TSecond value)
        {
            left.secondValue = value;
            Interlocked.MemoryBarrier();
            left.hasSecondValue = true;
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            left.observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            // only propagate failure
            if (result.IsFailure)
            {
                left.observer.OnCompleted(result);
            }
        }
    }
}



================================================
FILE: src/R3/Operators/Zip.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var GenerateTCount = 15;

    var generateT = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"T{i}").ToArray());
    var generateSources = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"source{i}").ToArray());
    var generateHasValue = (int x) => string.Join(" && ", Enumerable.Range(1, x).Select(i => $"observer{i}.HasValue(out var shouldComplete{i})").ToArray());
    var generateIsCompleted = (int x) => string.Join(" && ", Enumerable.Range(1, x).Select(i => $"observer{i}.IsCompleted").ToArray());
    var generateShouldComplete = (int x) => string.Join(" || ", Enumerable.Range(1, x).Select(i => $"shouldComplete{i}").ToArray());
    var generateValue = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"observer{i}.Values.Dequeue()").ToArray());
#>
namespace R3;

public static partial class Observable
{
<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
    public static Observable<TResult> Zip<<#= generateT(i) #>, TResult>(
        this
<# for (var j = 1; j <= i; j++ ) { #>
        Observable<T<#= j #>> source<#= j #>,
<# } #>
        Func<<#= generateT(i) #>, TResult> resultSelector)
    {
        return new Zip<<#= generateT(i) #>, TResult>(<#= generateSources(i) #>, resultSelector);
    }

<# } #>
}

<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
internal sealed class Zip<<#= generateT(i) #>, TResult>(
<# for (var j = 1; j <= i; j++ ) { #>
    Observable<T<#= j #>> source<#= j #>,
<# } #>
    Func<<#= generateT(i) #>, TResult> resultSelector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return new _Zip(observer, <#= generateSources(i) #>, resultSelector).Run();
    }

    sealed class _Zip : IDisposable
    {
        readonly Observer<TResult> observer;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly Observable<T<#= j #>> source<#= j #>;
<# } #>
        readonly Func<<#= generateT(i) #>, TResult> resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly ZipObserver<T<#= j #>> observer<#= j #>;
<# } #>        
        readonly object gate = new object();

        public _Zip(
            Observer<TResult> observer,
<# for (var j = 1; j <= i; j++ ) { #>
            Observable<T<#= j #>> source<#= j #>,
<# } #>
            Func<<#= generateT(i) #>, TResult> resultSelector)
        {
            this.observer = observer;
<# for (var j = 1; j <= i; j++ ) { #>
            this.source<#= j #> = source<#= j #>;
<# } #>
            this.resultSelector = resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
            this.observer<#= j #> = new ZipObserver<T<#= j #>>(this);
<# } #>
        }

        public IDisposable Run()
        {
            try
            {
<# for (var j = 1; j <= i; j++ ) { #>
                source<#= j #>.Subscribe(observer<#= j #>);
<# } #>
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            if (<#= generateHasValue(i) #>)
            {
                var result = resultSelector(<#= generateValue(i) #>);
                observer.OnNext(result);

                if (<#= generateShouldComplete(i) #>)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                if (empty || (<#= generateIsCompleted(i) #>))
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void Dispose()
        {
<# for (var j = 1; j <= i; j++ ) { #>
            observer<#= j #>.Dispose();
<# } #>
        }

        sealed class ZipObserver<T>(_Zip parent) : Observer<T>
        {
            public Queue<T> Values { get; } = new Queue<T>();
            public bool IsCompleted { get; private set; }

            public bool HasValue(out bool shouldComplete)
            {
                var count = Values.Count;
                shouldComplete = IsCompleted && count == 1;
                return count != 0;
            }

            protected override void OnNextCore(T value)
            {
                lock (parent.gate)
                {
                    this.Values.Enqueue(value);
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.gate)
                {
                    IsCompleted = true;
                    parent.TryPublishOnCompleted(result, Values.Count == 0);
                }
            }
        }
    }
}

<# } #>



================================================
FILE: src/R3/Operators/ZipLatest.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var GenerateTCount = 15;

    var generateT = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"T{i}").ToArray());
    var generateSources = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"source{i}").ToArray());
    var generateHasValue = (int x) => string.Join(" && ", Enumerable.Range(1, x).Select(i => $"observer{i}.HasValue").ToArray());
    var generateValue = (int x) => string.Join(", ", Enumerable.Range(1, x).Select(i => $"observer{i}.GetValue()").ToArray());
    var generateIsCompleted = (int x) => string.Join(" && ", Enumerable.Range(1, x).Select(i => $"observer{i}.IsCompleted").ToArray());
    var generateIsCompletedOr = (int x) => string.Join(" || ", Enumerable.Range(1, x).Select(i => $"observer{i}.IsCompleted").ToArray());
#>
namespace R3;

public static partial class Observable
{
<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
    public static Observable<TResult> ZipLatest<<#= generateT(i) #>, TResult>(
        this
<# for (var j = 1; j <= i; j++ ) { #>
        Observable<T<#= j #>> source<#= j #>,
<# } #>
        Func<<#= generateT(i) #>, TResult> resultSelector)
    {
        return new ZipLatest<<#= generateT(i) #>, TResult>(<#= generateSources(i) #>, resultSelector);
    }

<# } #>
}

<# for (var i = 2; i <= GenerateTCount; i++ ) { #>
internal sealed class ZipLatest<<#= generateT(i) #>, TResult>(
<# for (var j = 1; j <= i; j++ ) { #>
    Observable<T<#= j #>> source<#= j #>,
<# } #>
    Func<<#= generateT(i) #>, TResult> resultSelector) : Observable<TResult>
{
    protected override IDisposable SubscribeCore(Observer<TResult> observer)
    {
        return new _ZipLatest(observer, <#= generateSources(i) #>, resultSelector).Run();
    }

    sealed class _ZipLatest : IDisposable
    {
        readonly Observer<TResult> observer;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly Observable<T<#= j #>> source<#= j #>;
<# } #>
        readonly Func<<#= generateT(i) #>, TResult> resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
        readonly ZipLatestObserver<T<#= j #>> observer<#= j #>;
<# } #>        
        readonly object gate = new object();

        public _ZipLatest(
            Observer<TResult> observer,
<# for (var j = 1; j <= i; j++ ) { #>
            Observable<T<#= j #>> source<#= j #>,
<# } #>
            Func<<#= generateT(i) #>, TResult> resultSelector)
        {
            this.observer = observer;
<# for (var j = 1; j <= i; j++ ) { #>
            this.source<#= j #> = source<#= j #>;
<# } #>
            this.resultSelector = resultSelector;
<# for (var j = 1; j <= i; j++ ) { #>
            this.observer<#= j #> = new ZipLatestObserver<T<#= j #>>(this);
<# } #>
        }

        public IDisposable Run()
        {
            try
            {
<# for (var j = 1; j <= i; j++ ) { #>
                source<#= j #>.Subscribe(observer<#= j #>);
<# } #>
            }
            catch
            {
                Dispose();
                throw;
            }
            return this;
        }

        public void TryPublishOnNext()
        {
            if (<#= generateHasValue(i) #>)
            {
                var result = resultSelector(<#= generateValue(i) #>);
                observer.OnNext(result);
                
                if (<#= generateIsCompletedOr(i) #>)
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void TryPublishOnCompleted(Result result, bool empty)
        {
            if (result.IsFailure)
            {
                observer.OnCompleted(result);
                Dispose();
            }
            else
            {
                if (empty || (<#= generateIsCompleted(i) #>))
                {
                    observer.OnCompleted();
                    Dispose();
                }
            }
        }

        public void Dispose()
        {
<# for (var j = 1; j <= i; j++ ) { #>
            observer<#= j #>.Dispose();
<# } #>
        }

        sealed class ZipLatestObserver<T>(_ZipLatest parent) : Observer<T>
        {
            T? value;
            public bool HasValue { get; private set; }
            public bool IsCompleted { get; private set; }

            public T GetValue()
            {
                var v = this.value;
                this.value = default;
                this.HasValue = false;
                return v!;
            }

            protected override void OnNextCore(T value)
            {
                lock (parent.gate)
                {
                    this.value = value;
                    this.HasValue = true;
                    parent.TryPublishOnNext();
                }
            }

            protected override void OnErrorResumeCore(Exception error)
            {
                parent.observer.OnErrorResume(error);
            }

            protected override void OnCompletedCore(Result result)
            {
                lock (parent.gate)
                {
                    IsCompleted = true;
                    parent.TryPublishOnCompleted(result, !HasValue);
                }
            }
        }
    }
}

<# } #>



================================================
FILE: src/R3.Avalonia/AppBuilderR3InitializeExtensions.cs
================================================
﻿using Avalonia.Threading;
using R3;

namespace Avalonia; // Avalonia namespace

public static class AppBuilderR3InitializeExtensions
{
    public static AppBuilder UseR3(this AppBuilder builder)
    {
        // need to delay setup, initialize provider(dispatcher) need to determine platform
        return builder.AfterSetup(_ => AvaloniaProviderInitializer.SetDefaultObservableSystem());
    }

    public static AppBuilder UseR3(this AppBuilder builder, Action<Exception> unhandledExceptionHandler)
    {
        return builder.AfterSetup(_ => AvaloniaProviderInitializer.SetDefaultObservableSystem(unhandledExceptionHandler));
    }

    public static AppBuilder UseR3(this AppBuilder builder, DispatcherPriority priority, Action<Exception> unhandledExceptionHandler)
    {
        return builder.AfterSetup(_ => AvaloniaProviderInitializer.SetDefaultObservableSystem(unhandledExceptionHandler, priority));
    }

    public static AppBuilder UseR3(this AppBuilder builder, int framesPerSecond, Action<Exception> unhandledExceptionHandler)
    {
        return builder.AfterSetup(_ => AvaloniaProviderInitializer.SetDefaultObservableSystem(unhandledExceptionHandler, framesPerSecond));
    }

    public static AppBuilder UseR3(this AppBuilder builder, DispatcherPriority priority, int framesPerSecond, Action<Exception> unhandledExceptionHandler)
    {
        return builder.AfterSetup(_ => AvaloniaProviderInitializer.SetDefaultObservableSystem(unhandledExceptionHandler, priority, framesPerSecond));
    }
}



================================================
FILE: src/R3.Avalonia/AvaloniaDispatcherFrameProvider.cs
================================================
﻿using Avalonia.Threading;
using R3.Collections;
using System.Diagnostics.CodeAnalysis;

namespace R3;

// like the Avalonia.Rendering.UiThreadRenderTimer

// NOTE: idially, not polling, use like the WPF's CompositionTarget.Rendering

public sealed class AvaloniaDispatcherFrameProvider : FrameProvider, IDisposable
{
    public static readonly FrameProvider Default = new AvaloniaDispatcherFrameProvider(isDefaultFrameProvider: true);

    bool disposed;
    long frameCount;
    readonly bool isDefaultFrameProvider = false;
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();
    readonly DispatcherTimer timer;
    EventHandler timerTick;

    // frame loop is delayed until first register
    bool running;

    private AvaloniaDispatcherFrameProvider(bool isDefaultFrameProvider) // ctor for default
        : this()
    {
        this.isDefaultFrameProvider = isDefaultFrameProvider;
    }

    public AvaloniaDispatcherFrameProvider()
        : this(60, null)
    {
    }

    public AvaloniaDispatcherFrameProvider(int framesPerSecond)
        : this(framesPerSecond, null)
    {
    }

    public AvaloniaDispatcherFrameProvider(int framesPerSecond, DispatcherPriority? dispatcherPriority)
    {
        this.timerTick = Run;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        this.timer = dispatcherPriority == null
            ? new DispatcherTimer()
            : new DispatcherTimer(dispatcherPriority.Value);
        this.timer.Interval = TimeSpan.FromSeconds(1.0 / framesPerSecond);
        this.timer.Tick += timerTick;
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(NewThreadSleepFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(NewThreadSleepFrameProvider));
        lock (gate)
        {
            if (running == false)
            {
                running = true;
                timer.Start();
            }
            list.Add(callback, out _);
        }
    }

    public void Dispose()
    {
        if (isDefaultFrameProvider) return; // default frameprovider don't dispose

        lock (gate)
        {
            disposed = true;
            this.timer.Tick -= timerTick;
            this.timer.Stop();
            list.Dispose();
        }
    }

    void Run(object? sender, EventArgs e)
    {
        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3.Avalonia/AvaloniaDispatcherTimeProvider.cs
================================================
﻿using Avalonia.Threading;

namespace R3;

public sealed class AvaloniaDispatcherTimeProvider : TimeProvider
{
    public static readonly TimeProvider Default = new AvaloniaDispatcherTimeProvider();

    readonly DispatcherPriority? priority;

    public AvaloniaDispatcherTimeProvider()
    {
        this.priority = null;
    }

    public AvaloniaDispatcherTimeProvider(DispatcherPriority priority)
    {
        this.priority = priority;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new AvaloniaDispatcherTimeProviderTimer(priority, callback, state, dueTime, period);
    }
}

internal sealed class AvaloniaDispatcherTimeProviderTimer : ITimer
{
    DispatcherTimer? timer;
    TimerCallback callback;
    object? state;
    EventHandler timerTick;
    TimeSpan? period;
    short timerId;

    public AvaloniaDispatcherTimeProviderTimer(DispatcherPriority? priority, TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.timerTick = Timer_Tick;
        this.callback = callback;
        this.state = state;
        if (priority == null)
        {
            this.timer = new DispatcherTimer();
        }
        else
        {
            this.timer = new DispatcherTimer(priority!.Value);
        }

        timer.Tick += timerTick;

        if (dueTime != Timeout.InfiniteTimeSpan)
        {
            Change(dueTime, period);
        }
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (timer != null)
        {
            this.period = period;
            timer.Interval = dueTime;

            // when start, change timerId.
            unchecked { timerId++; }
            timer.Start();
            return true;
        }
        return false;
    }

    void Timer_Tick(object? sender, EventArgs e)
    {
        var id = timerId;
        callback(state);
        if (id != timerId)
        {
            // called new timer status, do nothing.
            return;
        }

        if (timer != null && period != null)
        {
            if (period.Value == Timeout.InfiniteTimeSpan)
            {
                period = null;
                unchecked { timerId++; }
                timer.Stop();
            }
            else
            {
                timer.Interval = period.Value;
                period = null;
            }
        }
    }

    public void Dispose()
    {
        if (timer != null)
        {
            unchecked { timerId++; }
            timer.Stop();
            timer.Tick -= timerTick;
            timer = null;
        }
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.Avalonia/AvaloniaProviderInitializer.cs
================================================
﻿using Avalonia.Logging;
using Avalonia.Threading;

namespace R3;

public static class AvaloniaProviderInitializer
{
    public static void SetDefaultObservableSystem()
    {
        SetDefaultObservableSystem(ex => Logger.Sink?.Log(LogEventLevel.Error, "R3", null, "R3 Unhandled Exception {0}", ex));
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = AvaloniaDispatcherTimeProvider.Default;
        ObservableSystem.DefaultFrameProvider = AvaloniaDispatcherFrameProvider.Default;
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler, DispatcherPriority priority)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new AvaloniaDispatcherTimeProvider(priority);
        ObservableSystem.DefaultFrameProvider = new AvaloniaDispatcherFrameProvider(priority);
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler, int framesPerSecond)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = AvaloniaDispatcherTimeProvider.Default;
        ObservableSystem.DefaultFrameProvider = new AvaloniaDispatcherFrameProvider(framesPerSecond);
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler, DispatcherPriority priority, int framesPerSecond)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new AvaloniaDispatcherTimeProvider(priority);
        ObservableSystem.DefaultFrameProvider = new AvaloniaDispatcherFrameProvider(framesPerSecond, priority);
    }
}



================================================
FILE: src/R3.Avalonia/AvaloniaRenderingFrameProvider.cs
================================================
﻿using Avalonia.Controls;
using R3.Collections;

namespace R3.Avalonia;

public class AvaloniaRenderingFrameProvider : FrameProvider, IDisposable
{
    Func<TopLevel>? topLevelFactory;
    TopLevel? topLevel;
    bool disposed;
    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    Action<TimeSpan> messageLoop;

    private AvaloniaRenderingFrameProvider()
    {
        this.messageLoop = Run;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
    }

    public AvaloniaRenderingFrameProvider(TopLevel topLevel) : this()
    {
        this.topLevel = topLevel;
    }

    public AvaloniaRenderingFrameProvider(Func<TopLevel> topLevelFactory) : this()
    {
        this.topLevelFactory = topLevelFactory;
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(AvaloniaRenderingFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(AvaloniaRenderingFrameProvider));
        list.Add(callback, out _);

        (topLevel ??= topLevelFactory!()).RequestAnimationFrame(this.messageLoop);
    }

    public void Dispose()
    {
        disposed = true;
        list.Dispose();
    }

    void Run(TimeSpan _)
    {
        if (disposed) return;

        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }

        // Schedule next frame right after this one.
        topLevel!.RequestAnimationFrame(this.messageLoop);
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3.Avalonia/ObserveOnExtensions.cs
================================================
﻿using Avalonia.Threading;
using R3.Collections;

namespace R3; // using R3

public static class ObserveOnExtensions
{
    public static Observable<T> ObserveOnDispatcher<T>(this Observable<T> source, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority = null)
    {
        return new ObserveOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> ObserveOnUIThreadDispatcher<T>(this Observable<T> source, DispatcherPriority? dispatcherPriority = null)
    {
        return ObserveOnDispatcher(source, Dispatcher.UIThread, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnDispatcher<T>(this Observable<T> source, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority = null)
    {
        return new SubscribeOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnUIThreadDispatcher<T>(this Observable<T> source, DispatcherPriority? dispatcherPriority = null)
    {
        return SubscribeOnDispatcher(source, Dispatcher.UIThread, dispatcherPriority);
    }
}

internal sealed class ObserveOnDispatcher<T>(Observable<T> source, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOnDispatcher(observer, dispatcher, dispatcherPriority));
    }

    sealed class _ObserveOnDispatcher : Observer<T>
    {
        readonly Action postCallback;

        readonly Observer<T> observer;
        readonly Dispatcher dispatcher;
        readonly DispatcherPriority? dispatcherPriority;
        readonly object gate = new object();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOnDispatcher(Observer<T> observer, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority)
        {
            this.observer = observer;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = DrainMessages;
        }

        protected override void OnNextCore(T value)
        {
            EnqueueValue(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    if (dispatcherPriority == null)
                    {
                        dispatcher.InvokeAsync(postCallback);
                    }
                    else
                    {
                        dispatcher.InvokeAsync(postCallback, dispatcherPriority.Value);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }

        void DrainMessages()
        {
            var self = this;

            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (self.gate)
            {
                values = self.list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

        FINALIZE:
            lock (self.gate)
            {
                self.list.Clear(token);

                if (self.IsDisposed)
                {
                    self.running = false;
                    return;
                }

                if (self.list.HasValue)
                {
                    // post again
                    if (dispatcherPriority == null)
                    {
                        dispatcher.InvokeAsync(postCallback);
                    }
                    else
                    {
                        dispatcher.InvokeAsync(postCallback, dispatcherPriority.Value);
                    }
                    return;
                }
                else
                {
                    self.running = false;
                    return;
                }
            }
        }
    }
}

internal sealed class SubscribeOnDispatcher<T>(Observable<T> source, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOnDispatcher(observer, source, dispatcher, dispatcherPriority).Run();
    }

    sealed class _SubscribeOnDispatcher : Observer<T>
    {
        readonly Action postCallback;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly Dispatcher dispatcher;
        readonly DispatcherPriority? dispatcherPriority;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOnDispatcher(Observer<T> observer, Observable<T> source, Dispatcher dispatcher, DispatcherPriority? dispatcherPriority)
        {
            this.observer = observer;
            this.source = source;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = Subscribe;
        }

        public IDisposable Run()
        {
            if (dispatcherPriority == null)
            {
                dispatcher.InvokeAsync(postCallback);
            }
            else
            {
                dispatcher.InvokeAsync(postCallback, dispatcherPriority.Value);
            }
            return this;
        }

        void Subscribe()
        {
            disposable.Disposable = source.Subscribe(this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}



================================================
FILE: src/R3.Avalonia/R3.Avalonia.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>netstandard2.0;netstandard2.1;net6.0;net8.0</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.Avalonia</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>Avalonia Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Avalonia" Version="11.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3.Blazor/ObservableSystemInitializationService.cs
================================================
﻿using Microsoft.Extensions.DependencyInjection.Extensions;

namespace R3;

public static class BlazorR3Extensions
{
    public static IServiceCollection AddBlazorR3(this IServiceCollection services)
    {
        return AddBlazorR3(services, _ => new SynchronizationContextTimeProvider(() => SynchronizationContext.Current), null!);
    }

    public static IServiceCollection AddBlazorR3(this IServiceCollection services, Action<Exception> unhandledExceptionHandler)
    {
        return AddBlazorR3(services, _ => new SynchronizationContextTimeProvider(() => SynchronizationContext.Current), unhandledExceptionHandler);
    }

    public static IServiceCollection AddBlazorR3(this IServiceCollection services, Func<IServiceProvider, TimeProvider> timeProviderFactory)
    {
        return AddBlazorR3(services, timeProviderFactory, null!);
    }

    public static IServiceCollection AddBlazorR3(this IServiceCollection services, Func<IServiceProvider, TimeProvider> timeProviderFactory, Action<Exception> unhandledExceptionHandler)
    {
        services.AddHttpContextAccessor();
        services.TryAddSingleton<TimeProvider>(timeProviderFactory);
        services.AddHostedService(sp => new ObservableSystemInitializationService(sp.GetRequiredService<IHttpContextAccessor>(), unhandledExceptionHandler));

        return services;
    }
}

public sealed class ObservableSystemInitializationService(IHttpContextAccessor accessor, Action<Exception>? unhandledExceptionHandler) : IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        ObservableSystem.RegisterServiceProvider(() => accessor.HttpContext!.RequestServices);
        if (unhandledExceptionHandler != null)
        {
            ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        }
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }
}



================================================
FILE: src/R3.Blazor/R3.Blazor.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFrameworks>net6.0;net8.0</TargetFrameworks>
        <OutputType>Library</OutputType>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>
        <RootNamespace>R3</RootNamespace>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.Blazor</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>Blazor Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Blazor/Properties/launchSettings.json
================================================
{
  "profiles": {
    "R3.Blazor": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:57917;http://localhost:57918"
    }
  }
}


================================================
FILE: src/R3.BlazorWebAssembly/ObservableSystemInitializationService.cs
================================================
﻿using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;

namespace R3;

public static class BlazorWebAssemblyR3Extensions
{
    public static IServiceCollection AddBlazorWebAssemblyR3(this IServiceCollection services)
    {
        return AddBlazorWebAssemblyR3(services, _ => new SynchronizationContextTimeProvider(() => SynchronizationContext.Current), null!);
    }

    public static IServiceCollection AddBlazorWebAssemblyR3(this IServiceCollection services, Action<Exception> unhandledExceptionHandler)
    {
        return AddBlazorWebAssemblyR3(services, _ => new SynchronizationContextTimeProvider(() => SynchronizationContext.Current), unhandledExceptionHandler);
    }

    public static IServiceCollection AddBlazorWebAssemblyR3(this IServiceCollection services, Func<IServiceProvider, TimeProvider> timeProviderFactory)
    {
        return AddBlazorWebAssemblyR3(services, timeProviderFactory, null!);
    }

    public static IServiceCollection AddBlazorWebAssemblyR3(this IServiceCollection services, Func<IServiceProvider, TimeProvider> timeProviderFactory, Action<Exception> unhandledExceptionHandler)
    {
        services.TryAddSingleton<TimeProvider>(timeProviderFactory);
        services.AddHostedService(sp => new ObservableSystemInitializationService(sp.GetRequiredService<IServiceProvider>(), unhandledExceptionHandler));

        return services;
    }
}

public sealed class ObservableSystemInitializationService(IServiceProvider serviceProvider, Action<Exception>? unhandledExceptionHandler) : IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        ObservableSystem.RegisterServiceProvider(() => serviceProvider);
        if (unhandledExceptionHandler != null)
        {
            ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        }
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }
}



================================================
FILE: src/R3.BlazorWebAssembly/R3.BlazorWebAssembly.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net6.0;net8.0</TargetFrameworks>
        <OutputType>Library</OutputType>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>
        <RootNamespace>R3</RootNamespace>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.BlazorWebAssembly</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>BlazorWebAssembly Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="8.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Godot/R3.Godot.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>disable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <NoWarn>1701;1702;1591;1573;8002;</NoWarn>

        <!-- Currently not packable -->
        <IsPackable>false</IsPackable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="GodotSharp" Version="4.2.1" />
        <!--<PackageReference Include="Godot.SourceGenerators" Version="4.2.1" />-->
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3.Godot/addons/R3.Godot/FrameProviderDispatcher.cs
================================================
﻿#nullable enable

using System.Runtime.CompilerServices;

namespace R3;

public partial class FrameProviderDispatcher : global::Godot.Node
{
    StrongBox<double> processDelta = new StrongBox<double>();
    StrongBox<double> physicsProcessDelta = new StrongBox<double>();

    public override void _Ready()
    {
        GodotProviderInitializer.SetDefaultObservableSystem();

        ((GodotFrameProvider)GodotFrameProvider.Process).Delta = processDelta;
        ((GodotFrameProvider)GodotFrameProvider.PhysicsProcess).Delta = physicsProcessDelta;
    }

    public override void _Process(double delta)
    {
        processDelta.Value = delta;
        ((GodotTimeProvider)GodotTimeProvider.Process).time += delta;
        ((GodotFrameProvider)GodotFrameProvider.Process).Run(delta);
    }

    public override void _PhysicsProcess(double delta)
    {
        physicsProcessDelta.Value = delta;
        ((GodotTimeProvider)GodotTimeProvider.PhysicsProcess).time += delta;
        ((GodotFrameProvider)GodotFrameProvider.PhysicsProcess).Run(delta);
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotFrameProvider.cs
================================================
﻿#nullable enable

using Godot;
using R3.Collections;
using System;
using System.Runtime.CompilerServices;

namespace R3;

internal enum PlayerLoopTiming
{
    Process,
    PhysicsProcess
}

public class GodotFrameProvider : FrameProvider
{
    public static readonly GodotFrameProvider Process = new GodotFrameProvider(PlayerLoopTiming.Process);
    public static readonly GodotFrameProvider PhysicsProcess = new GodotFrameProvider(PlayerLoopTiming.PhysicsProcess);

    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    PlayerLoopTiming PlayerLoopTiming { get; }

    internal StrongBox<double> Delta = default!; // set from Node before running process.

    internal GodotFrameProvider(PlayerLoopTiming playerLoopTiming)
    {
        this.PlayerLoopTiming = playerLoopTiming;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
    }

    public override long GetFrameCount()
    {
        if (PlayerLoopTiming == PlayerLoopTiming.Process)
        {
            return (long)Engine.GetProcessFrames();
        }
        else
        {
            return (long)Engine.GetPhysicsFrames();
        }
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        list.Add(callback, out _);
    }

    internal void Run(double _)
    {
        long frameCount = GetFrameCount();

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotNodeExtensions.cs
================================================
﻿using System;
using Godot;

namespace R3;

public static class GodotNodeExtensions
{
    /// <summary>
    /// Dispose self on target node has bee tree exited.
    /// </summary>
    /// <param name="disposable"></param>
    /// <param name="node"></param>
    /// <typeparam name="T"></typeparam>
    /// <returns>Self disposable</returns>
    public static T AddTo<T>(this T disposable, Node node) where T : IDisposable
    {
        // Note: Dispose when tree exited, so if node is not inside tree, dispose immediately.
        if (!node.IsInsideTree()) 
        {
            if (!node.IsNodeReady()) // Before enter tree
            {
                GD.PrintErr("AddTo does not support to use before enter tree.");
            }

            disposable.Dispose();
            return disposable;
        }
        
        node.TreeExited += () => disposable.Dispose();
        return disposable;
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotObservableExtensions.cs
================================================
﻿using System;

namespace R3;

public static class GodotObservableExtensions
{
    public static Observable<double> Delta(this Observable<Unit> source)
    {
        return Delta(source, GodotFrameProvider.Process);
    }

    public static Observable<double> Delta(this Observable<Unit> source, GodotFrameProvider frameProvider)
    {
        return new Delta(source, frameProvider);
    }

    public static Observable<(double Delta, T Item)> Delta<T>(this Observable<T> source)
    {
        return Delta(source, GodotFrameProvider.Process);
    }

    public static Observable<(double Delta, T Item)> Delta<T>(this Observable<T> source, GodotFrameProvider frameProvider)
    {
        return new Delta<T>(source, frameProvider);
    }
}

internal sealed class Delta(Observable<Unit> source, GodotFrameProvider frameProvider) : Observable<double>
{
    protected override IDisposable SubscribeCore(Observer<double> observer)
    {
        return source.Subscribe(new _Delta(observer, frameProvider));
    }

    sealed class _Delta(Observer<double> observer, GodotFrameProvider frameProvider) : Observer<Unit>
    {
        protected override void OnNextCore(Unit value)
        {
            observer.OnNext(frameProvider.Delta.Value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class Delta<T>(Observable<T> source, GodotFrameProvider frameProvider) : Observable<(double Delta, T Item)>
{
    protected override IDisposable SubscribeCore(Observer<(double Delta, T Item)> observer)
    {
        return source.Subscribe(new _Delta(observer, frameProvider));
    }

    sealed class _Delta(Observer<(double Delta, T Item)> observer, GodotFrameProvider frameProvider) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext((frameProvider.Delta.Value, value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotProviderInitializer.cs
================================================
﻿#nullable enable

using Godot;
using System;

namespace R3;

public static class GodotProviderInitializer
{
    public static void SetDefaultObservableSystem()
    {
        SetDefaultObservableSystem(ex => GD.PrintErr(ex));
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = GodotTimeProvider.Process;
        ObservableSystem.DefaultFrameProvider = GodotFrameProvider.Process;
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotR3Plugin.cs
================================================
﻿#if TOOLS
#nullable enable

using Godot;

namespace R3;

[Tool]
public partial class GodotR3Plugin : EditorPlugin
{
    static ObservableTrackerDebuggerPlugin? observableTrackerDebugger;
    public override void _EnterTree()
    {
        observableTrackerDebugger ??= new ObservableTrackerDebuggerPlugin();
        AddDebuggerPlugin(observableTrackerDebugger);
        // Automatically install autoloads here for ease of use.
        AddAutoloadSingleton(nameof(FrameProviderDispatcher), "res://addons/R3.Godot/FrameProviderDispatcher.cs");
        AddAutoloadSingleton(nameof(ObservableTrackerRuntimeHook), "res://addons/R3.Godot/ObservableTrackerRuntimeHook.cs");
    }

    public override void _ExitTree()
    {
        if (observableTrackerDebugger != null)
        {
            RemoveDebuggerPlugin(observableTrackerDebugger);
            observableTrackerDebugger = null;
        }
        RemoveAutoloadSingleton(nameof(FrameProviderDispatcher));
        RemoveAutoloadSingleton(nameof(ObservableTrackerRuntimeHook));
    }
}
#endif



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotSignalMapper.cs
================================================
﻿using System;
using System.Threading;
using Godot;

namespace R3;

public static class GodotObjectExtensions
{
    /// <summary>Returns a <see cref="CancellationToken"/> that cancels when <paramref name="obj"/> emits the specified signal, this cancellation is one-shot unless <paramref name="oneShot"/> is false.</summary>
    public static CancellationToken CancelOnSignal(this GodotObject obj, StringName signalName, bool oneShot = true)
    {
        CancellationTokenSource cts = new();
        obj.Connect(signalName, Callable.From(cts.Cancel), oneShot ? (uint) GodotObject.ConnectFlags.OneShot : 0);
        return cts.Token;
    }

    /// <summary>Returns an observable that: publishes a <see cref="Unit"/> when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<Unit> SignalAsObservable(this Node node, StringName signalName)
    {
        return node.SignalAsObservable(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes data of type <typeparamref name="T"/> when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<T> SignalAsObservable<[MustBeVariant] T>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3, T4)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3, T4>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3, T4, T5>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3, T4, T5, T6>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6, T7)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3, T4, T5, T6, T7>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>) when <paramref name="node"/> emits the specified signal (except for <see cref="Node.SignalName.TreeExited"/>); finishes when <paramref name="node"/> emits <see cref="Node.SignalName.TreeExited"/>.</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7, [MustBeVariant] T8>(this Node node, StringName signalName)
    {
        return node.SignalAsObservable<T0, T1, T2, T3, T4, T5, T6, T7, T8>(signalName, node.CancelOnSignal(Node.SignalName.TreeExited));
    }

    /// <summary>Returns an observable that: publishes a <see cref="Unit"/> when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<Unit> SignalAsObservable(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes data of type <typeparamref name="T"/> when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<T> SignalAsObservable<[MustBeVariant] T>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3, T4)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3, T4>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3, T4, T5>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3, T4, T5, T6>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6, T7)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3, T4, T5, T6, T7>(obj, signalName, cancellationToken).RefCount();
    }

    /// <summary>Returns an observable that: publishes a tuple (<typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>) when <paramref name="obj"/> emits the specified signal; finishes when <paramref name="cancellationToken"/> cancels, or when all subscriptions are disposed, if only <paramref name="cancellationToken"/> is default (= <see cref="CancellationToken.None"/>).</summary>
    public static Observable<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> SignalAsObservable<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7, [MustBeVariant] T8>(this GodotObject obj, StringName signalName, CancellationToken cancellationToken = default)
    {
        return new GodotSignalMapper<T0, T1, T2, T3, T4, T5, T6, T7, T8>(obj, signalName, cancellationToken).RefCount();
    }
}

internal abstract class GodotSignalMapperBase<T> : ConnectableObservable<T>, IDisposable
{
    protected readonly Subject<T> subject = new();

    private readonly GodotObject godotObject;
    private readonly StringName godotSignalName;
    private readonly CancellationTokenRegistration? cancellationTokenRegistration;
    private Callable? godotCallableOnNext;
    private int connected;
    private int disposed;

    private bool ShouldDisposeOnDisconnect => !cancellationTokenRegistration.HasValue;

    protected GodotSignalMapperBase(GodotObject obj, StringName signalName, CancellationToken cancellationToken)
    {
        godotObject = obj;
        godotSignalName = signalName;
        if (cancellationToken.CanBeCanceled)
        {
            cancellationTokenRegistration = cancellationToken.UnsafeRegister((state) => ((GodotSignalMapperBase<T>) state!).Dispose(), this);
        }
    }

    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return subject.Subscribe(observer.Wrap());
    }

    public override IDisposable Connect()
    {
        if (Interlocked.CompareExchange(ref connected, 1, 0) == 0)
        {
            godotCallableOnNext ??= OnNextAsGodotCallable();
            godotObject.Connect(godotSignalName, godotCallableOnNext.Value);
        }
        return new Connection(this);
    }

    private void Disconnect()
    {
        if (Interlocked.CompareExchange(ref connected, 0, 1) == 1)
        {
            godotObject.Disconnect(godotSignalName, godotCallableOnNext!.Value);
        }
    }

    private class Connection(GodotSignalMapperBase<T> parent) : IDisposable
    {
        public void Dispose()
        {
            parent.Disconnect();
            if (parent.ShouldDisposeOnDisconnect) { parent.Dispose(); }
        }
    }

    public void Dispose()
    {
        if (Interlocked.CompareExchange(ref disposed, 1, 0) == 1) { return; }
        Disconnect();
        subject.Dispose(true);
        cancellationTokenRegistration?.Dispose();
    }

    protected abstract Callable OnNextAsGodotCallable();
}

internal class GodotSignalMapper(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<Unit>(obj, signalName, cancellationToken) {
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action) OnNextWithUnit);
    private void OnNextWithUnit() => subject.OnNext(Unit.Default);
}

internal class GodotSignalMapper<[MustBeVariant] T>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<T>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T>) OnNextWithArgs);
    private void OnNextWithArgs(T _a) => subject.OnNext(_a);
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1) => subject.OnNext((_0, _1));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2) => subject.OnNext((_0, _1, _2));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3) => subject.OnNext((_0, _1, _2, _3));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3, T4)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3, T4>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4) => subject.OnNext((_0, _1, _2, _3, _4));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3, T4, T5)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3, T4, T5>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5) => subject.OnNext((_0, _1, _2, _3, _4, _5));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3, T4, T5, T6)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3, T4, T5, T6>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6) => subject.OnNext((_0, _1, _2, _3, _4, _5, _6));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3, T4, T5, T6, T7)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3, T4, T5, T6, T7>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7) => subject.OnNext((_0, _1, _2, _3, _4, _5, _6, _7));
}

internal class GodotSignalMapper<[MustBeVariant] T0, [MustBeVariant] T1, [MustBeVariant] T2, [MustBeVariant] T3, [MustBeVariant] T4, [MustBeVariant] T5, [MustBeVariant] T6, [MustBeVariant] T7, [MustBeVariant] T8>(GodotObject obj, StringName signalName, CancellationToken cancellationToken) : GodotSignalMapperBase<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>(obj, signalName, cancellationToken)
{
    protected override Callable OnNextAsGodotCallable() => Callable.From((Action<T0, T1, T2, T3, T4, T5, T6, T7, T8>) OnNextWithArgs);
    private void OnNextWithArgs(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8) => subject.OnNext((_0, _1, _2, _3, _4, _5, _6, _7, _8));
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotTimeProvider.cs
================================================
﻿#nullable enable

using System;
using System.Threading;
using System.Threading.Tasks;

namespace R3;

public class GodotTimeProvider : TimeProvider
{
    public static readonly GodotTimeProvider Process = new GodotTimeProvider(GodotFrameProvider.Process);
    public static readonly GodotTimeProvider PhysicsProcess = new GodotTimeProvider(GodotFrameProvider.PhysicsProcess);

    readonly GodotFrameProvider frameProvider;

    internal double time;

    GodotTimeProvider(FrameProvider frameProvider)
    {
        this.frameProvider = (GodotFrameProvider)frameProvider;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new FrameTimer(callback, state, dueTime, period, frameProvider);
    }

    public override long GetTimestamp()
    {
        return TimeSpan.FromSeconds(time).Ticks;
    }
}

internal sealed class FrameTimer : ITimer, IFrameRunnerWorkItem
{
    enum RunningState
    {
        Stop,
        RunningDueTime,
        RunningPeriod,
        ChangeRequested
    }

    readonly TimerCallback callback;
    readonly object? state;
    readonly GodotFrameProvider frameProvider;
    readonly object gate = new object();

    TimeSpan dueTime;
    TimeSpan period;
    RunningState runningState;
    double elapsed;
    bool isDisposed;

    public FrameTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period, GodotFrameProvider frameProvider)
    {
        this.callback = callback;
        this.state = state;
        this.dueTime = dueTime;
        this.period = period;
        this.frameProvider = frameProvider;
        Change(dueTime, period);
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (isDisposed) return false;

        lock (gate)
        {
            this.dueTime = dueTime;
            this.period = period;

            if (dueTime == Timeout.InfiniteTimeSpan)
            {
                if (runningState == RunningState.Stop)
                {
                    return true;
                }
            }

            if (runningState == RunningState.Stop)
            {
                frameProvider.Register(this);
            }

            runningState = RunningState.ChangeRequested;
        }
        return true;
    }

    bool IFrameRunnerWorkItem.MoveNext(long frameCount)
    {
        if (isDisposed) return false;

        RunningState runState;
        TimeSpan p; // period
        TimeSpan d; // dueTime
        lock (gate)
        {
            runState = runningState;

            if (runState == RunningState.ChangeRequested)
            {
                elapsed = 0;
                if (dueTime == Timeout.InfiniteTimeSpan)
                {
                    runningState = RunningState.Stop;
                    return false;
                }

                runState = runningState = RunningState.RunningDueTime;
            }
            p = period;
            d = dueTime;
        }

        elapsed += frameProvider.Delta.Value;

        try
        {
            if (runState == RunningState.RunningDueTime)
            {
                var dt = (double)d.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);

                    elapsed = 0;
                    if (period == Timeout.InfiniteTimeSpan)
                    {
                        return ChangeState(RunningState.Stop);
                    }
                    else
                    {
                        return ChangeState(RunningState.RunningPeriod);
                    }
                }
                else
                {
                    return true;
                }
            }
            else
            {
                var dt = (double)p.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);
                    elapsed = 0;
                }

                return ChangeState(RunningState.RunningPeriod);
            }
        }
        catch (Exception ex)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
            return ChangeState(RunningState.Stop);
        }
    }

    bool ChangeState(RunningState state)
    {
        lock (gate)
        {
            // change requested is high priority
            if (runningState == RunningState.ChangeRequested)
            {
                return true;
            }

            switch (state)
            {
                case RunningState.RunningPeriod:
                    runningState = state;
                    return true;
                default: // otherwise(Stop)
                    runningState = state;
                    return false;
            }
        }
    }

    public void Dispose()
    {
        Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
        isDisposed = true;
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/GodotUINodeExtensions.cs
================================================
﻿using System;
using System.Threading;
using Godot;

namespace R3;

public static class GodotUINodeExtensions
{
    public static IDisposable SubscribeToLabel(this Observable<string> source, Label label)
    {
        return source.Subscribe(label, static (x, l) => l.Text = x);
    }

    public static IDisposable SubscribeToLabel<T>(this Observable<T> source, Label label)
    {
        return source.Subscribe(label, static (x, l) => l.Text = x?.ToString());
    }

    public static IDisposable SubscribeToLabel<T>(this Observable<T> source, Label label, Func<T, string> selector)
    {
        return source.Subscribe((label, selector), static (x, state) => state.label.Text = state.selector(x));
    }

    /// <summary>Observe Pressed event.</summary>
    public static Observable<Unit> OnPressedAsObservable(this BaseButton button, CancellationToken cancellationToken = default)
    {
        return Observable.FromEvent(h => button.Pressed += h, h => button.Pressed -= h, cancellationToken);
    }

    /// <summary>Observe Toggled with current `ButtonPressed` value on subscribe.</summary>
    public static Observable<bool> OnToggledAsObservable(this BaseButton button, CancellationToken cancellationToken = default)
    {
        if (!button.ToggleMode) return Observable.Empty<bool>();

        return Observable.Create<bool, (BaseButton, CancellationToken)>((button, cancellationToken), static (observer, state) =>
        {
            var (b, cancellationToken) = state;
            observer.OnNext(b.ButtonPressed);
            return Observable.FromEvent<BaseButton.ToggledEventHandler, bool>(h => new BaseButton.ToggledEventHandler(h), h => b.Toggled += h, h => b.Toggled -= h, cancellationToken).Subscribe(observer);
        });
    }

    /// <summary>Observe ValueChanged with current `Value` on subscribe.</summary>
    public static Observable<double> OnValueChangedAsObservable(this Godot.Range range, CancellationToken cancellationToken = default)
    {
        return Observable.Create<double, (Godot.Range, CancellationToken)>((range, cancellationToken), static (observer, state) =>
        {
            var (s, cancellationToken) = state;
            observer.OnNext(s.Value);
            return Observable.FromEvent<Godot.Range.ValueChangedEventHandler, double>(h => new Godot.Range.ValueChangedEventHandler(h), h => s.ValueChanged += h, h => s.ValueChanged -= h, cancellationToken).Subscribe(observer);
        });
    }

    /// <summary>Observe TextSubmitted event.</summary>
    public static Observable<string> OnTextSubmittedAsObservable(this LineEdit lineEdit, CancellationToken cancellationToken = default)
    {
        return Observable.FromEvent<LineEdit.TextSubmittedEventHandler, string>(h => new LineEdit.TextSubmittedEventHandler(h), h => lineEdit.TextSubmitted += h, h => lineEdit.TextSubmitted -= h, cancellationToken);
    }

    /// <summary>Observe TextChanged event.</summary>
    public static Observable<string> OnTextChangedAsObservable(this LineEdit lineEdit, CancellationToken cancellationToken = default)
    {
        return Observable.FromEvent<LineEdit.TextChangedEventHandler, string>(h => new LineEdit.TextChangedEventHandler(h), h => lineEdit.TextChanged += h, h => lineEdit.TextChanged -= h, cancellationToken);
    }

    /// <summary>Observe TextChanged event.</summary>
    public static Observable<Unit> OnTextChangedAsObservable(this TextEdit textEdit, CancellationToken cancellationToken = default)
    {
        return Observable.FromEvent(h => textEdit.TextChanged += h, h => textEdit.TextChanged -= h, cancellationToken);
    }

    /// <summary>Observe ItemSelected with current `Selected` on subscribe.</summary>
    public static Observable<long> OnItemSelectedAsObservable(this OptionButton optionButton, CancellationToken cancellationToken = default)
    {
        return Observable.Create<long, (OptionButton, CancellationToken)>((optionButton, cancellationToken), static (observer, state) =>
        {
            var (b, cancellationToken) = state;
            observer.OnNext(b.Selected);
            return Observable.FromEvent<OptionButton.ItemSelectedEventHandler, long>(h => new OptionButton.ItemSelectedEventHandler(h), h => b.ItemSelected += h, h => b.ItemSelected -= h, cancellationToken).Subscribe(observer);
        });
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/ObservableTrackerDebuggerPlugin.cs
================================================
﻿#if TOOLS
#nullable enable

using Godot;
using System;
using System.Collections.Generic;
using GDArray = Godot.Collections.Array;

namespace R3;

// ObservableTrackerDebuggerPlugin creates the Observable Tracker tab in the debugger, and communicates with ObservableTrackerRuntimeHook via EditorDebuggerSessions.
[Tool]
public partial class ObservableTrackerDebuggerPlugin : EditorDebuggerPlugin
{
    // Shared header used in IPC by ObservableTracker classes.
    public const string MessageHeader = "ObservableTracker";

    // Implemented by ObservableTrackerRuntimeHook.
    public const string Message_RequestActiveTasks = "RequestActiveTasks";
    public const string Message_SetEnableStates = "SetEnableStates";
    public const string Message_InvokeGCCollect = "InvokeGCCollect";

    // Implemented by ObservableTrackerDebuggerPlugin.
    public const string Message_ReceiveActiveTasks = "ReceiveActiveTasks";

    // A TrackerSession isolates each debugger session's states.
    // There's no way to know if a session has been disposed for good, so we will never remove anything from this dictionary.
    // This is similar to how it is handled in the Godot core (see: https://github.com/godotengine/godot/blob/master/modules/multiplayer/editor/multiplayer_editor_plugin.cpp)
    readonly Dictionary<int, TrackerSession> sessions = new();

    private class TrackerSession
    {
        public readonly EditorDebuggerSession debuggerSession;
        public readonly List<TrackingState> states = new();
        public event Action<IEnumerable<TrackingState>>? ReceivedActiveTasks;

        public TrackerSession(EditorDebuggerSession debuggerSession)
        {
            this.debuggerSession = debuggerSession;
        }

        public void InvokeReceivedActiveTasks()
        {
            ReceivedActiveTasks?.Invoke(states);
        }
    }

    public override void _SetupSession(int sessionId)
    {
        var currentSession = GetSession(sessionId);
        sessions[sessionId] = new TrackerSession(currentSession);

        // NotifyOnSessionSetup gives the tab a reference to the debugger plugin, as well as the sessionId which is needed for messages.
		var tab = new ObservableTrackerTab();
        tab.NotifyOnSessionSetup(this, sessionId);
        currentSession.AddSessionTab(tab);

        // As sessions don't seem to be ever disposed, we don't need to unregister these callbacks either.
        currentSession.Started += () =>
        {
            if (IsInstanceValid(tab))
            {
                tab.SetProcess(true);
                // Important! We need to tell the tab the session has started, so it can initialize the enabled states of the runtime ObservableTracker.
                tab.NotifyOnSessionStart();
            }
        };
        currentSession.Stopped += () =>
        {
            if (IsInstanceValid(tab))
            {
                tab.SetProcess(false);
            }
        };
    }

    public override bool _HasCapture(string capture)
    {
        return capture == MessageHeader;
    }

    public override bool _Capture(string message, GDArray data, int sessionId)
    {
        // When EditorDebuggerPlugin._Capture receives messages, the header isn't trimmed (unlike how it is in EngineDebugger),
        // so we need to trim it here.
        string messageWithoutHeader = message.Substring(message.IndexOf(':') + 1);
        //GD.Print(nameof(ObservableTrackerDebuggerPlugin) + " received " + messageWithoutHeader);
        switch(messageWithoutHeader)
        {
            case Message_ReceiveActiveTasks:
                // Only invoke event if updated.
                if (data[0].AsBool())
                {
                    var session = sessions[sessionId];
                    session.states.Clear();
                    foreach (GDArray item in data[1].AsGodotArray())
                    {
                        var state = new TrackingState()
                        {
                            TrackingId = item[0].AsInt32(),
                            FormattedType = item[1].AsString(),
                            AddTime = new DateTime(item[2].AsInt64()),
                            StackTrace = item[3].AsString(),
                        };;
                        session.states.Add(state);
                    }
                    session.InvokeReceivedActiveTasks();
                }
                return true;
        }
        return base._Capture(message, data, sessionId);
    }

    public void RegisterReceivedActiveTasks(int sessionId, Action<IEnumerable<TrackingState>> action)
    {
        if (sessions.Count > 0)
            sessions[sessionId].ReceivedActiveTasks += action;
    }

    public void UnregisterReceivedActiveTasks(int sessionId, Action<IEnumerable<TrackingState>> action)
    {
        if (sessions.Count > 0)
            sessions[sessionId].ReceivedActiveTasks -= action;
    }

    public void UpdateTrackingStates(int sessionId, bool forceUpdate = false)
    {
        if (sessions.Count > 0 && sessions[sessionId].debuggerSession.IsActive())
        {
            sessions[sessionId].debuggerSession.SendMessage(MessageHeader + ":" + Message_RequestActiveTasks, new () { forceUpdate });
        }
    }

    public void SetEnableStates(int sessionId, bool enableTracking, bool enableStackTrace)
    {
        if (sessions.Count > 0 && sessions[sessionId].debuggerSession.IsActive())
        {
            sessions[sessionId].debuggerSession.SendMessage(MessageHeader + ":" + Message_SetEnableStates, new () { enableTracking, enableStackTrace});
        }
    }

    public void InvokeGCCollect(int sessionId)
    {
        if (sessions.Count > 0 && sessions[sessionId].debuggerSession.IsActive())
        {
            sessions[sessionId].debuggerSession.SendMessage(MessageHeader + ":" + Message_InvokeGCCollect);
        }
    }
}
#endif



================================================
FILE: src/R3.Godot/addons/R3.Godot/ObservableTrackerRuntimeHook.cs
================================================
﻿
#nullable enable

using Godot;
using System;
using GDArray = Godot.Collections.Array;

namespace R3;

// Sends runtime ObservableTracker information to ObservableTrackerDebuggerPlugin.
// Needs to be an Autoload. Should not be instantiated manually.
public partial class ObservableTrackerRuntimeHook : Node
{
    public override void _Ready()
    {
#if TOOLS
        EngineDebugger.RegisterMessageCapture(ObservableTrackerDebuggerPlugin.MessageHeader, Callable.From((string message, GDArray data) =>
        { 
            //GD.Print(nameof(ObservableTrackerRuntimeHook) + " received " + message);
            switch (message)
            {
                case ObservableTrackerDebuggerPlugin.Message_RequestActiveTasks:
                    // data[0]: If true, force an update anyway.
                    if (ObservableTracker.CheckAndResetDirty() || data[0].AsBool())
                    {
                        GDArray states = new();
                        ObservableTracker.ForEachActiveTask(state =>
                        {
                            // DateTime is not a Variant type, so we serialize it using Ticks instead.
                            states.Add(new GDArray { state.TrackingId, state.FormattedType, state.AddTime.Ticks, state.StackTrace });
                        });
                        EngineDebugger.SendMessage(ObservableTrackerDebuggerPlugin.MessageHeader + ":" + ObservableTrackerDebuggerPlugin.Message_ReceiveActiveTasks, new () { true, states });
                    }
                    else
                    {
                        EngineDebugger.SendMessage(ObservableTrackerDebuggerPlugin.MessageHeader + ":" + ObservableTrackerDebuggerPlugin.Message_ReceiveActiveTasks, new () { false, });
                    }
                    break;
                case ObservableTrackerDebuggerPlugin.Message_SetEnableStates:
                    ObservableTracker.EnableTracking = data[0].AsBool();
                    ObservableTracker.EnableStackTrace = data[1].AsBool();
                    break;
                case ObservableTrackerDebuggerPlugin.Message_InvokeGCCollect:
                    GC.Collect(0);
                    break;
            }
            return true;
        }));
#endif
    }

    public override void _ExitTree()
    {
#if TOOLS
        EngineDebugger.UnregisterMessageCapture(ObservableTrackerDebuggerPlugin.MessageHeader);
#endif
    }
}



================================================
FILE: src/R3.Godot/addons/R3.Godot/ObservableTrackerTab.cs
================================================
﻿#if TOOLS
#nullable enable

using Godot;
using System;

namespace R3;

[Tool]
public partial class ObservableTrackerTab : VBoxContainer
{
    public const string EnableAutoReloadKey = "ObservableTracker_EnableAutoReloadKey";
    public const string EnableTrackingKey = "ObservableTracker_EnableTrackingKey";
    public const string EnableStackTraceKey = "ObservableTracker_EnableStackTraceKey";
    bool enableAutoReload, enableTracking, enableStackTrace;
    ObservableTrackerTree? tree;
    ObservableTrackerDebuggerPlugin? debuggerPlugin;
    int interval = 0;
    int sessionId = 0;

    public void NotifyOnSessionSetup(ObservableTrackerDebuggerPlugin debuggerPlugin, int sessionId)
    {
        this.debuggerPlugin = debuggerPlugin;
        this.sessionId = sessionId;
        tree ??= new ObservableTrackerTree();
        tree.NotifyOnSessionSetup(debuggerPlugin!, sessionId);
    }

    public void NotifyOnSessionStart()
    {
        debuggerPlugin!.SetEnableStates(sessionId, enableTracking, enableStackTrace);
    }

    public override void _Ready()
    {
        Name = "Observable Tracker";

        tree ??= new ObservableTrackerTree();
        
        // Head panel
        var headPanelLayout = new HBoxContainer();
        headPanelLayout.SetAnchor(Side.Left, 0);
        headPanelLayout.SetAnchor(Side.Right, 0);
        AddChild(headPanelLayout);

        // Toggle buttons (top left)
        var enableAutoReloadToggle = new CheckButton
        {
            Text = "Enable AutoReload",
            TooltipText = "Reload automatically."
        };
        var enableTrackingToggle = new CheckButton
        {
            Text = "Enable Tracking",
            TooltipText = "Start to track Observable subscription. Performance impact: low"
        };
        var enableStackTraceToggle = new CheckButton
        {
            Text = "Enable StackTrace",
            TooltipText = "Capture StackTrace when subscribed. Performance impact: high"
        };

        // For every button: Initialize pressed state and subscribe to Toggled event.
        EditorSettings settings = EditorInterface.Singleton.GetEditorSettings();
        enableAutoReloadToggle.ButtonPressed = enableAutoReload = GetSettingOrDefault(settings, EnableAutoReloadKey, false).AsBool();
        enableAutoReloadToggle.Toggled += toggledOn =>
        {
            settings.SetSetting(EnableAutoReloadKey, toggledOn);
            enableAutoReload = toggledOn;
        };
        enableTrackingToggle.ButtonPressed = enableTracking = GetSettingOrDefault(settings, EnableTrackingKey, false).AsBool();
        enableTrackingToggle.Toggled += toggledOn =>
        {
            settings.SetSetting(EnableTrackingKey, toggledOn);
            enableTracking = toggledOn;
            debuggerPlugin!.SetEnableStates(sessionId, enableTracking, enableStackTrace);
        };
        enableStackTraceToggle.ButtonPressed = enableStackTrace = GetSettingOrDefault(settings, EnableStackTraceKey, false).AsBool();
        enableStackTraceToggle.Toggled += toggledOn =>
        {
            settings.SetSetting(EnableStackTraceKey, toggledOn);
            enableStackTrace = toggledOn;
            debuggerPlugin!.SetEnableStates(sessionId, enableTracking, enableStackTrace);
        };

        // Regular buttons (top right)
        var reloadButton = new Button
        {
            Text = "Reload",
            TooltipText = "Reload View."
        };
        var GCButton = new Button
        {
            Text = "GC.Collect",
            TooltipText = "Invoke GC.Collect."
        };

        reloadButton.Pressed += () =>
        {
            debuggerPlugin!.UpdateTrackingStates(sessionId, true);
        };
        GCButton.Pressed += () =>
        {
            debuggerPlugin!.InvokeGCCollect(sessionId);
        };

        // Button layout.
        headPanelLayout.AddChild(enableAutoReloadToggle);
        headPanelLayout.AddChild(enableTrackingToggle);
        headPanelLayout.AddChild(enableStackTraceToggle);
        // Kind of like Unity's FlexibleSpace. Pushes the first three buttons to the left, and the remaining buttons to the right.
        headPanelLayout.AddChild(new Control()
        {
            SizeFlagsHorizontal = SizeFlags.Expand,
        });
        headPanelLayout.AddChild(reloadButton);
        headPanelLayout.AddChild(GCButton);

        // Tree goes last.
        AddChild(tree);
    }

    public override void _Process(double delta)
    {
        if (enableAutoReload)
        {
            if (interval++ % 120 == 0)
            {
                debuggerPlugin!.UpdateTrackingStates(sessionId);
            }
        }
    }

    static Variant GetSettingOrDefault(EditorSettings settings, string key, Variant @default)
    {
        if (settings.HasSetting(key))
        {
            return settings.GetSetting(key);
        }
        else
        {
            return @default;
        }
    }
}
#endif



================================================
FILE: src/R3.Godot/addons/R3.Godot/ObservableTrackerTree.cs
================================================
﻿#if TOOLS
#nullable enable

using Godot;
using System;
using System.Collections;
using System.Collections.Generic;

namespace R3;

[Tool]
public partial class ObservableTrackerTree : Tree
{
    ObservableTrackerDebuggerPlugin? debuggerPlugin;
    int sessionId;
    public void NotifyOnSessionSetup(ObservableTrackerDebuggerPlugin debuggerPlugin, int sessionId)
    {
        this.debuggerPlugin = debuggerPlugin;
        this.sessionId = sessionId;
        debuggerPlugin!.RegisterReceivedActiveTasks(sessionId, Reload);
        Clear();
    }

    public override void _Ready()
    {
        AllowReselect = false;
        Columns = 3;
        ColumnTitlesVisible = true;
        SetColumnTitle(0, "Type");
        SetColumnTitle(1, "Elapsed");
        SetColumnTitle(2, "StackTrace");
        SetColumnExpand(0, true);
        SetColumnExpand(1, true);
        SetColumnExpand(2, true);
        SetColumnExpandRatio(0, 3);
        SetColumnExpandRatio(1, 1);
        SetColumnExpandRatio(2, 6);
        SetColumnClipContent(0, true);
        SetColumnClipContent(1, true);
        SetColumnClipContent(2, true);
        HideRoot = true;
        SizeFlagsVertical = SizeFlags.ExpandFill;
    }

    public override void _ExitTree()
    {
        debuggerPlugin!.UnregisterReceivedActiveTasks(sessionId, Reload);
    }

    public void Reload(IEnumerable<TrackingState> states)
    {
        Clear();
        TreeItem root = CreateItem();
        foreach(TrackingState state in states)
        {
            TreeItem row = CreateItem(root);
            var now = DateTime.Now;
            // Type
            row.SetText(0, state.FormattedType);
            // Elapsed
            row.SetText(1, (now - state.AddTime).TotalSeconds.ToString("00.00"));
            // StackTrace
            row.SetText(2, state.StackTrace);
        };
    }
}
#endif



================================================
FILE: src/R3.Godot/addons/R3.Godot/plugin.cfg
================================================
[plugin]

name="R3.Godot"
description="The new future of dotnet/reactive and UniRx."
author="Cysharp"
version="1.3.0"
language="C-sharp"
script="GodotR3Plugin.cs"



================================================
FILE: src/R3.LogicLooper/LogicLooperFrameProvider.cs
================================================
﻿using System;
using System.ComponentModel.DataAnnotations;
using Cysharp.Threading;
using R3.Collections;

namespace R3;

public sealed class LogicLooperFrameProvider : FrameProvider, IDisposable
{
    bool disposed;
    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    Task loop;
    internal long timestamp;
    internal TimeSpan deltaTime;
    readonly object gate = new object();

    public LogicLooperFrameProvider(ILogicLooper looper)
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);

        this.frameCount = looper.CurrentFrame;
        this.loop = looper.RegisterActionAsync(Run);
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(LogicLooperFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(LogicLooperFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        disposed = true;
        list.Dispose();
    }

    bool Run(in LogicLooperActionContext context)
    {
        if (disposed) return false;

        frameCount = context.CurrentFrame;
        deltaTime = context.ElapsedTimeFromPreviousFrame;
        timestamp += context.ElapsedTimeFromPreviousFrame.Ticks;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }

        return true;
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3.LogicLooper/LogicLooperTimeProvider.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3;

public sealed class LogicLooperTimeProvider(LogicLooperFrameProvider frameProvider) : TimeProvider
{
    public override long GetTimestamp()
    {
        return frameProvider.timestamp;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new FrameTimer(callback, state, dueTime, period, frameProvider);
    }
}

internal sealed class FrameTimer : ITimer, IFrameRunnerWorkItem
{
    enum RunningState
    {
        Stop,
        RunningDueTime,
        RunningPeriod,
        ChangeRequested
    }

    readonly TimerCallback callback;
    readonly object? state;
    readonly LogicLooperFrameProvider frameProvider;
    readonly object gate = new object();

    TimeSpan dueTime;
    TimeSpan period;
    RunningState runningState;
    double elapsed;
    bool isDisposed;

    public FrameTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period, LogicLooperFrameProvider frameProvider)
    {
        this.callback = callback;
        this.state = state;
        this.dueTime = dueTime;
        this.period = period;
        this.frameProvider = frameProvider;
        Change(dueTime, period);
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (isDisposed) return false;

        lock (gate)
        {
            this.dueTime = dueTime;
            this.period = period;

            if (dueTime == Timeout.InfiniteTimeSpan)
            {
                if (runningState == RunningState.Stop)
                {
                    return true;
                }
            }

            if (runningState == RunningState.Stop)
            {
                frameProvider.Register(this);
            }

            runningState = RunningState.ChangeRequested;
        }
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    double GetDeltaTime()
    {
        return frameProvider.deltaTime.TotalSeconds;
    }

    bool IFrameRunnerWorkItem.MoveNext(long frameCount)
    {
        if (isDisposed) return false;

        RunningState runState;
        TimeSpan p; // period
        TimeSpan d; // dueTime
        lock (gate)
        {
            runState = runningState;

            if (runState == RunningState.ChangeRequested)
            {
                elapsed = 0;
                if (dueTime == Timeout.InfiniteTimeSpan)
                {
                    runningState = RunningState.Stop;
                    return false;
                }

                runState = runningState = RunningState.RunningDueTime;
            }
            p = period;
            d = dueTime;
        }

        elapsed += GetDeltaTime();

        try
        {
            if (runState == RunningState.RunningDueTime)
            {
                var dt = (float)d.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);

                    elapsed = 0;
                    if (period == Timeout.InfiniteTimeSpan)
                    {
                        return ChangeState(RunningState.Stop);
                    }
                    else
                    {
                        return ChangeState(RunningState.RunningPeriod);
                    }
                }
                else
                {
                    return true;
                }
            }
            else
            {
                var dt = (float)p.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);
                    elapsed = 0;
                }

                return ChangeState(RunningState.RunningPeriod);
            }
        }
        catch (Exception ex)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
            return ChangeState(RunningState.Stop);
        }
    }

    bool ChangeState(RunningState state)
    {
        lock (gate)
        {
            // change requested is high priority
            if (runningState == RunningState.ChangeRequested)
            {
                return true;
            }

            switch (state)
            {
                case RunningState.RunningPeriod:
                    runningState = state;
                    return true;
                default: // otherwise(Stop)
                    runningState = state;
                    return false;
            }
        }
    }

    public void Dispose()
    {
        Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
        isDisposed = true;
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.LogicLooper/R3.LogicLooper.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>netstandard2.0;netstandard2.1;net6.0;net8.0</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.LogicLooper</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>LogicLooper Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="LogicLooper" Version="1.5.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Maui/MauiAppBuilderExtensions.cs
================================================
﻿using Microsoft.Extensions.DependencyInjection;
using Microsoft.Maui.Hosting;

namespace R3.Maui;

public static class MauiAppBuilderExtensions
{
    public static MauiAppBuilder UseR3(this MauiAppBuilder builder)
    {
        builder.Services.AddSingleton<IMauiInitializeService, R3MauiInitializeService>();
        builder.Services.AddSingleton<IR3MauiExceptionHandler, R3MauiDefaultExceptionHandler>();
        return builder;
    }

    public static MauiAppBuilder UseR3(this MauiAppBuilder builder, Action<Exception> unhandledExceptionHandler)
    {
        builder.UseR3();
        builder.Services.AddSingleton<IR3MauiExceptionHandler>(new R3MauiAnonymousExceptionHandler(unhandledExceptionHandler));
        return builder;
    }
}



================================================
FILE: src/R3.Maui/MauiDispatcherTimeProvider.cs
================================================
﻿using Microsoft.Maui.Dispatching;

namespace R3;

public class MauiDispatcherTimeProvider(IDispatcher dispatcher) : TimeProvider
{
    public IDispatcher Dispatcher => dispatcher;

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        var dispatcherTimer = dispatcher.CreateTimer();
        return new MauiDispatcherTimeProviderTimer(dispatcherTimer, callback, state, dueTime, period);
    }
}

sealed class MauiDispatcherTimeProviderTimer : ITimer
{
    readonly TimerCallback callback;
    readonly object? state;
    readonly EventHandler timerTick;
    IDispatcherTimer? timer;
    TimeSpan? period;
    short timerId;

    public MauiDispatcherTimeProviderTimer(IDispatcherTimer timer, TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.timer = timer;
        this.timerTick = Tick;
        this.callback = callback;
        this.state = state;
        timer.Tick += timerTick;

        if (dueTime != Timeout.InfiniteTimeSpan)
        {
            Change(dueTime, period);
        }
    }

    public void Dispose()
    {
        if (timer != null)
        {
            timer.Stop();
            timer.Tick -= timerTick;
            timer = null;
        }
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (timer != null)
        {
            this.period = period;
            timer.Interval = dueTime;
            // when start, change timerId.
            unchecked { timerId++; }
            timer.Start();
            return true;
        }
        return false;
    }

    void Tick(object? sender, EventArgs _)
    {
        var id = timerId;
        callback(state);
        if (id != timerId)
        {
            // called new timer status, do nothing.
            return;
        }

        if (timer != null && period != null)
        {
            if (period.Value == Timeout.InfiniteTimeSpan)
            {
                period = null;
                unchecked { timerId++; }
                timer.Stop();
            }
            else
            {
                timer.Interval = period.Value;
                period = null;
            }
        }
    }
}



================================================
FILE: src/R3.Maui/MauiTickerFrameProvider.cs
================================================
using Microsoft.Maui.Animations;
using R3.Collections;

namespace R3;

public class MauiTickerFrameProvider : FrameProvider, IDisposable
{
    readonly ITicker ticker;
    readonly object gate = new();
    readonly Action timerTick;

    FreeListCore<IFrameRunnerWorkItem> runners;
    long frameCount;
    bool disposed;

    // frame loop is delayed until first register
    bool running;

    public MauiTickerFrameProvider(ITicker ticker)
    {
        this.ticker = ticker;
        timerTick = Tick;
        runners = new FreeListCore<IFrameRunnerWorkItem>(gate);
    }

    public override long GetFrameCount()
    {
        ThrowIfDisposed();
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowIfDisposed();
        lock (gate)
        {
            if (running == false)
            {
                if (!ticker.IsRunning)
                {
                    ticker.Start();
                }
                ticker.Fire += timerTick;
                running = true;
            }
            runners.Add(callback, out _);
        }
    }

    public void Dispose()
    {
        lock (gate)
        {
            disposed = true;
            ticker.Fire -= timerTick;
            runners.Dispose();
        }
    }

    void Tick()
    {
        frameCount++;

        var span = runners.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        runners.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    runners.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }

    void ThrowIfDisposed()
    {
        if (disposed)
        {
            throw new ObjectDisposedException(typeof(MauiTickerFrameProvider).FullName);
        }
    }
}



================================================
FILE: src/R3.Maui/ObserveOnExtensions.cs
================================================
﻿using Microsoft.Maui.Controls;
using Microsoft.Maui.Dispatching;
using R3.Collections;

namespace R3; // using R3

public static class ObserveOnExtensions
{
    static IDispatcher GetDefaultDispatcher() =>
        (ObservableSystem.DefaultTimeProvider as MauiDispatcherTimeProvider)?.Dispatcher
        ?? Application.Current!.Dispatcher;

    public static Observable<T> ObserveOnDispatcher<T>(this Observable<T> source)
    {
        return ObserveOnDispatcher(source, GetDefaultDispatcher());
    }

    public static Observable<T> ObserveOnDispatcher<T>(this Observable<T> source, IDispatcher dispatcher)
    {
        return new ObserveOnDispatcher<T>(source, dispatcher);
    }

    public static Observable<T> SubscribeOnUIThreadDispatcher<T>(this Observable<T> source)
    {
        return SubscribeOnDispatcher(source, GetDefaultDispatcher());
    }

    public static Observable<T> SubscribeOnDispatcher<T>(this Observable<T> source, IDispatcher dispatcher)
    {
        return new SubscribeOnDispatcher<T>(source, dispatcher);
    }
}

internal sealed class ObserveOnDispatcher<T>(Observable<T> source, IDispatcher dispatcher) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOnDispatcher(observer, dispatcher));
    }

    sealed class _ObserveOnDispatcher : Observer<T>
    {
        readonly Action postCallback;
        readonly Observer<T> observer;
        readonly IDispatcher dispatcher;
        readonly object gate = new();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOnDispatcher(Observer<T> observer, IDispatcher dispatcher)
        {
            this.observer = observer;
            this.dispatcher = dispatcher;
            this.postCallback = DrainMessages;
        }

        protected override void OnNextCore(T value)
        {
            EnqueueValue(new Notification<T>(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new Notification<T>(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new Notification<T>(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    dispatcher.Dispatch(postCallback);
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }

        void DrainMessages()
        {
            var self = this;

            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (self.gate)
            {
                values = self.list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

            FINALIZE:
            lock (self.gate)
            {
                self.list.Clear(token);

                if (self.IsDisposed)
                {
                    self.running = false;
                    return;
                }

                if (self.list.HasValue)
                {
                    // post again
                    dispatcher.Dispatch(postCallback);
                }
                else
                {
                    self.running = false;
                }
            }
        }
    }
}

internal sealed class SubscribeOnDispatcher<T>(Observable<T> source, IDispatcher dispatcher) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOnDispatcher(observer, source, dispatcher).Run();
    }

    sealed class _SubscribeOnDispatcher : Observer<T>
    {
        readonly Action postCallback;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly IDispatcher dispatcher;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOnDispatcher(Observer<T> observer, Observable<T> source, IDispatcher dispatcher)
        {
            this.observer = observer;
            this.source = source;
            this.dispatcher = dispatcher;
            this.postCallback = Subscribe;
        }

        public IDisposable Run()
        {
            dispatcher.Dispatch(postCallback);
            return this;
        }

        void Subscribe()
        {
            disposable.Disposable = source.Subscribe(this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}



================================================
FILE: src/R3.Maui/R3.Maui.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>netstandard2.0;netstandard2.1;net6.0;net8.0</TargetFrameworks>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573;CS8002</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.Maui</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>.NET MAUI Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Microsoft.Maui.Core" Version="8.0.3" />
      <PackageReference Include="Microsoft.Maui.Controls.Core" Version="8.0.3" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Maui/R3MauiExceptionHandler.cs
================================================
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace R3.Maui;

public interface IR3MauiExceptionHandler
{
    void HandleException(Exception ex);
}

public class R3MauiDefaultExceptionHandler(IServiceProvider serviceProvider) : IR3MauiExceptionHandler
{
    public void HandleException(Exception ex)
    {
        System.Diagnostics.Trace.TraceError("R3 Unhandled Exception {0}", ex);

        var logger = serviceProvider.GetService<ILogger<R3MauiDefaultExceptionHandler>>();
        logger?.LogError(ex, "R3 Unhandled Exception");
    }
}

public class R3MauiAnonymousExceptionHandler(Action<Exception> handler) : IR3MauiExceptionHandler
{
    public void HandleException(Exception ex)
    {
        handler(ex);
    }
}



================================================
FILE: src/R3.Maui/R3MauiInitializeService.cs
================================================
﻿using Microsoft.Maui.Animations;
using Microsoft.Maui.Dispatching;
using Microsoft.Maui.Hosting;
using R3.Maui;

namespace R3;

public class R3MauiInitializeService(
    IDispatcher dispatcher,
    ITicker ticker,
    IR3MauiExceptionHandler exceptionHandler) : IMauiInitializeService
{
    public void Initialize(IServiceProvider services)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(exceptionHandler.HandleException);
        ObservableSystem.DefaultTimeProvider = new MauiDispatcherTimeProvider(dispatcher);
        ObservableSystem.DefaultFrameProvider = new MauiTickerFrameProvider(ticker);
    }
}



================================================
FILE: src/R3.MonoGame/MonoGameFrameProvider.cs
================================================
using System;
using R3.Collections;

namespace R3;

public class MonoGameFrameProvider : FrameProvider
{
    public static readonly MonoGameFrameProvider Update = new();

    readonly object gate = new();
    FreeListCore<IFrameRunnerWorkItem> list;
    long frameCount;
    bool disposed;

    // frame loop is delayed until first register
    bool running;

    public MonoGameFrameProvider()
    {
        list = new FreeListCore<IFrameRunnerWorkItem>(gate);
    }

    public override long GetFrameCount()
    {
        ThrowIfDisposed();
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowIfDisposed();
        lock (gate)
        {
            running = true;
            list.Add(callback, out _);
        }
    }

    public void Dispose()
    {
        lock (gate)
        {
            disposed = true;
            list.Dispose();
        }
    }

    public void Tick()
    {
        if (!running) return;

        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch
                    {
                        // ignored
                    }
                }
            }
        }
    }

    void ThrowIfDisposed()
    {
        if (disposed)
        {
            throw new ObjectDisposedException(typeof(MonoGameFrameProvider).FullName);
        }
    }
}



================================================
FILE: src/R3.MonoGame/MonoGameObservableExtensions.cs
================================================
using System;
using Microsoft.Xna.Framework;

namespace R3;

public static class MonoGameObservableExtensions
{
    /// <summary>
    /// Observe the current GameTime once.
    /// </summary>
    public static Observable<GameTime> GameTime(this Observable<Unit> source)
    {
        return new GameTimeObservable(source, MonoGameTimeProvider.Update);
    }

    /// <summary>
    /// Observes the current GameTime and the value of the source observable.
    /// </summary>
    public static Observable<(GameTime GameTime, T Item)> GameTime<T>(this Observable<T> source)
    {
        return new GameTimeObservable<T>(source,  MonoGameTimeProvider.Update);
    }
}

internal sealed class GameTimeObservable(Observable<Unit> source, MonoGameTimeProvider frameProvider) : Observable<GameTime>
{
    protected override IDisposable SubscribeCore(Observer<GameTime> observer)
    {
        return source.Subscribe(new _GameTime(observer, frameProvider));
    }

    sealed class _GameTime(Observer<GameTime> observer, MonoGameTimeProvider timeProvider) : Observer<Unit>
    {
        protected override void OnNextCore(Unit value)
        {
            observer.OnNext(timeProvider.GameTime);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}

internal sealed class GameTimeObservable<T>(Observable<T> source, MonoGameTimeProvider timeProvider) : Observable<(GameTime gameTime, T Item)>
{
    protected override IDisposable SubscribeCore(Observer<(GameTime gameTime, T Item)> observer)
    {
        return source.Subscribe(new _GameTime(observer, timeProvider));
    }

    sealed class _GameTime(Observer<(GameTime GameTime, T Item)> observer, MonoGameTimeProvider timeProvider) : Observer<T>
    {
        protected override void OnNextCore(T value)
        {
            observer.OnNext((timeProvider.GameTime, value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }
    }
}



================================================
FILE: src/R3.MonoGame/MonoGameTimeProvider.cs
================================================
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using R3.Collections;

namespace R3;

public class MonoGameTimeProvider : TimeProvider, IDisposable
{
    public static readonly MonoGameTimeProvider Update = new();

    public GameTime GameTime { get; private set; } = new();

    FreeListCore<FrameTimer> list;
    readonly object gate = new();

    // frame loop is delayed until first register
    bool running;
    bool disposed;

    public MonoGameTimeProvider()
    {
        list = new FreeListCore<FrameTimer>(gate);
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new FrameTimer(callback, state, dueTime, period, this);
    }

    public override long GetTimestamp()
    {
        return GameTime.TotalGameTime.Ticks;
    }

    public void Dispose()
    {
        lock (gate)
        {
            disposed = true;
            list.Dispose();
        }
    }

    public void Tick(GameTime gameTime)
    {
        if (!running) return;

        this.GameTime = gameTime;

        var span = list.AsSpan();
        for (var i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.Tick(gameTime))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch
                    {
                        // ignored
                    }
                }
            }
        }
    }

    internal void Register(FrameTimer timer)
    {
        ThrowIfDisposed();
        lock (gate)
        {
            running = true;
            list.Add(timer, out _);
        }
    }

    void ThrowIfDisposed()
    {
        if (disposed)
        {
            throw new ObjectDisposedException(typeof(MonoGameFrameProvider).FullName);
        }
    }
}

internal sealed class FrameTimer : ITimer
{
    enum RunningState
    {
        Stop,
        RunningDueTime,
        RunningPeriod,
        ChangeRequested
    }

    readonly MonoGameTimeProvider timeProvider;
    readonly TimerCallback callback;
    readonly object? state;
    readonly object gate = new();

    TimeSpan dueTime;
    TimeSpan period;
    RunningState runningState;
    double elapsed;
    bool isDisposed;

    public FrameTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period, MonoGameTimeProvider timeProvider)
    {
        this.callback = callback;
        this.state = state;
        this.dueTime = dueTime;
        this.period = period;
        this.timeProvider = timeProvider;
        Change(dueTime, period);
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (isDisposed) return false;

        lock (gate)
        {
            this.dueTime = dueTime;
            this.period = period;

            if (dueTime == Timeout.InfiniteTimeSpan)
            {
                if (runningState == RunningState.Stop)
                {
                    return true;
                }
            }

            if (runningState == RunningState.Stop)
            {
                timeProvider.Register(this);
            }

            runningState = RunningState.ChangeRequested;
        }
        return true;
    }

    public bool Tick(GameTime gameTime)
    {
        if (isDisposed) return false;

        RunningState runState;
        TimeSpan p; // period
        TimeSpan d; // dueTime
        lock (gate)
        {
            runState = runningState;

            if (runState == RunningState.ChangeRequested)
            {
                elapsed = 0;
                if (dueTime == Timeout.InfiniteTimeSpan)
                {
                    runningState = RunningState.Stop;
                    return false;
                }

                runState = runningState = RunningState.RunningDueTime;
            }
            p = period;
            d = dueTime;
        }

        elapsed += gameTime.ElapsedGameTime.TotalSeconds; // ElapsedGameTime is delta time

        try
        {
            if (runState == RunningState.RunningDueTime)
            {
                var dt = (double)d.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);

                    elapsed = 0;
                    if (period == Timeout.InfiniteTimeSpan)
                    {
                        return ChangeState(RunningState.Stop);
                    }
                    return ChangeState(RunningState.RunningPeriod);
                }
                return true;
            }
            else
            {
                var dt = (double)p.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);
                    elapsed = 0;
                }

                return ChangeState(RunningState.RunningPeriod);
            }
        }
        catch (Exception ex)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
            return ChangeState(RunningState.Stop);
        }
    }

    bool ChangeState(RunningState state)
    {
        lock (gate)
        {
            // change requested is high priority
            if (runningState == RunningState.ChangeRequested)
            {
                return true;
            }

            switch (state)
            {
                case RunningState.RunningPeriod:
                    runningState = state;
                    return true;
                default: // otherwise(Stop)
                    runningState = state;
                    return false;
            }
        }
    }

    public void Dispose()
    {
        Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
        isDisposed = true;
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}




================================================
FILE: src/R3.MonoGame/ObservableSystemComponent.cs
================================================
﻿using System;
using Microsoft.Xna.Framework;

namespace R3;

public class ObservableSystemComponent(Game game, Action<Exception> exceptionHandler) : GameComponent(game)
{
    public ObservableSystemComponent(Game game)
        : this(game, ex => System.Diagnostics.Trace.TraceError("R3 Unhandled Exception {0}", ex))
    {
    }

    public override void Initialize()
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(exceptionHandler);
        ObservableSystem.DefaultTimeProvider = MonoGameTimeProvider.Update;
        ObservableSystem.DefaultFrameProvider = MonoGameFrameProvider.Update;
    }

    public override void Update(GameTime gameTime)
    {
        MonoGameTimeProvider.Update.Tick(gameTime);
        MonoGameFrameProvider.Update.Tick();
    }
}



================================================
FILE: src/R3.MonoGame/R3.MonoGame.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net6.0;net8.0</TargetFrameworks>
        <Nullable>enable</Nullable>
        <LangVersion>12</LangVersion>

        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573;CS8002</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.MonoGame</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>MonoGame Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="MonoGame.Framework.DesktopGL" Version="3.8.1.303">
            <PrivateAssets>All</PrivateAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Stride/README.md
================================================
# R3.Stride

R3 integration with Stride

* [R3](https://github.com/Cysharp/R3)
* [Stride](https://stride3d.net)

# Usage

## add default FrameProvider

1. Reference R3.Stride
2. add empty Entity by Stride editor
3. add "R3/R3 Frame Dispatcher"
4. set Stride Frame Provider Component's priority to execute subscribed callback

## add additional FrameProvider

1. Reference R3.Stride
2. add empty Entity by Stride editor
3. add "R3/additional R3 Frame Dispatcher"
4. set Stride Frame Provider Component's priority to execute subscribed callback
    * if you set priority to largest number in other script components, it behaves like Unity's LateUpdate
5. get `AdditionalR3FrameDispatcherComponent` in your script(e.g. `Entity.Get<AdditionalR3FrameDispatcherComponent>()`)
6. use `FrameProvider AdditionalR3FrameDispatcherComponent.FrameProvider` in R3 operator



================================================
FILE: src/R3.Stride/AdditionalR3FrameDispatcherComponent.cs
================================================
﻿using Stride.Core;
using Stride.Core.Annotations;
using Stride.Engine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using Stride.Engine.Design;

namespace R3.Stride;
[DataContract(nameof(AdditionalR3FrameDispatcherComponent))]
[Display("additional R3 frame dispatcher")]
[ComponentCategory("R3")]
[DefaultEntityComponentProcessor(typeof(AdditionalStrideFrameDispatcherProcessor), ExecutionMode = ExecutionMode.Runtime)]
public class AdditionalR3FrameDispatcherComponent : SyncScript
{
    [DataMemberIgnore]
    public StrideFrameProvider? FrameProvider { get; private set; }
    public override void Start()
    {
        InitializeFrameProvider();
    }
    public override void Update()
    {
        if(FrameProvider != null)
        {
            this.FrameProvider.Delta.Value = Game.UpdateTime.Total.TotalSeconds;
            this.FrameProvider.Run(Game.UpdateTime.Total.TotalSeconds);
        }
    }
    internal void InitializeFrameProvider()
    {
        if(FrameProvider == null)
        {
            FrameProvider = new StrideFrameProvider(Game);
            FrameProvider.Delta = new StrongBox<double>();
        }
    }
}

public class AdditionalStrideFrameDispatcherProcessor: EntityProcessor<AdditionalR3FrameDispatcherComponent>
{
    protected override void ProcessEntityComponent(Entity entity, EntityComponent entityComponentArg, bool forceRemove)
    {
        base.ProcessEntityComponent(entity, entityComponentArg, forceRemove);
    }
    protected override void OnEntityComponentAdding(Entity entity, [NotNull] AdditionalR3FrameDispatcherComponent component, [NotNull] AdditionalR3FrameDispatcherComponent data)
    {
        component.InitializeFrameProvider();
        base.OnEntityComponentAdding(entity, component, data);
    }
}



================================================
FILE: src/R3.Stride/Directory.Build.props
================================================
<Project>
  <!-- See https://aka.ms/dotnet/msbuild/customize for more details on customizing your build -->
  <Import Project="$(MSBuildThisFileDirectory)..\..\Directory.Build.props"/>
  <PropertyGroup>
    <!-- disable assembly signing for avoiding build failure related to Stride -->
    <AssemblyOriginatorKeyFile></AssemblyOriginatorKeyFile>
  </PropertyGroup>
</Project>



================================================
FILE: src/R3.Stride/Module.cs
================================================
﻿using Stride.Core;
using Stride.Core.Reflection;
namespace R3.Stride;
internal class Module
{
    [ModuleInitializer]
    public static void Initialize()
    {
        AssemblyRegistry.Register(typeof(Module).Assembly, AssemblyCommonCategories.Assets);
    }
}



================================================
FILE: src/R3.Stride/R3.Stride.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net8.0</TargetFrameworks>
        <Nullable>enable</Nullable>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.Stride</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>Stride Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="../R3/R3.csproj" />
        <PackageReference Include="Stride.Engine" Version="4.2.0.2067" PrivateAssets="contentfiles;analyzers" />
        <PackageReference Include="Stride.UI" Version="4.2.0.2067" PrivateAssets="contentFiles;analyzers" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.Stride/R3.Stride.sdpkg
================================================
!Package
SerializedVersion: {Assets: 3.1.0.0}
Meta:
    Name: R3.Stride
    Version: 1.0.0
    Authors: []
    Owners: []
    Dependencies: null
AssetFolders:
    -   Path: !dir Assets
ResourceFolders:
    - !dir Resources
OutputGroupDirectories: {}
ExplicitFolders: []
Bundles: []
TemplateFolders: []
RootAssets: []



================================================
FILE: src/R3.Stride/R3FrameDispatcherComponent.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Core;
using Stride.Engine;
using Stride.Games;
using System.Runtime.CompilerServices;
using Stride.Core.Serialization;
using Stride.Core.Annotations;
using Stride.Engine.Design;

namespace R3.Stride
{
    [ComponentCategory("R3")]
    [Display("R3 Frame Dispatcher")]
    [DataContract(nameof(R3FrameDispatcherComponent))]
    [DefaultEntityComponentProcessor(typeof(R3FrameDispatcherProcessor), ExecutionMode = ExecutionMode.Runtime)]
    public class R3FrameDispatcherComponent : SyncScript
    {
        public override void Start()
        {
            InitializeFrameProvider();
        }
        public override void Update()
        {
            if(StrideInitializer.DefaultFrameProvider != null)
            {
                StrideInitializer.DefaultFrameProvider.Delta.Value = Game.UpdateTime.Elapsed.TotalSeconds;
                StrideInitializer.DefaultFrameProvider.Run(Game.UpdateTime.Elapsed.TotalSeconds);
            }
        }
        internal void InitializeFrameProvider()
        {
            StrideInitializer.SetDefaultObservableSystem(Game);
        }
        internal void UninitializeFrameProvider()
        {
            StrideInitializer.ClearDefaultObservableSystem();
        }
    }
    public class R3FrameDispatcherProcessor: EntityProcessor<R3FrameDispatcherComponent>
    {
        protected override void OnEntityComponentAdding(Entity entity, [NotNull] R3FrameDispatcherComponent component, [NotNull] R3FrameDispatcherComponent data)
        {
            component.InitializeFrameProvider();
            base.OnEntityComponentAdding(entity, component, data);
        }
        protected override void OnEntityComponentRemoved(Entity entity, [NotNull] R3FrameDispatcherComponent component, [NotNull] R3FrameDispatcherComponent data)
        {
            component.UninitializeFrameProvider();
            base.OnEntityComponentRemoved(entity, component, data);
        }
    }
}



================================================
FILE: src/R3.Stride/R3StrideCollectionExtension.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Core.Collections;
using System.Threading;

namespace R3;
public static class R3StrideCollectionExtension
{
    public static Observable<(object? sender, TrackingCollectionChangedEventArgs arg)> CollectionChangedAsObservable(this ITrackingCollectionChanged hashset, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TrackingCollectionChangedEventArgs>(h => hashset.CollectionChanged += h, h => hashset.CollectionChanged -= h, token);
    }
    public static Observable<(object? sender, FastTrackingCollectionChangedEventArgs arg)> CollectionChangedAsObservable<T>(this FastTrackingCollection<T> collection, CancellationToken token = default)
    {
        return Observable.FromEvent<FastTrackingCollection<T>.FastEventHandler<FastTrackingCollectionChangedEventArgs>, (object?, FastTrackingCollectionChangedEventArgs)>(
            h =>
            {
                void Handler(object? sender, ref FastTrackingCollectionChangedEventArgs arg)
                {
                    h((sender, arg));
                }
                return new FastTrackingCollection<T>.FastEventHandler<FastTrackingCollectionChangedEventArgs>(Handler);
            },
            h => collection.CollectionChanged += h,
            h => collection.CollectionChanged -= h,
            token);
    }
}



================================================
FILE: src/R3.Stride/R3StrideEventExtension.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Stride.Engine;
using Stride.Engine.Events;

namespace R3;
public static class R3StrideEventExtension
{
    public static Observable<T> AsObservable<T>(this EventKey<T> eventKey, CancellationToken token = default)
    {
        return Observable.Create<T, (EventKey<T>, CancellationToken)>((eventKey, token), static (observer, state) =>
        {
            if(R3.Stride.StrideInitializer.DefaultFrameProvider == null)
            {
                throw new NullReferenceException("initialize default frameprovider first");
            }
            var (evk, token) = state;
            var receiver = new EventReceiver<T>(evk);
            var runnerItem = new EventReceiverRunnerItem<T>(observer, receiver, R3.Stride.StrideInitializer.DefaultFrameProvider, token);
            Stride.StrideInitializer.DefaultFrameProvider.Register(runnerItem);
            return runnerItem;
        });
    }
    public static Observable<Unit> AsObservable(this EventKey eventKey, CancellationToken token = default)
    {
        return Observable.Create<Unit, (EventKey, CancellationToken)>((eventKey, token), static (observer, state) =>
        {
            if (R3.Stride.StrideInitializer.DefaultFrameProvider == null)
            {
                throw new NullReferenceException("initialize default frameprovider first");
            }
            var (evk, token) = state;
            var receiver = new EventReceiver(evk);
            var runnerItem = new EventReceiverRunnerItem(observer, receiver, R3.Stride.StrideInitializer.DefaultFrameProvider, token);
            Stride.StrideInitializer.DefaultFrameProvider.Register(runnerItem);
            return runnerItem;
        });
    }
    sealed class EventReceiverRunnerItem : IFrameRunnerWorkItem, IDisposable
    {
        Observer<Unit> observer;
        CancellationToken token;
        IDisposable cancellationTokenSubscription;
        EventReceiver _receiver;
        public EventReceiverRunnerItem(Observer<Unit> observer, EventReceiver receiver, FrameProvider frameProvider, CancellationToken token = default)
        {
            this.observer = observer;
            this.token = token;
            this._receiver = receiver;
            if (token.CanBeCanceled)
            {
                this.cancellationTokenSubscription = token.UnsafeRegister(static (state) =>
                {
                    var item = state as EventReceiverRunnerItem;
                    if (item != null)
                    {
                        item.observer.OnCompleted();
                        item.Dispose();
                    }
                }, this);
            }
            else
            {
                this.cancellationTokenSubscription = Disposable.Empty;
            }
        }
        bool isDisposed = false;
        public bool MoveNext(long frameCount)
        {
            if (token.IsCancellationRequested || isDisposed)
            {
                return false;
            }
            if (observer.IsDisposed)
            {
                Dispose();
                return false;
            }
            if (_receiver.TryReceive())
            {
                observer.OnNext(Unit.Default);
            }
            return true;
        }
        public void Dispose()
        {
            if (!isDisposed)
            {
                isDisposed = true;
                cancellationTokenSubscription.Dispose();
                try
                {
                    _receiver.Dispose();
                } catch { }
            }
        }
    }
    // I did trying to merge EventReceiverRunnerItem and EventReceiverRunnerItem<T>, but could not.
    sealed class EventReceiverRunnerItem<T> : IFrameRunnerWorkItem, IDisposable
    {
        Observer<T> observer;
        CancellationToken token;
        IDisposable cancellationTokenSubscription;
        EventReceiver<T> _receiver;
        public EventReceiverRunnerItem(Observer<T> observer, EventReceiver<T> receiver, FrameProvider frameProvider, CancellationToken token = default)
        {
            this.observer = observer;
            this.token = token;
            this._receiver = receiver;
            if(token.CanBeCanceled)
            {
                this.cancellationTokenSubscription = token.UnsafeRegister(static (state) =>
                {
                    var item = state as EventReceiverRunnerItem<T>;
                    if(item != null)
                    {
                        item.observer.OnCompleted();
                        item.Dispose();
                    }
                }, this);
            }
            else
            {
                this.cancellationTokenSubscription = Disposable.Empty;
            }
        }
        bool isDisposed = false;
        public bool MoveNext(long frameCount)
        {
            if(token.IsCancellationRequested || isDisposed)
            {
                return false;
            }
            if(observer.IsDisposed)
            {
                Dispose();
                return false;
            }
            if(_receiver.TryReceive(out var item))
            {
                observer.OnNext(item);
            }
            return true;
        }
        public void Dispose()
        {
            if(!isDisposed)
            {
                isDisposed = true;
                cancellationTokenSubscription.Dispose();
                try
                {
                    _receiver.Dispose();
                } catch { }
            }
        }
    }
}



================================================
FILE: src/R3.Stride/R3StrideUIExtension.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Stride.UI;
using Stride.UI.Controls;
using Stride.UI.Events;
using Vortice.Vulkan;

namespace R3;
public static class R3StrideUIExtension
{
    // UIElement
    public static Observable<(object? sender, PropertyChangedArgs<MouseOverState> arg)> MouseOverStateChangedAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEvent<PropertyChangedHandler<MouseOverState>, (object?, PropertyChangedArgs<MouseOverState>)>(h => new PropertyChangedHandler<MouseOverState>((sender, arg) => h((sender, arg))),
            h => element.MouseOverStateChanged += h,
            h => element.MouseOverStateChanged -= h,
            token);
    }
    public static Observable<(object? sender, TouchEventArgs)> PreviewTouchDownAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.PreviewTouchDown += h, h => element.PreviewTouchDown -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> PreviewTouchMoveAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.PreviewTouchMove += h, h => element.PreviewTouchMove -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> PreviewTouchUpAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.PreviewTouchUp += h, h => element.PreviewTouchUp -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> TouchDownAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.TouchDown += h, h => element.TouchDown -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> TouchMoveAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.TouchMove += h, h => element.TouchMove -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> TouchUpAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.TouchUp += h, h => element.TouchUp -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> TouchEnterAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.TouchEnter += h, h => element.TouchEnter -= h, token);
    }
    public static Observable<(object? sender, TouchEventArgs)> TouchLeaveAsObservable(this UIElement element, CancellationToken token = default)
    {
        return Observable.FromEventHandler<TouchEventArgs>(h => element.TouchLeave += h, h => element.TouchLeave -= h, token);
    }
    // Button
    public static Observable<(object? sender, RoutedEventArgs arg)> ClickAsObservable(this ButtonBase btn, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => btn.Click += h, h => btn.Click -= h, token);
    }
    // Slider
    public static Observable<(object? sender, RoutedEventArgs arg)> ValueChangedAsObservable(this Slider slider, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => slider.ValueChanged += h, h => slider.ValueChanged -= h, token);
    }
    // EditText
    public static Observable<(object? sender, RoutedEventArgs arg)> TextChangedAsObservable(this EditText editText, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => editText.TextChanged += h, h => editText.TextChanged -= h, token);
    }
    // ToggleButton
    public static Observable<(object? sender, RoutedEventArgs arg)> CheckedAsObservable(this ToggleButton toggleButton, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => toggleButton.Checked += h, h => toggleButton.Checked -= h, token);
    }
    public static Observable<(object? sender, RoutedEventArgs arg)> IndeterminateAsObservable(this ToggleButton button, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => button.Indeterminate += h, h => button.Indeterminate -= h, token);
    }
    public static Observable<(object? sender, RoutedEventArgs arg)> UncheckedAsObservable(this ToggleButton toggleButton, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => toggleButton.Unchecked += h, h => toggleButton.Unchecked -= h, token);
    }
    // ModalElement
    public static Observable<(object? sender, RoutedEventArgs arg)> OutsideClickAsObservable(this ModalElement modalElement, CancellationToken token = default)
    {
        return Observable.FromEventHandler<RoutedEventArgs>(h => modalElement.OutsideClick += h, h => modalElement.OutsideClick -= h, token);
    }
}



================================================
FILE: src/R3.Stride/StrideFrameProvider.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using R3.Collections;
using Stride.Games;

namespace R3;

public sealed class StrideFrameProvider : FrameProvider
{
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    internal StrongBox<double> Delta = default!; // set from Node before running process.

    internal StrideFrameProvider(IGame game)
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        _Game = game;
    }

    readonly IGame _Game;

    public override long GetFrameCount()
    {
        if(_Game != null)
        {
            return _Game.UpdateTime.FrameCount;
        }
        else
        {
            return 0;
        }
    }

    internal TimeSpan GetTotalTime()
    {
        if(_Game != null)
        {
            return _Game.UpdateTime.Total;
        }
        else
        {
            return TimeSpan.Zero;
        }
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        list.Add(callback, out _);
    }

    internal void Run(double _)
    {
        long frameCount = GetFrameCount();

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }
}



================================================
FILE: src/R3.Stride/StrideInitializer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Stride.Games;
using Stride.Core.Diagnostics;
using System.Threading;

namespace R3.Stride
{
    public static class StrideInitializer
    {
        static readonly Logger _logger = GlobalLogger.GetLogger("R3.Stride");
        static void DefaultUnobservableExceptionHandler(Exception exception)
        {
            _logger.Error("UnobservableException", exception);
        }
        public static StrideFrameProvider? DefaultFrameProvider;
        public static StrideTimeProvider? DefaultTimeProvider;
        static IGame? gameObject;
        public static void ClearDefaultObservableSystem()
        {
            DefaultFrameProvider = null;
            DefaultTimeProvider = null;
        }
        public static void SetDefaultObservableSystem(IGame game, Action<Exception>? unobservableExceptionHandler = null)
        {
            if(game != null && (gameObject == null || !object.ReferenceEquals(game, gameObject)))
            {
                while (true)
                {
                    IGame? old = gameObject;
                    var retval = Interlocked.CompareExchange(ref gameObject, game, old);
                    if (old == retval)
                    {
                        break;
                    }
                }
                if (unobservableExceptionHandler != null)
                {
                    ObservableSystem.RegisterUnhandledExceptionHandler(unobservableExceptionHandler);
                }
                else
                {
                    ObservableSystem.RegisterUnhandledExceptionHandler(DefaultUnobservableExceptionHandler);
                }
                DefaultFrameProvider = new StrideFrameProvider(game);
                DefaultTimeProvider = new StrideTimeProvider(DefaultFrameProvider);
                DefaultFrameProvider.Delta = new System.Runtime.CompilerServices.StrongBox<double>();
                ObservableSystem.DefaultFrameProvider = DefaultFrameProvider;
                ObservableSystem.DefaultTimeProvider = DefaultTimeProvider;
            }
        }
    }
}



================================================
FILE: src/R3.Stride/StrideTimeProvider.cs
================================================
﻿using Stride.Games;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace R3;

public sealed class StrideTimeProvider: TimeProvider
{
    readonly StrideFrameProvider frameProvider;

    internal StrideTimeProvider(StrideFrameProvider frameProvider)
    {
        this.frameProvider = frameProvider;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new StrideFrameTimer(callback, state, dueTime, period, frameProvider);
    }

    public override long GetTimestamp()
    {
        return frameProvider.GetTotalTime().Ticks;
    }
}
internal sealed class StrideFrameTimer : ITimer, IFrameRunnerWorkItem
{
    enum RunningState
    {
        Stop,
        RunningDueTime,
        RunningPeriod,
        ChangeRequested
    }
    readonly TimerCallback callback;
    readonly object? state;
    TimeSpan dueTime;
    TimeSpan period;
    bool isDisposed;
    readonly StrideFrameProvider frameProvider;
    readonly object gate = new object();
    RunningState runningState;
    double elapsed;


    public StrideFrameTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period, StrideFrameProvider frameProvider)
    {
        this.callback = callback;
        this.state = state;
        this.dueTime = dueTime;
        this.period = period;
        runningState = RunningState.Stop;
        isDisposed = false;
        this.frameProvider = frameProvider;
        elapsed = 0;
        Change(dueTime, period);
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (isDisposed) return false;

        lock (gate)
        {
            this.dueTime = dueTime;
            this.period = period;

            if (dueTime == Timeout.InfiniteTimeSpan)
            {
                if (runningState == RunningState.Stop)
                {
                    return true;
                }
            }

            if (runningState == RunningState.Stop)
            {
                frameProvider.Register(this);
            }

            runningState = RunningState.ChangeRequested;
        }
        return true;
    }

    public void Dispose()
    {
        Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
        isDisposed = true;
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return ValueTask.CompletedTask;
    }

    public bool MoveNext(long frameCount)
    {
        if (isDisposed) return false;

        RunningState runState;
        TimeSpan p; // period
        TimeSpan d; // dueTime
        lock (gate)
        {
            runState = runningState;

            if (runState == RunningState.ChangeRequested)
            {
                elapsed = 0;
                if (dueTime == Timeout.InfiniteTimeSpan)
                {
                    runningState = RunningState.Stop;
                    return false;
                }

                runState = runningState = RunningState.RunningDueTime;
            }
            p = period;
            d = dueTime;
        }

        elapsed += frameProvider.Delta.Value;

        try
        {
            if (runState == RunningState.RunningDueTime)
            {
                var dt = (double)d.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);

                    elapsed = 0;
                    if (period == Timeout.InfiniteTimeSpan)
                    {
                        return ChangeState(RunningState.Stop);
                    }
                    else
                    {
                        return ChangeState(RunningState.RunningPeriod);
                    }
                }
                else
                {
                    return true;
                }
            }
            else
            {
                var dt = (double)p.TotalSeconds;
                if (elapsed >= dt)
                {
                    callback(state);
                    elapsed = 0;
                }

                return ChangeState(RunningState.RunningPeriod);
            }
        }
        catch (Exception ex)
        {
            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
            return ChangeState(RunningState.Stop);
        }
    }
    bool ChangeState(RunningState state)
    {
        lock (gate)
        {
            // change requested is high priority
            if (runningState == RunningState.ChangeRequested)
            {
                return true;
            }

            switch (state)
            {
                case RunningState.RunningPeriod:
                    runningState = state;
                    return true;
                default: // otherwise(Stop)
                    runningState = state;
                    return false;
            }
        }
    }
}



================================================
FILE: src/R3.Unity/.vsconfig
================================================
﻿{
  "version": "1.0",
  "components": [
    "Microsoft.VisualStudio.Workload.ManagedGame"
  ]
}



================================================
FILE: src/R3.Unity/Assets/NuGet.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
  <disabledPackageSources />
  <activePackageSource>
    <add key="All" value="(Aggregate source)" />
  </activePackageSource>
  <config>
    <add key="repositoryPath" value="./Packages" />
    <add key="PackagesConfigDirectoryPath" value="." />
    <add key="slimRestore" value="true" />
  </config>
</configuration>


================================================
FILE: src/R3.Unity/Assets/NuGet.config.meta
================================================
fileFormatVersion: 2
guid: d451c6e4bf6ed114eb4d99196f23dbf6
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.Bcl.AsyncInterfaces" version="6.0.0" manuallyInstalled="true" />
  <package id="Microsoft.Bcl.TimeProvider" version="8.0.0" manuallyInstalled="true" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" manuallyInstalled="true" />
  <package id="System.Threading.Channels" version="8.0.0" manuallyInstalled="true" />
</packages>


================================================
FILE: src/R3.Unity/Assets/packages.config.meta
================================================
fileFormatVersion: 2
guid: 42288f3cbf75a1342a22425c76f9a4ff
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages.meta
================================================
fileFormatVersion: 2
guid: 43802844a6303ab43b50f03d6a366cd6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity.meta
================================================
fileFormatVersion: 2
guid: 7f945005998564e4e94663edb0f71b18
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Scenes.meta
================================================
fileFormatVersion: 2
guid: 131a6b21c8605f84396be9f6751fb6e3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI.meta
================================================
fileFormatVersion: 2
guid: f788124761da08c4380e6e4fd0679e78
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0.meta
================================================
fileFormatVersion: 2
guid: bf9a11b79e963b54eae11cc8f75e83ef
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0.meta
================================================
fileFormatVersion: 2
guid: d21364578054b084ab9af41f4c8417e7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0.meta
================================================
fileFormatVersion: 2
guid: e782158a00f879a4e9f0bd91ccf73baf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0.meta
================================================
fileFormatVersion: 2
guid: b3893278e1fa5fc4d9325075b55cdc73
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: 512b49cecbc80f343b4c82bcca55be76
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: 49fe32c2bd30afc4fab296670179c676
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: ff3fc3e7bb69549478f1b69f102070c3
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/Microsoft.Bcl.AsyncInterfaces.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata>
    <id>Microsoft.Bcl.AsyncInterfaces</id>
    <version>6.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <projectUrl>https://dot.net/</projectUrl>
    <description>Provides the IAsyncEnumerable&lt;T&gt; and IAsyncDisposable interfaces and helper types for .NET Standard 2.0. This package is not required starting with .NET Standard 2.1 and .NET Core 3.0.

Commonly Used Types:
System.IAsyncDisposable
System.Collections.Generic.IAsyncEnumerable
System.Collections.Generic.IAsyncEnumerator</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="4822e3c3aa77eb82b2fb33c9321f923cf11ddde6" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.1">
        <dependency id="System.Threading.Tasks.Extensions" version="4.5.4" exclude="Build,Analyzers" />
      </group>
      <group targetFramework=".NETStandard2.0">
        <dependency id="System.Threading.Tasks.Extensions" version="4.5.4" exclude="Build,Analyzers" />
      </group>
      <group targetFramework=".NETStandard2.1" />
    </dependencies>
  </metadata>
</package>


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/Microsoft.Bcl.AsyncInterfaces.nuspec.meta
================================================
fileFormatVersion: 2
guid: cf3a301f8031ca14095019f4c1c14421
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/THIRD-PARTY-NOTICES.TXT
================================================
.NET Runtime uses third-party libraries or other resources that may be
distributed under licenses different than the .NET Runtime software.

In the event that we accidentally failed to list a required notice, please
bring it to our attention. Post an issue or email us:

           dotnet@microsoft.com

The attached notices are provided for information only.

License notice for ASP.NET
-------------------------------

Copyright (c) .NET Foundation. All rights reserved.
Licensed under the Apache License, Version 2.0.

Available at
https://github.com/dotnet/aspnetcore/blob/main/LICENSE.txt

License notice for Slicing-by-8
-------------------------------

http://sourceforge.net/projects/slicing-by-8/

Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved


This software program is licensed subject to the BSD License,  available at
http://www.opensource.org/licenses/bsd-license.html.


License notice for Unicode data
-------------------------------

https://www.unicode.org/license.html

Copyright © 1991-2020 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Unicode data files and any associated documentation
(the "Data Files") or Unicode software and any associated documentation
(the "Software") to deal in the Data Files or Software
without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, and/or sell copies of
the Data Files or Software, and to permit persons to whom the Data Files
or Software are furnished to do so, provided that either
(a) this copyright and permission notice appear with all copies
of the Data Files or Software, or
(b) this copyright and permission notice appear in associated
Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in these Data Files or Software without prior
written authorization of the copyright holder.

License notice for Zlib
-----------------------

https://github.com/madler/zlib
http://zlib.net/zlib_license.html

/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/

License notice for Mono
-------------------------------

http://www.mono-project.com/docs/about-mono/

Copyright (c) .NET Foundation Contributors

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software  and associated documentation files (the Software), to deal
in the Software without restriction,  including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense,  and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so,  subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for International Organization for Standardization
-----------------------------------------------------------------

Portions (C) International Organization for Standardization 1986:
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

License notice for Intel
------------------------

"Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Xamarin and Novell
-------------------------------------

Copyright (c) 2015 Xamarin, Inc (http://www.xamarin.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Copyright (c) 2011 Novell, Inc (http://www.novell.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Third party notice for W3C
--------------------------

"W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE
Status: This license takes effect 13 May, 2015.
This work is being provided by the copyright holders under the following license.
License
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.
Permission to copy, modify, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:
The full text of this NOTICE in a location viewable to users of the redistributed or derivative work.
Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software and Document Short Notice should be included.
Notice of any changes or modifications, through a copyright statement on the new code or document such as "This software or document includes material copied from or derived from [title and URI of the W3C document]. Copyright © [YEAR] W3C® (MIT, ERCIM, Keio, Beihang)."
Disclaimers
THIS WORK IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.
The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders."

License notice for Bit Twiddling Hacks
--------------------------------------

Bit Twiddling Hacks

By Sean Eron Anderson
seander@cs.stanford.edu

Individually, the code snippets here are in the public domain (unless otherwise
noted) — feel free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are
distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and
without even the implied warranty of merchantability or fitness for a particular
purpose.

License notice for Brotli
--------------------------------------

Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

compress_fragment.c:
Copyright (c) 2011, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

decode_fuzzer.c:
Copyright (c) 2015 The Chromium Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

License notice for Json.NET
-------------------------------

https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md

The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized base64 encoding / decoding
--------------------------------------------------------

Copyright (c) 2005-2007, Nick Galbreath
Copyright (c) 2013-2017, Alfred Klomp
Copyright (c) 2015-2017, Wojciech Mula
Copyright (c) 2016-2017, Matthieu Darbois
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for RFC 3492
---------------------------

The punycode implementation is based on the sample code in RFC 3492

Copyright (C) The Internet Society (2003).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

License notice for Algorithm from Internet Draft document "UUIDs and GUIDs"
---------------------------------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, or Digital Equipment Corporation be used in advertising
or publicity pertaining to distribution of the software without
specific, written prior permission.  Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
Corporation makes any representations about the suitability of
this software for any purpose.

Copyright(C) The Internet Society 1997. All Rights Reserved.

This document and translations of it may be copied and furnished to others,
and derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published and distributed, in
whole or in part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such copies and
derivative works.However, this document itself may not be modified in any
way, such as by removing the copyright notice or references to the Internet
Society or other Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for copyrights
defined in the Internet Standards process must be followed, or as required
to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked
by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS IS"
basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE
DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

License notice for Algorithm from RFC 4122 -
A Universally Unique IDentifier (UUID) URN Namespace
----------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
Copyright (c) 1998 Microsoft.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, Microsoft, or Digital Equipment Corporation be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission. Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
Equipment Corporation makes any representations about the
suitability of this software for any purpose."

License notice for The LLVM Compiler Infrastructure
---------------------------------------------------

Developed by:

    LLVM Team

    University of Illinois at Urbana-Champaign

    http://llvm.org

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimers.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimers in the
      documentation and/or other materials provided with the distribution.

    * Neither the names of the LLVM Team, University of Illinois at
      Urbana-Champaign, nor the names of its contributors may be used to
      endorse or promote products derived from this Software without specific
      prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
SOFTWARE.

License notice for Bob Jenkins
------------------------------

By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this
code any way you wish, private, educational, or commercial.  It's free.

License notice for Greg Parker
------------------------------

Greg Parker     gparker@cs.stanford.edu     December 2000
This code is in the public domain and may be copied or modified without
permission.

License notice for libunwind based code
----------------------------------------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for Printing Floating-Point Numbers (Dragon4)
------------------------------------------------------------

/******************************************************************************
  Copyright (c) 2014 Ryan Juckett
  http://www.ryanjuckett.com/

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
******************************************************************************/

License notice for Printing Floating-point Numbers (Grisu3)
-----------------------------------------------------------

Copyright 2012 the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xxHash
-------------------------

xxHash Library
Copyright (c) 2012-2014, Yann Collet
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Berkeley SoftFloat Release 3e
------------------------------------------------

https://github.com/ucb-bar/berkeley-softfloat-3
https://github.com/ucb-bar/berkeley-softfloat-3/blob/master/COPYING.txt

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xoshiro RNGs
--------------------------------

Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>.

License for fastmod (https://github.com/lemire/fastmod) and ibm-fpgen (https://github.com/nigeltao/parse-number-fxx-test-data)
--------------------------------------

   Copyright 2018 Daniel Lemire

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

License notice for The C++ REST SDK
-----------------------------------

C++ REST SDK

The MIT License (MIT)

Copyright (c) Microsoft Corporation

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for MessagePack-CSharp
-------------------------------------

MessagePack for C#

MIT License

Copyright (c) 2017 Yoshifumi Kawai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for lz4net
-------------------------------------

lz4net

Copyright (c) 2013-2017, Milosz Krajewski

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Nerdbank.Streams
-----------------------------------

The MIT License (MIT)

Copyright (c) Andrew Arnott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for RapidJSON
----------------------------

Tencent is pleased to support the open source community by making RapidJSON available.

Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved.

Licensed under the MIT License (the "License"); you may not use this file except
in compliance with the License. You may obtain a copy of the License at

http://opensource.org/licenses/MIT

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.

License notice for DirectX Math Library
---------------------------------------

https://github.com/microsoft/DirectXMath/blob/master/LICENSE

                               The MIT License (MIT)

Copyright (c) 2011-2020 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for ldap4net
---------------------------

The MIT License (MIT)

Copyright (c) 2018 Alexander Chermyanin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized sorting code
------------------------------------------

MIT License

Copyright (c) 2020 Dan Shechter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for musl
-----------------------

musl as a whole is licensed under the following standard MIT license:

Copyright © 2005-2020 Rich Felker, et al.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


License notice for "Faster Unsigned Division by Constants"
------------------------------

Reference implementations of computing and using the "magic number" approach to dividing
by constants, including codegen instructions. The unsigned division incorporates the
"round down" optimization per ridiculous_fish.

This is free and unencumbered software. Any copyright is dedicated to the Public Domain.


License notice for mimalloc
-----------------------------------

MIT License

Copyright (c) 2019 Microsoft Corporation, Daan Leijen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: eda7afb40b1e52d4bad4ce21b2ee7f76
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: 2ac4a73598e120a4ab4e613d10523ce5
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/lib/netstandard2.1.meta
================================================
fileFormatVersion: 2
guid: 5c49bb166a48ebe4699ba849c98aa375
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/lib/netstandard2.1/Microsoft.Bcl.AsyncInterfaces.dll.meta
================================================
fileFormatVersion: 2
guid: 2748bb0a1a9da384097287fcf4613a09
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/lib/netstandard2.1/Microsoft.Bcl.AsyncInterfaces.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Bcl.AsyncInterfaces</name>
    </assembly>
    <members>
    </members>
</doc>



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.AsyncInterfaces.6.0.0/lib/netstandard2.1/Microsoft.Bcl.AsyncInterfaces.xml.meta
================================================
fileFormatVersion: 2
guid: 7c1643025e933c64dba104c92e625795
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive.meta
================================================
fileFormatVersion: 2
guid: 676aff98f0af9e149a82498964fd89ee
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: 7eae56cc544986e47943d614eee6d1de
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: 3057d169b27c5934ebb3aa5d93faf5c7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: 7fb6738086433354dbfa4033f7a02e81
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/Microsoft.Bcl.TimeProvider.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata>
    <id>Microsoft.Bcl.TimeProvider</id>
    <version>8.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <readme>PACKAGE.md</readme>
    <projectUrl>https://dot.net/</projectUrl>
    <description>Provides support for system time abstraction primitives for .NET Framework and .NET Standard.

Commonly Used Types:
System.TimeProvider
System.ITimer</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="5535e31a712343a63f5d7d796cd874e563e5ac14" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.2">
        <dependency id="Microsoft.Bcl.AsyncInterfaces" version="6.0.0" exclude="Build,Analyzers" />
        <dependency id="System.ValueTuple" version="4.5.0" exclude="Build,Analyzers" />
      </group>
      <group targetFramework="net8.0" />
      <group targetFramework=".NETStandard2.0">
        <dependency id="Microsoft.Bcl.AsyncInterfaces" version="6.0.0" exclude="Build,Analyzers" />
      </group>
    </dependencies>
  </metadata>
</package>


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/Microsoft.Bcl.TimeProvider.nuspec.meta
================================================
fileFormatVersion: 2
guid: c0d237050d9f6d541acb4a452555b31b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/PACKAGE.md
================================================
## About

Microsoft.Bcl.TimeProvider provides time abstraction support for apps targeting .NET 7 and earlier, as well as those intended for the .NET Framework. For apps targeting .NET 8 and newer versions, referencing this package is unnecessary, as the types it contains are already included in the .NET 8 and higher platform versions.

## Key Features

* Provides a common abstraction for time-related operations.

## How to Use

```csharp
using System;

// A class that uses TimeProvider to get the current time in Utc coordinates
public class UtcClock
{
    private readonly TimeProvider _timeProvider;

    // Constructor that takes a TimeProvider as a dependency
    public Clock(TimeProvider timeProvider)
    {
        _timeProvider = timeProvider;
    }

    // A method that returns the current time as a string
    public string GetTime()
    {
        return _timeProvider.GetLocalNow().ToString("HH:mm:ss");
    }
}

// A class that inherits from TimeProvider and overrides the GetLocalNow method
public class UtcTimeProvider : TimeProvider
{
    // Override the GetLocalNow method to always return UTC time
    public override DateTimeOffset GetLocalNow()
    {
        return TimeProvider.System.GetUtcNow();
    }
}

```

## Main Types

The main types provided by this library are:

* `TimeProvider`
* `TimeProviderTaskExtensions`

## Additional Documentation

* [API documentation](https://learn.microsoft.com/dotnet/api/system.timeprovider)

## Feedback & Contributing

Microsoft.Bcl.TimeProvider is released as open source under the [MIT license](https://licenses.nuget.org/MIT). Bug reports and contributions are welcome at [the GitHub repository](https://github.com/dotnet/runtime).


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/PACKAGE.md.meta
================================================
fileFormatVersion: 2
guid: 9fea3ae3e6a4803459141658f9225627
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: d1fe757ecc72370429eda606275f2fad
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: 4f61331636f3ae848bdb61f5eb53f6f7
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net461.meta
================================================
fileFormatVersion: 2
guid: ac63155f439382b4ea929846bbbb3cc3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net462.meta
================================================
fileFormatVersion: 2
guid: edc3cfd6d364d9f4ca38f9ed10b1f060
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net6.0.meta
================================================
fileFormatVersion: 2
guid: 7788567b5eb28284593be9887664cd8b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/netcoreapp2.0.meta
================================================
fileFormatVersion: 2
guid: 6782f9ea56a5ab44bb16c9f0de2e8c17
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net461/Microsoft.Bcl.TimeProvider.targets
================================================
<Project InitialTargets="NETStandardCompatError_Microsoft_Bcl_TimeProvider_net462">
  <Target Name="NETStandardCompatError_Microsoft_Bcl_TimeProvider_net462"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Warning Text="Microsoft.Bcl.TimeProvider 8.0.0 doesn't support $(TargetFramework) and has not been tested with it. Consider upgrading your TargetFramework to net462 or later. You may also set &lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt; in the project file to ignore this warning and attempt to run in this unsupported configuration at your own risk." />
  </Target>
</Project>



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net461/Microsoft.Bcl.TimeProvider.targets.meta
================================================
fileFormatVersion: 2
guid: 4dbfd286615ac384ca40d87a4b238494
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net462/_._
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net462/_._.meta
================================================
fileFormatVersion: 2
guid: b43afab54bc0c1844b084617e115eb27
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net6.0/_._
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/net6.0/_._.meta
================================================
fileFormatVersion: 2
guid: 7c8f13d0e74feb148be6507a3634f83a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/netcoreapp2.0/Microsoft.Bcl.TimeProvider.targets
================================================
<Project InitialTargets="NETStandardCompatError_Microsoft_Bcl_TimeProvider_net6_0">
  <Target Name="NETStandardCompatError_Microsoft_Bcl_TimeProvider_net6_0"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Warning Text="Microsoft.Bcl.TimeProvider 8.0.0 doesn't support $(TargetFramework) and has not been tested with it. Consider upgrading your TargetFramework to net6.0 or later. You may also set &lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt; in the project file to ignore this warning and attempt to run in this unsupported configuration at your own risk." />
  </Target>
</Project>



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/buildTransitive/netcoreapp2.0/Microsoft.Bcl.TimeProvider.targets.meta
================================================
fileFormatVersion: 2
guid: ef77ef0aeb9e98c4b809412222f2bc27
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/lib/netstandard2.0.meta
================================================
fileFormatVersion: 2
guid: cfe6f3eca2ca897449538935dea96292
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/lib/netstandard2.0/Microsoft.Bcl.TimeProvider.dll.meta
================================================
fileFormatVersion: 2
guid: 8859797c29624ff43ad81b991fb59f24
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/lib/netstandard2.0/Microsoft.Bcl.TimeProvider.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Bcl.TimeProvider</name>
    </assembly>
    <members>
        <member name="T:System.TimeProvider">
            <summary>Provides an abstraction for time.</summary>
        </member>
        <member name="P:System.TimeProvider.System">
            <summary>
            Gets a <see cref="T:System.TimeProvider"/> that provides a clock based on <see cref="P:System.DateTimeOffset.UtcNow"/>,
            a time zone based on <see cref="P:System.TimeZoneInfo.Local"/>, a high-performance time stamp based on <see cref="T:System.Diagnostics.Stopwatch"/>,
            and a timer based on <see cref="T:System.Threading.Timer"/>.
            </summary>
            <remarks>
            If the <see cref="P:System.TimeZoneInfo.Local"/> changes after the object is returned, the change will be reflected in any subsequent operations that retrieve <see cref="M:System.TimeProvider.GetLocalNow"/>.
            </remarks>
        </member>
        <member name="M:System.TimeProvider.#ctor">
            <summary>
            Initializes the <see cref="T:System.TimeProvider"/>.
            </summary>
        </member>
        <member name="M:System.TimeProvider.GetUtcNow">
            <summary>
            Gets a <see cref="T:System.DateTimeOffset"/> value whose date and time are set to the current
            Coordinated Universal Time (UTC) date and time and whose offset is Zero,
            all according to this <see cref="T:System.TimeProvider"/>'s notion of time.
            </summary>
            <remarks>
            The default implementation returns <see cref="P:System.DateTimeOffset.UtcNow"/>.
            </remarks>
        </member>
        <member name="M:System.TimeProvider.GetLocalNow">
            <summary>
            Gets a <see cref="T:System.DateTimeOffset"/> value that is set to the current date and time according to this <see cref="T:System.TimeProvider"/>'s
            notion of time based on <see cref="M:System.TimeProvider.GetUtcNow"/>, with the offset set to the <see cref="P:System.TimeProvider.LocalTimeZone"/>'s offset from Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="P:System.TimeProvider.LocalTimeZone">
            <summary>
            Gets a <see cref="T:System.TimeZoneInfo"/> object that represents the local time zone according to this <see cref="T:System.TimeProvider"/>'s notion of time.
            </summary>
            <remarks>
            The default implementation returns <see cref="P:System.TimeZoneInfo.Local"/>.
            </remarks>
        </member>
        <member name="P:System.TimeProvider.TimestampFrequency">
            <summary>
            Gets the frequency of <see cref="M:System.TimeProvider.GetTimestamp"/> of high-frequency value per second.
            </summary>
            <remarks>
            The default implementation returns <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>. For a given TimeProvider instance, the value must be idempotent and remain unchanged.
            </remarks>
        </member>
        <member name="M:System.TimeProvider.GetTimestamp">
            <summary>
            Gets the current high-frequency value designed to measure small time intervals with high accuracy in the timer mechanism.
            </summary>
            <returns>A long integer representing the high-frequency counter value of the underlying timer mechanism. </returns>
            <remarks>
            The default implementation returns <see cref="M:System.Diagnostics.Stopwatch.GetTimestamp"/>.
            </remarks>
        </member>
        <member name="M:System.TimeProvider.GetElapsedTime(System.Int64,System.Int64)">
            <summary>
            Gets the elapsed time between two timestamps retrieved using <see cref="M:System.TimeProvider.GetTimestamp"/>.
            </summary>
            <param name="startingTimestamp">The timestamp marking the beginning of the time period.</param>
            <param name="endingTimestamp">The timestamp marking the end of the time period.</param>
            <returns>A <see cref="T:System.TimeSpan"/> for the elapsed time between the starting and ending timestamps.</returns>
        </member>
        <member name="M:System.TimeProvider.GetElapsedTime(System.Int64)">
            <summary>
            Gets the elapsed time since the <paramref name="startingTimestamp"/> value retrieved using <see cref="M:System.TimeProvider.GetTimestamp"/>.
            </summary>
            <param name="startingTimestamp">The timestamp marking the beginning of the time period.</param>
            <returns>A <see cref="T:System.TimeSpan"/> for the elapsed time between the starting timestamp and the time of this call./></returns>
        </member>
        <member name="M:System.TimeProvider.CreateTimer(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
            <summary>Creates a new <see cref="T:System.Threading.ITimer"/> instance, using <see cref="T:System.TimeSpan"/> values to measure time intervals.</summary>
            <param name="callback">
            A delegate representing a method to be executed when the timer fires. The method specified for callback should be reentrant,
            as it may be invoked simultaneously on two threads if the timer fires again before or while a previous callback is still being handled.
            </param>
            <param name="state">An object to be passed to the <paramref name="callback"/>. This may be null.</param>
            <param name="dueTime">The amount of time to delay before <paramref name="callback"/> is invoked. Specify <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> to prevent the timer from starting. Specify <see cref="F:System.TimeSpan.Zero"/> to start the timer immediately.</param>
            <param name="period">The time interval between invocations of <paramref name="callback"/>. Specify <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> to disable periodic signaling.</param>
            <returns>
            The newly created <see cref="T:System.Threading.ITimer"/> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The number of milliseconds in the value of <paramref name="dueTime"/> or <paramref name="period"/> is negative and not equal to <see cref="F:System.Threading.Timeout.Infinite"/>, or is greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <remarks>
            <para>
            The delegate specified by the callback parameter is invoked once after <paramref name="dueTime"/> elapses, and thereafter each time the <paramref name="period"/> time interval elapses.
            </para>
            <para>
            If <paramref name="dueTime"/> is zero, the callback is invoked immediately. If <paramref name="dueTime"/> is -1 milliseconds, <paramref name="callback"/> is not invoked; the timer is disabled,
            but can be re-enabled by calling the <see cref="M:System.Threading.ITimer.Change(System.TimeSpan,System.TimeSpan)"/> method.
            </para>
            <para>
            If <paramref name="period"/> is 0 or -1 milliseconds and <paramref name="dueTime"/> is positive, <paramref name="callback"/> is invoked once; the periodic behavior of the timer is disabled,
            but can be re-enabled using the <see cref="M:System.Threading.ITimer.Change(System.TimeSpan,System.TimeSpan)"/> method.
            </para>
            <para>
            The return <see cref="T:System.Threading.ITimer"/> instance will be implicitly rooted while the timer is still scheduled.
            </para>
            <para>
            <see cref="M:System.TimeProvider.CreateTimer(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)"/> captures the <see cref="T:System.Threading.ExecutionContext"/> and stores that with the <see cref="T:System.Threading.ITimer"/> for use in invoking <paramref name="callback"/>
            each time it's called. That capture can be suppressed with <see cref="M:System.Threading.ExecutionContext.SuppressFlow"/>.
            </para>
            </remarks>
        </member>
        <member name="T:System.TimeProvider.SystemTimeProviderTimer">
            <summary>Thin wrapper for a <see cref="T:System.Threading.Timer"/>.</summary>
            <remarks>
            We don't return a TimerQueueTimer directly as it implements IThreadPoolWorkItem and we don't
            want it exposed in a way that user code could directly queue the timer to the thread pool.
            We also use this instead of Timer because CreateTimer needs to return a timer that's implicitly
            rooted while scheduled.
            </remarks>
        </member>
        <member name="T:System.TimeProvider.SystemTimeProvider">
            <summary>
            Used to create a <see cref="T:System.TimeProvider"/> instance returned from <see cref="P:System.TimeProvider.System"/> and uses the default implementation
            provided by <see cref="T:System.TimeProvider"/> which uses <see cref="P:System.DateTimeOffset.UtcNow"/>, <see cref="P:System.TimeZoneInfo.Local"/>, <see cref="T:System.Diagnostics.Stopwatch"/>, and <see cref="T:System.Threading.Timer"/>.
            </summary>
        </member>
        <member name="M:System.TimeProvider.SystemTimeProvider.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Threading.ITimer">
            <summary>Represents a timer that can have its due time and period changed.</summary>
            <remarks>
            Implementations of <see cref="M:System.Threading.ITimer.Change(System.TimeSpan,System.TimeSpan)"/>, <see cref="M:System.IDisposable.Dispose"/>, and <see cref="M:System.IAsyncDisposable.DisposeAsync"/>
            must all be thread-safe such that the timer instance may be accessed concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Threading.ITimer.Change(System.TimeSpan,System.TimeSpan)">
            <summary>Changes the start time and the interval between method invocations for a timer, using <see cref="T:System.TimeSpan"/> values to measure time intervals.</summary>
            <param name="dueTime">
            A <see cref="T:System.TimeSpan"/> representing the amount of time to delay before invoking the callback method specified when the <see cref="T:System.Threading.ITimer"/> was constructed.
            Specify <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> to prevent the timer from restarting. Specify <see cref="F:System.TimeSpan.Zero"/> to restart the timer immediately.
            </param>
            <param name="period">
            The time interval between invocations of the callback method specified when the Timer was constructed.
            Specify <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> to disable periodic signaling.
            </param>
            <returns><see langword="true"/> if the timer was successfully updated; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="dueTime"/> or <paramref name="period"/> parameter, in milliseconds, is less than -1 or greater than 4294967294.</exception>
            <remarks>
            It is the responsibility of the implementer of the ITimer interface to ensure thread safety.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.TimeProviderTaskExtensions">
            <summary>
            Provide extensions methods for <see cref="T:System.Threading.Tasks.Task"/> operations with <see cref="T:System.TimeProvider"/>.
            </summary>
            <remarks>
            The Microsoft.Bcl.TimeProvider library interfaces are intended solely for use in building against pre-.NET 8 surface area.
            If your code is being built against .NET 8 or higher, then this library should not be utilized.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TimeProviderTaskExtensions.Delay(System.TimeProvider,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>Creates a task that completes after a specified time interval.</summary>
            <param name="timeProvider">The <see cref="T:System.TimeProvider"/> with which to interpret <paramref name="delay"/>.</param>
            <param name="delay">The <see cref="T:System.TimeSpan"/> to wait before completing the returned task, or <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
            <returns>A task that represents the time delay.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="timeProvider"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay"/> represents a negative time interval other than <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TimeProviderTaskExtensions.WaitAsync(System.Threading.Tasks.Task,System.TimeSpan,System.TimeProvider,System.Threading.CancellationToken)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, when the specified timeout expires, or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.
            </summary>
            <param name="task">The task for which to wait on until completion.</param>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <param name="timeProvider">The <see cref="T:System.TimeProvider"/> with which to interpret <paramref name="timeout"/>.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="task"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="timeProvider"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> represents a negative time interval other than <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TimeProviderTaskExtensions.WaitAsync``1(System.Threading.Tasks.Task{``0},System.TimeSpan,System.TimeProvider,System.Threading.CancellationToken)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when this <see cref="T:System.Threading.Tasks.Task"/> completes, when the specified timeout expires, or when the specified <see cref="T:System.Threading.CancellationToken"/> has cancellation requested.
            </summary>
            <param name="task">The task for which to wait on until completion.</param>
            <param name="timeout">The timeout after which the <see cref="T:System.Threading.Tasks.Task"/> should be faulted with a <see cref="T:System.TimeoutException"/> if it hasn't otherwise completed.</param>
            <param name="timeProvider">The <see cref="T:System.TimeProvider"/> with which to interpret <paramref name="timeout"/>.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to monitor for a cancellation request.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous wait.  It may or may not be the same instance as the current instance.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="task"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="timeProvider"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> represents a negative time interval other than <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/>.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TimeProviderTaskExtensions.CreateCancellationTokenSource(System.TimeProvider,System.TimeSpan)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.CancellationTokenSource"/> class that will be canceled after the specified <see cref="T:System.TimeSpan"/>. </summary>
            <param name="timeProvider">The <see cref="T:System.TimeProvider"/> with which to interpret the <paramref name="delay"/>. </param>
            <param name="delay">The time interval to wait before canceling this <see cref="T:System.Threading.CancellationTokenSource"/>. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="delay"/> is negative and not equal to <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" /> or greater than maximum allowed timer duration.</exception>
            <returns><see cref="T:System.Threading.CancellationTokenSource"/> that will be canceled after the specified <paramref name="delay"/>.</returns>
            <remarks>
            <para>
            The countdown for the delay starts during the call to the constructor. When the delay expires,
            the constructed <see cref="T:System.Threading.CancellationTokenSource"/> is canceled if it has
            not been canceled already.
            </para>
            <para>
            If running on .NET versions earlier than .NET 8.0, there is a constraint when invoking <see cref="M:System.Threading.CancellationTokenSource.CancelAfter(System.TimeSpan)"/> on the resultant object.
            This action will not terminate the initial timer indicated by <paramref name="delay"/>. However, this restriction does not apply on .NET 8.0 and later versions.
            </para>
            </remarks>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Generic_MustBeNonNegativeNonZero">
            <summary>'{0}' must be a non-negative and non-zero value.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Generic_MustBeGreaterOrEqual">
            <summary>'{0}' must be greater than or equal to '{1}'.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Generic_MustBeLessOrEqual">
            <summary>'{0}' must be less than or equal to '{1}'.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TimeProviderNullLocalTimeZone">
            <summary>The operation cannot be performed when TimeProvider.LocalTimeZone is null.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TimeProviderInvalidTimestampFrequency">
            <summary>The operation cannot be performed when TimeProvider.TimestampFrequency is zero or negative.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.LibraryImportAttribute">
            <summary>
            Attribute used to indicate a source generator should create a function for marshalling
            arguments instead of relying on the runtime to generate an equivalent marshalling function at run-time.
            </summary>
            <remarks>
            This attribute is meaningless if the source generator associated with it is not enabled.
            The current built-in source generator only supports C# and only supplies an implementation when
            applied to static, partial, non-generic methods.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.LibraryImportAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.LibraryImportAttribute"/>.
            </summary>
            <param name="libraryName">Name of the library containing the import.</param>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.LibraryName">
            <summary>
            Gets the name of the library containing the import.
            </summary>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.EntryPoint">
            <summary>
            Gets or sets the name of the entry point to be called.
            </summary>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshalling">
            <summary>
            Gets or sets how to marshal string arguments to the method.
            </summary>
            <remarks>
            If this field is set to a value other than <see cref="F:System.Runtime.InteropServices.StringMarshalling.Custom" />,
            <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType" /> must not be specified.
            </remarks>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> used to control how string arguments to the method are marshalled.
            </summary>
            <remarks>
            If this field is specified, <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshalling" /> must not be specified
            or must be set to <see cref="F:System.Runtime.InteropServices.StringMarshalling.Custom" />.
            </remarks>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.SetLastError">
            <summary>
            Gets or sets whether the callee sets an error (SetLastError on Windows or errno
            on other platforms) before returning from the attributed method.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.StringMarshalling">
            <summary>
            Specifies how strings should be marshalled for generated p/invokes
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Custom">
            <summary>
            Indicates the user is suppling a specific marshaller in <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Utf8">
            <summary>
            Use the platform-provided UTF-8 marshaller.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Utf16">
            <summary>
            Use the platform-provided UTF-16 marshaller.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>



================================================
FILE: src/R3.Unity/Assets/Packages/Microsoft.Bcl.TimeProvider.8.0.0/lib/netstandard2.0/Microsoft.Bcl.TimeProvider.xml.meta
================================================
fileFormatVersion: 2
guid: 89b5227602d5de44da22ac561da10e43
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive.meta
================================================
fileFormatVersion: 2
guid: 78d1d00edac7dd44cb606c2a453f1de0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: bb21060fd24d1fe4481d94ded01a888c
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: 565fa6c5bfcdd4d478c4e0c346e4961f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: 19945c05bd77b2441aaffafc321480f3
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/System.Runtime.CompilerServices.Unsafe.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd">
  <metadata>
    <id>System.Runtime.CompilerServices.Unsafe</id>
    <version>6.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <projectUrl>https://dot.net/</projectUrl>
    <description>Provides the System.Runtime.CompilerServices.Unsafe class, which provides generic, low-level functionality for manipulating pointers.

Commonly Used Types:
System.Runtime.CompilerServices.Unsafe</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="4822e3c3aa77eb82b2fb33c9321f923cf11ddde6" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.1" />
      <group targetFramework=".NETCoreApp3.1" />
      <group targetFramework="net6.0" />
      <group targetFramework=".NETStandard2.0" />
    </dependencies>
    <frameworkAssemblies>
      <frameworkAssembly assemblyName="mscorlib" targetFramework=".NETFramework4.6.1" />
    </frameworkAssemblies>
  </metadata>
</package>


================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/System.Runtime.CompilerServices.Unsafe.nuspec.meta
================================================
fileFormatVersion: 2
guid: 22e5978bdccca604b96264d2e484252b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/THIRD-PARTY-NOTICES.TXT
================================================
.NET Runtime uses third-party libraries or other resources that may be
distributed under licenses different than the .NET Runtime software.

In the event that we accidentally failed to list a required notice, please
bring it to our attention. Post an issue or email us:

           dotnet@microsoft.com

The attached notices are provided for information only.

License notice for ASP.NET
-------------------------------

Copyright (c) .NET Foundation. All rights reserved.
Licensed under the Apache License, Version 2.0.

Available at
https://github.com/dotnet/aspnetcore/blob/main/LICENSE.txt

License notice for Slicing-by-8
-------------------------------

http://sourceforge.net/projects/slicing-by-8/

Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved


This software program is licensed subject to the BSD License,  available at
http://www.opensource.org/licenses/bsd-license.html.


License notice for Unicode data
-------------------------------

https://www.unicode.org/license.html

Copyright © 1991-2020 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

Permission is hereby granted, free of charge, to any person obtaining
a copy of the Unicode data files and any associated documentation
(the "Data Files") or Unicode software and any associated documentation
(the "Software") to deal in the Data Files or Software
without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, and/or sell copies of
the Data Files or Software, and to permit persons to whom the Data Files
or Software are furnished to do so, provided that either
(a) this copyright and permission notice appear with all copies
of the Data Files or Software, or
(b) this copyright and permission notice appear in associated
Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in these Data Files or Software without prior
written authorization of the copyright holder.

License notice for Zlib
-----------------------

https://github.com/madler/zlib
http://zlib.net/zlib_license.html

/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/

License notice for Mono
-------------------------------

http://www.mono-project.com/docs/about-mono/

Copyright (c) .NET Foundation Contributors

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software  and associated documentation files (the Software), to deal
in the Software without restriction,  including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense,  and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so,  subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for International Organization for Standardization
-----------------------------------------------------------------

Portions (C) International Organization for Standardization 1986:
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

License notice for Intel
------------------------

"Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Xamarin and Novell
-------------------------------------

Copyright (c) 2015 Xamarin, Inc (http://www.xamarin.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Copyright (c) 2011 Novell, Inc (http://www.novell.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Third party notice for W3C
--------------------------

"W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE
Status: This license takes effect 13 May, 2015.
This work is being provided by the copyright holders under the following license.
License
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.
Permission to copy, modify, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:
The full text of this NOTICE in a location viewable to users of the redistributed or derivative work.
Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the W3C Software and Document Short Notice should be included.
Notice of any changes or modifications, through a copyright statement on the new code or document such as "This software or document includes material copied from or derived from [title and URI of the W3C document]. Copyright © [YEAR] W3C® (MIT, ERCIM, Keio, Beihang)."
Disclaimers
THIS WORK IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.
The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders."

License notice for Bit Twiddling Hacks
--------------------------------------

Bit Twiddling Hacks

By Sean Eron Anderson
seander@cs.stanford.edu

Individually, the code snippets here are in the public domain (unless otherwise
noted) — feel free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and descriptions are
distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY and
without even the implied warranty of merchantability or fitness for a particular
purpose.

License notice for Brotli
--------------------------------------

Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

compress_fragment.c:
Copyright (c) 2011, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

decode_fuzzer.c:
Copyright (c) 2015 The Chromium Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

License notice for Json.NET
-------------------------------

https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md

The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized base64 encoding / decoding
--------------------------------------------------------

Copyright (c) 2005-2007, Nick Galbreath
Copyright (c) 2013-2017, Alfred Klomp
Copyright (c) 2015-2017, Wojciech Mula
Copyright (c) 2016-2017, Matthieu Darbois
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for RFC 3492
---------------------------

The punycode implementation is based on the sample code in RFC 3492

Copyright (C) The Internet Society (2003).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

License notice for Algorithm from Internet Draft document "UUIDs and GUIDs"
---------------------------------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, or Digital Equipment Corporation be used in advertising
or publicity pertaining to distribution of the software without
specific, written prior permission.  Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
Corporation makes any representations about the suitability of
this software for any purpose.

Copyright(C) The Internet Society 1997. All Rights Reserved.

This document and translations of it may be copied and furnished to others,
and derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published and distributed, in
whole or in part, without restriction of any kind, provided that the above
copyright notice and this paragraph are included on all such copies and
derivative works.However, this document itself may not be modified in any
way, such as by removing the copyright notice or references to the Internet
Society or other Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for copyrights
defined in the Internet Standards process must be followed, or as required
to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked
by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS IS"
basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE
DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

License notice for Algorithm from RFC 4122 -
A Universally Unique IDentifier (UUID) URN Namespace
----------------------------------------------------

Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
Digital Equipment Corporation, Maynard, Mass.
Copyright (c) 1998 Microsoft.
To anyone who acknowledges that this file is provided "AS IS"
without any express or implied warranty: permission to use, copy,
modify, and distribute this file for any purpose is hereby
granted without fee, provided that the above copyright notices and
this notice appears in all source code copies, and that none of
the names of Open Software Foundation, Inc., Hewlett-Packard
Company, Microsoft, or Digital Equipment Corporation be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission. Neither Open Software
Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
Equipment Corporation makes any representations about the
suitability of this software for any purpose."

License notice for The LLVM Compiler Infrastructure
---------------------------------------------------

Developed by:

    LLVM Team

    University of Illinois at Urbana-Champaign

    http://llvm.org

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimers.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimers in the
      documentation and/or other materials provided with the distribution.

    * Neither the names of the LLVM Team, University of Illinois at
      Urbana-Champaign, nor the names of its contributors may be used to
      endorse or promote products derived from this Software without specific
      prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
SOFTWARE.

License notice for Bob Jenkins
------------------------------

By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this
code any way you wish, private, educational, or commercial.  It's free.

License notice for Greg Parker
------------------------------

Greg Parker     gparker@cs.stanford.edu     December 2000
This code is in the public domain and may be copied or modified without
permission.

License notice for libunwind based code
----------------------------------------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for Printing Floating-Point Numbers (Dragon4)
------------------------------------------------------------

/******************************************************************************
  Copyright (c) 2014 Ryan Juckett
  http://www.ryanjuckett.com/

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
******************************************************************************/

License notice for Printing Floating-point Numbers (Grisu3)
-----------------------------------------------------------

Copyright 2012 the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xxHash
-------------------------

xxHash Library
Copyright (c) 2012-2014, Yann Collet
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Berkeley SoftFloat Release 3e
------------------------------------------------

https://github.com/ucb-bar/berkeley-softfloat-3
https://github.com/ucb-bar/berkeley-softfloat-3/blob/master/COPYING.txt

License for Berkeley SoftFloat Release 3e

John R. Hauser
2018 January 20

The following applies to the whole of SoftFloat Release 3e as well as to
each source file individually.

Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 The Regents of the
University of California.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the University nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for xoshiro RNGs
--------------------------------

Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>.

License for fastmod (https://github.com/lemire/fastmod) and ibm-fpgen (https://github.com/nigeltao/parse-number-fxx-test-data)
--------------------------------------

   Copyright 2018 Daniel Lemire

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

License notice for The C++ REST SDK
-----------------------------------

C++ REST SDK

The MIT License (MIT)

Copyright (c) Microsoft Corporation

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for MessagePack-CSharp
-------------------------------------

MessagePack for C#

MIT License

Copyright (c) 2017 Yoshifumi Kawai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for lz4net
-------------------------------------

lz4net

Copyright (c) 2013-2017, Milosz Krajewski

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

License notice for Nerdbank.Streams
-----------------------------------

The MIT License (MIT)

Copyright (c) Andrew Arnott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for RapidJSON
----------------------------

Tencent is pleased to support the open source community by making RapidJSON available.

Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved.

Licensed under the MIT License (the "License"); you may not use this file except
in compliance with the License. You may obtain a copy of the License at

http://opensource.org/licenses/MIT

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.

License notice for DirectX Math Library
---------------------------------------

https://github.com/microsoft/DirectXMath/blob/master/LICENSE

                               The MIT License (MIT)

Copyright (c) 2011-2020 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for ldap4net
---------------------------

The MIT License (MIT)

Copyright (c) 2018 Alexander Chermyanin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

License notice for vectorized sorting code
------------------------------------------

MIT License

Copyright (c) 2020 Dan Shechter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

License notice for musl
-----------------------

musl as a whole is licensed under the following standard MIT license:

Copyright © 2005-2020 Rich Felker, et al.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


License notice for "Faster Unsigned Division by Constants"
------------------------------

Reference implementations of computing and using the "magic number" approach to dividing
by constants, including codegen instructions. The unsigned division incorporates the
"round down" optimization per ridiculous_fish.

This is free and unencumbered software. Any copyright is dedicated to the Public Domain.


License notice for mimalloc
-----------------------------------

MIT License

Copyright (c) 2019 Microsoft Corporation, Daan Leijen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: 882622fae9c03c54a945e737c7063741
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: 3a8d41e470308ab4d97dc610c86e3f65
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0.meta
================================================
fileFormatVersion: 2
guid: a82325660c308eb479fdbeaad63ccd49
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1.meta
================================================
fileFormatVersion: 2
guid: 5098a7da713ba324299dc34e13d16166
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0/System.Runtime.CompilerServices.Unsafe.targets
================================================
<Project InitialTargets="NETStandardCompatError_System_Runtime_CompilerServices_Unsafe_netcoreapp3_1">
  <Target Name="NETStandardCompatError_System_Runtime_CompilerServices_Unsafe_netcoreapp3_1"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Error Text="System.Runtime.CompilerServices.Unsafe doesn't support $(TargetFramework). Consider updating your TargetFramework to netcoreapp3.1 or later." />
  </Target>
</Project>



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp2.0/System.Runtime.CompilerServices.Unsafe.targets.meta
================================================
fileFormatVersion: 2
guid: a7f6036f40fd37a4baac2adf55671eac
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1/_._
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/buildTransitive/netcoreapp3.1/_._.meta
================================================
fileFormatVersion: 2
guid: 0c5405265d897b9478c6b52e576ed4f3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0.meta
================================================
fileFormatVersion: 2
guid: 8bd11addbf718d4458c3827d56faba39
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll.meta
================================================
fileFormatVersion: 2
guid: 99fab1bd05a93444d95c6e6eb6a505f0
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.xml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Runtime.CompilerServices.Unsafe</name>
  </assembly>
  <members>
    <member name="T:System.Runtime.CompilerServices.Unsafe">
      <summary>Contains generic, low-level functionality for manipulating pointers.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.Int32)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.IntPtr)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.UIntPtr)">
      <summary>Adds an element offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Add``1(System.Void*,System.Int32)">
      <summary>Adds an element offset to the given void pointer.</summary>
      <param name="source">The void pointer to add the offset to.</param>
      <param name="elementOffset">The offset to add.</param>
      <typeparam name="T">The type of void pointer.</typeparam>
      <returns>A new void pointer that reflects the addition of offset to the specified pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.IntPtr)">
      <summary>Adds a byte offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="byteOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of byte offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.UIntPtr)">
      <summary>Adds a byte offset to the given reference.</summary>
      <param name="source">The reference to add the offset to.</param>
      <param name="byteOffset">The offset to add.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the addition of byte offset to pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AreSame``1(``0@,``0@)">
      <summary>Determines whether the specified references point to the same location.</summary>
      <param name="left">The first reference to compare.</param>
      <param name="right">The second reference to compare.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> point to the same location; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.As``1(System.Object)">
      <summary>Casts the given object to the specified type.</summary>
      <param name="o">The object to cast.</param>
      <typeparam name="T">The type which the object will be cast to.</typeparam>
      <returns>The original object, casted to the given type.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)">
      <summary>Reinterprets the given reference as a reference to a value of type <typeparamref name="TTo" />.</summary>
      <param name="source">The reference to reinterpret.</param>
      <typeparam name="TFrom">The type of reference to reinterpret.</typeparam>
      <typeparam name="TTo">The desired type of the reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="TTo" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsPointer``1(``0@)">
      <summary>Returns a pointer to the given by-ref parameter.</summary>
      <param name="value">The object whose pointer is obtained.</param>
      <typeparam name="T">The type of object.</typeparam>
      <returns>A pointer to the given value.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(``0@)">
      <summary>Reinterprets the given read-only reference as a reference.</summary>
      <param name="source">The read-only reference to reinterpret.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(System.Void*)">
      <summary>Reinterprets the given location as a reference to a value of type <typeparamref name="T" />.</summary>
      <param name="source">The location of the value to reference.</param>
      <typeparam name="T">The type of the interpreted location.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ByteOffset``1(``0@,``0@)">
      <summary>Determines the byte offset from origin to target from the given references.</summary>
      <param name="origin">The reference to origin.</param>
      <param name="target">The reference to target.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>Byte offset from origin to target i.e. <paramref name="target" /> - <paramref name="origin" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Copy``1(``0@,System.Void*)">
      <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to copy to.</param>
      <param name="source">A pointer to the value to copy.</param>
      <typeparam name="T">The type of value to copy.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Copy``1(System.Void*,``0@)">
      <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to copy to.</param>
      <param name="source">A reference to the value to copy.</param>
      <typeparam name="T">The type of value to copy.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Byte@,System.Byte@,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Void*,System.Void*,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Byte@,System.Byte@,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Void*,System.Void*,System.UInt32)">
      <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The destination address to copy to.</param>
      <param name="source">The source address to copy from.</param>
      <param name="byteCount">The number of bytes to copy.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Byte@,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Void*,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Byte@,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Void*,System.Byte,System.UInt32)">
      <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
      <param name="startAddress">The address of the start of the memory block to initialize.</param>
      <param name="value">The value to initialize the block to.</param>
      <param name="byteCount">The number of bytes to initialize.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsAddressGreaterThan``1(``0@,``0@)">
      <summary>Returns a value that indicates whether a specified reference is greater than another specified reference.</summary>
      <param name="left">The first value to compare.</param>
      <param name="right">The second value to compare.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsAddressLessThan``1(``0@,``0@)">
      <summary>Returns a value that indicates whether a specified reference is less than another specified reference.</summary>
      <param name="left">The first value to compare.</param>
      <param name="right">The second value to compare.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)">
      <summary>Determines if a given reference to a value of type <typeparamref name="T" /> is a null reference.</summary>
      <param name="source">The reference to check.</param>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>
        <see langword="true" /> if <paramref name="source" /> is a null reference; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.NullRef``1">
      <summary>Returns a reference to a value of type <typeparamref name="T" /> that is a null reference.</summary>
      <typeparam name="T">The type of the reference.</typeparam>
      <returns>A reference to a value of type <typeparamref name="T" /> that is a null reference.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Read``1(System.Void*)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Byte@)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Void*)">
      <summary>Reads a value of type <typeparamref name="T" /> from the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="source">The location to read from.</param>
      <typeparam name="T">The type to read.</typeparam>
      <returns>An object of type <typeparamref name="T" /> read from the given location.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1">
      <summary>Returns the size of an object of the given type parameter.</summary>
      <typeparam name="T">The type of object whose size is retrieved.</typeparam>
      <returns>The size of an object of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SkipInit``1(``0@)">
      <summary>Bypasses definite assignment rules for a given value.</summary>
      <param name="value">The uninitialized object.</param>
      <typeparam name="T">The type of the uninitialized object.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.Int32)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.IntPtr)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.UIntPtr)">
      <summary>Subtracts an element offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subraction of offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(System.Void*,System.Int32)">
      <summary>Subtracts an element offset from the given void pointer.</summary>
      <param name="source">The void pointer to subtract the offset from.</param>
      <param name="elementOffset">The offset to subtract.</param>
      <typeparam name="T">The type of the void pointer.</typeparam>
      <returns>A new void pointer that reflects the subtraction of offset from the specified pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.IntPtr)">
      <summary>Subtracts a byte offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="byteOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subtraction of byte offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.UIntPtr)">
      <summary>Subtracts a byte offset from the given reference.</summary>
      <param name="source">The reference to subtract the offset from.</param>
      <param name="byteOffset">The offset to subtract.</param>
      <typeparam name="T">The type of reference.</typeparam>
      <returns>A new reference that reflects the subraction of byte offset from pointer.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Unbox``1(System.Object)">
      <summary>Returns a <see langword="mutable ref" /> to a boxed value.</summary>
      <param name="box">The value to unbox.</param>
      <typeparam name="T">The type to be unboxed.</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="box" /> is <see langword="null" />, and <typeparamref name="T" /> is a non-nullable value type.</exception>
      <exception cref="T:System.InvalidCastException">
        <paramref name="box" /> is not a boxed value type.
         
-or-

<paramref name="box" /> is not a boxed <typeparamref name="T" />.</exception>
      <exception cref="T:System.TypeLoadException">
        <typeparamref name="T" /> cannot be found.</exception>
      <returns>A <see langword="mutable ref" /> to the boxed value <paramref name="box" />.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.Write``1(System.Void*,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Byte@,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Void*,``0)">
      <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the addresses.</summary>
      <param name="destination">The location to write to.</param>
      <param name="value">The value to write.</param>
      <typeparam name="T">The type of value to write.</typeparam>
    </member>
  </members>
</doc>


================================================
FILE: src/R3.Unity/Assets/Packages/System.Runtime.CompilerServices.Unsafe.6.0.0/lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.xml.meta
================================================
fileFormatVersion: 2
guid: 64dc638c399f271459ce6349977025af
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive.meta
================================================
fileFormatVersion: 2
guid: 63d50fd1713fb8a42874e817a0d55298
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/Icon.png.meta
================================================
fileFormatVersion: 2
guid: b01048c97c500ad48a154601ad883271
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 12
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
    flipGreenChannel: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  ignoreMipmapLimit: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 1
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 8
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  swizzle: 50462976
  cookieLightType: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Server
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    ignorePlatformSupport: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 5e97eb03825dee720800000000000000
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
    nameFileIdTable: {}
  mipmapLimitGroupName: 
  pSDRemoveMatte: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/lib.meta
================================================
fileFormatVersion: 2
guid: f31c35baa1e33444c9f61d8be86f0778
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/LICENSE.TXT
================================================
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: df21a23996313dd4c9f7070b3f503164
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/PACKAGE.md
================================================
## About

<!-- A description of the package and where one can find more documentation -->

The `System.Threading.Channels` library provides types for passing data asynchronously between producers and consumers.

## Key Features

<!-- The key features of this package -->

* Abstractions representing channels for one or more producers to publish data to one or more consumers
* APIs focused on asynchronous production and consumption of data
* Factory methods for producing multiple kinds of channels

## How to Use

<!-- A compelling example on how to use this package with code, as well as any specific guidelines for when to use the package -->

```C#
using System;
using System.Threading.Channels;
using System.Threading.Tasks;

Channel<int> channel = Channel.CreateUnbounded<int>();

Task producer = Task.Run(async () =>
{
    int i = 0;
    while (true)
    {
        channel.Writer.TryWrite(i++);
        await Task.Delay(TimeSpan.FromSeconds(1));
    }
});

Task consumer = Task.Run(async () =>
{
    await foreach (int value in channel.Reader.ReadAllAsync())
    {
        Console.WriteLine(value);
    }
});

await Task.WhenAll(producer, consumer);
```

## Main Types

<!-- The main types provided in this library -->

The main types provided by this library are:

* `System.Threading.Channel<T>`
* `System.Threading.Channel`

## Additional Documentation

<!-- Links to further documentation. Remove conceptual documentation if not available for the library. -->

* [Overview](https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/)
* [API documentation](https://learn.microsoft.com/dotnet/api/system.threading.channels)

## Related Packages

<!-- The related packages associated with this package -->

https://www.nuget.org/packages/System.Threading.Tasks.Dataflow/

## Feedback & Contributing

<!-- How to provide feedback on this package and contribute to it -->

System.Threading.Channels is released as open source under the [MIT license](https://licenses.nuget.org/MIT). Bug reports and contributions are welcome at [the GitHub repository](https://github.com/dotnet/runtime).


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/PACKAGE.md.meta
================================================
fileFormatVersion: 2
guid: 61bc823819351c743a53e05d0208d91c
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/System.Threading.Channels.nuspec
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata>
    <id>System.Threading.Channels</id>
    <version>8.0.0</version>
    <authors>Microsoft</authors>
    <license type="expression">MIT</license>
    <licenseUrl>https://licenses.nuget.org/MIT</licenseUrl>
    <icon>Icon.png</icon>
    <readme>PACKAGE.md</readme>
    <projectUrl>https://dot.net/</projectUrl>
    <description>Provides types for passing data between producers and consumers.

Commonly Used Types:
System.Threading.Channel
System.Threading.Channel&lt;T&gt;</description>
    <releaseNotes>https://go.microsoft.com/fwlink/?LinkID=799421</releaseNotes>
    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
    <serviceable>true</serviceable>
    <repository type="git" url="https://github.com/dotnet/runtime" commit="5535e31a712343a63f5d7d796cd874e563e5ac14" />
    <dependencies>
      <group targetFramework=".NETFramework4.6.2">
        <dependency id="System.Threading.Tasks.Extensions" version="4.5.4" exclude="Build,Analyzers" />
      </group>
      <group targetFramework="net6.0" />
      <group targetFramework="net7.0" />
      <group targetFramework="net8.0" />
      <group targetFramework=".NETStandard2.0">
        <dependency id="System.Threading.Tasks.Extensions" version="4.5.4" exclude="Build,Analyzers" />
      </group>
      <group targetFramework=".NETStandard2.1" />
    </dependencies>
  </metadata>
</package>


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/System.Threading.Channels.nuspec.meta
================================================
fileFormatVersion: 2
guid: 4629e671e917f7d4f99c6e36a42c9268
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/THIRD-PARTY-NOTICES.TXT.meta
================================================
fileFormatVersion: 2
guid: 72ef5d2490d48ec46871deb0b74b7813
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/useSharedDesignerContext.txt
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/useSharedDesignerContext.txt.meta
================================================
fileFormatVersion: 2
guid: 79af3d705668bf649952c24b89659dd7
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/.signature.p7s
================================================
[Binary file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net461.meta
================================================
fileFormatVersion: 2
guid: 649d4110f1705194cbc01de03ebf1e64
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net462.meta
================================================
fileFormatVersion: 2
guid: 9c7d9d8a90cddb64295bf128eb9cc17d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net6.0.meta
================================================
fileFormatVersion: 2
guid: 2e3d28456546fe84da0db6742c4cfafb
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/netcoreapp2.0.meta
================================================
fileFormatVersion: 2
guid: 98af5666413382a48babab9fc497c137
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net461/System.Threading.Channels.targets
================================================
<Project InitialTargets="NETStandardCompatError_System_Threading_Channels_net462">
  <Target Name="NETStandardCompatError_System_Threading_Channels_net462"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Warning Text="System.Threading.Channels 8.0.0 doesn't support $(TargetFramework) and has not been tested with it. Consider upgrading your TargetFramework to net462 or later. You may also set &lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt; in the project file to ignore this warning and attempt to run in this unsupported configuration at your own risk." />
  </Target>
</Project>



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net461/System.Threading.Channels.targets.meta
================================================
fileFormatVersion: 2
guid: 7b62868cdbdef6e46aa3b1eb8f78d4dc
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net462/_._
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net462/_._.meta
================================================
fileFormatVersion: 2
guid: e6a6129dd0d80554aaee1665729e65a7
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net6.0/_._
================================================
[Empty file]


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/net6.0/_._.meta
================================================
fileFormatVersion: 2
guid: fa9bf1219388dc94c9663dc5732a403c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/netcoreapp2.0/System.Threading.Channels.targets
================================================
<Project InitialTargets="NETStandardCompatError_System_Threading_Channels_net6_0">
  <Target Name="NETStandardCompatError_System_Threading_Channels_net6_0"
          Condition="'$(SuppressTfmSupportBuildWarnings)' == ''">
    <Warning Text="System.Threading.Channels 8.0.0 doesn't support $(TargetFramework) and has not been tested with it. Consider upgrading your TargetFramework to net6.0 or later. You may also set &lt;SuppressTfmSupportBuildWarnings&gt;true&lt;/SuppressTfmSupportBuildWarnings&gt; in the project file to ignore this warning and attempt to run in this unsupported configuration at your own risk." />
  </Target>
</Project>



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/buildTransitive/netcoreapp2.0/System.Threading.Channels.targets.meta
================================================
fileFormatVersion: 2
guid: a2a6cb20fcd93574ea9bd50a32bbad01
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/lib/netstandard2.1.meta
================================================
fileFormatVersion: 2
guid: bc8731f0410c3b1458d9b44a697880d2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/lib/netstandard2.1/System.Threading.Channels.dll.meta
================================================
fileFormatVersion: 2
guid: 178d59b1c5291b64d9a206e568e79b9b
labels:
- NuGetForUnity
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/lib/netstandard2.1/System.Threading.Channels.xml
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading.Channels</name>
  </assembly>
  <members>
    <member name="T:System.Threading.Channels.BoundedChannelFullMode">
      <summary>Specifies the behavior to use when writing to a bounded channel that is already full.</summary>
    </member>
    <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropNewest">
      <summary>Removes and ignores the newest item in the channel in order to make room for the item being written.</summary>
    </member>
    <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropOldest">
      <summary>Removes and ignores the oldest item in the channel in order to make room for the item being written.</summary>
    </member>
    <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropWrite">
      <summary>Drops the item being written.</summary>
    </member>
    <member name="F:System.Threading.Channels.BoundedChannelFullMode.Wait">
      <summary>Waits for space to be available in order to complete the write operation.</summary>
    </member>
    <member name="T:System.Threading.Channels.BoundedChannelOptions">
      <summary>Provides options that control the behavior of bounded <see cref="T:System.Threading.Channels.Channel`1" /> instances.</summary>
    </member>
    <member name="M:System.Threading.Channels.BoundedChannelOptions.#ctor(System.Int32)">
      <summary>Initializes the options.</summary>
      <param name="capacity">The maximum number of items the bounded channel may store.</param>
    </member>
    <member name="P:System.Threading.Channels.BoundedChannelOptions.Capacity">
      <summary>Gets or sets the maximum number of items the bounded channel may store.</summary>
    </member>
    <member name="P:System.Threading.Channels.BoundedChannelOptions.FullMode">
      <summary>Gets or sets the behavior incurred by write operations when the channel is full.</summary>
    </member>
    <member name="T:System.Threading.Channels.Channel">
      <summary>Provides static methods for creating channels.</summary>
    </member>
    <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Int32)">
      <summary>Creates a channel with the specified maximum capacity.</summary>
      <param name="capacity">The maximum number of items the channel may store.</param>
      <typeparam name="T">Specifies the type of data in the channel.</typeparam>
      <returns>The created channel.</returns>
    </member>
    <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Threading.Channels.BoundedChannelOptions)">
      <summary>Creates a channel with the specified maximum capacity.</summary>
      <param name="options">Options that guide the behavior of the channel.</param>
      <typeparam name="T">Specifies the type of data in the channel.</typeparam>
      <returns>The created channel.</returns>
    </member>
    <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Threading.Channels.BoundedChannelOptions,System.Action{``0})">
      <summary>Creates a channel subject to the provided options.</summary>
      <param name="options">Options that guide the behavior of the channel.</param>
      <param name="itemDropped">Delegate that will be called when item is being dropped from channel. See <see cref="T:System.Threading.Channels.BoundedChannelFullMode" />.</param>
      <typeparam name="T">Specifies the type of data in the channel.</typeparam>
      <returns>The created channel.</returns>
    </member>
    <member name="M:System.Threading.Channels.Channel.CreateUnbounded``1">
      <summary>Creates an unbounded channel usable by any number of readers and writers concurrently.</summary>
      <typeparam name="T">The type of data in the channel.</typeparam>
      <returns>The created channel.</returns>
    </member>
    <member name="M:System.Threading.Channels.Channel.CreateUnbounded``1(System.Threading.Channels.UnboundedChannelOptions)">
      <summary>Creates an unbounded channel subject to the provided options.</summary>
      <param name="options">Options that guide the behavior of the channel.</param>
      <typeparam name="T">Specifies the type of data in the channel.</typeparam>
      <returns>The created channel.</returns>
    </member>
    <member name="T:System.Threading.Channels.Channel`1">
      <summary>Provides a base class for channels that support reading and writing elements of type <typeparamref name="T" />.</summary>
      <typeparam name="T">Specifies the type of data readable and writable in the channel.</typeparam>
    </member>
    <member name="M:System.Threading.Channels.Channel`1.#ctor">
      <summary>Initializes an instance of the <see cref="T:System.Threading.Channels.Channel`1" /> class.</summary>
    </member>
    <member name="T:System.Threading.Channels.Channel`2">
      <summary>Provides a base class for channels that support reading elements of type <typeparamref name="TRead" /> and writing elements of type <typeparamref name="TWrite" />.</summary>
      <typeparam name="TWrite">Specifies the type of data that may be written to the channel.</typeparam>
      <typeparam name="TRead">Specifies the type of data that may be read from the channel.</typeparam>
    </member>
    <member name="M:System.Threading.Channels.Channel`2.#ctor">
      <summary>Initializes an instance of the <see cref="T:System.Threading.Channels.Channel`2" /> class.</summary>
    </member>
    <member name="M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})~System.Threading.Channels.ChannelReader{`1}">
      <summary>Implicit cast from a <see cref="T:System.Threading.Channels.Channel`2" /> to its readable half.</summary>
      <param name="channel">The <see cref="T:System.Threading.Channels.Channel`2" /> being cast.</param>
      <returns>The readable half.</returns>
    </member>
    <member name="M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})~System.Threading.Channels.ChannelWriter{`0}">
      <summary>Implicit cast from a <see cref="T:System.Threading.Channels.Channel`2" /> to its writable half.</summary>
      <param name="channel">The <see cref="T:System.Threading.Channels.Channel`2" /> being cast.</param>
      <returns>The writable half.</returns>
    </member>
    <member name="P:System.Threading.Channels.Channel`2.Reader">
      <summary>Gets the readable half of this channel.</summary>
    </member>
    <member name="P:System.Threading.Channels.Channel`2.Writer">
      <summary>Gets the writable half of this channel.</summary>
    </member>
    <member name="T:System.Threading.Channels.ChannelClosedException">
      <summary>Exception thrown when a channel is used after it's been closed.</summary>
    </member>
    <member name="M:System.Threading.Channels.ChannelClosedException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException" /> class.</summary>
    </member>
    <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException" /> class.</summary>
      <param name="innerException">The exception that is the cause of this exception.</param>
    </member>
    <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException" /> class with serialized data.</summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException" /> class.</summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException" /> class.</summary>
      <param name="message">The message that describes the error.</param>
      <param name="innerException">The exception that is the cause of this exception.</param>
    </member>
    <member name="T:System.Threading.Channels.ChannelOptions">
      <summary>Provides options that control the behavior of channel instances.</summary>
    </member>
    <member name="M:System.Threading.Channels.ChannelOptions.#ctor">
      <summary>Initializes an instance of the <see cref="T:System.Threading.Channels.ChannelOptions" /> class.</summary>
    </member>
    <member name="P:System.Threading.Channels.ChannelOptions.AllowSynchronousContinuations">
      <summary>
        <see langword="true" /> if operations performed on a channel may synchronously invoke continuations subscribed to
            notifications of pending async operations; <see langword="false" /> if all continuations should be invoked asynchronously.</summary>
    </member>
    <member name="P:System.Threading.Channels.ChannelOptions.SingleReader">
      <summary>
        <see langword="true" /> readers from the channel guarantee that there will only ever be at most one read operation at a time;
            <see langword="false" /> if no such constraint is guaranteed.</summary>
    </member>
    <member name="P:System.Threading.Channels.ChannelOptions.SingleWriter">
      <summary>
        <see langword="true" /> if writers to the channel guarantee that there will only ever be at most one write operation
            at a time; <see langword="false" /> if no such constraint is guaranteed.</summary>
    </member>
    <member name="T:System.Threading.Channels.ChannelReader`1">
      <summary>Provides a base class for reading from a channel.</summary>
      <typeparam name="T">Specifies the type of data that may be read from the channel.</typeparam>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.#ctor">
      <summary>Initializes an instance of the <see cref="T:System.Threading.Channels.ChannelReader`1" /> class.</summary>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.ReadAllAsync(System.Threading.CancellationToken)">
      <summary>Creates an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> that enables reading all of the data from the channel.</summary>
      <param name="cancellationToken">The cancellation token to use to cancel the enumeration. If data is immediately ready for reading, then that data may be yielded even after cancellation has been requested.</param>
      <returns>The created async enumerable.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.ReadAsync(System.Threading.CancellationToken)">
      <summary>Asynchronously reads an item from the channel.</summary>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> used to cancel the read operation.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1" /> that represents the asynchronous read operation.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.TryPeek(`0@)">
      <summary>Attempts to peek at an item from the channel.</summary>
      <param name="item">The peeked item, or a default value if no item could be peeked.</param>
      <returns>
        <see langword="true" /> if an item was read; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.TryRead(`0@)">
      <summary>Attempts to read an item from the channel.</summary>
      <param name="item">The read item, or a default value if no item could be read.</param>
      <returns>
        <see langword="true" /> if an item was read; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelReader`1.WaitToReadAsync(System.Threading.CancellationToken)">
      <summary>Returns a <see cref="T:System.Threading.Tasks.ValueTask`1" /> that will complete when data is available to read.</summary>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> used to cancel the wait operation.</param>
      <returns>
        <para>A <see cref="T:System.Threading.Tasks.ValueTask`1" /> that will complete with a <see langword="true" /> result when data is available to read
            or with a <see langword="false" /> result when no further data will ever be available to be read due to the channel completing successfully.</para>
        <para>If the channel completes with an exception, the task will also complete with an exception.</para>
      </returns>
    </member>
    <member name="P:System.Threading.Channels.ChannelReader`1.CanCount">
      <summary>Gets a value that indicates whether <see cref="P:System.Threading.Channels.ChannelReader`1.Count" /> is available for use on this <see cref="T:System.Threading.Channels.ChannelReader`1" /> instance.</summary>
    </member>
    <member name="P:System.Threading.Channels.ChannelReader`1.CanPeek">
      <summary>Gets a value that indicates whether <see cref="M:System.Threading.Channels.ChannelReader`1.TryPeek(`0@)" /> is available for use on this <see cref="T:System.Threading.Channels.ChannelReader`1" /> instance.</summary>
      <returns>
        <see langword="true" /> if peeking is supported by this channel instance; <see langword="false" /> otherwise.</returns>
    </member>
    <member name="P:System.Threading.Channels.ChannelReader`1.Completion">
      <summary>Gets a <see cref="T:System.Threading.Tasks.Task" /> that completes when no more data will ever
            be available to be read from this channel.</summary>
    </member>
    <member name="P:System.Threading.Channels.ChannelReader`1.Count">
      <summary>Gets the current number of items available from this channel reader.</summary>
      <exception cref="T:System.NotSupportedException">Counting is not supported on this instance.</exception>
    </member>
    <member name="T:System.Threading.Channels.ChannelWriter`1">
      <summary>Provides a base class for writing to a channel.</summary>
      <typeparam name="T">Specifies the type of data that may be written to the channel.</typeparam>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.#ctor">
      <summary>Initializes an instance of the <see cref="T:System.Threading.Channels.ChannelWriter`1" /> class.</summary>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.Complete(System.Exception)">
      <summary>Mark the channel as being complete, meaning no more items will be written to it.</summary>
      <param name="error">Optional Exception indicating a failure that's causing the channel to complete.</param>
      <exception cref="T:System.InvalidOperationException">The channel has already been marked as complete.</exception>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.TryComplete(System.Exception)">
      <summary>Attempts to mark the channel as being completed, meaning no more data will be written to it.</summary>
      <param name="error">An <see cref="T:System.Exception" /> indicating the failure causing no more data to be written, or null for success.</param>
      <returns>
        <see langword="true" /> if this operation successfully completes the channel; otherwise, <see langword="false" /> if the channel could not be marked for completion,
            for example due to having already been marked as such, or due to not supporting completion.
          .</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.TryWrite(`0)">
      <summary>Attempts to write the specified item to the channel.</summary>
      <param name="item">The item to write.</param>
      <returns>
        <see langword="true" /> if the item was written; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.WaitToWriteAsync(System.Threading.CancellationToken)">
      <summary>Returns a <see cref="T:System.Threading.Tasks.ValueTask`1" /> that will complete when space is available to write an item.</summary>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> used to cancel the wait operation.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1" /> that will complete with a <see langword="true" /> result when space is available to write an item
            or with a <see langword="false" /> result when no further writing will be permitted.</returns>
    </member>
    <member name="M:System.Threading.Channels.ChannelWriter`1.WriteAsync(`0,System.Threading.CancellationToken)">
      <summary>Asynchronously writes an item to the channel.</summary>
      <param name="item">The value to write to the channel.</param>
      <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken" /> used to cancel the write operation.</param>
      <returns>A <see cref="T:System.Threading.Tasks.ValueTask" /> that represents the asynchronous write operation.</returns>
    </member>
    <member name="T:System.Threading.Channels.UnboundedChannelOptions">
      <summary>Provides options that control the behavior of unbounded <see cref="T:System.Threading.Channels.Channel`1" /> instances.</summary>
    </member>
    <member name="M:System.Threading.Channels.UnboundedChannelOptions.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.UnboundedChannelOptions" /> class.</summary>
    </member>
  </members>
</doc>


================================================
FILE: src/R3.Unity/Assets/Packages/System.Threading.Channels.8.0.0/lib/netstandard2.1/System.Threading.Channels.xml.meta
================================================
fileFormatVersion: 2
guid: 3a999c3e0c15371408a73b75c174eeac
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor.meta
================================================
fileFormatVersion: 2
guid: 8dfacb58d7567834fbd8a4a006915cfd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/package.json
================================================
{
    "name": "com.cysharp.r3",
    "displayName": "R3",
    "author": { "name": "Cysharp, Inc.", "url": "https://cysharp.co.jp/en/" },
    "version": "1.3.0",
    "unity": "2021.3",
    "description": "Reactive Extensions for Unity.",
    "keywords": [ "rx", "event", "Scripting" ],
    "license": "MIT",
    "category": "Scripting",
    "dependencies": {
        "com.unity.modules.imgui": "1.0.0"
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/package.json.meta
================================================
fileFormatVersion: 2
guid: ab73519690403a9428c7d05e008ca466
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime.meta
================================================
fileFormatVersion: 2
guid: df6f082a67ae96342ae0a4e0745f52bf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/EditorEnableState.cs
================================================
﻿using UnityEditor;

namespace R3.Unity.Editor
{
    public static class EditorEnableState
    {
        const string EnableAutoReloadKey = "ObservableTrackerWindow_EnableAutoReloadKey";
        const string EnableTrackingKey = "ObservableTrackerWindow_EnableTrackingKey";
        const string EnableStackTraceKey = "ObservableTrackerWindow_EnableStackTraceKey";

        public static bool EnableAutoReload
        {
            get
            {
                return EditorPrefs.GetBool(EnableAutoReloadKey, false);
            }
            set
            {
                UnityEditor.EditorPrefs.SetBool(EnableAutoReloadKey, value);
            }
        }

        public static bool EnableTracking
        {
            get
            {
                return UnityEditor.EditorPrefs.GetBool(EnableTrackingKey, false);
            }
            set
            {
                UnityEditor.EditorPrefs.SetBool(EnableTrackingKey, value);
            }
        }

        public static bool EnableStackTrace
        {
            get
            {
                return UnityEditor.EditorPrefs.GetBool(EnableStackTraceKey, false);
            }
            set
            {
                UnityEditor.EditorPrefs.SetBool(EnableStackTraceKey, value);
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/EditorEnableState.cs.meta
================================================
fileFormatVersion: 2
guid: dcb7a4c0bad64844a9826d605a62c7fd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/ObservableTrackerTreeView.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

namespace R3.Unity.Editor
{
    public class ObservableTrackerViewItem : TreeViewItem
    {
        static Regex removeHref = new Regex("<a href.+>(.+)</a>", RegexOptions.Compiled);

        public string Type { get; set; }
        public string Elapsed { get; set; }

        string location;
        public string Location
        {
            get { return location; }
            set
            {
                location = value;
                LocationFirstLine = GetFirstLine(location);
            }
        }

        public string LocationFirstLine { get; private set; }

        static string GetFirstLine(string str)
        {
            var sb = new StringBuilder();
            for (int i = 0; i < str.Length; i++)
            {
                if (str[i] == '\r' || str[i] == '\n')
                {
                    break;
                }
                sb.Append(str[i]);
            }

            return removeHref.Replace(sb.ToString(), "$1");
        }

        public ObservableTrackerViewItem(int id) : base(id)
        {

        }
    }

    public class ObservableTrackerTreeView : TreeView
    {
        const string sortedColumnIndexStateKey = "ObservableTrackerTreeView_sortedColumnIndex";

        public IReadOnlyList<TreeViewItem> CurrentBindingItems;

        public ObservableTrackerTreeView()
            : this(new TreeViewState(), new MultiColumnHeader(new MultiColumnHeaderState(new[]
            {
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Type"), width = 20},
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Elapsed"), width = 10},
                new MultiColumnHeaderState.Column() { headerContent = new GUIContent("Location")},
            })))
        {
        }

        ObservableTrackerTreeView(TreeViewState state, MultiColumnHeader header)
            : base(state, header)
        {
            rowHeight = 20;
            showAlternatingRowBackgrounds = true;
            showBorder = true;
            header.sortingChanged += Header_sortingChanged;

            header.ResizeToFit();
            Reload();

            header.sortedColumnIndex = SessionState.GetInt(sortedColumnIndexStateKey, 1);
        }

        public void ReloadAndSort()
        {
            var currentSelected = this.state.selectedIDs;
            Reload();
            Header_sortingChanged(this.multiColumnHeader);
            this.state.selectedIDs = currentSelected;
        }

        private void Header_sortingChanged(MultiColumnHeader multiColumnHeader)
        {
            SessionState.SetInt(sortedColumnIndexStateKey, multiColumnHeader.sortedColumnIndex);
            var index = multiColumnHeader.sortedColumnIndex;
            var ascending = multiColumnHeader.IsSortedAscending(multiColumnHeader.sortedColumnIndex);

            var items = rootItem.children.Cast<ObservableTrackerViewItem>();

            IOrderedEnumerable<ObservableTrackerViewItem> orderedEnumerable;
            switch (index)
            {
                case 0:
                    orderedEnumerable = ascending ? items.OrderBy(item => item.Type) : items.OrderByDescending(item => item.Type);
                    break;
                case 1:
                    orderedEnumerable = ascending ? items.OrderBy(item => double.Parse(item.Elapsed)) : items.OrderByDescending(item => double.Parse(item.Elapsed));
                    break;
                case 2:
                    orderedEnumerable = ascending ? items.OrderBy(item => item.Location) : items.OrderByDescending(item => item.Location);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(index), index, null);
            }

            CurrentBindingItems = rootItem.children = orderedEnumerable.Cast<TreeViewItem>().ToList();
            BuildRows(rootItem);
        }

        protected override TreeViewItem BuildRoot()
        {
            var root = new TreeViewItem { depth = -1 };

            var children = new List<TreeViewItem>();

            var now = DateTime.Now; // tracking state is using local Now.
            ObservableTracker.ForEachActiveTask(state =>
            {
                children.Add(new ObservableTrackerViewItem(state.TrackingId) { Type = state.FormattedType, Elapsed = (now - state.AddTime).TotalSeconds.ToString("00.00"), Location = state.StackTrace });
            });

            CurrentBindingItems = children;
            root.children = CurrentBindingItems as List<TreeViewItem>;
            return root;
        }

        protected override bool CanMultiSelect(TreeViewItem item)
        {
            return false;
        }

        protected override void RowGUI(RowGUIArgs args)
        {
            var item = args.item as ObservableTrackerViewItem;

            for (var visibleColumnIndex = 0; visibleColumnIndex < args.GetNumVisibleColumns(); visibleColumnIndex++)
            {
                var rect = args.GetCellRect(visibleColumnIndex);
                var columnIndex = args.GetColumn(visibleColumnIndex);

                var labelStyle = args.selected ? EditorStyles.whiteLabel : EditorStyles.label;
                labelStyle.alignment = TextAnchor.MiddleLeft;
                switch (columnIndex)
                {
                    case 0:
                        EditorGUI.LabelField(rect, item.Type, labelStyle);
                        break;
                    case 1:
                        EditorGUI.LabelField(rect, item.Elapsed, labelStyle);
                        break;
                    case 2:
                        EditorGUI.LabelField(rect, item.LocationFirstLine, labelStyle);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(columnIndex), columnIndex, null);
                }
            }
        }
    }

}




================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/ObservableTrackerTreeView.cs.meta
================================================
fileFormatVersion: 2
guid: eb169fd740c0ebd459cbfe2b76c8687a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/ObservableTrackerWindow.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System;
using UnityEditor.IMGUI.Controls;

namespace R3.Unity.Editor
{
    public class ObservableTrackerWindow : EditorWindow
    {
        static int interval;

        static ObservableTrackerWindow window;

        [MenuItem("Window/Observable Tracker")]
        public static void OpenWindow()
        {
            if (window != null)
            {
                window.Close();
            }

            // will called OnEnable(singleton instance will be set).
            GetWindow<ObservableTrackerWindow>("Observable Tracker").Show();
        }

        static readonly GUILayoutOption[] EmptyLayoutOption = new GUILayoutOption[0];

        ObservableTrackerTreeView treeView;
        object splitterState;

        // state on window
        static bool enableAutoReload;
        static bool enableTracking;
        static bool enableStackTrace;

        void OnEnable()
        {
            window = this; // set singleton.
            splitterState = SplitterGUILayout.CreateSplitterState(new float[] { 75f, 25f }, new int[] { 32, 32 }, null);
            treeView = new ObservableTrackerTreeView();

            // restore settings from EditorPrefs.
            enableAutoReload = EditorEnableState.EnableAutoReload;
            enableTracking = EditorEnableState.EnableTracking;
            enableStackTrace = EditorEnableState.EnableStackTrace;
        }

        void OnGUI()
        {
            // Head
            RenderHeadPanel();

            // Splittable
            SplitterGUILayout.BeginVerticalSplit(this.splitterState, EmptyLayoutOption);
            {
                // Column Tabble
                RenderTable();

                // StackTrace details
                RenderDetailsPanel();
            }
            SplitterGUILayout.EndVerticalSplit();
        }

        #region HeadPanel

        static readonly GUIContent EnableAutoReloadHeadContent = EditorGUIUtility.TrTextContent("Enable AutoReload", "Reload automatically.", (Texture)null);
        static readonly GUIContent ReloadHeadContent = EditorGUIUtility.TrTextContent("Reload", "Reload View.", (Texture)null);
        static readonly GUIContent GCHeadContent = EditorGUIUtility.TrTextContent("GC.Collect", "Invoke GC.Collect.", (Texture)null);
        static readonly GUIContent EnableTrackingHeadContent = EditorGUIUtility.TrTextContent("Enable Tracking", "Start to track Observable subscription. Performance impact: low", (Texture)null);
        static readonly GUIContent EnableStackTraceHeadContent = EditorGUIUtility.TrTextContent("Enable StackTrace", "Capture StackTrace when subscribed. Performance impact: high", (Texture)null);

        // [Enable Tracking] | [Enable StackTrace]
        void RenderHeadPanel()
        {
            EditorGUILayout.BeginVertical(EmptyLayoutOption);
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar, EmptyLayoutOption);

            if (GUILayout.Toggle(enableAutoReload, EnableAutoReloadHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != enableAutoReload)
            {
                EditorEnableState.EnableAutoReload = enableAutoReload = !enableAutoReload;
            }

            if (GUILayout.Toggle(enableTracking, EnableTrackingHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != enableTracking)
            {
                EditorEnableState.EnableTracking = enableTracking = !enableTracking;
            }

            if (GUILayout.Toggle(enableStackTrace, EnableStackTraceHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption) != enableStackTrace)
            {
                EditorEnableState.EnableStackTrace = enableStackTrace = !enableStackTrace;
            }

            GUILayout.FlexibleSpace();

            if (GUILayout.Button(ReloadHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption))
            {
                ObservableTracker.CheckAndResetDirty();
                treeView.ReloadAndSort();
                Repaint();
            }

            if (GUILayout.Button(GCHeadContent, EditorStyles.toolbarButton, EmptyLayoutOption))
            {
                GC.Collect(0);
            }

            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
        }

        #endregion

        #region TableColumn

        Vector2 tableScroll;
        GUIStyle tableListStyle;

        void RenderTable()
        {
            if (tableListStyle == null)
            {
                tableListStyle = new GUIStyle("CN Box");
                tableListStyle.margin.top = 0;
                tableListStyle.padding.left = 3;
            }

            EditorGUILayout.BeginVertical(tableListStyle, EmptyLayoutOption);

            this.tableScroll = EditorGUILayout.BeginScrollView(this.tableScroll, new GUILayoutOption[]
            {
                GUILayout.ExpandWidth(true),
                GUILayout.MaxWidth(2000f)
            });
            var controlRect = EditorGUILayout.GetControlRect(new GUILayoutOption[]
            {
                GUILayout.ExpandHeight(true),
                GUILayout.ExpandWidth(true)
            });


            treeView?.OnGUI(controlRect);

            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
        }

        private void Update()
        {
            // reflect to ObservableTracker
            ObservableTracker.EnableTracking = enableTracking;
            ObservableTracker.EnableStackTrace = enableStackTrace;

            //var count = 0;
            //ObservableTracker.ForEachActiveTask(_ => count++);
            //Debug.Log(count);

            if (enableAutoReload)
            {
                if (interval++ % 120 == 0)
                {
                    if (ObservableTracker.CheckAndResetDirty())
                    {
                        treeView.ReloadAndSort();
                        Repaint();
                    }
                }
            }
        }

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
        public static void SetObservableTrackerValues()
        {
            ObservableTracker.EnableTracking = EditorEnableState.EnableTracking;
            ObservableTracker.EnableStackTrace = EditorEnableState.EnableStackTrace;
        }

        #endregion

        #region Details

        static GUIStyle detailsStyle;
        Vector2 detailsScroll;

        void RenderDetailsPanel()
        {
            if (detailsStyle == null)
            {
                detailsStyle = new GUIStyle("CN Message");
                detailsStyle.wordWrap = false;
                detailsStyle.stretchHeight = true;
                detailsStyle.margin.right = 15;
            }

            string message = "";
            var selected = treeView.state.selectedIDs;
            if (selected.Count > 0)
            {
                var first = selected[0];
                var item = treeView.CurrentBindingItems.FirstOrDefault(x => x.id == first) as ObservableTrackerViewItem;
                if (item != null)
                {
                    message = item.Location;
                }
            }

            detailsScroll = EditorGUILayout.BeginScrollView(this.detailsScroll, EmptyLayoutOption);
            var vector = detailsStyle.CalcSize(new GUIContent(message));
            EditorGUILayout.SelectableLabel(message, detailsStyle, new GUILayoutOption[]
            {
                GUILayout.ExpandHeight(true),
                GUILayout.ExpandWidth(true),
                GUILayout.MinWidth(vector.x),
                GUILayout.MinHeight(vector.y)
            });
            EditorGUILayout.EndScrollView();
        }

        #endregion
    }
}




================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/ObservableTrackerWindow.cs.meta
================================================
fileFormatVersion: 2
guid: 54ec5737689776f48bc8358aba501f1a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/R3.Unity.Editor.asmdef
================================================
{
    "name": "R3.Unity.Editor",
    "references": [
        "R3.Unity"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": false,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/R3.Unity.Editor.asmdef.meta
================================================
fileFormatVersion: 2
guid: f8c68d614fe30d647996098360b5e0d5
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/SplitterGUILayout.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace R3.Unity.Editor
{
    // reflection call of UnityEditor.SplitterGUILayout
    internal static class SplitterGUILayout
    {
        static BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;

        static Lazy<Type> splitterStateType = new Lazy<Type>(() =>
        {
            var type = typeof(EditorWindow).Assembly.GetTypes().First(x => x.FullName == "UnityEditor.SplitterState");
            return type;
        });

        static Lazy<ConstructorInfo> splitterStateCtor = new Lazy<ConstructorInfo>(() =>
        {
            var type = splitterStateType.Value;
            return type.GetConstructor(flags, null, new Type[] { typeof(float[]), typeof(int[]), typeof(int[]) }, null);
        });

        static Lazy<Type> splitterGUILayoutType = new Lazy<Type>(() =>
        {
            var type = typeof(EditorWindow).Assembly.GetTypes().First(x => x.FullName == "UnityEditor.SplitterGUILayout");
            return type;
        });

        static Lazy<MethodInfo> beginVerticalSplit = new Lazy<MethodInfo>(() =>
        {
            var type = splitterGUILayoutType.Value;
            return type.GetMethod("BeginVerticalSplit", flags, null, new Type[] { splitterStateType.Value, typeof(GUILayoutOption[]) }, null);
        });

        static Lazy<MethodInfo> endVerticalSplit = new Lazy<MethodInfo>(() =>
        {
            var type = splitterGUILayoutType.Value;
            return type.GetMethod("EndVerticalSplit", flags, null, Type.EmptyTypes, null);
        });

        public static object CreateSplitterState(float[] relativeSizes, int[] minSizes, int[] maxSizes)
        {
            return splitterStateCtor.Value.Invoke(new object[] { relativeSizes, minSizes, maxSizes });
        }

        public static void BeginVerticalSplit(object splitterState, params GUILayoutOption[] options)
        {
            beginVerticalSplit.Value.Invoke(null, new object[] { splitterState, options });
        }

        public static void EndVerticalSplit()
        {
            endVerticalSplit.Value.Invoke(null, Type.EmptyTypes);
        }
    }
}




================================================
FILE: src/R3.Unity/Assets/R3.Unity/Editor/SplitterGUILayout.cs.meta
================================================
fileFormatVersion: 2
guid: b16473ade3ccae84eb3a8a9e560efcb3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/_InternalVisibleTo.cs
================================================
﻿using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("R3.Unity.TextMeshPro")]
[assembly: InternalsVisibleTo("R3.Unity.XRInteractionToolkit")]



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/_InternalVisibleTo.cs.meta
================================================
fileFormatVersion: 2
guid: f92126740e714becbbcea4bd7612f848
timeCreated: 1736167319
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External.meta
================================================
fileFormatVersion: 2
guid: 92b2b4ebe25aa924f908d2004d55a026
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/MonoBehaviourExtensions.cs
================================================
﻿using R3.Triggers;
using System;
using System.Threading;
using UnityEngine;

namespace R3
{
    public static class MonoBehaviourExtensions
    {
        internal static CancellationToken GetDestroyCancellationToken(this MonoBehaviour value)
        {
            // UNITY_2022_2_OR_NEWER has MonoBehavior.destroyCancellationToken
#if UNITY_2022_2_OR_NEWER
            return value.destroyCancellationToken;
#else
            var component = value.gameObject.GetComponent<R3.Triggers.ObservableDestroyTrigger>();
            if (component == null)
            {
                component = value.gameObject.AddComponent<R3.Triggers.ObservableDestroyTrigger>();
            }
            return component.GetCancellationToken();
#endif
        }

        /// <summary>Dispose self on target gameObject has been destroyed. Return value is self disposable.</summary>
        public static T AddTo<T>(this T disposable, GameObject gameObject)
            where T : IDisposable
        {
            if (gameObject == null)
            {
                disposable.Dispose();
                return disposable;
            }

            var trigger = gameObject.GetComponent<ObservableDestroyTrigger>();
            if (trigger == null)
            {
                trigger = gameObject.AddComponent<ObservableDestroyTrigger>();
            }

            // If gameObject is deactive, does not raise OnDestroy, watch and invoke trigger.
            if (!trigger.IsActivated && !trigger.gameObject.activeInHierarchy)
            {
                trigger.TryStartActivateMonitoring();
            }

            trigger.AddDisposableOnDestroy(disposable);
            return disposable;
        }

        /// <summary>Dispose self on target gameObject has been destroyed. Return value is self disposable.</summary>
        public static T AddTo<T>(this T disposable, Component gameObjectComponent)
            where T : IDisposable
        {
            if (gameObjectComponent == null)
            {
                disposable.Dispose();
                return disposable;
            }

#if UNITY_2022_2_OR_NEWER
            if (gameObjectComponent.gameObject.activeInHierarchy && gameObjectComponent is MonoBehaviour mb)
            {
                // gameObject is Awaked, no need to use ObservableDestroyTrigger
                disposable.RegisterTo(mb.destroyCancellationToken);
                return disposable;
            }
#endif

            // Add ObservableDestroyTrigger
            return AddTo(disposable, gameObjectComponent.gameObject);
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/MonoBehaviourExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: b4768aaec75c8ad4bb78d266fca5704c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/ObserveOnExtensions.cs
================================================
﻿namespace R3 // using R3
{
    public static class ObserveOnExtensions
    {
        public static Observable<T> ObserveOnMainThread<T>(this Observable<T> source)
        {
            return source.ObserveOn(UnityFrameProvider.Update);
        }

        public static Observable<T> SubscribeOnMainThread<T>(this Observable<T> source)
        {
            return source.SubscribeOn(UnityFrameProvider.Update);
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/ObserveOnExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: ddacbc050f511cc408f795b787d03a0b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/PlayerLoopHelper.cs
================================================
﻿#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System;
using System.Linq;
using UnityEngine;
using UnityEngine.LowLevel;
using PlayerLoopType = UnityEngine.PlayerLoop;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace R3
{
    public static class R3LoopRunners
    {
        public struct R3Initialization { };
        public struct R3EarlyUpdate { };
        public struct R3FixedUpdate { };
        public struct R3PreUpdate { };
        public struct R3Update { };
        public struct R3PreLateUpdate { };
        public struct R3PostLateUpdate { };
        public struct R3TimeUpdate { };
        public struct R3PostFixedUpdate { };
    }

    internal enum PlayerLoopTiming
    {
        Initialization = 0,
        EarlyUpdate = 1,
        FixedUpdate = 2,
        PreUpdate = 3,
        Update = 4,
        PreLateUpdate = 5,
        PostLateUpdate = 6,
        TimeUpdate = 7,

        PostFixedUpdate = 8 // new in v1.2.4
    }

    public static class PlayerLoopHelper
    {
        internal static string ApplicationDataPath => applicationDataPath; // used for editor window
        static string applicationDataPath;

        static UnityFrameProvider[] runners;

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
        static void Init()
        {
            try
            {
                applicationDataPath = Application.dataPath;
            }
            catch { }

#if UNITY_EDITOR
            // When domain reload is disabled, re-initialization is required when entering play mode; 
            // otherwise, pending tasks will leak between play mode sessions.
            var domainReloadDisabled = UnityEditor.EditorSettings.enterPlayModeOptionsEnabled &&
                UnityEditor.EditorSettings.enterPlayModeOptions.HasFlag(UnityEditor.EnterPlayModeOptions.DisableDomainReload);
            if (!domainReloadDisabled && runners != null) return;
#else
            if (runners != null) return; // already initialized
#endif

            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();
            Initialize(ref playerLoop);
        }

        public static void Initialize(ref PlayerLoopSystem playerLoop)
        {
            runners = new UnityFrameProvider[9];

            var newLoop = playerLoop.subSystemList.ToArray();

            // Initialization
            InsertLoop(newLoop, typeof(PlayerLoopType.Initialization), typeof(R3LoopRunners.R3Initialization), runners[0] = (UnityFrameProvider)UnityFrameProvider.Initialization);
            InsertLoop(newLoop, typeof(PlayerLoopType.EarlyUpdate), typeof(R3LoopRunners.R3EarlyUpdate), runners[1] = (UnityFrameProvider)UnityFrameProvider.EarlyUpdate);
            InsertLoop(newLoop, typeof(PlayerLoopType.FixedUpdate), typeof(R3LoopRunners.R3FixedUpdate), runners[2] = (UnityFrameProvider)UnityFrameProvider.FixedUpdate);
            InsertLoop(newLoop, typeof(PlayerLoopType.PreUpdate), typeof(R3LoopRunners.R3PreUpdate), runners[3] = (UnityFrameProvider)UnityFrameProvider.PreUpdate);
            InsertLoop(newLoop, typeof(PlayerLoopType.Update), typeof(R3LoopRunners.R3Update), runners[4] = (UnityFrameProvider)UnityFrameProvider.Update);
            InsertLoop(newLoop, typeof(PlayerLoopType.PreLateUpdate), typeof(R3LoopRunners.R3PreLateUpdate), runners[5] = (UnityFrameProvider)UnityFrameProvider.PreLateUpdate);
            InsertLoop(newLoop, typeof(PlayerLoopType.PostLateUpdate), typeof(R3LoopRunners.R3PostLateUpdate), runners[6] = (UnityFrameProvider)UnityFrameProvider.PostLateUpdate);
            InsertLoop(newLoop, typeof(PlayerLoopType.TimeUpdate), typeof(R3LoopRunners.R3TimeUpdate), runners[7] = (UnityFrameProvider)UnityFrameProvider.TimeUpdate);
            // FixedUpdate - Post
            InsertLoop(newLoop, typeof(PlayerLoopType.FixedUpdate), typeof(R3LoopRunners.R3PostFixedUpdate), runners[8] = (UnityFrameProvider)UnityFrameProvider.PostFixedUpdate);

            playerLoop.subSystemList = newLoop;
            PlayerLoop.SetPlayerLoop(playerLoop);
        }

        static void InsertLoop(PlayerLoopSystem[] loopSystems, Type loopType, Type loopRunnerType, UnityFrameProvider frameProvider)
        {
            var i = FindLoopSystemIndex(loopSystems, loopType);
            ref var loop = ref loopSystems[i];
            loop.subSystemList = InsertRunner(loop.subSystemList, loopRunnerType, frameProvider);
        }

        static int FindLoopSystemIndex(PlayerLoopSystem[] playerLoopList, Type systemType)
        {
            for (int i = 0; i < playerLoopList.Length; i++)
            {
                if (playerLoopList[i].type == systemType)
                {
                    return i;
                }
            }

            throw new Exception("Target PlayerLoopSystem does not found. Type:" + systemType.FullName);
        }

        static PlayerLoopSystem[] InsertRunner(PlayerLoopSystem[] subSystemList, Type loopRunnerType, UnityFrameProvider runner)
        {

#if UNITY_EDITOR
            EditorApplication.playModeStateChanged += (state) =>
            {
                if (state == PlayModeStateChange.EnteredEditMode || state == PlayModeStateChange.ExitingEditMode)
                {
                    // run rest action before clear.
                    if (runner != null)
                    {
                        runner.Run();
                        runner.Clear();
                    }
                }
            };
#endif

            var source = subSystemList.Where(x => x.type != loopRunnerType).ToArray(); // remove duplicate(initialized previously)
            var dest = new PlayerLoopSystem[source.Length + 1];

            // insert first
            var insertIndex = (runner.PlayerLoopTiming != PlayerLoopTiming.PostFixedUpdate)
                ? 0 // insert first
                : dest.Length - 1; // insert last

            Array.Copy(source, 0, dest, insertIndex == 0 ? 1 : 0, source.Length);

            dest[insertIndex] = new PlayerLoopSystem
            {
                type = loopRunnerType,
                updateDelegate = runner.Run
            };

            return dest;
        }

#if UNITY_EDITOR

        [InitializeOnLoadMethod]
        static void InitOnEditor()
        {
            // Execute the play mode init method
            Init();

            // register an Editor update delegate, used to forcing playerLoop update
            EditorApplication.update += ForceEditorPlayerLoopUpdate;
        }

        private static void ForceEditorPlayerLoopUpdate()
        {
            if (EditorApplication.isPlayingOrWillChangePlaymode || EditorApplication.isCompiling || EditorApplication.isUpdating)
            {
                // Not in Edit mode, don't interfere
                return;
            }

            if (runners != null)
            {
                foreach (var item in runners)
                {
                    if (item != null) item.Run();
                }
            }
        }

#endif
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/PlayerLoopHelper.cs.meta
================================================
fileFormatVersion: 2
guid: fec43b7564edb8246a071f06ebbf0b8c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/R3.Unity.asmdef
================================================
{
    "name": "R3.Unity",
    "rootNamespace": "R3",
    "references": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": true,
    "precompiledReferences": [
        "R3.dll",
        "Microsoft.Bcl.TimeProvider.dll",
        "Microsoft.Bcl.AsyncInterfaces.dll"
    ],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.ugui",
            "expression": "",
            "define": "R3_UGUI_SUPPORT"
        },
        {
            "name": "com.unity.modules.physics",
            "expression": "",
            "define": "R3_PHYSICS_SUPPORT"
        },
        {
            "name": "com.unity.modules.physics2d",
            "expression": "",
            "define": "R3_PHYSICS2D_SUPPORT"
        },
        {
            "name": "com.unity.modules.particlesystem",
            "expression": "",
            "define": "R3_PARTICLESYSTEM_SUPPORT"
        },
        {
            "name": "com.unity.modules.animation",
            "expression": "",
            "define": "R3_ANIMATION_SUPPORT"
        }
    ],
    "noEngineReferences": false
}


================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/R3.Unity.asmdef.meta
================================================
fileFormatVersion: 2
guid: 77221876cc6b8244180b96e320b1bcd4
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/SerializableReactiveProperty.cs
================================================
﻿using System;
using UnityEngine;
using System.Reflection;
using System.Text.RegularExpressions;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace R3
{
    [Serializable]
    public class SerializableReactiveProperty<T> : ReactiveProperty<T>, ISerializationCallbackReceiver
    {
        [SerializeField]
        T value;

        public SerializableReactiveProperty()
            : base(default!)
        {
        }

        public SerializableReactiveProperty(T value)
            : base(value)
        {
        }

        protected override void OnValueChanged(T value)
        {
            this.value = value;
        }

        void ISerializationCallbackReceiver.OnBeforeSerialize()
        {
        }

        void ISerializationCallbackReceiver.OnAfterDeserialize()
        {
            GetValueRef() = this.value; // force set
        }
    }

#if UNITY_EDITOR

    [CustomPropertyDrawer(typeof(SerializableReactiveProperty<>))]
    internal class SerializableReactivePropertyDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            var p = property.FindPropertyRelative("value");

            EditorGUI.BeginChangeCheck();

            if (p.propertyType == SerializedPropertyType.Quaternion)
            {
                label.text += "(EulerAngles)";
                EditorGUI.PropertyField(position, p, label, true);
            }
            else
            {
                EditorGUI.PropertyField(position, p, label, true);
            }

            if (EditorGUI.EndChangeCheck())
            {
                var paths = property.propertyPath.Split('.'); // X.Y.Z...
                var attachedComponent = property.serializedObject.targetObject;

                var targetProp = GetValueRecursive(attachedComponent, 0, paths);
                if (targetProp == null) return;

                property.serializedObject.ApplyModifiedProperties(); // deserialize to field
                var methodInfo = targetProp.GetType().GetMethod("ForceNotify", BindingFlags.IgnoreCase | BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (methodInfo != null)
                {
                    methodInfo.Invoke(targetProp, Array.Empty<object>());
                }
            }
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            var p = property.FindPropertyRelative("value");
            if (p.propertyType == SerializedPropertyType.Quaternion)
            {
                // Quaternion is Vector3(EulerAngles)
                return EditorGUI.GetPropertyHeight(SerializedPropertyType.Vector3, label);
            }
            else
            {
                return EditorGUI.GetPropertyHeight(p);
            }
        }

        object GetValueRecursive(object obj, int index, string[] paths)
        {
            var path = paths[index];

            FieldInfo fldInfo = null;
            var type = obj.GetType();
            while (fldInfo == null)
            {
                // attempt to get information about the field
                fldInfo = type.GetField(path, BindingFlags.IgnoreCase | BindingFlags.GetField | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

                if (fldInfo != null ||
                    type.BaseType == null ||
                    type.BaseType.IsSubclassOf(typeof(ReactiveProperty<>))) break;

                // if the field information is missing, it may be in the base class
                type = type.BaseType;
            }

            // If array, path = Array.data[index]
            if (fldInfo == null && path == "Array")
            {
                try
                {
                    path = paths[++index];
                    var m = Regex.Match(path, @"(.+)\[([0-9]+)*\]");
                    var arrayIndex = int.Parse(m.Groups[2].Value);
                    var arrayValue = (obj as System.Collections.IList)[arrayIndex];
                    if (index < paths.Length - 1)
                    {
                        return GetValueRecursive(arrayValue, ++index, paths);
                    }
                    else
                    {
                        return arrayValue;
                    }
                }
                catch
                {
                    Debug.Log("SerializableReactivePropertyDrawer Exception, objType:" + obj.GetType().Name + " path:" + string.Join(", ", paths));
                    throw;
                }
            }
            else if (fldInfo == null)
            {
                throw new Exception("Can't decode path:" + string.Join(", ", paths));
            }

            var v = fldInfo.GetValue(obj);
            if (index < paths.Length - 1)
            {
                return GetValueRecursive(v, ++index, paths);
            }

            return v;
        }
    }

#endif
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/SerializableReactiveProperty.cs.meta
================================================
fileFormatVersion: 2
guid: f3a8f864823daf440abfd9108a6cabed
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers.meta
================================================
fileFormatVersion: 2
guid: 7df3531eb9850634ba82d4a934cc5778
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityEventExtensions.cs
================================================
﻿using System.Threading;
using UnityEngine.Events;

namespace R3
{
    public static class UnityEventExtensions
    {
        public static Observable<Unit> AsObservable(this UnityEngine.Events.UnityEvent unityEvent, CancellationToken cancellationToken = default)
        {
            return Observable.FromEvent(h => new UnityAction(h), h => unityEvent.AddListener(h), h => unityEvent.RemoveListener(h), cancellationToken);
        }

        public static Observable<T> AsObservable<T>(this UnityEngine.Events.UnityEvent<T> unityEvent, CancellationToken cancellationToken = default)
        {
            return Observable.FromEvent<UnityAction<T>, T>(h => new UnityAction<T>(h), h => unityEvent.AddListener(h), h => unityEvent.RemoveListener(h), cancellationToken);
        }

        public static Observable<(T0 Arg0, T1 Arg1)> AsObservable<T0, T1>(this UnityEngine.Events.UnityEvent<T0, T1> unityEvent, CancellationToken cancellationToken = default)
        {
            return Observable.FromEvent<UnityAction<T0, T1>, (T0, T1)>(h =>
            {
                return new UnityAction<T0, T1>((t0, t1) =>
                {
                    h((t0, t1));
                });
            }, h => unityEvent.AddListener(h), h => unityEvent.RemoveListener(h), cancellationToken);
        }

        public static Observable<(T0 Arg0, T1 Arg1, T2 Arg2)> AsObservable<T0, T1, T2>(this UnityEngine.Events.UnityEvent<T0, T1, T2> unityEvent, CancellationToken cancellationToken = default)
        {
            return Observable.FromEvent<UnityAction<T0, T1, T2>, (T0, T1, T2)>(h =>
            {
                return new UnityAction<T0, T1, T2>((t0, t1, t2) =>
                {
                    h((t0, t1, t2));
                });
            }, h => unityEvent.AddListener(h), h => unityEvent.RemoveListener(h), cancellationToken);
        }

        public static Observable<(T0 Arg0, T1 Arg1, T2 Arg2, T3 Arg3)> AsObservable<T0, T1, T2, T3>(this UnityEngine.Events.UnityEvent<T0, T1, T2, T3> unityEvent, CancellationToken cancellationToken = default)
        {
            return Observable.FromEvent<UnityAction<T0, T1, T2, T3>, (T0, T1, T2, T3)>(h =>
            {
                return new UnityAction<T0, T1, T2, T3>((t0, t1, t2, t3) =>
                {
                    h((t0, t1, t2, t3));
                });
            }, h => unityEvent.AddListener(h), h => unityEvent.RemoveListener(h), cancellationToken);
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityEventExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: c39b1e6add48ef24c95fd640b08622ef
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityFrameProvider.cs
================================================
﻿using R3.Collections;
using System;
using UnityEngine;

namespace R3
{
    public class UnityFrameProvider : FrameProvider
    {
        public static readonly FrameProvider Initialization = new UnityFrameProvider(PlayerLoopTiming.Initialization);
        public static readonly FrameProvider EarlyUpdate = new UnityFrameProvider(PlayerLoopTiming.EarlyUpdate);
        public static readonly FrameProvider FixedUpdate = new UnityFrameProvider(PlayerLoopTiming.FixedUpdate);
        public static readonly FrameProvider PreUpdate = new UnityFrameProvider(PlayerLoopTiming.PreUpdate);
        public static readonly FrameProvider Update = new UnityFrameProvider(PlayerLoopTiming.Update);
        public static readonly FrameProvider PreLateUpdate = new UnityFrameProvider(PlayerLoopTiming.PreLateUpdate);
        public static readonly FrameProvider PostLateUpdate = new UnityFrameProvider(PlayerLoopTiming.PostLateUpdate);
        public static readonly FrameProvider TimeUpdate = new UnityFrameProvider(PlayerLoopTiming.TimeUpdate);
        public static readonly FrameProvider PostFixedUpdate = new UnityFrameProvider(PlayerLoopTiming.PostFixedUpdate);

        FreeListCore<IFrameRunnerWorkItem> list;
        readonly object gate = new object();

        internal PlayerLoopTiming PlayerLoopTiming { get; }

        internal UnityFrameProvider(PlayerLoopTiming playerLoopTiming)
        {
            this.PlayerLoopTiming = playerLoopTiming;
            this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        }

        public override long GetFrameCount()
        {
            return Time.frameCount;
        }

        public override void Register(IFrameRunnerWorkItem callback)
        {
            list.Add(callback, out _);
        }

        // called from PlayerLoop

        internal void Run()
        {
            long frameCount = Time.frameCount;

            var span = list.AsSpan();
            for (int i = 0; i < span.Length; i++)
            {
                ref readonly var item = ref span[i];
                if (item != null)
                {
                    try
                    {
                        if (!item.MoveNext(frameCount))
                        {
                            list.Remove(i);
                        }
                    }
                    catch (Exception ex)
                    {
                        list.Remove(i);
                        try
                        {
                            ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                        }
                        catch { }
                    }
                }
            }
        }

        internal void Clear()
        {
            list.Clear(removeArray: true);
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityFrameProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 1dca9d5e587a27346b74649eeec0df56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityProviderInitializer.cs
================================================
﻿using System;
using UnityEngine;

[assembly: UnityEngine.Scripting.AlwaysLinkAssembly]

namespace R3
{
#if UNITY_EDITOR
    [UnityEditor.InitializeOnLoad]
#endif
    public static class UnityProviderInitializer
    {
        static UnityProviderInitializer()
        {
            SetDefaultObservableSystem();
        }

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
        public static void SetDefaultObservableSystem()
        {
            SetDefaultObservableSystem(static ex => UnityEngine.Debug.LogException(ex));
        }

        public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)
        {
            ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
            ObservableSystem.DefaultTimeProvider = UnityTimeProvider.Update;
            ObservableSystem.DefaultFrameProvider = UnityFrameProvider.Update;
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityProviderInitializer.cs.meta
================================================
fileFormatVersion: 2
guid: 0e0d541f39058cb4d9c10db7c3182f71
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityTimeProvider.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

namespace R3
{
    public enum TimeKind
    {
        /// <summary>use Time.time, Time.deltaTime or Time.fixedTime, Time.fixedDeltaTime.</summary>
        Time,
        /// <summary>Ignore timescale, use Time.unscaledTime, Time.unscaledDeltaTime or Time.fixedUnscaledTime, Time.fixedUnscaledDeltaTime.</summary>
        UnscaledTime,
        /// <summary>use Time.realtimeSinceStartup, TimeProvider.System.GetTimestamp()<summary>
        Realtime
    }

    public class UnityTimeProvider : TimeProvider
    {
        public static readonly TimeProvider Initialization = new UnityTimeProvider(UnityFrameProvider.Initialization, TimeKind.Time);
        public static readonly TimeProvider EarlyUpdate = new UnityTimeProvider(UnityFrameProvider.EarlyUpdate, TimeKind.Time);
        public static readonly TimeProvider FixedUpdate = new UnityTimeProvider(UnityFrameProvider.FixedUpdate, TimeKind.Time);
        public static readonly TimeProvider PreUpdate = new UnityTimeProvider(UnityFrameProvider.PreUpdate, TimeKind.Time);
        public static readonly TimeProvider Update = new UnityTimeProvider(UnityFrameProvider.Update, TimeKind.Time);
        public static readonly TimeProvider PreLateUpdate = new UnityTimeProvider(UnityFrameProvider.PreLateUpdate, TimeKind.Time);
        public static readonly TimeProvider PostLateUpdate = new UnityTimeProvider(UnityFrameProvider.PostLateUpdate, TimeKind.Time);
        public static readonly TimeProvider TimeUpdate = new UnityTimeProvider(UnityFrameProvider.TimeUpdate, TimeKind.Time);

        public static readonly TimeProvider InitializationIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.Initialization, TimeKind.UnscaledTime);
        public static readonly TimeProvider EarlyUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.EarlyUpdate, TimeKind.UnscaledTime);
        public static readonly TimeProvider FixedUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.FixedUpdate, TimeKind.UnscaledTime);
        public static readonly TimeProvider PreUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.PreUpdate, TimeKind.UnscaledTime);
        public static readonly TimeProvider UpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.Update, TimeKind.UnscaledTime);
        public static readonly TimeProvider PreLateUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.PreLateUpdate, TimeKind.UnscaledTime);
        public static readonly TimeProvider PostLateUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.PostLateUpdate, TimeKind.UnscaledTime);
        public static readonly TimeProvider TimeUpdateIgnoreTimeScale = new UnityTimeProvider(UnityFrameProvider.TimeUpdate, TimeKind.UnscaledTime);

        public static readonly TimeProvider InitializationRealtime = new UnityTimeProvider(UnityFrameProvider.Initialization, TimeKind.Realtime);
        public static readonly TimeProvider EarlyUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.EarlyUpdate, TimeKind.Realtime);
        public static readonly TimeProvider FixedUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.FixedUpdate, TimeKind.Realtime);
        public static readonly TimeProvider PreUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.PreUpdate, TimeKind.Realtime);
        public static readonly TimeProvider UpdateRealtime = new UnityTimeProvider(UnityFrameProvider.Update, TimeKind.Realtime);
        public static readonly TimeProvider PreLateUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.PreLateUpdate, TimeKind.Realtime);
        public static readonly TimeProvider PostLateUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.PostLateUpdate, TimeKind.Realtime);
        public static readonly TimeProvider TimeUpdateRealtime = new UnityTimeProvider(UnityFrameProvider.TimeUpdate, TimeKind.Realtime);

        readonly UnityFrameProvider frameProvider;
        readonly TimeKind timeKind;

        UnityTimeProvider(FrameProvider frameProvider, TimeKind timeKind)
        {
            this.frameProvider = (UnityFrameProvider)frameProvider;
            this.timeKind = timeKind;
        }

        public override long GetTimestamp()
        {
            // need to convert ticks(used TimeSpan ctor)
            if (frameProvider.PlayerLoopTiming == PlayerLoopTiming.FixedUpdate)
            {
                switch (timeKind)
                {
                    case TimeKind.Time:
                        return TimeSpan.FromSeconds(Time.fixedTimeAsDouble).Ticks;
                    case TimeKind.UnscaledTime:
                        return TimeSpan.FromSeconds(Time.fixedUnscaledTimeAsDouble).Ticks;
                    default:
                        break;
                }
            }
            else
            {
                switch (timeKind)
                {
                    case TimeKind.Time:
                        return TimeSpan.FromSeconds(Time.timeAsDouble).Ticks;
                    case TimeKind.UnscaledTime:
                        return TimeSpan.FromSeconds(Time.unscaledTimeAsDouble).Ticks;
                    default:
                        break;
                }
            }

            return TimeSpan.FromSeconds(Time.realtimeSinceStartupAsDouble).Ticks;
        }

        public override ITimer CreateTimer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period)
        {
            return new FrameTimer(callback, state, dueTime, period, frameProvider, timeKind);
        }
    }

    internal sealed class FrameTimer : ITimer, IFrameRunnerWorkItem
    {
        enum RunningState
        {
            Stop,
            RunningDueTime,
            RunningPeriod,
            ChangeRequested
        }

        readonly TimerCallback callback;
        readonly object state;
        readonly UnityFrameProvider frameProvider;
        readonly TimeKind timeKind;
        readonly object gate = new object();

        TimeSpan dueTime;
        TimeSpan period;
        RunningState runningState;
        float elapsed;
        bool isDisposed;

        // for DeltaType.Realtime
        long lastTimestamp;

        public FrameTimer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period, UnityFrameProvider frameProvider, TimeKind timeKind)
        {
            this.callback = callback;
            this.state = state;
            this.dueTime = dueTime;
            this.period = period;
            this.frameProvider = frameProvider;
            this.timeKind = timeKind;
            Change(dueTime, period);
        }

        public bool Change(TimeSpan dueTime, TimeSpan period)
        {
            if (isDisposed) return false;

            lock (gate)
            {
                this.dueTime = dueTime;
                this.period = period;

                if (dueTime == Timeout.InfiniteTimeSpan)
                {
                    if (runningState == RunningState.Stop)
                    {
                        return true;
                    }
                }

                if (runningState == RunningState.Stop)
                {
                    frameProvider.Register(this);
                }

                runningState = RunningState.ChangeRequested;
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        float GetDeltaTime()
        {
            if (frameProvider.PlayerLoopTiming == PlayerLoopTiming.FixedUpdate)
            {
                switch (timeKind)
                {
                    case TimeKind.Time:
                        return Time.fixedDeltaTime;
                    case TimeKind.UnscaledTime:
                        return Time.fixedUnscaledDeltaTime;
                    default:
                        break;
                }
            }
            else
            {
                switch (timeKind)
                {
                    case TimeKind.Time:
                        return Time.deltaTime;
                    case TimeKind.UnscaledTime:
                        return Time.unscaledDeltaTime;
                    default:
                        break;
                }
            }

            // DelayType.Realtime
            var current = TimeProvider.System.GetTimestamp();
            var elapsed = TimeProvider.System.GetElapsedTime(lastTimestamp, current);
            lastTimestamp = current;
            return (float)elapsed.TotalSeconds;
        }

        bool IFrameRunnerWorkItem.MoveNext(long frameCount)
        {
            if (isDisposed) return false;

            RunningState runState;
            TimeSpan p; // period
            TimeSpan d; // dueTime
            lock (gate)
            {
                runState = runningState;

                if (runState == RunningState.ChangeRequested)
                {
                    elapsed = 0;
                    if (dueTime == Timeout.InfiniteTimeSpan)
                    {
                        runningState = RunningState.Stop;
                        return false;
                    }

                    runState = runningState = RunningState.RunningDueTime;
                }
                p = period;
                d = dueTime;
            }

            elapsed += GetDeltaTime();

            try
            {
                if (runState == RunningState.RunningDueTime)
                {
                    var dt = (float)d.TotalSeconds;
                    if (elapsed >= dt)
                    {
                        callback(state);

                        elapsed = 0;
                        if (period == Timeout.InfiniteTimeSpan)
                        {
                            return ChangeState(RunningState.Stop);
                        }
                        else
                        {
                            return ChangeState(RunningState.RunningPeriod);
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                else
                {
                    var dt = (float)p.TotalSeconds;
                    if (elapsed >= dt)
                    {
                        callback(state);
                        elapsed = 0;
                    }

                    return ChangeState(RunningState.RunningPeriod);
                }
            }
            catch (Exception ex)
            {
                ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                return ChangeState(RunningState.Stop);
            }
        }

        bool ChangeState(RunningState state)
        {
            lock (gate)
            {
                // change requested is high priority
                if (runningState == RunningState.ChangeRequested)
                {
                    return true;
                }

                switch (state)
                {
                    case RunningState.RunningPeriod:
                        runningState = state;
                        return true;
                    default: // otherwise(Stop)
                        runningState = state;
                        return false;
                }
            }
        }

        public void Dispose()
        {
            Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
            isDisposed = true;
        }

        public ValueTask DisposeAsync()
        {
            Dispose();
            return default;
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityTimeProvider.cs.meta
================================================
fileFormatVersion: 2
guid: 5f17971c716f43e4bb0ef1bcdf690956
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityUIComponentExtensions.cs
================================================
#if R3_UGUI_SUPPORT
using R3;
using System;
using UnityEngine;
using UnityEngine.UI;

namespace R3
{
    public static partial class UnityUIComponentExtensions
    {
        public static IDisposable SubscribeToText(this Observable<string> source, Text text)
        {
            return source.Subscribe(text, static (x, t) => t.text = x);
        }

        public static IDisposable SubscribeToText<T>(this Observable<T> source, Text text)
        {
            return source.Subscribe(text, static (x, t) => t.text = x.ToString());
        }

        public static IDisposable SubscribeToText<T>(this Observable<T> source, Text text, Func<T, string> selector)
        {
            return source.Subscribe((text, selector), static (x, state) => state.text.text = state.selector(x));
        }

        public static IDisposable SubscribeToInteractable(this Observable<bool> source, Selectable selectable)
        {
            return source.Subscribe(selectable, static (x, s) => s.interactable = x);
        }

        /// <summary>Observe onClick event.</summary>
        public static Observable<Unit> OnClickAsObservable(this Button button)
        {
            return button.onClick.AsObservable(button.GetDestroyCancellationToken());
        }

        /// <summary>Observe onValueChanged with current `isOn` value on subscribe.</summary>
        public static Observable<bool> OnValueChangedAsObservable(this Toggle toggle)
        {
            // Optimized Defer + StartWith
            return Observable.Create<bool, Toggle>(toggle, static (observer, t) =>
            {
                observer.OnNext(t.isOn);
                return t.onValueChanged.AsObservable(t.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        public static Observable<float> OnValueChangedAsObservable(this Scrollbar scrollbar)
        {
            return Observable.Create<float, Scrollbar>(scrollbar, static (observer, s) =>
            {
                observer.OnNext(s.value);
                return s.onValueChanged.AsObservable(s.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onValueChanged with current `normalizedPosition` value on subscribe.</summary>
        public static Observable<Vector2> OnValueChangedAsObservable(this ScrollRect scrollRect)
        {
            return Observable.Create<Vector2, ScrollRect>(scrollRect, static (observer, s) =>
            {
                observer.OnNext(s.normalizedPosition);
                return s.onValueChanged.AsObservable(s.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        public static Observable<float> OnValueChangedAsObservable(this Slider slider)
        {
            return Observable.Create<float, Slider>(slider, static (observer, s) =>
            {
                observer.OnNext(s.value);
                return s.onValueChanged.AsObservable(s.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onEndEdit(Submit) event.</summary>
        public static Observable<string> OnEndEditAsObservable(this InputField inputField)
        {
            return inputField.onEndEdit.AsObservable(inputField.GetDestroyCancellationToken());
        }

        /// <summary>Observe onValueChanged with current `text` value on subscribe.</summary>
        public static Observable<string> OnValueChangedAsObservable(this InputField inputField)
        {
            return Observable.Create<string, InputField>(inputField, static (observer, i) =>
            {
                observer.OnNext(i.text);
                return i.onValueChanged.AsObservable(i.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        public static Observable<int> OnValueChangedAsObservable(this Dropdown dropdown)
        {
            return Observable.Create<int, Dropdown>(dropdown, static (observer, d) =>
            {
                observer.OnNext(d.value);
                return d.onValueChanged.AsObservable(d.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/UnityUIComponentExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 882637b17a532954791545bbc03d97cd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/TextMeshPro.meta
================================================
fileFormatVersion: 2
guid: 5a8e6a6ce06b23c4980c23d2d37c2eda
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/XRInteractionToolkit.meta
================================================
fileFormatVersion: 2
guid: c945df85fc3bc9a45be1ce4cb608c538
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/TextMeshPro/R3.Unity.TextMeshPro.asmdef
================================================
{
    "name": "R3.Unity.TextMeshPro",
    "rootNamespace": "",
    "references": [
        "R3.Unity",
        "Unity.TextMeshPro"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.textmeshpro",
            "expression": "",
            "define": "R3_TEXTMESHPRO_SUPPORT"
        },
        {
            "name": "com.unity.ugui",
            "expression": "2.0.0",
            "define": "R3_TEXTMESHPRO_SUPPORT"
        }
    ],
    "noEngineReferences": false
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/TextMeshPro/R3.Unity.TextMeshPro.asmdef.meta
================================================
fileFormatVersion: 2
guid: f02da9ca564ed54499f6f43d8249d415
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/TextMeshPro/TextMeshProExtensions.cs
================================================
#if R3_TEXTMESHPRO_SUPPORT

using System;
using TMPro;

namespace R3
{
    public static class TextMeshProExtensions
    {
        public static IDisposable SubscribeToText(this Observable<string> source, TMP_Text text)
        {
            return source.Subscribe(text, static (x, t) => t.text = x);
        }

        public static IDisposable SubscribeToText<T>(this Observable<T> source, TMP_Text text)
        {
            return source.Subscribe(text, static (x, t) => t.text = x.ToString());
        }

        public static IDisposable SubscribeToText<T>(this Observable<T> source, TMP_Text text, Func<T, string> selector)
        {
            return source.Subscribe((text, selector), static (x, state) => state.text.text = state.selector(x));
        }

        /// <summary>Observe onEndEdit(Submit) event.</summary>
        public static Observable<string> OnEndEditAsObservable(this TMP_InputField inputField)
        {
            return inputField.onEndEdit.AsObservable(inputField.GetDestroyCancellationToken());
        }

        /// <summary>Observe onValueChanged with current `text` value on subscribe.</summary>
        public static Observable<string> OnValueChangedAsObservable(this TMP_InputField inputField)
        {
            return Observable.Create<string, TMP_InputField>(inputField, static (observer, i) =>
            {
                observer.OnNext(i.text);
                return i.onValueChanged.AsObservable(i.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }

        /// <summary>Observe onValueChanged with current `value` on subscribe.</summary>
        public static Observable<int> OnValueChangedAsObservable(this TMP_Dropdown dropdown)
        {
            return Observable.Create<int, TMP_Dropdown>(dropdown, static (observer, d) =>
            {
                observer.OnNext(d.value);
                return d.onValueChanged.AsObservable(d.GetDestroyCancellationToken()).Subscribe(observer);
            });
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/TextMeshPro/TextMeshProExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: bf183de6575eba64599662fa9e4e5103
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/XRInteractionToolkit/R3.Unity.XRInteractionToolkit.asmdef
================================================
{
    "name": "R3.Unity.XRInteractionToolkit",
    "rootNamespace": "R3.Unity.XRInteractionToolkit",
    "references": [
        "R3.Unity",
        "Unity.XR.Interaction.Toolkit"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": false,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.xr.interaction.toolkit",
            "expression": "",
            "define": "R3_XRI_SUPPORT"
        }
    ],
    "noEngineReferences": false
}


================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/XRInteractionToolkit/R3.Unity.XRInteractionToolkit.asmdef.meta
================================================
fileFormatVersion: 2
guid: f7c3854fe92796b44ace45670f7ee36c
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/XRInteractionToolkit/UnityXRBaseInteractableExtensions.cs
================================================
﻿#if R3_XRI_SUPPORT
using UnityEngine.XR.Interaction.Toolkit;

namespace R3
{
    public static partial class UnityXRBaseInteractableExtensions
    {
        /// <summary>Observe selectEntered event.</summary>
        public static Observable<SelectEnterEventArgs> OnSelectEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.selectEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe selectExited event.</summary>
        public static Observable<SelectExitEventArgs> OnSelectExitedAsObservable(this XRBaseInteractable component)
        {
            return component.selectExited.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe firstSelectEntered event.</summary>
        public static Observable<SelectEnterEventArgs> OnFirstSelectEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.firstSelectEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe lastSelectExited event.</summary>
        public static Observable<SelectExitEventArgs> OnLastSelectExitedAsObservable(this XRBaseInteractable component)
        {
            return component.lastSelectExited.AsObservable(component.GetDestroyCancellationToken());
        }

        /// <summary>Observe hoverEntered event.</summary>
        public static Observable<HoverEnterEventArgs> OnHoverEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.hoverEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe hoverExited event.</summary>
        public static Observable<HoverExitEventArgs> OnHoverExitedAsObservable(this XRBaseInteractable component)
        {
            return component.hoverExited.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe firstHoverEntered event.</summary>
        public static Observable<HoverEnterEventArgs> OnFirstHoverEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.firstHoverEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe lastHoverExited event.</summary>
        public static Observable<HoverExitEventArgs> OnLastHoverExitedAsObservable(this XRBaseInteractable component)
        {
            return component.lastHoverExited.AsObservable(component.GetDestroyCancellationToken());
        }

        /// <summary>Observe focusEntered event.</summary>
        public static Observable<FocusEnterEventArgs> OnFocusEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.focusEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe focusExited event.</summary>
        public static Observable<FocusExitEventArgs> OnFocusExitedAsObservable(this XRBaseInteractable component)
        {
            return component.focusExited.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe firstFocusEntered event.</summary>
        public static Observable<FocusEnterEventArgs> OnFirstFocusEnteredAsObservable(this XRBaseInteractable component)
        {
            return component.firstFocusEntered.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe lastFocusExited event.</summary>
        public static Observable<FocusExitEventArgs> OnLastFocusExitedAsObservable(this XRBaseInteractable component)
        {
            return component.lastFocusExited.AsObservable(component.GetDestroyCancellationToken());
        }

        /// <summary>Observe activated event.</summary>
        public static Observable<ActivateEventArgs> OnActivatedAsObservable(this XRBaseInteractable component)
        {
            return component.activated.AsObservable(component.GetDestroyCancellationToken());
        }
        /// <summary>Observe activated event.</summary>
        public static Observable<DeactivateEventArgs> OnDeactivatedAsObservable(this XRBaseInteractable component)
        {
            return component.deactivated.AsObservable(component.GetDestroyCancellationToken());
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/External/XRInteractionToolkit/UnityXRBaseInteractableExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: c3fdb9ef9ef9cd24a86e12738de0d104
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableAnimatorTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableAnimatorTrigger : ObservableTriggerBase
    {
        Subject<int> onAnimatorIK;

        /// <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        void OnAnimatorIK(int layerIndex)
        {
            if (onAnimatorIK != null) onAnimatorIK.OnNext(layerIndex);
        }

        /// <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        public Observable<int> OnAnimatorIKAsObservable()
        {
            return onAnimatorIK ?? (onAnimatorIK = new Subject<int>());
        }

        Subject<Unit> onAnimatorMove;

        /// <summary>Callback for processing animation movements for modifying root motion.</summary>
        void OnAnimatorMove()
        {
            if (onAnimatorMove != null) onAnimatorMove.OnNext(Unit.Default);
        }

        /// <summary>Callback for processing animation movements for modifying root motion.</summary>
        public Observable<Unit> OnAnimatorMoveAsObservable()
        {
            return onAnimatorMove ?? (onAnimatorMove = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onAnimatorIK != null)
            {
                onAnimatorIK.OnCompleted();
            }
            if (onAnimatorMove != null)
            {
                onAnimatorMove.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableAnimatorTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 81dd5f99d5230db489d57add90f34cd0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableBeginDragTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT

using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableBeginDragTrigger : ObservableTriggerBase, IEventSystemHandler, IBeginDragHandler
    {
        Subject<PointerEventData> onBeginDrag;

        void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
        {
            if (onBeginDrag != null) onBeginDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnBeginDragAsObservable()
        {
            return onBeginDrag ?? (onBeginDrag = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onBeginDrag != null)
            {
                onBeginDrag.OnCompleted();
            }
        }
    }
}

#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableBeginDragTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: ebd6c5e9d53abcc4abf64976e85b2555
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCancelTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT

using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableCancelTrigger : ObservableTriggerBase, IEventSystemHandler, ICancelHandler
    {
        Subject<BaseEventData> onCancel;

        void ICancelHandler.OnCancel(BaseEventData eventData)
        {
            if (onCancel != null) onCancel.OnNext(eventData);
        }

        public Observable<BaseEventData> OnCancelAsObservable()
        {
            return onCancel ?? (onCancel = new Subject<BaseEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onCancel != null)
            {
                onCancel.OnCompleted();
            }
        }
    }
}

#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCancelTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 950b53eba1853b846bb6c13e5902076f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCanvasGroupChangedTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableCanvasGroupChangedTrigger : ObservableTriggerBase
    {
        Subject<Unit> onCanvasGroupChanged;

        // Callback that is sent if the canvas group is changed
        void OnCanvasGroupChanged()
        {
            if (onCanvasGroupChanged != null) onCanvasGroupChanged.OnNext(Unit.Default);
        }

        /// <summary>Callback that is sent if the canvas group is changed.</summary>
        public Observable<Unit> OnCanvasGroupChangedAsObservable()
        {
            return onCanvasGroupChanged ?? (onCanvasGroupChanged = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onCanvasGroupChanged != null)
            {
                onCanvasGroupChanged.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCanvasGroupChangedTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 2cf8e5c580158c545aa0f7f78e4994ea
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCollision2DTrigger.cs
================================================
﻿#if R3_PHYSICS2D_SUPPORT
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableCollision2DTrigger : ObservableTriggerBase
    {
        Subject<Collision2D> onCollisionEnter2D;

        /// <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
         void OnCollisionEnter2D(Collision2D coll)
        {
            if (onCollisionEnter2D != null) onCollisionEnter2D.OnNext(coll);
        }

        /// <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        public Observable<Collision2D> OnCollisionEnter2DAsObservable()
        {
            return onCollisionEnter2D ?? (onCollisionEnter2D = new Subject<Collision2D>());
        }

        Subject<Collision2D> onCollisionExit2D;

        /// <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
         void OnCollisionExit2D(Collision2D coll)
        {
            if (onCollisionExit2D != null) onCollisionExit2D.OnNext(coll);
        }

        /// <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        public Observable<Collision2D> OnCollisionExit2DAsObservable()
        {
            return onCollisionExit2D ?? (onCollisionExit2D = new Subject<Collision2D>());
        }

        Subject<Collision2D> onCollisionStay2D;

        /// <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
         void OnCollisionStay2D(Collision2D coll)
        {
            if (onCollisionStay2D != null) onCollisionStay2D.OnNext(coll);
        }

        /// <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        public Observable<Collision2D> OnCollisionStay2DAsObservable()
        {
            return onCollisionStay2D ?? (onCollisionStay2D = new Subject<Collision2D>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onCollisionEnter2D != null)
            {
                onCollisionEnter2D.OnCompleted();
            }
            if (onCollisionExit2D != null)
            {
                onCollisionExit2D.OnCompleted();
            }
            if (onCollisionStay2D != null)
            {
                onCollisionStay2D.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCollision2DTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: f76e4ba761142284794dfadc21507388
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCollisionTrigger.cs
================================================
﻿#if R3_PHYSICS_SUPPORT
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableCollisionTrigger : ObservableTriggerBase
    {
        Subject<Collision> onCollisionEnter;

        /// <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
         void OnCollisionEnter(Collision collision)
        {
            if (onCollisionEnter != null) onCollisionEnter.OnNext(collision);
        }

        /// <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        public Observable<Collision> OnCollisionEnterAsObservable()
        {
            return onCollisionEnter ?? (onCollisionEnter = new Subject<Collision>());
        }

        Subject<Collision> onCollisionExit;

        /// <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
         void OnCollisionExit(Collision collisionInfo)
        {
            if (onCollisionExit != null) onCollisionExit.OnNext(collisionInfo);
        }

        /// <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        public Observable<Collision> OnCollisionExitAsObservable()
        {
            return onCollisionExit ?? (onCollisionExit = new Subject<Collision>());
        }

        Subject<Collision> onCollisionStay;

        /// <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
         void OnCollisionStay(Collision collisionInfo)
        {
            if (onCollisionStay != null) onCollisionStay.OnNext(collisionInfo);
        }

        /// <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        public Observable<Collision> OnCollisionStayAsObservable()
        {
            return onCollisionStay ?? (onCollisionStay = new Subject<Collision>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onCollisionEnter != null)
            {
                onCollisionEnter.OnCompleted();
            }
            if (onCollisionExit != null)
            {
                onCollisionExit.OnCompleted();
            }
            if (onCollisionStay != null)
            {
                onCollisionStay.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableCollisionTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 54409f3471be0f04882f19ee62dc7d62
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDeselectTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT

using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableDeselectTrigger : ObservableTriggerBase, IEventSystemHandler, IDeselectHandler
    {
        Subject<BaseEventData> onDeselect;

        void IDeselectHandler.OnDeselect(BaseEventData eventData)
        {
            if (onDeselect != null) onDeselect.OnNext(eventData);
        }

        public Observable<BaseEventData> OnDeselectAsObservable()
        {
            return onDeselect ?? (onDeselect = new Subject<BaseEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onDeselect != null)
            {
                onDeselect.OnCompleted();
            }
        }
    }
}

#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDeselectTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 4a8c94a0b474ee9448bba2108b330bf2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDestroyTrigger.cs
================================================
﻿using System;
using System.Threading;
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableDestroyTrigger : MonoBehaviour, IFrameRunnerWorkItem
    {
        bool calledDestroy = false;
        Subject<Unit> onDestroy;
        CancellationTokenSource cancellationTokenSource;
        DisposableBag disposableBag;

        bool isMonitoring;

        public bool IsActivated { get; private set; }

        public CancellationToken GetCancellationToken()
        {
            if (cancellationTokenSource == null)
            {
                cancellationTokenSource = new CancellationTokenSource();
                if (calledDestroy)
                {
                    cancellationTokenSource.Cancel();
                }
            }

            return cancellationTokenSource.Token;
        }

        public void AddDisposableOnDestroy(IDisposable disposable)
        {
            if (calledDestroy)
            {
                disposable.Dispose();
                return;
            }

            disposableBag.Add(disposable);
        }

        void Awake()
        {
            IsActivated = true;
        }

        /// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        void OnDestroy()
        {
            if (!calledDestroy)
            {
                calledDestroy = true;
                if (cancellationTokenSource != null) cancellationTokenSource.Cancel();
                disposableBag.Dispose();
                if (onDestroy != null) { onDestroy.OnNext(Unit.Default); onDestroy.OnCompleted(); }
            }
        }

        /// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        public Observable<Unit> OnDestroyAsObservable()
        {
            if (this == null) return Observable.Return(Unit.Default);
            if (calledDestroy) return Observable.Return(Unit.Default);
            return onDestroy ?? (onDestroy = new Subject<Unit>());
        }

        internal void TryStartActivateMonitoring()
        {
            if (isMonitoring) return;
            isMonitoring = true;
            UnityFrameProvider.Update.Register(this);
        }

        bool IFrameRunnerWorkItem.MoveNext(long frameCount)
        {
            if (IsActivated) return false;

            if (this == null)
            {
                OnDestroy(); // call on destroy manually
                return false;
            }

            // keep monitoring
            return true;
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDestroyTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 49e9c678e8ad14d4094fc444a5148949
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDragTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT

using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableDragTrigger : ObservableTriggerBase, IEventSystemHandler, IDragHandler
    {
        Subject<PointerEventData> onDrag;

        void IDragHandler.OnDrag(PointerEventData eventData)
        {
            if (onDrag != null) onDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnDragAsObservable()
        {
            return onDrag ?? (onDrag = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onDrag != null)
            {
                onDrag.OnCompleted();
            }
        }
    }
}

#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDragTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 69162816271ebc84e8c0bc4f61960014
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDropTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableDropTrigger : ObservableTriggerBase, IEventSystemHandler, IDropHandler
    {
        Subject<PointerEventData> onDrop;

        void IDropHandler.OnDrop(PointerEventData eventData)
        {
            if (onDrop != null) onDrop.OnNext(eventData);
        }

        public Observable<PointerEventData> OnDropAsObservable()
        {
            return onDrop ?? (onDrop = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onDrop != null)
            {
                onDrop.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableDropTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 175863aed172cdf47a35bdce36b9f67b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEnableTrigger.cs
================================================
﻿
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableEnableTrigger : ObservableTriggerBase
    {
        Subject<Unit> onEnable;

        /// <summary>This function is called when the object becomes enabled and active.</summary>
        void OnEnable()
        {
            if (onEnable != null) onEnable.OnNext(Unit.Default);
        }

        /// <summary>This function is called when the object becomes enabled and active.</summary>
        public Observable<Unit> OnEnableAsObservable()
        {
            return onEnable ?? (onEnable = new Subject<Unit>());
        }

        Subject<Unit> onDisable;

        /// <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        void OnDisable()
        {
            if (onDisable != null) onDisable.OnNext(Unit.Default);
        }

        /// <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        public Observable<Unit> OnDisableAsObservable()
        {
            return onDisable ?? (onDisable = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onEnable != null)
            {
                onEnable.OnCompleted();
            }
            if (onDisable != null)
            {
                onDisable.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEnableTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 189db14a1f1ffb342ae2727ca6ee2967
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEndDragTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableEndDragTrigger : ObservableTriggerBase, IEventSystemHandler, IEndDragHandler
    {
        Subject<PointerEventData> onEndDrag;

        void IEndDragHandler.OnEndDrag(PointerEventData eventData)
        {
            if (onEndDrag != null) onEndDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnEndDragAsObservable()
        {
            return onEndDrag ?? (onEndDrag = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onEndDrag != null)
            {
                onEndDrag.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEndDragTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: b8406da5e64ec9846a5c5f10a671fede
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEventTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableEventTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler
    {
        #region IDeselectHandler

        Subject<BaseEventData> onDeselect;

        void IDeselectHandler.OnDeselect(BaseEventData eventData)
        {
            if (onDeselect != null) onDeselect.OnNext(eventData);
        }

        public Observable<BaseEventData> OnDeselectAsObservable()
        {
            return onDeselect ?? (onDeselect = new Subject<BaseEventData>());
        }

        #endregion

        #region IMoveHandler

        Subject<AxisEventData> onMove;

        void IMoveHandler.OnMove(AxisEventData eventData)
        {
            if (onMove != null) onMove.OnNext(eventData);
        }

        public Observable<AxisEventData> OnMoveAsObservable()
        {
            return onMove ?? (onMove = new Subject<AxisEventData>());
        }

        #endregion

        #region IPointerDownHandler

        Subject<PointerEventData> onPointerDown;

        void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
        {
            if (onPointerDown != null) onPointerDown.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerDownAsObservable()
        {
            return onPointerDown ?? (onPointerDown = new Subject<PointerEventData>());
        }

        #endregion

        #region IPointerEnterHandler

        Subject<PointerEventData> onPointerEnter;

        void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
        {
            if (onPointerEnter != null) onPointerEnter.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerEnterAsObservable()
        {
            return onPointerEnter ?? (onPointerEnter = new Subject<PointerEventData>());
        }

        #endregion

        #region IPointerExitHandler

        Subject<PointerEventData> onPointerExit;

        void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
        {
            if (onPointerExit != null) onPointerExit.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerExitAsObservable()
        {
            return onPointerExit ?? (onPointerExit = new Subject<PointerEventData>());
        }

        #endregion

        #region IPointerUpHandler

        Subject<PointerEventData> onPointerUp;

        void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
        {
            if (onPointerUp != null) onPointerUp.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerUpAsObservable()
        {
            return onPointerUp ?? (onPointerUp = new Subject<PointerEventData>());
        }

        #endregion

        #region ISelectHandler

        Subject<BaseEventData> onSelect;

        void ISelectHandler.OnSelect(BaseEventData eventData)
        {
            if (onSelect != null) onSelect.OnNext(eventData);
        }

        public Observable<BaseEventData> OnSelectAsObservable()
        {
            return onSelect ?? (onSelect = new Subject<BaseEventData>());
        }

        #endregion

        #region IPointerClickHandler

        Subject<PointerEventData> onPointerClick;

        void IPointerClickHandler.OnPointerClick(PointerEventData eventData)
        {
            if (onPointerClick != null) onPointerClick.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerClickAsObservable()
        {
            return onPointerClick ?? (onPointerClick = new Subject<PointerEventData>());
        }

        #endregion

        #region ISubmitHandler

        Subject<BaseEventData> onSubmit;

        void ISubmitHandler.OnSubmit(BaseEventData eventData)
        {
            if (onSubmit != null) onSubmit.OnNext(eventData);
        }

        public Observable<BaseEventData> OnSubmitAsObservable()
        {
            return onSubmit ?? (onSubmit = new Subject<BaseEventData>());
        }

        #endregion

        #region IDragHandler

        Subject<PointerEventData> onDrag;

        void IDragHandler.OnDrag(PointerEventData eventData)
        {
            if (onDrag != null) onDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnDragAsObservable()
        {
            return onDrag ?? (onDrag = new Subject<PointerEventData>());
        }

        #endregion

        #region IBeginDragHandler

        Subject<PointerEventData> onBeginDrag;

        void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
        {
            if (onBeginDrag != null) onBeginDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnBeginDragAsObservable()
        {
            return onBeginDrag ?? (onBeginDrag = new Subject<PointerEventData>());
        }

        #endregion

        #region IEndDragHandler

        Subject<PointerEventData> onEndDrag;

        void IEndDragHandler.OnEndDrag(PointerEventData eventData)
        {
            if (onEndDrag != null) onEndDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnEndDragAsObservable()
        {
            return onEndDrag ?? (onEndDrag = new Subject<PointerEventData>());
        }

        #endregion

        #region IDropHandler

        Subject<PointerEventData> onDrop;

        void IDropHandler.OnDrop(PointerEventData eventData)
        {
            if (onDrop != null) onDrop.OnNext(eventData);
        }

        public Observable<PointerEventData> OnDropAsObservable()
        {
            return onDrop ?? (onDrop = new Subject<PointerEventData>());
        }

        #endregion

        #region IUpdateSelectedHandler

        Subject<BaseEventData> onUpdateSelected;

        void IUpdateSelectedHandler.OnUpdateSelected(BaseEventData eventData)
        {
            if (onUpdateSelected != null) onUpdateSelected.OnNext(eventData);
        }

        public Observable<BaseEventData> OnUpdateSelectedAsObservable()
        {
            return onUpdateSelected ?? (onUpdateSelected = new Subject<BaseEventData>());
        }

        #endregion

        #region IInitializePotentialDragHandler

        Subject<PointerEventData> onInitializePotentialDrag;

        void IInitializePotentialDragHandler.OnInitializePotentialDrag(PointerEventData eventData)
        {
            if (onInitializePotentialDrag != null) onInitializePotentialDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnInitializePotentialDragAsObservable()
        {
            return onInitializePotentialDrag ?? (onInitializePotentialDrag = new Subject<PointerEventData>());
        }

        #endregion

        #region ICancelHandler

        Subject<BaseEventData> onCancel;

        void ICancelHandler.OnCancel(BaseEventData eventData)
        {
            if (onCancel != null) onCancel.OnNext(eventData);
        }

        public Observable<BaseEventData> OnCancelAsObservable()
        {
            return onCancel ?? (onCancel = new Subject<BaseEventData>());
        }

        #endregion

        #region IScrollHandler

        Subject<PointerEventData> onScroll;

        void IScrollHandler.OnScroll(PointerEventData eventData)
        {
            if (onScroll != null) onScroll.OnNext(eventData);
        }

        public Observable<PointerEventData> OnScrollAsObservable()
        {
            return onScroll ?? (onScroll = new Subject<PointerEventData>());
        }

        #endregion

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onDeselect != null)
            {
                onDeselect.OnCompleted();
            }
            if (onMove != null)
            {
                onMove.OnCompleted();
            }
            if (onPointerDown != null)
            {
                onPointerDown.OnCompleted();
            }
            if (onPointerEnter != null)
            {
                onPointerEnter.OnCompleted();
            }
            if (onPointerExit != null)
            {
                onPointerExit.OnCompleted();
            }
            if (onPointerUp != null)
            {
                onPointerUp.OnCompleted();
            }
            if (onSelect != null)
            {
                onSelect.OnCompleted();
            }
            if (onPointerClick != null)
            {
                onPointerClick.OnCompleted();
            }
            if (onSubmit != null)
            {
                onSubmit.OnCompleted();
            }
            if (onDrag != null)
            {
                onDrag.OnCompleted();
            }
            if (onBeginDrag != null)
            {
                onBeginDrag.OnCompleted();
            }
            if (onEndDrag != null)
            {
                onEndDrag.OnCompleted();
            }
            if (onDrop != null)
            {
                onDrop.OnCompleted();
            }
            if (onUpdateSelected != null)
            {
                onUpdateSelected.OnCompleted();
            }
            if (onInitializePotentialDrag != null)
            {
                onInitializePotentialDrag.OnCompleted();
            }
            if (onCancel != null)
            {
                onCancel.OnCompleted();
            }
            if (onScroll != null)
            {
                onScroll.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableEventTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: fd253e17d14ec9346b4e8ec0b1ecf277
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableFixedUpdateTrigger.cs
================================================
﻿
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableFixedUpdateTrigger : ObservableTriggerBase
    {
        Subject<Unit> fixedUpdate;

        /// <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        void FixedUpdate()
        {
            if (fixedUpdate != null) fixedUpdate.OnNext(Unit.Default);
        }

        /// <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        public Observable<Unit> FixedUpdateAsObservable()
        {
            return fixedUpdate ?? (fixedUpdate = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (fixedUpdate != null)
            {
                fixedUpdate.OnCompleted();
            }
        }
    }
}


================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableFixedUpdateTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 6f715a0b3418541449c2f3656418724d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableInitializePotentialDragTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableInitializePotentialDragTrigger : ObservableTriggerBase, IEventSystemHandler, IInitializePotentialDragHandler
    {
        Subject<PointerEventData> onInitializePotentialDrag;

        void IInitializePotentialDragHandler.OnInitializePotentialDrag(PointerEventData eventData)
        {
            if (onInitializePotentialDrag != null) onInitializePotentialDrag.OnNext(eventData);
        }

        public Observable<PointerEventData> OnInitializePotentialDragAsObservable()
        {
            return onInitializePotentialDrag ?? (onInitializePotentialDrag = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onInitializePotentialDrag != null)
            {
                onInitializePotentialDrag.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableInitializePotentialDragTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 2d647a2133ece484ea93bdfa2c20e5f0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableJointTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableJointTrigger : ObservableTriggerBase
    {
        Subject<float> onJointBreak;

        void OnJointBreak(float breakForce)
        {
            if (onJointBreak != null) onJointBreak.OnNext(breakForce);
        }

        public Observable<float> OnJointBreakAsObservable()
        {
            return onJointBreak ?? (onJointBreak = new Subject<float>());
        }

#if R3_PHYSICS2D_SUPPORT
        
        Subject<Joint2D> onJointBreak2D;

        void OnJointBreak2D(Joint2D brokenJoint)
        {
            if (onJointBreak2D != null) onJointBreak2D.OnNext(brokenJoint);
        }

        public Observable<Joint2D> OnJointBreak2DAsObservable()
        {
            return onJointBreak2D ?? (onJointBreak2D = new Subject<Joint2D>());
        }
#endif

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onJointBreak != null)
            {
                onJointBreak.OnCompleted();
            }
#if R3_PHYSICS2D_SUPPORT
            if (onJointBreak2D != null)
            {
                onJointBreak2D.OnCompleted();
            }
#endif
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableJointTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: a5c8ddee7e79db44e9c2b7f08ffd68a1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableLateUpdateTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableLateUpdateTrigger : ObservableTriggerBase
    {
        Subject<Unit> lateUpdate;

        /// <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        void LateUpdate()
        {
            if (lateUpdate != null) lateUpdate.OnNext(Unit.Default);
        }

        /// <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        public Observable<Unit> LateUpdateAsObservable()
        {
            return lateUpdate ?? (lateUpdate = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (lateUpdate != null)
            {
                lateUpdate.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableLateUpdateTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 543cbdc05bce2754a983163c8cb6bce2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableMouseTrigger.cs
================================================
﻿#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_METRO)


using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableMouseTrigger : ObservableTriggerBase
    {
        Subject<Unit> onMouseDown;

        /// <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        void OnMouseDown()
        {
            if (onMouseDown != null) onMouseDown.OnNext(Unit.Default);
        }

        /// <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        public Observable<Unit> OnMouseDownAsObservable()
        {
            return onMouseDown ?? (onMouseDown = new Subject<Unit>());
        }

        Subject<Unit> onMouseDrag;

        /// <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        void OnMouseDrag()
        {
            if (onMouseDrag != null) onMouseDrag.OnNext(Unit.Default);
        }

        /// <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        public Observable<Unit> OnMouseDragAsObservable()
        {
            return onMouseDrag ?? (onMouseDrag = new Subject<Unit>());
        }

        Subject<Unit> onMouseEnter;

        /// <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        void OnMouseEnter()
        {
            if (onMouseEnter != null) onMouseEnter.OnNext(Unit.Default);
        }

        /// <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        public Observable<Unit> OnMouseEnterAsObservable()
        {
            return onMouseEnter ?? (onMouseEnter = new Subject<Unit>());
        }

        Subject<Unit> onMouseExit;

        /// <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        void OnMouseExit()
        {
            if (onMouseExit != null) onMouseExit.OnNext(Unit.Default);
        }

        /// <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        public Observable<Unit> OnMouseExitAsObservable()
        {
            return onMouseExit ?? (onMouseExit = new Subject<Unit>());
        }

        Subject<Unit> onMouseOver;

        /// <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        void OnMouseOver()
        {
            if (onMouseOver != null) onMouseOver.OnNext(Unit.Default);
        }

        /// <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        public Observable<Unit> OnMouseOverAsObservable()
        {
            return onMouseOver ?? (onMouseOver = new Subject<Unit>());
        }

        Subject<Unit> onMouseUp;

        /// <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        void OnMouseUp()
        {
            if (onMouseUp != null) onMouseUp.OnNext(Unit.Default);
        }

        /// <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        public Observable<Unit> OnMouseUpAsObservable()
        {
            return onMouseUp ?? (onMouseUp = new Subject<Unit>());
        }

        Subject<Unit> onMouseUpAsButton;

        /// <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        void OnMouseUpAsButton()
        {
            if (onMouseUpAsButton != null) onMouseUpAsButton.OnNext(Unit.Default);
        }

        /// <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        public Observable<Unit> OnMouseUpAsButtonAsObservable()
        {
            return onMouseUpAsButton ?? (onMouseUpAsButton = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onMouseDown != null)
            {
                onMouseDown.OnCompleted();
            }
            if (onMouseDrag != null)
            {
                onMouseDrag.OnCompleted();
            }
            if (onMouseEnter != null)
            {
                onMouseEnter.OnCompleted();
            }
            if (onMouseExit != null)
            {
                onMouseExit.OnCompleted();
            }
            if (onMouseOver != null)
            {
                onMouseOver.OnCompleted();
            }
            if (onMouseUp != null)
            {
                onMouseUp.OnCompleted();
            }
            if (onMouseUpAsButton != null)
            {
                onMouseUpAsButton.OnCompleted();
            }
        }
    }
}

#endif


================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableMouseTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 23ce65ebeb2510a4c8915bfe9a04fe6a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableMoveTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableMoveTrigger : ObservableTriggerBase, IEventSystemHandler, IMoveHandler
    {
        Subject<AxisEventData> onMove;

        void IMoveHandler.OnMove(AxisEventData eventData)
        {
            if (onMove != null) onMove.OnNext(eventData);
        }

        public Observable<AxisEventData> OnMoveAsObservable()
        {
            return onMove ?? (onMove = new Subject<AxisEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onMove != null)
            {
                onMove.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableMoveTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 193e7dc691485664eaf8e7ba5db62e85
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableParticleTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableParticleTrigger : ObservableTriggerBase
    {
        Subject<GameObject> onParticleCollision;
        Subject<Unit> onParticleTrigger;

        /// <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        void OnParticleCollision(GameObject other)
        {
            if (onParticleCollision != null) onParticleCollision.OnNext(other);
        }

        /// <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        public Observable<GameObject> OnParticleCollisionAsObservable()
        {
            return onParticleCollision ?? (onParticleCollision = new Subject<GameObject>());
        }

        /// <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        void OnParticleTrigger()
        {
            if (onParticleTrigger != null) onParticleTrigger.OnNext(Unit.Default);
        }

        /// <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        public Observable<Unit> OnParticleTriggerAsObservable()
        {
            return onParticleTrigger ?? (onParticleTrigger = new Subject<Unit>());
        }


        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onParticleCollision != null)
            {
                onParticleCollision.OnCompleted();
            }
            if (onParticleTrigger != null)
            {
                onParticleTrigger.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableParticleTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: ec0da8d9461ed534eb4eb0f6682eeb95
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerClickTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservablePointerClickTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerClickHandler
    {
        Subject<PointerEventData> onPointerClick;

        void IPointerClickHandler.OnPointerClick(PointerEventData eventData)
        {
            if (onPointerClick != null) onPointerClick.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerClickAsObservable()
        {
            return onPointerClick ?? (onPointerClick = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onPointerClick != null)
            {
                onPointerClick.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerClickTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 4f029a96607ef284f9106063137864a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerDownTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservablePointerDownTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerDownHandler
    {
        Subject<PointerEventData> onPointerDown;

        void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
        {
            if (onPointerDown != null) onPointerDown.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerDownAsObservable()
        {
            return onPointerDown ?? (onPointerDown = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onPointerDown != null)
            {
                onPointerDown.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerDownTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: f14ff3c2d53ce3642888a1bd7458019e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerEnterTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservablePointerEnterTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerEnterHandler
    {
        Subject<PointerEventData> onPointerEnter;

        void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
        {
            if (onPointerEnter != null) onPointerEnter.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerEnterAsObservable()
        {
            return onPointerEnter ?? (onPointerEnter = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onPointerEnter != null)
            {
                onPointerEnter.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerEnterTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: a8db2cc52408f6d479081d183d573307
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerExitTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservablePointerExitTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerExitHandler
    {
        Subject<PointerEventData> onPointerExit;

        void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
        {
            if (onPointerExit != null) onPointerExit.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerExitAsObservable()
        {
            return onPointerExit ?? (onPointerExit = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onPointerExit != null)
            {
                onPointerExit.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerExitTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 116eb1539f4db5d418ddbe24579b9900
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerUpTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservablePointerUpTrigger : ObservableTriggerBase, IEventSystemHandler, IPointerUpHandler
    {
        Subject<PointerEventData> onPointerUp;

        void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
        {
            if (onPointerUp != null) onPointerUp.OnNext(eventData);
        }

        public Observable<PointerEventData> OnPointerUpAsObservable()
        {
            return onPointerUp ?? (onPointerUp = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onPointerUp != null)
            {
                onPointerUp.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservablePointerUpTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 61f4d59301482a0478779f375c014109
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableRectTransformTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableRectTransformTrigger : ObservableTriggerBase
    {
        Subject<Unit> onRectTransformDimensionsChange;

        // Callback that is sent if an associated RectTransform has it's dimensions changed
        void OnRectTransformDimensionsChange()
        {
            if (onRectTransformDimensionsChange != null) onRectTransformDimensionsChange.OnNext(Unit.Default);
        }

        /// <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        public Observable<Unit> OnRectTransformDimensionsChangeAsObservable()
        {
            return onRectTransformDimensionsChange ?? (onRectTransformDimensionsChange = new Subject<Unit>());
        }

        Subject<Unit> onRectTransformRemoved;

        // Callback that is sent if an associated RectTransform is removed
        void OnRectTransformRemoved()
        {
            if (onRectTransformRemoved != null) onRectTransformRemoved.OnNext(Unit.Default);
        }

        /// <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        public Observable<Unit> OnRectTransformRemovedAsObservable()
        {
            return onRectTransformRemoved ?? (onRectTransformRemoved = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onRectTransformDimensionsChange != null)
            {
                onRectTransformDimensionsChange.OnCompleted();
            }
            if (onRectTransformRemoved != null)
            {
                onRectTransformRemoved.OnCompleted();
            }
        }

    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableRectTransformTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 3a5cd2cfdc3721d488903ad5923aec65
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableScrollTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableScrollTrigger : ObservableTriggerBase, IEventSystemHandler, IScrollHandler
    {
        Subject<PointerEventData> onScroll;

        void IScrollHandler.OnScroll(PointerEventData eventData)
        {
            if (onScroll != null) onScroll.OnNext(eventData);
        }

        public Observable<PointerEventData> OnScrollAsObservable()
        {
            return onScroll ?? (onScroll = new Subject<PointerEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onScroll != null)
            {
                onScroll.OnCompleted();
            }
        }
    }
}

#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableScrollTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 58733523a0a576648890120abbb88fb6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableSelectTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableSelectTrigger : ObservableTriggerBase, IEventSystemHandler, ISelectHandler
    {
        Subject<BaseEventData> onSelect;

        void ISelectHandler.OnSelect(BaseEventData eventData)
        {
            if (onSelect != null) onSelect.OnNext(eventData);
        }

        public Observable<BaseEventData> OnSelectAsObservable()
        {
            return onSelect ?? (onSelect = new Subject<BaseEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onSelect != null)
            {
                onSelect.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableSelectTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: c02572138f7328e43b9a3acbf76ba1fa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableStateMachineTrigger.cs
================================================
#if R3_ANIMATION_SUPPORT
using UnityEngine;

namespace R3.Triggers
{
    public class ObservableStateMachineTrigger : StateMachineBehaviour
    {
        public class OnStateInfo
        {
            public Animator Animator { get; private set; }
            public AnimatorStateInfo StateInfo { get; private set; }
            public int LayerIndex { get; private set; }

            public OnStateInfo(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
            {
                Animator = animator;
                StateInfo = stateInfo;
                LayerIndex = layerIndex;
            }
        }

        public class OnStateMachineInfo
        {
            public Animator Animator { get; private set; }
            public int StateMachinePathHash { get; private set; }

            public OnStateMachineInfo(Animator animator, int stateMachinePathHash)
            {
                Animator = animator;
                StateMachinePathHash = stateMachinePathHash;
            }
        }

        // OnStateExit
        Subject<OnStateInfo> onStateExit;

        public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            onStateExit?.OnNext(new OnStateInfo(animator, stateInfo, layerIndex));
        }

        public Observable<OnStateInfo> OnStateExitAsObservable()
        {
            return onStateExit ??= new Subject<OnStateInfo>();
        }

        // OnStateEnter
        Subject<OnStateInfo> onStateEnter;

        public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            onStateEnter?.OnNext(new OnStateInfo(animator, stateInfo, layerIndex));
        }

        public Observable<OnStateInfo> OnStateEnterAsObservable()
        {
            return onStateEnter ??= new Subject<OnStateInfo>();
        }

        // OnStateIK
        Subject<OnStateInfo> onStateIK;

        public override void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            if(onStateIK !=null) onStateIK.OnNext(new OnStateInfo(animator, stateInfo, layerIndex));
        }

        public Observable<OnStateInfo> OnStateIKAsObservable()
        {
            return onStateIK ??= new Subject<OnStateInfo>();
        }

        // OnStateUpdate
        Subject<OnStateInfo> onStateUpdate;

        public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
        {
            onStateUpdate?.OnNext(new OnStateInfo(animator, stateInfo, layerIndex));
        }

        public Observable<OnStateInfo> OnStateUpdateAsObservable()
        {
            return onStateUpdate ??= new Subject<OnStateInfo>();
        }

        // OnStateMachineEnter
        Subject<OnStateMachineInfo> onStateMachineEnter;

        public override void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
        {
            onStateMachineEnter?.OnNext(new OnStateMachineInfo(animator, stateMachinePathHash));
        }

        public Observable<OnStateMachineInfo> OnStateMachineEnterAsObservable()
        {
            return onStateMachineEnter ??= new Subject<OnStateMachineInfo>();
        }

        // OnStateMachineExit
        Subject<OnStateMachineInfo> onStateMachineExit;

        public override void OnStateMachineExit(Animator animator, int stateMachinePathHash)
        {
            onStateMachineExit?.OnNext(new OnStateMachineInfo(animator, stateMachinePathHash));
        }

        public Observable<OnStateMachineInfo> OnStateMachineExitAsObservable()
        {
            return onStateMachineExit ??= new Subject<OnStateMachineInfo>();
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableStateMachineTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: b6f6416fc103718499c3a5dae141b4c1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableSubmitTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableSubmitTrigger : ObservableTriggerBase, IEventSystemHandler, ISubmitHandler
    {
        Subject<BaseEventData> onSubmit;

        void ISubmitHandler.OnSubmit(BaseEventData eventData)
        {
            if (onSubmit != null) onSubmit.OnNext(eventData);
        }

        public Observable<BaseEventData> OnSubmitAsObservable()
        {
            return onSubmit ?? (onSubmit = new Subject<BaseEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onSubmit != null)
            {
                onSubmit.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableSubmitTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 3cc4ba804a9a2da46923df54e791963e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTransformChangedTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableTransformChangedTrigger : ObservableTriggerBase
    {
        Subject<Unit> onBeforeTransformParentChanged;

        // Callback sent to the graphic before a Transform parent change occurs
        void OnBeforeTransformParentChanged()
        {
            if (onBeforeTransformParentChanged != null) onBeforeTransformParentChanged.OnNext(Unit.Default);
        }

        /// <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        public Observable<Unit> OnBeforeTransformParentChangedAsObservable()
        {
            return onBeforeTransformParentChanged ?? (onBeforeTransformParentChanged = new Subject<Unit>());
        }

        Subject<Unit> onTransformParentChanged;

        // This function is called when the parent property of the transform of the GameObject has changed
        void OnTransformParentChanged()
        {
            if (onTransformParentChanged != null) onTransformParentChanged.OnNext(Unit.Default);
        }

        /// <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        public Observable<Unit> OnTransformParentChangedAsObservable()
        {
            return onTransformParentChanged ?? (onTransformParentChanged = new Subject<Unit>());
        }

        Subject<Unit> onTransformChildrenChanged;

        // This function is called when the list of children of the transform of the GameObject has changed
        void OnTransformChildrenChanged()
        {
            if (onTransformChildrenChanged != null) onTransformChildrenChanged.OnNext(Unit.Default);
        }

        /// <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        public Observable<Unit> OnTransformChildrenChangedAsObservable()
        {
            return onTransformChildrenChanged ?? (onTransformChildrenChanged = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onBeforeTransformParentChanged != null)
            {
                onBeforeTransformParentChanged.OnCompleted();
            }
            if (onTransformParentChanged != null)
            {
                onTransformParentChanged.OnCompleted();
            }
            if (onTransformChildrenChanged != null)
            {
                onTransformChildrenChanged.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTransformChangedTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 2fae811c386e49a498fd5adcec0782ff
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTrigger2DTrigger.cs
================================================
﻿#if R3_PHYSICS2D_SUPPORT
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableTrigger2DTrigger : ObservableTriggerBase
    {
        Subject<Collider2D> onTriggerEnter2D;

        /// <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        void OnTriggerEnter2D(Collider2D other)
        {
            if (onTriggerEnter2D != null) onTriggerEnter2D.OnNext(other);
        }

        /// <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        public Observable<Collider2D> OnTriggerEnter2DAsObservable()
        {
            return onTriggerEnter2D ?? (onTriggerEnter2D = new Subject<Collider2D>());
        }

        Subject<Collider2D> onTriggerExit2D;

        /// <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        void OnTriggerExit2D(Collider2D other)
        {
            if (onTriggerExit2D != null) onTriggerExit2D.OnNext(other);
        }

        /// <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        public Observable<Collider2D> OnTriggerExit2DAsObservable()
        {
            return onTriggerExit2D ?? (onTriggerExit2D = new Subject<Collider2D>());
        }

        Subject<Collider2D> onTriggerStay2D;

        /// <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        void OnTriggerStay2D(Collider2D other)
        {
            if (onTriggerStay2D != null) onTriggerStay2D.OnNext(other);
        }

        /// <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        public Observable<Collider2D> OnTriggerStay2DAsObservable()
        {
            return onTriggerStay2D ?? (onTriggerStay2D = new Subject<Collider2D>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onTriggerEnter2D != null)
            {
                onTriggerEnter2D.OnCompleted();
            }
            if (onTriggerExit2D != null)
            {
                onTriggerExit2D.OnCompleted();
            }
            if (onTriggerStay2D != null)
            {
                onTriggerStay2D.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTrigger2DTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 07c75deb315dfb144954da7e85ab9ac8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerBase.cs
================================================
﻿
using UnityEngine;

namespace R3.Triggers
{
    public abstract class ObservableTriggerBase : MonoBehaviour
    {
        //bool calledAwake = false;
        //Subject<Unit> awake;

        ///// <summary>Awake is called when the script instance is being loaded.</summary>
        //void Awake()
        //{
        //    calledAwake = true;
        //    if (awake != null) { awake.OnNext(Unit.Default); awake.OnCompleted(); }
        //}

        ///// <summary>Awake is called when the script instance is being loaded.</summary>
        //public Observable<Unit> AwakeAsObservable()
        //{
        //    if (calledAwake) return Observable.Return(Unit.Default);
        //    return awake ?? (awake = new Subject<Unit>());
        //}

        //bool calledStart = false;
        //Subject<Unit> start;

        ///// <summary>Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.</summary>
        //void Start()
        //{
        //    calledStart = true;
        //    if (start != null) { start.OnNext(Unit.Default); start.OnCompleted(); }
        //}

        ///// <summary>Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.</summary>
        //public Observable<Unit> StartAsObservable()
        //{
        //    if (calledStart) return Observable.Return(Unit.Default);
        //    return start ?? (start = new Subject<Unit>());
        //}


        bool calledDestroy = false;

        /// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        void OnDestroy()
        {
            if (!calledDestroy)
            {
                calledDestroy = true;
                RaiseOnCompletedOnDestroy();
            }
        }

        ///// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        //public Observable<Unit> OnDestroyAsObservable()
        //{
        //    if (this == null) return Observable.Return(Unit.Default);
        //    if (calledDestroy) return Observable.Return(Unit.Default);
        //    return onDestroy ?? (onDestroy = new Subject<Unit>());
        //}

        protected abstract void RaiseOnCompletedOnDestroy();
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerBase.cs.meta
================================================
fileFormatVersion: 2
guid: a20b70ad048eedc438cdc22db5940016
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerExtensions.Component.cs
================================================
﻿
using UnityEngine;

#if R3_UGUI_SUPPORT
using UnityEngine.EventSystems;
#endif

namespace R3.Triggers
{
    // for Component
    public static partial class ObservableTriggerExtensions
    {
        #region ObservableAnimatorTrigger

        /// <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        public static Observable<int> OnAnimatorIKAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<int>();
            return GetOrAddComponent<ObservableAnimatorTrigger>(component.gameObject).OnAnimatorIKAsObservable();
        }

        /// <summary>Callback for processing animation movements for modifying root motion.</summary>
        public static Observable<Unit> OnAnimatorMoveAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableAnimatorTrigger>(component.gameObject).OnAnimatorMoveAsObservable();
        }

        #endregion

#region ObservableCollision2DTrigger
#if R3_PHYSICS2D_SUPPORT
        /// <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionEnter2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(component.gameObject).OnCollisionEnter2DAsObservable();
        }


        /// <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionExit2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(component.gameObject).OnCollisionExit2DAsObservable();
        }

        /// <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionStay2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(component.gameObject).OnCollisionStay2DAsObservable();
        }
#endif
#endregion

#region ObservableCollisionTrigger
#if R3_PHYSICS_SUPPORT

        /// <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionEnterAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(component.gameObject).OnCollisionEnterAsObservable();
        }


        /// <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionExitAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(component.gameObject).OnCollisionExitAsObservable();
        }

        /// <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionStayAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(component.gameObject).OnCollisionStayAsObservable();
        }
#endif
#endregion

        #region ObservableDestroyTrigger

        /// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        public static Observable<Unit> OnDestroyAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Return(Unit.Default); // send destroy message
            return GetOrAddComponent<ObservableDestroyTrigger>(component.gameObject).OnDestroyAsObservable();
        }

        #endregion


        #region ObservableEnableTrigger

        /// <summary>This function is called when the object becomes enabled and active.</summary>
        public static Observable<Unit> OnEnableAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableEnableTrigger>(component.gameObject).OnEnableAsObservable();
        }

        /// <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        public static Observable<Unit> OnDisableAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableEnableTrigger>(component.gameObject).OnDisableAsObservable();
        }

        #endregion

        #region ObservableFixedUpdateTrigger

        /// <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        public static Observable<Unit> FixedUpdateAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableFixedUpdateTrigger>(component.gameObject).FixedUpdateAsObservable();
        }

        #endregion

        #region ObservableLateUpdateTrigger

        /// <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        public static Observable<Unit> LateUpdateAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableLateUpdateTrigger>(component.gameObject).LateUpdateAsObservable();
        }

        #endregion

#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_METRO)

        #region ObservableMouseTrigger

        /// <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseDownAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseDownAsObservable();
        }

        /// <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        public static Observable<Unit> OnMouseDragAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseDragAsObservable();
        }

        /// <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseEnterAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseEnterAsObservable();
        }

        /// <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseExitAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseExitAsObservable();
        }

        /// <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseOverAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseOverAsObservable();
        }

        /// <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        public static Observable<Unit> OnMouseUpAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseUpAsObservable();
        }

        /// <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        public static Observable<Unit> OnMouseUpAsButtonAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(component.gameObject).OnMouseUpAsButtonAsObservable();
        }

        #endregion

#endif

#region ObservableTrigger2DTrigger
#if R3_PHYSICS2D_SUPPORT
        /// <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerEnter2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(component.gameObject).OnTriggerEnter2DAsObservable();
        }


        /// <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerExit2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(component.gameObject).OnTriggerExit2DAsObservable();
        }

        /// <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerStay2DAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(component.gameObject).OnTriggerStay2DAsObservable();
        }
#endif
#endregion

#region ObservableTriggerTrigger
#if R3_PHYSICS_SUPPORT

        /// <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        public static Observable<Collider> OnTriggerEnterAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(component.gameObject).OnTriggerEnterAsObservable();
        }


        /// <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        public static Observable<Collider> OnTriggerExitAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(component.gameObject).OnTriggerExitAsObservable();
        }

        /// <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        public static Observable<Collider> OnTriggerStayAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(component.gameObject).OnTriggerStayAsObservable();
        }
#endif
#endregion

        #region ObservableUpdateTrigger

        /// <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        public static Observable<Unit> UpdateAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableUpdateTrigger>(component.gameObject).UpdateAsObservable();
        }

        #endregion

        #region ObservableVisibleTrigger

        /// <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        public static Observable<Unit> OnBecameInvisibleAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableVisibleTrigger>(component.gameObject).OnBecameInvisibleAsObservable();
        }

        /// <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        public static Observable<Unit> OnBecameVisibleAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableVisibleTrigger>(component.gameObject).OnBecameVisibleAsObservable();
        }

        #endregion

        #region ObservableTransformChangedTrigger

        /// <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        public static Observable<Unit> OnBeforeTransformParentChangedAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(component.gameObject).OnBeforeTransformParentChangedAsObservable();
        }

        /// <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        public static Observable<Unit> OnTransformParentChangedAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(component.gameObject).OnTransformParentChangedAsObservable();
        }

        /// <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        public static Observable<Unit> OnTransformChildrenChangedAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(component.gameObject).OnTransformChildrenChangedAsObservable();
        }

        #endregion

        #region ObservableCanvasGroupChangedTrigger

        /// <summary>Callback that is sent if the canvas group is changed.</summary>
        public static Observable<Unit> OnCanvasGroupChangedAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableCanvasGroupChangedTrigger>(component.gameObject).OnCanvasGroupChangedAsObservable();
        }

        #endregion

        #region ObservableRectTransformTrigger

        /// <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        public static Observable<Unit> OnRectTransformDimensionsChangeAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableRectTransformTrigger>(component.gameObject).OnRectTransformDimensionsChangeAsObservable();
        }

        /// <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        public static Observable<Unit> OnRectTransformRemovedAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableRectTransformTrigger>(component.gameObject).OnRectTransformRemovedAsObservable();
        }

        #endregion

        // uGUI

        #region ObservableEventTrigger classes
#if R3_UGUI_SUPPORT
        public static Observable<BaseEventData> OnDeselectAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<BaseEventData>();
            return GetOrAddComponent<ObservableDeselectTrigger>(component.gameObject).OnDeselectAsObservable();
        }

        public static Observable<AxisEventData> OnMoveAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<AxisEventData>();
            return GetOrAddComponent<ObservableMoveTrigger>(component.gameObject).OnMoveAsObservable();
        }

        public static Observable<PointerEventData> OnPointerDownAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservablePointerDownTrigger>(component.gameObject).OnPointerDownAsObservable();
        }

        public static Observable<PointerEventData> OnPointerEnterAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservablePointerEnterTrigger>(component.gameObject).OnPointerEnterAsObservable();
        }

        public static Observable<PointerEventData> OnPointerExitAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservablePointerExitTrigger>(component.gameObject).OnPointerExitAsObservable();
        }

        public static Observable<PointerEventData> OnPointerUpAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservablePointerUpTrigger>(component.gameObject).OnPointerUpAsObservable();
        }

        public static Observable<BaseEventData> OnSelectAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<BaseEventData>();
            return GetOrAddComponent<ObservableSelectTrigger>(component.gameObject).OnSelectAsObservable();
        }

        public static Observable<PointerEventData> OnPointerClickAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservablePointerClickTrigger>(component.gameObject).OnPointerClickAsObservable();
        }

        public static Observable<BaseEventData> OnSubmitAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<BaseEventData>();
            return GetOrAddComponent<ObservableSubmitTrigger>(component.gameObject).OnSubmitAsObservable();
        }

        public static Observable<PointerEventData> OnDragAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableDragTrigger>(component.gameObject).OnDragAsObservable();
        }

        public static Observable<PointerEventData> OnBeginDragAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableBeginDragTrigger>(component.gameObject).OnBeginDragAsObservable();
        }

        public static Observable<PointerEventData> OnEndDragAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableEndDragTrigger>(component.gameObject).OnEndDragAsObservable();
        }

        public static Observable<PointerEventData> OnDropAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableDropTrigger>(component.gameObject).OnDropAsObservable();
        }

        public static Observable<BaseEventData> OnUpdateSelectedAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<BaseEventData>();
            return GetOrAddComponent<ObservableUpdateSelectedTrigger>(component.gameObject).OnUpdateSelectedAsObservable();
        }

        public static Observable<PointerEventData> OnInitializePotentialDragAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableInitializePotentialDragTrigger>(component.gameObject).OnInitializePotentialDragAsObservable();
        }

        public static Observable<BaseEventData> OnCancelAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<BaseEventData>();
            return GetOrAddComponent<ObservableCancelTrigger>(component.gameObject).OnCancelAsObservable();
        }

        public static Observable<PointerEventData> OnScrollAsObservable(this UIBehaviour component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<PointerEventData>();
            return GetOrAddComponent<ObservableScrollTrigger>(component.gameObject).OnScrollAsObservable();
        }
#endif
        #endregion

        #region ObservableParticleTrigger

        /// <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        public static Observable<GameObject> OnParticleCollisionAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<GameObject>();
            return GetOrAddComponent<ObservableParticleTrigger>(component.gameObject).OnParticleCollisionAsObservable();
        }

#if UNITY_5_4_OR_NEWER

        /// <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        public static Observable<Unit> OnParticleTriggerAsObservable(this Component component)
        {
            if (component == null || component.gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableParticleTrigger>(component.gameObject).OnParticleTriggerAsObservable();
        }

#endif

        #endregion
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerExtensions.Component.cs.meta
================================================
fileFormatVersion: 2
guid: 9e550227cbaf90642ab579da06e24e44
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerExtensions.cs
================================================
﻿
using UnityEngine;

namespace R3.Triggers
{
    // for GameObject
    public static partial class ObservableTriggerExtensions
    {
        #region ObservableAnimatorTrigger

        /// <summary>Callback for setting up animation IK (inverse kinematics).</summary>
        public static Observable<int> OnAnimatorIKAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<int>();
            return GetOrAddComponent<ObservableAnimatorTrigger>(gameObject).OnAnimatorIKAsObservable();
        }

        /// <summary>Callback for processing animation movements for modifying root motion.</summary>
        public static Observable<Unit> OnAnimatorMoveAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableAnimatorTrigger>(gameObject).OnAnimatorMoveAsObservable();
        }

        #endregion

        #region ObservableCollision2DTrigger
#if R3_PHYSICS2D_SUPPORT

        /// <summary>Sent when an incoming collider makes contact with this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionEnter2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(gameObject).OnCollisionEnter2DAsObservable();
        }


        /// <summary>Sent when a collider on another object stops touching this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionExit2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(gameObject).OnCollisionExit2DAsObservable();
        }

        /// <summary>Sent each frame where a collider on another object is touching this object's collider (2D physics only).</summary>
        public static Observable<Collision2D> OnCollisionStay2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision2D>();
            return GetOrAddComponent<ObservableCollision2DTrigger>(gameObject).OnCollisionStay2DAsObservable();
        }
#endif
        #endregion

        #region ObservableCollisionTrigger
#if R3_PHYSICS_SUPPORT

        /// <summary>OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionEnterAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(gameObject).OnCollisionEnterAsObservable();
        }


        /// <summary>OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionExitAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(gameObject).OnCollisionExitAsObservable();
        }

        /// <summary>OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.</summary>
        public static Observable<Collision> OnCollisionStayAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collision>();
            return GetOrAddComponent<ObservableCollisionTrigger>(gameObject).OnCollisionStayAsObservable();
        }
#endif
        #endregion

        #region ObservableDestroyTrigger

        /// <summary>This function is called when the MonoBehaviour will be destroyed.</summary>
        public static Observable<Unit> OnDestroyAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Return(Unit.Default); // send destroy message
            return GetOrAddComponent<ObservableDestroyTrigger>(gameObject).OnDestroyAsObservable();
        }

        #endregion

        #region ObservableEnableTrigger

        /// <summary>This function is called when the object becomes enabled and active.</summary>
        public static Observable<Unit> OnEnableAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableEnableTrigger>(gameObject).OnEnableAsObservable();
        }

        /// <summary>This function is called when the behaviour becomes disabled () or inactive.</summary>
        public static Observable<Unit> OnDisableAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableEnableTrigger>(gameObject).OnDisableAsObservable();
        }

        #endregion

        #region ObservableFixedUpdateTrigger

        /// <summary>This function is called every fixed framerate frame, if the MonoBehaviour is enabled.</summary>
        public static Observable<Unit> FixedUpdateAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableFixedUpdateTrigger>(gameObject).FixedUpdateAsObservable();
        }

        #endregion

        #region ObservableLateUpdateTrigger

        /// <summary>LateUpdate is called every frame, if the Behaviour is enabled.</summary>
        public static Observable<Unit> LateUpdateAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableLateUpdateTrigger>(gameObject).LateUpdateAsObservable();
        }

        #endregion

#if !(UNITY_IPHONE || UNITY_ANDROID || UNITY_METRO)

        #region ObservableMouseTrigger

        /// <summary>OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseDownAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseDownAsObservable();
        }

        /// <summary>OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.</summary>
        public static Observable<Unit> OnMouseDragAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseDragAsObservable();
        }

        /// <summary>OnMouseEnter is called when the mouse entered the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseEnterAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseEnterAsObservable();
        }

        /// <summary>OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseExitAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseExitAsObservable();
        }

        /// <summary>OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.</summary>
        public static Observable<Unit> OnMouseOverAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseOverAsObservable();
        }

        /// <summary>OnMouseUp is called when the user has released the mouse button.</summary>
        public static Observable<Unit> OnMouseUpAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseUpAsObservable();
        }

        /// <summary>OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.</summary>
        public static Observable<Unit> OnMouseUpAsButtonAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableMouseTrigger>(gameObject).OnMouseUpAsButtonAsObservable();
        }

        #endregion

#endif

        #region ObservableTrigger2DTrigger
#if R3_PHYSICS2D_SUPPORT

        /// <summary>Sent when another object enters a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerEnter2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(gameObject).OnTriggerEnter2DAsObservable();
        }


        /// <summary>Sent when another object leaves a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerExit2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(gameObject).OnTriggerExit2DAsObservable();
        }

        /// <summary>Sent each frame where another object is within a trigger collider attached to this object (2D physics only).</summary>
        public static Observable<Collider2D> OnTriggerStay2DAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider2D>();
            return GetOrAddComponent<ObservableTrigger2DTrigger>(gameObject).OnTriggerStay2DAsObservable();
        }
#endif
        #endregion

        #region ObservableTriggerTrigger
#if R3_PHYSICS_SUPPORT

        /// <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        public static Observable<Collider> OnTriggerEnterAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(gameObject).OnTriggerEnterAsObservable();
        }


        /// <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        public static Observable<Collider> OnTriggerExitAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(gameObject).OnTriggerExitAsObservable();
        }

        /// <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        public static Observable<Collider> OnTriggerStayAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Collider>();
            return GetOrAddComponent<ObservableTriggerTrigger>(gameObject).OnTriggerStayAsObservable();
        }
#endif
        #endregion

        #region ObservableUpdateTrigger

        /// <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        public static Observable<Unit> UpdateAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableUpdateTrigger>(gameObject).UpdateAsObservable();
        }

        #endregion

        #region ObservableVisibleTrigger

        /// <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        public static Observable<Unit> OnBecameInvisibleAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableVisibleTrigger>(gameObject).OnBecameInvisibleAsObservable();
        }

        /// <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        public static Observable<Unit> OnBecameVisibleAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableVisibleTrigger>(gameObject).OnBecameVisibleAsObservable();
        }

        #endregion

        #region ObservableTransformChangedTrigger

        /// <summary>Callback sent to the graphic before a Transform parent change occurs.</summary>
        public static Observable<Unit> OnBeforeTransformParentChangedAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(gameObject).OnBeforeTransformParentChangedAsObservable();
        }

        /// <summary>This function is called when the parent property of the transform of the GameObject has changed.</summary>
        public static Observable<Unit> OnTransformParentChangedAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(gameObject).OnTransformParentChangedAsObservable();
        }

        /// <summary>This function is called when the list of children of the transform of the GameObject has changed.</summary>
        public static Observable<Unit> OnTransformChildrenChangedAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableTransformChangedTrigger>(gameObject).OnTransformChildrenChangedAsObservable();
        }

        #endregion

        #region ObservableCanvasGroupChangedTrigger

        /// <summary>Callback that is sent if the canvas group is changed.</summary>
        public static Observable<Unit> OnCanvasGroupChangedAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableCanvasGroupChangedTrigger>(gameObject).OnCanvasGroupChangedAsObservable();
        }

        #endregion

        #region ObservableRectTransformTrigger

        /// <summary>Callback that is sent if an associated RectTransform has it's dimensions changed.</summary>
        public static Observable<Unit> OnRectTransformDimensionsChangeAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableRectTransformTrigger>(gameObject).OnRectTransformDimensionsChangeAsObservable();
        }

        /// <summary>Callback that is sent if an associated RectTransform is removed.</summary>
        public static Observable<Unit> OnRectTransformRemovedAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableRectTransformTrigger>(gameObject).OnRectTransformRemovedAsObservable();
        }

        #endregion

        #region ObservableParticleTrigger

        /// <summary>OnParticleCollision is called when a particle hits a collider.</summary>
        public static Observable<GameObject> OnParticleCollisionAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<GameObject>();
            return GetOrAddComponent<ObservableParticleTrigger>(gameObject).OnParticleCollisionAsObservable();
        }

        /// <summary>OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module.</summary>
        public static Observable<Unit> OnParticleTriggerAsObservable(this GameObject gameObject)
        {
            if (gameObject == null) return Observable.Empty<Unit>();
            return GetOrAddComponent<ObservableParticleTrigger>(gameObject).OnParticleTriggerAsObservable();
        }

        #endregion

        static T GetOrAddComponent<T>(GameObject gameObject)
            where T : Component
        {
            var component = gameObject.GetComponent<T>();
            if (component == null)
            {
                component = gameObject.AddComponent<T>();
            }

            return component;
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 52641452e5a8194429bbdce2b14a5b35
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerTrigger.cs
================================================
﻿#if R3_PHYSICS_SUPPORT
using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableTriggerTrigger : ObservableTriggerBase
    {
        Subject<Collider> onTriggerEnter;

        /// <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        void OnTriggerEnter(Collider other)
        {
            if (onTriggerEnter != null) onTriggerEnter.OnNext(other);
        }

        /// <summary>OnTriggerEnter is called when the Collider other enters the trigger.</summary>
        public Observable<Collider> OnTriggerEnterAsObservable()
        {
            return onTriggerEnter ?? (onTriggerEnter = new Subject<Collider>());
        }

        Subject<Collider> onTriggerExit;

        /// <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        void OnTriggerExit(Collider other)
        {
            if (onTriggerExit != null) onTriggerExit.OnNext(other);
        }

        /// <summary>OnTriggerExit is called when the Collider other has stopped touching the trigger.</summary>
        public Observable<Collider> OnTriggerExitAsObservable()
        {
            return onTriggerExit ?? (onTriggerExit = new Subject<Collider>());
        }

        Subject<Collider> onTriggerStay;

        /// <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        void OnTriggerStay(Collider other)
        {
            if (onTriggerStay != null) onTriggerStay.OnNext(other);
        }

        /// <summary>OnTriggerStay is called once per frame for every Collider other that is touching the trigger.</summary>
        public Observable<Collider> OnTriggerStayAsObservable()
        {
            return onTriggerStay ?? (onTriggerStay = new Subject<Collider>());
        }
        
        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onTriggerEnter != null)
            {
                onTriggerEnter.OnCompleted();
            }
            if (onTriggerExit != null)
            {
                onTriggerExit.OnCompleted();
            }
            if (onTriggerStay != null)
            {
                onTriggerStay.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableTriggerTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: bdba31c558827be4d9bf87dbcccb7493
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableUpdateSelectedTrigger.cs
================================================
﻿#if R3_UGUI_SUPPORT
using UnityEngine;
using UnityEngine.EventSystems;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableUpdateSelectedTrigger : ObservableTriggerBase, IEventSystemHandler, IUpdateSelectedHandler
    {
        Subject<BaseEventData> onUpdateSelected;

        void IUpdateSelectedHandler.OnUpdateSelected(BaseEventData eventData)
        {
            if (onUpdateSelected != null) onUpdateSelected.OnNext(eventData);
        }

        public Observable<BaseEventData> OnUpdateSelectedAsObservable()
        {
            return onUpdateSelected ?? (onUpdateSelected = new Subject<BaseEventData>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onUpdateSelected != null)
            {
                onUpdateSelected.OnCompleted();
            }
        }
    }
}
#endif



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableUpdateSelectedTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 827ff21525ac7f94080bf71dd6866d4d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableUpdateTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableUpdateTrigger : ObservableTriggerBase
    {
        Subject<Unit> update;

        /// <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        void Update()
        {
            if (update != null) update?.OnNext(Unit.Default);
        }

        /// <summary>Update is called every frame, if the MonoBehaviour is enabled.</summary>
        public Observable<Unit> UpdateAsObservable()
        {
            return update ?? (update = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (update != null)
            {
                update.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableUpdateTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 23ecd6a0559dbc846821f4793dca5040
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableVisibleTrigger.cs
================================================
﻿using UnityEngine;

namespace R3.Triggers
{
    [DisallowMultipleComponent]
    public class ObservableVisibleTrigger : ObservableTriggerBase
    {
        Subject<Unit> onBecameInvisible;

        /// <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        void OnBecameInvisible()
        {
            if (onBecameInvisible != null) onBecameInvisible.OnNext(Unit.Default);
        }

        /// <summary>OnBecameInvisible is called when the renderer is no longer visible by any camera.</summary>
        public Observable<Unit> OnBecameInvisibleAsObservable()
        {
            return onBecameInvisible ?? (onBecameInvisible = new Subject<Unit>());
        }

        Subject<Unit> onBecameVisible;

        /// <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        void OnBecameVisible()
        {
            if (onBecameVisible != null) onBecameVisible.OnNext(Unit.Default);
        }

        /// <summary>OnBecameVisible is called when the renderer became visible by any camera.</summary>
        public Observable<Unit> OnBecameVisibleAsObservable()
        {
            return onBecameVisible ?? (onBecameVisible = new Subject<Unit>());
        }

        protected override void RaiseOnCompletedOnDestroy()
        {
            if (onBecameInvisible != null)
            {
                onBecameInvisible.OnCompleted();
            }
            if (onBecameVisible != null)
            {
                onBecameVisible.OnCompleted();
            }
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/R3.Unity/Runtime/Triggers/ObservableVisibleTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: da10a5f26bc0b074a9ee55c5080178ee
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Scenes/NewBehaviourScript.cs
================================================
﻿using R3;
using System;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;
using Cysharp.Threading.Tasks;
using System.Threading;
using System.Text;
using UnityEngine.LowLevel;
using System.Linq;

public class NewBehaviourScript : MonoBehaviour
{
    public SerializableReactiveProperty<int> rpInt;
    public SerializableReactiveProperty<long> rpLong;
    public SerializableReactiveProperty<byte> rpByte;
    public SerializableReactiveProperty<float> rpFloat;
    public SerializableReactiveProperty<double> rpDouble;
    public SerializableReactiveProperty<string> rpString;
    public SerializableReactiveProperty<bool> rpBool;
    public SerializableReactiveProperty<Vector2> rpVector2;
    public SerializableReactiveProperty<Vector2Int> rpVector2Int;
    public SerializableReactiveProperty<Vector3> rpVector3;
    public SerializableReactiveProperty<Vector3Int> rpVector3Int;
    public SerializableReactiveProperty<Vector4> rpVector4;
    public SerializableReactiveProperty<Color> rpColor;
    public SerializableReactiveProperty<Rect> rpRect;
    public SerializableReactiveProperty<Bounds> rpBounds;
    public SerializableReactiveProperty<BoundsInt> rpBoundsInt;

    public SerializableReactiveProperty<Quaternion> rpQuaternion;
    public SerializableReactiveProperty<Matrix4x4> rpMatrix4x4;
    public SerializableReactiveProperty<FruitEnum> rpEnum;
    public SerializableReactiveProperty<FruitFlagsEnum> rpFlagsEnum;


    public SerializableReactiveProperty<int> NANTOKAMARU;
    //public NantonakuProperty NANTOKAMARU;

    public Button button1;
    public Button button2;
    // Text text;

    public NoAwakeTest noAwake;

     void Start()
    {
        rpInt.Subscribe(x =>
        {
            Debug.Log(x);
        });



    }



}



public enum FruitEnum
{
    Apple, Grape, Orange
}

[Flags]
public enum FruitFlagsEnum
{
    None = 0,
    Apple = 1,
    Grape = 2,
    Orange = 4
}

[Serializable]
public class NantonakuProperty
{
    public int value;
}


public class PlayerLoopInfo
{
    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
    static void Init()
    {
        // var playerLoop = UnityEngine.LowLevel.PlayerLoop.GetDefaultPlayerLoop();
        var playerLoop = UnityEngine.LowLevel.PlayerLoop.GetCurrentPlayerLoop();
        DumpPlayerLoop("After SubsystemRegistration", playerLoop);
    }

    public static void DumpPlayerLoop(string which, UnityEngine.LowLevel.PlayerLoopSystem playerLoop)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"{which} PlayerLoop List");
        foreach (var header in playerLoop.subSystemList)
        {
            sb.AppendFormat("------{0}------", header.type.Name);
            sb.AppendLine();
            foreach (var subSystem in header.subSystemList)
            {
                sb.AppendFormat("{0}.{1}", header.type.Name, subSystem.type.Name);
                sb.AppendLine();

                if (subSystem.subSystemList != null)
                {
                    UnityEngine.Debug.LogWarning("More Subsystem:" + subSystem.subSystemList.Length);
                }
            }
        }

        UnityEngine.Debug.Log(sb.ToString());
    }

    public static Type CurrentLoopType { get; private set; }

    public static void Inject()
    {
        var system = PlayerLoop.GetCurrentPlayerLoop();

        for (int i = 0; i < system.subSystemList.Length; i++)
        {
            var loop = system.subSystemList[i].subSystemList.SelectMany(x =>
            {
                var t = typeof(WrapLoop<>).MakeGenericType(x.type);
                var instance = (ILoopRunner)Activator.CreateInstance(t, x.type);
                return new[] { new PlayerLoopSystem { type = t, updateDelegate = instance.Run }, x };
            }).ToArray();

            system.subSystemList[i].subSystemList = loop;
        }

        PlayerLoop.SetPlayerLoop(system);
    }

    interface ILoopRunner
    {
        void Run();
    }

    class WrapLoop<T> : ILoopRunner
    {
        readonly Type type;

        public WrapLoop(Type type)
        {
            this.type = type;
        }

        public void Run()
        {
            CurrentLoopType = type;
        }
    }
}



================================================
FILE: src/R3.Unity/Assets/Scenes/NewBehaviourScript.cs.meta
================================================
fileFormatVersion: 2
guid: 166e09caa7feabc45bc1122fd021c625
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Scenes/NoAwakeTest.cs
================================================
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NoAwakeTest : MonoBehaviour
{
    private void OnDestroy()
    {
        Debug.Log("Destroy");
    }
}



================================================
FILE: src/R3.Unity/Assets/Scenes/NoAwakeTest.cs.meta
================================================
fileFormatVersion: 2
guid: ec38ff9540a4ce742b873b63c8e2392a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Scenes/SampleScene.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 0
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 500
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 500
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 2
    m_PVRDenoiserTypeDirect: 0
    m_PVRDenoiserTypeIndirect: 0
    m_PVRDenoiserTypeAO: 0
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 0
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_LightingSettings: {fileID: 0}
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 3
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    buildHeightMesh: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &115865986
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 115865987}
  - component: {fileID: 115865989}
  - component: {fileID: 115865988}
  m_Layer: 5
  m_Name: Text (Legacy)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &115865987
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 115865986}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 2133489487}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &115865988
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 115865986}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &115865989
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 115865986}
  m_CullTransparentMesh: 1
--- !u!1 &203216165
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 203216166}
  - component: {fileID: 203216168}
  - component: {fileID: 203216167}
  m_Layer: 5
  m_Name: Text1
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &203216166
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 203216165}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 2113242578}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -241.6, y: 8.5}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &203216167
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 203216165}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 0
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: New Text
--- !u!222 &203216168
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 203216165}
  m_CullTransparentMesh: 1
--- !u!1 &406184468
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 406184471}
  - component: {fileID: 406184470}
  - component: {fileID: 406184469}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &406184469
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 406184468}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_SendPointerHoverToParent: 1
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &406184470
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 406184468}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!4 &406184471
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 406184468}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &470145737
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 470145738}
  - component: {fileID: 470145741}
  - component: {fileID: 470145740}
  - component: {fileID: 470145739}
  m_Layer: 5
  m_Name: Button1
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &470145738
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 470145737}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 939889271}
  m_Father: {fileID: 2113242578}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -251, y: -104}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &470145739
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 470145737}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_WrapAround: 0
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 470145740}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &470145740
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 470145737}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &470145741
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 470145737}
  m_CullTransparentMesh: 1
--- !u!1 &519420028
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 519420032}
  - component: {fileID: 519420031}
  - component: {fileID: 519420033}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!20 &519420031
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 2
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_Iso: 200
  m_ShutterSpeed: 0.005
  m_Aperture: 16
  m_FocusDistance: 10
  m_FocalLength: 50
  m_BladeCount: 5
  m_Curvature: {x: 2, y: 11}
  m_BarrelClipping: 0.25
  m_Anamorphism: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 1
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 0
  m_HDR: 1
  m_AllowMSAA: 0
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 0
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &519420032
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 2113242578}
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &519420033
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 166e09caa7feabc45bc1122fd021c625, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  rpInt:
    value: 1339
  rpLong:
    value: 183
  rpByte:
    value: 0
  rpFloat:
    value: 3.55
  rpDouble:
    value: 0
  rpString:
    value: 
  rpBool:
    value: 0
  rpVector2:
    value: {x: 0, y: 0}
  rpVector2Int:
    value: {x: 0, y: 0}
  rpVector3:
    value: {x: 0, y: 0, z: 0}
  rpVector3Int:
    value: {x: 0, y: 0, z: 0}
  rpVector4:
    value: {x: 0, y: 0, z: 0, w: 0}
  rpColor:
    value: {r: 0, g: 0, b: 0, a: 0}
  rpRect:
    value:
      serializedVersion: 2
      x: 0
      y: 0
      width: 0
      height: 0
  rpBounds:
    value:
      m_Center: {x: 0, y: 0, z: 0}
      m_Extent: {x: 0, y: 0, z: 0}
  rpBoundsInt:
    value:
      m_Position: {x: 0, y: 0, z: 0}
      m_Size: {x: 0, y: 0, z: 0}
  rpQuaternion:
    value: {x: 0, y: 0, z: 0, w: 0}
  rpMatrix4x4:
    value:
      e00: 0
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 0
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 0
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 0
  rpEnum:
    value: 0
  rpFlagsEnum:
    value: 0
  NANTOKAMARU:
    value: 747
  button1: {fileID: 470145739}
  button2: {fileID: 2133489488}
  noAwake: {fileID: 1833500693}
--- !u!1 &939889270
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 939889271}
  - component: {fileID: 939889273}
  - component: {fileID: 939889272}
  m_Layer: 5
  m_Name: Text (Legacy)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &939889271
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 939889270}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 470145738}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &939889272
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 939889270}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &939889273
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 939889270}
  m_CullTransparentMesh: 1
--- !u!1 &1342220071
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1342220072}
  - component: {fileID: 1342220074}
  - component: {fileID: 1342220073}
  m_Layer: 5
  m_Name: Text2
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1342220072
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1342220071}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 2113242578}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -241.6, y: -50}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1342220073
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1342220071}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 0
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: New Text
--- !u!222 &1342220074
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1342220071}
  m_CullTransparentMesh: 1
--- !u!1 &1833500692
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1833500694}
  - component: {fileID: 1833500693}
  m_Layer: 0
  m_Name: GameObject
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 0
--- !u!114 &1833500693
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1833500692}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: ec38ff9540a4ce742b873b63c8e2392a, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!4 &1833500694
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1833500692}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 415.07205, y: 196.23882, z: -12.989617}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &2113242577
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2113242578}
  - component: {fileID: 2113242581}
  - component: {fileID: 2113242580}
  - component: {fileID: 2113242579}
  - component: {fileID: 2113242582}
  m_Layer: 5
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2113242578
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2113242577}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 470145738}
  - {fileID: 2133489487}
  - {fileID: 203216166}
  - {fileID: 1342220072}
  m_Father: {fileID: 519420032}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!114 &2113242579
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2113242577}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &2113242580
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2113242577}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
  m_PresetInfoIsWorld: 0
--- !u!223 &2113242581
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2113242577}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_VertexColorAlwaysGammaSpace: 0
  m_AdditionalShaderChannelsFlag: 0
  m_UpdateRectTransformForStandalone: 0
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!114 &2113242582
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2113242577}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 7caf8005612d032479292c91b7f9c781, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  button1: {fileID: 470145739}
  button2: {fileID: 2133489488}
  text1: {fileID: 203216167}
  text2: {fileID: 1342220073}
  iii: 0
  ccccc: 0
--- !u!1 &2133489486
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2133489487}
  - component: {fileID: 2133489490}
  - component: {fileID: 2133489489}
  - component: {fileID: 2133489488}
  m_Layer: 5
  m_Name: Button2
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2133489487
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2133489486}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children:
  - {fileID: 115865987}
  m_Father: {fileID: 2113242578}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -251, y: -164}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &2133489488
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2133489486}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_WrapAround: 0
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 2133489489}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &2133489489
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2133489486}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &2133489490
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2133489486}
  m_CullTransparentMesh: 1
--- !u!1660057539 &9223372036854775807
SceneRoots:
  m_ObjectHideFlags: 0
  m_Roots:
  - {fileID: 519420032}
  - {fileID: 406184471}
  - {fileID: 1833500694}



================================================
FILE: src/R3.Unity/Assets/Scenes/SampleScene.unity.meta
================================================
fileFormatVersion: 2
guid: 2cda990e2423bbf4892e6590ba056729
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/Scenes/SubjectBench.cs
================================================
﻿using R3;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine;
using UnityEngine.UI;

public class SubjectBench : MonoBehaviour
{
    public Button button1;
    public Button button2;
    public Text text1;
    public Text text2;

    EventBusMsg<int> msg = new EventBusMsg<int>() { Value = 1 };

    public int iii;

    public class EventBusMsg<T>
    {
        public T Value { get; set; }
    }

    void Start()
    {
        SetupSubject();

        button1.onClick.AddListener(() =>
        {
            var sw = Stopwatch.StartNew();
            TestR3LegacySubject();
            sw.Stop();
            text1.text = "legacy subject:" + sw.ElapsedMilliseconds;
        });

        button2.onClick.AddListener(() =>
        {
            var sw = Stopwatch.StartNew();
            TestR3Subject();
            sw.Stop();
            text2.text = "new subject:" + sw.ElapsedMilliseconds;
        });
    }

    public int ccccc;
    Subject<EventBusMsg<int>> subject = new Subject<EventBusMsg<int>>();
    // LegacySubject<EventBusMsg<int>> legacysubject = new LegacySubject<EventBusMsg<int>>();


    void SetupSubject()
    {

        var msg = new EventBusMsg<int>() { Value = 1 };
        for (int i = 0; i < 1000; i++)
        {
            subject.Subscribe(OnReceiveMsg);
        }
        for (int i = 0; i < 1000; i++)
        {
            // legacysubject.Subscribe(OnReceiveMsg);
        }

    }
    public void TestR3Subject()
    {


        for (int i = 0; i < 100000; i++)
        {
            subject.OnNext(msg);
        }
    }


    public void TestR3LegacySubject()
    {
        for (int i = 0; i < 100000; i++)
        {
            // legacysubject.OnNext(msg);
        }
    }


    public void OnReceiveMsg(EventBusMsg<int> msg)
    {
        ccccc++;
    }



}



================================================
FILE: src/R3.Unity/Assets/Scenes/SubjectBench.cs.meta
================================================
fileFormatVersion: 2
guid: 7caf8005612d032479292c91b7f9c781
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings.meta
================================================
fileFormatVersion: 2
guid: 60c6cbe6b84af3346a6519851ca897f4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/Resources.meta
================================================
fileFormatVersion: 2
guid: 557fd66430676eb4bbfdff649a7ebe59
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/XRInteractionEditorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2d38fb1463c5c804b8847c20e8873623, type: 3}
  m_Name: XRInteractionEditorSettings
  m_EditorClassIdentifier: 
  m_InteractionLayerUpdaterShown: 1
  m_ShowOldInteractionLayerMaskInInspector: 0



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/XRInteractionEditorSettings.asset.meta
================================================
fileFormatVersion: 2
guid: 342577e6ec60fad449228dd0cd70f73b
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/Resources/InteractionLayerSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 191492db6e452eb468b95433ec162164, type: 3}
  m_Name: InteractionLayerSettings
  m_EditorClassIdentifier: 
  m_LayerNames:
  - Default
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/Resources/InteractionLayerSettings.asset.meta
================================================
fileFormatVersion: 2
guid: 73d2cf6f259decb4f91cfba965a46c04
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/Resources/XRDeviceSimulatorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 690929a59dc7a42da9030305190d391f, type: 3}
  m_Name: XRDeviceSimulatorSettings
  m_EditorClassIdentifier: 
  m_AutomaticallyInstantiateSimulatorPrefab: 0
  m_AutomaticallyInstantiateInEditorOnly: 1
  m_SimulatorPrefab: {fileID: 0}



================================================
FILE: src/R3.Unity/Assets/XRI/Settings/Resources/XRDeviceSimulatorSettings.asset.meta
================================================
fileFormatVersion: 2
guid: 3164c5b082a56d04f939fb81f768f996
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/R3.Unity/Packages/manifest.json
================================================
{
  "dependencies": {
    "com.cysharp.r3.internal": "file:../../R3/bin/Debug/netstandard2.0",
    "com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask",
    "com.github-glitchenzo.nugetforunity": "https://github.com/GlitchEnzo/NuGetForUnity.git?path=/src/NuGetForUnity",
    "com.unity.ide.visualstudio": "2.0.22",
    "com.unity.textmeshpro": "3.0.9",
    "com.unity.ugui": "1.0.0",
    "com.unity.xr.interaction.toolkit": "2.6.3",
    "com.unity.modules.physics": "1.0.0",
    "com.unity.modules.physics2d": "1.0.0"
  }
}



================================================
FILE: src/R3.Unity/Packages/packages-lock.json
================================================
{
  "dependencies": {
    "com.cysharp.r3.internal": {
      "version": "file:../../R3/bin/Debug/netstandard2.0",
      "depth": 0,
      "source": "local",
      "dependencies": {}
    },
    "com.cysharp.unitask": {
      "version": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "66de0d3a58b256b6e0194f285cc530fd0c08407b"
    },
    "com.github-glitchenzo.nugetforunity": {
      "version": "https://github.com/GlitchEnzo/NuGetForUnity.git?path=/src/NuGetForUnity",
      "depth": 0,
      "source": "git",
      "dependencies": {},
      "hash": "7388d28922b2144497f639630fd8b8b7a3c1ee6d"
    },
    "com.unity.ext.nunit": {
      "version": "1.0.6",
      "depth": 2,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.visualstudio": {
      "version": "2.0.22",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.test-framework": "1.1.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.inputsystem": {
      "version": "1.7.0",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.uielements": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.mathematics": {
      "version": "1.2.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.test-framework": {
      "version": "1.1.33",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.textmeshpro": {
      "version": "3.0.9",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ugui": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ugui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0"
      }
    },
    "com.unity.xr.core-utils": {
      "version": "2.2.3",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.xr": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.xr.interaction.toolkit": {
      "version": "2.6.3",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ugui": "1.0.0",
        "com.unity.inputsystem": "1.7.0",
        "com.unity.mathematics": "1.2.6",
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.xr.core-utils": "2.2.3",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.xr.legacyinputhelpers": "2.1.10"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.xr.legacyinputhelpers": {
      "version": "2.1.10",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.vr": "1.0.0",
        "com.unity.modules.xr": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.modules.audio": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.imgui": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.jsonserialize": {
      "version": "1.0.0",
      "depth": 2,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics2d": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.subsystems": {
      "version": "1.0.0",
      "depth": 3,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.ui": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.uielements": {
      "version": "1.0.0",
      "depth": 2,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.vr": {
      "version": "1.0.0",
      "depth": 2,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.xr": "1.0.0"
      }
    },
    "com.unity.modules.xr": {
      "version": "1.0.0",
      "depth": 2,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.subsystems": "1.0.0"
      }
    }
  }
}



================================================
FILE: src/R3.Unity/ProjectSettings/AudioManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!11 &1
AudioManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Volume: 1
  Rolloff Scale: 1
  Doppler Factor: 1
  Default Speaker Mode: 2
  m_SampleRate: 0
  m_DSPBufferSize: 1024
  m_VirtualVoiceCount: 512
  m_RealVoiceCount: 32
  m_SpatializerPlugin: 
  m_AmbisonicDecoderPlugin: 
  m_DisableAudio: 0
  m_VirtualizeEffects: 1
  m_RequestedDSPBufferSize: 0



================================================
FILE: src/R3.Unity/ProjectSettings/BurstAotSettings_StandaloneWindows.json
================================================
{
  "MonoBehaviour": {
    "Version": 4,
    "EnableBurstCompilation": true,
    "EnableOptimisations": true,
    "EnableSafetyChecks": false,
    "EnableDebugInAllBuilds": false,
    "DebugDataKind": 1,
    "EnableArmv9SecurityFeatures": false,
    "CpuMinTargetX32": 0,
    "CpuMaxTargetX32": 0,
    "CpuMinTargetX64": 0,
    "CpuMaxTargetX64": 0,
    "CpuTargetsX32": 6,
    "CpuTargetsX64": 72,
    "OptimizeFor": 0
  }
}



================================================
FILE: src/R3.Unity/ProjectSettings/ClusterInputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!236 &1
ClusterInputManager:
  m_ObjectHideFlags: 0
  m_Inputs: []



================================================
FILE: src/R3.Unity/ProjectSettings/CommonBurstAotSettings.json
================================================
{
  "MonoBehaviour": {
    "Version": 4,
    "DisabledWarnings": ""
  }
}



================================================
FILE: src/R3.Unity/ProjectSettings/DynamicsManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!55 &1
PhysicsManager:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Gravity: {x: 0, y: -9.81, z: 0}
  m_DefaultMaterial: {fileID: 0}
  m_BounceThreshold: 2
  m_DefaultMaxDepenetrationVelocity: 10
  m_SleepThreshold: 0.005
  m_DefaultContactOffset: 0.01
  m_DefaultSolverIterations: 6
  m_DefaultSolverVelocityIterations: 1
  m_QueriesHitBackfaces: 0
  m_QueriesHitTriggers: 1
  m_EnableAdaptiveForce: 0
  m_ClothInterCollisionDistance: 0.1
  m_ClothInterCollisionStiffness: 0.2
  m_ContactsGeneration: 1
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  m_AutoSimulation: 1
  m_AutoSyncTransforms: 0
  m_ReuseCollisionCallbacks: 1
  m_ClothInterCollisionSettingsToggle: 0
  m_ClothGravity: {x: 0, y: -9.81, z: 0}
  m_ContactPairsMode: 0
  m_BroadphaseType: 0
  m_WorldBounds:
    m_Center: {x: 0, y: 0, z: 0}
    m_Extent: {x: 250, y: 250, z: 250}
  m_WorldSubdivisions: 8
  m_FrictionType: 0
  m_EnableEnhancedDeterminism: 0
  m_EnableUnifiedHeightmaps: 1
  m_SolverType: 0
  m_DefaultMaxAngularSpeed: 50



================================================
FILE: src/R3.Unity/ProjectSettings/EditorBuildSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1045 &1
EditorBuildSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Scenes:
  - enabled: 1
    path: Assets/Scenes/SampleScene.unity
    guid: 2cda990e2423bbf4892e6590ba056729
  m_configObjects: {}



================================================
FILE: src/R3.Unity/ProjectSettings/EditorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!159 &1
EditorSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_SerializationMode: 2
  m_LineEndingsForNewScripts: 0
  m_DefaultBehaviorMode: 1
  m_PrefabRegularEnvironment: {fileID: 0}
  m_PrefabUIEnvironment: {fileID: 0}
  m_SpritePackerMode: 4
  m_SpritePackerCacheSize: 10
  m_SpritePackerPaddingPower: 1
  m_Bc7TextureCompressor: 0
  m_EtcTextureCompressorBehavior: 1
  m_EtcTextureFastCompressor: 1
  m_EtcTextureNormalCompressor: 2
  m_EtcTextureBestCompressor: 4
  m_ProjectGenerationIncludedExtensions: txt;xml;fnt;cd;asmdef;asmref;rsp
  m_ProjectGenerationRootNamespace: 
  m_EnableTextureStreamingInEditMode: 1
  m_EnableTextureStreamingInPlayMode: 1
  m_EnableEditorAsyncCPUTextureLoading: 0
  m_AsyncShaderCompilation: 1
  m_PrefabModeAllowAutoSave: 1
  m_EnterPlayModeOptionsEnabled: 1
  m_EnterPlayModeOptions: 0
  m_GameObjectNamingDigits: 1
  m_GameObjectNamingScheme: 0
  m_AssetNamingUsesSpace: 1
  m_InspectorUseIMGUIDefaultInspector: 0
  m_UseLegacyProbeSampleCount: 0
  m_SerializeInlineMappingsOnOneLine: 1
  m_DisableCookiesInLightmapper: 1
  m_AssetPipelineMode: 1
  m_RefreshImportMode: 0
  m_CacheServerMode: 0
  m_CacheServerEndpoint: 
  m_CacheServerNamespacePrefix: default
  m_CacheServerEnableDownload: 1
  m_CacheServerEnableUpload: 1
  m_CacheServerEnableAuth: 0
  m_CacheServerEnableTls: 0
  m_CacheServerValidationMode: 2
  m_CacheServerDownloadBatchSize: 128
  m_EnableEnlightenBakedGI: 0



================================================
FILE: src/R3.Unity/ProjectSettings/GraphicsSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!30 &1
GraphicsSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 13
  m_Deferred:
    m_Mode: 1
    m_Shader: {fileID: 69, guid: 0000000000000000f000000000000000, type: 0}
  m_DeferredReflections:
    m_Mode: 1
    m_Shader: {fileID: 74, guid: 0000000000000000f000000000000000, type: 0}
  m_ScreenSpaceShadows:
    m_Mode: 1
    m_Shader: {fileID: 64, guid: 0000000000000000f000000000000000, type: 0}
  m_LegacyDeferred:
    m_Mode: 1
    m_Shader: {fileID: 63, guid: 0000000000000000f000000000000000, type: 0}
  m_DepthNormals:
    m_Mode: 1
    m_Shader: {fileID: 62, guid: 0000000000000000f000000000000000, type: 0}
  m_MotionVectors:
    m_Mode: 1
    m_Shader: {fileID: 75, guid: 0000000000000000f000000000000000, type: 0}
  m_LightHalo:
    m_Mode: 1
    m_Shader: {fileID: 105, guid: 0000000000000000f000000000000000, type: 0}
  m_LensFlare:
    m_Mode: 1
    m_Shader: {fileID: 102, guid: 0000000000000000f000000000000000, type: 0}
  m_VideoShadersIncludeMode: 2
  m_AlwaysIncludedShaders:
  - {fileID: 7, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15104, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15105, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15106, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10753, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10770, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10783, guid: 0000000000000000f000000000000000, type: 0}
  m_PreloadedShaders: []
  m_SpritesDefaultMaterial: {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_CustomRenderPipeline: {fileID: 0}
  m_TransparencySortMode: 0
  m_TransparencySortAxis: {x: 0, y: 0, z: 1}
  m_DefaultRenderingPath: 1
  m_DefaultMobileRenderingPath: 1
  m_TierSettings: []
  m_LightmapStripping: 0
  m_FogStripping: 0
  m_InstancingStripping: 0
  m_LightmapKeepPlain: 1
  m_LightmapKeepDirCombined: 1
  m_LightmapKeepDynamicPlain: 1
  m_LightmapKeepDynamicDirCombined: 1
  m_LightmapKeepShadowMask: 1
  m_LightmapKeepSubtractive: 1
  m_FogKeepLinear: 1
  m_FogKeepExp: 1
  m_FogKeepExp2: 1
  m_AlbedoSwatchInfos: []
  m_LightsUseLinearIntensity: 0
  m_LightsUseColorTemperature: 0
  m_DefaultRenderingLayerMask: 1
  m_LogWhenShaderIsCompiled: 0



================================================
FILE: src/R3.Unity/ProjectSettings/InputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!13 &1
InputManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Axes:
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: a
    altPositiveButton: d
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: s
    altPositiveButton: w
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: mouse 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: mouse 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: mouse 2
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: space
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse X
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse Y
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse ScrollWheel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 2
    joyNum: 0
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 0
    type: 2
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 1
    type: 2
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 0
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 1
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 2
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 3
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: enter
    altNegativeButton: 
    altPositiveButton: space
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Cancel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: escape
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: joystick button 8
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: backspace
    altNegativeButton: 
    altPositiveButton: joystick button 9
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Reset
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Next
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page down
    altNegativeButton: 
    altPositiveButton: joystick button 5
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Previous
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page up
    altNegativeButton: 
    altPositiveButton: joystick button 4
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Validate
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Persistent
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: right shift
    altNegativeButton: 
    altPositiveButton: joystick button 2
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Multiplier
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: joystick button 3
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 6
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 5
    joyNum: 0



================================================
FILE: src/R3.Unity/ProjectSettings/MemorySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!387306366 &1
MemorySettings:
  m_ObjectHideFlags: 0
  m_EditorMemorySettings:
    m_MainAllocatorBlockSize: -1
    m_ThreadAllocatorBlockSize: -1
    m_MainGfxBlockSize: -1
    m_ThreadGfxBlockSize: -1
    m_CacheBlockSize: -1
    m_TypetreeBlockSize: -1
    m_ProfilerBlockSize: -1
    m_ProfilerEditorBlockSize: -1
    m_BucketAllocatorGranularity: -1
    m_BucketAllocatorBucketsCount: -1
    m_BucketAllocatorBlockSize: -1
    m_BucketAllocatorBlockCount: -1
    m_ProfilerBucketAllocatorGranularity: -1
    m_ProfilerBucketAllocatorBucketsCount: -1
    m_ProfilerBucketAllocatorBlockSize: -1
    m_ProfilerBucketAllocatorBlockCount: -1
    m_TempAllocatorSizeMain: -1
    m_JobTempAllocatorBlockSize: -1
    m_BackgroundJobTempAllocatorBlockSize: -1
    m_JobTempAllocatorReducedBlockSize: -1
    m_TempAllocatorSizeGIBakingWorker: -1
    m_TempAllocatorSizeNavMeshWorker: -1
    m_TempAllocatorSizeAudioWorker: -1
    m_TempAllocatorSizeCloudWorker: -1
    m_TempAllocatorSizeGfx: -1
    m_TempAllocatorSizeJobWorker: -1
    m_TempAllocatorSizeBackgroundWorker: -1
    m_TempAllocatorSizePreloadManager: -1
  m_PlatformMemorySettings: {}



================================================
FILE: src/R3.Unity/ProjectSettings/NavMeshAreas.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!126 &1
NavMeshProjectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  areas:
  - name: Walkable
    cost: 1
  - name: Not Walkable
    cost: 1
  - name: Jump
    cost: 2
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  m_LastAgentTypeID: -887442657
  m_Settings:
  - serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.75
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    maxJobWorkers: 0
    preserveTilesOutsideBounds: 0
    debug:
      m_Flags: 0
  m_SettingNames:
  - Humanoid



================================================
FILE: src/R3.Unity/ProjectSettings/NetworkManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!149 &1
NetworkManager:
  m_ObjectHideFlags: 0
  m_DebugLevel: 0
  m_Sendrate: 15
  m_AssetToPrefab: {}



================================================
FILE: src/R3.Unity/ProjectSettings/PackageManagerSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 61
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 13964, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_EnablePreReleasePackages: 0
  m_EnablePackageDependencies: 0
  m_AdvancedSettingsExpanded: 1
  m_ScopedRegistriesSettingsExpanded: 1
  m_SeeAllPackageVersions: 0
  oneTimeWarningShown: 0
  m_Registries:
  - m_Id: main
    m_Name: 
    m_Url: https://packages.unity.com
    m_Scopes: []
    m_IsDefault: 1
    m_Capabilities: 7
  m_UserSelectedRegistryName: 
  m_UserAddingNewScopedRegistry: 0
  m_RegistryInfoDraft:
    m_ErrorMessage: 
    m_Original:
      m_Id: 
      m_Name: 
      m_Url: 
      m_Scopes: []
      m_IsDefault: 0
      m_Capabilities: 0
    m_Modified: 0
    m_Name: 
    m_Url: 
    m_Scopes:
    - 
    m_SelectedScopeIndex: 0



================================================
FILE: src/R3.Unity/ProjectSettings/Physics2DSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!19 &1
Physics2DSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_Gravity: {x: 0, y: -9.81}
  m_DefaultMaterial: {fileID: 0}
  m_VelocityIterations: 8
  m_PositionIterations: 3
  m_VelocityThreshold: 1
  m_MaxLinearCorrection: 0.2
  m_MaxAngularCorrection: 8
  m_MaxTranslationSpeed: 100
  m_MaxRotationSpeed: 360
  m_BaumgarteScale: 0.2
  m_BaumgarteTimeOfImpactScale: 0.75
  m_TimeToSleep: 0.5
  m_LinearSleepTolerance: 0.01
  m_AngularSleepTolerance: 2
  m_DefaultContactOffset: 0.01
  m_JobOptions:
    serializedVersion: 2
    useMultithreading: 0
    useConsistencySorting: 0
    m_InterpolationPosesPerJob: 100
    m_NewContactsPerJob: 30
    m_CollideContactsPerJob: 100
    m_ClearFlagsPerJob: 200
    m_ClearBodyForcesPerJob: 200
    m_SyncDiscreteFixturesPerJob: 50
    m_SyncContinuousFixturesPerJob: 50
    m_FindNearestContactsPerJob: 100
    m_UpdateTriggerContactsPerJob: 100
    m_IslandSolverCostThreshold: 100
    m_IslandSolverBodyCostScale: 1
    m_IslandSolverContactCostScale: 10
    m_IslandSolverJointCostScale: 10
    m_IslandSolverBodiesPerJob: 50
    m_IslandSolverContactsPerJob: 50
  m_SimulationMode: 0
  m_QueriesHitTriggers: 1
  m_QueriesStartInColliders: 1
  m_CallbacksOnDisable: 1
  m_ReuseCollisionCallbacks: 1
  m_AutoSyncTransforms: 0
  m_AlwaysShowColliders: 0
  m_ShowColliderSleep: 1
  m_ShowColliderContacts: 0
  m_ShowColliderAABB: 0
  m_ContactArrowScale: 0.2
  m_ColliderAwakeColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.7529412}
  m_ColliderAsleepColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.36078432}
  m_ColliderContactColor: {r: 1, g: 0, b: 1, a: 0.6862745}
  m_ColliderAABBColor: {r: 1, g: 1, b: 0, a: 0.2509804}
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff



================================================
FILE: src/R3.Unity/ProjectSettings/PresetManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1386491679 &1
PresetManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_DefaultPresets: {}



================================================
FILE: src/R3.Unity/ProjectSettings/ProjectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 26
  productGUID: 1f748a2d273c1254f855121cc630c985
  AndroidProfiler: 0
  AndroidFilterTouchesWhenObscured: 0
  AndroidEnableSustainedPerformanceMode: 0
  defaultScreenOrientation: 4
  targetDevice: 2
  useOnDemandResources: 0
  accelerometerFrequency: 60
  companyName: DefaultCompany
  productName: R3.Unity
  defaultCursor: {fileID: 0}
  cursorHotspot: {x: 0, y: 0}
  m_SplashScreenBackgroundColor: {r: 0.13725491, g: 0.12156863, b: 0.1254902, a: 1}
  m_ShowUnitySplashScreen: 1
  m_ShowUnitySplashLogo: 1
  m_SplashScreenOverlayOpacity: 1
  m_SplashScreenAnimation: 1
  m_SplashScreenLogoStyle: 1
  m_SplashScreenDrawMode: 0
  m_SplashScreenBackgroundAnimationZoom: 1
  m_SplashScreenLogoAnimationZoom: 1
  m_SplashScreenBackgroundLandscapeAspect: 1
  m_SplashScreenBackgroundPortraitAspect: 1
  m_SplashScreenBackgroundLandscapeUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenBackgroundPortraitUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenLogos: []
  m_VirtualRealitySplashScreen: {fileID: 0}
  m_HolographicTrackingLossScreen: {fileID: 0}
  defaultScreenWidth: 1920
  defaultScreenHeight: 1080
  defaultScreenWidthWeb: 960
  defaultScreenHeightWeb: 600
  m_StereoRenderingPath: 0
  m_ActiveColorSpace: 0
  unsupportedMSAAFallback: 0
  m_SpriteBatchVertexThreshold: 300
  m_MTRendering: 1
  mipStripping: 0
  numberOfMipsStripped: 0
  numberOfMipsStrippedPerMipmapLimitGroup: {}
  m_StackTraceTypes: 010000000100000001000000010000000100000001000000
  iosShowActivityIndicatorOnLoading: -1
  androidShowActivityIndicatorOnLoading: -1
  iosUseCustomAppBackgroundBehavior: 0
  allowedAutorotateToPortrait: 1
  allowedAutorotateToPortraitUpsideDown: 1
  allowedAutorotateToLandscapeRight: 1
  allowedAutorotateToLandscapeLeft: 1
  useOSAutorotation: 1
  use32BitDisplayBuffer: 1
  preserveFramebufferAlpha: 0
  disableDepthAndStencilBuffers: 0
  androidStartInFullscreen: 1
  androidRenderOutsideSafeArea: 1
  androidUseSwappy: 1
  androidBlitType: 0
  androidResizableWindow: 0
  androidDefaultWindowWidth: 1920
  androidDefaultWindowHeight: 1080
  androidMinimumWindowWidth: 400
  androidMinimumWindowHeight: 300
  androidFullscreenMode: 1
  defaultIsNativeResolution: 1
  macRetinaSupport: 1
  runInBackground: 0
  captureSingleScreen: 0
  muteOtherAudioSources: 0
  Prepare IOS For Recording: 0
  Force IOS Speakers When Recording: 0
  deferSystemGesturesMode: 0
  hideHomeButton: 0
  submitAnalytics: 1
  usePlayerLog: 1
  dedicatedServerOptimizations: 0
  bakeCollisionMeshes: 0
  forceSingleInstance: 0
  useFlipModelSwapchain: 1
  resizableWindow: 0
  useMacAppStoreValidation: 0
  macAppStoreCategory: public.app-category.games
  gpuSkinning: 0
  xboxPIXTextureCapture: 0
  xboxEnableAvatar: 0
  xboxEnableKinect: 0
  xboxEnableKinectAutoTracking: 0
  xboxEnableFitness: 0
  visibleInBackground: 1
  allowFullscreenSwitch: 1
  fullscreenMode: 3
  xboxSpeechDB: 0
  xboxEnableHeadOrientation: 0
  xboxEnableGuest: 0
  xboxEnablePIXSampling: 0
  metalFramebufferOnly: 0
  xboxOneResolution: 0
  xboxOneSResolution: 0
  xboxOneXResolution: 3
  xboxOneMonoLoggingLevel: 0
  xboxOneLoggingLevel: 1
  xboxOneDisableEsram: 0
  xboxOneEnableTypeOptimization: 0
  xboxOnePresentImmediateThreshold: 0
  switchQueueCommandMemory: 1048576
  switchQueueControlMemory: 16384
  switchQueueComputeMemory: 262144
  switchNVNShaderPoolsGranularity: 33554432
  switchNVNDefaultPoolsGranularity: 16777216
  switchNVNOtherPoolsGranularity: 16777216
  switchGpuScratchPoolGranularity: 2097152
  switchAllowGpuScratchShrinking: 0
  switchNVNMaxPublicTextureIDCount: 0
  switchNVNMaxPublicSamplerIDCount: 0
  switchNVNGraphicsFirmwareMemory: 32
  switchMaxWorkerMultiple: 8
  stadiaPresentMode: 0
  stadiaTargetFramerate: 0
  vulkanNumSwapchainBuffers: 3
  vulkanEnableSetSRGBWrite: 0
  vulkanEnablePreTransform: 0
  vulkanEnableLateAcquireNextImage: 0
  vulkanEnableCommandBufferRecycling: 1
  loadStoreDebugModeEnabled: 0
  bundleVersion: 1.0
  preloadedAssets: []
  metroInputSource: 0
  wsaTransparentSwapchain: 0
  m_HolographicPauseOnTrackingLoss: 1
  xboxOneDisableKinectGpuReservation: 1
  xboxOneEnable7thCore: 1
  vrSettings:
    enable360StereoCapture: 0
  isWsaHolographicRemotingEnabled: 0
  enableFrameTimingStats: 0
  enableOpenGLProfilerGPURecorders: 1
  allowHDRDisplaySupport: 0
  useHDRDisplay: 0
  hdrBitDepth: 0
  m_ColorGamuts: 00000000
  targetPixelDensity: 30
  resolutionScalingMode: 0
  resetResolutionOnWindowResize: 0
  androidSupportedAspectRatio: 1
  androidMaxAspectRatio: 2.1
  applicationIdentifier:
    Standalone: com.DefaultCompany.2DProject
  buildNumber:
    Standalone: 0
    VisionOS: 0
    iPhone: 0
    tvOS: 0
  overrideDefaultApplicationIdentifier: 1
  AndroidBundleVersionCode: 1
  AndroidMinSdkVersion: 22
  AndroidTargetSdkVersion: 0
  AndroidPreferredInstallLocation: 1
  aotOptions: 
  stripEngineCode: 1
  iPhoneStrippingLevel: 0
  iPhoneScriptCallOptimization: 0
  ForceInternetPermission: 0
  ForceSDCardPermission: 0
  CreateWallpaper: 0
  APKExpansionFiles: 0
  keepLoadedShadersAlive: 0
  StripUnusedMeshComponents: 0
  strictShaderVariantMatching: 0
  VertexChannelCompressionMask: 4054
  iPhoneSdkVersion: 988
  iOSTargetOSVersionString: 12.0
  tvOSSdkVersion: 0
  tvOSRequireExtendedGameController: 0
  tvOSTargetOSVersionString: 12.0
  VisionOSSdkVersion: 0
  VisionOSTargetOSVersionString: 1.0
  uIPrerenderedIcon: 0
  uIRequiresPersistentWiFi: 0
  uIRequiresFullScreen: 1
  uIStatusBarHidden: 1
  uIExitOnSuspend: 0
  uIStatusBarStyle: 0
  appleTVSplashScreen: {fileID: 0}
  appleTVSplashScreen2x: {fileID: 0}
  tvOSSmallIconLayers: []
  tvOSSmallIconLayers2x: []
  tvOSLargeIconLayers: []
  tvOSLargeIconLayers2x: []
  tvOSTopShelfImageLayers: []
  tvOSTopShelfImageLayers2x: []
  tvOSTopShelfImageWideLayers: []
  tvOSTopShelfImageWideLayers2x: []
  iOSLaunchScreenType: 0
  iOSLaunchScreenPortrait: {fileID: 0}
  iOSLaunchScreenLandscape: {fileID: 0}
  iOSLaunchScreenBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreenFillPct: 100
  iOSLaunchScreenSize: 100
  iOSLaunchScreenCustomXibPath: 
  iOSLaunchScreeniPadType: 0
  iOSLaunchScreeniPadImage: {fileID: 0}
  iOSLaunchScreeniPadBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreeniPadFillPct: 100
  iOSLaunchScreeniPadSize: 100
  iOSLaunchScreeniPadCustomXibPath: 
  iOSLaunchScreenCustomStoryboardPath: 
  iOSLaunchScreeniPadCustomStoryboardPath: 
  iOSDeviceRequirements: []
  iOSURLSchemes: []
  macOSURLSchemes: []
  iOSBackgroundModes: 0
  iOSMetalForceHardShadows: 0
  metalEditorSupport: 1
  metalAPIValidation: 1
  iOSRenderExtraFrameOnPause: 0
  iosCopyPluginsCodeInsteadOfSymlink: 0
  appleDeveloperTeamID: 
  iOSManualSigningProvisioningProfileID: 
  tvOSManualSigningProvisioningProfileID: 
  VisionOSManualSigningProvisioningProfileID: 
  iOSManualSigningProvisioningProfileType: 0
  tvOSManualSigningProvisioningProfileType: 0
  VisionOSManualSigningProvisioningProfileType: 0
  appleEnableAutomaticSigning: 0
  iOSRequireARKit: 0
  iOSAutomaticallyDetectAndAddCapabilities: 1
  appleEnableProMotion: 0
  shaderPrecisionModel: 0
  clonedFromGUID: 10ad67313f4034357812315f3c407484
  templatePackageId: com.unity.template.2d@6.1.1
  templateDefaultScene: Assets/Scenes/SampleScene.unity
  useCustomMainManifest: 0
  useCustomLauncherManifest: 0
  useCustomMainGradleTemplate: 0
  useCustomLauncherGradleManifest: 0
  useCustomBaseGradleTemplate: 0
  useCustomGradlePropertiesTemplate: 0
  useCustomGradleSettingsTemplate: 0
  useCustomProguardFile: 0
  AndroidTargetArchitectures: 1
  AndroidTargetDevices: 0
  AndroidSplashScreenScale: 0
  androidSplashScreen: {fileID: 0}
  AndroidKeystoreName: 
  AndroidKeyaliasName: 
  AndroidEnableArmv9SecurityFeatures: 0
  AndroidBuildApkPerCpuArchitecture: 0
  AndroidTVCompatibility: 0
  AndroidIsGame: 1
  AndroidEnableTango: 0
  androidEnableBanner: 1
  androidUseLowAccuracyLocation: 0
  androidUseCustomKeystore: 0
  m_AndroidBanners:
  - width: 320
    height: 180
    banner: {fileID: 0}
  androidGamepadSupportLevel: 0
  chromeosInputEmulation: 1
  AndroidMinifyRelease: 0
  AndroidMinifyDebug: 0
  AndroidValidateAppBundleSize: 1
  AndroidAppBundleSizeToValidate: 150
  m_BuildTargetIcons: []
  m_BuildTargetPlatformIcons: []
  m_BuildTargetBatching: []
  m_BuildTargetShaderSettings: []
  m_BuildTargetGraphicsJobs:
  - m_BuildTarget: MacStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: Switch
    m_GraphicsJobs: 0
  - m_BuildTarget: MetroSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AppleTVSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: BJMSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: LinuxStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: PS4Player
    m_GraphicsJobs: 0
  - m_BuildTarget: iOSSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: WindowsStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: XboxOnePlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: LuminSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AndroidPlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: WebGLSupport
    m_GraphicsJobs: 0
  m_BuildTargetGraphicsJobMode: []
  m_BuildTargetGraphicsAPIs:
  - m_BuildTarget: AndroidPlayer
    m_APIs: 150000000b000000
    m_Automatic: 1
  - m_BuildTarget: iOSSupport
    m_APIs: 10000000
    m_Automatic: 1
  m_BuildTargetVRSettings: []
  m_DefaultShaderChunkSizeInMB: 16
  m_DefaultShaderChunkCount: 0
  openGLRequireES31: 0
  openGLRequireES31AEP: 0
  openGLRequireES32: 0
  m_TemplateCustomTags: {}
  mobileMTRendering:
    Android: 1
    iPhone: 1
    tvOS: 1
  m_BuildTargetGroupLightmapEncodingQuality: []
  m_BuildTargetGroupHDRCubemapEncodingQuality: []
  m_BuildTargetGroupLightmapSettings: []
  m_BuildTargetGroupLoadStoreDebugModeSettings: []
  m_BuildTargetNormalMapEncoding: []
  m_BuildTargetDefaultTextureCompressionFormat:
  - m_BuildTarget: Android
    m_Format: 3
  playModeTestRunnerEnabled: 0
  runPlayModeTestAsEditModeTest: 0
  actionOnDotNetUnhandledException: 1
  enableInternalProfiler: 0
  logObjCUncaughtExceptions: 1
  enableCrashReportAPI: 0
  cameraUsageDescription: 
  locationUsageDescription: 
  microphoneUsageDescription: 
  bluetoothUsageDescription: 
  macOSTargetOSVersion: 10.13.0
  switchNMETAOverride: 
  switchNetLibKey: 
  switchSocketMemoryPoolSize: 6144
  switchSocketAllocatorPoolSize: 128
  switchSocketConcurrencyLimit: 14
  switchScreenResolutionBehavior: 2
  switchUseCPUProfiler: 0
  switchEnableFileSystemTrace: 0
  switchLTOSetting: 0
  switchApplicationID: 0x01004b9000490000
  switchNSODependencies: 
  switchCompilerFlags: 
  switchTitleNames_0: 
  switchTitleNames_1: 
  switchTitleNames_2: 
  switchTitleNames_3: 
  switchTitleNames_4: 
  switchTitleNames_5: 
  switchTitleNames_6: 
  switchTitleNames_7: 
  switchTitleNames_8: 
  switchTitleNames_9: 
  switchTitleNames_10: 
  switchTitleNames_11: 
  switchTitleNames_12: 
  switchTitleNames_13: 
  switchTitleNames_14: 
  switchTitleNames_15: 
  switchPublisherNames_0: 
  switchPublisherNames_1: 
  switchPublisherNames_2: 
  switchPublisherNames_3: 
  switchPublisherNames_4: 
  switchPublisherNames_5: 
  switchPublisherNames_6: 
  switchPublisherNames_7: 
  switchPublisherNames_8: 
  switchPublisherNames_9: 
  switchPublisherNames_10: 
  switchPublisherNames_11: 
  switchPublisherNames_12: 
  switchPublisherNames_13: 
  switchPublisherNames_14: 
  switchPublisherNames_15: 
  switchIcons_0: {fileID: 0}
  switchIcons_1: {fileID: 0}
  switchIcons_2: {fileID: 0}
  switchIcons_3: {fileID: 0}
  switchIcons_4: {fileID: 0}
  switchIcons_5: {fileID: 0}
  switchIcons_6: {fileID: 0}
  switchIcons_7: {fileID: 0}
  switchIcons_8: {fileID: 0}
  switchIcons_9: {fileID: 0}
  switchIcons_10: {fileID: 0}
  switchIcons_11: {fileID: 0}
  switchIcons_12: {fileID: 0}
  switchIcons_13: {fileID: 0}
  switchIcons_14: {fileID: 0}
  switchIcons_15: {fileID: 0}
  switchSmallIcons_0: {fileID: 0}
  switchSmallIcons_1: {fileID: 0}
  switchSmallIcons_2: {fileID: 0}
  switchSmallIcons_3: {fileID: 0}
  switchSmallIcons_4: {fileID: 0}
  switchSmallIcons_5: {fileID: 0}
  switchSmallIcons_6: {fileID: 0}
  switchSmallIcons_7: {fileID: 0}
  switchSmallIcons_8: {fileID: 0}
  switchSmallIcons_9: {fileID: 0}
  switchSmallIcons_10: {fileID: 0}
  switchSmallIcons_11: {fileID: 0}
  switchSmallIcons_12: {fileID: 0}
  switchSmallIcons_13: {fileID: 0}
  switchSmallIcons_14: {fileID: 0}
  switchSmallIcons_15: {fileID: 0}
  switchManualHTML: 
  switchAccessibleURLs: 
  switchLegalInformation: 
  switchMainThreadStackSize: 1048576
  switchPresenceGroupId: 
  switchLogoHandling: 0
  switchReleaseVersion: 0
  switchDisplayVersion: 1.0.0
  switchStartupUserAccount: 0
  switchSupportedLanguagesMask: 0
  switchLogoType: 0
  switchApplicationErrorCodeCategory: 
  switchUserAccountSaveDataSize: 0
  switchUserAccountSaveDataJournalSize: 0
  switchApplicationAttribute: 0
  switchCardSpecSize: -1
  switchCardSpecClock: -1
  switchRatingsMask: 0
  switchRatingsInt_0: 0
  switchRatingsInt_1: 0
  switchRatingsInt_2: 0
  switchRatingsInt_3: 0
  switchRatingsInt_4: 0
  switchRatingsInt_5: 0
  switchRatingsInt_6: 0
  switchRatingsInt_7: 0
  switchRatingsInt_8: 0
  switchRatingsInt_9: 0
  switchRatingsInt_10: 0
  switchRatingsInt_11: 0
  switchRatingsInt_12: 0
  switchLocalCommunicationIds_0: 
  switchLocalCommunicationIds_1: 
  switchLocalCommunicationIds_2: 
  switchLocalCommunicationIds_3: 
  switchLocalCommunicationIds_4: 
  switchLocalCommunicationIds_5: 
  switchLocalCommunicationIds_6: 
  switchLocalCommunicationIds_7: 
  switchParentalControl: 0
  switchAllowsScreenshot: 1
  switchAllowsVideoCapturing: 1
  switchAllowsRuntimeAddOnContentInstall: 0
  switchDataLossConfirmation: 0
  switchUserAccountLockEnabled: 0
  switchSystemResourceMemory: 16777216
  switchSupportedNpadStyles: 22
  switchNativeFsCacheSize: 32
  switchIsHoldTypeHorizontal: 0
  switchSupportedNpadCount: 8
  switchEnableTouchScreen: 1
  switchSocketConfigEnabled: 0
  switchTcpInitialSendBufferSize: 32
  switchTcpInitialReceiveBufferSize: 64
  switchTcpAutoSendBufferSizeMax: 256
  switchTcpAutoReceiveBufferSizeMax: 256
  switchUdpSendBufferSize: 9
  switchUdpReceiveBufferSize: 42
  switchSocketBufferEfficiency: 4
  switchSocketInitializeEnabled: 1
  switchNetworkInterfaceManagerInitializeEnabled: 1
  switchUseNewStyleFilepaths: 0
  switchUseLegacyFmodPriorities: 0
  switchUseMicroSleepForYield: 1
  switchEnableRamDiskSupport: 0
  switchMicroSleepForYieldTime: 25
  switchRamDiskSpaceSize: 12
  ps4NPAgeRating: 12
  ps4NPTitleSecret: 
  ps4NPTrophyPackPath: 
  ps4ParentalLevel: 11
  ps4ContentID: ED1633-NPXX51362_00-0000000000000000
  ps4Category: 0
  ps4MasterVersion: 01.00
  ps4AppVersion: 01.00
  ps4AppType: 0
  ps4ParamSfxPath: 
  ps4VideoOutPixelFormat: 0
  ps4VideoOutInitialWidth: 1920
  ps4VideoOutBaseModeInitialWidth: 1920
  ps4VideoOutReprojectionRate: 60
  ps4PronunciationXMLPath: 
  ps4PronunciationSIGPath: 
  ps4BackgroundImagePath: 
  ps4StartupImagePath: 
  ps4StartupImagesFolder: 
  ps4IconImagesFolder: 
  ps4SaveDataImagePath: 
  ps4SdkOverride: 
  ps4BGMPath: 
  ps4ShareFilePath: 
  ps4ShareOverlayImagePath: 
  ps4PrivacyGuardImagePath: 
  ps4ExtraSceSysFile: 
  ps4NPtitleDatPath: 
  ps4RemotePlayKeyAssignment: -1
  ps4RemotePlayKeyMappingDir: 
  ps4PlayTogetherPlayerCount: 0
  ps4EnterButtonAssignment: 2
  ps4ApplicationParam1: 0
  ps4ApplicationParam2: 0
  ps4ApplicationParam3: 0
  ps4ApplicationParam4: 0
  ps4DownloadDataSize: 0
  ps4GarlicHeapSize: 2048
  ps4ProGarlicHeapSize: 2560
  playerPrefsMaxSize: 32768
  ps4Passcode: bi9UOuSpM2Tlh01vOzwvSikHFswuzleh
  ps4pnSessions: 1
  ps4pnPresence: 1
  ps4pnFriends: 1
  ps4pnGameCustomData: 1
  playerPrefsSupport: 0
  enableApplicationExit: 0
  resetTempFolder: 1
  restrictedAudioUsageRights: 0
  ps4UseResolutionFallback: 0
  ps4ReprojectionSupport: 0
  ps4UseAudio3dBackend: 0
  ps4UseLowGarlicFragmentationMode: 1
  ps4SocialScreenEnabled: 0
  ps4ScriptOptimizationLevel: 2
  ps4Audio3dVirtualSpeakerCount: 14
  ps4attribCpuUsage: 0
  ps4PatchPkgPath: 
  ps4PatchLatestPkgPath: 
  ps4PatchChangeinfoPath: 
  ps4PatchDayOne: 0
  ps4attribUserManagement: 0
  ps4attribMoveSupport: 0
  ps4attrib3DSupport: 0
  ps4attribShareSupport: 0
  ps4attribExclusiveVR: 0
  ps4disableAutoHideSplash: 0
  ps4videoRecordingFeaturesUsed: 0
  ps4contentSearchFeaturesUsed: 0
  ps4CompatibilityPS5: 0
  ps4AllowPS5Detection: 0
  ps4GPU800MHz: 1
  ps4attribEyeToEyeDistanceSettingVR: 0
  ps4IncludedModules: []
  ps4attribVROutputEnabled: 0
  monoEnv: 
  splashScreenBackgroundSourceLandscape: {fileID: 0}
  splashScreenBackgroundSourcePortrait: {fileID: 0}
  blurSplashScreenBackground: 1
  spritePackerPolicy: 
  webGLMemorySize: 32
  webGLExceptionSupport: 1
  webGLNameFilesAsHashes: 0
  webGLShowDiagnostics: 0
  webGLDataCaching: 1
  webGLDebugSymbols: 0
  webGLEmscriptenArgs: 
  webGLModulesDirectory: 
  webGLTemplate: APPLICATION:Default
  webGLAnalyzeBuildSize: 0
  webGLUseEmbeddedResources: 0
  webGLCompressionFormat: 0
  webGLWasmArithmeticExceptions: 0
  webGLLinkerTarget: 1
  webGLThreadsSupport: 0
  webGLDecompressionFallback: 0
  webGLInitialMemorySize: 32
  webGLMaximumMemorySize: 2048
  webGLMemoryGrowthMode: 2
  webGLMemoryLinearGrowthStep: 16
  webGLMemoryGeometricGrowthStep: 0.2
  webGLMemoryGeometricGrowthCap: 96
  webGLPowerPreference: 2
  scriptingDefineSymbols: {}
  additionalCompilerArguments: {}
  platformArchitecture: {}
  scriptingBackend:
    Standalone: 1
  il2cppCompilerConfiguration: {}
  il2cppCodeGeneration: {}
  managedStrippingLevel:
    EmbeddedLinux: 1
    GameCoreScarlett: 1
    GameCoreXboxOne: 1
    Nintendo Switch: 1
    PS4: 1
    PS5: 1
    QNX: 1
    Stadia: 1
    VisionOS: 1
    WebGL: 1
    Windows Store Apps: 1
    XboxOne: 1
    iPhone: 1
    tvOS: 1
  incrementalIl2cppBuild: {}
  suppressCommonWarnings: 1
  allowUnsafeCode: 0
  useDeterministicCompilation: 1
  additionalIl2CppArgs: 
  scriptingRuntimeVersion: 1
  gcIncremental: 1
  gcWBarrierValidation: 0
  apiCompatibilityLevelPerPlatform: {}
  m_RenderingPath: 1
  m_MobileRenderingPath: 1
  metroPackageName: 2D_BuiltInRenderer
  metroPackageVersion: 
  metroCertificatePath: 
  metroCertificatePassword: 
  metroCertificateSubject: 
  metroCertificateIssuer: 
  metroCertificateNotAfter: 0000000000000000
  metroApplicationDescription: 2D_BuiltInRenderer
  wsaImages: {}
  metroTileShortName: 
  metroTileShowName: 0
  metroMediumTileShowName: 0
  metroLargeTileShowName: 0
  metroWideTileShowName: 0
  metroSupportStreamingInstall: 0
  metroLastRequiredScene: 0
  metroDefaultTileSize: 1
  metroTileForegroundText: 2
  metroTileBackgroundColor: {r: 0.13333334, g: 0.17254902, b: 0.21568628, a: 0}
  metroSplashScreenBackgroundColor: {r: 0.12941177, g: 0.17254902, b: 0.21568628, a: 1}
  metroSplashScreenUseBackgroundColor: 0
  platformCapabilities: {}
  metroTargetDeviceFamilies: {}
  metroFTAName: 
  metroFTAFileTypes: []
  metroProtocolName: 
  vcxProjDefaultLanguage: 
  XboxOneProductId: 
  XboxOneUpdateKey: 
  XboxOneSandboxId: 
  XboxOneContentId: 
  XboxOneTitleId: 
  XboxOneSCId: 
  XboxOneGameOsOverridePath: 
  XboxOnePackagingOverridePath: 
  XboxOneAppManifestOverridePath: 
  XboxOneVersion: 1.0.0.0
  XboxOnePackageEncryption: 0
  XboxOnePackageUpdateGranularity: 2
  XboxOneDescription: 
  XboxOneLanguage:
  - enus
  XboxOneCapability: []
  XboxOneGameRating: {}
  XboxOneIsContentPackage: 0
  XboxOneEnhancedXboxCompatibilityMode: 0
  XboxOneEnableGPUVariability: 1
  XboxOneSockets: {}
  XboxOneSplashScreen: {fileID: 0}
  XboxOneAllowedProductIds: []
  XboxOnePersistentLocalStorageSize: 0
  XboxOneXTitleMemory: 8
  XboxOneOverrideIdentityName: 
  XboxOneOverrideIdentityPublisher: 
  vrEditorSettings: {}
  cloudServicesEnabled: {}
  luminIcon:
    m_Name: 
    m_ModelFolderPath: 
    m_PortalFolderPath: 
  luminCert:
    m_CertPath: 
    m_SignPackage: 1
  luminIsChannelApp: 0
  luminVersion:
    m_VersionCode: 1
    m_VersionName: 
  hmiPlayerDataPath: 
  hmiForceSRGBBlit: 1
  embeddedLinuxEnableGamepadInput: 1
  hmiLogStartupTiming: 0
  hmiCpuConfiguration: 
  apiCompatibilityLevel: 6
  activeInputHandler: 2
  windowsGamepadBackendHint: 0
  cloudProjectId: 
  framebufferDepthMemorylessMode: 0
  qualitySettingsNames: []
  projectName: 
  organizationId: 
  cloudEnabled: 0
  legacyClampBlendShapeWeights: 0
  hmiLoadingImage: {fileID: 0}
  platformRequiresReadableAssets: 0
  virtualTexturingSupportEnabled: 0
  insecureHttpOption: 0



================================================
FILE: src/R3.Unity/ProjectSettings/ProjectVersion.txt
================================================
m_EditorVersion: 2022.3.16f1
m_EditorVersionWithRevision: 2022.3.16f1 (d2c21f0ef2f1)



================================================
FILE: src/R3.Unity/ProjectSettings/QualitySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!47 &1
QualitySettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_CurrentQuality: 5
  m_QualitySettings:
  - serializedVersion: 2
    name: Very Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 15
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 1
    textureQuality: 1
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.3
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.4
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 16
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Medium
    pixelLightCount: 1
    shadows: 1
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 0.7
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 64
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: High
    pixelLightCount: 2
    shadows: 2
    shadowResolution: 1
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 40
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 2
    textureQuality: 0
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 256
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Very High
    pixelLightCount: 3
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 70
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 4
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 1.5
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 1024
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Ultra
    pixelLightCount: 4
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 4
    shadowDistance: 150
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 255
    textureQuality: 0
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    vSyncCount: 1
    lodBias: 2
    maximumLODLevel: 0
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    excludedTargetPlatforms: []
  m_PerPlatformDefaultQuality:
    Android: 2
    Lumin: 5
    GameCoreScarlett: 5
    GameCoreXboxOne: 5
    Nintendo Switch: 5
    PS4: 5
    PS5: 5
    Stadia: 5
    Standalone: 5
    WebGL: 3
    Windows Store Apps: 5
    XboxOne: 5
    iPhone: 2
    tvOS: 2



================================================
FILE: src/R3.Unity/ProjectSettings/SceneTemplateSettings.json
================================================
{
    "templatePinStates": [],
    "dependencyTypeInfos": [
        {
            "userAdded": false,
            "type": "UnityEngine.AnimationClip",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Animations.AnimatorController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.AnimatorOverrideController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Audio.AudioMixerController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ComputeShader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Cubemap",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.GameObject",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.LightingDataAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.LightingSettings",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Material",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.MonoScript",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicMaterial",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicsMaterial2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessResources",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.VolumeProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.SceneAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Shader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ShaderVariantCollection",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Timeline.TimelineAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        }
    ],
    "defaultDependencyTypeInfo": {
        "userAdded": false,
        "type": "<default_scene_template_dependencies>",
        "ignore": false,
        "defaultInstantiationMode": 1,
        "supportsModification": true
    },
    "newSceneOverride": 0
}


================================================
FILE: src/R3.Unity/ProjectSettings/TagManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!78 &1
TagManager:
  serializedVersion: 2
  tags: []
  layers:
  - Default
  - TransparentFX
  - Ignore Raycast
  - 
  - Water
  - UI
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  m_SortingLayers:
  - name: Default
    uniqueID: 0
    locked: 0



================================================
FILE: src/R3.Unity/ProjectSettings/TimeManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!5 &1
TimeManager:
  m_ObjectHideFlags: 0
  Fixed Timestep: 0.02
  Maximum Allowed Timestep: 0.33333334
  m_TimeScale: 1
  Maximum Particle Timestep: 0.03



================================================
FILE: src/R3.Unity/ProjectSettings/UnityConnectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!310 &1
UnityConnectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 1
  m_Enabled: 0
  m_TestMode: 0
  m_EventOldUrl: https://api.uca.cloud.unity3d.com/v1/events
  m_EventUrl: https://cdp.cloud.unity3d.com/v1/events
  m_ConfigUrl: https://config.uca.cloud.unity3d.com
  m_DashboardUrl: https://dashboard.unity3d.com
  m_TestInitMode: 0
  CrashReportingSettings:
    m_EventUrl: https://perf-events.cloud.unity3d.com
    m_Enabled: 0
    m_LogBufferSize: 10
    m_CaptureEditorExceptions: 1
  UnityPurchasingSettings:
    m_Enabled: 0
    m_TestMode: 0
  UnityAnalyticsSettings:
    m_Enabled: 0
    m_TestMode: 0
    m_InitializeOnStartup: 1
  UnityAdsSettings:
    m_Enabled: 0
    m_InitializeOnStartup: 1
    m_TestMode: 0
    m_IosGameId: 
    m_AndroidGameId: 
    m_GameIds: {}
    m_GameId: 
  PerformanceReportingSettings:
    m_Enabled: 0



================================================
FILE: src/R3.Unity/ProjectSettings/VersionControlSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!890905787 &1
VersionControlSettings:
  m_ObjectHideFlags: 0
  m_Mode: Visible Meta Files
  m_CollabEditorSettings:
    inProgressEnabled: 1



================================================
FILE: src/R3.Unity/ProjectSettings/VFXManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!937362698 &1
VFXManager:
  m_ObjectHideFlags: 0
  m_IndirectShader: {fileID: 0}
  m_CopyBufferShader: {fileID: 0}
  m_SortShader: {fileID: 0}
  m_StripUpdateShader: {fileID: 0}
  m_RenderPipeSettingsPath: 
  m_FixedTimeStep: 0.016666668
  m_MaxDeltaTime: 0.05
  m_CompiledVersion: 0
  m_RuntimeVersion: 0



================================================
FILE: src/R3.Unity/ProjectSettings/XRSettings.asset
================================================
{
    "m_SettingKeys": [
        "VR Device Disabled",
        "VR Device User Alert"
    ],
    "m_SettingValues": [
        "False",
        "False"
    ]
}


================================================
FILE: src/R3.Uno/IApplicationBuilderR3InitializeExtensions.cs
================================================
﻿using Microsoft.Extensions.Logging;
using R3;
using Uno.Extensions;
using Uno.Extensions.Hosting;

namespace Uno; // Uno namespace

public static class IApplicationBuilderR3InitializeExtensions
{
    public static IApplicationBuilder UseR3(this IApplicationBuilder builder)
    {
        UnoProviderInitializer.SetDefaultObservableSystem(ex => builder.Log().LogError("R3 Unhandled Exception {0}", ex));
        return builder;
    }

    public static IApplicationBuilder UseR3(this IApplicationBuilder builder, Action<Exception> unhandledExceptionHandler)
    {
        UnoProviderInitializer.SetDefaultObservableSystem(unhandledExceptionHandler);
        return builder;
    }
}



================================================
FILE: src/R3.Uno/ObserveOnExtensions.cs
================================================
﻿using Windows.UI.Core;
using Microsoft.UI.Xaml;
using R3.Collections;
using Windows.Foundation;

namespace R3; // using R3

public static class ObserveOnExtensions
{
    public static Observable<T> ObserveOnDispatcher<T>(this Observable<T> source, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority = null)
    {
        return new ObserveOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> ObserveOnCurrentWindowDispatcher<T>(this Observable<T> source, CoreDispatcherPriority? dispatcherPriority = null)
    {
        return ObserveOnDispatcher(source, Window.Current!.Dispatcher, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnDispatcher<T>(this Observable<T> source, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority = null)
    {
        return new SubscribeOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnCurrentWindowDispatcher<T>(this Observable<T> source, CoreDispatcherPriority? dispatcherPriority = null)
    {
        return SubscribeOnDispatcher(source, Window.Current!.Dispatcher, dispatcherPriority);
    }
}

internal sealed class ObserveOnDispatcher<T>(Observable<T> source, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOnDispatcher(observer, dispatcher, dispatcherPriority));
    }

    sealed class _ObserveOnDispatcher : Observer<T>
    {
        readonly DispatchedHandler postCallback;

        readonly Observer<T> observer;
        readonly CoreDispatcher dispatcher;
        readonly CoreDispatcherPriority? dispatcherPriority;
        readonly object gate = new object();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOnDispatcher(Observer<T> observer, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority)
        {
            this.observer = observer;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = DrainMessages;
        }

        protected override void OnNextCore(T value)
        {
            EnqueueValue(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    if (dispatcherPriority == null)
                    {
                        _ = dispatcher.RunAsync(CoreDispatcherPriority.Normal, postCallback);
                    }
                    else
                    {
                        _ = dispatcher.RunAsync(dispatcherPriority.Value, postCallback);
                    }
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }

        void DrainMessages()
        {
            var self = this;

            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (self.gate)
            {
                values = self.list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

        FINALIZE:
            lock (self.gate)
            {
                self.list.Clear(token);

                if (self.IsDisposed)
                {
                    self.running = false;
                    return;
                }

                if (self.list.HasValue)
                {
                    // post again
                    if (dispatcherPriority == null)
                    {
                        _ = dispatcher.RunAsync(CoreDispatcherPriority.Normal, postCallback);
                    }
                    else
                    {
                        _ = dispatcher.RunAsync(dispatcherPriority.Value, postCallback);
                    }
                    return;
                }
                else
                {
                    self.running = false;
                    return;
                }
            }
        }
    }
}

internal sealed class SubscribeOnDispatcher<T>(Observable<T> source, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOnDispatcher(observer, source, dispatcher, dispatcherPriority).Run();
    }

    sealed class _SubscribeOnDispatcher : Observer<T>
    {
        readonly DispatchedHandler postCallback;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly CoreDispatcher dispatcher;
        readonly CoreDispatcherPriority? dispatcherPriority;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOnDispatcher(Observer<T> observer, Observable<T> source, CoreDispatcher dispatcher, CoreDispatcherPriority? dispatcherPriority)
        {
            this.observer = observer;
            this.source = source;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = Subscribe;
        }

        public IDisposable Run()
        {
            if (dispatcherPriority == null)
            {
                _ = dispatcher.RunAsync(CoreDispatcherPriority.Normal, postCallback);
            }
            else
            {
                _ = dispatcher.RunAsync(dispatcherPriority.Value, postCallback);
            }
            return this;
        }

        void Subscribe()
        {
            disposable.Disposable = source.Subscribe(this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}



================================================
FILE: src/R3.Uno/R3.Uno.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <NoWarn>1701;1702;CS8002</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.Uno</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>Uno Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Uno.Extensions.Logging.WinUI" Version="5.2.7" />
        <PackageReference Include="Uno.Extensions.Hosting.WinUI" Version="5.2.7" />
        <PackageReference Include="Uno.WinUI" Version="5.6.33" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3.Uno/UnoDispatcherFrameProvider.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using R3.Collections;

namespace R3;

public sealed class UnoRenderingFrameProvider : FrameProvider, IDisposable
{
    public static readonly FrameProvider Default = new UnoRenderingFrameProvider(isDefaultFrameProvider: true);

    readonly bool isDefaultFrameProvider = false;
    bool disposed;
    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    EventHandler<object> messageLoop;

    UnoRenderingFrameProvider(bool isDefaultFrameProvider) // ctor for default
        : this()
    {
        this.isDefaultFrameProvider = isDefaultFrameProvider;
    }

    public UnoRenderingFrameProvider()
    {
        this.messageLoop = Run;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        Microsoft.UI.Xaml.Media.CompositionTarget.Rendering += messageLoop;
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(UnoRenderingFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(UnoRenderingFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        if (isDefaultFrameProvider) return; // default don't dispose

        disposed = true;
        Microsoft.UI.Xaml.Media.CompositionTarget.Rendering -= messageLoop;
        list.Dispose();
    }

    void Run(object? sender, object e)
    {
        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler()?.Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3.Uno/UnoDispatcherTimeProvider.cs
================================================
﻿using Microsoft.UI.Xaml;
using System.Threading.Tasks;
using System.Threading;
using System;

namespace R3;

public sealed class UnoDispatcherTimeProvider : TimeProvider
{
    public static readonly TimeProvider Default = new UnoDispatcherTimeProvider();

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new UnoDispatcherTimeProviderTimer(callback, state, dueTime, period);
    }
}

internal sealed class UnoDispatcherTimeProviderTimer : ITimer
{
    DispatcherTimer? timer;
    TimerCallback callback;
    object? state;
    EventHandler<object> timerTick;
    TimeSpan? period;
    short timerId;

    public UnoDispatcherTimeProviderTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.timerTick = Timer_Tick;
        this.callback = callback;
        this.state = state;
        this.timer = new DispatcherTimer();

        timer.Tick += timerTick;

        if (dueTime != Timeout.InfiniteTimeSpan)
        {
            Change(dueTime, period);
        }
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (timer != null)
        {
            this.period = period;
            timer.Interval = dueTime;

            // when start, change timerId.
            unchecked { timerId++; }
            timer.Start();
            return true;
        }
        return false;
    }

    void Timer_Tick(object? sender, object e)
    {
        var id = timerId;
        callback(state);
        if (id != timerId)
        {
            // called new timer status, do nothing.
            return;
        }

        if (timer != null && period != null)
        {
            if (period.Value == Timeout.InfiniteTimeSpan)
            {
                period = null;
                unchecked { timerId++; }
                timer.Stop();
            }
            else
            {
                timer.Interval = period.Value;
                period = null;
                unchecked { timerId++; }
                timer.Start();
            }
        }
    }

    public void Dispose()
    {
        if (timer != null)
        {
            unchecked { timerId++; }
            timer.Stop();
            timer.Tick -= timerTick;
            timer = null;
        }
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.Uno/UnoProviderInitializer.cs
================================================
﻿namespace R3;

public static class UnoProviderInitializer
{
    public static void SetDefaultObservableSystem(Action<Exception>? unhandledExceptionHandler = null)
    {
        if (unhandledExceptionHandler is not null)
        {
            ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        }

        ObservableSystem.DefaultTimeProvider = UnoDispatcherTimeProvider.Default;
        ObservableSystem.DefaultFrameProvider = UnoRenderingFrameProvider.Default;
    }
}



================================================
FILE: src/R3.WinForms/DisposableExtensions.cs
================================================
﻿using System;
using System.ComponentModel;

namespace R3.WinForms;

public static class DisposableExtensions
{
    /// <summary>
    /// Destroy objects that implement <see cref="IDisposable"/> in sync with <see cref="IContainer"/>.
    /// </summary>
    /// <param name="disposable">Objects to be disposed</param>
    /// <param name="container">Container to manage object lifetime</param>
    /// <remarks>If a form does not have a member derived from a <seealso cref="Component"/> (such as <see cref="System.Windows.Forms.Timer"/>, but not <see cref="System.Windows.Forms.Control"/>), the container is not created by the form designer.</remarks>
    public static void AddTo(this IDisposable disposable, IContainer? container)
    {
        container?.Add(new DisposableWrapper(disposable));
    }

    private sealed class DisposableWrapper(IDisposable disposable) : Component
    {
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                disposable.Dispose();
            }

            base.Dispose(disposing);
        }
    }
}



================================================
FILE: src/R3.WinForms/Polyfills.cs
================================================
﻿#if !NET5_0_OR_GREATER

namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit
    {
    }
}

#endif



================================================
FILE: src/R3.WinForms/R3.WinForms.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net6.0-windows;net8.0-windows;net472</TargetFrameworks>
        <UseWindowsForms>true</UseWindowsForms>
        <LangVersion>12</LangVersion>
        <ImplicitUsings>disable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.WinForms</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>WinForms Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3.WinForms/WinFormsFrameProvider.cs
================================================
﻿using System;
using System.Windows.Forms;

using R3.Collections;

namespace R3.WinForms;

public delegate bool MessageFilter(in Message message);

public sealed class WinFormsFrameProvider :
    FrameProvider,
    IDisposable
{
    public static readonly FrameProvider Default = new WinFormsFrameProvider(true);

    bool isDefaultFrameProvider = false;
    private bool disposed;
    private long frameCount;
    private FreeListCore<IFrameRunnerWorkItem> list;
    private readonly object gate = new object();
    private readonly MessageHook filter;
    private readonly MessageFilter? predicate;

     WinFormsFrameProvider(bool _) : this()
    {
        isDefaultFrameProvider = true;
    }

    public WinFormsFrameProvider()
        : this(null)
    {
    }

    public WinFormsFrameProvider(
        MessageFilter? predicate)
    {
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        this.filter = new MessageHook(this);
        this.predicate = predicate;

        Application.AddMessageFilter(this.filter);
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(WinFormsFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(WinFormsFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        if (isDefaultFrameProvider) return;

        disposed = true;
        Application.RemoveMessageFilter(this.filter);
        list.Dispose();
    }

    private void Run(in Message message)
    {
        if (this.predicate is {} p && !p(message))
        {
            return;
        }

        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch
                    {
                    }
                }
            }
        }
    }

    private static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    private static void ThrowObjectDisposedException(Type? type) =>
        throw new ObjectDisposedException(type?.FullName);

    private sealed class MessageHook(WinFormsFrameProvider parent) : IMessageFilter
    {
        public bool PreFilterMessage(ref Message m)
        {
            parent.Run(in m);
            return false;
        }
    }
}



================================================
FILE: src/R3.WinForms/WinFormsProviderInitializer.cs
================================================
﻿using System;
using System.ComponentModel;

namespace R3.WinForms;

public static class WinFormsProviderInitializer
{
    public static void SetDefaultObservableSystem(
        Action<Exception> unhandledExceptionHandler)
    {
        SetDefaultObservableSystem(unhandledExceptionHandler, null);
    }

    public static void SetDefaultObservableSystem(
        Action<Exception> unhandledExceptionHandler,
        ISynchronizeInvoke? marshalingControl)
    {
        SetDefaultObservableSystem(unhandledExceptionHandler, marshalingControl, null);
    }

    public static void SetDefaultObservableSystem(
        Action<Exception> unhandledExceptionHandler,
        ISynchronizeInvoke? marshalingControl,
        MessageFilter? isStepFrame)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = (marshalingControl == null) ? WinFormsTimeProvider.Default : new WinFormsTimeProvider(marshalingControl);
        ObservableSystem.DefaultFrameProvider = (isStepFrame == null) ? WinFormsFrameProvider.Default : new WinFormsFrameProvider(isStepFrame);
    }
}



================================================
FILE: src/R3.WinForms/WinFormsTimeProvider.cs
================================================
﻿using System;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

using ThreadingTimer = System.Threading.Timer;

namespace R3.WinForms;

public sealed class WinFormsTimeProvider(ISynchronizeInvoke? marshalingControl) : TimeProvider
{
    public static readonly TimeProvider Default = new WinFormsTimeProvider();

    public WinFormsTimeProvider()
        : this(null)
    {
    }

    public override ITimer CreateTimer(
        TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new WinFormsTimeProviderTimer(
            marshalingControl,
            SynchronizationContext.Current as WindowsFormsSynchronizationContext,
            callback,
            state,
            dueTime,
            period);
    }
}

internal sealed class WinFormsTimeProviderTimer : ITimer
{
    public WinFormsTimeProviderTimer(
        ISynchronizeInvoke? marshalingControl,
        WindowsFormsSynchronizationContext? synchronizationContext,
        TimerCallback callback,
        object? state,
        TimeSpan dueTime,
        TimeSpan period)
    {
        if (marshalingControl is null && synchronizationContext is null)
        {
            throw new ArgumentNullException(nameof(marshalingControl));
        }

        var context = new TimerContext(
            marshalingControl,
            synchronizationContext,
            callback,
            state);

        this._timer = new ThreadingTimer(InvokeCallback, context, dueTime, period);

        static void InvokeCallback(object? context)
        {
            var (control, syncCtx, callback, state) = (TimerContext)context!;

            if (control is not null)
            {
                if (control.InvokeRequired)
                {
                    control.Invoke(callback, [state]);
                }
                else
                {
                    callback(state);
                }
            }
            else if (syncCtx is not null)
            {
                syncCtx.Send(new SendOrPostCallback(callback), state);
            }
        }
    }

    private record TimerContext(
        ISynchronizeInvoke? Control,
        WindowsFormsSynchronizationContext? SynchronizationContext,
        TimerCallback Callback,
        object? State);

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        return this._timer.Change(dueTime, period);
    }

    public void Dispose()
    {
        this._timer.Dispose();
    }

    public ValueTask DisposeAsync()
    {
        this.Dispose();
        return default;
    }

    private readonly ThreadingTimer _timer;
}



================================================
FILE: src/R3.WinUI3/R3.WinUI3.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFrameworks>net6.0-windows10.0.19041.0</TargetFrameworks>
        <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
        <Nullable>enable</Nullable>
        <RootNamespace>R3.WinUI3</RootNamespace>
        <RuntimeIdentifiers>win10-x86;win10-x64;win10-arm64</RuntimeIdentifiers>
        <UseWinUI>true</UseWinUI>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>

        <!-- For CI Build -->
        <!-- https://github.com/dotnet/maui/issues/5886 -->
        <EnablePreviewMsixTooling>true</EnablePreviewMsixTooling>
        <GenerateLibraryLayout>true</GenerateLibraryLayout>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.WinUI3</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>WinUI3 Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.WindowsAppSDK" Version="1.4.230913002" />
    </ItemGroup>

    <ItemGroup Condition="$(TargetFramework) == 'net6.0-windows10.0.19041.0'">
        <PackageReference Include="Microsoft.Bcl.TimeProvider" Version="8.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>
</Project>



================================================
FILE: src/R3.WinUI3/WinUI3DispatcherTimeProvider.cs
================================================
﻿using Microsoft.UI.Xaml;
using System.Threading.Tasks;
using System.Threading;
using System;

namespace R3;

public sealed class WinUI3DispatcherTimeProvider : TimeProvider
{
    public static readonly TimeProvider Default = new WinUI3DispatcherTimeProvider();

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new WinUI3DispatcherTimeProviderTimer(callback, state, dueTime, period);
    }
}

internal sealed class WinUI3DispatcherTimeProviderTimer : ITimer
{
    DispatcherTimer? timer;
    TimerCallback callback;
    object? state;
    EventHandler<object> timerTick;
    TimeSpan? period;
    short timerId;

    public WinUI3DispatcherTimeProviderTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.timerTick = Timer_Tick;
        this.callback = callback;
        this.state = state;
        this.timer = new DispatcherTimer();

        timer.Tick += timerTick;

        if (dueTime != Timeout.InfiniteTimeSpan)
        {
            Change(dueTime, period);
        }
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (timer != null)
        {
            this.period = period;
            timer.Interval = dueTime;

            // when start, change timerId.
            unchecked { timerId++; }
            timer.Start();
            return true;
        }
        return false;
    }

    void Timer_Tick(object? sender, object e)
    {
        var id = timerId;
        callback(state);
        if (id != timerId)
        {
            // called new timer status, do nothing.
            return;
        }

        if (timer != null && period != null)
        {
            if (period.Value == Timeout.InfiniteTimeSpan)
            {
                period = null;
                unchecked { timerId++; }
                timer.Stop();
            }
            else
            {
                timer.Interval = period.Value;
                period = null;
                unchecked { timerId++; }
                timer.Start();
            }
        }
    }

    public void Dispose()
    {
        if (timer != null)
        {
            unchecked { timerId++; }
            timer.Stop();
            timer.Tick -= timerTick;
            timer = null;
        }
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.WinUI3/WinUI3ProviderInitializer.cs
================================================
﻿using System;
using System.Windows;

namespace R3;

public static class WinUI3ProviderInitializer
{
    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = WinUI3DispatcherTimeProvider.Default;
        ObservableSystem.DefaultFrameProvider = WinUI3RenderingFrameProvider.Default;
    }
}



================================================
FILE: src/R3.WinUI3/WinUI3RenderingFrameProvider.cs
================================================
﻿using System;
using System.Diagnostics.CodeAnalysis;
using R3.Collections;

namespace R3;

public sealed class WinUI3RenderingFrameProvider : FrameProvider, IDisposable
{
    public static readonly FrameProvider Default = new WinUI3RenderingFrameProvider(true);

    readonly bool isDefaultProvider;
    bool disposed;
    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    EventHandler<object> messageLoop;

    WinUI3RenderingFrameProvider(bool _) : this()
    {
        isDefaultProvider = true;
    }

    public WinUI3RenderingFrameProvider()
    {
        this.messageLoop = Run;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        Microsoft.UI.Xaml.Media.CompositionTarget.Rendering += messageLoop;
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(WinUI3RenderingFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(WinUI3RenderingFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        if (isDefaultProvider) return;

        disposed = true;
        Microsoft.UI.Xaml.Media.CompositionTarget.Rendering -= messageLoop;
        list.Dispose();
    }

    void Run(object? sender, object e)
    {
        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: src/R3.WPF/ObserveOnExtensions.cs
================================================
﻿using R3.Collections;
using System.Windows.Threading;

namespace R3; // using R3

public static class ObserveOnExtensions
{
    public static Observable<T> ObserveOnDispatcher<T>(this Observable<T> source, Dispatcher dispatcher, DispatcherPriority dispatcherPriority = DispatcherPriority.Normal)
    {
        return new ObserveOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> ObserveOnCurrentDispatcher<T>(this Observable<T> source, DispatcherPriority dispatcherPriority = DispatcherPriority.Normal)
    {
        return ObserveOnDispatcher(source, Dispatcher.CurrentDispatcher, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnDispatcher<T>(this Observable<T> source, Dispatcher dispatcher, DispatcherPriority dispatcherPriority = DispatcherPriority.Normal)
    {
        return new SubscribeOnDispatcher<T>(source, dispatcher, dispatcherPriority);
    }

    public static Observable<T> SubscribeOnCurrentDispatcher<T>(this Observable<T> source, DispatcherPriority dispatcherPriority = DispatcherPriority.Normal)
    {
        return SubscribeOnDispatcher(source, Dispatcher.CurrentDispatcher, dispatcherPriority);
    }
}

internal sealed class ObserveOnDispatcher<T>(Observable<T> source, Dispatcher dispatcher, DispatcherPriority dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return source.Subscribe(new _ObserveOnDispatcher(observer, dispatcher, dispatcherPriority));
    }

    sealed class _ObserveOnDispatcher : Observer<T>
    {
        readonly Action postCallback;

        readonly Observer<T> observer;
        readonly Dispatcher dispatcher;
        readonly DispatcherPriority dispatcherPriority;
        readonly object gate = new object();
        SwapListCore<Notification<T>> list;
        bool running;

        protected override bool AutoDisposeOnCompleted => false;

        public _ObserveOnDispatcher(Observer<T> observer, Dispatcher dispatcher, DispatcherPriority dispatcherPriority)
        {
            this.observer = observer;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = DrainMessages;
        }

        protected override void OnNextCore(T value)
        {
            EnqueueValue(new(value));
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            EnqueueValue(new(error));
        }

        protected override void OnCompletedCore(Result result)
        {
            EnqueueValue(new(result));
        }

        void EnqueueValue(Notification<T> value)
        {
            lock (gate)
            {
                if (IsDisposed) return;
                list.Add(value);

                if (!running)
                {
                    running = true;
                    dispatcher.InvokeAsync(postCallback, dispatcherPriority);
                }
            }
        }

        protected override void DisposeCore()
        {
            lock (gate)
            {
                list.Dispose();
            }
        }

        void DrainMessages()
        {
            var self = this;

            ReadOnlySpan<Notification<T>> values;
            bool token;
            lock (self.gate)
            {
                values = self.list.Swap(out token);
                if (values.Length == 0)
                {
                    goto FINALIZE;
                }
            }

            foreach (var value in values)
            {
                try
                {
                    switch (value.Kind)
                    {
                        case NotificationKind.OnNext:
                            self.observer.OnNext(value.Value!);
                            break;
                        case NotificationKind.OnErrorResume:
                            self.observer.OnErrorResume(value.Error!);
                            break;
                        case NotificationKind.OnCompleted:
                            try
                            {
                                self.observer.OnCompleted(value.Result!);
                            }
                            finally
                            {
                                self.Dispose();
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }

        FINALIZE:
            lock (self.gate)
            {
                self.list.Clear(token);

                if (self.IsDisposed)
                {
                    self.running = false;
                    return;
                }

                if (self.list.HasValue)
                {
                    // post again
                    dispatcher.InvokeAsync(postCallback, dispatcherPriority);
                    return;
                }
                else
                {
                    self.running = false;
                    return;
                }
            }
        }
    }
}

internal sealed class SubscribeOnDispatcher<T>(Observable<T> source, Dispatcher dispatcher, DispatcherPriority dispatcherPriority) : Observable<T>
{
    protected override IDisposable SubscribeCore(Observer<T> observer)
    {
        return new _SubscribeOnDispatcher(observer, source, dispatcher, dispatcherPriority).Run();
    }

    sealed class _SubscribeOnDispatcher : Observer<T>
    {
        readonly Action postCallback;

        readonly Observer<T> observer;
        readonly Observable<T> source;
        readonly Dispatcher dispatcher;
        readonly DispatcherPriority dispatcherPriority;
        SingleAssignmentDisposableCore disposable;

        public _SubscribeOnDispatcher(Observer<T> observer, Observable<T> source, Dispatcher dispatcher, DispatcherPriority dispatcherPriority)
        {
            this.observer = observer;
            this.source = source;
            this.dispatcher = dispatcher;
            this.dispatcherPriority = dispatcherPriority;
            this.postCallback = Subscribe;
        }

        public IDisposable Run()
        {
            dispatcher.InvokeAsync(postCallback, dispatcherPriority);
            return this;
        }

        void Subscribe()
        {
            disposable.Disposable = source.Subscribe(this);
        }

        protected override void OnNextCore(T value)
        {
            observer.OnNext(value);
        }

        protected override void OnErrorResumeCore(Exception error)
        {
            observer.OnErrorResume(error);
        }

        protected override void OnCompletedCore(Result result)
        {
            observer.OnCompleted(result);
        }

        protected override void DisposeCore()
        {
            disposable.Dispose();
        }
    }
}



================================================
FILE: src/R3.WPF/R3.WPF.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFrameworks>net6.0-windows;net7.0-windows;net8.0-windows;net472;</TargetFrameworks>
        <Nullable>enable</Nullable>
        <UseWPF>true</UseWPF>
        <LangVersion>12</LangVersion>
        <ImplicitUsings>enable</ImplicitUsings>
        <EnableWindowsTargeting>true</EnableWindowsTargeting>

        <GenerateDocumentationFile>true</GenerateDocumentationFile>
        <NoWarn>1701;1702;1591;1573</NoWarn>

        <!-- NuGet Packaging -->
        <IsPackable>true</IsPackable>
        <PackageId>R3Extensions.WPF</PackageId>
        <PackageTags>rx</PackageTags>
        <Description>WPF Provider and Methods for R3.</Description>
    </PropertyGroup>

    <ItemGroup>
        <ProjectReference Include="..\R3\R3.csproj" />
    </ItemGroup>

</Project>



================================================
FILE: src/R3.WPF/WpfDispatcherTimeProvider.cs
================================================
﻿using System.Windows.Threading;

namespace R3;

public sealed class WpfDispatcherTimeProvider : TimeProvider
{
    public static readonly TimeProvider Default = new WpfDispatcherTimeProvider();

    readonly DispatcherPriority? priority;
    readonly Dispatcher? dispatcher;

    public WpfDispatcherTimeProvider()
    {
        this.priority = null;
        this.dispatcher = null;
    }

    public WpfDispatcherTimeProvider(DispatcherPriority priority)
    {
        this.priority = priority;
        this.dispatcher = null;
    }

    public WpfDispatcherTimeProvider(DispatcherPriority priority, Dispatcher dispatcher)
    {
        this.priority = priority;
        this.dispatcher = dispatcher;
    }

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        return new WpfDispatcherTimeProviderTimer(priority, dispatcher, callback, state, dueTime, period);
    }
}

internal sealed class WpfDispatcherTimeProviderTimer : ITimer
{
    DispatcherTimer? timer;
    TimerCallback callback;
    object? state;
    EventHandler timerTick;
    TimeSpan? period;
    short timerId;

    public WpfDispatcherTimeProviderTimer(DispatcherPriority? priority, Dispatcher? dispatcher, TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        this.timerTick = Timer_Tick;
        this.callback = callback;
        this.state = state;
        if (priority == null && dispatcher == null)
        {
            this.timer = new DispatcherTimer();
        }
        else if (dispatcher == null) // priority is not null
        {
            this.timer = new DispatcherTimer(priority!.Value);
        }
        else
        {
            this.timer = new DispatcherTimer(priority!.Value, dispatcher);
        }

        timer.Tick += timerTick;

        if (dueTime != Timeout.InfiniteTimeSpan)
        {
            Change(dueTime, period);
        }
    }

    public bool Change(TimeSpan dueTime, TimeSpan period)
    {
        if (timer != null)
        {
            this.period = period;
            timer.Interval = dueTime;

            // when start, change timerId.
            unchecked { timerId++; }
            timer.Start();
            return true;
        }
        return false;
    }

    void Timer_Tick(object? sender, EventArgs e)
    {
        var id = timerId;
        callback(state);
        if (id != timerId)
        {
            // called new timer status, do nothing.
            return;
        }

        if (timer != null && period != null)
        {
            if (period.Value == Timeout.InfiniteTimeSpan)
            {
                period = null;
                unchecked { timerId++; }
                timer.Stop();
            }
            else
            {
                timer.Interval = period.Value;
                period = null;
                unchecked { timerId++; }
                timer.Start();
            }
        }
    }

    public void Dispose()
    {
        if (timer != null)
        {
            unchecked { timerId++; }
            timer.Stop();
            timer.Tick -= timerTick;
            timer = null;
        }
    }

    public ValueTask DisposeAsync()
    {
        Dispose();
        return default;
    }
}



================================================
FILE: src/R3.WPF/WpfProviderInitializer.cs
================================================
﻿using System.Windows;
using System.Windows.Threading;

namespace R3;

public static class WpfProviderInitializer
{
    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = WpfDispatcherTimeProvider.Default;
        ObservableSystem.DefaultFrameProvider = WpfRenderingFrameProvider.Default;
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler, DispatcherPriority priority)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new WpfDispatcherTimeProvider(priority);
        ObservableSystem.DefaultFrameProvider = WpfRenderingFrameProvider.Default;
    }

    public static void SetDefaultObservableSystem(Action<Exception> unhandledExceptionHandler, DispatcherPriority priority, Dispatcher dispatcher)
    {
        ObservableSystem.RegisterUnhandledExceptionHandler(unhandledExceptionHandler);
        ObservableSystem.DefaultTimeProvider = new WpfDispatcherTimeProvider(priority, dispatcher);
        ObservableSystem.DefaultFrameProvider = WpfRenderingFrameProvider.Default;
    }
}



================================================
FILE: src/R3.WPF/WpfRenderingFrameProvider.cs
================================================
﻿using System.Diagnostics.CodeAnalysis;
using R3.Collections;

namespace R3;

public sealed class WpfRenderingFrameProvider : FrameProvider, IDisposable
{
    public static readonly FrameProvider Default = new WpfRenderingFrameProvider(true);

    bool isDefaultProvider = false;
    bool disposed;
    long frameCount;
    FreeListCore<IFrameRunnerWorkItem> list;
    readonly object gate = new object();

    EventHandler messageLoop;

    WpfRenderingFrameProvider(bool _)
        : this()
    {
        isDefaultProvider = true;
    }

    public WpfRenderingFrameProvider()
    {
        this.messageLoop = Run;
        this.list = new FreeListCore<IFrameRunnerWorkItem>(gate);
        System.Windows.Media.CompositionTarget.Rendering += messageLoop;
    }

    public override long GetFrameCount()
    {
        ThrowObjectDisposedIf(disposed, typeof(WpfRenderingFrameProvider));
        return frameCount;
    }

    public override void Register(IFrameRunnerWorkItem callback)
    {
        ThrowObjectDisposedIf(disposed, typeof(WpfRenderingFrameProvider));
        list.Add(callback, out _);
    }

    public void Dispose()
    {
        if (isDefaultProvider) return;

        disposed = true;
        System.Windows.Media.CompositionTarget.Rendering -= messageLoop;
        list.Dispose();
    }

    void Run(object? sender, EventArgs e)
    {
        frameCount++;

        var span = list.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            ref readonly var item = ref span[i];
            if (item != null)
            {
                try
                {
                    if (!item.MoveNext(frameCount))
                    {
                        list.Remove(i);
                    }
                }
                catch (Exception ex)
                {
                    list.Remove(i);
                    try
                    {
                        ObservableSystem.GetUnhandledExceptionHandler().Invoke(ex);
                    }
                    catch { }
                }
            }
        }
    }

    static void ThrowObjectDisposedIf(/*[DoesNotReturnIf(true)]*/ bool condition, Type type)
    {
        if (condition)
        {
            ThrowObjectDisposedException(type);
        }
    }

    // [DoesNotReturn]
    internal static void ThrowObjectDisposedException(Type? type) => throw new ObjectDisposedException(type?.FullName);
}



================================================
FILE: tests/R3.Tests/_TestHelper.cs
================================================
﻿using R3.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace R3.Tests;

public static class _TestHelper
{
    public static void AssertEqual<T>(this LiveList<T> list, params T[] expected)
    {
        list.ShouldBe(expected);
    }

    public static void AssertEqual<T>(this LiveList<T[]> list, params T[][] expected)
    {
        list.Count.ShouldBe(expected.Length);

        for (int i = 0; i < expected.Length; i++)
        {
            list[i].ShouldBe(expected[i]);
        }
    }

    public static void AssertEmpty<T>(this LiveList<T> list)
    {
        list.Count.ShouldBe(0);
    }

    public static void AssertIsCompleted<T>(this LiveList<T> list)
    {
        list.IsCompleted.ShouldBeTrue();
    }

    public static void AssertIsNotCompleted<T>(this LiveList<T> list)
    {
        list.IsCompleted.ShouldBeFalse();
    }

    public static void Advance(this FakeTimeProvider timeProvider, int seconds)
    {
        timeProvider.Advance(TimeSpan.FromSeconds(seconds));
    }

    // ShouldBe -> Is

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Is<T>(
       [NotNullIfNotNull(nameof(expected))] this T? actual,
       [NotNullIfNotNull(nameof(actual))] T? expected,
       string? customMessage = null)
    {
        actual.ShouldBe(expected, customMessage);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Is<T>(
        [NotNullIfNotNull(nameof(expected))] this T? actual,
        [NotNullIfNotNull(nameof(actual))] T? expected,
        IEqualityComparer<T> comparer,
        string? customMessage = null)
    {
        actual.ShouldBe(expected, comparer, customMessage);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void IsNot<T>(this T? actual, T? expected, string? customMessage = null)
    {
        actual.ShouldNotBe(expected, customMessage);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void IsNot<T>(this T? actual, T? expected, IEqualityComparer<T> comparer, string? customMessage = null)
    {
        actual.ShouldNotBe(expected, comparer, customMessage);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Is<T>(
        [NotNullIfNotNull(nameof(expected))] this IEnumerable<T>? actual,
        [NotNullIfNotNull(nameof(actual))] IEnumerable<T>? expected,
        bool ignoreOrder = false)
    {
        actual.ShouldBe(expected, ignoreOrder);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Is<T>(
        [NotNullIfNotNull(nameof(expected))] this IEnumerable<T>? actual,
        [NotNullIfNotNull(nameof(actual))] IEnumerable<T>? expected,
        bool ignoreOrder,
        string? customMessage)
    {
        actual.ShouldBe(expected, ignoreOrder, customMessage);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Is<T>(
        [NotNullIfNotNull(nameof(expected))] this IEnumerable<T>? actual,
        [NotNullIfNotNull(nameof(actual))] IEnumerable<T>? expected,
        IEqualityComparer<T> comparer,
        bool ignoreOrder = false,
        string? customMessage = null)
    {
        actual.ShouldBe(expected, comparer, ignoreOrder, customMessage);
    }
}



================================================
FILE: tests/R3.Tests/AwaitOperationCancelOnCompleted.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit.Sdk;

namespace R3.Tests;

public class AwaitOperationCancelOnCompleted
{
    [Theory]
    [InlineData(AwaitOperation.Sequential)]
    [InlineData(AwaitOperation.Drop)]
    [InlineData(AwaitOperation.Switch)]
    [InlineData(AwaitOperation.Parallel)]
    [InlineData(AwaitOperation.SequentialParallel)]
    [InlineData(AwaitOperation.ThrottleFirstLast)]
    public void SelectAwaitCancelOnCompletedTrue(AwaitOperation op)
    {
        SynchronizationContext.SetSynchronizationContext(null);

        Subject<int> subject = new Subject<int>();
        var time = new FakeTimeProvider();
        bool canceled = false;
        var list = subject.SelectAwait(async (x, ct) =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(3), time, ct);
                }
                catch
                {
                    canceled = true;
                    throw;
                }
                return x;
            }, op, cancelOnCompleted: true)
            .ToLiveList();

        subject.OnNext(1);

        subject.OnCompleted();

        Thread.Sleep(TimeSpan.FromSeconds(1)); // CI failed?
        canceled.ShouldBeTrue();
        list.AssertIsCompleted();
    }

    [Theory]
    [InlineData(AwaitOperation.Sequential)]
    [InlineData(AwaitOperation.Drop)]
    [InlineData(AwaitOperation.Switch)]
    [InlineData(AwaitOperation.Parallel)]
    [InlineData(AwaitOperation.SequentialParallel)]
    [InlineData(AwaitOperation.ThrottleFirstLast)]
    public void SelectAwaitCancelOnCompletedFalse(AwaitOperation op)
    {
        SynchronizationContext.SetSynchronizationContext(null);

        Subject<int> subject = new Subject<int>();
        var time = new FakeTimeProvider();
        bool canceled = false;
        var list = subject.SelectAwait(async (x, ct) =>
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(3), time, ct);
            }
            catch
            {
                canceled = true;
                throw;
            }
            return x * 10;
        }, op, cancelOnCompleted: false)
            .ToLiveList();

        subject.OnNext(1);

        subject.OnCompleted();

        canceled.ShouldBeFalse();

        list.AssertEqual([]);
        list.AssertIsNotCompleted();

        time.Advance(3);

        list.AssertEqual([10]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/BehaviorSubjectTest.cs
================================================
﻿namespace R3.Tests;

public class BehaviorSubjectTest
{
    [Fact]
    public void Test()
    {
        // Dispose(not yet completed)
        {
            var s = new BehaviorSubject<int>(100);
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.Dispose();

            l.AssertEqual([100, 1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Success), Dispose
        {
            var s = new BehaviorSubject<int>(100);
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted();
            s.Dispose();

            l.AssertEqual([100, 1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Failure), Dispose
        {
            var s = new BehaviorSubject<int>(100);
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted(new Exception("foo"));
            s.Dispose();

            l.AssertEqual([100, 1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }


        // already Disposed, call OnNext
        {
            var s = new BehaviorSubject<int>(100);
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnNext(1));
        }
        // already Disposed, call OnError
        {
            var s = new BehaviorSubject<int>(100);
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnErrorResume(new Exception()));
        }
        // already Disposed, call OnCompleted
        {
            var s = new BehaviorSubject<int>(100);
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnCompleted());
        }
        // already Disposed, call Value
        {
            var s = new BehaviorSubject<int>(100);
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => _ = s.Value);
        }
    }

    [Fact]
    public void SubscribeAfterCompleted()
    {
        {
            // after Success
            var s = new BehaviorSubject<int>(100);
            s.OnCompleted();

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsSuccess.ShouldBeTrue();
            l.Count.ShouldBe(0); // doesnt publish on subscribe

            // get value is ok, latest
            s.Value.ShouldBe(100);
        }
        {
            // after Failure
            var s = new BehaviorSubject<int>(100);
            s.OnCompleted(new Exception("foo"));

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsFailure.ShouldBeTrue();
            l.Result.Exception!.Message.ShouldBe("foo");

            Assert.Throws<Exception>(() => _ = s.Value).Message.ShouldBe("foo");
        }
    }
}



================================================
FILE: tests/R3.Tests/CompositeDisposableTest.cs
================================================
﻿namespace R3.Tests;

public class CompositeDisposableTest
{
    [Fact]
    public void Add()
    {
        var d1 = new TestDisposable();
        var d2 = new TestDisposable();
        var d3 = new TestDisposable();

        var composite = new CompositeDisposable();

        composite.Add(d1);
        composite.Add(d2);
        composite.Add(d3);

        d1.CalledCount.ShouldBe(0);

        composite.Remove(d2);
        d2.CalledCount.ShouldBe(1);

        composite.Clear();
        d1.CalledCount.ShouldBe(1);
        d3.CalledCount.ShouldBe(1);

        composite.Add(d1);
        composite.Add(d2);
        composite.Add(d3);

        composite.Dispose();

        d1.CalledCount.ShouldBe(2);
        d2.CalledCount.ShouldBe(2);
        d3.CalledCount.ShouldBe(2);

        composite.Add(d1);
        d1.CalledCount.ShouldBe(3);
    }

    [Fact]
    public void RemoveAndShrink()
    {
        var disposables = Enumerable.Range(1, 100).Select(x => new TestDisposable()).ToArray();
        var composite = new CompositeDisposable(disposables);

        foreach (var item in disposables)
        {
            composite.Remove(item);
        }

        foreach (var item in disposables)
        {
            item.CalledCount.ShouldBe(1);
        }
    }


    class TestDisposable : IDisposable
    {
        public int CalledCount = 0;

        public void Dispose()
        {
            CalledCount += 1;
        }
    }
}



================================================
FILE: tests/R3.Tests/DisposableBagTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace R3.Tests;

public class DisposableBagTest
{
    [Fact]
    public void Test()
    {
        var bag = new DisposableBag();

        var disposed = new bool[6];

        var subject = new Subject<int>();
        subject.Do(onDispose: () => disposed[0] = true).Subscribe().AddTo(ref bag);
        subject.Do(onDispose: () => disposed[1] = true).Subscribe().AddTo(ref bag);
        subject.Do(onDispose: () => disposed[2] = true).Subscribe().AddTo(ref bag);
        subject.Do(onDispose: () => disposed[3] = true).Subscribe().AddTo(ref bag);
        subject.Do(onDispose: () => disposed[4] = true).Subscribe().AddTo(ref bag);
        subject.Do(onDispose: () => disposed[5] = true).Subscribe().AddTo(ref bag);

        disposed.ShouldBe([false, false, false, false, false, false]);

        bag.Dispose();

        disposed.ShouldBe([true, true, true, true, true, true]);
    }
}



================================================
FILE: tests/R3.Tests/DisposableBuilderTest.cs
================================================
﻿namespace R3.Tests;

public class DisposableBuilderTest
{
    // 1~8 = Combined, 9~ array
    [Fact]
    public void Combined()
    {
        // combined check
        for (int i = 1; i <= 8; i++)
        {
            var l = new List<int>();
            using var builder = Disposable.CreateBuilder();
            for (int j = 0; j < i; j++)
            {
                builder.Add(Disposable.Create(() => l.Add(j + 1)));
            }

            var disposable = builder.Build();

            if (i == 1)
            {
                disposable.GetType().Name.ShouldBe("AnonymousDisposable");
            }
            else
            {
                disposable.GetType().Name.ShouldStartWith("CombinedDisposable");
            }

            l.ShouldBeEmpty();

            disposable.Dispose();

            l.Count.ShouldBe(i);
        }
    }

    [Fact]
    public void Array()
    {
        var l = new List<int>();
        using var builder = Disposable.CreateBuilder();
        for (int i = 1; i <= 8; i++)
        {
            var v = i;
            builder.Add(Disposable.Create(() => l.Add(v)));
        }

        // array
        builder.Add(Disposable.Create(() => l.Add(9)));
        builder.Add(Disposable.Create(() => l.Add(10)));
        builder.Add(Disposable.Create(() => l.Add(11)));
        builder.Add(Disposable.Create(() => l.Add(12)));
        builder.Add(Disposable.Create(() => l.Add(13)));
        builder.Add(Disposable.Create(() => l.Add(14)));
        builder.Add(Disposable.Create(() => l.Add(15)));
        builder.Add(Disposable.Create(() => l.Add(16)));
        // grow
        builder.Add(Disposable.Create(() => l.Add(17)));
        builder.Add(Disposable.Create(() => l.Add(18)));
        builder.Add(Disposable.Create(() => l.Add(19)));
        builder.Add(Disposable.Create(() => l.Add(20)));

        var disposable = builder.Build();

        disposable.GetType().Name.ShouldBe("CombinedDisposable");

        l.ShouldBeEmpty();

        disposable.Dispose();

        l.ShouldBe([
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20]);
    }

}



================================================
FILE: tests/R3.Tests/LiveListTest.cs
================================================
﻿namespace R3.Tests;

public class LiveListTest
{
    [Fact]
    public void FromEvent()
    {
        var publisher = new Subject<int>();
        var list = publisher.ToLiveList();

        list.AssertEqual([]);

        publisher.OnNext(10);
        list.AssertEqual([10]);

        publisher.OnNext(20);
        list.AssertEqual([10, 20]);

        publisher.OnNext(30);
        list.AssertEqual([10, 20, 30]);

        list.Dispose();

        publisher.OnNext(40);
        list.AssertEqual([10, 20, 30]);
    }

    [Fact]
    public void BufferSize()
    {
        var publisher = new Subject<int>();
        var list = publisher.ToLiveList(bufferSize: 5);

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);
        publisher.OnNext(40);
        publisher.OnNext(50);

        list.AssertEqual([10, 20, 30, 40, 50]);

        publisher.OnNext(60);

        list.AssertEqual([20, 30, 40, 50, 60]);

        list[0].ShouldBe(20);
        list[1].ShouldBe(30);
        list[2].ShouldBe(40);
        list[3].ShouldBe(50);
        list[4].ShouldBe(60);
    }
}



================================================
FILE: tests/R3.Tests/R3.Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <!-- xUnit1051 is async test for CancellationToken warning -->
        <NoWarn>9113;xUnit1051</NoWarn>
        <!-- Microsoft.Testing.Platform Support -->
        <OutputType>Exe</OutputType>
        <UseMicrosoftTestingPlatformRunner>true</UseMicrosoftTestingPlatformRunner>
        <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="xunit.v3" Version="1.1.0" />
        <PackageReference Include="Shouldly" Version="4.3.0" />

        <PackageReference Include="Microsoft.Extensions.TimeProvider.Testing" Version="9.2.0" />
        <PackageReference Include="System.Reactive.Linq" Version="6.0.1" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\src\R3\R3.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Using Include="R3" />
        <Using Include="Xunit" />
        <Using Include="Shouldly" />
        <Using Include="Microsoft.Extensions.Time.Testing" />
    </ItemGroup>

</Project>



================================================
FILE: tests/R3.Tests/ReactivePropertyTest.cs
================================================
﻿using R3.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace R3.Tests;

public class ReactivePropertyTest
{
    [Fact]
    public void Test()
    {
        var rp = new ReactiveProperty<int>(100);
        rp.Value.ShouldBe(100);

        var list = rp.ToLiveList();
        list.AssertEqual([100]);

        rp.Value = 9999;

        var list2 = rp.ToLiveList();
        list.AssertEqual([100, 9999]);
        list2.AssertEqual([9999]);

        rp.Value = 9999;
        list.AssertEqual([100, 9999]);
        list2.AssertEqual([9999]);

        rp.Value = 100;
        list.AssertEqual([100, 9999, 100]);
        list2.AssertEqual([9999, 100]);

        rp.Dispose();

        list.AssertIsCompleted();
        list2.AssertIsCompleted();
    }

    [Fact]
    public void DefaultValueTest()
    {
        using var rp = new ReactiveProperty<int>();
        rp.Value.ShouldBe(default);
    }

    [Fact]
    public void SubscribeAfterCompleted()
    {
        var rp = new ReactiveProperty<string>("foo");
        rp.OnCompleted();

        using var list = rp.ToLiveList();

        list.AssertIsCompleted();
        list.AssertEqual(["foo"]);
    }

    // Node Check
    [Fact]
    public void CheckNode()
    {
        var rp = new ReactiveProperty<int>();


        var list1 = rp.ToLiveList();

        rp.Value = 1;

        list1.AssertEqual([0, 1]);

        list1.Dispose();

        var list2 = rp.ToLiveList();

        rp.Value = 2;

        list2.AssertEqual([1, 2]);

        var list3 = rp.ToLiveList();
        var list4 = rp.ToLiveList();

        // remove first

        list2.Dispose();
        rp.Value = 3;

        list3.AssertEqual([2, 3]);
        list4.AssertEqual([2, 3]);

        var list5 = rp.ToLiveList();

        // remove middle
        list4.Dispose();

        rp.Value = 4;

        list3.AssertEqual([2, 3, 4]);
        list5.AssertEqual([3, 4]);

        // remove last
        list5.Dispose();

        rp.Value = 5;
        list3.AssertEqual([2, 3, 4, 5]);

        // remove single
        list3.Dispose();

        // subscribe once
        var list6 = rp.ToLiveList();
        rp.Value = 6;
        list6.AssertEqual([5, 6]);
    }

    [Fact]
    public void NodeDisposeCheck()
    {
        {
            var rp = new ReactiveProperty<int>(1);

            LiveList<int> list1;
            LiveList<int> list2;
            LiveList<int> list3 = null!;
            LiveList<int> list4 = null!;
            LiveList<int> list5;

            list1 = rp.ToLiveList();
            list2 = rp.Take(2).Do(_ => { list3?.Dispose(); list4?.Dispose(); }).ToLiveList();
            list3 = rp.ToLiveList();
            list4 = rp.ToLiveList();
            list5 = rp.ToLiveList();

            rp.Value = 10;

            list1.AssertEqual([1, 10]);
            list2.AssertEqual([1, 10]);
            list3.AssertEqual([1]);
            list4.AssertEqual([1]);
            list5.AssertEqual([1, 10]);
        }
        {
            // Dispose only self.
            var rp = new ReactiveProperty<int>(1);

            LiveList<int> list1;
            LiveList<int> list2;
            LiveList<int> list3 = null!;
            LiveList<int> list4 = null!;
            LiveList<int> list5;

            list1 = rp.ToLiveList();
            list2 = rp.Take(2).Do(_ => { /* list3?.Dispose(); list4?.Dispose(); */}).ToLiveList();
            list3 = rp.ToLiveList();
            list4 = rp.ToLiveList();
            list5 = rp.ToLiveList();

            rp.Value = 10;

            list1.AssertEqual([1, 10]);
            list2.AssertEqual([1, 10]);
            list3.AssertEqual([1, 10]);
            list4.AssertEqual([1, 10]);
            list5.AssertEqual([1, 10]);

            rp.Value = 20;

            list1.AssertEqual([1, 10, 20]);
            list2.AssertEqual([1, 10]);
            list3.AssertEqual([1, 10, 20]);
            list4.AssertEqual([1, 10, 20]);
            list5.AssertEqual([1, 10, 20]);
        }
        {
            // Dispose only next one.
            var rp = new ReactiveProperty<int>(1);

            LiveList<int> list1;
            LiveList<int> list2;
            LiveList<int> list3 = null!;
            LiveList<int> list4 = null!;
            LiveList<int> list5;

            list1 = rp.ToLiveList();
            list2 = rp.Do(_ => { list3?.Dispose(); /* list4?.Dispose(); */}).ToLiveList();
            list3 = rp.ToLiveList();
            list4 = rp.ToLiveList();
            list5 = rp.ToLiveList();

            rp.Value = 10;

            list1.AssertEqual([1, 10]);
            list2.AssertEqual([1, 10]);
            list3.AssertEqual([1]);
            list4.AssertEqual([1, 10]);
            list5.AssertEqual([1, 10]);

            rp.Value = 20;

            list1.AssertEqual([1, 10, 20]);
            list2.AssertEqual([1, 10, 20]);
            list3.AssertEqual([1]);
            list4.AssertEqual([1, 10, 20]);
            list5.AssertEqual([1, 10, 20]);
        }
        {
            // Dispose only next next one.
            var rp = new ReactiveProperty<int>(1);

            LiveList<int> list1;
            LiveList<int> list2;
            LiveList<int> list3 = null!;
            LiveList<int> list4 = null!;
            LiveList<int> list5;

            list1 = rp.ToLiveList();
            list2 = rp.Do(_ => { list4?.Dispose(); }).ToLiveList();
            list3 = rp.ToLiveList();
            list4 = rp.ToLiveList();
            list5 = rp.ToLiveList();

            rp.Value = 10;

            list1.AssertEqual([1, 10]);
            list2.AssertEqual([1, 10]);
            list3.AssertEqual([1, 10]);
            list4.AssertEqual([1]);
            list5.AssertEqual([1, 10]);

            rp.Value = 20;

            list1.AssertEqual([1, 10, 20]);
            list2.AssertEqual([1, 10, 20]);
            list3.AssertEqual([1, 10, 20]);
            list4.AssertEqual([1]);
            list5.AssertEqual([1, 10, 20]);
        }
    }

    [Fact]
    public void RecursiveSubscribe()
    {
        var rp = new ReactiveProperty<int>(0);

        List<LiveList<int>> recList = new();

        var list = rp.Do(x =>
            {
                recList.Add(rp.ToLiveList());
            })
            .ToLiveList();

        list.AssertEqual([0]);
        recList[0].AssertEqual([0]);

        rp.Value = 99;
        list.AssertEqual([0, 99]);
        recList[0].AssertEqual([0, 99]);
        recList[1].AssertEqual([99]);


    }

    [Fact]
    public void RootChangedFromSecond()
    {

        var p1 = new ReactiveProperty<int>();
        var p1List = p1.Skip(1).ToLiveList();

        p1.Skip(1).Subscribe().Dispose(); // Subscribe and Dispose

        var p3List = p1.Skip(1).ToLiveList();

        p1.Value = 1;
        p1.Value = 2;

        p1List.AssertEqual([1, 2]);
        p3List.AssertEqual([1, 2]);
    }

    [Fact]
    public void RemoveLastNode()
    {
        var log = new List<string>();

        var count = 0;
        var r = new ReactiveProperty<int>(count);
        var ctsA = new CancellationTokenSource();
        var ctsB = new CancellationTokenSource();
        var ctsC = new CancellationTokenSource();
        r.Subscribe(x => log.Add($"A = {x}")).RegisterTo(ctsA.Token);
        r.Subscribe(x => log.Add($"B = {x}")).RegisterTo(ctsB.Token);
        r.Subscribe(x => log.Add($"C = {x}")).RegisterTo(ctsC.Token);
        ctsA.Cancel();
        ctsA.Dispose();
        log.Add("A disposed");

        ctsA = new CancellationTokenSource();
        r.Subscribe(x => log.Add($"A = {x}")).RegisterTo(ctsA.Token);
        log.Add("A re-registered");
        ctsA.Cancel();
        ctsA.Dispose();
        log.Add("A disposed");
        ctsA = new CancellationTokenSource();
        r.Subscribe(x => log.Add($"A = {x}")).RegisterTo(ctsA.Token);
        log.Add("A re-registered");
        r.Value = ++count;
        r.Value = ++count;

        var actual = string.Join(Environment.NewLine, log);

        actual.ShouldBe("""
A = 0
B = 0
C = 0
A disposed
A = 0
A re-registered
A disposed
A = 0
A re-registered
B = 1
C = 1
A = 1
B = 2
C = 2
A = 2
""");
    }

    [Fact]
    public void RemoveMiddle()
    {
        var log = new List<string>();

        var p1 = new ReactiveProperty<int>();
        p1.Skip(1).Subscribe(x => log.Add("[P1]" + x)); // alive

        var d1 = p1.Skip(1).Subscribe(x => log.Add("[P2]" + x));
        var d2 = p1.Skip(1).Subscribe(x => log.Add("[P2]" + x));
        d1.Dispose();
        d2.Dispose();

        p1.Skip(1).Subscribe(x => log.Add("[P3]" + x)); // alive

        p1.Value = 1;
        p1.Value = 2;

        var actual = string.Join(Environment.NewLine, log);

        actual.ShouldBe("""
[P1]1
[P3]1
[P1]2
[P3]2
""");
    }



    [Fact]
    public void RemoveFirst()
    {
        var log = new List<string>();

        var p1 = new ReactiveProperty<int>();
        var d1 = p1.Skip(1).Subscribe(x => log.Add("[P1]" + x));

        var d2 = p1.Skip(1).Subscribe(x => log.Add("[P2_1]" + x)); // alive
        var d3 = p1.Skip(1).Subscribe(x => log.Add("[P2_2]" + x)); // alive
        
        d1.Dispose();

        p1.Skip(1).Subscribe(x => log.Add("[P3]" + x)); // alive

        p1.Value = 1;
        p1.Value = 2;

        var actual = string.Join(Environment.NewLine, log);

        actual.ShouldBe("""
[P2_1]1
[P2_2]1
[P3]1
[P2_1]2
[P2_2]2
[P3]2
""");
    }

    [Fact]
    public void RemoveLast()
    {
        var log = new List<string>();

        var p1 = new ReactiveProperty<int>();
        p1.Skip(1).Subscribe(x => log.Add("[P1]" + x)); // alive

        var d1 = p1.Skip(1).Subscribe(x => log.Add("[P2]" + x)); // alive
        var d2 = p1.Skip(1).Subscribe(x => log.Add("[P2]" + x)); // alive

        var d3 = p1.Skip(1).Subscribe(x => log.Add("[P3]" + x));
        d3.Dispose();

        p1.Value = 1;
        p1.Value = 2;

        var actual = string.Join(Environment.NewLine, log);

        actual.ShouldBe("""
[P1]1
[P2]1
[P2]1
[P1]2
[P2]2
[P2]2
""");
    }
}



================================================
FILE: tests/R3.Tests/ReplayFrameSubjectTest .cs
================================================
﻿namespace R3.Tests;

public class ReplayFrameSubjectTest
{
    [Fact]
    public void ReplayTime()
    {
        var fakeTime = new FakeFrameProvider();

        var subject = new ReplayFrameSubject<int>((3), fakeTime);

        subject.OnNext(10);
        fakeTime.Advance((1));
        subject.ToLiveList().AssertEqual([10]);

        subject.OnNext(20);
        fakeTime.Advance((1));
        subject.ToLiveList().AssertEqual([10, 20]);

        subject.OnNext(30);
        fakeTime.Advance((1));

        var list = subject.ToLiveList();
        subject.ToLiveList().AssertEqual([20, 30]);

        subject.OnNext(40);
        subject.OnNext(50);
        subject.OnNext(60);

        fakeTime.Advance((2));
        subject.OnNext(70);

        subject.ToLiveList().AssertEqual([40, 50, 60, 70]);
        fakeTime.Advance((1));

        subject.ToLiveList().AssertEqual([70]);

        subject.OnCompleted();
        subject.ToLiveList().AssertEqual([70]);
        subject.ToLiveList().AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/ReplaySubjectTest.cs
================================================
﻿namespace R3.Tests;

public class ReplaySubjectTest
{
    [Fact]
    public void ReplayAll()
    {
        var subject = new ReplaySubject<int>();
        foreach (var i in Enumerable.Range(0, 100))
        {
            subject.OnNext(i);
        }

        var list = subject.ToLiveList();
        list.AssertEqual(Enumerable.Range(0, 100).ToArray());

        list.Clear();
        subject.OnNext(9);
        list.AssertEqual([9]);

        subject.OnCompleted();
        list.AssertIsCompleted();

        var list2 = subject.ToLiveList();

        list2.AssertEqual(Enumerable.Range(0, 100).Append(9).ToArray());
        list2.AssertIsCompleted();
    }

    [Fact]
    public void ReplayCount()
    {
        var subject = new ReplaySubject<int>(bufferSize: 50);
        foreach (var i in Enumerable.Range(0, 50))
        {
            subject.OnNext(i);
        }

        {
            using var list = subject.ToLiveList();
            list.AssertEqual(Enumerable.Range(0, 50).ToArray());
        }
        {
            subject.OnNext(100);
            subject.OnNext(101);
            subject.OnNext(102);

            using var list = subject.ToLiveList();
            list.AssertEqual(Enumerable.Range(0, 50).Skip(3).Concat([100, 101, 102]).ToArray());
        }

        subject.OnCompleted();

        {
            using var list = subject.ToLiveList();
            list.AssertEqual(Enumerable.Range(0, 50).Skip(3).Concat([100, 101, 102]).ToArray());
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void ReplayTime()
    {
        var fakeTime = new FakeTimeProvider();

        var subject = new ReplaySubject<int>(TimeSpan.FromSeconds(3), fakeTime);

        subject.OnNext(10);
        fakeTime.Advance(TimeSpan.FromSeconds(1));
        subject.ToLiveList().AssertEqual([10]);

        subject.OnNext(20);
        fakeTime.Advance(TimeSpan.FromSeconds(1));
        subject.ToLiveList().AssertEqual([10, 20]);

        subject.OnNext(30);
        fakeTime.Advance(TimeSpan.FromSeconds(1));

        var list = subject.ToLiveList();
        subject.ToLiveList().AssertEqual([20, 30]);

        subject.OnNext(40);
        subject.OnNext(50);
        subject.OnNext(60);

        fakeTime.Advance(TimeSpan.FromSeconds(2));
        subject.OnNext(70);

        subject.ToLiveList().AssertEqual([40, 50, 60, 70]);
        fakeTime.Advance(TimeSpan.FromSeconds(1));

        subject.ToLiveList().AssertEqual([70]);

        subject.OnCompleted();
        subject.ToLiveList().AssertEqual([70]);
        subject.ToLiveList().AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/SerialDisposableTest.cs
================================================
﻿namespace R3.Tests;

public class SerialDisposableTest
{
    [Fact]
    public void Dispose()
    {
        var l = new List<int>();

        var d = new SerialDisposableCore();
        d.Disposable = Disposable.Create(() => l.Add(1));

        l.ShouldBe([]);

        d.Disposable = Disposable.Create(() => l.Add(2));
        l.ShouldBe([1]);

        d.Disposable = Disposable.Create(() => l.Add(3));
        l.ShouldBe([1, 2]);

        d.Disposable = Disposable.Create(() => l.Add(4));
        l.ShouldBe([1, 2, 3]);

        d.Dispose();

        l.ShouldBe([1, 2, 3, 4]);

        d.Disposable = Disposable.Create(() => l.Add(5));

        l.ShouldBe([1, 2, 3, 4, 5]);
    }
}



================================================
FILE: tests/R3.Tests/SubjectTest.cs
================================================
﻿namespace R3.Tests;

public class SubjectTest
{
    [Fact]
    public void Test()
    {
        // Dispose(not yet completed)
        {
            var s = new Subject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Success), Dispose
        {
            var s = new Subject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted();
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Failure), Dispose
        {
            var s = new Subject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted(new Exception("foo"));
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }


        // already Disposed, call OnNext
        {
            var s = new Subject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnNext(1));
        }
        // already Disposed, call OnError
        {
            var s = new Subject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnErrorResume(new Exception()));
        }
        // already Disposed, call OnCompleted
        {
            var s = new Subject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnCompleted());
        }
    }

    [Fact]
    public void SubscribeAfterCompleted()
    {
        {
            // after Success
            var s = new Subject<int>();
            s.OnCompleted();

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsSuccess.ShouldBeTrue();
        }
        {
            // after Failure
            var s = new Subject<int>();
            s.OnCompleted(new Exception("foo"));

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsFailure.ShouldBeTrue();
            l.Result.Exception!.Message.ShouldBe("foo");
        }
    }

    [Fact]
    public void SingleAssignment()
    {
        // normal
        {
            var s = new SingleAssignmentSubject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            l.ShouldBe([1, 2, 3]);

            s.OnCompleted();
            l.AssertIsCompleted();
        }
        // subscribe twice
        {
            var s = new SingleAssignmentSubject<int>();
            using var l = s.ToLiveList();
            Assert.Throws<InvalidOperationException>(() => s.Subscribe());
        }

        // subject test copy

        // Dispose(not yet completed)
        {
            var s = new SingleAssignmentSubject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Success), Dispose
        {
            var s = new SingleAssignmentSubject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted();
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }

        // already OnCompleted(Failure), Dispose
        {
            var s = new SingleAssignmentSubject<int>();
            using var l = s.ToLiveList();
            s.OnNext(1);
            s.OnNext(2);
            s.OnNext(3);
            s.OnCompleted(new Exception("foo"));
            s.Dispose();

            l.AssertEqual([1, 2, 3]);
            l.AssertIsCompleted();
            s.IsDisposed.ShouldBeTrue();
        }


        // already Disposed, call OnNext
        {
            var s = new SingleAssignmentSubject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnNext(1));
        }
        // already Disposed, call OnError
        {
            var s = new SingleAssignmentSubject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnErrorResume(new Exception()));
        }
        // already Disposed, call OnCompleted
        {
            var s = new SingleAssignmentSubject<int>();
            s.Dispose();
            Assert.Throws<ObjectDisposedException>(() => s.OnCompleted());
        }


        {
            // after Success
            var s = new SingleAssignmentSubject<int>();
            s.OnCompleted();

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsSuccess.ShouldBeTrue();
        }
        {
            // after Failure
            var s = new SingleAssignmentSubject<int>();
            s.OnCompleted(new Exception("foo"));

            using var l = s.ToLiveList();

            l.AssertIsCompleted();
            l.Result.IsFailure.ShouldBeTrue();
            l.Result.Exception!.Message.ShouldBe("foo");
        }
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/CreateTest.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3.Tests.FactoryTests;

public class CreateTest
{
    [Fact]
    public void Create()
    {
        var source = Observable.Create<int>(observer =>
        {
            observer.OnNext(1);
            observer.OnNext(10);
            observer.OnNext(100);
            observer.OnCompleted();
            return Disposable.Empty;
        }, rawObserver: true);

        source.ToLiveList().AssertEqual([1, 10, 100]);
    }

    [Fact]
    public void CreateS()
    {
        using var publisher = new Subject<int>();
        var source = Observable.Create<int, Subject<int>>(publisher, (observer, state) =>
        {
            return state.Subscribe(observer);
        });

        using var list = source.ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);
        publisher.OnNext(10);
        list.AssertEqual([1, 10]);
        publisher.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void AsyncCreate()
    {
        var gate = new TaskCompletionSource();

        var source = Observable.Create<int>(async (observer, _) =>
        {
            observer.OnNext(1);
            await gate.Task;
            observer.OnNext(10);
            observer.OnCompleted();
        });

        using var list = source.ToLiveList();
        list.AssertEqual([1]);
        gate.SetResult();
        list.AssertEqual([1, 10]);
    }

    [Fact]
    public void AsyncCreateCancel()
    {
        var gate = new TaskCompletionSource();

        var list = Observable.Create<int>(async (observer, ct) =>
            {
                ct.Register(() => gate.SetCanceled(ct));
                observer.OnNext(1);
                await gate.Task;
                observer.OnNext(2);
                observer.OnCompleted();
            })
            .ToLiveList();

        list.AssertEqual([1]);
        list.Dispose();
        gate.Task.Status.ShouldBe(TaskStatus.Canceled);
    }

    [Fact]
    public void AsyncCreateS()
    {
        using var publisher = new Subject<int>();
        var source = Observable.Create<int, Subject<int>>(publisher,
            async (observer, state, ct) =>
            {
                while (!ct.IsCancellationRequested)
                {
                    try
                    {
                        var value = await state.FirstAsync(ct);
                        observer.OnNext(value);
                    }
                    catch (Exception ex)
                    {
                        observer.OnCompleted(ex);
                    }
                }
            });

        using var list = source.ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);
        publisher.OnNext(10);
        list.AssertEqual([1, 10]);
        publisher.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void AsyncCreateSCancel()
    {
        var gate = new TaskCompletionSource();

        var list = Observable.Create<int, TaskCompletionSource>(gate, async (observer, g, ct) =>
            {
                ct.Register(() => g.SetCanceled(ct));
                observer.OnNext(1);
                await g.Task;
                observer.OnNext(2);
                observer.OnCompleted();
            })
            .ToLiveList();

        list.AssertEqual([1]);
        list.Dispose();
        gate.Task.Status.ShouldBe(TaskStatus.Canceled);
    }

    [Fact]
    public void CreateFrom()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var gate = new TaskCompletionSource();

        var source = Observable.CreateFrom(Seq);

        using var list = source.ToLiveList();
        list.AssertEqual([1]);
        gate.SetResult();
        list.AssertEqual([1, 10]);

        async IAsyncEnumerable<int> Seq([EnumeratorCancellation] CancellationToken ct)
        {
            yield return 1;
            await gate!.Task;
            yield return 10;
        }
    }

    [Fact]
    public void CreateFromCancel()
    {
        var tp = new FakeTimeProvider();

        var source = Observable.CreateFrom(Seq);

        using var list = source.ToLiveList();
        list.AssertEqual([1]);

        list.Dispose();

        async IAsyncEnumerable<int> Seq([EnumeratorCancellation] CancellationToken ct)
        {
            yield return 1;
            await Task.Delay(TimeSpan.FromSeconds(1), tp, ct);
            yield return 10;
        }
    }

    [Fact]
    public void CreateFromError()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var gate = new TaskCompletionSource();

        var source = Observable.CreateFrom(Seq);

        using var list = source.ToLiveList();
        list.AssertEqual([1]);
        gate.SetException(new Exception("foo"));
        list.Result!.Exception!.Message.ShouldBe("foo");

        async IAsyncEnumerable<int> Seq([EnumeratorCancellation] CancellationToken ct)
        {
            yield return 1;
            await gate!.Task;
            yield return 10;
        }
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/DeferTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class DeferTest
{
    [Fact]
    public void Test()
    {
        var called = false;
        var def = Observable.Defer(() =>
        {
            called = true;
            return Observable.Range(1, 10);
        });

        called.ShouldBeFalse();

        var list = def.ToLiveList();

        called.ShouldBeTrue();

        list.AssertEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    [Fact]
    public void SubscribeInDefer()
    {
        Observable.ReturnUnit()
            .SelectMany(selector: _ => Observable
            .Defer(observableFactory: () => Observable.ReturnUnit().SubscribeOnThreadPool())
            .SubscribeOnThreadPool()
            )
            .Subscribe();

        Observable.Defer(observableFactory: () => Observable.ReturnUnit().SubscribeOnThreadPool()).Subscribe();
        Observable.Defer(observableFactory: () => Observable.ReturnUnit().Delay(TimeSpan.FromSeconds(1))).Subscribe();

        Thread.Sleep(TimeSpan.FromSeconds(1.5));
    }
}





================================================
FILE: tests/R3.Tests/FactoryTests/EmptyTest.cs
================================================
﻿using Microsoft.Extensions.Time.Testing;

namespace R3.Tests.FactoryTests;

public class EmptyTest
{
    [Fact]
    public void Empty()
    {
        using var list = Observable.Empty<int>().ToLiveList();
        list.AssertIsCompleted();
    }

    [Fact]
    public void EmptyWithTime()
    {
        var fakeTime = new FakeTimeProvider();
        using var list = Observable.Empty<int>(TimeSpan.FromSeconds(5), fakeTime).ToLiveList();

        fakeTime.Advance(TimeSpan.FromSeconds(4));
        list.AssertIsNotCompleted();

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/EveryUpdateTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class EveryUpdateTest
{
    [Fact]
    public void EveryUpdateCancelImmediate()
    {
        var cts = new CancellationTokenSource();
        var frameProvider = new FakeFrameProvider();

        var list = Observable.EveryUpdate(frameProvider, cts.Token).Select(_ => frameProvider.GetFrameCount()).ToLiveList();

        list.AssertEqual([]);

        frameProvider.Advance();
        list.AssertEqual([0]);

        frameProvider.Advance(3);
        list.AssertEqual([0, 1, 2, 3]);

        cts.Cancel();
        list.AssertIsCompleted();

        frameProvider.Advance();
        list.AssertEqual([0, 1, 2, 3]);
        list.AssertIsCompleted();
    }
    
    [Fact]
    public void EveryUpdateDispose()
    {
        var frameProvider = new FakeFrameProvider();

        var list = Observable.EveryUpdate(frameProvider).Select(_ => frameProvider.GetFrameCount()).ToLiveList();

        list.AssertEqual([]);

        frameProvider.Advance();
        list.AssertEqual([0]);

        frameProvider.Advance(3);
        list.AssertEqual([0, 1, 2, 3]);

        list.Dispose();
        frameProvider.Advance();
        list.AssertEqual([0, 1, 2, 3]);
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/EveryValueChangedTest.cs
================================================
﻿
namespace R3.Tests.FactoryTests;

public class EveryValueChangedTest
{
    [Fact]
    public void EveryValueChanged()
    {
        var frameProvider = new FakeFrameProvider();

        var t = new Target();
        t.MyProperty = 99;

        var list = Observable.EveryValueChanged(t, x => x.MyProperty, frameProvider).ToLiveList();

        list.AssertEqual([99]);

        t.MyProperty = 100;
        frameProvider.Advance();

        list.AssertEqual([99, 100]);

        t.MyProperty = 100;
        frameProvider.Advance();

        list.AssertEqual([99, 100]);

        t.MyProperty = 1000;
        frameProvider.Advance();

        list.AssertEqual([99, 100, 1000]);

        frameProvider.GetRegisteredCount().ShouldBe(1);

        list.Dispose();
        frameProvider.Advance();

        frameProvider.GetRegisteredCount().ShouldBe(0);
    }
}

file class Target
{
    public int MyProperty { get; set; }
}



================================================
FILE: tests/R3.Tests/FactoryTests/FromAsyncTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class FromAsyncTest
{
    [Fact]
    public void FromAsync()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var fakeTime = new FakeTimeProvider();
        var list = Observable.FromAsync(async (ct) =>
        {
            await Task.Delay(TimeSpan.FromSeconds(1), fakeTime, ct);
            return 1000;
        }).ToLiveList();

        list.AssertEqual([]);

        fakeTime.Advance(1);

        list.AssertEqual([1000]);
        list.AssertIsCompleted();
    }

    [Fact]
    public async Task FromAsyncCancel()
    {
        SynchronizationContext.SetSynchronizationContext(null);
        var fakeTime = new FakeTimeProvider();
        var cancelled = new TaskCompletionSource();
        var list = Observable.FromAsync(async (ct) =>
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(1), fakeTime, ct);
            }
            catch (OperationCanceledException)
            {
                cancelled.TrySetResult();
                throw;
            }
            return 1000;
        }).ToLiveList();

        list.AssertEqual([]);

        list.Dispose();

        await cancelled.Task; // await OK.
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/FromEventTest.cs
================================================
﻿using Shouldly;

namespace R3.Tests.FactoryTests;

public class FromEventTest
{

    [Fact]
    public void Event()
    {
        var ev = new EventPattern();

        var l1 = Observable.FromEventHandler(h => ev.E1 += h, h => ev.E1 -= h).ToLiveList();
        var l2 = Observable.FromEventHandler<int>(h => ev.E2 += h, h => ev.E2 -= h).ToLiveList();
        var l3 = Observable.FromEvent(h => ev.A1 += h, h => ev.A1 -= h).ToLiveList();
        var l4 = Observable.FromEvent<int>(h => ev.A2 += h, h => ev.A2 -= h).ToLiveList();
        var l5 = Observable.FromEvent<MyDelegate1>(h => new MyDelegate1(h), h => ev.M1 += h, h => ev.M1 -= h).ToLiveList();
        var l6 = Observable.FromEvent<MyDelegate2, int>(h => new MyDelegate2(h), h => ev.M2 += h, h => ev.M2 -= h).ToLiveList();
        var l7 = Observable.FromEvent<MyDelegate3, (int x, int y)>(h => (x, y) => h((x, y)), h => ev.M3 += h, h => ev.M3 -= h).ToLiveList();

        ev.Raise(10, 20);
        ev.Raise(100, 200);

        l1.Count.ShouldBe(2);
        l3.Count.ShouldBe(2);
        l5.Count.ShouldBe(2);

        l2.Select(x => x.e).ShouldBe([10, 100]);
        l4.AssertEqual([10, 100]);
        l6.AssertEqual([10, 100]);
        l7.AssertEqual([(10, 20), (100, 200)]);

        ev.InvocationListCount().ShouldBe((1, 1, 1, 1, 1, 1, 1));

        l1.Dispose();
        l2.Dispose();
        l3.Dispose();
        l4.Dispose();
        l5.Dispose();
        l6.Dispose();
        l7.Dispose();

        ev.InvocationListCount().ShouldBe((0, 0, 0, 0, 0, 0, 0));
    }

    [Fact]
    public void Cancel()
    {
        var cts = new CancellationTokenSource();

        var ev = new EventPattern();

        var l1 = Observable.FromEventHandler(h => ev.E1 += h, h => ev.E1 -= h, cts.Token).ToLiveList();
        var l2 = Observable.FromEventHandler<int>(h => ev.E2 += h, h => ev.E2 -= h, cts.Token).ToLiveList();
        var l3 = Observable.FromEvent(h => ev.A1 += h, h => ev.A1 -= h, cts.Token).ToLiveList();
        var l4 = Observable.FromEvent<int>(h => ev.A2 += h, h => ev.A2 -= h, cts.Token).ToLiveList();
        var l5 = Observable.FromEvent<MyDelegate1>(h => new MyDelegate1(h), h => ev.M1 += h, h => ev.M1 -= h, cts.Token).ToLiveList();
        var l6 = Observable.FromEvent<MyDelegate2, int>(h => new MyDelegate2(h), h => ev.M2 += h, h => ev.M2 -= h, cts.Token).ToLiveList();
        var l7 = Observable.FromEvent<MyDelegate3, (int x, int y)>(h => (x, y) => h((x, y)), h => ev.M3 += h, h => ev.M3 -= h, cts.Token).ToLiveList();

        ev.Raise(10, 20);
        ev.Raise(100, 200);

        l1.Count.ShouldBe(2);
        l3.Count.ShouldBe(2);
        l5.Count.ShouldBe(2);

        l2.Select(x => x.e).ShouldBe([10, 100]);
        l4.AssertEqual([10, 100]);
        l6.AssertEqual([10, 100]);
        l7.AssertEqual([(10, 20), (100, 200)]);

        ev.InvocationListCount().ShouldBe((1, 1, 1, 1, 1, 1, 1));

        cts.Cancel();

        ev.InvocationListCount().ShouldBe((0, 0, 0, 0, 0, 0, 0));
    }


    class EventPattern
    {
        public event EventHandler? E1;
        public event EventHandler<int>? E2;
        public event Action? A1;
        public event Action<int>? A2;
        public event MyDelegate1? M1;
        public event MyDelegate2? M2;
        public event MyDelegate3? M3;

        public void Raise(int x, int y)
        {
            E1?.Invoke(this, new EventArgs());
            E2?.Invoke(this, x);
            A1?.Invoke();
            A2?.Invoke(x);
            M1?.Invoke();
            M2?.Invoke(x);
            M3?.Invoke(x, y);
        }

        public (int, int, int, int, int, int, int) InvocationListCount()
        {
            return (
                E1?.GetInvocationList().Length ?? 0,
                E2?.GetInvocationList().Length ?? 0,
                A1?.GetInvocationList().Length ?? 0,
                A2?.GetInvocationList().Length ?? 0,
                M1?.GetInvocationList().Length ?? 0,
                M2?.GetInvocationList().Length ?? 0,
                M3?.GetInvocationList().Length ?? 0);
        }
    }

    public delegate void MyDelegate1();
    public delegate void MyDelegate2(int x);
    public delegate void MyDelegate3(int x, int y);
}



================================================
FILE: tests/R3.Tests/FactoryTests/NeverTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class NeverTest
{
    [Fact]
    public void Never()
    {
        using var list = Observable.Never<int>().ToLiveList();
        list.AssertEqual([]);
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/ObservePropertyTest.cs
================================================
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace R3.Tests.FactoryTests;

public class ObservePropertyTest
{
    [Fact]
    public void PropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([0]);

        propertyChanger.Value = 1;

        liveList.AssertEqual([0, 1]);
    }

    [Fact]
    public void NullablePropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([null]);

        var nipc = new ChangesProperty();

        propertyChanger.NullableInnerPropertyChanged = nipc;

        liveList.AssertEqual([null, nipc]);
    }

    [Fact]
    public void NestedPropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.InnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.InnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 1]);

        propertyChanger.InnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 1, 2]);
    }

    [Fact]
    public void NullableNestedPropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.NullableInnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.NullableInnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 1]);

        propertyChanger.NullableInnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 1, 2]);
    }

    [Fact]
    public void NullableNestedPropertyChangedWithNullableEndProperty()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([null]);

        var nipc = new ChangesProperty();

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc;

        liveList.AssertEqual([null, nipc]);
    }

    [Fact]
    public void DoubleNestedPropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.InnerPropertyChanged, x => x.InnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged.InnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.InnerPropertyChanged.InnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 1]);
    }

    [Fact]
    public void NullableDoubleNestedPropertyChanged()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 1]);
    }

    [Fact]
    public void NullableDoubleNestedPropertyChangedWithNullableEndProperty()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanged(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([null]);

        var nipc = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc;

        liveList.AssertEqual([null, nipc]);
    }

    [Fact]
    public void PropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([0]);

        propertyChanger.Value = 1;

        liveList.AssertEqual([0, 0]);
    }

    [Fact]
    public void NullablePropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([null]);

        var nipc1 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged = nipc1;

        liveList.AssertEqual([null, null]);

        var nipc2 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged = nipc2;

        liveList.AssertEqual([null, null, nipc1]);
    }

    [Fact]
    public void NestedPropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.InnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.InnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 0]);

        propertyChanger.InnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 0, 1]);
    }

    [Fact]
    public void NullableNestedPropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.NullableInnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.NullableInnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 0]);

        propertyChanger.NullableInnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 0, 1]);
    }

    [Fact]
    public void NullableNestedPropertyChangingWithNullableEndProperty()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([null]);

        var nipc1 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc1;

        liveList.AssertEqual([null, null]);

        var nipc2 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc2;

        liveList.AssertEqual([null, null, nipc1]);

        var nipc3 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc3;

        liveList.AssertEqual([null, null, nipc1, nipc2]);
    }

    [Fact]
    public void DoubleNestedPropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.InnerPropertyChanged, x => x.InnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.InnerPropertyChanged.InnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.InnerPropertyChanged.InnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 0]);

        propertyChanger.InnerPropertyChanged.InnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 0, 1]);
    }

    [Fact]
    public void NullableDoubleNestedPropertyChanging()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged, x => x.Value)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([0]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.Value = 1;

        liveList.AssertEqual([0, 0]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.Value = 2;

        liveList.AssertEqual([0, 0, 1]);
    }

    [Fact]
    public void NullableDoubleNestedPropertyChangingWithNullableEndProperty()
    {
        ChangesProperty propertyChanger = new();

        using var liveList = propertyChanger
            .ObservePropertyChanging(x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged, x => x.NullableInnerPropertyChanged)
            .ToLiveList();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([]);

        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged = new();

        liveList.AssertEqual([null]);

        var nipc1 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc1;

        liveList.AssertEqual([null, null]);

        var nipc2 = new ChangesProperty();
        propertyChanger.NullableInnerPropertyChanged.NullableInnerPropertyChanged.NullableInnerPropertyChanged = nipc2;

        liveList.AssertEqual([null, null, nipc1]);
    }

    class ChangesProperty : INotifyPropertyChanged, INotifyPropertyChanging
    {
        private int _value;
        private ChangesProperty _innerPropertyChanged = default!;
        private ChangesProperty? _nullableInnerPropertyChanged;

        public event PropertyChangedEventHandler? PropertyChanged;
        public event PropertyChangingEventHandler? PropertyChanging;

        public int Value
        {
            get => _value;
            set => SetField(ref _value, value);
        }

        public ChangesProperty InnerPropertyChanged
        {
            get => _innerPropertyChanged;
            set => SetField(ref _innerPropertyChanged, value);
        }

        public ChangesProperty? NullableInnerPropertyChanged
        {
            get => _nullableInnerPropertyChanged;
            set => SetField(ref _nullableInnerPropertyChanged, value);
        }

        private void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        private void OnPropertyChanging([CallerMemberName] string? propertyName = null)
        {
            PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));
        }

        private bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value))
            {
                return false;
            }

            OnPropertyChanging(propertyName);
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }

    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/RangeTest.cs
================================================
﻿using System.Collections.Generic;

namespace R3.Tests.FactoryTests;

public class RangeTest
{
    [Fact]
    public void Range()
    {
        using var list1 = Observable.Range(5, 8).ToLiveList();
        list1.AssertEqual([5, 6, 7, 8, 9, 10, 11, 12]);
        list1.AssertIsCompleted();

        using var list2 = Observable.Range(20, 3).ToLiveList();
        list2.AssertEqual([20, 21, 22]);
        list2.AssertIsCompleted();

        using var list3 = Observable.Range(-3, 5).ToLiveList();
        list3.AssertEqual([-3, -2, -1, 0, 1]);
        list3.AssertIsCompleted();

        using var list4 = Observable.Range(10, 0).ToLiveList();
        list4.AssertEqual([]);
        list4.AssertIsCompleted();

        Assert.Throws<ArgumentOutOfRangeException>(() => Observable.Range(10, -1));
    }

    [Fact]
    public void Stop()
    {
        var cts = new CancellationTokenSource();

        using var list = Observable.Range(0, int.MaxValue, cts.Token)
            .Take(5)
            .DoCancelOnCompleted(cts)
            .ToLiveList();

        list.AssertEqual([0, 1, 2, 3, 4]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/RepeatTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class RepeatTest
{
    // test
    [Fact]
    public void Repeat()
    {
        using var list = Observable.Repeat("foo", 3).ToLiveList();
        list.AssertEqual(["foo", "foo", "foo"]);
        list.AssertIsCompleted();

        using var list2 = Observable.Repeat("foo", 0).ToLiveList();
        list2.AssertEqual([]);
        list2.AssertIsCompleted();

        Assert.Throws<ArgumentOutOfRangeException>(() => Observable.Repeat("foo", -1));
    }

    [Fact]
    public void Stop()
    {
        var cts = new CancellationTokenSource();

        using var list = Observable.Repeat("foo", int.MaxValue, cts.Token)
            .Take(5)
            .DoCancelOnCompleted(cts)
            .ToLiveList();

        list.AssertEqual(["foo", "foo", "foo", "foo", "foo"]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/ReturnFrameTest.cs
================================================
﻿using System.Runtime.InteropServices;

namespace R3.Tests.FactoryTests;

public class ReturnFrameTest
{
    [Fact]
    public void UnitTest()
    {
        var frameProvider = new FakeFrameProvider();
        var cts = new CancellationTokenSource();

        var list = Observable.YieldFrame(frameProvider, cts.Token).ToLiveList();
        list.AssertIsNotCompleted();

        frameProvider.Advance();
        list.AssertIsCompleted();
        list.AssertEqual([Unit.Default]);
    }

    [Fact]
    public void ValueTest()
    {
        {
            var frameProvider = new FakeFrameProvider();
            var cts = new CancellationTokenSource();

            var list = Observable.ReturnFrame(10, frameProvider, cts.Token).ToLiveList();
            list.AssertIsNotCompleted();

            frameProvider.Advance();
            list.AssertIsCompleted();
            list.AssertEqual([10]);
        }
        {
            var frameProvider = new FakeFrameProvider();
            var cts = new CancellationTokenSource();

            var list = Observable.ReturnFrame(10, frameProvider, cts.Token).ToLiveList();
            list.AssertIsNotCompleted();

            cts.Cancel();
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void TimeTest()
    {
        var frameProvider = new FakeFrameProvider();
        var cts = new CancellationTokenSource();

        var list = Observable.ReturnFrame(10, 5, frameProvider, cts.Token).ToLiveList();
        list.AssertIsNotCompleted();

        frameProvider.Advance(4);
        list.AssertIsNotCompleted();

        frameProvider.Advance(1);
        list.AssertIsCompleted();
        list.AssertEqual([10]);
    }

    [Fact]
    public void NextFrameTest()
    {
        {
            var frameProvider = new FakeFrameProvider();
            var cts = new CancellationTokenSource();

            var list = Observable.NextFrame(frameProvider, cts.Token).ToLiveList();
            list.AssertIsNotCompleted();

            frameProvider.Advance(1); // same frame, not run.
            list.AssertIsNotCompleted();

            frameProvider.Advance(1); // diffrent frame, ok to run.
            list.AssertIsCompleted();
            list.AssertEqual(Unit.Default);
        }
        {
            var frameProvider = new FakeFrameProvider(); // use custom fake
            var cts = new CancellationTokenSource();

            var list = Observable.YieldFrame(frameProvider, cts.Token).ToLiveList();
            list.AssertIsNotCompleted();

            // ReturnFrame run same frame.
            frameProvider.Advance(1);

            list.AssertIsCompleted();
            list.AssertEqual(Unit.Default);
        }
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/ReturnOnCompletedTest.cs
================================================
﻿
namespace R3.Tests.FactoryTests;

public class ReturnOnCompletedTest
{
    // test
    [Fact]
    public void ReturnOnCompleted()
    {
        {
            using var list = Observable.ReturnOnCompleted<int>(Result.Success).ToLiveList();
            list.AssertEqual([]);
            list.AssertIsCompleted();
        }
        {
            var fakeTime = new FakeTimeProvider();

            using var list = Observable.ReturnOnCompleted<int>(Result.Success, TimeSpan.FromSeconds(5), fakeTime).ToLiveList();

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertEqual([]);
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertEqual([]);
            list.AssertIsCompleted();
        }
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/ReturnTest.cs
================================================
﻿using Microsoft.Extensions.Time.Testing;

namespace R3.Tests.FactoryTests;

public class ReturnTest
{
    [Fact]
    public void Return()
    {
        {
            using var list = Observable.Return(10).ToLiveList();
            list.AssertEqual([10]);
            list.AssertIsCompleted();
        }
        {
            var fakeTime = new FakeTimeProvider();

            using var list = Observable.Return(10, TimeSpan.Zero, fakeTime).ToLiveList();
            list.AssertEqual([10]);
            list.AssertIsCompleted();
        }
        {
            var fakeTime = new FakeTimeProvider();

            using var list = Observable.Return(10, TimeSpan.FromSeconds(5), fakeTime).ToLiveList();
            list.AssertEqual([]);

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertEqual([]);
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertEqual([10]);
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void ReturnThreadPoolScheduleOptimized()
    {
        using var list = Observable.Return(10).ToLiveList();

        Thread.Sleep(1);

        list.AssertEqual([10]);
        list.AssertIsCompleted();
    }

    // return on completed
    [Fact]
    public void ReturnOnCompleted()
    {
        {
            using var list = Observable.Return(0).ToLiveList();
            list.AssertEqual([0]);
            list.AssertIsCompleted();
        }
        {
            var fakeTime = new FakeTimeProvider();

            using var list = Observable.Return(10, TimeSpan.FromSeconds(5), fakeTime).ToLiveList();
            list.AssertEqual([]);

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertEqual([]);
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertEqual([10]);
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void Optimized()
    {
        for (int i = -10; i < 100; i++)
        {
            using var list = Observable.Return(i).ToLiveList(); // int optimized
            list.AssertEqual([i]);
            list.AssertIsCompleted();
        }

        foreach (var item in new bool[] { true, false })
        {
            using var list = Observable.Return(item).ToLiveList(); // bool optimized
            list.AssertEqual([item]);
            list.AssertIsCompleted();
        }

        Observable.Return(Unit.Default).ToLiveList().AssertEqual([Unit.Default]);
        Observable.ReturnUnit().ToLiveList().AssertEqual([Unit.Default]);
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/ThrowTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class ThrowTest
{
    // throw test
    [Fact]
    public void Throw()
    {
        {
            var e = new Exception();
            using var list = Observable.Throw<int>(e).ToLiveList();
            list.AssertEqual([]);
            list.Result.IsFailure.ShouldBeTrue();
            list.Result.Exception.ShouldBe(e);
        }
        {
            var fakeTime = new FakeTimeProvider();

            var e = new Exception();
            using var list = Observable.Throw<int>(e, TimeSpan.FromSeconds(5), fakeTime).ToLiveList();

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertEqual([]);
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertEqual([]);
            list.Result.IsFailure.ShouldBeTrue();
            list.Result.Exception.ShouldBe(e);
        }
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/TimerFrameTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class TimerFrameTest
{

    [Fact]
    public void TimerSingle()
    {
        {
            var fakeTime = new FakeFrameProvider();
            var list = Observable.TimerFrame(0, fakeTime).ToLiveList();
            fakeTime.Advance(1);
            list.AssertIsCompleted();
            list.AssertEqual([Unit.Default]);
        }
        {
            var fakeTime = new FakeFrameProvider();
            var list = Observable.TimerFrame(1, fakeTime).ToLiveList();
            fakeTime.Advance(1);
            list.AssertIsCompleted();
            list.AssertEqual([Unit.Default]);
        }
        {
            var fakeTime = new FakeFrameProvider();
            var list = Observable.TimerFrame(2, fakeTime).ToLiveList();
            fakeTime.Advance(2);
            list.AssertIsCompleted();
            list.AssertEqual([Unit.Default]);
        }
    }

    [Fact]
    public void TimerSingle2()
    {
        var fakeTime = new FakeFrameProvider();

        var list = Observable.TimerFrame(5, fakeTime).ToLiveList();

        fakeTime.Advance(4);
        list.AssertIsNotCompleted();

        fakeTime.Advance(1);
        list.AssertIsCompleted();
        list.AssertEqual(new[] { Unit.Default });
    }

    [Fact]
    public void TimerMulti()
    {
        var cts = new CancellationTokenSource();
        var fakeTime = new FakeFrameProvider();

        var list = Observable.TimerFrame(5, 8, fakeTime, cts.Token).ToLiveList();

        fakeTime.Advance(4);
        list.AssertIsNotCompleted();

        fakeTime.Advance(1);
        list.AssertIsNotCompleted();
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(7);
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(1);
        list.AssertEqual([Unit.Default, Unit.Default]);

        fakeTime.Advance(8);
        list.AssertEqual([Unit.Default, Unit.Default, Unit.Default]);

        cts.Cancel();
        list.AssertIsCompleted();
    }

    [Fact]
    public void Interval()
    {
        var cts = new CancellationTokenSource();
        var fakeTime = new FakeFrameProvider();

        var list = Observable.IntervalFrame(5, fakeTime, cts.Token).ToLiveList();

        fakeTime.Advance(4);
        list.AssertIsNotCompleted();

        fakeTime.Advance(1);
        list.AssertIsNotCompleted();
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(4);
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(1);
        list.AssertEqual([Unit.Default, Unit.Default]);

        fakeTime.Advance(5);
        list.AssertEqual([Unit.Default, Unit.Default, Unit.Default]);

        cts.Cancel();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/FactoryTests/TimerTest.cs
================================================
﻿namespace R3.Tests.FactoryTests;

public class TimerTest
{
    [Fact]
    public void TimerSingle()
    {
        {
            var fakeTime = new FakeTimeProvider();

            var list = Observable.Timer(TimeSpan.FromSeconds(5), fakeTime).ToLiveList();

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertIsCompleted();
            list.AssertEqual([Unit.Default]);
        }
        {
            var fakeTime = new FakeTimeProvider();

            var dueTime = fakeTime.GetUtcNow().AddSeconds(5);

            var list = Observable.Timer(dueTime, fakeTime).ToLiveList();

            fakeTime.Advance(TimeSpan.FromSeconds(4));
            list.AssertIsNotCompleted();

            fakeTime.Advance(TimeSpan.FromSeconds(1));
            list.AssertIsCompleted();
            list.AssertEqual([Unit.Default]);
        }
    }

    [Fact]
    public void TimerMulti()
    {
        var cts = new CancellationTokenSource();
        var fakeTime = new FakeTimeProvider();

        var list = Observable.Timer(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(8), fakeTime, cts.Token).ToLiveList();

        fakeTime.Advance(TimeSpan.FromSeconds(4));
        list.AssertIsNotCompleted();

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        list.AssertIsNotCompleted();
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(7));
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([Unit.Default, Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(8));
        list.AssertEqual([Unit.Default, Unit.Default, Unit.Default]);

        cts.Cancel();
        list.AssertIsCompleted();
    }

    [Fact]
    public void Interval()
    {
        var cts = new CancellationTokenSource();
        var fakeTime = new FakeTimeProvider();

        var list = Observable.Interval(TimeSpan.FromSeconds(5), fakeTime, cts.Token).ToLiveList();

        fakeTime.Advance(TimeSpan.FromSeconds(4));
        list.AssertIsNotCompleted();

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        list.AssertIsNotCompleted();
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(4));
        list.AssertEqual([Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([Unit.Default, Unit.Default]);

        fakeTime.Advance(TimeSpan.FromSeconds(5));
        list.AssertEqual([Unit.Default, Unit.Default, Unit.Default]);

        cts.Cancel();
        list.AssertIsCompleted();
    }

}



================================================
FILE: tests/R3.Tests/FactoryTests/ToObservableTest.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace R3.Tests.FactoryTests;

public class ToObservableTest
{
    [Fact]
    public async Task TaskToObservable()
    {
        var fakeTime = new FakeTimeProvider();
        var t = System.Threading.Tasks.Task.Run(async () =>
        {
            await Task.Delay(TimeSpan.FromSeconds(1), fakeTime);
            return 100;
        });
        var list = t.ToObservable().ToLiveList();

        list.AssertIsNotCompleted();

        fakeTime.Advance(TimeSpan.FromSeconds(1));
        await t;
        await Task.Delay(1); // wait

        list.AssertIsCompleted();
        list.AssertEqual([100]);
    }

    [Fact]
    public void EnumerableToObservable()
    {
        {
            var list = Enumerable.Range(0, 10).ToObservable().ToLiveList();

            list.AssertEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
            list.AssertIsCompleted();
        }
        {
            var cts = new CancellationTokenSource();

            var list = Enumerable.Range(0, int.MaxValue)
                .ToObservable(cts.Token)
                .Take(10)
                .DoCancelOnCompleted(cts)
                .ToLiveList();

            list.AssertEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void ObservableToObservable()
    {
        var l1 = new SuccessObservable().ToObservable().ToLiveList();
        l1.AssertEqual([1, 2, 3]);
        l1.AssertIsCompleted();

        var l2 = new FaileObservable().ToObservable().ToLiveList();
        l2.AssertEqual([1, 2, 3]);
        l2.AssertIsCompleted();
        l2.Result.IsFailure.ShouldBeTrue();
    }

    [Fact]
    public async Task AsyncEnumerableToObservable()
    {
        var fakeTime = new FakeTimeProvider();
        using var list = AsyncOne(fakeTime).ToObservable().ToLiveList();

        list.AssertEqual([1]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));

        await Task.Delay(1000);
        await Task.Yield();
        list.AssertEqual([1, 2]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));

        await Task.Delay(1000);
        await Task.Yield();
        list.AssertEqual([1, 2, 3]);
    }

    [Fact]
    public async Task AsyncEnumerableToObservableCt()
    {
        var fakeTime = new FakeTimeProvider();
        using var list = AsyncOne(fakeTime).ToObservable().ToLiveList();

        list.AssertEqual([1]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));

        await Task.Delay(1000);
        await Task.Yield();
        list.AssertEqual([1, 2]);

        list.Dispose();
    }

    [Fact]
    public async Task AsyncEnumerableToObservableEx()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var fakeTime = new FakeTimeProvider();
        using var list = AsyncTwo(fakeTime).ToObservable().ToLiveList();

        list.AssertEqual([1]);

        fakeTime.Advance(TimeSpan.FromSeconds(1));

        await Task.Delay(1000);
        await Task.Yield();
        list.AssertEqual([1, 2]);

        list.AssertIsNotCompleted();
        fakeTime.Advance(TimeSpan.FromSeconds(1));

        list.Result.IsFailure.ShouldBeTrue();
        list.Result.Exception!.Message.ShouldBe("foo");
    }

    async IAsyncEnumerable<int> AsyncOne(TimeProvider timeProvider, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        yield return 1;
        await Task.Delay(TimeSpan.FromSeconds(1), timeProvider, cancellationToken);
        yield return 2;
        await Task.Delay(TimeSpan.FromSeconds(1), timeProvider, cancellationToken);
        yield return 3;
        await Task.Delay(TimeSpan.FromSeconds(1), timeProvider, cancellationToken);
    }

    async IAsyncEnumerable<int> AsyncTwo(TimeProvider timeProvider, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        yield return 1;
        await Task.Delay(TimeSpan.FromSeconds(1), timeProvider, cancellationToken);
        yield return 2;
        await Task.Delay(TimeSpan.FromSeconds(1), timeProvider, cancellationToken);
        throw new Exception("foo");
    }

    class SuccessObservable : IObservable<int>
    {
        public IDisposable Subscribe(IObserver<int> observer)
        {
            observer.OnNext(1);
            observer.OnNext(2);
            observer.OnNext(3);
            observer.OnCompleted();
            return Disposable.Empty;
        }
    }

    class FaileObservable : IObservable<int>
    {
        public IDisposable Subscribe(IObserver<int> observer)
        {
            observer.OnNext(1);
            observer.OnNext(2);
            observer.OnNext(3);
            observer.OnError(new Exception());
            return Disposable.Empty;
        }
    }

    [Fact]
    public void TaskToObservable2()
    {
        var tcs = new TaskCompletionSource();

        var myLiveList = tcs.Task.ToObservable()
            .Select(x => x)
            .Where(x => true)
            .Take(10)
            .ToLiveList();

        myLiveList.Dispose();

        tcs.TrySetResult();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AggregateByTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AggregateByTest
{
    [Fact]
    public async Task AggregateBy()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateByAsync(x => x % 2 == 0, 100, (sum, x) => x + sum);

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        var result = await task;
        result.FirstOrDefault(x => x.Key).Value.ShouldBe(106);
        result.FirstOrDefault(x => !x.Key).Value.ShouldBe(109);
    }

    [Fact]
    public async Task AggregateBy_Empty()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateByAsync(x => x % 2 == 0, 100, (sum, x) => x + sum);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);
        publisher.OnCompleted();

        (await task).ShouldBeEmpty();
    }

    [Fact]
    public async Task AggregateBy_One()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateByAsync(x => x % 2 == 0, 100, (sum, x) => x + sum);

        publisher.OnNext(2);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);
        publisher.OnCompleted();

        var result = await task;
        result.Count().ShouldBe(1);
        result.First().Value.ShouldBe(102);
    }

    [Fact]
    public async Task AggregateBy_SeedSelector()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateByAsync(
            x => x % 2 == 0,
            key => key ? 100 : 0,
            (sum, x) => x + sum);

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        var result = await task;
        result.FirstOrDefault(x => x.Key).Value.ShouldBe(106);
        result.FirstOrDefault(x => !x.Key).Value.ShouldBe(9);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AggregateTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AggregateTest
{
    [Fact]
    public async Task Reduce()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateAsync((result, x) => result + x);

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        (await task).ShouldBe(15);
    }

    [Fact]
    public async Task ReduceEmptyElement()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateAsync((result, x) => result + x);
        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task);
    }

    [Fact]
    public async Task ReduceOneElement()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateAsync((result, x) => result + x);
        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnNext(100);
        publisher.OnCompleted();

        (await task).ShouldBe(100);
    }

    [Fact]
    public async Task Aggregate()
    {
        var publisher = new Subject<int>();

        var listTask = publisher.AggregateAsync(new List<int>(), (x, i) => { x.Add(i); return x; });

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        (await listTask).ShouldBe([1, 2, 3, 4, 5]);
    }

    [Fact]
    public async Task AggregateWithResultSelector()
    {
        var publisher = new Subject<int>();

        var task = publisher.AggregateAsync(0, (max, x) => max < x ? x : max, x => x.ToString());

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        (await task).ShouldBe("5");
    }

    [Fact]
    public async Task ImmediateCompleted()
    {
        var range = Observable.Range(1, 5);
        var listTask = range.AggregateAsync(new List<int>(), (x, i) => { x.Add(i); return x; }, (x) => x);
        (await listTask).ShouldBe([1, 2, 3, 4, 5]);
    }

    [Fact]
    public async Task BeforeCanceled()
    {
        var cts = new CancellationTokenSource();
        cts.Cancel();

        var publisher = new Subject<int>();
        var isDisposed = false;

        var listTask = publisher
            .Do(onDispose: () => isDisposed = true)
            .AggregateAsync(new List<int>(), (x, i) => { x.Add(i); return x; }, (x) => x, cts.Token);


        isDisposed.ShouldBeTrue();

        await Assert.ThrowsAsync<TaskCanceledException>(async () => await listTask);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AllTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AllTest
{
    [Fact]
    public async Task Positive()
    {
        var range = Observable.Range(1, 10);
        var task = range.AllAsync(static x => x is > 0 and <= 10);
        (await task).ShouldBeTrue();
    }

    [Fact]
    public async Task Negative()
    {
        var range = Observable.Range(1, 10);
        var task = range.AllAsync(static x => x is > 0 and < 10);
        (await task).ShouldBeFalse();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AnyTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AnyTest
{
    [Fact]
    public async Task Positive()
    {
        var range = Observable.Range(1, 10);
        var task = range.AnyAsync(static x => x is 5);
        (await task).ShouldBeTrue();
    }

    [Fact]
    public async Task Negative()
    {
        var range = Observable.Range(1, 10);
        var task = range.AnyAsync(static x => x is 11);
        (await task).ShouldBeFalse();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AsObservableTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AsObservableTest
{
    [Fact]
    public void AsObservable()
    {
        var p = new Subject<int>();

        var l = p.AsObservable().AsObservable().ToLiveList();
        p.OnNext(1);
        p.OnNext(2);
        p.OnNext(3);
        p.OnCompleted();

        l.AssertEqual([1, 2, 3]);
        l.AssertIsCompleted();
    }

    [Fact]
    public void AsSystemObservable()
    {

        {
            var p = new Subject<int>();
            var l = new List<int>();
            Exception? ex = null;
            bool completed = false;
            p.AsSystemObservable().Subscribe(l.Add, e => ex = e, () => completed = true);

            p.OnNext(1);
            p.OnNext(2);
            p.OnNext(3);
            p.OnCompleted();

            l.ShouldBe([1, 2, 3]);
            completed.ShouldBeTrue();
        }
        {
            // error complete
            var p = new Subject<int>();
            var l = new List<int>();
            Exception? ex = null;
            bool completed = false;
            p.AsSystemObservable().Subscribe(l.Add, e => ex = e, () => completed = true);

            p.OnNext(1);
            p.OnNext(2);
            p.OnNext(3);
            p.OnCompleted(new Exception("aaa"));

            l.ShouldBe([1, 2, 3]);
            ex!.Message.ShouldBe("aaa");
            completed.ShouldBeFalse();
        }
        {
            // error resume
            var p = new Subject<int>();
            var l = new List<int>();
            Exception? ex = null;
            bool completed = false;
            p.AsSystemObservable().Subscribe(l.Add, e => ex = e, () => completed = true);

            p.OnNext(1);
            p.OnNext(2);
            p.OnNext(3);
            p.OnErrorResume(new Exception("bbb"));

            l.ShouldBe([1, 2, 3]);
            ex!.Message.ShouldBe("bbb");
            completed.ShouldBeFalse();
        }
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AsUnitObservableTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class AsUnitObservableTest
{
    [Fact]
    public void Test()
    {
        var subject = new Subject<int>();
        using var list = subject.AsUnitObservable().ToLiveList();

        subject.OnNext(10);
        subject.OnNext(20);

        list.AssertEqual([Unit.Default, Unit.Default]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/AverageTest.cs
================================================
﻿using System.Globalization;
using System.Numerics;

namespace R3.Tests.OperatorTests;

public class AverageTest
{
    [Fact]
    public async Task Empty()
    {
        await Assert.ThrowsAsync<InvalidOperationException>(async () =>
        {
            await Observable.Empty<int>().AverageAsync();
        });
        //await Assert.ThrowsAsync<InvalidOperationException>(async () =>
        //{
        //    await Observable.Empty<TestNumber>().AverageAsync();
        //});

        await Assert.ThrowsAsync<InvalidOperationException>(async () =>
        {
            await Observable.Empty<int>().AverageAsync(x => x);
        });
        //await Assert.ThrowsAsync<InvalidOperationException>(async () =>
        //{
        //    await Observable.Empty<TestNumber>().AverageAsync(x => x);
        //});
    }

    [Fact]
    public async Task One()
    {
        (await Observable.Return(7).AverageAsync()).ShouldBe(7.0);
        (await Observable.Return(7).AverageAsync(x => x * 10)).ShouldBe(70.0);
        //(await Observable.Return(new TestNumber(7)).AverageAsync()).ShouldBe(7.0);
        //(await Observable.Return(new TestNumber(7)).AverageAsync(x => x)).ShouldBe(7.0);
    }

    [Fact]
    public async Task AnyValues()
    {
        var values = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 };

        var result = await values.ToObservable().AverageAsync();
        result.ShouldBe(values.Average());

        result = await values.ToObservable().AverageAsync(x => x * 2);
        result.ShouldBe(values.Average(x => x * 2));
    }

    [Fact]
    public async Task Error()
    {
        var error = Observable.Range(0, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () => await error.AverageAsync());
        await Assert.ThrowsAsync<Exception>(async () => await error.OnErrorResumeAsFailure().AverageAsync());
    }

    [Fact]
    public async Task SelectorError()
    {
        var o = Observable.Range(1, 10);

        await Assert.ThrowsAsync<Exception>(async () => await o.AverageAsync(_ => throw new Exception("foo")));
        await Assert.ThrowsAsync<Exception>(async () => await o.Select(x => new TestNumber(x)).AverageAsync(x => throw new Exception("bra")));
    }

    //[Fact]
    //public async Task DoubleConvertError()
    //{
    //    var o = Observable.Return(new TestNumber(100, CannotConvert: true));

    //    await Assert.ThrowsAsync<NotSupportedException>(async () =>
    //    {
    //        await o.AverageAsync();
    //    });
    //    await Assert.ThrowsAsync<NotSupportedException>(async () =>
    //    {
    //        await o.AverageAsync(x => x);
    //    });
    //}
}

file record struct TestNumber(int Value, bool CannotConvert = false) : INumberBase<TestNumber>
{
    public static TestNumber operator +(TestNumber left, TestNumber right) =>
        new(left.Value + right.Value, right.CannotConvert);

    public static TestNumber operator /(TestNumber left, TestNumber right) =>
        new(left.Value / right.Value, right.CannotConvert);

    public string ToString(string? format, IFormatProvider? formatProvider)
    {
        throw new NotImplementedException();
    }

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        throw new NotImplementedException();
    }

    public static TestNumber Parse(string s, IFormatProvider? provider)
    {
        throw new NotImplementedException();
    }

    public static bool TryParse(string? s, IFormatProvider? provider, out TestNumber result)
    {
        throw new NotImplementedException();
    }

    public static TestNumber Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
    {
        throw new NotImplementedException();
    }

    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TestNumber result)
    {
        throw new NotImplementedException();
    }

    public static TestNumber AdditiveIdentity => throw new NotImplementedException();

    public static TestNumber operator --(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static TestNumber operator ++(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static TestNumber MultiplicativeIdentity => throw new NotImplementedException();
    public static TestNumber operator *(TestNumber left, TestNumber right)
    {
        throw new NotImplementedException();
    }

    public static TestNumber operator -(TestNumber left, TestNumber right)
    {
        throw new NotImplementedException();
    }

    public static TestNumber operator -(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static TestNumber operator +(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static TestNumber Abs(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsCanonical(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsComplexNumber(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsEvenInteger(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsFinite(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsImaginaryNumber(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsInfinity(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsInteger(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsNaN(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsNegative(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsNegativeInfinity(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsNormal(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsOddInteger(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsPositive(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsPositiveInfinity(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsRealNumber(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsSubnormal(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static bool IsZero(TestNumber value)
    {
        throw new NotImplementedException();
    }

    public static TestNumber MaxMagnitude(TestNumber x, TestNumber y)
    {
        throw new NotImplementedException();
    }

    public static TestNumber MaxMagnitudeNumber(TestNumber x, TestNumber y)
    {
        throw new NotImplementedException();
    }

    public static TestNumber MinMagnitude(TestNumber x, TestNumber y)
    {
        throw new NotImplementedException();
    }

    public static TestNumber MinMagnitudeNumber(TestNumber x, TestNumber y)
    {
        throw new NotImplementedException();
    }

    public static TestNumber Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider)
    {
        throw new NotImplementedException();
    }

    public static TestNumber Parse(string s, NumberStyles style, IFormatProvider? provider)
    {
        throw new NotImplementedException();
    }

    public static bool TryConvertFromChecked<TOther>(TOther value, out TestNumber result) where TOther : INumberBase<TOther>
    {
        throw new NotImplementedException();
    }

    public static bool TryConvertFromSaturating<TOther>(TOther value, out TestNumber result) where TOther : INumberBase<TOther>
    {
        throw new NotImplementedException();
    }

    public static bool TryConvertFromTruncating<TOther>(TOther value, out TestNumber result) where TOther : INumberBase<TOther>
    {
        throw new NotImplementedException();
    }

    public static bool TryConvertToChecked<TOther>(TestNumber value, out TOther result) where TOther : INumberBase<TOther>
    {
        if (value.CannotConvert)
        {
            throw new NotSupportedException();
        }

        if (typeof(TOther) == typeof(double))
        {
            result = (TOther)(object)(double)value.Value;
            return true;
        }
        throw new NotImplementedException();
    }

    public static bool TryConvertToSaturating<TOther>(TestNumber value, out TOther result) where TOther : INumberBase<TOther>
    {
        throw new NotImplementedException();
    }

    public static bool TryConvertToTruncating<TOther>(TestNumber value, out TOther result) where TOther : INumberBase<TOther>
    {
        throw new NotImplementedException();
    }

    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out TestNumber result)
    {
        throw new NotImplementedException();
    }

    public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out TestNumber result)
    {
        throw new NotImplementedException();
    }

    public static TestNumber One => throw new NotImplementedException();
    public static int Radix => throw new NotImplementedException();
    public static TestNumber Zero => throw new NotImplementedException();
}



================================================
FILE: tests/R3.Tests/OperatorTests/CastTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class CastTest
{
    [Fact]
    public void Cast()
    {
        var subject = new Subject<object>();
        using var list = subject.Cast<object, int>().ToLiveList();

        subject.OnNext(10);
        subject.OnNext(20);
        subject.OnNext(30);

        list.AssertEqual([10, 20, 30]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/CatchTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class CatchTest
{
    [Fact]
    public void CatchSecond()
    {
        {
            var first = new Subject<int>();
            var second = new Subject<int>();

            using var list = first.Catch(second).ToLiveList();

            first.OnNext(10);
            first.OnNext(20);
            first.OnNext(30);
            second.OnNext(9999);
            first.OnCompleted();
            second.OnNext(9998);

            list.AssertEqual([10, 20, 30]);
            list.AssertIsCompleted();
        }
        {
            var first = new Subject<int>();
            var second = new Subject<int>();

            using var list = first.Catch(second).ToLiveList();

            first.OnNext(10);
            first.OnNext(20);
            first.OnNext(30);
            second.OnNext(9999);
            first.OnCompleted(new Exception()); // error, so switch to second
            list.AssertIsNotCompleted();
            second.OnNext(9998);

            list.AssertEqual([10, 20, 30, 9998]);
            second.OnCompleted();
            list.AssertIsCompleted();
        }
    }

    [Fact]
    public void CatchHandler()
    {
        {
            var first = new Subject<int>();
            var second = new Subject<int>();

            using var list = first.Catch<int, ArgumentException>(ex => second).ToLiveList();

            first.OnNext(10);
            first.OnNext(20);
            first.OnNext(30);
            second.OnNext(9999);
            first.OnCompleted();
            second.OnNext(9998);

            list.AssertEqual([10, 20, 30]);
            list.AssertIsCompleted();
        }
        {
            var first = new Subject<int>();
            var second = new Subject<int>();

            using var list = first.Catch<int, ArgumentException>(ex => second).ToLiveList();

            first.OnNext(10);
            first.OnNext(20);
            first.OnNext(30);
            second.OnNext(9999);
            first.OnCompleted(new Exception()); // error, but not switch
            list.AssertEqual([10, 20, 30]);
            list.AssertIsCompleted();
        }
        {
            var first = new Subject<int>();
            var second = new Subject<int>();

            using var list = first.Catch<int, ArgumentException>(ex => second).ToLiveList();

            first.OnNext(10);
            first.OnNext(20);
            first.OnNext(30);
            second.OnNext(9999);
            first.OnCompleted(new ArgumentException()); // error, switch
            list.AssertIsNotCompleted();
            second.OnNext(9998);

            list.AssertEqual([10, 20, 30, 9998]);
            second.OnCompleted();
            list.AssertIsCompleted();
        }
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ChunkTest.cs
================================================
﻿using R3.Collections;

namespace R3.Tests.OperatorTests;

public class ChunkTest
{
    [Fact]
    public void Chunk()
    {
        var subject = new Subject<int>();

        var list = subject.Chunk(3).ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        list.AssertEqual([[1, 2, 3]]);

        subject.OnNext(4);
        subject.OnNext(5);
        subject.OnNext(6);
        list.AssertEqual([1, 2, 3], [4, 5, 6]);

        subject.OnNext(7);
        subject.OnNext(8);
        subject.OnNext(9);
        list.AssertEqual([1, 2, 3], [4, 5, 6], [7, 8, 9]);

        subject.OnNext(10);

        subject.OnCompleted();

        list.AssertEqual([1, 2, 3], [4, 5, 6], [7, 8, 9], [10]);

        list.AssertIsCompleted();
    }

    // ChunkTime
    [Fact]
    public void ChunkTime()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Chunk(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));


        list.AssertEqual([[1, 10, 100, 1000, 10000]]);

        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        timeProvider.Advance(TimeSpan.FromSeconds(3));
        list.AssertEqual([[1, 10, 100, 1000, 10000], [2, 20, 200]]);

        publisher.OnNext(2300);


        publisher.OnCompleted();

        list.AssertEqual([[1, 10, 100, 1000, 10000], [2, 20, 200], [2300]]);

        list.AssertIsCompleted();
    }

    // ChunkTimeAndCount
    [Fact]
    public void ChunkTimeAndCount()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Chunk(TimeSpan.FromSeconds(3), 2, timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        list.AssertEqual([1, 10]);
        publisher.OnNext(100);
        list.AssertEqual([1, 10]);

        timeProvider.Advance(TimeSpan.FromSeconds(3));

        list.AssertEqual([1, 10], [100]);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        publisher.OnNext(50);
        list.AssertEqual([1, 10], [100], [1000, 10000]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([1, 10], [100], [1000, 10000]);

        publisher.OnNext(2);
        publisher.OnNext(3);
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2]);
        timeProvider.Advance(TimeSpan.FromSeconds(2));
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3]);

        timeProvider.Advance(TimeSpan.FromSeconds(3));

        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3]);

        publisher.OnNext(4);

        publisher.OnCompleted();

        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3], [4]);

        list.AssertIsCompleted();
    }

    // ChunkWindowBoundary
    [Fact]
    public void ChunkWindowBoundary()
    {
        var publisher = new Subject<int>();
        var boundary = new Subject<Unit>();
        var list = publisher.Chunk(boundary).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        boundary.OnNext(Unit.Default);
        list.AssertEqual([[1, 10, 100]]);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([[1, 10, 100]]);

        boundary.OnNext(Unit.Default);
        list.AssertEqual([[1, 10, 100], [1000, 10000]]);

        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        list.AssertEqual([[1, 10, 100], [1000, 10000]]);

        boundary.OnNext(Unit.Default);
        list.AssertEqual([[1, 10, 100], [1000, 10000], [2, 20, 200]]);

        publisher.OnNext(500);

        publisher.OnCompleted();

        list.AssertEqual([[1, 10, 100], [1000, 10000], [2, 20, 200], [500]]);
        list.AssertIsCompleted();
    }

    // ChunkFrame
    [Fact]
    public void ChunkFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.ChunkFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        frameProvider.Advance(1);

        list.AssertEqual([[1, 10, 100, 1000, 10000]]);

        publisher.OnNext(2);
        publisher.OnNext(20);
        frameProvider.Advance(3);
        list.AssertEqual([[1, 10, 100, 1000, 10000], [2, 20]]);

        publisher.OnNext(50);


        publisher.OnCompleted();

        list.AssertEqual([[1, 10, 100, 1000, 10000], [2, 20], [50]]);


        list.AssertIsCompleted();
    }

    // ChunkFrameAndCount
    [Fact]
    public void ChunkFrameAndCount()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.ChunkFrame(3, 2, frameProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        list.AssertEqual([1, 10]);
        publisher.OnNext(100);
        list.AssertEqual([1, 10]);

        frameProvider.Advance(3);

        list.AssertEqual([1, 10], [100]);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        publisher.OnNext(50);
        list.AssertEqual([1, 10], [100], [1000, 10000]);

        frameProvider.Advance(1);
        list.AssertEqual([1, 10], [100], [1000, 10000]);

        publisher.OnNext(2);
        publisher.OnNext(3);
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2]);
        frameProvider.Advance(2);
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2]);

        frameProvider.Advance(1);
        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3]);

        frameProvider.Advance(3);

        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3]);

        publisher.OnNext(4);

        publisher.OnCompleted();

        list.AssertEqual([1, 10], [100], [1000, 10000], [50, 2], [3], [4]);

        list.AssertIsCompleted();
    }

    // Async
    [Fact]
    public void ChunkAsync()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var tp = new FakeTimeProvider();
        var list = publisher.Chunk(async (x, ct) =>
        {
            await Task.Delay(TimeSpan.FromSeconds(3), tp);

        }).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        tp.Advance(3);

        list.AssertEqual([[1, 10, 100]]);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([[1, 10, 100]]);

        tp.Advance(3);
        list.AssertEqual([[1, 10, 100], [1000, 10000]]);

        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        list.AssertEqual([[1, 10, 100], [1000, 10000]]);

        tp.Advance(1);
        list.AssertEqual([[1, 10, 100], [1000, 10000]]);

        tp.Advance(2);
        list.AssertEqual([[1, 10, 100], [1000, 10000], [2, 20, 200]]);

        publisher.OnNext(500);

        publisher.OnCompleted();

        list.AssertEqual([[1, 10, 100], [1000, 10000], [2, 20, 200], [500]]);
        list.AssertIsCompleted();
    }

    // count + skip
    [Fact]
    public async Task ChunkCountSkip()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        {
            var xs = await Observable.Range(1, 10).Chunk(3, 1).ToArrayAsync();

            xs[0].ShouldBe([1, 2, 3]);
            xs[1].ShouldBe([2, 3, 4]);
            xs[2].ShouldBe([3, 4, 5]);
            xs[3].ShouldBe([4, 5, 6]);
            xs[4].ShouldBe([5, 6, 7]);
            xs[5].ShouldBe([6, 7, 8]);
            xs[6].ShouldBe([7, 8, 9]);
            xs[7].ShouldBe([8, 9, 10]);
            xs[8].ShouldBe([9, 10]);
            xs[9].ShouldBe([10]);
        }

        // count == skip
        {
            var xs = await Observable.Range(1, 10).Chunk(3, 3).ToArrayAsync();

            xs[0].ShouldBe([1, 2, 3]);
            xs[1].ShouldBe([4, 5, 6]);
            xs[2].ShouldBe([7, 8, 9]);
            xs[3].ShouldBe([10]);
        }

        // count < skip
        {
            var xs = await Observable.Range(1, 20).Chunk(3, 5).ToArrayAsync();

            xs[0].ShouldBe([1, 2, 3]);
            xs[1].ShouldBe([6, 7, 8]);
            xs[2].ShouldBe([11, 12, 13]);
            xs[3].ShouldBe([16, 17, 18]);
        }
    }

    // FrameOperator should start on OnNext

    [Fact]
    public void ChunkFrame2()
    {
        var publisher = new Subject<int>();
        var provider = new FakeFrameProvider();

        using var list = publisher.ChunkFrame(5, provider).ToLiveList();

        provider.Advance(8); // tick 8 frame before OnNext(time is not starting)

        publisher.OnNext(1); // start timer
        publisher.OnNext(2);
        publisher.OnNext(3);

        provider.Advance(2);

        list.AssertEmpty();

        provider.Advance(3);

        list[0].ShouldBe([1, 2, 3]);

        provider.Advance(4); // timer is stopping

        publisher.OnNext(4);

        provider.Advance(1);

        list.Count.ShouldBe(1);

        publisher.OnNext(5);

        provider.Advance(4);

        list[1].ShouldBe([4, 5]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ChunkFrameCount2()
    {
        var publisher = new Subject<int>();
        var provider = new FakeFrameProvider();

        using var list = publisher.ChunkFrame(frameCount: 5, count: 10, provider).ToLiveList();

        provider.Advance(8); // tick 8 frame before OnNext(time is not starting)

        publisher.OnNext(1); // start timer
        publisher.OnNext(2);
        publisher.OnNext(3);

        provider.Advance(2);

        list.AssertEmpty();

        provider.Advance(3);

        list[0].ShouldBe([1, 2, 3]);

        provider.Advance(4); // timer is stopping

        publisher.OnNext(4);

        provider.Advance(1);

        list.Count.ShouldBe(1);

        publisher.OnNext(5);

        provider.Advance(4);

        list[1].ShouldBe([4, 5]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ChunkFrameCount2_countfull()
    {
        var publisher = new Subject<int>();
        var provider = new FakeFrameProvider();

        using var list = publisher.ChunkFrame(frameCount: 5, count: 2, provider).ToLiveList();

        provider.Advance(8); // tick 8 frame before OnNext(time is not starting)

        publisher.OnNext(1); // start timer

        provider.Advance(3);

        publisher.OnNext(2); // count full, timer reset

        list[0].ShouldBe([1, 2]);

        publisher.OnNext(3);

        provider.Advance(2);

        list.Count().ShouldBe(1);

        provider.Advance(3);

        list[1].ShouldBe([3]);
    }

    // ChunkUntil

    [Fact]
    public void ChunkUntil()
    {
        var publisher = new Subject<int>();
        var list = publisher.ChunkUntil(x => x % 3 == 0).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(4);
        publisher.OnNext(5);

        list.Count.Is(0);
        publisher.OnNext(3); // true

        list.ShouldBe([[1, 2, 4, 5, 3]]);

        publisher.OnNext(8);
        publisher.OnNext(9); // true

        list.ShouldBe([[1, 2, 4, 5, 3], [8, 9]]);

        publisher.OnNext(10);
        publisher.OnCompleted();
        list.ShouldBe([[1, 2, 4, 5, 3], [8, 9], [10]]);
        list.IsCompleted.ShouldBeTrue();
    }

    [Fact]
    public void ChunkUntilIndex()
    {
        var publisher = new Subject<int>();
        var list = publisher.ChunkUntil((x, i) => i % 3 == 0).ToLiveList();

        publisher.OnNext(1); // 0
        publisher.OnNext(2); // 1
        publisher.OnNext(4); // 2
        publisher.OnNext(5); // 3

        list.ShouldBe([[1], [2, 4, 5]]);
    }
}





================================================
FILE: tests/R3.Tests/OperatorTests/CombineLatestTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class CombineLatestTest
{
    [Fact]
    public void CombineLatest()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<string>();

        using var list = source1.CombineLatest(source2, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);

        list.AssertEmpty();

        source1.OnNext(2);

        list.AssertEmpty();

        source2.OnNext("a");

        list.AssertEqual([(2, "a")]);

        source1.OnNext(3);

        list.AssertEqual([(2, "a"), (3, "a")]);

        source2.OnNext("b");

        list.AssertEqual([(2, "a"), (3, "a"), (3, "b")]);

        source2.OnNext("c");

        list.AssertEqual([(2, "a"), (3, "a"), (3, "b"), (3, "c")]);

        source1.OnCompleted();

        list.AssertIsNotCompleted();

        source1.OnNext(4);
        source2.OnNext("d");

        list.AssertEqual([(2, "a"), (3, "a"), (3, "b"), (3, "c"), (3, "d")]);

        source2.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void CombineLatestCompletedCheck()
    {
        {
            var source1 = new Subject<int>();
            var source2 = new Subject<int>();
            var source3 = new Subject<int>();
            using var list = Observable.CombineLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

            // no value cached complete
            source1.OnCompleted();

            list.AssertIsCompleted();
        }
        {
            var source1 = new Subject<int>();
            var source2 = new Subject<int>();
            var source3 = new Subject<int>();
            using var list = Observable.CombineLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

            // value cached, ok
            source1.OnNext(1);
            source1.OnCompleted();

            list.AssertIsNotCompleted();
        }
    }

    [Fact]
    public void CombineLatestCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.CombineLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);

        list.AssertEqual((1, 10, 100));

        source1.OnCompleted();
        list.AssertIsNotCompleted();

        source2.OnCompleted();
        list.AssertIsNotCompleted();

        source3.OnNext(200);
        list.AssertEqual((1, 10, 100), (1, 10, 200));

        source3.OnCompleted();
        list.AssertIsCompleted(); // all completed
    }

    [Fact]
    public void NthCombineLatestCompletedCheck()
    {
        {
            var source1 = new Subject<int>();
            var source2 = new Subject<int>();
            var source3 = new Subject<int>();
            using var list = Observable.CombineLatest(source1, source2, source3).ToLiveList();

            // no value cached complete
            source1.OnCompleted();

            list.AssertIsCompleted();
        }
        {
            var source1 = new Subject<int>();
            var source2 = new Subject<int>();
            var source3 = new Subject<int>();
            using var list = Observable.CombineLatest(source1, source2, source3).ToLiveList();

            // value cached, ok
            source1.OnNext(1);
            source1.OnCompleted();

            list.AssertIsNotCompleted();
        }
    }

    [Fact]
    public void NthCombineLatestCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.CombineLatest(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);

        list.AssertEqual([1, 10, 100]);

        source1.OnCompleted();
        list.AssertIsNotCompleted();

        source2.OnCompleted();
        list.AssertIsNotCompleted();

        source3.OnNext(200);
        list.AssertEqual([1, 10, 100], [1, 10, 200]);

        source3.OnCompleted();
        list.AssertIsCompleted(); // all completed
    }

    [Fact]
    public void CombineLatestFactoryAndEmpty()
    {
        var empty = Enumerable.Empty<Observable<int>>();
        var liveList = Observable.CombineLatest(empty).ToLiveList();

        // not never, return empty
        liveList.IsCompleted.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ConcatAppendPrependTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ConcatAppendPrependTest
{
    [Fact]
    public void Prepend()
    {
        var subject = new Subject<int>();
        using var list = subject.Prepend(9999).ToLiveList();

        subject.OnNext(10);

        list.AssertEqual([9999, 10]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void Prepend2()
    {
        using var list = Observable.Range(1, 3).Prepend(9999).ToLiveList();

        list.AssertEqual([9999, 1, 2, 3]);
    }

    [Fact]
    public void Append()
    {
        var subject = new Subject<int>();
        using var list = subject.Append(9999).ToLiveList();

        subject.OnNext(10);

        list.AssertEqual([10]);

        subject.OnCompleted();

        list.AssertEqual([10, 9999]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void Concat()
    {
        var subject = new Subject<int>();
        var subject2 = new Subject<int>();
        using var list = subject.Concat(subject2).ToLiveList();

        subject.OnNext(10);
        subject2.OnNext(9999);

        list.AssertEqual([10]);

        subject.OnCompleted();

        subject2.OnNext(11111);

        list.AssertEqual([10, 11111]);

        subject2.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatMany()
    {
        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();
        using var list = Observable.Concat(subject1, subject2, subject3).ToLiveList();

        subject1.OnNext(10);
        subject2.OnNext(9999);

        list.AssertEqual([10]);

        subject1.OnCompleted();

        subject2.OnNext(11111);

        list.AssertEqual([10, 11111]);

        subject2.OnCompleted();

        subject3.OnNext(9999999);

        list.AssertEqual([10, 11111, 9999999]);

        subject3.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatNestedSources()
    {
        var outerSubject = new Subject<Observable<int>>();
        using var list = outerSubject.Concat().ToLiveList();

        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();

        outerSubject.OnNext(subject1);
        outerSubject.OnNext(subject2);
        outerSubject.OnNext(subject3);

        subject1.OnNext(10);
        subject2.OnNext(9999);

        list.AssertEqual([10]);

        subject1.OnCompleted();

        subject2.OnNext(11111);

        list.AssertEqual([10, 11111]);

        subject2.OnCompleted();

        subject3.OnNext(9999999);

        list.AssertEqual([10, 11111, 9999999]);

        subject3.OnCompleted();

        outerSubject.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatNestedSources_WaitForInner()
    {
        var outerSubject = new Subject<Observable<int>>();
        using var list = outerSubject.Concat().ToLiveList();

        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();

        outerSubject.OnNext(subject1);
        outerSubject.OnNext(subject2);
        outerSubject.OnNext(subject3);

        subject1.OnNext(10);
        subject2.OnNext(9999);

        list.AssertEqual([10]);

        subject1.OnCompleted();

        subject2.OnNext(11111);

        list.AssertEqual([10, 11111]);

        subject2.OnCompleted();

        subject3.OnNext(9999999);
        outerSubject.OnCompleted();

        list.AssertIsNotCompleted();
        list.AssertEqual([10, 11111, 9999999]);

        subject3.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatNestedSources_Empty()
    {
        var outerSubject = new Subject<Observable<int>>();

        using var list = outerSubject.Concat().ToLiveList();
        list.AssertIsNotCompleted();
        outerSubject.OnCompleted();

        list.AssertIsCompleted();
        list.AssertEqual([]);
    }

    // Prepend factory
    [Fact]
    public void PrependFactory()
    {
        {
            using var list = Observable.Range(1, 3).Prepend(() => 10).ToLiveList();
            list.AssertEqual([10, 1, 2, 3]);
        }
        // with state
        {
            var o = new { V = 20 };
            using var list = Observable.Range(1, 3).Prepend(o, static x => x.V).ToLiveList();
            list.AssertEqual([20, 1, 2, 3]);
        }
    }

    [Fact]
    public void PrependEnumerable()
    {
        // Array
        {
            using var list = Observable.Range(1, 3).Prepend([10, 11, 12]).ToLiveList();
            list.AssertEqual([10, 11, 12, 1, 2, 3]);
        }
        // Pure Enumerable
        {
            using var list = Observable.Range(1, 3).Prepend(Iterate()).ToLiveList();
            list.AssertEqual([100, 200, 300, 1, 2, 3]);
        }
    }

    [Fact]
    public void AppendFactory()
    {
        {
            using var list = Observable.Range(1, 3).Append(() => 10).ToLiveList();
            list.AssertEqual([1, 2, 3, 10]);
        }
        // with state
        {
            var o = new { V = 20 };
            using var list = Observable.Range(1, 3).Append(o, static x => x.V).ToLiveList();
            list.AssertEqual([1, 2, 3, 20]);
        }
    }

    [Fact]
    public void AppendEnumerable()
    {
        // Array
        {
            using var list = Observable.Range(1, 3).Append([10, 11, 12]).ToLiveList();
            list.AssertEqual([1, 2, 3, 10, 11, 12]);
        }
        // Pure Enumerable
        {
            using var list = Observable.Range(1, 3).Append(Iterate()).ToLiveList();
            list.AssertEqual([1, 2, 3, 100, 200, 300]);
        }
    }

    static IEnumerable<int> Iterate()
    {
        yield return 100;
        yield return 200;
        yield return 300;
    }

    [Fact]
    public void ConcatTail()
    {
        var fakeTime = new FakeTimeProvider();

        using var list = Observable.Concat(
                Observable.Return(1), // immediate
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 2), // delay
                Observable.Return(3), // immediate
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 4) // delay
            )
            .ToLiveList();

        list.AssertEqual([1]);

        fakeTime.Advance(1);

        list.AssertEqual([1, 2, 3]);

        fakeTime.Advance(1);

        list.AssertEqual([1, 2, 3, 4]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatAllImmediateTail()
    {
        using var list = Observable.Concat(
                Observable.Return(1), // immediate
                Observable.Return(2),
                Observable.Return(3), // immediate
                Observable.Return(4)
            )
            .ToLiveList();

        list.AssertEqual([1, 2, 3, 4]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void ConcatAllDelay()
    {
        var fakeTime = new FakeTimeProvider();

        using var list = Observable.Concat(
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 1), // delay
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 2), // delay
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 3), // delay
                Observable.Timer(TimeSpan.FromSeconds(1), fakeTime).Select(_ => 4) // delay
            )
            .ToLiveList();

        list.AssertEqual([]);

        fakeTime.Advance(1);
        list.AssertEqual([1]);

        fakeTime.Advance(1);
        list.AssertEqual([1, 2]);

        fakeTime.Advance(1);
        list.AssertEqual([1, 2, 3]);

        fakeTime.Advance(1);
        list.AssertEqual([1, 2, 3, 4]);

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ContainsTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ContainsTest
{
    [Fact]
    public async Task Positive()
    {
        var range = Observable.Range(1, 10);
        var task = range.ContainsAsync(5);
        (await task).ShouldBeTrue();
    }

    [Fact]
    public async Task Negative()
    {
        var range = Observable.Range(1, 10);
        var task = range.ContainsAsync(0);
        (await task).ShouldBeFalse();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/CountTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class CountTest
{
    [Fact]
    public async Task Empty()
    {
        (await Observable.Empty<int>().CountAsync()).ShouldBe(0);
        (await Observable.Empty<int>().CountAsync(_ => true)).ShouldBe(0);
        (await Observable.Empty<long>().LongCountAsync()).ShouldBe(0);
        (await Observable.Empty<long>().LongCountAsync(_ => true)).ShouldBe(0);
    }

    [Fact]
    public async Task MultipleValues()
    {
        var source = new [] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        (await source.CountAsync()).ShouldBe(8);
        (await source.Select(x => (long)x).CountAsync()).ShouldBe(8);

        (await source.CountAsync(x => x % 2 == 0)).ShouldBe(4);
        (await source.Select(x => (long)x).CountAsync(x => x % 2== 0)).ShouldBe(4);
    }

    [Fact]
    public async Task Filter()
    {
        var source = new [] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        (await source.CountAsync(x => x % 2 == 0)).ShouldBe(4);
        (await source.Select(x => (long)x).CountAsync(x => x % 2== 0)).ShouldBe(4);
    }

    [Fact]
    public async Task Error()
    {
        var error = Observable.Range(0, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () => await error.CountAsync());
        await Assert.ThrowsAsync<Exception>(async () => await error.LongCountAsync());
        await Assert.ThrowsAsync<Exception>(async () => await error.OnErrorResumeAsFailure().CountAsync());
        await Assert.ThrowsAsync<Exception>(async () => await error.OnErrorResumeAsFailure().LongCountAsync());
    }

    [Fact]
    public async Task PredicateError()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await source.CountAsync(_ => throw new Exception("hoge"));
        });
        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await source.LongCountAsync(_ => throw new Exception("hoge"));
        });
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DebounceThrottleFirstThrottleLastTest.cs
================================================
﻿using System.Threading;

namespace R3.Tests.OperatorTests;

public class DebounceThrottleFirstThrottleLastTest
{
    // Debounce
    [Fact]
    public void Debounce()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Debounce(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));

        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        list.AssertEqual([10000]);

        publisher.OnNext(2);

        timeProvider.Advance(TimeSpan.FromSeconds(2));
        list.AssertEqual([10000]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));

        list.AssertEqual([10000, 2]);

        publisher.OnNext(3);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([10000, 2]);

        publisher.OnCompleted();

        list.AssertEqual([10000, 2, 3]);
    }

    // ThrottleFirst
    [Fact]
    public void ThrottleFirst()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleFirst(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        publisher.OnNext(2);
        list.AssertEqual([1, 2]);
        publisher.OnNext(20);
        publisher.OnNext(200);

        timeProvider.Advance(TimeSpan.FromSeconds(3));
        list.AssertEqual([1, 2]);
        publisher.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    // Sample
    [Fact]
    public void Sample()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleLast(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([10000]);
        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        timeProvider.Advance(TimeSpan.FromSeconds(3));
        list.AssertEqual([10000, 200]);
        publisher.OnNext(3);

        publisher.OnCompleted();

        list.AssertEqual([10000, 200]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void DebounceFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.DebounceFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        frameProvider.Advance(1);

        list.AssertEqual([]);

        frameProvider.Advance(2);

        list.AssertEqual([10000]);

        publisher.OnNext(2);

        frameProvider.Advance(2);
        list.AssertEqual([10000]);

        frameProvider.Advance(1);

        list.AssertEqual([10000, 2]);

        publisher.OnNext(3);

        frameProvider.Advance(1);
        list.AssertEqual([10000, 2]);

        publisher.OnCompleted();

        list.AssertEqual([10000, 2, 3]);
    }

    [Fact]
    public void ThrottleFirstFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleFirstFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1]);

        frameProvider.Advance(1);
        publisher.OnNext(2);
        list.AssertEqual([1, 2]);
        publisher.OnNext(20);
        publisher.OnNext(200);

        frameProvider.Advance(3);
        publisher.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void SampleFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleLastFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        frameProvider.Advance(1);
        list.AssertEqual([10000]);
        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        frameProvider.Advance(3);
        list.AssertEqual([10000, 200]);
        publisher.OnNext(3);

        publisher.OnCompleted();

        list.AssertEqual([10000, 200]);
        list.AssertIsCompleted();
    }

    // + Observable/Async sampler
    [Fact]
    public void ThrottleFirstAsyncSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var fakeTime = new FakeTimeProvider();
        var list = publisher.ThrottleFirst(async (x, ct) =>
        {
            await Task.Delay(TimeSpan.FromSeconds(x),fakeTime, ct);
        }).ToLiveList();

        publisher.OnNext(1); // gate close
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([1]);

        fakeTime.Advance(1); // gate open

        publisher.OnNext(5);
        publisher.OnNext(6);
        publisher.OnNext(7);

        list.AssertEqual([1, 5]);

        fakeTime.Advance(4);
        publisher.OnNext(8);

        list.AssertEqual([1, 5]);

        fakeTime.Advance(1);
        list.AssertEqual([1, 5]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ThrottleLastAsyncSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var fakeTime = new FakeTimeProvider();
        var list = publisher.ThrottleLast(async (x, ct) =>
        {
            await Task.Delay(TimeSpan.FromSeconds(x), fakeTime, ct);
        }).ToLiveList();

        publisher.OnNext(1); // gate close
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([]);

        fakeTime.Advance(1); // gate open
        list.AssertEqual([3]);

        publisher.OnNext(5);
        publisher.OnNext(6);
        publisher.OnNext(7);

        list.AssertEqual([3]);

        fakeTime.Advance(4);
        publisher.OnNext(8);

        list.AssertEqual([3]);

        fakeTime.Advance(1);
        list.AssertEqual([3, 8]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ThrottleFirstObservableSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var sampler = new Subject<Unit>();
        var list = publisher.ThrottleFirst(sampler).ToLiveList();

        publisher.OnNext(1); // gate close
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([1]);

        sampler.OnNext(Unit.Default);

        publisher.OnNext(5);
        list.AssertEqual([1, 5]);
        publisher.OnNext(6);
        publisher.OnNext(7);
        list.AssertEqual([1, 5]);

        sampler.OnNext(Unit.Default);

        publisher.OnNext(8);
        list.AssertEqual([1, 5, 8]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([1, 5, 8]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void ThrottleLastObservableSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var sampler = new Subject<Unit>();
        var list = publisher.ThrottleLast(sampler).ToLiveList();

        publisher.OnNext(1); // gate close
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([3]);

        publisher.OnNext(5);
        list.AssertEqual([3]);
        publisher.OnNext(6);
        publisher.OnNext(7);
        list.AssertEqual([3]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([3, 7]);

        publisher.OnNext(8);
        list.AssertEqual([3, 7]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([3, 7, 8]);
        sampler.OnNext(Unit.Default);
        sampler.OnNext(Unit.Default);
        list.AssertEqual([3, 7, 8]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void DebounceSelector()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var fakeTime = new FakeTimeProvider();
        var list = publisher.Debounce(async (x, ct) =>
        {
            try
            {
                // await fakeTime.Delay(TimeSpan.FromSeconds(x), ct);
                await Task.Delay(TimeSpan.FromSeconds(x), fakeTime, ct);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
        }).ToLiveList();



        publisher.OnNext(1);   // cancel
        publisher.OnNext(10);  // cancel
        publisher.OnNext(100); // wait 100...
        list.AssertEqual([]);

        fakeTime.Advance(100);
        list.AssertEqual([100]);

        publisher.OnNext(1000);  // cancel
        publisher.OnNext(10000); // wait 10000
        list.AssertEqual([100]);

        fakeTime.Advance(10000);

        list.AssertEqual([100, 10000]);

        publisher.OnNext(5);
        fakeTime.Advance(5);

        publisher.OnNext(6);
        fakeTime.Advance(6);

        publisher.OnCompleted();

        list.AssertEqual([100, 10000, 5, 6]);

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DefaultIfEmptyTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DefaultIfEmptyTest
{
    [Fact]
    public void DefaultIfEmpty()
    {
        using var list = Observable.Empty<int>().DefaultIfEmpty().ToLiveList();

        list.AssertEqual([0]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DelaySubscriptionTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DelaySubscriptionTest
{
    [Fact]
    public void DelaySubscription()
    {
        var provider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var subscribed = false;
        var list = publisher
            .Do(onSubscribe: () => subscribed = true)
            .DelaySubscription(TimeSpan.FromSeconds(3), provider)
            .ToLiveList();

        subscribed.ShouldBeFalse();
        publisher.OnNext(1);
        list.AssertEqual([]);

        provider.Advance(TimeSpan.FromSeconds(2));

        subscribed.ShouldBeFalse();
        publisher.OnNext(2);
        list.AssertEqual([]);

        provider.Advance(TimeSpan.FromSeconds(1));

        subscribed.ShouldBeTrue();
        publisher.OnNext(3);
        list.AssertEqual([3]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void DelaySubscriptionFrame()
    {
        var provider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var subscribed = false;
        var list = publisher
            .Do(onSubscribe: () => subscribed = true)
            .DelaySubscriptionFrame(3, provider)
            .ToLiveList();

        subscribed.ShouldBeFalse();
        publisher.OnNext(1);
        list.AssertEqual([]);

        provider.Advance(2);

        subscribed.ShouldBeFalse();
        publisher.OnNext(2);
        list.AssertEqual([]);

        provider.Advance(1);

        subscribed.ShouldBeTrue();
        publisher.OnNext(3);
        list.AssertEqual([3]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DelayTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DelayTest
{
    [Fact]
    public void Delay()
    {
        var provider = new FakeTimeProvider();
        var subject = new Subject<int>();

        var e = new List<Exception>();

        var list = subject.Delay(TimeSpan.FromSeconds(3), provider).Do(onErrorResume: ex => e.Add(ex)).ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        subject.OnErrorResume(new Exception("a"));
        subject.OnNext(4);
        subject.OnNext(5);

        list.AssertEqual([]);
        provider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([]);
        provider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([]);
        e.ShouldBeEmpty();
        provider.Advance(TimeSpan.FromSeconds(1));

        list.AssertEqual([1, 2, 3, 4, 5]);
        e[0].Message.ShouldBe("a");

        list.Clear();

        subject.OnNext(10);
        provider.Advance(TimeSpan.FromSeconds(1));
        subject.OnNext(20);
        provider.Advance(TimeSpan.FromSeconds(1));
        subject.OnNext(30);
        provider.Advance(TimeSpan.FromSeconds(1));

        list.AssertEqual([10]);
        provider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([10, 20]);
        provider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([10, 20, 30]);

        subject.OnCompleted();
        list.AssertIsNotCompleted();
        provider.Advance(TimeSpan.FromSeconds(3));
        list.AssertIsCompleted();
    }

    [Fact]
    public void DelayFrame()
    {
        var provider = new FakeFrameProvider();
        var subject = new Subject<int>();

        var e = new List<Exception>();

        var list = subject.DelayFrame((3), provider).Do(onErrorResume: ex => e.Add(ex)).ToLiveList();
        provider.Advance(10);

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        subject.OnErrorResume(new Exception("a"));
        subject.OnNext(4);
        subject.OnNext(5);

        list.AssertEqual([]);
        provider.Advance((1));
        list.AssertEqual([]);
        provider.Advance((1));
        list.AssertEqual([]);
        e.ShouldBeEmpty();
        provider.Advance((1));

        list.AssertEqual([1, 2, 3, 4, 5]);
        e[0].Message.ShouldBe("a");

        list.Clear();

        subject.OnNext(10);
        provider.Advance((1));
        subject.OnNext(20);
        provider.Advance((1));
        subject.OnNext(30);
        provider.Advance((1));

        list.AssertEqual([10]);
        provider.Advance((1));
        list.AssertEqual([10, 20]);
        provider.Advance((1));
        list.AssertEqual([10, 20, 30]);

        subject.OnCompleted();
        list.AssertIsNotCompleted();
        provider.Advance((3));
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DistinctByTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DistinctByTest
{
    [Fact]
    public void DistinctBy()
    {
        var source = new Subject<(int, int)>();

        using var list = source.DistinctBy(static x => x.Item1).ToLiveList();

        source.OnNext((1, 10));
        source.OnNext((2, 20));
        source.OnNext((3, 30));
        source.OnNext((1, 100));
        source.OnNext((2, 200));
        source.OnNext((3, 300));
        source.OnNext((4, 400));

        list.AssertEqual(
            [
                (1, 10),
                (2, 20),
                (3, 30),
                (4, 400)
            ]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DistinctTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DistinctTest
{
    [Fact]
    public void Distinct()
    {
        var source = new Subject<int>();

        using var list = source.Distinct().ToLiveList();

        source.OnNext(1);
        source.OnNext(2);
        source.OnNext(3);
        source.OnNext(1);
        source.OnNext(2);
        source.OnNext(3);
        source.OnNext(4);

        list.AssertEqual([1, 2, 3, 4]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DistinctUntilChangedByTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DistinctUntilChangedByTest
{
    [Fact]
    public void DistinctUntilChangedBy()
    {
        var source = new Subject<(int, int)>();

        using var list = source.DistinctUntilChangedBy(static x => x.Item1).ToLiveList();

        source.OnNext((1, 10));
        source.OnNext((2, 20));
        source.OnNext((3, 30));
        source.OnNext((3, 300));
        source.OnNext((2, 200));
        source.OnNext((1, 100));

        list.AssertEqual(
            [
                (1, 10),
                (2, 20),
                (3, 30),
                (2, 200),
                (1, 100)
            ]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DistinctUntilChangedTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DistinctUntilChangedTest
{
    [Fact]
    public void DistinctUntilChanged()
    {
        var source = new Subject<int>();

        using var list = source.DistinctUntilChanged().ToLiveList();

        source.OnNext(1);
        source.OnNext(2);
        source.OnNext(3);
        source.OnNext(3);
        source.OnNext(2);
        source.OnNext(1);

        list.AssertEqual([1, 2, 3, 2, 1]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/DoTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class DoTest
{
    [Fact]
    public void Test()
    {
        var subject = new Subject<int>();

        List<int> onNext = new();
        List<Exception> onErrorResume = new();
        List<Result> onCompleted = new();
        bool disposeCalled = false;
        bool subscribeCalled = false;
        var source = subject.Do(onNext.Add, onErrorResume.Add, onCompleted.Add, () => disposeCalled = true, () => subscribeCalled = true);

        subscribeCalled.ShouldBeFalse();

        var list = source.ToLiveList();

        subscribeCalled.ShouldBeTrue();

        subject.OnNext(10);
        subject.OnNext(20);
        subject.OnNext(30);
        subject.OnErrorResume(new Exception("a"));
        subject.OnErrorResume(new Exception("b"));
        subject.OnErrorResume(new Exception("c"));

        onNext.ShouldBe([10, 20, 30]);
        onErrorResume.Select(x => x.Message).ShouldBe(["a", "b", "c"]);


        disposeCalled.ShouldBeFalse();

        subject.OnCompleted();
        onCompleted.Count.ShouldNotBe(0);

        disposeCalled.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ElementAtTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ElementAtTest
{
    [Fact]
    public async Task ElementAt()
    {
        var xs = Observable.Range(0, 10);
        (await xs.ElementAtAsync(0)).ShouldBe(0);
        (await xs.ElementAtAsync(5)).ShouldBe(5);
        (await xs.ElementAtAsync(9)).ShouldBe(9);

        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtAsync(-1));
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtAsync(10));

        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtAsync(0));

        // empty case
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await Observable.Empty<int>().ElementAtAsync(0));
    }

    [Fact]
    public async Task ElementAtOrDefault()
    {
        var xs = Observable.Range(0, 10);
        (await xs.ElementAtOrDefaultAsync(0)).ShouldBe(0);
        (await xs.ElementAtOrDefaultAsync(5)).ShouldBe(5);
        (await xs.ElementAtOrDefaultAsync(9)).ShouldBe(9);

        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtOrDefaultAsync(-1));
        (await xs.ElementAtOrDefaultAsync(10, 9999)).ShouldBe(9999);

        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtOrDefaultAsync(0));

        // empty case
        (await Observable.Empty<int>().ElementAtOrDefaultAsync(0, 99999)).ShouldBe(99999);
    }

    [Fact]
    public async Task ElementAtIndex()
    {
        var xs = Observable.Range(0, 10);
        (await xs.ElementAtAsync(new Index(0))).ShouldBe(0);
        (await xs.ElementAtAsync(new Index(5))).ShouldBe(5);
        (await xs.ElementAtAsync(new Index(9))).ShouldBe(9);

        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtAsync(new Index(10)));

        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtAsync(new Index(0)));

        // empty case
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await Observable.Empty<int>().ElementAtAsync(new Index(0)));

        // more
        (await xs.ElementAtAsync(^1)).ShouldBe(9);
        (await xs.ElementAtAsync(^4)).ShouldBe(6);
        (await xs.ElementAtAsync(^10)).ShouldBe(0);

        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtAsync(^0));
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await xs.ElementAtAsync(^11));
        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtAsync(^1));
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(async () => await Observable.Empty<int>().ElementAtAsync(^1));
    }

    [Fact]
    public async Task ElementAtOrDefaultIndex()
    {
        var xs = Observable.Range(0, 10);
        (await xs.ElementAtOrDefaultAsync(new Index(0))).ShouldBe(0);
        (await xs.ElementAtOrDefaultAsync(new Index(5))).ShouldBe(5);
        (await xs.ElementAtOrDefaultAsync(new Index(9))).ShouldBe(9);

        (await xs.ElementAtOrDefaultAsync(new Index(10))).ShouldBe(0);

        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtOrDefaultAsync(new Index(0)));

        // empty case
        (await Observable.Empty<int>().ElementAtOrDefaultAsync(new Index(0))).ShouldBe(0);

        // more
        (await xs.ElementAtOrDefaultAsync(^1)).ShouldBe(9);
        (await xs.ElementAtOrDefaultAsync(^4)).ShouldBe(6);
        (await xs.ElementAtOrDefaultAsync(^10)).ShouldBe(0);

        (await xs.ElementAtOrDefaultAsync(^0, 9999)).ShouldBe(9999);
        (await xs.ElementAtOrDefaultAsync(^11, 9999)).ShouldBe(9999);
        await Assert.ThrowsAsync<Exception>(async () => await Observable.Throw<int>(new Exception()).ElementAtOrDefaultAsync(^1));
        (await Observable.Empty<int>().ElementAtOrDefaultAsync(^1, 9999)).ShouldBe(9999);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/FirstLastSingleTest.cs
================================================
﻿using System.Threading.Tasks;

namespace R3.Tests.OperatorTests;

public class FirstLastSingleTest
{
    // Empty, 1, ...

    // Event First
    // Completable First/FirstOrDefault/Last/LastOrDefault

    // CompletablePublisher First Test
    [Fact]
    public async Task First2()
    {
        var publisher = new Subject<int>();
        var task = publisher.FirstAsync();
        publisher.OnNext(10);
        (await task).ShouldBe(10);

        var task2 = publisher.FirstAsync();
        publisher.OnNext(15);
        publisher.OnNext(25);

        (await task2).ShouldBe(15);

        var task3 = publisher.FirstAsync();

        publisher.OnCompleted(default);
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task3);

        publisher = new Subject<int>();
        var task4 = publisher.FirstAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task FirstOrDefault()
    {
        var publisher = new Subject<int>();
        var task = publisher.FirstOrDefaultAsync();
        publisher.OnNext(10);
        (await task).ShouldBe(10);

        var task2 = publisher.FirstOrDefaultAsync();
        publisher.OnNext(15);
        publisher.OnNext(25);

        (await task2).ShouldBe(15);

        var task3 = publisher.FirstOrDefaultAsync(9999);

        publisher.OnCompleted(default);
        (await task3).ShouldBe(9999);

        publisher = new Subject<int>();
        var task4 = publisher.FirstOrDefaultAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task LastAsync()
    {
        var publisher = new Subject<int>();
        var task = publisher.LastAsync();
        publisher.OnNext(10);
        publisher.OnCompleted(default);
        (await task).ShouldBe(10);

        publisher = new Subject<int>();
        var task2 = publisher.LastAsync();
        publisher.OnNext(15);
        publisher.OnNext(25);
        publisher.OnCompleted(default);

        (await task2).ShouldBe(25);

        publisher = new Subject<int>();
        var task3 = publisher.LastAsync();

        publisher.OnCompleted(default);
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task3);

        publisher = new Subject<int>();
        var task4 = publisher.LastAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        publisher.OnNext(11);
        publisher.OnCompleted();
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task LastOrDefaultAsync()
    {
        var publisher = new Subject<int>();
        var task = publisher.LastOrDefaultAsync();
        publisher.OnNext(10);
        publisher.OnCompleted(default);
        (await task).ShouldBe(10);

        publisher = new Subject<int>();
        var task2 = publisher.LastOrDefaultAsync();
        publisher.OnNext(15);
        publisher.OnNext(25);
        publisher.OnCompleted(default);

        (await task2).ShouldBe(25);

        publisher = new Subject<int>();
        var task3 = publisher.LastOrDefaultAsync(9999);

        publisher.OnCompleted(default);
        (await task3).ShouldBe(9999);

        publisher = new Subject<int>();
        var task4 = publisher.LastOrDefaultAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        publisher.OnNext(11);
        publisher.OnCompleted();
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task Single()
    {
        var publisher = new Subject<int>();
        var task = publisher.SingleAsync();
        publisher.OnNext(10);
        publisher.OnCompleted();
        (await task).ShouldBe(10);

        publisher = new Subject<int>();
        var task2 = publisher.SingleAsync();
        publisher.OnNext(15);
        publisher.OnNext(25);
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task2);

        publisher = new Subject<int>();
        var task3 = publisher.SingleAsync();

        publisher.OnCompleted(default);
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task3);

        publisher = new Subject<int>();
        var task4 = publisher.SingleAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        publisher.OnCompleted();
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task SingleOrDefault()
    {
        var publisher = new Subject<int>();
        var task = publisher.SingleOrDefaultAsync(9999);
        publisher.OnNext(10);
        publisher.OnCompleted();
        (await task).ShouldBe(10);

        publisher = new Subject<int>();
        var task2 = publisher.SingleOrDefaultAsync(9999);
        publisher.OnNext(15);
        publisher.OnNext(25);
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task2);

        publisher = new Subject<int>();
        var task3 = publisher.SingleOrDefaultAsync(9999);

        publisher.OnCompleted(default);
        (await task3).ShouldBe(9999);

        publisher = new Subject<int>();
        var task4 = publisher.SingleOrDefaultAsync(x => x % 3 == 0);
        publisher.OnNext(5);
        task4.Status.ShouldNotBe(TaskStatus.RanToCompletion);

        publisher.OnNext(99);
        publisher.OnCompleted();
        (await task4).ShouldBe(99);
    }

    [Fact]
    public async Task ErrorStream()
    {
        var publisher = new Subject<int>();
        var task = publisher.LastAsync();

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);
        publisher.OnCompleted(Result.Failure(new Exception("foo")));

        await Assert.ThrowsAsync<Exception>(async () => await task);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ForEachAsyncTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ForEachAsyncTest
{
    [Fact]
    public async Task ForEach()
    {
        var range = Observable.Range(1, 10);

        {
            var l = new List<int>();
            await range.ForEachAsync(l.Add);
            l.ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        }
        {
            var l = new List<(int, int)>();
            await range.ForEachAsync((x, i) => l.Add((x, i)));
            l.Select(x => x.Item1).ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
            l.Select(x => x.Item2).ShouldBe([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
        }
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/IgnoreElementsTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class IgnoreElementsTest
{
    [Fact]
    public void Test()
    {
        var subject = new Subject<int>();
        using var list = subject.IgnoreElements().ToLiveList();

        subject.OnNext(10);
        subject.OnNext(20);
        subject.OnNext(30);

        list.AssertEqual([]);
        list.AssertIsNotCompleted();

        subject.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/IndexTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class IndexTest
{
    [Fact]
    public void Unit()
    {
        var subject = new Subject<Unit>();
        using var list = subject.Index().ToLiveList();

        subject.OnNext(default);
        subject.OnNext(default);
        subject.OnNext(default);
        subject.OnNext(default);
        subject.OnNext(default);

        list.AssertEqual([0, 1, 2, 3, 4]);

        subject.Dispose();

        list.AssertIsCompleted();
    }

    [Fact]
    public void Item()
    {
        var subject = new Subject<string>();
        using var list = subject.Index().ToLiveList();

        subject.OnNext("a");
        subject.OnNext("b");
        subject.OnNext("c");
        subject.OnNext("d");
        subject.OnNext("e");

        list.AssertEqual([(0, "a"), (1, "b"), (2, "c"), (3, "d"), (4, "e")]);

        subject.Dispose();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/IsEmptyTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class IsEmptyTest
{
    [Fact]
    public async Task Positive()
    {
        var range = Observable.Empty<int>();
        var task = range.IsEmptyAsync();
        (await task).ShouldBeTrue();
    }

    [Fact]
    public async Task Negative()
    {
        var range = Observable.Return(0);
        var task = range.IsEmptyAsync();
        (await task).ShouldBeFalse();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MaterializeTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MaterializeTest
{
    [Fact]
    public void Materialize()
    {
        var publisher = new Subject<int>();
        var list = publisher.Materialize().ToLiveList();

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);
        publisher.OnErrorResume(new Exception("foo"));
        publisher.OnCompleted(new Exception("comp"));

        list[0].Value.ShouldBe(10);
        list[1].Value.ShouldBe(20);
        list[2].Value.ShouldBe(30);
        list[3].Error!.Message.ShouldBe("foo");
        list[4].Result!.Exception!.Message.ShouldBe("comp");

        list.AssertIsCompleted();
    }

    [Fact]
    public void Dematerialize()
    {
        var publisher = new Subject<int>();
        var list = publisher.Materialize().Dematerialize().ToLiveList();

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);
        publisher.OnErrorResume(new Exception("foo"));
        publisher.OnCompleted(new Exception("comp"));

        list.AssertEqual([10, 20, 30]);
        list.Result.IsFailure.ShouldBeTrue();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MaxByTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MaxByTest
{
    [Fact]
    public async Task First()
    {
        var items = new[] { (3, 1), (2, 2), (1, 3) }.ToObservable();

        var task = items.MaxByAsync(static x => x.Item1);
        (await task).ShouldBe((3, 1));
    }

    [Fact]
    public async Task Last()
    {
        var items = new[] { (1, 3), (2, 2), (3, 1) }.ToObservable();

        var task = items.MaxByAsync(static x => x.Item1);
        (await task).ShouldBe((3, 1));
    }

    [Fact]
    public async Task Midway()
    {
        var items = new[] { (2, 2), (3, 1), (1, 3) }.ToObservable();

        var task = items.MaxByAsync(static x => x.Item1);
        (await task).ShouldBe((3, 1));
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MaxTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MaxTest
{
    [Fact]
    public async Task One()
    {
        (await Observable.Return(999).MaxAsync()).ShouldBe(999);
    }

    [Fact]
    public async Task MultipleValue()
    {
        var max = await new[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable().MaxAsync();
        max.ShouldBe(10);
    }

    [Fact]
    public async Task First()
    {
        var max = await new[] { 10, 1, 3, 4, 6, 7, 5 }.ToObservable().MaxAsync();
        max.ShouldBe(10);
    }

    [Fact]
    public async Task Last()
    {
        var max = await new[] { 6, 2, 7, 1, 3, 4, 10 }.ToObservable().MaxAsync();
        max.ShouldBe(10);
    }

    [Fact]
    public async Task Midway()
    {
        var max = await new[] { 6, 2, 7, 10, 3, 4, 1 }.ToObservable().MaxAsync();
        max.ShouldBe(10);
    }

    [Fact]
    public async Task Empty()
    {
        var task = Observable.Empty<int>().MaxAsync();
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task);
    }

    [Fact]
    public async Task Error()
    {
        var error = Observable.Range(1, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.MaxAsync();
        });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.OnErrorResumeAsFailure().MaxAsync();
        });
    }

    [Fact]
    public async Task WithComparer()
    {
        var result = await new[] { new TestData(100), new TestData(200) }.ToObservable().MaxAsync(new TestComparer());
        result.Value.ShouldBe(200);
    }

    [Fact]
    public async Task WithSelector()
    {
        var source = new[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        (await source.MaxAsync(x => x == 7 ? 777 : x)).ShouldBe(777);
        // (await source.MaxAsync(x => new TestData(x), new TestComparer())).Value.ShouldBe(1);
    }

    [Fact]
    public async Task WithSelectorError()
    {
        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await Observable.Range(1, 10)
                .Select(x =>
                {
                    if (x == 3) throw new Exception("foo");
                    return x;
                })
                .MaxAsync(x => x);
        });

        var error = Observable.Range(1, 10)
            .Select(x =>
            {
                if (x == 3) throw new Exception("foo");
                return x;
            });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.MaxAsync(x => x);
        });
        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.OnErrorResumeAsFailure().MaxAsync(x => x);
        });
    }

    record struct TestData(int Value);

    class TestComparer : IComparer<TestData>
    {
        public int Compare(TestData x, TestData y) => x.Value.CompareTo(y.Value);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MergeTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MergeTest
{
    [Fact]
    public void Std()
    {
        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();

        using var list = Observable.Merge(subject1, subject2, subject3).ToLiveList();

        subject1.OnNext(10);
        subject2.OnNext(20);
        subject2.OnNext(21);
        subject3.OnNext(30);
        subject1.OnNext(11);
        subject3.OnNext(31);

        subject2.OnCompleted();

        subject1.OnNext(12);
        subject1.OnCompleted();

        subject3.OnNext(32);

        list.AssertIsNotCompleted();

        subject3.OnCompleted();

        list.AssertEqual([10, 20, 21, 30, 11, 31, 12, 32]);

        list.AssertIsCompleted();
    }

    [Fact]
    public void CompleteFirst()
    {
        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();

        subject1.OnCompleted();
        subject2.OnCompleted();
        subject3.OnCompleted();
        using var list = Observable.Merge(subject1, subject2, subject3).ToLiveList();

        list.AssertIsCompleted();
    }

    [Fact]
    public void Empty()
    {
        using var list = Observable.Empty<int>().ToLiveList();

        list.AssertIsCompleted();
    }

    [Fact]
    public void NestedSources()
    {
        var outerSubject = new Subject<Observable<int>>();

        using var list = Observable.Merge(outerSubject).ToLiveList();

        var innerSubject1 = new Subject<int>();
        var innerSubject2 = new Subject<int>();
        var innerSubject3 = new Subject<int>();

        outerSubject.OnNext(innerSubject1);
        innerSubject1.OnNext(10);
        innerSubject1.OnNext(11);

        outerSubject.OnNext(innerSubject2);
        innerSubject2.OnNext(20);
        innerSubject1.OnNext(12);
        innerSubject2.OnNext(21);

        outerSubject.OnNext(innerSubject3);
        innerSubject3.OnNext(30);
        innerSubject2.OnNext(22);
        innerSubject1.OnNext(12);

        innerSubject1.OnCompleted();
        innerSubject2.OnCompleted();
        innerSubject3.OnCompleted();

        list.AssertIsNotCompleted();

        outerSubject.OnCompleted();

        list.AssertIsCompleted();
        list.AssertEqual([10, 11, 20, 12, 21, 30, 22, 12]);
    }

    [Fact]
    public void NestedSources_WaitForInners()
    {
        var outerSubject = new Subject<Observable<int>>();

        using var list = Observable.Merge(outerSubject).ToLiveList();

        var innerSubject1 = new Subject<int>();
        var innerSubject2 = new Subject<int>();
        var innerSubject3 = new Subject<int>();

        outerSubject.OnNext(innerSubject1);
        innerSubject1.OnNext(10);
        innerSubject1.OnNext(11);

        outerSubject.OnNext(innerSubject2);
        innerSubject2.OnNext(20);
        innerSubject1.OnNext(12);
        innerSubject2.OnNext(21);

        outerSubject.OnNext(innerSubject3);
        innerSubject3.OnNext(30);
        innerSubject2.OnNext(22);
        innerSubject1.OnNext(12);

        innerSubject1.OnCompleted();
        innerSubject3.OnCompleted();
        outerSubject.OnCompleted();

        list.AssertIsNotCompleted();

        innerSubject2.OnCompleted();

        list.AssertIsCompleted();
        list.AssertEqual([10, 11, 20, 12, 21, 30, 22, 12]);
    }

    [Fact]
    public void NestedSources_Empty()
    {
        var outerSubject = new Subject<Observable<int>>();

        using var list = Observable.Merge(outerSubject).ToLiveList();
        list.AssertIsNotCompleted();
        outerSubject.OnCompleted();

        list.AssertIsCompleted();
        list.AssertEqual([]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MinByTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MinByTest
{
    [Fact]
    public async Task First()
    {
        var items = new[] { (1, 3), (2, 2), (3, 1) }.ToObservable();

        var task = items.MinByAsync(static x => x.Item1);
        (await task).ShouldBe((1, 3));
    }

    [Fact]
    public async Task Last()
    {
        var items = new[] { (3, 1), (2, 2), (1, 3) }.ToObservable();

        var task = items.MinByAsync(static x => x.Item1);
        (await task).ShouldBe((1, 3));
    }

    [Fact]
    public async Task Midway()
    {
        var items = new[] { (2, 2), (1, 3), (3, 1) }.ToObservable();

        var task = items.MinByAsync(static x => x.Item1);
        (await task).ShouldBe((1, 3));
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MinMaxTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MinMaxTest
{
    [Fact]
    public async Task Empty()
    {
        var o = Observable.Empty<int>();
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await o.MinMaxAsync());
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await o.MinMaxAsync(x => x));
    }

    [Fact]
    public async Task One()
    {
        (await Observable.Return(999).MinMaxAsync()).ShouldBe((999, 999));
        (await Observable.Return(999).MinMaxAsync(x => 777)).ShouldBe((777, 777));
    }

    [Fact]
    public async Task MultipleValues()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();
        (await source.MinMaxAsync()).ShouldBe((1, 10));
        (await source.MinMaxAsync(x => x * 10)).ShouldBe((10, 100));
    }

    [Fact]
    public async Task First()
    {
        var minMax = await new[] { 1, 5, 3, 4, 6, 7, 10 }.ToObservable().MinMaxAsync();
        minMax.ShouldBe((1, 10));
    }

    [Fact]
    public async Task Last()
    {
        var minMax = await new[] { 10, 2, 3, 4, 6, 7, 1 }.ToObservable().MinMaxAsync();
        minMax.ShouldBe((1, 10));
    }

    [Fact]
    public async Task Midway()
    {
        var minMax = await new[] { 2, 4, 10, 3, 1, 6, 7, 5 }.ToObservable().MinMaxAsync();
        minMax.ShouldBe((1, 10));
    }

    [Fact]
    public async Task Error()
    {
        var o = Observable.Range(1, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });
        await Assert.ThrowsAsync<Exception>(async () => await o.MinMaxAsync());
        await Assert.ThrowsAsync<Exception>(async () => await o.MinMaxAsync(x => x));
        await Assert.ThrowsAsync<Exception>(async () => await o.OnErrorResumeAsFailure().MinMaxAsync(x => x));
        await Assert.ThrowsAsync<Exception>(async () => await o.OnErrorResumeAsFailure().MinMaxAsync());
    }

    [Fact]
    public async Task SelectorError()
    {
        var o = Observable.Range(1, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });
        await Assert.ThrowsAsync<Exception>(async () => await o.MinMaxAsync<int, int>(x => throw new Exception("bra")));
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MinTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MinTest
{
    [Fact]
    public async Task Empty()
    {
        var task = Observable.Empty<int>().MinAsync();
        await Assert.ThrowsAsync<InvalidOperationException>(async () => await task);
    }

    [Fact]
    public async Task One()
    {
        (await Observable.Return(999).MinAsync()).ShouldBe(999);
    }

    [Fact]
    public async Task MultipleValue()
    {
        var min = await new[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable().MinAsync();
        min.ShouldBe(1);
    }

    [Fact]
    public async Task First()
    {
        var min = await new[] { 1, 10, 3, 4, 6, 7, 5 }.ToObservable().MinAsync();
        min.ShouldBe(1);
    }

    [Fact]
    public async Task Last()
    {
        var min = await new[] { 2, 10, 3, 4, 6, 7, 1 }.ToObservable().MinAsync();
        min.ShouldBe(1);
    }

    [Fact]
    public async Task Midway()
    {
        var min = await new[] { 2, 10, 3, 4, 1, 6, 7, 5 }.ToObservable().MinAsync();
        min.ShouldBe(1);
    }

    [Fact]
    public async Task Error()
    {
        var error = Observable.Range(1, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.MinAsync();
        });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.OnErrorResumeAsFailure().MinAsync();
        });
    }

    [Fact]
    public async Task WithComparer()
    {
        var result = await new[] { new TestData(100), new TestData(200) }.ToObservable().MinAsync(new TestComparer());
        result.Value.ShouldBe(100);
    }

    [Fact]
    public async Task WithSelector()
    {
        var source = new[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        (await source.MinAsync(x => x == 7 ? -1 : x)).ShouldBe(-1);
        // (await source.MinAsync(x => new TestData(x), new TestComparer())).Value.ShouldBe(10);
    }

    [Fact]
    public async Task WithSelectorError()
    {
        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await Observable.Range(1, 10)
                .Select(x =>
                {
                    if (x == 3) throw new Exception("foo");
                    return x;
                })
                .MinAsync(x => x);
        });

        var error = Observable.Range(1, 10)
            .Select(x =>
            {
                if (x == 3) throw new Exception("foo");
                return x;
            });

        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.MinAsync(x => x);
        });
        await Assert.ThrowsAsync<Exception>(async () =>
        {
            await error.OnErrorResumeAsFailure().MinAsync(x => x);
        });
    }

    record struct TestData(int Value);

    class TestComparer : IComparer<TestData>
    {
        public int Compare(TestData x, TestData y) => x.Value.CompareTo(y.Value);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/MulticastTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class MulticastTest
{
    [Fact]
    public void Publish()
    {
        var subject = new Subject<int>();

        var connectable = subject.Publish();

        var list1 = connectable.ToLiveList();
        var list2 = connectable.ToLiveList();

        subject.OnNext(100);

        var connection = connectable.Connect();

        subject.OnNext(110);
        subject.OnNext(120);
        subject.OnNext(130);

        list1.AssertEqual([110, 120, 130]);
        list2.AssertEqual([110, 120, 130]);

        connection.Dispose();

        subject.OnCompleted();

        list1.AssertIsNotCompleted();
        list2.AssertIsNotCompleted();

        var reconnection = connectable.Connect();

        list1.AssertIsCompleted();
        list2.AssertIsCompleted();

        reconnection.Dispose();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ObserveOnTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ObserveOnTest
{
    // null synccontext(TimeProvider.System)
    [Fact]
    public async Task ThreadPool()
    {
        var l = new List<int>();
        await Observable.Range(1, 10).ObserveOn((SynchronizationContext?)null).ForEachAsync(x =>
        {
            Thread.CurrentThread.IsThreadPoolThread.ShouldBeTrue();
            lock (l)
            {
                l.Add(x);
            }
        });

        l.Order().ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    [Fact]
    public void SyncContext()
    {
        var syncContext = new CustomSyncContext();
        var list = Observable.Range(1, 10).ObserveOn(syncContext).ToLiveList();

        syncContext.PostCount.ShouldBe(11); // OnNext + OnCompleted
        list.AssertEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void TimeProvider()
    {
        var fakeTime = new FakeTimeProvider();
        var publisher = new Subject<int>();

        using var list = publisher.ObserveOn(fakeTime).ToLiveList();


        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);

        list.AssertEqual([10, 20, 30]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void FrameProvider()
    {
        var fakeTime = new FakeFrameProvider();
        var publisher = new Subject<int>();

        using var list = publisher.ObserveOn(fakeTime).ToLiveList();

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);

        list.AssertEqual([]);

        fakeTime.Advance();
        list.AssertEqual([10, 20, 30]);

        publisher.OnCompleted();
        list.AssertIsNotCompleted();

        fakeTime.Advance();
        list.AssertIsCompleted();
    }

    [Fact]
    public void FrameProvider2()
    {

        var fakeTime = new FakeFrameProvider();
        var publisher = new Subject<int>();

        using var list = publisher.ObserveOn(fakeTime)
            .Do(x =>
            {
                if (x == 20)
                {
                    publisher.OnNext(99);
                }
            })
            .ToLiveList();

        publisher.OnNext(10);
        publisher.OnNext(20);
        publisher.OnNext(30);

        list.AssertEqual([]);

        fakeTime.Advance();
        list.AssertEqual([10, 20, 30]);

        fakeTime.Advance();
        list.AssertEqual([10, 20, 30, 99]);

        publisher.OnNext(40);
        fakeTime.Advance();
        list.AssertEqual([10, 20, 30, 99, 40]);

        publisher.OnCompleted();
        list.AssertIsNotCompleted();

        fakeTime.Advance();
        list.AssertIsCompleted();
    }
}


file class CustomSyncContext : SynchronizationContext
{
    public int PostCount;

    public override void Post(SendOrPostCallback d, object? state)
    {
        PostCount++;
        d(state);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/OfTypeTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class OfTypeTest
{
    [Fact]
    public void Test()
    {
        var subject = new Subject<object>();
        using var list = subject.OfType<object, int>().ToLiveList();

        subject.OnNext(10);
        subject.OnNext("hello");
        subject.OnNext(20);
        subject.OnNext(30);
        subject.OnNext("world");
        subject.OnNext(40);

        list.AssertEqual([10, 20, 30, 40]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/OnErrorResumeAsFailureTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class OnErrorResumeAsFailureTest
{

    [Fact]
    public void OnErrorResumeAsFailure()
    {
        var subject = new Subject<int>();
        var list = subject.OnErrorResumeAsFailure().ToLiveList();


        subject.OnNext(10);
        subject.OnErrorResume(new Exception("foo"));

        list.AssertEqual([10]);
        list.AssertIsCompleted();
        list.Result.Exception!.Message.ShouldBe("foo");

    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/PairwiseTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class PairwiseTest
{
    [Fact]
    public void Pairwise()
    {
        using var list = Observable.Range(1, 3).Pairwise().ToLiveList();

        list.AssertEqual(
            [
                (1, 2),
                (2, 3)
            ]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/RaceTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class RaceTest
{
    [Fact]
    public void Race3()
    {
        var subject1 = new Subject<int>();
        var subject2 = new Subject<int>();
        var subject3 = new Subject<int>();

        var d1Called = false;
        var d2Called = false;
        var d3Called = false;

        var list = Observable.Race(
            subject1.Do(onDispose: () => d1Called = true),
            subject2.Do(onDispose: () => d2Called = true),
            subject3.Do(onDispose: () => d3Called = true)
            ).ToLiveList();

        d1Called.ShouldBeFalse();

        subject2.OnNext(2);
        list.AssertEqual([2]);

        d1Called.ShouldBeTrue();
        d3Called.ShouldBeTrue();

        subject2.OnNext(20);
        list.AssertEqual([2, 20]);

        subject2.OnCompleted();

        d2Called.ShouldBeTrue();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/RefCountTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class RefCountTest
{
    [Fact]
    public void RefCount()
    {
        var subject = new Subject<int>();
        var refCounted = subject.Publish().RefCount(); // same as Share
        var list1 = refCounted.ToLiveList();
        var list2 = refCounted.ToLiveList();

        subject.OnNext(10);
        list1.AssertEqual([10]);
        list2.AssertEqual([10]);

        subject.OnNext(20);
        list1.AssertEqual([10, 20]);
        list2.AssertEqual([10, 20]);

        list1.Dispose();
        list2.Dispose();

        var list3 = refCounted.ToLiveList();

        subject.OnNext(30);
        subject.OnCompleted();

        list3.AssertEqual([30]);
        list3.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ScanTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ScanTest
{
    [Fact]
    public void Scan()
    {
        using var list = Observable
            .Range(1, 3)
            .Scan(static (first, second) => first + second)
            .ToLiveList();

        list.AssertEqual([ 1, 3, 6 ]);
    }

    [Fact]
    public void ScanWithSeed()
    {
        using var list = Observable
            .Range(1, 3)
            .Scan(1, static (first, second) => first + second)
            .ToLiveList();

        list.AssertEqual([ 2, 4, 7]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SelectAwaitTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace R3.Tests.OperatorTests;

public class SelectAwaitTest
{
    [Fact]
    public void Sequential()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Sequential, configureAwait: false)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 200, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public async Task SequentialCancel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        bool canceled = false;
        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                    return x * 100;
                }
                catch (OperationCanceledException)
                {
                    canceled = true;
                    throw;
                }
            }, AwaitOperation.Sequential)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100]);

        canceled.ShouldBeFalse();

        liveList.Dispose();

        await Task.Delay(TimeSpan.FromSeconds(1));

        canceled.ShouldBeTrue();
    }

    [Fact]
    public void Drop()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Drop)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public async Task DropCancel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();
        bool canceled = false;

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                    return x * 100;
                }
                catch (OperationCanceledException)
                {
                    canceled = true;
                    throw;
                }
            }, AwaitOperation.Drop)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        Thread.Sleep(100);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        Thread.Sleep(100);
        liveList.AssertEqual([100]);

        subject.OnNext(3);

        canceled.ShouldBeFalse();

        liveList.Dispose();

        await Task.Delay(TimeSpan.FromSeconds(1));

        canceled.ShouldBeTrue();
    }

    [Fact]
    public void Parallel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Parallel)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 200]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 200, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public async Task ParallelCancel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();
        var canceled = false;

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                    return x * 100;
                }
                catch (OperationCanceledException)
                {
                    canceled = true;
                    throw;
                }
            }, AwaitOperation.Parallel)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 200]);

        subject.OnNext(3);

        canceled.ShouldBeFalse();
        liveList.Dispose();

        await Task.Delay(TimeSpan.FromSeconds(1));

        canceled.ShouldBeTrue();
    }


    [Fact]
    public void SequentialOnCompleted()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Sequential, configureAwait: false)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 200, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void Switch()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Switch, configureAwait: false)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2); // disposed 1

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([200]);

        timeProvider.Advance(2);
        liveList.AssertEqual([200]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([200]);

        timeProvider.Advance(3);
        liveList.AssertEqual([200, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void SequentialParallel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(x), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.SequentialParallel, configureAwait: false)
            .ToLiveList();

        subject.OnNext(2); // 2 seconds wait
        subject.OnNext(1); // 1 seconds wait

        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([]); // 1 seconds complete but not yet complete

        timeProvider.Advance(1);
        liveList.AssertEqual([200, 100]); // both complete

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([200, 100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([200, 100, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void ParallelLimit()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.Parallel, maxConcurrent: 2)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3); // enqueue

        liveList.AssertEqual([]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 200]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 200, 300]);

        subject.OnNext(4);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 200, 300, 400]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void SequentialParallelLimit()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(x), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.SequentialParallel, configureAwait: false, cancelOnCompleted: false, maxConcurrent: 2)
            .ToLiveList();

        subject.OnNext(2); // 2 seconds wait
        subject.OnNext(1); // 1 seconds wait
        subject.OnNext(3); // 3 seconds enqueue
        subject.OnNext(2); // 1 seconds enqueue

        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([]); // 1 seconds complete but not yet complete, start 3 seconds

        timeProvider.Advance(1);
        liveList.AssertEqual([200, 100]); // both complete

        timeProvider.Advance(2);
        liveList.AssertEqual([200, 100, 300, 200]);

        subject.OnNext(2); // 2 seconds wait
        subject.OnNext(1); // 1 seconds wait
        subject.OnNext(3); // 3 seconds enqueue
        subject.OnNext(2); // 1 seconds enqueue

        subject.OnCompleted();

        timeProvider.Advance(2);
        liveList.AssertEqual([200, 100, 300, 200, 200, 100]);
        timeProvider.Advance(3);
        liveList.AssertEqual([200, 100, 300, 200, 200, 100, 300, 200]);

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void ThrottleFirstLast()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x * 100;
            }, AwaitOperation.ThrottleFirstLast, configureAwait: false)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        subject.OnNext(4);
        subject.OnNext(5);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 500]);

        subject.OnNext(6);
        subject.OnNext(7);
        subject.OnNext(8);
        subject.OnNext(9);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 500]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 500, 600]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 500, 600, 900]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public async Task ThrottleFirstLastCancel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        bool canceled = false;
        using var liveList = subject
            .SelectAwait(async (x, ct) =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                    return x * 100;
                }
                catch (OperationCanceledException)
                {
                    canceled = true;
                    throw;
                }
            }, AwaitOperation.ThrottleFirstLast)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100]);

        canceled.ShouldBeFalse();

        liveList.Dispose();

        await Task.Delay(TimeSpan.FromSeconds(1));

        canceled.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SelectManyTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class SelectManyTest
{
    [Fact]
    public void Standard()
    {
        var root = new Subject<int>();
        var child1 = new Subject<int>();
        var child2 = new Subject<int>();
        var child3 = new Subject<int>();
        Subject<int>[] childs = [child1, child2, child3];

        using var list = root.SelectMany(x => childs[x], (x, y) => y).ToLiveList();

        // many
        root.OnNext(0);
        root.OnNext(1);
        root.OnNext(2);

        list.AssertEqual([]);

        child1.OnNext(100);
        list.AssertEqual([100]);

        child2.OnNext(2000);
        list.AssertEqual([100, 2000]);

        child3.OnCompleted();
        child1.OnCompleted();
        child2.OnCompleted();

        list.AssertIsNotCompleted();

        root.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void Standard2()
    {
        var root = new Subject<int>();
        var child1 = new Subject<int>();
        var child2 = new Subject<int>();
        var child3 = new Subject<int>();
        Subject<int>[] childs = [child1, child2, child3];

        using var list = root.SelectMany(x => childs[x], (x, y) => y).ToLiveList();

        // many
        root.OnNext(0);
        root.OnNext(1);
        root.OnNext(2);

        list.AssertEqual([]);

        child1.OnNext(100);
        list.AssertEqual([100]);

        child2.OnNext(2000);
        list.AssertEqual([100, 2000]);


        root.OnCompleted();
        list.AssertIsNotCompleted();

        child1.OnCompleted();
        child2.OnCompleted();

        list.AssertIsNotCompleted();

        child3.OnNext(9999);
        list.AssertEqual([100, 2000, 9999]);

        child3.OnCompleted();
        list.AssertIsCompleted();
    }


    [Fact]
    public void Error()
    {
        var root = new Subject<int>();
        var child1 = new Subject<int>();
        var child2 = new Subject<int>();
        var child3 = new Subject<int>();
        Subject<int>[] childs = [child1, child2, child3];

        using var list = root.SelectMany(x => childs[x], (x, y) => y).ToLiveList();

        // many
        root.OnNext(0);
        root.OnNext(1);
        root.OnNext(2);

        list.AssertEqual([]);

        child1.OnNext(100);
        list.AssertEqual([100]);

        child2.OnNext(2000);
        list.AssertEqual([100, 2000]);

        child3.OnCompleted(Result.Failure(new Exception()));
        list.AssertIsCompleted();
    }


    [Fact]
    public void WithIndex()
    {
        var root = new Subject<int>();
        var child1 = new Subject<int>();
        var child2 = new Subject<int>();
        var child3 = new Subject<int>();
        Subject<int>[] childs = [child1, child2, child3];

        using var list = root.SelectMany((x, i) => childs[i], (x, i, y, i2) => (x, i, y, i2)).ToLiveList();

        // many
        root.OnNext(1000);
        root.OnNext(2000);
        root.OnNext(3000);

        list.AssertEqual([]);

        child1.OnNext(100);
        list.AssertEqual([(1000, 0, 100, 0)]);
        child1.OnNext(200);
        list.AssertEqual([(1000, 0, 100, 0), (1000, 0, 200, 1)]);

        child2.OnNext(300);
        list.AssertEqual([(1000, 0, 100, 0), (1000, 0, 200, 1), (2000, 1, 300, 0)]);

        child3.OnCompleted();
        child1.OnCompleted();
        child2.OnCompleted();

        list.AssertIsNotCompleted();

        root.OnCompleted();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SelectTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class SelectTest
{
    [Fact]
    public void Select()
    {
        var subject = new Subject<int>();
        using var list = subject.Select(x => x * 2).ToLiveList();

        subject.OnNext(10);
        list.AssertEqual([20]);

        subject.OnNext(20);
        list.AssertEqual([20, 40]);

        subject.OnNext(40);
        list.AssertEqual([20, 40, 80]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }

    // WhereSelect
    [Fact]
    public void WhereSelect()
    {
        var subject = new Subject<int>();
        using var list = subject.Where(x => x % 2 == 0).Select(x => x * 2).ToLiveList();

        subject.OnNext(10);
        list.AssertEqual([20]);

        subject.OnNext(11);
        list.AssertEqual([20]);

        subject.OnNext(20);
        list.AssertEqual([20, 40]);

        subject.OnNext(40);
        list.AssertEqual([20, 40, 80]);

        subject.OnNext(99);
        list.AssertEqual([20, 40, 80]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }

    // SelectWithIndex
    [Fact]
    public void SelectWithIndex()
    {
        var subject = new Subject<int>();
        using var list = subject.Select((x, i) => x * 2 + i).ToLiveList();

        subject.OnNext(10);
        list.AssertEqual([20]);

        subject.OnNext(20);
        list.AssertEqual([20, 41]);

        subject.OnNext(40);
        list.AssertEqual([20, 41, 82]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }

    // Select State
    [Fact]
    public void SelectState()
    {
        var subject = new Subject<int>();
        using var list = subject.Select("a", (x, state) => x * 2 + state).ToLiveList();

        subject.OnNext(10);
        list.AssertEqual(["20a"]);

        subject.OnNext(20);
        list.AssertEqual(["20a", "40a"]);

        subject.OnNext(40);
        list.AssertEqual(["20a", "40a", "80a"]);

        subject.OnCompleted();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SequenceEqualTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class SequenceEqualTest
{
    [Fact]
    public async Task Positive()
    {
        var range1 = Observable.Range(1, 10);
        var range2 = Observable.Range(1, 10);

        var task = range1.SequenceEqualAsync(range2);
        (await task).ShouldBeTrue();
    }

    [Fact]
    public async Task Negative()
    {
        var range1 = Observable.Range(1, 10);
        var range2 = Observable.Range(1, 11);

        var task = range1.SequenceEqualAsync(range2);
        (await task).ShouldBeFalse();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SkipLastTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class SkipLastTest
{
    [Fact]
    public async Task Skip()
    {
        var xs = await Observable.Range(1, 10).SkipLast(3).ToArrayAsync();
        xs.ShouldBe([1, 2, 3, 4, 5, 6, 7]);
    }

    [Fact]
    public void SkipTime()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.SkipLast(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));
        publisher.OnNext(100);
        publisher.OnNext(1000);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        publisher.OnNext(2);
        publisher.OnNext(20);

        publisher.OnCompleted();

        list.AssertEqual([1, 10]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void SkipFrame2()
    {
        var frameProvider = new FakeFrameProvider();
        var cts = new CancellationTokenSource();

        var list = Observable.EveryUpdate(frameProvider, cts.Token)
            .Select(x => frameProvider.GetFrameCount())
            .SkipLastFrame(3, frameProvider)
            .ToLiveList();

        frameProvider.Advance(3); // 0, 1, 2
        list.AssertEqual([]);
        frameProvider.Advance(1); // 3
        list.AssertEqual([0]);

        frameProvider.Advance(1); // 4
        list.AssertEqual([0, 1]);

        frameProvider.Advance(1); // 5
        list.AssertEqual([0, 1, 2]);

        frameProvider.Advance(1); // 6
        list.AssertEqual([0, 1, 2, 3]);

        cts.Cancel(); // stop and OnCompleted(frame no is adavnced +1)

        list.AssertEqual([0, 1, 2, 3, 4]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SkipTest.cs
================================================
﻿using System;
using System.Reactive.Linq;
using Xunit.Sdk;

namespace R3.Tests.OperatorTests;

public class SkipTest
{
    [Fact]
    public async Task Skip()
    {
        var xs = await Observable.Range(1, 10).Skip(3).ToArrayAsync();

        xs.ShouldBe([4, 5, 6, 7, 8, 9, 10]);

        // skip zero
        var ys = await Observable.Range(1, 10).Skip(0).ToArrayAsync();
        ys.ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    [Fact]
    public void SkipTime()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Skip(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));

        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        list.AssertEqual([2, 20, 200]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void SkipFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.SkipFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([]);

        frameProvider.Advance(1);

        publisher.OnNext(2);
        publisher.OnNext(20);
        publisher.OnNext(200);

        list.AssertEqual([2, 20, 200]);

        publisher.OnCompleted();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SkipUntilTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class SkipUntilTest
{
    [Fact]
    public void EventOther()
    {
        var publisher1 = new Subject<int>();
        var publisher2 = new Subject<int>();
        var isDisposed = false;
        var list = publisher1.SkipUntil(publisher2.Do(onDispose: () => { isDisposed = true; })).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([]);

        publisher2.OnNext(10000);
        isDisposed.ShouldBeTrue();

        publisher1.OnNext(999999);
        publisher1.OnNext(9999990);

        list.AssertEqual([999999, 9999990]);
        publisher1.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void CancellationToken()
    {
        var publisher1 = new Subject<int>();
        var cts = new CancellationTokenSource();
        var list = publisher1.SkipUntil(cts.Token).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([]);

        cts.Cancel();

        publisher1.OnNext(999999);
        publisher1.OnNext(9999990);

        list.AssertEqual([999999, 9999990]);
        publisher1.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public async Task TaskT()
    {
        var publisher1 = new Subject<int>();
        var tcs = new TaskCompletionSource();
        var list = publisher1.SkipUntil(tcs.Task).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([]);

        tcs.TrySetResult();
        await Task.Delay(100); // wait for completion


        publisher1.OnNext(999999);
        publisher1.OnNext(9999990);

        list.AssertEqual([999999, 9999990]);
        publisher1.OnCompleted();
        list.AssertIsCompleted();
    }

    [Fact]
    public void Async()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher1 = new Subject<int>();
        var tcs = new TaskCompletionSource();
        var list = publisher1.SkipUntil(async (x,ct) => await tcs.Task).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([]);

        tcs.TrySetResult();

        publisher1.OnNext(999999);
        publisher1.OnNext(9999990);

        list.AssertEqual([999999, 9999990]);
        publisher1.OnCompleted();
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SkipWhileTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class SkipWhileTest
{
    [Fact]
    public void SkipWhile()
    {
        var xs = Observable.Range(1, 10).SkipWhile(x => x <= 3).ToLiveList();
        xs.AssertEqual([4, 5, 6, 7, 8, 9, 10]);
        xs.AssertIsCompleted();

        var ys = Observable.Range(100, 10).SkipWhile((x, i) => i < 3).ToLiveList();
        ys.AssertEqual([103, 104, 105, 106, 107, 108, 109]);
        ys.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SubscribeAwaitTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace R3.Tests.OperatorTests;

public class SubscribeAwaitTest
{
    [Fact]
    public void Sequential()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.Sequential);

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1);
        liveList.ShouldBe([100]);

        timeProvider.Advance(2);
        liveList.ShouldBe([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.ShouldBe([100, 200]);

        timeProvider.Advance(3);
        liveList.ShouldBe([100, 200, 300]);

        subject.OnCompleted();
    }

    [Fact]
    public void Drop()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.Drop);

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1);
        liveList.ShouldBe([100]);

        timeProvider.Advance(2);
        liveList.ShouldBe([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.ShouldBe([100]);

        timeProvider.Advance(2);
        liveList.ShouldBe([100, 300]);

        subject.OnCompleted();
    }

    [Fact]
    public void Parallel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.Parallel);

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1);
        liveList.ShouldBe([100, 200]);

        timeProvider.Advance(2);
        liveList.ShouldBe([100, 200]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.ShouldBe([100, 200]);

        timeProvider.Advance(2);
        liveList.ShouldBe([100, 200, 300]);

        subject.OnCompleted();
    }

    [Fact]
    public void Switch()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.Switch);

        subject.OnNext(1);
        subject.OnNext(2); // disposed 1

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1);
        liveList.ShouldBe([200]);

        timeProvider.Advance(2);
        liveList.ShouldBe([200]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.ShouldBe([200]);

        timeProvider.Advance(3);
        liveList.ShouldBe([200, 300]);

        subject.OnCompleted();
    }

    [Fact]
    public void ParallelLimit()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.Parallel, maxConcurrent: 2);

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1); // start 3
        liveList.ShouldBe([100, 200]);

        timeProvider.Advance(3);
        liveList.ShouldBe([100, 200, 300]);

        subject.OnCompleted();
    }

    [Fact]
    public void ThrottleFirstLast()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        var liveList = new List<int>();
        using var _ = subject
            .SubscribeAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                liveList.Add(x * 100);
            }, AwaitOperation.ThrottleFirstLast);

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        subject.OnNext(4);
        subject.OnNext(5);

        liveList.ShouldBe([]);

        timeProvider.Advance(2);
        liveList.ShouldBe([]);

        timeProvider.Advance(1);
        liveList.ShouldBe([100]);

        timeProvider.Advance(3);
        liveList.ShouldBe([100,500]);

        subject.OnNext(6);
        subject.OnNext(7);
        subject.OnNext(8);
        subject.OnNext(9);

        timeProvider.Advance(3);
        liveList.ShouldBe([100,500,600]);

        timeProvider.Advance(3);
        liveList.ShouldBe([100,500,600,900]);

        subject.OnCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SubscribeOnTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class SubscribeOnTest
{

    // null synccontext(TimeProvider.System)
    [Fact]
    public async Task ThreadPool()
    {
        var values = await Observable.Range(1, 10)
            .Do(onSubscribe: () => Thread.CurrentThread.IsThreadPoolThread.ShouldBeTrue())
            .SubscribeOnThreadPool()
            .ToArrayAsync();
        values.ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    [Fact]
    public async Task Synchronize()
    {
        var gate = new object();
        var values = await Observable.Range(1, 10)
            .SubscribeOnSynchronize(gate)
            .ToArrayAsync();
        values.ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }

    [Fact]
    public async Task SyncContext()
    {
        var syncContext = new CustomSyncContext();
        syncContext.IsInSyncContext.ShouldBeFalse();
        var values = await Observable.Range(1, 10)
            .Do(onSubscribe: () => syncContext.IsInSyncContext.ShouldBeTrue())
            .SubscribeOn(syncContext)
            .ToArrayAsync();
        values.ShouldBe([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        syncContext.PostCount.ShouldBe(1);
    }

    [Fact]
    public void TimeProvider()
    {
        var fakeTime = new ImmediateFakeTiemr();
        var subscribed = false;
        using var list = Observable.Range(1, 10)
            .Do(onSubscribe: () => subscribed = true)
            .SubscribeOn(fakeTime)
            .ToLiveList();


        subscribed.ShouldBeFalse();

        fakeTime.Advance();
        subscribed.ShouldBeTrue();

        list.AssertEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }


    [Fact]
    public void FrameProvider()
    {

        var fakeTime = new FakeFrameProvider();
        var subscribed = false;
        using var list = Observable.Range(1, 10)
            .Do(onSubscribe: () => subscribed = true)
            .SubscribeOn(fakeTime)
            .ToLiveList();


        subscribed.ShouldBeFalse();

        fakeTime.Advance();
        subscribed.ShouldBeTrue();

        list.AssertEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    }
}

file class CustomSyncContext : SynchronizationContext
{
    public int PostCount;
    public bool IsInSyncContext { get; set; }

    public override void Post(SendOrPostCallback d, object? state)
    {
        IsInSyncContext = true;
        PostCount++;
        d(state);
        IsInSyncContext = false;
    }
}

file class ImmediateFakeTiemr : TimeProvider
{
    List<Timer> timers = new();

    public override ITimer CreateTimer(TimerCallback callback, object? state, TimeSpan dueTime, TimeSpan period)
    {
        var t = new Timer(callback, state);
        timers.Add(t);
        return t;
    }

    public void Advance()
    {
        foreach (var item in timers)
        {
            item.Wakeup();
        }
    }

    class Timer(TimerCallback callback, object? state) : ITimer
    {
        public bool Change(TimeSpan dueTime, TimeSpan period)
        {
            return false;
        }

        public bool Wakeup()
        {
            callback(state);
            return true;
        }

        public void Dispose()
        {
        }

        public ValueTask DisposeAsync()
        {
            return default;
        }
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SumTest.cs
================================================
﻿using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;

namespace R3.Tests.OperatorTests;

public class SumTest
{
    [Fact]
    public async Task Empty()
    {
        (await Observable.Empty<int>().SumAsync()).ShouldBe(0);
        (await Observable.Empty<TestNumber>().SumAsync()).Value.ShouldBe(0);
    }

    [Fact]
    public async Task One()
    {
        (await Observable.Return(999).SumAsync()).ShouldBe(999);
        (await Observable.Return(new TestNumber(999)).SumAsync()).Value.ShouldBe(999);
    }

    [Fact]
    public async Task Error()
    {
        var error = Observable.Range(0, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () => await error.SumAsync());
        await Assert.ThrowsAsync<Exception>(async () => await error.OnErrorResumeAsFailure().SumAsync());
    }

    [Fact]
    public async Task MultipleValues()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();
        (await source.SumAsync()).ShouldBe(36);

        var source2 = source.Select(x => new TestNumber(x));
        (await source2.SumAsync()).Value.ShouldBe(36);
    }

    [Fact]
    public async Task WithSelector()
    {
        var source = new[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();

        (await source.SumAsync(x => x * 10f)).ShouldBe(360f);
        // (await source.SumAsync(x => new TestNumber(x))).Value.ShouldBe(36);
    }

    [Fact]
    public async Task WithSelectorError()
    {
        var error = Observable.Range(1, 10).Select(x =>
        {
            if (x == 3) throw new Exception("foo");
            return x;
        });

        await Assert.ThrowsAsync<Exception>(async () => await error.SumAsync(x => x));
        await Assert.ThrowsAsync<Exception>(async () => await error.OnErrorResumeAsFailure().SumAsync(x => x));
        await Assert.ThrowsAsync<Exception>(async () => await Observable.Range(0, 10).SumAsync(x => throw new Exception("bra")));
    }

    record struct TestNumber(int Value) : INumber<TestNumber>
    {
        public static TestNumber One => throw new NotImplementedException();

        public static int Radix => throw new NotImplementedException();

        public static TestNumber Zero => new TestNumber(0);

        public static TestNumber AdditiveIdentity => throw new NotImplementedException();

        public static TestNumber MultiplicativeIdentity => throw new NotImplementedException();

        static TestNumber INumberBase<TestNumber>.One => throw new NotImplementedException();

        static int INumberBase<TestNumber>.Radix => throw new NotImplementedException();

        static TestNumber INumberBase<TestNumber>.Zero => new TestNumber(0);

        static TestNumber IAdditiveIdentity<TestNumber, TestNumber>.AdditiveIdentity => throw new NotImplementedException();

        static TestNumber IMultiplicativeIdentity<TestNumber, TestNumber>.MultiplicativeIdentity => throw new NotImplementedException();

        public static TestNumber Abs(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsCanonical(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsComplexNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsEvenInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsFinite(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsImaginaryNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsNaN(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsNegative(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsNegativeInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsNormal(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsOddInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsPositive(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsPositiveInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsRealNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsSubnormal(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static bool IsZero(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static TestNumber MaxMagnitude(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        public static TestNumber MaxMagnitudeNumber(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        public static TestNumber MinMagnitude(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        public static TestNumber MinMagnitudeNumber(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        public static TestNumber Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        public static TestNumber Parse(string s, NumberStyles style, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        public static TestNumber Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        public static TestNumber Parse(string s, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, [MaybeNullWhen(false)] out TestNumber result)
        {
            throw new NotImplementedException();
        }

        public static bool TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, [MaybeNullWhen(false)] out TestNumber result)
        {
            throw new NotImplementedException();
        }

        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out TestNumber result)
        {
            throw new NotImplementedException();
        }

        public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.Abs(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsCanonical(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsComplexNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsEvenInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsFinite(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsImaginaryNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsNaN(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsNegative(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsNegativeInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsNormal(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsOddInteger(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsPositive(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsPositiveInfinity(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsRealNumber(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsSubnormal(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.IsZero(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.MaxMagnitude(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.MaxMagnitudeNumber(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.MinMagnitude(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.MinMagnitudeNumber(TestNumber x, TestNumber y)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        static TestNumber INumberBase<TestNumber>.Parse(string s, NumberStyles style, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        static TestNumber ISpanParsable<TestNumber>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        static TestNumber IParsable<TestNumber>.Parse(string s, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertFromChecked<TOther>(TOther value, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertFromSaturating<TOther>(TOther value, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertFromTruncating<TOther>(TOther value, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertToChecked<TOther>(TestNumber value, out TOther result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertToSaturating<TOther>(TestNumber value, out TOther result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryConvertToTruncating<TOther>(TestNumber value, out TOther result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool INumberBase<TestNumber>.TryParse(string? s, NumberStyles style, IFormatProvider? provider, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool ISpanParsable<TestNumber>.TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        static bool IParsable<TestNumber>.TryParse(string? s, IFormatProvider? provider, out TestNumber result)
        {
            throw new NotImplementedException();
        }

        public int CompareTo(object? obj)
        {
            throw new NotImplementedException();
        }

        public int CompareTo(TestNumber other)
        {
            throw new NotImplementedException();
        }

        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            throw new NotImplementedException();
        }

        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        int IComparable.CompareTo(object? obj)
        {
            throw new NotImplementedException();
        }

        int IComparable<TestNumber>.CompareTo(TestNumber other)
        {
            throw new NotImplementedException();
        }

        bool IEquatable<TestNumber>.Equals(TestNumber other)
        {
            throw new NotImplementedException();
        }

        string IFormattable.ToString(string? format, IFormatProvider? formatProvider)
        {
            throw new NotImplementedException();
        }

        bool ISpanFormattable.TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator +(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static TestNumber IUnaryPlusOperators<TestNumber, TestNumber>.operator +(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator +(TestNumber left, TestNumber right) =>
            new(left.Value + right.Value);

        static TestNumber IAdditionOperators<TestNumber, TestNumber, TestNumber>.operator +(TestNumber left, TestNumber right)
        {
            return new(left.Value + right.Value);
        }

        public static TestNumber operator -(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static TestNumber IUnaryNegationOperators<TestNumber, TestNumber>.operator -(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator -(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static TestNumber ISubtractionOperators<TestNumber, TestNumber, TestNumber>.operator -(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator ++(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static TestNumber IIncrementOperators<TestNumber>.operator ++(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator --(TestNumber value)
        {
            throw new NotImplementedException();
        }

        static TestNumber IDecrementOperators<TestNumber>.operator --(TestNumber value)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator *(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static TestNumber IMultiplyOperators<TestNumber, TestNumber, TestNumber>.operator *(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator /(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static TestNumber IDivisionOperators<TestNumber, TestNumber, TestNumber>.operator /(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static TestNumber operator %(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static TestNumber IModulusOperators<TestNumber, TestNumber, TestNumber>.operator %(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IEqualityOperators<TestNumber, TestNumber, bool>.operator ==(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IEqualityOperators<TestNumber, TestNumber, bool>.operator !=(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static bool operator <(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IComparisonOperators<TestNumber, TestNumber, bool>.operator <(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static bool operator >(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IComparisonOperators<TestNumber, TestNumber, bool>.operator >(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static bool operator <=(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IComparisonOperators<TestNumber, TestNumber, bool>.operator <=(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        public static bool operator >=(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }

        static bool IComparisonOperators<TestNumber, TestNumber, bool>.operator >=(TestNumber left, TestNumber right)
        {
            throw new NotImplementedException();
        }
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SwitchTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class SwitchTest
{
    [Fact]
    public void Switch()
    {
        var sources = new Subject<Observable<int>>();

        using var list = sources.Switch().ToLiveList();

        var source1 = new Subject<int>();
        var source2 = new Subject<int>();

        sources.OnNext(source1);

        list.AssertEmpty();

        source1.OnNext(1);
        source1.OnNext(2);

        sources.OnNext(source2);

        source2.OnNext(10);

        source1.OnNext(3);

        list.AssertEqual([1, 2, 10]);

        source1.OnCompleted();
        source2.OnCompleted();

        list.AssertIsNotCompleted();

        sources.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void DisposeOrderCheck()
    {
        var sources = new Subject<Observable<int>>();

        using var list = sources.Switch().ToLiveList();

        var source1 = new Subject<int>();
        var source2 = new Subject<int>();

        var msgs = new List<string>();

        sources.OnNext(source1.Do(onDispose: () => msgs.Add("dispose source1"), onSubscribe: () => msgs.Add("subscribe source1")));
        sources.OnNext(source2.Do(onDispose: () => msgs.Add("dispose source2"), onSubscribe: () => msgs.Add("subscribe source2")));
        source2.OnCompleted();

        msgs.Is(["subscribe source1", "dispose source1", "subscribe source2", "dispose source2"]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/SynchronizationTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class SynchronizationTest(ITestOutputHelper output)
{
    [Fact]
    public void Test()
    {
        var subject = new Subject<int>();

        var count = 0;
        var no_sync = 0;
        subject.Subscribe(x => no_sync++);
        subject.Synchronize().Subscribe(x => count++);

        Parallel.For(0, 100, x => subject.OnNext(x));

        count.ShouldBe(100);
        output.WriteLine($"Count: {count}, no_sync: {no_sync}");
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TakeLastTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class TakeLastTest(ITestOutputHelper helper)
{
    [Fact]
    public async Task Take()
    {
        var xs = await Observable.Range(1, 10).TakeLast(3).ToArrayAsync();
        xs.ShouldBe([8, 9, 10]);
    }

    [Fact]
    public void TakeTime()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.TakeLast(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        list.AssertEqual([]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));
        publisher.OnNext(100);
        publisher.OnNext(1000);

        timeProvider.Advance(TimeSpan.FromSeconds(2));
        publisher.OnNext(2);
        publisher.OnNext(20);

        publisher.OnCompleted();

        list.AssertEqual([100, 1000, 2, 20]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void TakeFrame2()
    {
        var frameProvider = new FakeFrameProvider();
        var cts = new CancellationTokenSource();

        var list = Observable.EveryUpdate(frameProvider, cts.Token)
            .Select(x => frameProvider.GetFrameCount())
            .TakeLastFrame(3, frameProvider)
            .ToLiveList();

        frameProvider.Advance(3); // 0, 1, 2
        list.AssertEqual([]);

        frameProvider.Advance(2); // 3, 4
        frameProvider.Advance(1); // 5

        cts.Cancel(); // stop and OnCompleted

        list.AssertEqual([3, 4, 5]);
        list.AssertIsCompleted();
    }

    //[Fact]
    //public async Task DisposeQueue()
    //{
    //    var defaultHandler = ObservableSystem.GetUnhandledExceptionHandler();
    //    Exception? exception = null; 
    //    ObservableSystem.RegisterUnhandledExceptionHandler(ex =>
    //    {
    //        exception = ex;
    //    });
    //    try
    //    {
    //        var status = Observable.Interval(TimeSpan.FromMilliseconds(100)).Index();
    //        var doSomething = Observable.Interval(TimeSpan.FromMilliseconds(100)).Take(5);

    //        var end = new TaskCompletionSource();
    //        status.TakeUntil(doSomething.TakeLast(1)).Subscribe(_ => end.TrySetResult());

    //        await end.Task;
    //        await Task.Delay(TimeSpan.FromMilliseconds(500));

    //        exception!.ShouldBeNull();
    //        // helper.WriteLine(exception!.Message);
    //    }
    //    finally
    //    {
    //        ObservableSystem.RegisterUnhandledExceptionHandler(defaultHandler);
    //    }
    //}
}



================================================
FILE: tests/R3.Tests/OperatorTests/TakeTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class TakeTest
{
    [Fact]
    public async Task Take()
    {
        var xs = await Observable.Range(1, 10).Take(3).ToArrayAsync();

        xs.ShouldBe([1, 2, 3]);

        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Take(TimeSpan.FromSeconds(5), timeProvider).ToLiveList();

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        timeProvider.Advance(TimeSpan.FromSeconds(3));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1, 10, 100, 1000, 10000]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));
        list.AssertIsCompleted();
    }

    [Fact]
    public void TakeFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.TakeFrame(5, frameProvider).ToLiveList();
        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        frameProvider.Advance(3);
        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1, 10, 100, 1000, 10000]);
        frameProvider.Advance(2);
        list.AssertIsCompleted();
    }

    [Fact]
    public void TakeFrame2()
    {
        var frameProvider = new FakeFrameProvider();

        var list = Observable.EveryUpdate(frameProvider)
            .Select(x => frameProvider.GetFrameCount())
            .TakeFrame(5, frameProvider)
            .ToLiveList();

        frameProvider.Advance(3);
        list.AssertEqual([0, 1, 2]);

        frameProvider.Advance(2);

        // not guranteed everyupdate and takeframe which call first
        // list.AssertEqual([0, 1, 2, 3]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TakeUntilTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class TakeUntilTest
{
    [Fact]
    public void EventOther()
    {
        var publisher1 = new Subject<int>();
        var publisher2 = new Subject<int>();
        var isDisposed = false;
        var list = publisher1.TakeUntil(publisher2.Do(onDispose: () => { isDisposed = true; })).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        publisher2.OnNext(10000);
        isDisposed.ShouldBeTrue();

        list.AssertEqual([1, 2, 3]);
        list.AssertIsCompleted();
    }


    [Fact]
    public void CancellationToken()
    {
        var publisher1 = new Subject<int>();
        var cts = new CancellationTokenSource();
        var list = publisher1.TakeUntil(cts.Token).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        cts.Cancel();

        list.AssertEqual([1, 2, 3]);
        list.AssertIsCompleted();
    }

    [Fact]
    public async Task TaskT()
    {
        var publisher1 = new Subject<int>();
        var tcs = new TaskCompletionSource();
        var list = publisher1.TakeUntil(tcs.Task).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        tcs.TrySetResult();
        await Task.Delay(100); // wait for completion

        list.AssertEqual([1, 2, 3]);
        list.AssertIsCompleted();
    }

    [Fact]
    public void Async()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher1 = new Subject<int>();
        var tcs = new TaskCompletionSource();
        var list = publisher1.TakeUntil(async (x, ct) => await tcs.Task).ToLiveList();

        publisher1.OnNext(1);
        publisher1.OnNext(2);
        publisher1.OnNext(3);
        list.AssertEqual([1, 2, 3]);

        tcs.TrySetResult();

        list.AssertEqual([1, 2, 3]);
        list.AssertIsCompleted();

    }

    [Fact]
    public void Predicate()
    {
        var sequence = new[] { "A", "B", "C", "D", "E", "F", "G" };

        sequence.ToObservable().TakeUntil(x => x == "E").ToLiveList().AssertEqual("A", "B", "C", "D", "E");
        sequence.ToObservable().TakeUntil(x => x == "A").ToLiveList().AssertEqual("A");

        sequence.ToObservable().TakeUntil((x, i) => i == 4).ToLiveList().AssertEqual("A", "B", "C", "D", "E");
        sequence.ToObservable().TakeUntil((x, i) => i == 0).ToLiveList().AssertEqual("A");
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TakeWhileTest.cs
================================================
﻿using System.Reactive.Linq;

namespace R3.Tests.OperatorTests;

public class TakeWhileTest
{
    [Fact]
    public void TakeWhile()
    {
        var xs = Observable.Range(1, 10).TakeWhile(x => x <= 3).ToLiveList();
        xs.AssertEqual([1, 2, 3]);
        xs.AssertIsCompleted();

        var ys = Observable.Range(100, 10).TakeWhile((x, i) => i < 3).ToLiveList();
        ys.AssertEqual([100, 101, 102]);
        ys.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ThrottleFirstLastTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ThrottleFirstLastTest
{
    // ThrottleFirstLast(TimeSpan)
    [Fact]
    public void ThrottleFirstLast()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleFirstLast(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);

        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([1, 10000]);
        publisher.OnNext(2);
        list.AssertEqual([1, 10000, 2]);
        publisher.OnNext(20);
        publisher.OnNext(200);

        timeProvider.Advance(TimeSpan.FromSeconds(3));
        list.AssertEqual([1, 10000, 2, 200]);
        publisher.OnNext(3);
        list.AssertEqual([1, 10000, 2, 200, 3]);

        publisher.OnCompleted();

        list.AssertEqual([1, 10000, 2, 200, 3]);
        list.AssertIsCompleted();
    }

    // ThrottleFirstLast(async)
    [Fact]
    public void ThrottleFirstLastAsyncSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var fakeTime = new FakeTimeProvider();
        var list = publisher.ThrottleFirstLast(async (x, ct) =>
        {
            await Task.Delay(TimeSpan.FromSeconds(x), fakeTime, ct);
        }).ToLiveList();

        publisher.OnNext(1); // gate close
        list.AssertEqual([1]);
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([1]);

        fakeTime.Advance(1); // gate open
        list.AssertEqual([1, 3]);

        publisher.OnNext(5);
        list.AssertEqual([1, 3, 5]);

        publisher.OnNext(6);
        publisher.OnNext(7);

        fakeTime.Advance(4);
        list.AssertEqual([1, 3, 5]);

        publisher.OnNext(8);

        list.AssertEqual([1, 3, 5]);

        fakeTime.Advance(1);
        list.AssertEqual([1, 3, 5, 8]);

        publisher.OnNext(9);

        fakeTime.Advance(9);

        list.AssertEqual([1, 3, 5, 8, 9]);

        publisher.OnNext(10);

        fakeTime.Advance(10);

        list.AssertEqual([1, 3, 5, 8, 9, 10]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }

    // ThrottleFirstLast(Observable)
    [Fact]
    public void ThrottleFirstLastObservableSampler()
    {
        SynchronizationContext.SetSynchronizationContext(null);

        var publisher = new Subject<int>();
        var sampler = new Subject<Unit>();
        var list = publisher.ThrottleFirstLast(sampler).ToLiveList();

        publisher.OnNext(1); // gate close
        list.AssertEqual([1]);
        publisher.OnNext(2);
        publisher.OnNext(3);

        list.AssertEqual([1]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([1, 3]);

        publisher.OnNext(5);
        list.AssertEqual([1, 3, 5]);
        publisher.OnNext(6);
        publisher.OnNext(7);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([1, 3, 5, 7]);


        publisher.OnNext(8);
        list.AssertEqual([1, 3, 5, 7, 8]);

        sampler.OnNext(Unit.Default);
        list.AssertEqual([1, 3, 5, 7, 8]);
        sampler.OnNext(Unit.Default);
        sampler.OnNext(Unit.Default);
        list.AssertEqual([1, 3, 5, 7, 8]);

        publisher.OnCompleted();

        list.AssertIsCompleted();
    }


    // ThrottleFirstLastFrame

    [Fact]
    public void ThrottleFirstLastFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.ThrottleFirstLastFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);
        publisher.OnNext(10);
        publisher.OnNext(100);
        list.AssertEqual([1]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1]);

        frameProvider.Advance(1);
        list.AssertEqual([1, 10000]);
        publisher.OnNext(2);
        list.AssertEqual([1, 10000, 2]);
        publisher.OnNext(20);
        publisher.OnNext(200);

        frameProvider.Advance(3);
        list.AssertEqual([1, 10000, 2, 200]);
        publisher.OnNext(3);

        publisher.OnCompleted();

        list.AssertEqual([1, 10000, 2, 200, 3]);
        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TimeIntervalFrameIntervalTimestampFrameCountTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace R3.Tests.OperatorTests;

public class TimeIntervalFrameIntervalTimestampFrameCountTest
{
    // TimeInterval
    // FrameInterval
    // Timestamp
    // FrameCount

    [Fact]
    public void TimeInterval()
    {
        var subject = new Subject<int>();
        var provider = new FakeTimeProvider();

        using var list = subject.TimeInterval(provider).ToLiveList();

        provider.Advance(3);

        subject.OnNext(0);
        list.AssertEqual([(TimeSpan.FromSeconds(3), 0)]);

        subject.OnNext(1);
        list.AssertEqual([(TimeSpan.FromSeconds(3), 0), (TimeSpan.FromSeconds(0), 1)]);

        provider.Advance(2);

        subject.OnNext(2);
        list.AssertEqual([(TimeSpan.FromSeconds(3), 0), (TimeSpan.FromSeconds(0), 1), (TimeSpan.FromSeconds(2), 2)]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void FrameInterval()
    {
        var subject = new Subject<int>();
        var provider = new FakeFrameProvider();

        using var list = subject.FrameInterval(provider).ToLiveList();

        provider.Advance(3);

        subject.OnNext(0);
        list.AssertEqual([((3), 0)]);

        subject.OnNext(1);
        list.AssertEqual([((3), 0), ((0), 1)]);

        provider.Advance(2);

        subject.OnNext(2);
        list.AssertEqual([((3), 0), ((0), 1), ((2), 2)]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void Timestamp()
    {
        var subject = new Subject<int>();
        var provider = new FakeTimeProvider(DateTimeOffset.MinValue);

        using var list = subject.Timestamp(provider).ToLiveList();

        subject.OnNext(0);
        list.AssertEqual([(0, 0)]);

        provider.Advance(TimeSpan.FromTicks(3));
        subject.OnNext(1);
        list.AssertEqual([(0, 0), (3, 1)]);

        provider.Advance(TimeSpan.FromTicks(2));

        subject.OnNext(2);
        list.AssertEqual([(0, 0), (3, 1), (5, 2)]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void FrameCount()
    {
        var subject = new Subject<int>();
        var provider = new FakeFrameProvider();

        using var list = subject.FrameCount(provider).ToLiveList();

        subject.OnNext(0);
        list.AssertEqual([(0, 0)]);

        provider.Advance(3);
        subject.OnNext(1);
        list.AssertEqual([(0, 0), (3, 1)]);

        provider.Advance(2);

        subject.OnNext(2);
        list.AssertEqual([(0, 0), (3, 1), (5, 2)]);

        subject.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TimeoutTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class TimeoutTest
{
    [Fact]
    public void Timeout()
    {
        var timeProvider = new FakeTimeProvider();

        var publisher = new Subject<int>();
        var list = publisher.Timeout(TimeSpan.FromSeconds(3), timeProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);

        timeProvider.Advance(TimeSpan.FromSeconds(2));

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1, 1000, 10000]);

        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([1, 1000, 10000]);
        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertEqual([1, 1000, 10000]);
        timeProvider.Advance(TimeSpan.FromSeconds(1));
        list.AssertIsCompleted();
        list.Result.Exception!.ShouldBeOfType<TimeoutException>();
    }

    [Fact]
    public void TimeoutFrame()
    {
        var frameProvider = new FakeFrameProvider();

        var publisher = new Subject<int>();
        var list = publisher.TimeoutFrame(3, frameProvider).ToLiveList();

        publisher.OnNext(1);
        list.AssertEqual([1]);

        frameProvider.Advance(2);

        publisher.OnNext(1000);
        publisher.OnNext(10000);
        list.AssertEqual([1, 1000, 10000]);

        frameProvider.Advance(1);
        list.AssertEqual([1, 1000, 10000]);
        frameProvider.Advance(1);
        list.AssertEqual([1, 1000, 10000]);
        frameProvider.Advance(1);
        list.AssertIsCompleted();
        list.Result.Exception!.ShouldBeOfType<TimeoutException>();
    }

    [Fact]
    public void Timeout2()
    {
        var fakeTimeProvider = new FakeTimeProvider();
        using var subject = new R3.Subject<int>();

        var results =
            subject.Timeout(TimeSpan.FromSeconds(3), fakeTimeProvider)
                .Materialize()
                .ToLiveList();

        // Timeout
        fakeTimeProvider.Advance(5);

        results.ShouldBeEmpty();
    }

    [Fact]
    public void TimeoutFrame2()
    {
        var fakeFrameProvider = new FakeFrameProvider();
        using var subject = new R3.Subject<int>();

        var results =
            subject.TimeoutFrame(3, fakeFrameProvider)
                .Materialize()
                .ToLiveList();

        // Timeout
        fakeFrameProvider.Advance(5);

        results.ShouldBeEmpty();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToArrayTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToArrayTest
{
    [Fact]
    public async Task Complete()
    {
        var publisher = new Subject<int>();

        var listTask = publisher.ToArrayAsync();

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        (await listTask).ShouldBe([1, 2, 3, 4, 5]);
    }

    [Fact]
    public async Task ResultCompletableFault()
    {
        var publisher = new Subject<int>();

        var listTask = publisher.ToArrayAsync();

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted(Result.Failure(new Exception("foo")));

        await Assert.ThrowsAsync<Exception>(async () => await listTask);
    }

    [Fact]
    public async Task ResultCompletableCancel()
    {
        var cts = new CancellationTokenSource();
        var isDisposed = false;

        var publisher = new Subject<int>();

        var listTask = publisher.Do(onDispose: () => isDisposed = true).ToArrayAsync(cts.Token);

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        cts.Cancel();

        await Assert.ThrowsAsync<TaskCanceledException>(async () => await listTask);

        isDisposed.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToAsyncEnumerableTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToAsyncEnumerableTest
{
    [Fact]
    async Task Test()
    {
        var publisher = new Subject<int>();
        var cts = new CancellationTokenSource();
        var e = publisher.ToAsyncEnumerable(cts.Token);

        publisher.OnNext(1);
        publisher.OnNext(10);
        publisher.OnNext(100);
        publisher.OnCompleted();

        var l = new List<int>();
        await foreach (var item in e)
        {
            l.Add(item);
        }

        l.ShouldBe([1, 10, 100]);
    }

    [Fact]
    async Task Cancel()
    {
        var publisher = new Subject<int>();
        var cts = new CancellationTokenSource();

        var disposed = false;
        var e = publisher.Do(onDispose: () => disposed = true).ToAsyncEnumerable(cts.Token);

        publisher.OnNext(1);
        publisher.OnNext(10);

        publisher.OnNext(100);
        // publisher.OnCompleted();

        var l = new List<int>();

        await Assert.ThrowsAsync<TaskCanceledException>(async () =>
        {
            await foreach (var item in e)
            {
                l.Add(item);
                if (item == 10)
                {
                    cts.Cancel();
                }
            }
        });

        l.ShouldBe([1, 10, 100]);
        disposed.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToDictionaryTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToDictionaryTest
{
    [Fact]
    public async Task ToDictionary()
    {
        var publisher = new Subject<(int, string)>();

        var task = publisher.ToDictionaryAsync(static x => x.Item1);

        publisher.OnNext((1, "a"));
        publisher.OnNext((2, "b"));
        publisher.OnNext((3, "c"));

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        task.Status.ShouldBe(TaskStatus.RanToCompletion);

        var expected = new Dictionary<int, (int, string)>
        {
            [1] = (1, "a"),
            [2] = (2, "b"),
            [3] = (3, "c")
        };

        (await task).ShouldBe(expected);
    }

    [Fact]
    public async Task ToDictionaryWithElementSelector()
    {
        var publisher = new Subject<(int, string)>();

        var task = publisher.ToDictionaryAsync(static x => x.Item1, static x => x.Item2.ToUpperInvariant());

        publisher.OnNext((1, "a"));
        publisher.OnNext((2, "b"));
        publisher.OnNext((3, "c"));

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        task.Status.ShouldBe(TaskStatus.RanToCompletion);

        var expected = new Dictionary<int, string>
        {
            [1] = "A",
            [2] = "B",
            [3] = "C"
        };

        (await task).ShouldBe(expected);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToHashSetTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToHashSetTest
{
    [Fact]
    public async Task Many()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();
        var set = await source.ToHashSetAsync();

        set.ShouldBe(new int[] { 1, 10, 3, 4, 6, 7 });
    }

    [Fact]
    public async Task SetComparer()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();
        var set = await source.ToHashSetAsync(new TestComparer());

        set.ShouldBe((int[])[1, 10, 3, 4, 6, 7]);
        set.Comparer.GetType().ShouldBe(typeof(TestComparer));
    }

    class TestComparer : IEqualityComparer<int>
    {
        public bool Equals(int x, int y) => x == y;
        public int GetHashCode(int obj) => obj.GetHashCode();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToListTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToListTest
{
    [Fact]
    public async Task ToList()
    {
        var publisher = new Subject<int>();

        var listTask = publisher.ToListAsync();

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        (await listTask).ShouldBe([1, 2, 3, 4, 5]);
    }

    [Fact]
    public async Task ResultCompletableFault()
    {
        var publisher = new Subject<int>();

        var listTask = publisher.ToListAsync();

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted(Result.Failure(new Exception("foo")));

        await Assert.ThrowsAsync<Exception>(async () => await listTask);
    }

    [Fact]
    public async Task ResultCompletableCancel()
    {
        var cts = new CancellationTokenSource();
        var isDisposed = false;

        var publisher = new Subject<int>();

        var listTask = publisher.Do(onDispose: () => isDisposed = true).ToListAsync(cts.Token);

        publisher.OnNext(1);
        publisher.OnNext(2);
        publisher.OnNext(3);
        publisher.OnNext(4);
        publisher.OnNext(5);

        listTask.Status.ShouldBe(TaskStatus.WaitingForActivation);

        cts.Cancel();

        await Assert.ThrowsAsync<TaskCanceledException>(async () => await listTask);

        isDisposed.ShouldBeTrue();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ToLookupTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ToLookupTest
{
    [Fact]
    public async Task ToLookup()
    {
        var publisher = new Subject<KeyValuePair<int, string>>();

        var task = publisher.ToLookupAsync(static x => x.Key);

        publisher.OnNext(new (1, "a"));
        publisher.OnNext(new (2, "b"));
        publisher.OnNext(new (3, "c"));

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();
        task.Status.ShouldBe(TaskStatus.RanToCompletion);

        var expected = new Dictionary<int, string>
        {
            [1] = "a",
            [2] = "b",
            [3] = "c"
        }
        .ToLookup(static x => x.Key);

        (await task).ShouldBe(expected);
    }

    [Fact]
    public async Task ToLookupWithElementSelector()
    {
        var publisher = new Subject<(int, string)>();

        var task = publisher.ToLookupAsync(static x => x.Item1, static x => x.Item2.ToUpperInvariant());

        publisher.OnNext((1, "a"));
        publisher.OnNext((2, "b"));
        publisher.OnNext((3, "c"));

        task.Status.ShouldBe(TaskStatus.WaitingForActivation);

        publisher.OnCompleted();

        task.Status.ShouldBe(TaskStatus.RanToCompletion);

        var expected = new Dictionary<int, string>
        {
            [1] = "A",
            [2] = "B",
            [3] = "C"
        }
        .ToLookup(static x => x.Key, static x => x.Value);

        (await task).ShouldBe(expected);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/TrampolineTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace R3.Tests.OperatorTests;

public class TrampolineTest
{
    [Fact]
    public void NonTrampoline()
    {
        var sender = new Subject<string>();
        var receiver = sender.Share();

        var log = new List<string>();

        // A
        receiver.Subscribe(x =>
        {
            log.Add($"A : {x}");
            if (x == "OnPlayerJoined") sender.OnNext("OnPlayerAddTeam");
        });

        // B
        receiver.Subscribe(x => log.Add($"B : {x}"));

        // C
        receiver.Subscribe(x => log.Add($"C : {x}"));

        sender.OnNext("OnPlayerJoined");

        var msg = string.Join(Environment.NewLine, log);

        msg.ShouldBe("""
A : OnPlayerJoined
A : OnPlayerAddTeam
B : OnPlayerAddTeam
C : OnPlayerAddTeam
B : OnPlayerJoined
C : OnPlayerJoined
""");
    }

    [Fact]
    public void Trampoline()
    {
        var sender = new Subject<string>();
        var receiver = sender.Trampoline().Share();

        var log = new List<string>();

        // A
        receiver.Subscribe(x =>
        {
            log.Add($"A : {x}");
            if (x == "OnPlayerJoined") sender.OnNext("OnPlayerAddTeam");
        });

        // B
        receiver.Subscribe(x => log.Add($"B : {x}"));

        // C
        receiver.Subscribe(x => log.Add($"C : {x}"));

        sender.OnNext("OnPlayerJoined");

        var msg = string.Join(Environment.NewLine, log);

        msg.ShouldBe("""
A : OnPlayerJoined
B : OnPlayerJoined
C : OnPlayerJoined
A : OnPlayerAddTeam
B : OnPlayerAddTeam
C : OnPlayerAddTeam
""");
    }


    [Fact]
    public void TrampolineIsReusable()
    {
        var sender = new Subject<string>();
        var receiver = sender.Trampoline().Share();

        var log = new List<string>();

        // A
        receiver.Subscribe(x =>
        {
            log.Add(x);
            if (x == "OnPlayerJoined") sender.OnNext("OnPlayerAddTeam");
        });

        sender.OnNext("OnPlayerJoined");

        var msg = string.Join(Environment.NewLine, log);

        msg.ShouldBe("""
                        OnPlayerJoined
                        OnPlayerAddTeam
                        """);

        // reset logs
        log.Clear();

        // send again
        sender.OnNext("OnPlayerJoined");

        msg = string.Join(Environment.NewLine, log);
        msg.ShouldBe("""
                        OnPlayerJoined
                        OnPlayerAddTeam
                        """);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/WaitTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class WaitTest
{
    [Fact]
    public async Task AnyValues()
    {
        var source = new int[] { 1, 10, 1, 3, 4, 6, 7, 4 }.ToObservable();
        await source.WaitAsync();

        var p = new Subject<int>();
        var task = p.WaitAsync();

        p.OnNext(10);
        p.OnNext(20);
        p.OnNext(30);
        p.OnCompleted();

        await task;
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/WhereAwaitTest.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace R3.Tests.OperatorTests;

public class WhereAwaitTest
{
    [Fact]
    public void Sequential()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.Sequential)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        subject.OnNext(3);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void Drop()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.Drop)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        Thread.Sleep(100);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        subject.OnNext(3);
        subject.OnNext(4);
        subject.OnNext(5);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(2);
        Thread.Sleep(100);
        liveList.AssertEqual([100, 300]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void Parallel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.Parallel)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 300]);

        subject.OnNext(4);
        subject.OnNext(5);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 300, 500]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void Switch()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.Switch)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3); // 1, 2 is canceled.

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([300]);

        timeProvider.Advance(2);
        liveList.AssertEqual([300]);

        subject.OnNext(5);

        timeProvider.Advance(1);
        liveList.AssertEqual([300]);

        timeProvider.Advance(3);
        liveList.AssertEqual([300, 500]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void SequentialParallel()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(x), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.SequentialParallel)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(2); // 2 seconds wait
        subject.OnNext(1); // 1 seconds wait
        subject.OnNext(3); // 3 seconds wait
        subject.OnNext(7); // 7 seconds wait
        subject.OnNext(5); // 5 seconds wait

        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(2);

        liveList.AssertEqual([100, 300, 700, 500]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void ParallelLimit()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.Parallel, cancelOnCompleted: false, maxConcurrent: 2)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);

        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100, 300]);


        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);

        subject.OnCompleted();

        timeProvider.Advance(1);
        timeProvider.Advance(2);
        timeProvider.Advance(3);
        liveList.AssertEqual([100, 300, 100, 300]);

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void SequentialParallelLimit()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(x), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.SequentialParallel, maxConcurrent: 3)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(2); // 2 seconds wait
        subject.OnNext(1); // 1 seconds wait
        subject.OnNext(3); // 3 seconds wait
        subject.OnNext(7); // 7 seconds wait
        subject.OnNext(5); // 5 seconds wait

        liveList.AssertEqual([]);

        timeProvider.Advance(2); // deq 3, 7
        liveList.AssertEqual([100]);

        timeProvider.Advance(1); // deq 5
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(2);
        liveList.AssertEqual([100, 300]);

        timeProvider.Advance(4);
        liveList.AssertEqual([100, 300, 700, 500]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

    [Fact]
    public void ThrottleFirstLast()
    {
        SynchronizationContext.SetSynchronizationContext(null); // xUnit insert fucking SynchronizationContext so ignore it.

        var subject = new Subject<int>();
        var timeProvider = new FakeTimeProvider();

        using var liveList = subject
            .WhereAwait(async (x, ct) =>
            {
                await Task.Delay(TimeSpan.FromSeconds(3), timeProvider, ct);
                return x % 2 != 0;
            }, AwaitOperation.ThrottleFirstLast)
            .Select(x => x * 100)
            .ToLiveList();

        subject.OnNext(1);
        subject.OnNext(2);
        subject.OnNext(3);
        subject.OnNext(4);
        subject.OnNext(5);
        liveList.AssertEqual([]);

        timeProvider.Advance(2);
        liveList.AssertEqual([]);

        timeProvider.Advance(1);
        liveList.AssertEqual([100]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100,500]);

        subject.OnNext(6);
        subject.OnNext(7);
        subject.OnNext(8);
        subject.OnNext(9);
        subject.OnNext(10);
        subject.OnNext(11);

        timeProvider.Advance(3);
        liveList.AssertEqual([100,500]);

        timeProvider.Advance(3);
        liveList.AssertEqual([100,500,1100]);

        subject.OnCompleted();

        liveList.AssertIsCompleted();
    }

}



================================================
FILE: tests/R3.Tests/OperatorTests/WhereNotNullTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class WhereNotNullTest(ITestOutputHelper output)
{
    [Fact]
    public void WhereNotNull()
    {
        var p = new Subject<string?>();

        using var list = p.WhereNotNull().ToLiveList();

        p.OnNext(null);
        list.AssertEqual([]);

        p.OnNext("foo");
        list.AssertEqual(["foo"]);

        p.OnNext(null);
        list.AssertEqual(["foo"]);

        p.OnNext("bar");
        list.AssertEqual(["foo", "bar"]);
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/WhereTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class WhereTest(ITestOutputHelper output)
{
    // test WhereWhere optimize
    [Fact]
    public void WhereWhere()
    {
        var p = new Subject<int>();

        using var list = p.Where(x => x % 2 != 0).Where(x => x % 3 != 0).ToLiveList();

        p.OnNext(2);
        list.AssertEqual([]);

        p.OnNext(1);
        list.AssertEqual([1]);

        p.OnNext(3);
        list.AssertEqual([1]);

        p.OnNext(5);
        list.AssertEqual([1, 5]);

        p.OnNext(6);
        list.AssertEqual([1, 5]);

        p.OnNext(7);
        list.AssertEqual([1, 5, 7]);
    }


    // test where completable
    [Fact]
    public void WhereCompletable()
    {
        var p = new Subject<int>();

        using var list = p.Where(x => x % 2 != 0).ToLiveList();

        p.OnNext(2);
        list.AssertEqual([]);

        p.OnNext(1);
        list.AssertEqual([1]);

        p.OnNext(3);
        list.AssertEqual([1, 3]);

        p.OnNext(30);
        list.AssertEqual([1, 3]);

        list.AssertIsNotCompleted();

        p.OnCompleted(default);

        list.AssertIsCompleted();
    }


    // test where completable indexed
    [Fact]
    public void WhereCompletableIndexed()
    {
        var p = new Subject<int>();

        using var list = p.Where((x, i) => i % 2 != 0).ToLiveList();

        p.OnNext(2);
        list.AssertEqual([]);

        p.OnNext(1);
        list.AssertEqual([1]);

        p.OnNext(3);
        list.AssertEqual([1]);

        p.OnNext(5);
        list.AssertEqual([1, 5]);

        p.OnNext(6);
        list.AssertEqual([1, 5]);

        p.OnNext(8);
        list.AssertEqual([1, 5, 8]);

        list.AssertIsNotCompleted();

        p.OnCompleted(default);

        list.AssertIsCompleted();
    }

    // test where with state
    [Fact]
    public void WhereState()
    {
        var p = new Subject<int>();

        var state = new { x = 2, y = 0 };
        using var list = p.Where(state, static (x, s) => x % s.x != s.y).ToLiveList();

        p.OnNext(2);
        list.AssertEqual([]);

        p.OnNext(1);
        list.AssertEqual([1]);

        p.OnNext(3);
        list.AssertEqual([1, 3]);

        p.OnNext(30);
        list.AssertEqual([1, 3]);

        list.AssertIsNotCompleted();

        p.OnCompleted(default);

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/WithLatestFromTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class WithLatestFromTest
{
    [Fact]
    public void WithLatestFrom()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<string>();

        using var list = source1.WithLatestFrom(source2, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);

        list.AssertEmpty();

        source1.OnNext(2);

        list.AssertEmpty();

        source2.OnNext("a");

        list.AssertEmpty();

        source1.OnNext(3);

        list.AssertEqual([(3, "a")]);

        source2.OnNext("b");

        list.AssertEqual([(3, "a")]);

        source2.OnNext("c");

        list.AssertEqual([(3, "a")]);

        source1.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ZipLatestTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ZipLatestTest
{
    [Fact]
    public void ZipLatest()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<string>();

        using var list = source1.ZipLatest(source2, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);

        list.AssertEmpty();

        source1.OnNext(2);

        list.AssertEmpty();

        source2.OnNext("a");

        list.AssertEqual([(2, "a")]);

        source1.OnNext(3);

        list.AssertEqual([(2, "a")]);

        source2.OnNext("b");

        list.AssertEqual([(2, "a"), (3, "b")]);

        source2.OnNext("c");

        list.AssertEqual([(2, "a"), (3, "b")]);

        source1.OnCompleted();

        list.AssertIsCompleted();
    }


    [Fact]
    public void ZipLatestCompletedCheck1()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual((1, 10, 100));

        source2.OnNext(20);
        source3.OnNext(200);
        source1.OnCompleted(); // no latest oncompleted immediately

        list.AssertIsCompleted();
    }

    [Fact]
    public void ZipLatestCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual((1, 10, 100));

        source1.OnNext(2);
        source1.OnNext(3);
        source1.OnCompleted(); // still exists value(3)

        list.AssertIsNotCompleted();

        source2.OnNext(20);
        source2.OnNext(30);
        source2.OnNext(40); // 40

        source3.OnNext(200); // 200 and flush, no more value
        list.AssertEqual((1, 10, 100), (3, 40, 200));

        list.AssertIsCompleted();
    }

    [Fact]
    public void ZipLatestCompletedCheck3()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);

        source1.OnCompleted(); // still exists values but completed all
        source2.OnCompleted();
        source3.OnCompleted();

        list.AssertIsCompleted();
    }



    [Fact]
    public void NthZipLatestCompletedCheck1()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        source2.OnNext(20);
        source3.OnNext(200);
        source1.OnCompleted(); // no latest oncompleted immediately

        list.AssertIsCompleted();
    }

    [Fact]
    public void NthZipLatestCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        source1.OnNext(2);
        source1.OnNext(3);
        source1.OnCompleted(); // still exists value(3)

        list.AssertIsNotCompleted();

        source2.OnNext(20);
        source2.OnNext(30);
        source2.OnNext(40); // 40

        source3.OnNext(200); // 200 and flush, no more value
        list.AssertEqual([1, 10, 100], [3, 40, 200]);

        list.AssertIsCompleted();
    }

    [Fact]
    public void NthZipLatestCompletedCheck3()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.ZipLatest(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);

        source1.OnCompleted(); // still exists values but completed all
        source2.OnCompleted();
        source3.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: tests/R3.Tests/OperatorTests/ZipTest.cs
================================================
﻿namespace R3.Tests.OperatorTests;

public class ZipTest
{
    [Fact]
    public void Zip()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<string>();

        using var list = source1.Zip(source2, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);

        list.AssertEmpty();

        source1.OnNext(2);

        list.AssertEmpty();

        source2.OnNext("a");

        list.AssertEqual([(1, "a")]);

        source1.OnNext(3);

        list.AssertEqual([(1, "a")]);

        source2.OnNext("b");

        list.AssertEqual([(1, "a"), (2, "b")]);

        source2.OnNext("c");

        list.AssertEqual([(1, "a"), (2, "b"), (3, "c")]);

        source1.OnCompleted();

        list.AssertIsCompleted();
    }


    [Fact]
    public void ZipCompletedCheck1()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual((1, 10, 100));

        source2.OnNext(20);
        source3.OnNext(200);
        source1.OnCompleted(); // no queue oncompleted immediately

        list.AssertIsCompleted();
    }

    [Fact]
    public void ZipCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual((1, 10, 100));

        source1.OnNext(2);
        source1.OnNext(3);
        source1.OnCompleted(); // still exists in queue

        list.AssertIsNotCompleted();

        source2.OnNext(20);
        source2.OnNext(30);
        source2.OnNext(40);

        source3.OnNext(200);
        list.AssertEqual((1, 10, 100), (2, 20, 200));

        source3.OnNext(300);
        list.AssertEqual((1, 10, 100), (2, 20, 200), (3, 30, 300)); // source1 queue is empty, call complete

        list.AssertIsCompleted();
    }

    [Fact]
    public void ZipCompletedCheck3()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3, ValueTuple.Create).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        
        source1.OnCompleted(); // still exists in queue but completed all
        source2.OnCompleted();
        source3.OnCompleted();

        list.AssertIsCompleted();
    }

    [Fact]
    public void NthZipCompletedCheck1()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        source2.OnNext(20);
        source3.OnNext(200);
        source1.OnCompleted(); // no queue oncompleted immediately

        list.AssertIsCompleted();
    }

    [Fact]
    public void NthZipCompletedCheck2()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);
        list.AssertEqual([1, 10, 100]);

        source1.OnNext(2);
        source1.OnNext(3);
        source1.OnCompleted(); // still exists in queue

        list.AssertIsNotCompleted();

        source2.OnNext(20);
        source2.OnNext(30);
        source2.OnNext(40);

        source3.OnNext(200);
        list.AssertEqual([1, 10, 100], [2, 20, 200]);

        source3.OnNext(300);
        list.AssertEqual([1, 10, 100], [2, 20, 200], [3, 30, 300]); // source1 queue is empty, call complete

        list.AssertIsCompleted();
    }

    [Fact]
    public void NthZipCompletedCheck3()
    {
        var source1 = new Subject<int>();
        var source2 = new Subject<int>();
        var source3 = new Subject<int>();

        using var list = Observable.Zip(source1, source2, source3).ToLiveList();

        source1.OnNext(1);
        source2.OnNext(10);
        source3.OnNext(100);

        source1.OnCompleted(); // still exists in queue but completed all
        source2.OnCompleted();
        source3.OnCompleted();

        list.AssertIsCompleted();
    }
}



================================================
FILE: .github/dependabot.yaml
================================================
# ref: https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly" # Check for updates to GitHub Actions every week
    cooldown:
      default-days: 14 # Wait 14 days before creating another PR for the same dependency. This will prevent vulnerability on the package impact.
    ignore:
      # I just want update action when major/minor version is updated. patch updates are too noisy.
      - dependency-name: "*"
        update-types:
          - version-update:semver-patch



================================================
FILE: .github/FUNDING.yml
================================================
github: [neuecc]


================================================
FILE: .github/workflows/build-debug.yaml
================================================
name: Build-Debug

on:
  push:
    branches:
      - "main"
  pull_request:
    branches:
      - "main"

jobs:
  build-dotnet:
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - uses: Cysharp/Actions/.github/actions/checkout@main
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Release
      - run: dotnet test -c Release --no-build
      # need build. don't use --no-build
      - run: dotnet pack -c Release -p:IncludeSymbols=true -p:SymbolPackageFormat=snupkg -o $GITHUB_WORKSPACE/artifacts



================================================
FILE: .github/workflows/build-release.yaml
================================================
name: Build-Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "tag: git tag you want create. (sample 1.0.0)"
        required: true
      dry-run:
        description: "dry-run: true will never create relase/nuget."
        required: true
        default: false
        type: boolean

jobs:
  update-packagejson:
    permissions:
      actions: read
      contents: write
    uses: Cysharp/Actions/.github/workflows/update-packagejson.yaml@main
    with:
      file-path: |
        ./src/R3.Unity/Assets/R3.Unity/package.json
        ./src/R3.Godot/addons/R3.Godot/plugin.cfg
      dotnet-run-path: ./sandbox/ReferenceBuilder/ReferenceBuilder.csproj
      tag: ${{ inputs.tag }}
      dry-run: ${{ inputs.dry-run }}

  build-dotnet:
    needs: [update-packagejson]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - uses: Cysharp/Actions/.github/actions/checkout@main
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Release -p:Version=${{ inputs.tag }}
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release -p:Version=${{ inputs.tag }} -o ./publish
      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: nuget
          path: ./publish/
          retention-days: 1

  # release
  create-release:
    needs: [update-packagejson, build-dotnet]
    permissions:
      contents: write
      id-token: write # required for NuGet Trusted Publish
    uses: Cysharp/Actions/.github/workflows/create-release.yaml@main
    with:
      commit-id: ${{ needs.update-packagejson.outputs.sha }}
      dry-run: ${{ inputs.dry-run }}
      tag: ${{ inputs.tag }}
      nuget-push: true
      release-upload: false
    secrets: inherit

  cleanup:
    if: ${{ needs.update-packagejson.outputs.is-branch-created == 'true' }}
    needs: [update-packagejson, build-dotnet]
    permissions:
      contents: write
    uses: Cysharp/Actions/.github/workflows/clean-packagejson-branch.yaml@main
    with:
      branch: ${{ needs.update-packagejson.outputs.branch-name }}



================================================
FILE: .github/workflows/stale.yaml
================================================
name: "Close stale issues"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

jobs:
  stale:
    permissions:
      contents: read
      pull-requests: write
      issues: write
    uses: Cysharp/Actions/.github/workflows/stale-issue.yaml@main


