Directory structure:
└── fmod-fmod-for-unity/
    ├── README.md
    ├── LICENSE
    └── Assets/
        └── Plugins/
            ├── FMOD.meta
            └── FMOD/
                ├── README.txt
                ├── README.txt.meta
                ├── addons.meta
                ├── FMODUnity.asmdef
                ├── FMODUnity.asmdef.meta
                ├── images.meta
                ├── LICENSE.TXT.meta
                ├── platform_ios.mm
                ├── platform_ios.mm.meta
                ├── platforms.meta
                ├── src.meta
                ├── addons/
                │   ├── Haptics.meta
                │   ├── ResonanceAudio.meta
                │   ├── Haptics/
                │   │   ├── Scripts.meta
                │   │   └── Scripts/
                │   │       ├── FMODHaptics.cs
                │   │       ├── FMODHaptics.cs.meta
                │   │       ├── FMODUnityHaptics.asmdef
                │   │       └── FMODUnityHaptics.asmdef.meta
                │   └── ResonanceAudio/
                │       ├── Editor.meta
                │       ├── Scripts.meta
                │       ├── Editor/
                │       │   ├── FmodResonanceAudioRoomEditor.cs
                │       │   ├── FmodResonanceAudioRoomEditor.cs.meta
                │       │   ├── FMODUnityResonanceEditor.asmdef
                │       │   ├── FMODUnityResonanceEditor.asmdef.meta
                │       │   ├── Localization.cs
                │       │   ├── Localization.cs.meta
                │       │   ├── zh_hans.po
                │       │   └── zh_hans.po.meta
                │       └── Scripts/
                │           ├── FmodResonanceAudio.cs
                │           ├── FmodResonanceAudio.cs.meta
                │           ├── FmodResonanceAudioRoom.cs
                │           ├── FmodResonanceAudioRoom.cs.meta
                │           ├── FMODUnityResonance.asmdef
                │           └── FMODUnityResonance.asmdef.meta
                ├── images/
                │   ├── AddIcon.png.meta
                │   ├── ArrowIcon.png.meta
                │   ├── BankIcon.png.meta
                │   ├── Border.png.meta
                │   ├── BrowserIcon.png.meta
                │   ├── ContinuousParameterIcon.png.meta
                │   ├── CopyIcon.png.meta
                │   ├── CrossYellow.png.meta
                │   ├── Delete.png.meta
                │   ├── DiscreteParameterIcon.png.meta
                │   ├── EventIcon.png.meta
                │   ├── FMODLogoBlack.png.meta
                │   ├── FMODLogoWhite.png.meta
                │   ├── FolderIconClosed.png.meta
                │   ├── FolderIconOpen.png.meta
                │   ├── LabeledParameterIcon.png.meta
                │   ├── LevelMeter.png.meta
                │   ├── LevelMeterOff.png.meta
                │   ├── NotFound.png.meta
                │   ├── Preview.png.meta
                │   ├── PreviewEmitter.png.meta
                │   ├── SearchIconBlack.png.meta
                │   ├── SelectedAlt.png.meta
                │   ├── SnapshotIcon.png.meta
                │   ├── StudioIcon.png.meta
                │   ├── TickGreen.png.meta
                │   ├── TransportOpen.png.meta
                │   ├── TransportPlayButtonOff.png.meta
                │   ├── TransportPlayButtonOn.png.meta
                │   ├── TransportStopButtonOff.png.meta
                │   ├── TransportStopButtonOn.png.meta
                │   └── Wrench.png.meta
                ├── platforms/
                │   ├── android.meta
                │   ├── html5.meta
                │   ├── ios.meta
                │   ├── linux.meta
                │   ├── mac.meta
                │   ├── tvos.meta
                │   ├── uwp.meta
                │   ├── visionos.meta
                │   ├── win.meta
                │   ├── android/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformAndroid.cs
                │   │       └── PlatformAndroid.cs.meta
                │   ├── html5/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformWebGL.cs
                │   │       └── PlatformWebGL.cs.meta
                │   ├── ios/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformIOS.cs
                │   │       └── PlatformIOS.cs.meta
                │   ├── linux/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformLinux.cs
                │   │       └── PlatformLinux.cs.meta
                │   ├── mac/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformMac.cs
                │   │       └── PlatformMac.cs.meta
                │   ├── tvos/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformAppleTV.cs
                │   │       └── PlatformAppleTV.cs.meta
                │   ├── visionos/
                │   │   ├── src.meta
                │   │   └── src/
                │   │       ├── PlatformVisionOS.cs
                │   │       └── PlatformVisionOS.cs.meta
                │   └── win/
                │       ├── src.meta
                │       └── src/
                │           ├── PlatformWindows.cs
                │           └── PlatformWindows.cs.meta
                └── src/
                    ├── AutomatableSlots.cs
                    ├── AutomatableSlots.cs.meta
                    ├── BankRefAttribute.cs
                    ├── BankRefAttribute.cs.meta
                    ├── Editor.meta
                    ├── EventHandler.cs
                    ├── EventHandler.cs.meta
                    ├── EventRefAttribute.cs
                    ├── EventRefAttribute.cs.meta
                    ├── EventReference.cs
                    ├── EventReference.cs.meta
                    ├── fmod.cs.meta
                    ├── fmod_dsp.cs
                    ├── fmod_dsp.cs.meta
                    ├── fmod_errors.cs
                    ├── fmod_errors.cs.meta
                    ├── fmod_studio.cs.meta
                    ├── FMODEventPlayable.cs
                    ├── FMODEventPlayable.cs.meta
                    ├── FMODEventTrack.cs
                    ├── FMODEventTrack.cs.meta
                    ├── FMODRuntimeManagerOnGUIHelper.cs
                    ├── FMODRuntimeManagerOnGUIHelper.cs.meta
                    ├── ParamRef.cs
                    ├── ParamRef.cs.meta
                    ├── ParamRefAttribute.cs
                    ├── ParamRefAttribute.cs.meta
                    ├── Platform.cs
                    ├── Platform.cs.meta
                    ├── PlatformDefault.cs
                    ├── PlatformDefault.cs.meta
                    ├── PlatformGroup.cs
                    ├── PlatformGroup.cs.meta
                    ├── PlatformMobileHigh.cs
                    ├── PlatformMobileHigh.cs.meta
                    ├── PlatformMobileLow.cs
                    ├── PlatformMobileLow.cs.meta
                    ├── PlatformPlayInEditor.cs
                    ├── PlatformPlayInEditor.cs.meta
                    ├── RuntimeManager.cs.meta
                    ├── RuntimeUtils.cs
                    ├── RuntimeUtils.cs.meta
                    ├── Settings.cs
                    ├── Settings.cs.meta
                    ├── StudioBankLoader.cs
                    ├── StudioBankLoader.cs.meta
                    ├── StudioEventEmitter.cs
                    ├── StudioEventEmitter.cs.meta
                    ├── StudioGlobalParameterTrigger.cs
                    ├── StudioGlobalParameterTrigger.cs.meta
                    ├── StudioListener.cs
                    ├── StudioListener.cs.meta
                    ├── StudioParameterTrigger.cs
                    ├── StudioParameterTrigger.cs.meta
                    └── Editor/
                        ├── BankRefDrawer.cs
                        ├── BankRefDrawer.cs.meta
                        ├── BankRefresher.cs
                        ├── BankRefresher.cs.meta
                        ├── BankRefreshWindow.cs
                        ├── BankRefreshWindow.cs.meta
                        ├── BoltIntegration.cs
                        ├── BoltIntegration.cs.meta
                        ├── CodeGeneration.cs
                        ├── CodeGeneration.cs.meta
                        ├── CreateEventPopup.cs
                        ├── CreateEventPopup.cs.meta
                        ├── EditorBankRef.cs
                        ├── EditorBankRef.cs.meta
                        ├── EditorEventRef.cs
                        ├── EditorEventRef.cs.meta
                        ├── EditorParamRef.cs
                        ├── EditorParamRef.cs.meta
                        ├── EditorSettings.cs
                        ├── EditorSettings.cs.meta
                        ├── EditorUtils.cs.meta
                        ├── EventBrowser.cs.meta
                        ├── EventCache.cs
                        ├── EventCache.cs.meta
                        ├── EventManager.cs.meta
                        ├── EventRefDrawer.cs
                        ├── EventRefDrawer.cs.meta
                        ├── EventReferenceUpdater.cs.meta
                        ├── FileReorganizer.cs
                        ├── FileReorganizer.cs.meta
                        ├── FindAndReplace.cs
                        ├── FindAndReplace.cs.meta
                        ├── FMODEventPlayableEditor.cs
                        ├── FMODEventPlayableEditor.cs.meta
                        ├── FMODEventTrackEditor.cs
                        ├── FMODEventTrackEditor.cs.meta
                        ├── FMODUnityEditor.asmdef
                        ├── FMODUnityEditor.asmdef.meta
                        ├── ListView.cs
                        ├── ListView.cs.meta
                        ├── Localization.cs
                        ├── Localization.cs.meta
                        ├── ParamRefDrawer.cs
                        ├── ParamRefDrawer.cs.meta
                        ├── SettingsEditor.cs.meta
                        ├── SetupWizard.cs
                        ├── SetupWizard.cs.meta
                        ├── StudioBankLoaderEditor.cs
                        ├── StudioBankLoaderEditor.cs.meta
                        ├── StudioEventEmitterEditor.cs
                        ├── StudioEventEmitterEditor.cs.meta
                        ├── StudioEventEmitterGizmoDrawer.cs
                        ├── StudioEventEmitterGizmoDrawer.cs.meta
                        ├── StudioGlobalParameterTriggerEditor.cs
                        ├── StudioGlobalParameterTriggerEditor.cs.meta
                        ├── StudioListenerEditor.cs
                        ├── StudioListenerEditor.cs.meta
                        ├── StudioParameterTriggerEditor.cs
                        ├── StudioParameterTriggerEditor.cs.meta
                        ├── zh_hans.po
                        └── zh_hans.po.meta

================================================
FILE: README.md
================================================
# FMOD For Unity

This repository contains the source code for the FMOD Studio Unity integration, excluding any platforms that require a non-disclosure agreement (such as Xbox). Additionally, native binaries for all platforms have been removed and must be acquired from a built Unity package. Developers can use this repository to track changes, report issues or submit modifications.

* Packages which include binaries can be downloaded from the Unity [asset store](https://assetstore.unity.com/packages/tools/audio/fmod-for-unity-161631) or the FMOD [download page](https://fmod.com/download#unityintegration).
* For getting started information, up-to-date documentation and compatibility details check the FMOD For Unity [documentation site](https://fmod.com/docs/2.03/unity).
* Free support is available on the FMOD [forums](https://qa.fmod.com/c/unity) for all users, paid / licensed support available by email.



================================================
FILE: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2016 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: Assets/Plugins/FMOD.meta
================================================
fileFormatVersion: 2
guid: 06ae579381df01a4a87bb149dec89954
folderAsset: yes
timeCreated: 1429061260
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/README.txt
================================================
Welcome to FMOD for Unity

This package allows you to easily play back audio events created in FMOD Studio
within your Unity project.

The best place to start is with our online documentation:
https://fmod.com/docs/2.03/unity

If you prefer a more step-by-step guide, try our integration tutorial that
builds on the familiar Karting Microgame:
https://fmod.com/unity-integrate

For support, join the conversation on our Unity forums:
https://qa.fmod.com/c/unity



================================================
FILE: Assets/Plugins/FMOD/README.txt.meta
================================================
fileFormatVersion: 2
guid: 081074d1d9d6ab448b88688c3730e8a1
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons.meta
================================================
fileFormatVersion: 2
guid: 850b7bf08237b964b8b005fe703774f9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/FMODUnity.asmdef
================================================
{
    "name": "FMODUnity",
    "references": [
        "Unity.Timeline",
        "Unity.Addressables",
        "Unity.ResourceManager",
        "Unity.RenderPipelines.Universal.Runtime"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [
        "UNITY_2021_3_OR_NEWER"
    ],
    "versionDefines": [
        {
            "name": "com.unity.timeline",
            "expression": "1.0.0",
            "define": "UNITY_TIMELINE_EXIST"
        },
        {
            "name": "com.unity.addressables",
            "expression": "1.0.0",
            "define": "UNITY_ADDRESSABLES_EXIST"
        },
        {
            "name": "com.unity.modules.physics",
            "expression": "1.0.0",
            "define": "UNITY_PHYSICS_EXIST"
        },
        {
            "name": "com.unity.modules.physics2d",
            "expression": "1.0.0",
            "define": "UNITY_PHYSICS2D_EXIST"
        },
        {
            "name": "com.unity.urp",
            "expression": "1.0.0",
            "define": "UNITY_URP_EXIST"
        },
        {
            "name": "com.unity.ugui",
            "expression": "1.0.0",
            "define": "UNITY_UI_EXIST"
        }
    ],
    "noEngineReferences": false
}


================================================
FILE: Assets/Plugins/FMOD/FMODUnity.asmdef.meta
================================================
fileFormatVersion: 2
guid: 0c752da273b17c547ae705acf0f2adf2
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images.meta
================================================
fileFormatVersion: 2
guid: 27e5eef2bd66ffe429eebdc4579b7231
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/LICENSE.TXT.meta
================================================
fileFormatVersion: 2
guid: d3ac3a44335d5564aaec902413595287
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platform_ios.mm
================================================
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>

static void (*gSuspendCallback)(bool suspend) = nullptr;
static bool gIsSuspended = false;
static bool gNeedsReset = false;

extern "C" void RegisterSuspendCallback(void (*callback)(bool))
{
    if (gSuspendCallback || !callback)
    {
        return;
    }
    gSuspendCallback = callback;

    [[NSNotificationCenter defaultCenter] addObserverForName:AVAudioSessionInterruptionNotification object:nil queue:nil usingBlock:^(NSNotification *notification)
    {
        AVAudioSessionInterruptionType type = (AVAudioSessionInterruptionType)[[notification.userInfo valueForKey:AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];
        if (type == AVAudioSessionInterruptionTypeBegan)
        {
            NSLog(@"Interruption Began");
            // Ignore deprecated warnings regarding AVAudioSessionInterruptionReasonAppWasSuspended and
            // AVAudioSessionInterruptionWasSuspendedKey, we protect usage for the versions where they are available
            #pragma clang diagnostic push
            #pragma clang diagnostic ignored "-Wdeprecated-declarations"

            // If the audio session was deactivated while the app was in the background, the app receives the
            // notification when relaunched. Identify this reason for interruption and ignore it.
            if (@available(iOS 16.0, tvOS 14.5, *))
            {
                // Delayed suspend-in-background notifications no longer exist, this must be a real interruption
            }
            #if !TARGET_OS_TV // tvOS never supported "AVAudioSessionInterruptionReasonAppWasSuspended"
            else if (@available(iOS 14.5, *))
            {
                if ([[notification.userInfo valueForKey:AVAudioSessionInterruptionReasonKey] intValue] == AVAudioSessionInterruptionReasonAppWasSuspended)
                {
                    return; // Ignore delayed suspend-in-background notification
                }
            }
            #endif
            else
            {
                if ([[notification.userInfo valueForKey:AVAudioSessionInterruptionWasSuspendedKey] boolValue])
                {
                    return; // Ignore delayed suspend-in-background notification
                }
            }

            gSuspendCallback(true);
            gIsSuspended = true;

            #pragma clang diagnostic pop
        }
        else if (type == AVAudioSessionInterruptionTypeEnded)
        {
            NSLog(@"Interruption Ended");
            NSError *errorMessage = nullptr;
            if (![[AVAudioSession sharedInstance] setActive:TRUE error:&errorMessage])
            {
                // Interruption like Siri can prevent session activation, wait for did-become-active notification
                NSLog(@"AVAudioSessionInterruptionNotification: AVAudioSession.setActive() failed: %@", errorMessage);
                return;
            }

            gSuspendCallback(false);
            gIsSuspended = false;
        }
    }];

    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification object:nil queue:nil usingBlock:^(NSNotification *notification)
    {
        // Unity video playback prior to 2022.3 on tvOS breaks FMOD audio, so force a reset
        #if TARGET_OS_TV && !UNITY_2022_3_OR_NEWER
        gNeedsReset = true;
        #endif

        if (gNeedsReset)
        {
            gSuspendCallback(true);
            gIsSuspended = true;
        }
        
        NSError *errorMessage = nullptr;
        if (![[AVAudioSession sharedInstance] setActive:TRUE error:&errorMessage])
        {
            if ([errorMessage code] == AVAudioSessionErrorCodeCannotStartPlaying)
            {
                // Interruption like Screen Time can prevent session activation, but will not trigger an interruption-ended notification.
                // There is no other callback or trigger to hook into after this point, we are not in the background and there is no other audio playing.
                // Our only option is to have a sleep loop until the Audio Session can be activated again.
                while (![[AVAudioSession sharedInstance] setActive:TRUE error:nil])
                {
                    usleep(20000);
                }
            }
            else
            {
                // Interruption like Siri can prevent session activation, wait for interruption-ended notification.
                NSLog(@"UIApplicationDidBecomeActiveNotification: AVAudioSession.setActive() failed: %@", errorMessage);
                return;
            }
        }

        // It's possible the system missed sending us an interruption end, so recover here
        if (gIsSuspended)
        {
            gSuspendCallback(false);
            gNeedsReset = false;
            gIsSuspended = false;
        }
    }];

    [[NSNotificationCenter defaultCenter] addObserverForName:AVAudioSessionMediaServicesWereResetNotification object:nil queue:nil usingBlock:^(NSNotification *notification)
    {
        if ([UIApplication sharedApplication].applicationState == UIApplicationStateBackground || gIsSuspended)
        {
            // Received the reset notification while in the background, need to reset the AudioUnit when we come back to foreground.
            gNeedsReset = true;
        }
        else
        {
            // In the foregound but something chopped the media services, need to do a reset.
            gSuspendCallback(true);
            gSuspendCallback(false);
        }
    }];
}



================================================
FILE: Assets/Plugins/FMOD/platform_ios.mm.meta
================================================
fileFormatVersion: 2
guid: fc7eb3c9194584004bdf04921e5cb057
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      '': Any
    second:
      enabled: 0
      settings:
        Exclude Editor: 1
        Exclude Linux: 1
        Exclude Linux64: 1
        Exclude LinuxUniversal: 1
        Exclude OSXUniversal: 1
        Exclude VisionOS: 0
        Exclude WebGL: 1
        Exclude Win: 1
        Exclude Win64: 1
        Exclude iOS: 0
        Exclude tvOS: 0
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
        DefaultValueInitialized: true
        OS: AnyOS
  - first:
      Facebook: Win
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Facebook: Win64
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Linux
    second:
      enabled: 0
      settings:
        CPU: x86
  - first:
      Standalone: Linux64
    second:
      enabled: 0
      settings:
        CPU: x86_64
  - first:
      Standalone: OSXUniversal
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Win
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Win64
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      VisionOS: VisionOS
    second:
      enabled: 1
      settings:
        AddToEmbeddedBinaries: false
        CompileFlags: 
        CPU: AnyCPU
        FrameworkDependencies: 
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings:
        AddToEmbeddedBinaries: false
        CPU: AnyCPU
        CompileFlags: 
        FrameworkDependencies: 
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings:
        CompileFlags: 
        FrameworkDependencies: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms.meta
================================================
fileFormatVersion: 2
guid: 8b617f082dd1f0645bde3b4ff3cbc25a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src.meta
================================================
fileFormatVersion: 2
guid: 2994e348941404549b266423c2ac329f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/Haptics.meta
================================================
fileFormatVersion: 2
guid: bf1b39bdd3c6c1f45a9b5a5d0435ed4e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio.meta
================================================
fileFormatVersion: 2
guid: ce39533effc93ba409e337ba540bf789
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/Haptics/Scripts.meta
================================================
fileFormatVersion: 2
guid: 6dbb069b530ddbe42bed7a146c2f9e46
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/Haptics/Scripts/FMODHaptics.cs
================================================
#if UNITY_OPENXR_EXIST && UNITY_ANDROID
using UnityEngine.XR.OpenXR.Features;
using UnityEngine.XR.OpenXR.NativeTypes;
using UnityEngine.InputSystem;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using FMODUnity;

#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.XR.OpenXR.Features;
#endif

namespace FMODUnityHaptics
{
#if UNITY_EDITOR
    [OpenXRFeature(UiName = displayName,
        BuildTargetGroups = new[] { BuildTargetGroup.Android },
        Company = "FMOD",
        Desc = "OpenXR feature to enable haptics using the fmod_haptics plugin.",
        DocumentationLink = "https://fmod.com/docs/unity",
        OpenxrExtensionStrings = "XR_FB_haptic_pcm",
        Version = "1.0.0",
        FeatureId = featureId)]
#endif
    public class FMODHapticsFeature : OpenXRFeature
    {
        internal const string featureId = "com.fmod.feature.haptic";
        internal const string displayName = "FMOD: Haptics";
        internal const string pluginName = "fmod_haptics";

        private static ulong XrSession;
        private static ulong XrInstance;
        private static ulong XrAction;

        private static InputAction inputAction = null;
        private static InputAction hapticAction = null;

        private static bool configured = false;
#if UNITY_EDITOR
        protected override void GetValidationChecks(List<ValidationRule> results, BuildTargetGroup targetGroup)
        {
            if (targetGroup == BuildTargetGroup.Android)
            {
                results.Add(new ValidationRule(this)
                {
                    message = "FMOD Unity Settings require the fmod_haptics plugin.",
                    error = true,
                    checkPredicate = () => Settings.Instance.Platforms.Find(p => p.Plugins.Contains(pluginName)) != null
                    && Settings.Instance.DefaultPlatform.Plugins.Contains(pluginName)
                    && Settings.Instance.PlayInEditorPlatform.Plugins.Contains(pluginName),
                    fixIt = () =>
                    {
                        var platforms = Settings.Instance.Platforms.FindAll(p => !p.Plugins.Contains(pluginName));
                        platforms.ForEach(p =>
                        {
                            if (!p.Plugins.Contains(pluginName))
                            {
                                p.Plugins.Add(pluginName);
                            }
                        });
                    }
                });
            }
        }
#endif

        protected override bool OnInstanceCreate(ulong xrInstance)
        {
            XrInstance = xrInstance;
            return true;
        }

        protected override void OnInstanceDestroy(ulong xrInstance)
        {
            if (hapticAction != null)
            {
                hapticAction.Disable();
                hapticAction.Dispose();
                hapticAction = null;
            }

            if (inputAction != null)
            {
                inputAction.Disable();
                inputAction.Dispose();
                inputAction = null;
            }
        }

        protected override void OnSessionStateChange(int oldState, int newState)
        {
            if (newState == (int)XrSessionState.Focused)
            {
                if (inputAction != null)
                {
                    inputAction.Disable();
                    inputAction.Dispose();
                    inputAction = null;
                }

                if (!configured)
                {
                    inputAction = new InputAction(type: InputActionType.Button, binding: "<XRController>/*");
                    //Defer native initialization until input actions are bound
                    inputAction.performed += context => RefreshConfig();
                    inputAction.Enable();
                }
            }
        }

        protected override void OnSessionBegin(ulong xrSession)
        {
            XrSession = xrSession;
        }

        private void RefreshConfig()
        {
            if (!configured)
            {
                if (hapticAction != null)
                {
                    hapticAction.Dispose();
                }

                // This works for both controllers, not just the RightHand. We just need 'a' haptic action.
                hapticAction = new InputAction(type: InputActionType.PassThrough, binding: "<XRController>{RightHand}/{Haptic}");
                hapticAction.Enable();

                XrAction = GetAction(hapticAction);

                FMOD_Haptics_OpenXrFocused(XrSession, XrInstance, XrAction);
            }
            configured = true;
        }

        [DllImport("libfmod_haptics.so")]
        private static extern FMOD.RESULT FMOD_Haptics_OpenXrFocused(ulong session, ulong instance, ulong actions);
    }
}
#endif


================================================
FILE: Assets/Plugins/FMOD/addons/Haptics/Scripts/FMODHaptics.cs.meta
================================================
fileFormatVersion: 2
guid: 369c18de2bb8eba458fea38b9c7dc289


================================================
FILE: Assets/Plugins/FMOD/addons/Haptics/Scripts/FMODUnityHaptics.asmdef
================================================
{
    "name": "FMODUnityHaptics",
    "references": [
        "FMODUnity",
        "Unity.XR.OpenXR",
        "Unity.InputSystem"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [
        "UNITY_6000_0_OR_NEWER"
    ],
    "versionDefines": [
        {
            "name": "com.unity.xr.openxr",
            "expression": "1.0.0",
            "define": "UNITY_OPENXR_EXIST"
        }
    ],
    "noEngineReferences": false
}



================================================
FILE: Assets/Plugins/FMOD/addons/Haptics/Scripts/FMODUnityHaptics.asmdef.meta
================================================
fileFormatVersion: 2
guid: 9cdf6dc5d95f5b94cba414c3008c5c76
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor.meta
================================================
fileFormatVersion: 2
guid: 93923a20291353a40809350917bab197
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts.meta
================================================
fileFormatVersion: 2
guid: 05a6a02c28ee77a49b6fcadf67aff3b7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/FmodResonanceAudioRoomEditor.cs
================================================
// Copyright 2017 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using UnityEngine;
using UnityEditor;
using System.Collections;
using static FMODUnityResonance.FmodResonanceAudioRoom;

namespace FMODUnityResonance
{
    /// A custom editor for properties on the FmodResonanceAudioRoom script. This appears in the
    /// Inspector window of a FmodResonanceAudioRoom object.
    [CustomEditor(typeof(FmodResonanceAudioRoom))]
    [CanEditMultipleObjects]
    public class FmodResonanceAudioRoomEditor : Editor
    {
        private SerializedProperty leftWall = null;
        private SerializedProperty rightWall = null;
        private SerializedProperty floor = null;
        private SerializedProperty ceiling = null;
        private SerializedProperty backWall = null;
        private SerializedProperty frontWall = null;
        private SerializedProperty reflectivity = null;
        private SerializedProperty reverbGainDb = null;
        private SerializedProperty reverbBrightness = null;
        private SerializedProperty reverbTime = null;
        private SerializedProperty size = null;

        private GUIContent surfaceMaterialsLabel;
        private GUIContent surfaceMaterialLabel;
        private GUIContent reflectivityLabel;
        private GUIContent reverbGainLabel;
        private GUIContent reverbPropertiesLabel;
        private GUIContent reverbBrightnessLabel;
        private GUIContent reverbTimeLabel;
        private GUIContent sizeLabel;

        private static readonly string[] SurfaceMaterialDisplay = new string[] {
            L10n.Tr("Transparent"),
            L10n.Tr("Acoustic Ceiling Tiles"),
            L10n.Tr("Brick Bare"),
            L10n.Tr("Brick Painted"),
            L10n.Tr("Concrete Block Coarse"),
            L10n.Tr("Concrete Block Painted"),
            L10n.Tr("Curtain Heavy"),
            L10n.Tr("Fiberglass Insulation"),
            L10n.Tr("Glass Thin"),
            L10n.Tr("Glass Thick"),
            L10n.Tr("Grass"),
            L10n.Tr("Linoleum On Concrete"),
            L10n.Tr("Marble"),
            L10n.Tr("Metal"),
            L10n.Tr("Parquet On Concrete"),
            L10n.Tr("Plaster Rough"),
            L10n.Tr("Plaster Smooth"),
            L10n.Tr("Plywood Panel"),
            L10n.Tr("Polished Concrete Or Tile"),
            L10n.Tr("Sheetrock"),
            L10n.Tr("Water Or Ice Surface"),
            L10n.Tr("Wood Ceiling"),
            L10n.Tr("Wood Panel"),
        };

        private static readonly int[] SurfaceMaterialValues = new int[] {
            (int)SurfaceMaterial.Transparent,
            (int)SurfaceMaterial.AcousticCeilingTiles,
            (int)SurfaceMaterial.BrickBare,
            (int)SurfaceMaterial.BrickPainted,
            (int)SurfaceMaterial.ConcreteBlockCoarse,
            (int)SurfaceMaterial.ConcreteBlockPainted,
            (int)SurfaceMaterial.CurtainHeavy,
            (int)SurfaceMaterial.FiberglassInsulation,
            (int)SurfaceMaterial.GlassThin,
            (int)SurfaceMaterial.GlassThick,
            (int)SurfaceMaterial.Grass,
            (int)SurfaceMaterial.LinoleumOnConcrete,
            (int)SurfaceMaterial.Marble,
            (int)SurfaceMaterial.Metal,
            (int)SurfaceMaterial.ParquetOnConcrete,
            (int)SurfaceMaterial.PlasterRough,
            (int)SurfaceMaterial.PlasterSmooth,
            (int)SurfaceMaterial.PlywoodPanel,
            (int)SurfaceMaterial.PolishedConcreteOrTile,
            (int)SurfaceMaterial.Sheetrock,
            (int)SurfaceMaterial.WaterOrIceSurface,
            (int)SurfaceMaterial.WoodCeiling,
            (int)SurfaceMaterial.WoodPanel,
        };

        private void OnEnable()
        {
            surfaceMaterialsLabel = new GUIContent(L10n.Tr("Surface Materials"),
            L10n.Tr("Room surface materials to calculate the acoustic properties of the room."));
            surfaceMaterialLabel = new GUIContent(L10n.Tr("Surface Material"),
            L10n.Tr("Surface material used to calculate the acoustic properties of the room."));
            reflectivityLabel = new GUIContent(L10n.Tr("Reflectivity"),
            L10n.Tr("Adjusts what proportion of the direct sound is reflected back by each surface, after an appropriate delay. Reverberation is unaffected by this setting."));
            reverbGainLabel = new GUIContent(L10n.Tr("Gain (dB)"),
            L10n.Tr("Applies a gain adjustment to the reverberation in the room. The default value will leave reverb unaffected."));
            reverbPropertiesLabel = new GUIContent(L10n.Tr("Reverb Properties"),
            L10n.Tr("Parameters to adjust the reverb properties of the room."));
            reverbBrightnessLabel = new GUIContent(L10n.Tr("Brightness"),
            L10n.Tr("Adjusts the balance between high and low frequencies in the reverb."));
            reverbTimeLabel = new GUIContent(L10n.Tr("Time"),
            L10n.Tr("Adjusts the overall duration of the reverb by a positive scaling factor."));
            sizeLabel = new GUIContent(L10n.Tr("Size"), L10n.Tr("Sets the room dimensions."));
            leftWall = serializedObject.FindProperty("LeftWall");
            rightWall = serializedObject.FindProperty("RightWall");
            floor = serializedObject.FindProperty("Floor");
            ceiling = serializedObject.FindProperty("Ceiling");
            backWall = serializedObject.FindProperty("BackWall");
            frontWall = serializedObject.FindProperty("FrontWall");
            reflectivity = serializedObject.FindProperty("Reflectivity");
            reverbGainDb = serializedObject.FindProperty("ReverbGainDb");
            reverbBrightness = serializedObject.FindProperty("ReverbBrightness");
            reverbTime = serializedObject.FindProperty("ReverbTime");
            size = serializedObject.FindProperty("Size");
        }

        /// @cond
        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            // Add clickable script field, as would have been provided by DrawDefaultInspector()
            MonoScript script = MonoScript.FromMonoBehaviour(target as MonoBehaviour);
            EditorGUI.BeginDisabledGroup(true);
            EditorGUILayout.ObjectField("Script", script, typeof(MonoScript), false);
            EditorGUI.EndDisabledGroup();
            EditorGUILayout.LabelField(surfaceMaterialsLabel);
            ++EditorGUI.indentLevel;
            DrawSurfaceMaterial(leftWall, L10n.Tr("Left Wall"));
            DrawSurfaceMaterial(rightWall, L10n.Tr("Right Wall"));
            DrawSurfaceMaterial(floor, L10n.Tr("Floor"));
            DrawSurfaceMaterial(ceiling, L10n.Tr("Ceiling"));
            DrawSurfaceMaterial(backWall, L10n.Tr("Back Wall"));
            DrawSurfaceMaterial(frontWall, L10n.Tr("Front Wall"));
            --EditorGUI.indentLevel;

            EditorGUILayout.Separator();

            EditorGUILayout.Slider(reflectivity, 0.0f, FmodResonanceAudio.MaxReflectivity, reflectivityLabel);

            EditorGUILayout.Separator();

            EditorGUILayout.LabelField(reverbPropertiesLabel);
            ++EditorGUI.indentLevel;
            EditorGUILayout.Slider(reverbGainDb, FmodResonanceAudio.MinGainDb, FmodResonanceAudio.MaxGainDb,
                                   reverbGainLabel);
            EditorGUILayout.Slider(reverbBrightness, FmodResonanceAudio.MinReverbBrightness,
                                   FmodResonanceAudio.MaxReverbBrightness, reverbBrightnessLabel);
            EditorGUILayout.Slider(reverbTime, 0.0f, FmodResonanceAudio.MaxReverbTime, reverbTimeLabel);
            --EditorGUI.indentLevel;

            EditorGUILayout.Separator();

            EditorGUILayout.PropertyField(size, sizeLabel);

            serializedObject.ApplyModifiedProperties();
        }
        /// @endcond

        private void DrawSurfaceMaterial(SerializedProperty surfaceMaterial, string displayName)
        {
            EditorGUILayout.BeginHorizontal();

            GUIContent labelContent = new GUIContent(displayName, surfaceMaterialLabel.tooltip);
            EditorGUILayout.LabelField(labelContent, GUILayout.Width(150));
            surfaceMaterial.intValue = EditorGUILayout.IntPopup(
                        surfaceMaterial.intValue, SurfaceMaterialDisplay, SurfaceMaterialValues);

            EditorGUILayout.EndHorizontal();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/FmodResonanceAudioRoomEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 935c6716e27bd481e97897dd9e1de595
timeCreated: 1511395157
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/FMODUnityResonanceEditor.asmdef
================================================
{
    "name": "FMODUnityResonanceEditor",
    "references": [
        "FMODUnityResonance"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [
        "UNITY_2021_3_OR_NEWER"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/FMODUnityResonanceEditor.asmdef.meta
================================================
fileFormatVersion: 2
guid: 194213485063a984b98ce9410892267a
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/Localization.cs
================================================
#if UNITY_2020_2_OR_NEWER
[assembly: UnityEditor.Localization]
#endif


================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/Localization.cs.meta
================================================
fileFormatVersion: 2
guid: 6711f1f86af21644c897cc89748266f6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/zh_hans.po
================================================
﻿msgid ""
msgstr ""
"Project-Id-Version: FMOD for Unity\n"
"POT-Creation-Date: 2024-12-20 15:03+1100\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.5\n"
"X-Poedit-KeywordsList: ;L10n.Tr\n"
"X-Poedit-Basepath: .\n"
"X-Poedit-SearchPath-0: .\n"

#: FmodResonanceAudioRoomEditor.cs:51
msgid "Transparent"
msgstr "透明"

#: FmodResonanceAudioRoomEditor.cs:52
msgid "Acoustic Ceiling Tiles"
msgstr "吸音天花板瓦"

#: FmodResonanceAudioRoomEditor.cs:53
msgid "Brick Bare"
msgstr "裸砖"

#: FmodResonanceAudioRoomEditor.cs:54
msgid "Brick Painted"
msgstr "涂漆砖"

#: FmodResonanceAudioRoomEditor.cs:55
msgid "Concrete Block Coarse"
msgstr "粗糙混凝土块"

#: FmodResonanceAudioRoomEditor.cs:56
msgid "Concrete Block Painted"
msgstr "涂漆混凝土块"

#: FmodResonanceAudioRoomEditor.cs:57
msgid "Curtain Heavy"
msgstr "厚重窗帘"

#: FmodResonanceAudioRoomEditor.cs:58
msgid "Fiberglass Insulation"
msgstr "玻璃纤维绝缘"

#: FmodResonanceAudioRoomEditor.cs:59
msgid "Glass Thin"
msgstr "薄玻璃"

#: FmodResonanceAudioRoomEditor.cs:60
msgid "Glass Thick"
msgstr "厚玻璃"

#: FmodResonanceAudioRoomEditor.cs:61
msgid "Grass"
msgstr "草地"

#: FmodResonanceAudioRoomEditor.cs:62
msgid "Linoleum On Concrete"
msgstr "沥青混凝土"

#: FmodResonanceAudioRoomEditor.cs:63
msgid "Marble"
msgstr "大理石"

#: FmodResonanceAudioRoomEditor.cs:64
msgid "Metal"
msgstr "金属"

#: FmodResonanceAudioRoomEditor.cs:65
msgid "Parquet On Concrete"
msgstr "混凝土上的镶木地板"

#: FmodResonanceAudioRoomEditor.cs:66
msgid "Plaster Rough"
msgstr "粗糙石膏"

#: FmodResonanceAudioRoomEditor.cs:67
msgid "Plaster Smooth"
msgstr "光滑石膏"

#: FmodResonanceAudioRoomEditor.cs:68
msgid "Plywood Panel"
msgstr "胶合板"

#: FmodResonanceAudioRoomEditor.cs:69
msgid "Polished Concrete Or Tile"
msgstr "抛光混凝土或瓷砖"

#: FmodResonanceAudioRoomEditor.cs:70
msgid "Sheetrock"
msgstr "石膏板"

#: FmodResonanceAudioRoomEditor.cs:71
msgid "Water Or Ice Surface"
msgstr "水面或冰面"

#: FmodResonanceAudioRoomEditor.cs:72
msgid "Wood Ceiling"
msgstr "木质天花板"

#: FmodResonanceAudioRoomEditor.cs:73
msgid "Wood Panel"
msgstr "木板"

#: FmodResonanceAudioRoomEditor.cs:104
msgid "Surface Materials"
msgstr "表面材质"

#: FmodResonanceAudioRoomEditor.cs:105
msgid "Room surface materials to calculate the acoustic properties of the room."
msgstr "用于计算房间声学属性的房间表面材质。"

#: FmodResonanceAudioRoomEditor.cs:106
msgid "Surface Material"
msgstr "表面材质"

#: FmodResonanceAudioRoomEditor.cs:107
msgid "Surface material used to calculate the acoustic properties of the room."
msgstr "用于计算房间声学属性的表面材质。"

#: FmodResonanceAudioRoomEditor.cs:108
msgid "Reflectivity"
msgstr "反射率"

#: FmodResonanceAudioRoomEditor.cs:109
msgid "Adjusts what proportion of the direct sound is reflected back by each surface, after an appropriate delay. Reverberation is unaffected by this setting."
msgstr "调整每个表面在适当延迟后反射回直接声音的比例。混响效果不受此设置影响。"

#: FmodResonanceAudioRoomEditor.cs:110
msgid "Gain (dB)"
msgstr "增加增益（分贝）"

#: FmodResonanceAudioRoomEditor.cs:111
msgid "Applies a gain adjustment to the reverberation in the room. The default value will leave reverb unaffected."
msgstr "对房间中的混响应用增益调整。默认值将不影响混响效果。"

#: FmodResonanceAudioRoomEditor.cs:112
msgid "Reverb Properties"
msgstr "混响属性"

#: FmodResonanceAudioRoomEditor.cs:113
msgid "Parameters to adjust the reverb properties of the room."
msgstr "用于调整房间混响属性的参数。"

#: FmodResonanceAudioRoomEditor.cs:114
msgid "Brightness"
msgstr "亮度"

#: FmodResonanceAudioRoomEditor.cs:115
msgid "Adjusts the balance between high and low frequencies in the reverb."
msgstr "调整混响中高频和低频之间的平衡。"

#: FmodResonanceAudioRoomEditor.cs:116
msgid "Time"
msgstr "时间"

#: FmodResonanceAudioRoomEditor.cs:117
msgid "Adjusts the overall duration of the reverb by a positive scaling factor."
msgstr "通过正比例缩放因子调整混响的整体持续时间。"

#: FmodResonanceAudioRoomEditor.cs:118
msgid "Size"
msgstr "尺寸"

#: FmodResonanceAudioRoomEditor.cs:118
msgid "Sets the room dimensions."
msgstr "设置房间的尺寸。"

#: FmodResonanceAudioRoomEditor.cs:144
msgid "Left Wall"
msgstr "左墙"

#: FmodResonanceAudioRoomEditor.cs:145
msgid "Right Wall"
msgstr "右墙"

#: FmodResonanceAudioRoomEditor.cs:146
msgid "Floor"
msgstr "地板"

#: FmodResonanceAudioRoomEditor.cs:147
msgid "Ceiling"
msgstr "天花板"

#: FmodResonanceAudioRoomEditor.cs:148
msgid "Back Wall"
msgstr "后墙"

#: FmodResonanceAudioRoomEditor.cs:149
msgid "Front Wall"
msgstr "前墙"



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Editor/zh_hans.po.meta
================================================
fileFormatVersion: 2
guid: df892acb3265e0043b3bb1b8981b5aeb
LocalizationImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FmodResonanceAudio.cs
================================================
// Copyright 2017 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using FMODUnity;

namespace FMODUnityResonance
{
    /// This is the main Resonance Audio class that communicates with the FMOD Unity integration. Native
    /// functions of the system can only be called through this class to preserve the internal system
    /// functionality.
    public static class FmodResonanceAudio
    {
        /// Maximum allowed gain value in decibels.
        public const float MaxGainDb = 24.0f;

        /// Minimum allowed gain value in decibels.
        public const float MinGainDb = -24.0f;

        /// Maximum allowed reverb brightness modifier value.
        public const float MaxReverbBrightness = 1.0f;

        /// Minimum allowed reverb brightness modifier value.
        public const float MinReverbBrightness = -1.0f;

        /// Maximum allowed reverb time modifier value.
        public const float MaxReverbTime = 3.0f;

        /// Maximum allowed reflectivity multiplier of a room surface material.
        public const float MaxReflectivity = 2.0f;

        // Right-handed to left-handed matrix converter (and vice versa).
        private static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1, 1, -1));

        // Get a handle to the Resonance Audio Listener FMOD Plugin.
        private static readonly string listenerPluginName = "Resonance Audio Listener";

        // Size of |RoomProperties| struct in bytes.
        private static readonly int roomPropertiesSize = Marshal.SizeOf<RoomProperties>();

        // Plugin data parameter index for the room properties.
        private static readonly int roomPropertiesIndex = 1;

        // Boundaries instance to be used in room detection logic.
        private static Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

        // Container to store the currently active rooms in the scene.
        private static List<FmodResonanceAudioRoom> enabledRooms = new List<FmodResonanceAudioRoom>();

        // Current listener position.
        private static FMOD.VECTOR listenerPositionFmod = new FMOD.VECTOR();

        // FMOD Resonance Audio Listener Plugin.
        private static FMOD.DSP listenerPlugin;

        /// Updates the room effects of the environment with given |room| properties.
        /// @note This should only be called from the main Unity thread.
        public static void UpdateAudioRoom(FmodResonanceAudioRoom room, bool roomEnabled)
        {
            // Update the enabled rooms list.
            if (roomEnabled)
            {
                if (!enabledRooms.Contains(room))
                {
                    enabledRooms.Add(room);
                }
            }
            else
            {
                enabledRooms.Remove(room);
            }
            // Update the current room effects to be applied.
            if (enabledRooms.Count > 0)
            {
                FmodResonanceAudioRoom currentRoom = enabledRooms[enabledRooms.Count - 1];
                RoomProperties roomProperties = GetRoomProperties(currentRoom);
                // Pass the room properties into a pointer.
                IntPtr roomPropertiesPtr = Marshal.AllocHGlobal(roomPropertiesSize);
                Marshal.StructureToPtr(roomProperties, roomPropertiesPtr, false);
                ListenerPlugin.setParameterData(roomPropertiesIndex, GetBytes(roomPropertiesPtr,
                                                                               roomPropertiesSize));
                Marshal.FreeHGlobal(roomPropertiesPtr);
            }
            else
            {
                // Set the room properties to a null room, which will effectively disable the room effects.
                ListenerPlugin.setParameterData(roomPropertiesIndex, GetBytes(IntPtr.Zero, 0));
            }
        }

        /// Returns whether the listener is currently inside the given |room| boundaries.
        public static bool IsListenerInsideRoom(FmodResonanceAudioRoom room)
        {
            // Compute the room position relative to the listener.
            FMOD.VECTOR unused;
            RuntimeManager.CoreSystem.get3DListenerAttributes(0, out listenerPositionFmod, out unused,
                                                                  out unused, out unused);
            Vector3 listenerPosition = new Vector3(listenerPositionFmod.x, listenerPositionFmod.y,
                                                   listenerPositionFmod.z);
            Vector3 relativePosition = listenerPosition - room.transform.position;
            Quaternion rotationInverse = Quaternion.Inverse(room.transform.rotation);
            // Set the size of the room as the boundary and return whether the listener is inside.
            bounds.size = Vector3.Scale(room.transform.lossyScale, room.Size);
            return bounds.Contains(rotationInverse * relativePosition);
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct RoomProperties
        {
            // Center position of the room in world space.
            public float PositionX;
            public float PositionY;
            public float PositionZ;

            // Rotation (quaternion) of the room in world space.
            public float RotationX;
            public float RotationY;
            public float RotationZ;
            public float RotationW;

            // Size of the shoebox room in world space.
            public float DimensionsX;
            public float DimensionsY;
            public float DimensionsZ;

            // Material name of each surface of the shoebox room.
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialLeft;
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialRight;
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialBottom;
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialTop;
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialFront;
            public FmodResonanceAudioRoom.SurfaceMaterial MaterialBack;

            // User defined uniform scaling factor for reflectivity. This parameter has no effect when set
            // to 1.0f.
            public float ReflectionScalar;

            // User defined reverb tail gain multiplier. This parameter has no effect when set to 0.0f.
            public float ReverbGain;

            // Adjusts the reverberation time across all frequency bands. RT60 values are multiplied by this
            // factor. Has no effect when set to 1.0f.
            public float ReverbTime;

            // Controls the slope of a line from the lowest to the highest RT60 values (increases high
            // frequency RT60s when positive, decreases when negative). Has no effect when set to 0.0f.
            public float ReverbBrightness;
        };

        // Returns the FMOD Resonance Audio Listener Plugin.
        private static FMOD.DSP ListenerPlugin
        {
            get
            {
                if (!listenerPlugin.hasHandle())
                {
                    listenerPlugin = Initialize();
                }
                return listenerPlugin;
            }
        }

        // Converts given |db| value to its amplitude equivalent where 'dB = 20 * log10(amplitude)'.
        private static float ConvertAmplitudeFromDb(float db)
        {
            return Mathf.Pow(10.0f, 0.05f * db);
        }

        // Converts given |position| and |rotation| from Unity space to audio space.
        private static void ConvertAudioTransformFromUnity(ref Vector3 position,
          ref Quaternion rotation)
        {
            // Compose the transformation matrix.
            Matrix4x4 transformMatrix = Matrix4x4.TRS(position, rotation, Vector3.one);
            // Convert the transformation matrix from left-handed to right-handed.
            transformMatrix = flipZ * transformMatrix * flipZ;
            // Update |position| and |rotation| respectively.
            position = transformMatrix.GetColumn(3);
            rotation = Quaternion.LookRotation(transformMatrix.GetColumn(2), transformMatrix.GetColumn(1));
        }

        // Returns a byte array of |length| created from |ptr|.
        private static byte[] GetBytes(IntPtr ptr, int length)
        {
            if (ptr != IntPtr.Zero)
            {
                byte[] byteArray = new byte[length];
                Marshal.Copy(ptr, byteArray, 0, length);
                return byteArray;
            }
            // Return an empty array if the pointer is null.
            return new byte[1];
        }

        // Returns room properties of the given |room|.
        private static RoomProperties GetRoomProperties(FmodResonanceAudioRoom room)
        {
            RoomProperties roomProperties;
            Vector3 position = room.transform.position;
            Quaternion rotation = room.transform.rotation;
            Vector3 scale = Vector3.Scale(room.transform.lossyScale, room.Size);
            ConvertAudioTransformFromUnity(ref position, ref rotation);
            roomProperties.PositionX = position.x;
            roomProperties.PositionY = position.y;
            roomProperties.PositionZ = position.z;
            roomProperties.RotationX = rotation.x;
            roomProperties.RotationY = rotation.y;
            roomProperties.RotationZ = rotation.z;
            roomProperties.RotationW = rotation.w;
            roomProperties.DimensionsX = scale.x;
            roomProperties.DimensionsY = scale.y;
            roomProperties.DimensionsZ = scale.z;
            roomProperties.MaterialLeft = room.LeftWall;
            roomProperties.MaterialRight = room.RightWall;
            roomProperties.MaterialBottom = room.Floor;
            roomProperties.MaterialTop = room.Ceiling;
            roomProperties.MaterialFront = room.FrontWall;
            roomProperties.MaterialBack = room.BackWall;
            roomProperties.ReverbGain = ConvertAmplitudeFromDb(room.ReverbGainDb);
            roomProperties.ReverbTime = room.ReverbTime;
            roomProperties.ReverbBrightness = room.ReverbBrightness;
            roomProperties.ReflectionScalar = room.Reflectivity;
            return roomProperties;
        }

        // Initializes and returns the FMOD Resonance Audio Listener Plugin.
        private static FMOD.DSP Initialize()
        {
            // Search through all busses on in banks.
            int numBanks = 0;
            FMOD.DSP dsp = new FMOD.DSP();
            FMOD.Studio.Bank[] banks = null;
            RuntimeManager.StudioSystem.getBankCount(out numBanks);
            RuntimeManager.StudioSystem.getBankList(out banks);
            for (int currentBank = 0; currentBank < numBanks; ++currentBank)
            {
                int numBusses = 0;
                FMOD.Studio.Bus[] busses = null;
                banks[currentBank].getBusCount(out numBusses);
                banks[currentBank].getBusList(out busses);
                for (int currentBus = 0; currentBus < numBusses; ++currentBus)
                {
                    // Make sure the channel group of the current bus is assigned properly.
                    string busPath = null;
                    busses[currentBus].getPath(out busPath);
                    RuntimeManager.StudioSystem.getBus(busPath, out busses[currentBus]);
                    busses[currentBus].lockChannelGroup();
                    RuntimeManager.StudioSystem.flushCommands();
                    FMOD.ChannelGroup channelGroup;
                    busses[currentBus].getChannelGroup(out channelGroup);
                    if (channelGroup.hasHandle())
                    {
                        int numDsps = 0;
                        channelGroup.getNumDSPs(out numDsps);
                        for (int currentDsp = 0; currentDsp < numDsps; ++currentDsp)
                        {
                            channelGroup.getDSP(currentDsp, out dsp);
                            string dspNameSb;
                            int unusedInt = 0;
                            uint unusedUint = 0;
                            dsp.getInfo(out dspNameSb, out unusedUint, out unusedInt, out unusedInt, out unusedInt);
                            if (dspNameSb.ToString().Equals(listenerPluginName) && dsp.hasHandle())
                            {
                                return dsp;
                            }
                        }
                    }
                    busses[currentBus].unlockChannelGroup();
                }
            }
            RuntimeUtils.DebugLogError(listenerPluginName + " not found in the FMOD project.");
            return dsp;
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FmodResonanceAudio.cs.meta
================================================
fileFormatVersion: 2
guid: 6794e6301575a445d8588930a0752568
timeCreated: 1511395157
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FmodResonanceAudioRoom.cs
================================================
// Copyright 2017 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using UnityEngine;
using UnityEngine.Serialization;
using System.Collections;

namespace FMODUnityResonance
{
    /// Resonance Audio room component that simulates environmental effects of a room with respect to
    /// the properties of the attached game object.
    [AddComponentMenu("ResonanceAudio/FmodResonanceAudioRoom")]
    public class FmodResonanceAudioRoom : MonoBehaviour
    {
        /// Material type that determines the acoustic properties of a room surface.
        public enum SurfaceMaterial
        {
            Transparent = 0,              ///< Transparent
            AcousticCeilingTiles = 1,     ///< Acoustic ceiling tiles
            BrickBare = 2,                ///< Brick, bare
            BrickPainted = 3,             ///< Brick, painted
            ConcreteBlockCoarse = 4,      ///< Concrete block, coarse
            ConcreteBlockPainted = 5,     ///< Concrete block, painted
            CurtainHeavy = 6,             ///< Curtain, heavy
            FiberglassInsulation = 7,     ///< Fiberglass insulation
            GlassThin = 8,                ///< Glass, thin
            GlassThick = 9,               ///< Glass, thick
            Grass = 10,                   ///< Grass
            LinoleumOnConcrete = 11,      ///< Linoleum on concrete
            Marble = 12,                  ///< Marble
            Metal = 13,                   ///< Galvanized sheet metal
            ParquetOnConcrete = 14,       ///< Parquet on concrete
            PlasterRough = 15,            ///< Plaster, rough
            PlasterSmooth = 16,           ///< Plaster, smooth
            PlywoodPanel = 17,            ///< Plywood panel
            PolishedConcreteOrTile = 18,  ///< Polished concrete or tile
            Sheetrock = 19,               ///< Sheetrock
            WaterOrIceSurface = 20,       ///< Water or ice surface
            WoodCeiling = 21,             ///< Wood ceiling
            WoodPanel = 22                ///< Wood panel
        }

        /// Room surface material in negative x direction.
        [FormerlySerializedAs("leftWall")]
        public SurfaceMaterial LeftWall = SurfaceMaterial.ConcreteBlockCoarse;

        /// Room surface material in positive x direction.
        [FormerlySerializedAs("rightWall")]
        public SurfaceMaterial RightWall = SurfaceMaterial.ConcreteBlockCoarse;

        /// Room surface material in negative y direction.
        [FormerlySerializedAs("floor")]
        public SurfaceMaterial Floor = SurfaceMaterial.ParquetOnConcrete;

        /// Room surface material in positive y direction.
        [FormerlySerializedAs("ceiling")]
        public SurfaceMaterial Ceiling = SurfaceMaterial.PlasterRough;

        /// Room surface material in negative z direction.
        [FormerlySerializedAs("backWall")]
        public SurfaceMaterial BackWall = SurfaceMaterial.ConcreteBlockCoarse;

        /// Room surface material in positive z direction.
        [FormerlySerializedAs("frontWall")]
        public SurfaceMaterial FrontWall = SurfaceMaterial.ConcreteBlockCoarse;

        /// Reflectivity scalar for each surface of the room.
        [FormerlySerializedAs("reflectivity")]
        public float Reflectivity = 1.0f;

        /// Reverb gain modifier in decibels.
        [FormerlySerializedAs("reverbGainDb")]
        public float ReverbGainDb = 0.0f;

        /// Reverb brightness modifier.
        [FormerlySerializedAs("reverbBrightness")]
        public float ReverbBrightness = 0.0f;

        /// Reverb time modifier.
        [FormerlySerializedAs("reverbTime")]
        public float ReverbTime = 1.0f;

        /// Size of the room (normalized with respect to scale of the game object).
        [FormerlySerializedAs("size")]
        public Vector3 Size = Vector3.one;

        private void OnEnable()
        {
            FmodResonanceAudio.UpdateAudioRoom(this, FmodResonanceAudio.IsListenerInsideRoom(this));
        }

        private void OnDisable()
        {
            FmodResonanceAudio.UpdateAudioRoom(this, false);
        }

        private void Update()
        {
            FmodResonanceAudio.UpdateAudioRoom(this, FmodResonanceAudio.IsListenerInsideRoom(this));
        }

        private void OnDrawGizmosSelected()
        {
            // Draw shoebox model wireframe of the room.
            Gizmos.color = Color.yellow;
            Gizmos.matrix = transform.localToWorldMatrix;
            Gizmos.DrawWireCube(Vector3.zero, Size);
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FmodResonanceAudioRoom.cs.meta
================================================
fileFormatVersion: 2
guid: 6b0c5e63920ee4f55b7ec5248525af4b
timeCreated: 1511395157
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FMODUnityResonance.asmdef
================================================
{
    "name": "FMODUnityResonance",
    "references": [
        "FMODUnity"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [
        "UNITY_2021_3_OR_NEWER"
    ],
    "versionDefines": [],
    "noEngineReferences": false
}


================================================
FILE: Assets/Plugins/FMOD/addons/ResonanceAudio/Scripts/FMODUnityResonance.asmdef.meta
================================================
fileFormatVersion: 2
guid: 44d09cf463b68274884d8a3c8a94e528
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/AddIcon.png.meta
================================================
fileFormatVersion: 2
guid: 3300e81f02e64924eb7cb7782713b126
timeCreated: 1455151837
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/ArrowIcon.png.meta
================================================
fileFormatVersion: 2
guid: 01c0101f357b9da4ba78b8f58c290f86
timeCreated: 1455161898
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/BankIcon.png.meta
================================================
fileFormatVersion: 2
guid: a7e06068a7215854a84bf5ed8280ed15
timeCreated: 1433208188
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/Border.png.meta
================================================
fileFormatVersion: 2
guid: 40848578d1961334d820821bec6175a4
timeCreated: 1455150446
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/BrowserIcon.png.meta
================================================
fileFormatVersion: 2
guid: c783b763d12874147876e070661b66ab
timeCreated: 1455688158
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/ContinuousParameterIcon.png.meta
================================================
fileFormatVersion: 2
guid: b92803770616fc747bc3c40ffaec0a42
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: -1
    mipBias: -100
    wrapU: -1
    wrapV: -1
    wrapW: -1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 0
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  applyGammaDecoding: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/CopyIcon.png.meta
================================================
fileFormatVersion: 2
guid: 6e164dcb85fc8ad4b9ab2f1e883862d2
timeCreated: 1455688729
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    linearTexture: 0
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: -1
    mipBias: -1
    wrapMode: -1
  nPOTScale: 1
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 0
  textureType: -1
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/CrossYellow.png.meta
================================================
fileFormatVersion: 2
guid: 348d2265b48c67342a4db2a7062813fa
TextureImporter:
  fileIDToRecycleName: {}
  externalObjects: {}
  serializedVersion: 9
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: -1
    mipBias: -100
    wrapU: -1
    wrapV: -1
    wrapW: -1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 0
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  platformSettings:
  - serializedVersion: 2
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    vertices: []
    indices: 
    edges: []
    weights: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/Delete.png.meta
================================================
fileFormatVersion: 2
guid: 196080340db65c44883dd3f599556fb9
timeCreated: 1434604329
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/DiscreteParameterIcon.png.meta
================================================
fileFormatVersion: 2
guid: 509563e7079a6ed4cbf3b3240327e702
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: -1
    mipBias: -100
    wrapU: -1
    wrapV: -1
    wrapW: -1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 0
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  applyGammaDecoding: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/EventIcon.png.meta
================================================
fileFormatVersion: 2
guid: a602f206f9cb31f439c79a2fe23687c5
timeCreated: 1432616010
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/FMODLogoBlack.png.meta
================================================
fileFormatVersion: 2
guid: 36e46b3c334e47e41a0b4ff2f26905ea
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Android
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: PS4
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: iPhone
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/FMODLogoWhite.png.meta
================================================
fileFormatVersion: 2
guid: 8fd8ccb8d7e81d943b28ea7975c7185d
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  vTOnly: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: 1
    aniso: 1
    mipBias: 0
    wrapU: 1
    wrapV: 1
    wrapW: 1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  flipbookRows: 1
  flipbookColumns: 1
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  ignorePngGamma: 0
  applyGammaDecoding: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Standalone
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: Android
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: PS4
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  - serializedVersion: 3
    buildTarget: iPhone
    maxTextureSize: 256
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 0
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/FolderIconClosed.png.meta
================================================
fileFormatVersion: 2
guid: 70efeb6d97126f843b30b8ed62d18a4f
timeCreated: 1432621560
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/FolderIconOpen.png.meta
================================================
fileFormatVersion: 2
guid: d2b54e4f7f80b9448a41d3c5985f5672
timeCreated: 1432621574
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/LabeledParameterIcon.png.meta
================================================
fileFormatVersion: 2
guid: b4d696e5c0be6f44bb2f02aa41320656
TextureImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 11
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: -1
    mipBias: -100
    wrapU: -1
    wrapV: -1
    wrapW: -1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 0
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  applyGammaDecoding: 0
  platformSettings:
  - serializedVersion: 3
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
    forceMaximumCompressionQuality_BC6H_BC7: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    internalID: 0
    vertices: []
    indices: 
    edges: []
    weights: []
    secondaryTextures: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/LevelMeter.png.meta
================================================
fileFormatVersion: 2
guid: 21e7a3d41a926364a8b9a6704ebe80d8
timeCreated: 1433917421
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/LevelMeterOff.png.meta
================================================
fileFormatVersion: 2
guid: 48dc5470d93f669419f294fcd33f7b7c
timeCreated: 1434426551
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/NotFound.png.meta
================================================
fileFormatVersion: 2
guid: 1138ab068176f29499337d7a73dfecd9
timeCreated: 1432798099
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/Preview.png.meta
================================================
fileFormatVersion: 2
guid: 0793eda432fc5df4ab1291e6baacd771
timeCreated: 1434430906
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: 1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/PreviewEmitter.png.meta
================================================
fileFormatVersion: 2
guid: 9519043db3741934fa01455c47683e8c
timeCreated: 1434431177
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    linearTexture: 0
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: -1
    mipBias: -1
    wrapMode: -1
  nPOTScale: 1
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 0
  textureType: -1
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/SearchIconBlack.png.meta
================================================
fileFormatVersion: 2
guid: 99471facfde9fb84dbe4a81ad570ebce
timeCreated: 1434602090
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/SelectedAlt.png.meta
================================================
fileFormatVersion: 2
guid: 8ce9b717b1bc7564cbe35664f2f178a7
timeCreated: 1455161898
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/SnapshotIcon.png.meta
================================================
fileFormatVersion: 2
guid: cf2bba5fb8be7e64ca39979f18eb372a
timeCreated: 1434600422
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/StudioIcon.png.meta
================================================
fileFormatVersion: 2
guid: a4edfa5854cdec34b98b1c55f0562bdd
timeCreated: 1434601223
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: .25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 8
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -1
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: .5, y: .5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TickGreen.png.meta
================================================
fileFormatVersion: 2
guid: 27533226416c4f549b9bec9c024100f7
TextureImporter:
  fileIDToRecycleName: {}
  externalObjects: {}
  serializedVersion: 9
  mipmaps:
    mipMapMode: 0
    enableMipMap: 1
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: -1
    mipBias: -100
    wrapU: -1
    wrapV: -1
    wrapW: -1
  nPOTScale: 1
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 0
  spriteTessellationDetail: -1
  textureType: 0
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  platformSettings:
  - serializedVersion: 2
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    vertices: []
    indices: 
    edges: []
    weights: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TransportOpen.png.meta
================================================
fileFormatVersion: 2
guid: b0fb832e401d1514a9611735d8d340b1
timeCreated: 1453178387
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: -1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TransportPlayButtonOff.png.meta
================================================
fileFormatVersion: 2
guid: 29258b1336a580946bc144df00b74ac1
timeCreated: 1453177025
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: 1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TransportPlayButtonOn.png.meta
================================================
fileFormatVersion: 2
guid: 2d777c9a14189d241aea1afeeeff448c
timeCreated: 1453177025
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: 1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TransportStopButtonOff.png.meta
================================================
fileFormatVersion: 2
guid: cafa069c15865d543a07375373f0a18e
timeCreated: 1453177025
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: 1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/TransportStopButtonOn.png.meta
================================================
fileFormatVersion: 2
guid: eab53cb0959d1244aadeacf8b76c755c
timeCreated: 1453177025
licenseType: Free
TextureImporter:
  fileIDToRecycleName: {}
  serializedVersion: 2
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    linearTexture: 1
    correctGamma: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  grayScaleToAlpha: 0
  generateCubemap: 0
  cubemapConvolution: 0
  cubemapConvolutionSteps: 7
  cubemapConvolutionExponent: 1.5
  seamlessCubemap: 0
  textureFormat: -3
  maxTextureSize: 2048
  textureSettings:
    filterMode: 1
    aniso: 1
    mipBias: -1
    wrapMode: 1
  nPOTScale: 0
  lightmap: 0
  rGBM: 0
  compressionQuality: 50
  allowsAlphaSplitting: 0
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spritePixelsToUnits: 100
  alphaIsTransparency: 1
  textureType: 2
  buildTargetSettings: []
  spriteSheet:
    sprites: []
    outline: []
  spritePackingTag: 
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/images/Wrench.png.meta
================================================
fileFormatVersion: 2
guid: 507cd805ad331e54cb9e9cab5a9270b5
TextureImporter:
  fileIDToRecycleName: {}
  externalObjects: {}
  serializedVersion: 9
  mipmaps:
    mipMapMode: 0
    enableMipMap: 0
    sRGBTexture: 1
    linearTexture: 0
    fadeOut: 0
    borderMipMap: 0
    mipMapsPreserveCoverage: 0
    alphaTestReferenceValue: 0.5
    mipMapFadeDistanceStart: 1
    mipMapFadeDistanceEnd: 3
  bumpmap:
    convertToNormalMap: 0
    externalNormalMap: 0
    heightScale: 0.25
    normalMapFilter: 0
  isReadable: 0
  streamingMipmaps: 0
  streamingMipmapsPriority: 0
  grayScaleToAlpha: 0
  generateCubemap: 6
  cubemapConvolution: 0
  seamlessCubemap: 0
  textureFormat: 1
  maxTextureSize: 2048
  textureSettings:
    serializedVersion: 2
    filterMode: -1
    aniso: 1
    mipBias: -100
    wrapU: 1
    wrapV: 1
    wrapW: -1
  nPOTScale: 0
  lightmap: 0
  compressionQuality: 50
  spriteMode: 0
  spriteExtrude: 1
  spriteMeshType: 1
  alignment: 0
  spritePivot: {x: 0.5, y: 0.5}
  spritePixelsToUnits: 100
  spriteBorder: {x: 0, y: 0, z: 0, w: 0}
  spriteGenerateFallbackPhysicsShape: 1
  alphaUsage: 1
  alphaIsTransparency: 1
  spriteTessellationDetail: -1
  textureType: 2
  textureShape: 1
  singleChannelComponent: 0
  maxTextureSizeSet: 0
  compressionQualitySet: 0
  textureFormatSet: 0
  platformSettings:
  - serializedVersion: 2
    buildTarget: DefaultTexturePlatform
    maxTextureSize: 2048
    resizeAlgorithm: 0
    textureFormat: -1
    textureCompression: 1
    compressionQuality: 50
    crunchedCompression: 0
    allowsAlphaSplitting: 0
    overridden: 0
    androidETC2FallbackOverride: 0
  spriteSheet:
    serializedVersion: 2
    sprites: []
    outline: []
    physicsShape: []
    bones: []
    spriteID: 
    vertices: []
    indices: 
    edges: []
    weights: []
  spritePackingTag: 
  pSDRemoveMatte: 0
  pSDShowRemoveMatteOption: 0
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/android.meta
================================================
fileFormatVersion: 2
guid: ca9461535f8115a4fb8293c748bcd2e1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/html5.meta
================================================
fileFormatVersion: 2
guid: 2e8b0cce3730fcf4e996e9cd562a9858
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/ios.meta
================================================
fileFormatVersion: 2
guid: 56ef07f8e7caf5f4589a020791b532cd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/linux.meta
================================================
fileFormatVersion: 2
guid: 127a9ee57a2a27a439bf9e6b2d5731b6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/mac.meta
================================================
fileFormatVersion: 2
guid: 5dd2bfa8b9eb6874b9e50b79490891a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/tvos.meta
================================================
fileFormatVersion: 2
guid: b878fb13ea2d16a40b79b4400b5149ba
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/uwp.meta
================================================
fileFormatVersion: 2
guid: 76cc08b21e1f3d04e9cc8fdf3cef9eda
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/visionos.meta
================================================
fileFormatVersion: 2
guid: c0af21c1e7f184d6f860c5bb39642057
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/win.meta
================================================
fileFormatVersion: 2
guid: c66754bc90bcdd74dbacaa9bc9adf48b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/android/src.meta
================================================
fileFormatVersion: 2
guid: 03be3f097a522854dbe1d585023925fb
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/android/src/PlatformAndroid.cs
================================================
﻿using System.Collections.Generic;
using System;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_ANDROID && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "fmod" + suffix;
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "fmodstudio" + VERSION.suffix;
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformAndroid : Platform
    {
        static PlatformAndroid()
        {
            Settings.AddPlatformTemplate<PlatformAndroid>("2fea114e74ecf3c4f920e1d5cc1c4c40");
        }

        internal override string DisplayName { get { return "Android"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.Android, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.Android;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.Android; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("android", "Plugins/Android/libs");
        }

        private static readonly string[] Architectures = { "arm64-v8a", "armeabi-v7a", "x86", "x86_64" };

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield return new FileRecord("fmod.jar")
                .WithAbsoluteVersion(FileLayout.Release_1_10, "Plugins/Android/fmod.jar");

            foreach (string architecture in Architectures)
            {
                yield return new FileRecord(string.Format("{0}/libfmod{1}.so", architecture, suffix));
                yield return new FileRecord(string.Format("{0}/libfmodstudio{1}.so", architecture, suffix));
            }
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            foreach (string architecture in Architectures)
            {
                yield return new FileRecord(string.Format("{0}/libgvraudio.so", architecture));
                yield return new FileRecord(string.Format("{0}/libresonanceaudio.so", architecture));
            }
        }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            // Unity parses --additional-cpp arguments specified via
            // PlayerSettings.SetAdditionalIl2CppArgs() incorrectly when the Android
            // Export Project option is set.
            return false;
        }
#endif

        internal override string GetBankFolder()
        {
            return StaticGetBankFolder();
        }

        internal static string StaticGetBankFolder()
        {
            return (Settings.Instance.AndroidUseOBB || Settings.Instance.AndroidPatchBuild)
                ? Application.streamingAssetsPath : "file:///android_asset";
        }

        internal override string GetPluginPath(string pluginName)
        {
            return StaticGetPluginPath(pluginName);
        }

        internal static string StaticGetPluginPath(string pluginName)
        {
            return string.Format("lib{0}.so", pluginName);
        }
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Java Audio Track", outputType = FMOD.OUTPUTTYPE.AUDIOTRACK },
           new OutputType() { displayName = "OpenSL ES", outputType = FMOD.OUTPUTTYPE.OPENSL },
           new OutputType() { displayName = "AAudio", outputType = FMOD.OUTPUTTYPE.AAUDIO },
        };

        internal override int CoreCount { get { return MaximumCoreCount; } }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/android/src/PlatformAndroid.cs.meta
================================================
fileFormatVersion: 2
guid: 97ba6cc2660c0ca498540d254701057a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/html5/src.meta
================================================
fileFormatVersion: 2
guid: 21a9406360b210946b0f52e8bf5ca333
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/html5/src/PlatformWebGL.cs
================================================
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_WEBGL && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "__Internal";
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "__Internal";
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformWebGL : Platform
    {
        static PlatformWebGL()
        {
            Settings.AddPlatformTemplate<PlatformWebGL>("46fbfdf3fc43db0458918377fd40293e");
        }

        internal override string DisplayName { get { return "WebGL"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.WebGLPlayer, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.WebGL;
#if UNITY_WEIXINMINIGAME
            yield return BuildTarget.WeixinMiniGame;
#endif
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.WebGL; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("html5", "Plugins/WebGL");
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            bool emVer_2_0_19 = false;
            bool emVer_3_1_8 = false;
            bool emVer_3_1_39 = false;

#if UNITY_6000_0_OR_NEWER
            emVer_3_1_39 = true;
#elif UNITY_2022_3_OR_NEWER
            emVer_3_1_8 = true;
#else
            emVer_2_0_19 = true;
#endif

            if (allVariants || emVer_3_1_39)
            {
                yield return new FileRecord(string.Format("3.1.39/libfmodstudio{0}.a", suffix));
            }

            if (allVariants || emVer_3_1_8)
            {
                yield return new FileRecord(string.Format("3.1.8/libfmodstudio{0}.a", suffix));
            }

            if (allVariants || emVer_2_0_19)
            {
                yield return new FileRecord(string.Format("2.0.19/libfmodstudio{0}.a", suffix));
            }
        }

        internal override bool IsFMODStaticallyLinked { get { return true; } }
#endif

        internal override string GetPluginPath(string pluginName)
        {
            return string.Format("{0}/{1}.a", GetPluginBasePath(), pluginName);
        }
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "JavaScript webaudio output", outputType = FMOD.OUTPUTTYPE.WEBAUDIO },
        };
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/html5/src/PlatformWebGL.cs.meta
================================================
fileFormatVersion: 2
guid: b87314b32fbe18943af496e4b47136c6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/ios/src.meta
================================================
fileFormatVersion: 2
guid: eb7a0bd9281687744b74c40dd220a50f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/ios/src/PlatformIOS.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_IPHONE && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "__Internal";
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "__Internal";
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformIOS : Platform
    {
        static PlatformIOS()
        {
            Settings.AddPlatformTemplate<PlatformIOS>("0f8eb3f400726694eb47beb1a9f94ce8");
        }

        internal override string DisplayName { get { return "iOS"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.IPhonePlayer, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.iOS;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.iOS; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("ios", "Plugins/iOS");
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            if (allVariants || PlayerSettings.iOS.sdkVersion == iOSSdkVersion.DeviceSDK)
            {
                yield return new FileRecord(string.Format("libfmodstudiounityplugin{0}.a", suffix));
            }

            if (allVariants || PlayerSettings.iOS.sdkVersion == iOSSdkVersion.SimulatorSDK)
            {
                yield return new FileRecord(string.Format("libfmodstudiounitypluginsimulator{0}.a", suffix));
            }
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            if (allVariants || PlayerSettings.iOS.sdkVersion == iOSSdkVersion.DeviceSDK)
            {
                yield return new FileRecord("libgvraudio.a");
                yield return new FileRecord("libresonanceaudio.a");
            }

            if (allVariants || PlayerSettings.iOS.sdkVersion == iOSSdkVersion.SimulatorSDK)
            {
                yield return new FileRecord("libresonanceaudiosimulator.a");
            }
        }

        internal override bool IsFMODStaticallyLinked { get { return true; } }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            return StaticSupportsAdditionalCpp();
        }

        public static bool StaticSupportsAdditionalCpp()
        {
            return false;
        }
#endif

        internal override void LoadPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            StaticLoadPlugins(this, coreSystem, reportResult);
        }

        public static void StaticLoadPlugins(Platform platform, FMOD.System coreSystem,
            Action<FMOD.RESULT, string> reportResult)
        {
            platform.LoadStaticPlugins(coreSystem, reportResult);

        }

#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Core Audio", outputType = FMOD.OUTPUTTYPE.COREAUDIO },
        };
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/ios/src/PlatformIOS.cs.meta
================================================
fileFormatVersion: 2
guid: bc1f51bc35d549941904cf062bae93a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/linux/src.meta
================================================
fileFormatVersion: 2
guid: fb8b6c816014ed44ebc2db5f8dc5e03e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/linux/src/PlatformLinux.cs
================================================
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_STANDALONE_LINUX && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "fmodstudio" + suffix;
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "fmodstudio" + VERSION.suffix;
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformLinux : Platform
    {
        static PlatformLinux()
        {
            Settings.AddPlatformTemplate<PlatformLinux>("b7716510a1f36934c87976f3a81dbf3d");
        }

        internal override string DisplayName { get { return "Linux"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.LinuxPlayer, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.StandaloneLinux64;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.Linux; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("linux", "Plugins");
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield return new FileRecord(string.Format("x86_64/libfmodstudio{0}.so", suffix));
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            if (allVariants)
            {
                yield return new FileRecord("x86_64/libfmod.so");
                yield return new FileRecord("x86_64/libfmodL.so");
            }

            yield return new FileRecord("x86_64/libgvraudio.so");
            yield return new FileRecord("x86_64/libresonanceaudio.so");
        }

        protected override IEnumerable<string> GetObsoleteFiles()
        {
            yield return "lib/linux/x86/libfmodstudio.so";
            yield return "platforms/linux/lib/x86/libfmodstudio.so";
            yield return "lib/linux/x86/libfmodstudioL.so";
            yield return "platforms/linux/lib/x86/libfmodstudioL.so";
        }
#endif

        internal override string GetPluginPath(string pluginName)
        {
            return string.Format("{0}/lib{1}.so", GetPluginBasePath(), pluginName);
        }

#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Pulse Audio", outputType = FMOD.OUTPUTTYPE.PULSEAUDIO },
           new OutputType() { displayName = "Advanced Linux Sound Architecture", outputType = FMOD.OUTPUTTYPE.ALSA },
        };
#endif

        internal override List<CodecChannelCount> DefaultCodecChannels { get { return staticCodecChannels; } }

        private static List<CodecChannelCount> staticCodecChannels = new List<CodecChannelCount>()
        {
            new CodecChannelCount { format = CodecType.FADPCM, channels = 0 },
            new CodecChannelCount { format = CodecType.Vorbis, channels = 32 },
        };
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/linux/src/PlatformLinux.cs.meta
================================================
fileFormatVersion: 2
guid: 73549a74f689f0849a8271d9e908c514
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/mac/src.meta
================================================
fileFormatVersion: 2
guid: 29af24c23c3906b44bbaeaa0c832f235
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/mac/src/PlatformMac.cs
================================================
﻿using System.Collections.Generic;
using System.IO;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_STANDALONE_OSX && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "fmodstudio" + suffix;
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "fmodstudio" + VERSION.suffix;
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformMac : Platform
    {
        static PlatformMac()
        {
            Settings.AddPlatformTemplate<PlatformMac>("52eb9df5db46521439908db3a29a1bbb");
        }

        internal override string DisplayName { get { return "macOS"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.OSXPlayer, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.StandaloneOSX;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.Mac; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("mac", "Plugins");
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield return new FileRecord(string.Format("fmodstudio{0}.bundle", suffix));
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            yield return new FileRecord("gvraudio.bundle");
            yield return new FileRecord("resonanceaudio.bundle");
        }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            return false;
        }
#endif

        internal override string GetPluginPath(string pluginName)
        {
            string pluginPath = string.Format("{0}/{1}.bundle", GetPluginBasePath(), pluginName);
            if (System.IO.Directory.Exists((pluginPath)))
            {
                return pluginPath;
            }
            else
            {
                return string.Format("{0}/{1}.dylib", GetPluginBasePath(), pluginName);
            }
        }
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Core Audio", outputType = FMOD.OUTPUTTYPE.COREAUDIO },
        };
#endif

        internal override List<CodecChannelCount> DefaultCodecChannels { get { return staticCodecChannels; } }

        private static List<CodecChannelCount> staticCodecChannels = new List<CodecChannelCount>()
        {
            new CodecChannelCount { format = CodecType.FADPCM, channels = 0 },
            new CodecChannelCount { format = CodecType.Vorbis, channels = 32 },
        };
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/mac/src/PlatformMac.cs.meta
================================================
fileFormatVersion: 2
guid: d92d0baf34dae0e4ea032a42bd6107c0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/tvos/src.meta
================================================
fileFormatVersion: 2
guid: a36cddbc75870b64e98ebaac7424553e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/tvos/src/PlatformAppleTV.cs
================================================
﻿using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_TVOS && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "__Internal";
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "__Internal";
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformAppleTV : Platform
    {
        static PlatformAppleTV()
        {
            Settings.AddPlatformTemplate<PlatformAppleTV>("e7a046c753c3c3d4aacc91f6597f310d");
        }

        internal override string DisplayName { get { return "Apple TV"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.tvOS, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.tvOS;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.AppleTV; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("tvos", "Plugins/tvOS");
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            if (allVariants || PlayerSettings.tvOS.sdkVersion == tvOSSdkVersion.Device)
            {
                yield return new FileRecord(string.Format("libfmodstudiounityplugin{0}.a", suffix));
            }

            if (allVariants || PlayerSettings.tvOS.sdkVersion == tvOSSdkVersion.Simulator)
            {
                yield return new FileRecord(string.Format("libfmodstudiounitypluginsimulator{0}.a", suffix));
            }
        }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            return PlatformIOS.StaticSupportsAdditionalCpp();
        }
#endif

#if !UNITY_EDITOR
        internal override void LoadPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            PlatformIOS.StaticLoadPlugins(this, coreSystem, reportResult);
        }
#endif

#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Core Audio", outputType = FMOD.OUTPUTTYPE.COREAUDIO },
        };
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/tvos/src/PlatformAppleTV.cs.meta
================================================
fileFormatVersion: 2
guid: 17eea195bdfbf014e91ba7620ee491f8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/visionos/src.meta
================================================
fileFormatVersion: 2
guid: dbc65c69ec16043268c63c40c92f8bf0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/visionos/src/PlatformVisionOS.cs
================================================
﻿using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_VISIONOS && !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "__Internal";
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "__Internal";
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformVisionOS : Platform
    {
        static PlatformVisionOS()
        {
            Settings.AddPlatformTemplate<PlatformVisionOS>("de700ef3f37a49b58a57ae3addf01ad9");
        }

        internal override string DisplayName { get { return "visionOS"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            #if UNITY_VISIONOS
            settings.DeclareRuntimePlatform(RuntimePlatform.VisionOS, this);
            #endif
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            #if UNITY_VISIONOS
            yield return BuildTarget.VisionOS;
            #else
            yield return BuildTarget.NoTarget;
            #endif
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.None; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return new BinaryAssetFolderInfo("visionos", FileLayout.Release_2_2);
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            #if UNITY_VISIONOS
            if (allVariants || PlayerSettings.VisionOS.sdkVersion == VisionOSSdkVersion.Device)
            #endif
            {
                yield return new FileRecord(string.Format("libfmodstudio{0}_xros.a", suffix));
            }

            #if UNITY_VISIONOS
            if (allVariants || PlayerSettings.VisionOS.sdkVersion == VisionOSSdkVersion.Simulator)
            #endif
            {
                yield return new FileRecord(string.Format("libfmodstudio{0}_xrsimulator.a", suffix));
            }
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            #if UNITY_VISIONOS
            if (allVariants || PlayerSettings.VisionOS.sdkVersion == VisionOSSdkVersion.Device)
            #endif
            {
                yield return new FileRecord("libresonanceaudio_xros.a");
            }

            #if UNITY_VISIONOS
            if (allVariants || PlayerSettings.VisionOS.sdkVersion == VisionOSSdkVersion.Simulator)
            #endif
            {
                yield return new FileRecord("libresonanceaudio_xrsimulator.a");
            }
        }

        internal override bool IsFMODStaticallyLinked { get { return true; } }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            return PlatformIOS.StaticSupportsAdditionalCpp();
        }
#endif

#if !UNITY_EDITOR
        internal override void LoadPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            PlatformIOS.StaticLoadPlugins(this, coreSystem, reportResult);
        }
#endif

#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Core Audio", outputType = FMOD.OUTPUTTYPE.COREAUDIO },
        };
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/visionos/src/PlatformVisionOS.cs.meta
================================================
fileFormatVersion: 2
guid: 8f591a193113347409efedcc618e83d6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/win/src.meta
================================================
fileFormatVersion: 2
guid: e3438d4d60981a7489133b13b11958ec
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/platforms/win/src/PlatformWindows.cs
================================================
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if !UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
#if UNITY_STANDALONE_WIN
        public const string dll = "fmodstudio" + suffix;
#elif UNITY_WSA
        public const string dll = "fmod" + suffix;
#endif
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
#if UNITY_STANDALONE_WIN || UNITY_WSA
        public const string dll = "fmodstudio" + VERSION.suffix;
#endif
    }
}
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformWindows : Platform
    {
        static PlatformWindows()
        {
            Settings.AddPlatformTemplate<PlatformWindows>("2c5177b11d81d824dbb064f9ac8527da");
        }

        internal override string DisplayName { get { return "Windows"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.WindowsPlayer, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.WSAPlayerX86, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.WSAPlayerX64, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.WSAPlayerARM, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield return BuildTarget.StandaloneWindows;
            yield return BuildTarget.StandaloneWindows64;
            yield return BuildTarget.WSAPlayer;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.Windows; } }
#endif

#if UNITY_WINRT_8_1 || UNITY_WSA_10_0
        internal override string GetBankFolder()
        {
            return "ms-appx:///Data/StreamingAssets";
        }
#endif

#if UNITY_EDITOR
        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            switch (buildTarget)
            {
                case BuildTarget.StandaloneWindows:
                case BuildTarget.StandaloneWindows64:
                    return new BinaryAssetFolderInfo("win", "Plugins");
                case BuildTarget.WSAPlayer:
                    return new BinaryAssetFolderInfo("uwp", "Plugins/UWP");
                default:
                    throw new System.ArgumentException("Unrecognised build target: " + buildTarget);
            }
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            string dllSuffix = suffix + ".dll";

            switch (buildTarget)
            {
                case BuildTarget.StandaloneWindows:
                    yield return new FileRecord("x86/fmodstudio" + dllSuffix);
                    break;
                case BuildTarget.StandaloneWindows64:
#if UNITY_2023_1_OR_NEWER
                    yield return new FileRecord("arm64/fmodstudio" + dllSuffix);
#endif
                    yield return new FileRecord("x86_64/fmodstudio" + dllSuffix);
                    break;
                case BuildTarget.WSAPlayer:
                    foreach (string architecture in new[] { "arm", "x64", "x86" })
                    {
                        yield return new FileRecord(string.Format("{0}/fmod{1}", architecture, dllSuffix));
                        yield return new FileRecord(string.Format("{0}/fmodstudio{1}", architecture, dllSuffix));
                    }
                    break;
                default:
                    throw new System.NotSupportedException("Unrecognised Build Target");
            }
        }

        protected override IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            switch (buildTarget)
            {
                case BuildTarget.StandaloneWindows:
                    yield return new FileRecord("x86/gvraudio.dll");
                    yield return new FileRecord("x86/resonanceaudio.dll");
                    break;
                case BuildTarget.StandaloneWindows64:
                    yield return new FileRecord("x86_64/gvraudio.dll");
                    yield return new FileRecord("x86_64/resonanceaudio.dll");
                    break;
                case BuildTarget.WSAPlayer:
                    yield break;
                default:
                    throw new System.NotSupportedException("Unrecognised Build Target");
            }
        }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            return target != BuildTarget.WSAPlayer;
        }
#endif

        internal override string GetPluginPath(string pluginName)
        {
#if UNITY_STANDALONE_WIN
            return string.Format("{0}/{1}/{2}.dll", GetPluginBasePath(), RuntimeUtils.GetPluginArchitectureFolder(), pluginName);
#else // UNITY_WSA
            return string.Format("{0}.dll", pluginName);
#endif
        }
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes
        {
            get
            {
                return sValidOutputTypes;
            }
        }

        private static OutputType[] sValidOutputTypes = {
           new OutputType() { displayName = "Windows Audio Session API", outputType = FMOD.OUTPUTTYPE.WASAPI },
           new OutputType() { displayName = "Windows Sonic", outputType = FMOD.OUTPUTTYPE.WINSONIC },
        };

        internal override int CoreCount { get { return MaximumCoreCount; } }
#endif

        internal override List<CodecChannelCount> DefaultCodecChannels { get { return staticCodecChannels; } }

        private static List<CodecChannelCount> staticCodecChannels = new List<CodecChannelCount>()
        {
            new CodecChannelCount { format = CodecType.FADPCM, channels = 0 },
            new CodecChannelCount { format = CodecType.Vorbis, channels = 32 },
        };
    }
}



================================================
FILE: Assets/Plugins/FMOD/platforms/win/src/PlatformWindows.cs.meta
================================================
fileFormatVersion: 2
guid: 9660e62d6232af242877f0cc2b90c63d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/AutomatableSlots.cs
================================================
﻿using System;
using UnityEngine.Serialization;

namespace FMODUnity
{
    [Serializable]
    public struct AutomatableSlots
    {
        public const int Count = 16;

        [FormerlySerializedAs("slot00")]
        public float Slot00;
        [FormerlySerializedAs("slot01")]
        public float Slot01;
        [FormerlySerializedAs("slot02")]
        public float Slot02;
        [FormerlySerializedAs("slot03")]
        public float Slot03;
        [FormerlySerializedAs("slot04")]
        public float Slot04;
        [FormerlySerializedAs("slot05")]
        public float Slot05;
        [FormerlySerializedAs("slot06")]
        public float Slot06;
        [FormerlySerializedAs("slot07")]
        public float Slot07;
        [FormerlySerializedAs("slot08")]
        public float Slot08;
        [FormerlySerializedAs("slot09")]
        public float Slot09;
        [FormerlySerializedAs("slot10")]
        public float Slot10;
        [FormerlySerializedAs("slot11")]
        public float Slot11;
        [FormerlySerializedAs("slot12")]
        public float Slot12;
        [FormerlySerializedAs("slot13")]
        public float Slot13;
        [FormerlySerializedAs("slot14")]
        public float Slot14;
        [FormerlySerializedAs("slot15")]
        public float Slot15;

        public float GetValue(int index)
        {
            switch(index)
            {
                case 0:
                    return Slot00;
                case 1:
                    return Slot01;
                case 2:
                    return Slot02;
                case 3:
                    return Slot03;
                case 4:
                    return Slot04;
                case 5:
                    return Slot05;
                case 6:
                    return Slot06;
                case 7:
                    return Slot07;
                case 8:
                    return Slot08;
                case 9:
                    return Slot09;
                case 10:
                    return Slot10;
                case 11:
                    return Slot11;
                case 12:
                    return Slot12;
                case 13:
                    return Slot13;
                case 14:
                    return Slot14;
                case 15:
                    return Slot15;
                default:
                    throw new ArgumentException(string.Format("Invalid slot index: {0}", index));
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/AutomatableSlots.cs.meta
================================================
fileFormatVersion: 2
guid: 9c13d4e62f5f7b44bb33162cbf29a9f8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/BankRefAttribute.cs
================================================
﻿using UnityEngine;

namespace FMODUnity
{
    public class BankRefAttribute : PropertyAttribute
    {
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/BankRefAttribute.cs.meta
================================================
fileFormatVersion: 2
guid: a8ab5f38e7776644297d8b3687c39b49
timeCreated: 1445488716
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor.meta
================================================
fileFormatVersion: 2
guid: bdb2bdc82b47a634b803bb658c6e312b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/EventHandler.cs
================================================
﻿using UnityEngine;
#if UNITY_UI_EXIST
using UnityEngine.EventSystems;
#endif

namespace FMODUnity
{
    public abstract class EventHandler : MonoBehaviour
#if UNITY_UI_EXIST
    , IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
#endif
    {
        public string CollisionTag = "";

        protected virtual void Start()
        {
            HandleGameEvent(EmitterGameEvent.ObjectStart);
        }

        protected virtual void OnDestroy()
        {
            HandleGameEvent(EmitterGameEvent.ObjectDestroy);
        }

        private void OnEnable()
        {
            HandleGameEvent(EmitterGameEvent.ObjectEnable);
        }

        private void OnDisable()
        {
            HandleGameEvent(EmitterGameEvent.ObjectDisable);
        }

#if UNITY_PHYSICS_EXIST
        private void OnTriggerEnter(Collider other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag) || (other.attachedRigidbody && other.attachedRigidbody.CompareTag(CollisionTag)))
            {
                HandleGameEvent(EmitterGameEvent.TriggerEnter);
            }
        }

        private void OnTriggerExit(Collider other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag) || (other.attachedRigidbody && other.attachedRigidbody.CompareTag(CollisionTag)))
            {
                HandleGameEvent(EmitterGameEvent.TriggerExit);
            }
        }
#endif

#if UNITY_PHYSICS2D_EXIST
        private void OnTriggerEnter2D(Collider2D other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(EmitterGameEvent.TriggerEnter2D);
            }
        }

        private void OnTriggerExit2D(Collider2D other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(EmitterGameEvent.TriggerExit2D);
            }
        }
#endif

        private void OnCollisionEnter()
        {
            HandleGameEvent(EmitterGameEvent.CollisionEnter);
        }

        private void OnCollisionExit()
        {
            HandleGameEvent(EmitterGameEvent.CollisionExit);
        }

        private void OnCollisionEnter2D()
        {
            HandleGameEvent(EmitterGameEvent.CollisionEnter2D);
        }

        private void OnCollisionExit2D()
        {
            HandleGameEvent(EmitterGameEvent.CollisionExit2D);
        }

#if UNITY_UI_EXIST
        private void OnMouseEnter()
        {
            HandleGameEvent(EmitterGameEvent.ObjectMouseEnter);
        }

        private void OnMouseExit()
        {
            HandleGameEvent(EmitterGameEvent.ObjectMouseExit);
        }

        private void OnMouseDown()
        {
            HandleGameEvent(EmitterGameEvent.ObjectMouseDown);
        }

        private void OnMouseUp()
        {
            HandleGameEvent(EmitterGameEvent.ObjectMouseUp);
        }

        public void OnPointerEnter(PointerEventData eventData)
        {
            HandleGameEvent(EmitterGameEvent.UIMouseEnter);
        }

        public void OnPointerExit(PointerEventData eventData)
        {
            HandleGameEvent(EmitterGameEvent.UIMouseExit);
        }
        public void OnPointerDown(PointerEventData eventData)
        {
            HandleGameEvent(EmitterGameEvent.UIMouseDown);
        }

        public void OnPointerUp(PointerEventData eventData)
        {
            HandleGameEvent(EmitterGameEvent.UIMouseUp);
        }
#endif
        protected abstract void HandleGameEvent(EmitterGameEvent gameEvent);
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/EventHandler.cs.meta
================================================
fileFormatVersion: 2
guid: a28d1e1a42561ed4f8d44293dab99079
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/EventRefAttribute.cs
================================================
﻿using System;
using UnityEngine;

namespace FMODUnity
{
    [Obsolete("Use the EventReference struct instead")]
    public class EventRefAttribute : PropertyAttribute
    {
        public string MigrateTo = null;
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/EventRefAttribute.cs.meta
================================================
fileFormatVersion: 2
guid: 1b29a1189268c3b47aa2ec4b96a9e7ef
timeCreated: 1445311748
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/EventReference.cs
================================================
using System;
using UnityEngine;

namespace FMODUnity
{
    [Serializable]
    public struct EventReference
    {
        public FMOD.GUID Guid;

#if UNITY_EDITOR
#if FMOD_SERIALIZE_GUID_ONLY
        [NonSerialized]
#endif
        public string Path;

        public static Func<string, FMOD.GUID> GuidLookupDelegate;

        public override string ToString()
        {
            return string.Format("{0} ({1})", Guid, Path);
        }

        public bool IsNull
        {
            get
            {
                return string.IsNullOrEmpty(Path) && Guid.IsNull;
            }
        }

        public static EventReference Find(string path)
        {
            if (GuidLookupDelegate == null)
            {
                throw new InvalidOperationException("EventReference.Find called before EventManager was initialized");
            }

            return new EventReference { Path = path, Guid = GuidLookupDelegate(path) };
        }
#else
        public override string ToString()
        {
            return Guid.ToString();
        }

        public bool IsNull
        {
            get
            {
                return Guid.IsNull;
            }
        }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/EventReference.cs.meta
================================================
fileFormatVersion: 2
guid: 1b1e4da3fb15e7a45a8f104b7d0fd6d9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/fmod.cs.meta
================================================
fileFormatVersion: 2
guid: bd0d0c955caff8940ac1667ee36dd4c9
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/fmod_dsp.cs
================================================
/* ======================================================================================== */
/* FMOD Core API - DSP header file.                                                         */
/* Copyright (c), Firelight Technologies Pty, Ltd. 2004-2026.                               */
/*                                                                                          */
/* Use this header if you are wanting to develop your own DSP plugin to use with FMODs      */
/* dsp system.  With this header you can make your own DSP plugin that FMOD can             */
/* register and use.  See the documentation and examples on how to make a working plugin.   */
/*                                                                                          */
/* For more detail visit:                                                                   */
/* https://fmod.com/docs/2.03/api/plugin-api-dsp.html                                       */
/* =========================================================================================*/

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace FMOD
{
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_BUFFER_ARRAY
    {
        public int              numbuffers;
        public IntPtr           buffernumchannels;
        public IntPtr           bufferchannelmask;
        public IntPtr           buffers;
        public SPEAKERMODE      speakermode;

        /*
            These properties take advantage of the fact that numbuffers is always zero or one
        */

        public int numchannels
        {
            get 
            {
                if (buffernumchannels != IntPtr.Zero && numbuffers != 0)
                    return Marshal.ReadInt32(buffernumchannels);

                return 0;
            }
            set
            {
                if (buffernumchannels != IntPtr.Zero && numbuffers != 0)
                    Marshal.WriteInt32(buffernumchannels, value);
            }
        }

        public IntPtr buffer
        {
            get
            {
                if (buffers != IntPtr.Zero && numbuffers != 0)
                    return Marshal.ReadIntPtr(buffers);

                return IntPtr.Zero;
            }
            set
            {
                if (buffers != IntPtr.Zero && numbuffers != 0)
                    Marshal.WriteIntPtr(buffers, value);
            }
        }
    }

    public enum DSP_PROCESS_OPERATION
    {
        PROCESS_PERFORM,
        PROCESS_QUERY
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct COMPLEX
    {
        public float real;
        public float imag;
    }

    public enum DSP_PAN_SURROUND_FLAGS
    {
        DEFAULT = 0,
        ROTATION_NOT_BIASED = 1,
    }


    /*
        DSP callbacks
    */
    public delegate RESULT DSP_CREATE_CALLBACK                  (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RELEASE_CALLBACK                 (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RESET_CALLBACK                   (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SETPOSITION_CALLBACK             (ref DSP_STATE dsp_state, uint pos);
    public delegate RESULT DSP_READ_CALLBACK                    (ref DSP_STATE dsp_state, IntPtr inbuffer, IntPtr outbuffer, uint length, int inchannels, ref int outchannels);
    public delegate RESULT DSP_SHOULDIPROCESS_CALLBACK          (ref DSP_STATE dsp_state, bool inputsidle, uint length, CHANNELMASK inmask, int inchannels, SPEAKERMODE speakermode);
    public delegate RESULT DSP_PROCESS_CALLBACK                 (ref DSP_STATE dsp_state, uint length, ref DSP_BUFFER_ARRAY inbufferarray, ref DSP_BUFFER_ARRAY outbufferarray, bool inputsidle, DSP_PROCESS_OPERATION op);
    public delegate RESULT DSP_SETPARAM_FLOAT_CALLBACK          (ref DSP_STATE dsp_state, int index, float value);
    public delegate RESULT DSP_SETPARAM_INT_CALLBACK            (ref DSP_STATE dsp_state, int index, int value);
    public delegate RESULT DSP_SETPARAM_BOOL_CALLBACK           (ref DSP_STATE dsp_state, int index, bool value);
    public delegate RESULT DSP_SETPARAM_DATA_CALLBACK           (ref DSP_STATE dsp_state, int index, IntPtr data, uint length);
    public delegate RESULT DSP_GETPARAM_FLOAT_CALLBACK          (ref DSP_STATE dsp_state, int index, ref float value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_INT_CALLBACK            (ref DSP_STATE dsp_state, int index, ref int value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_BOOL_CALLBACK           (ref DSP_STATE dsp_state, int index, ref bool value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_DATA_CALLBACK           (ref DSP_STATE dsp_state, int index, ref IntPtr data, ref uint length, IntPtr valuestr);
    public delegate RESULT DSP_SYSTEM_REGISTER_CALLBACK         (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SYSTEM_DEREGISTER_CALLBACK       (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SYSTEM_MIX_CALLBACK              (ref DSP_STATE dsp_state, int stage);


    /*
        DSP functions
    */
    public delegate IntPtr DSP_ALLOC_FUNC                         (uint size, MEMORY_TYPE type, IntPtr sourcestr);
    public delegate IntPtr DSP_REALLOC_FUNC                       (IntPtr ptr, uint size, MEMORY_TYPE type, IntPtr sourcestr);
    public delegate void   DSP_FREE_FUNC                          (IntPtr ptr, MEMORY_TYPE type, IntPtr sourcestr);
    public delegate void   DSP_LOG_FUNC                           (DEBUG_FLAGS level, IntPtr file, int line, IntPtr function, IntPtr str);
    public delegate RESULT DSP_GETSAMPLERATE_FUNC                 (ref DSP_STATE dsp_state, ref int rate);
    public delegate RESULT DSP_GETBLOCKSIZE_FUNC                  (ref DSP_STATE dsp_state, ref uint blocksize);
    public delegate RESULT DSP_GETSPEAKERMODE_FUNC                (ref DSP_STATE dsp_state, ref int speakermode_mixer, ref int speakermode_output);
    public delegate RESULT DSP_GETCLOCK_FUNC                      (ref DSP_STATE dsp_state, out ulong clock, out uint offset, out uint length);
    public delegate RESULT DSP_GETLISTENERATTRIBUTES_FUNC         (ref DSP_STATE dsp_state, ref int numlisteners, IntPtr attributes);
    public delegate RESULT DSP_GETUSERDATA_FUNC                   (ref DSP_STATE dsp_state, out IntPtr userdata);
    public delegate RESULT DSP_DFT_FFTREAL_FUNC                   (ref DSP_STATE dsp_state, int size, IntPtr signal, IntPtr dft, IntPtr window, int signalhop);
    public delegate RESULT DSP_DFT_IFFTREAL_FUNC                  (ref DSP_STATE dsp_state, int size, IntPtr dft, IntPtr signal, IntPtr window, int signalhop);
    public delegate RESULT DSP_PAN_SUMMONOMATRIX_FUNC             (ref DSP_STATE dsp_state, int sourceSpeakerMode, float lowFrequencyGain, float overallGain, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUMSTEREOMATRIX_FUNC           (ref DSP_STATE dsp_state, int sourceSpeakerMode, float pan, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUMSURROUNDMATRIX_FUNC         (ref DSP_STATE dsp_state, int sourceSpeakerMode, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix, DSP_PAN_SURROUND_FLAGS flags);
    public delegate RESULT DSP_PAN_SUMMONOTOSURROUNDMATRIX_FUNC   (ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUMSTEREOTOSURROUNDMATRIX_FUNC (ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_GETROLLOFFGAIN_FUNC            (ref DSP_STATE dsp_state, DSP_PAN_3D_ROLLOFF_TYPE rolloff, float distance, float mindistance, float maxdistance, out float gain);


    public enum DSP_TYPE : int
    {
        UNKNOWN,
        MIXER,
        OSCILLATOR,
        LOWPASS,
        ITLOWPASS,
        HIGHPASS,
        ECHO,
        FADER,
        FLANGE,
        DISTORTION,
        NORMALIZE,
        LIMITER,
        PARAMEQ,
        PITCHSHIFT,
        CHORUS,
        ITECHO,
        COMPRESSOR,
        SFXREVERB,
        LOWPASS_SIMPLE,
        DELAY,
        TREMOLO,
        SEND,
        RETURN,
        HIGHPASS_SIMPLE,
        PAN,
        THREE_EQ,
        FFT,
        LOUDNESS_METER,
        CONVOLUTIONREVERB,
        CHANNELMIX,
        TRANSCEIVER,
        OBJECTPAN,
        MULTIBAND_EQ,
        MULTIBAND_DYNAMICS,
        MAX
    }

    public enum DSP_PARAMETER_TYPE
    {
        FLOAT,
        INT,
        BOOL,
        DATA,
        MAX
    }

    public enum DSP_PARAMETER_FLOAT_MAPPING_TYPE
    {
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_LINEAR,
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_AUTO,
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_PIECEWISE_LINEAR,
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR
    {
        public int numpoints;
        public IntPtr pointparamvalues;
        public IntPtr pointpositions;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FLOAT_MAPPING
    {
        public DSP_PARAMETER_FLOAT_MAPPING_TYPE type;
        public DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR piecewiselinearmapping;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_FLOAT
    {
        public float                     min;
        public float                     max;
        public float                     defaultval;
        public DSP_PARAMETER_FLOAT_MAPPING mapping;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_INT
    {
        public int                       min;
        public int                       max;
        public int                       defaultval;
        public bool                      goestoinf;
        public IntPtr                    valuenames;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_BOOL
    {
        public bool                      defaultval;
        public IntPtr                    valuenames;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_DATA
    {
        public int                       datatype;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct DSP_PARAMETER_DESC_UNION
    {
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_FLOAT   floatdesc;
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_INT     intdesc;
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_BOOL    booldesc;
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_DATA    datadesc;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC
    {
        public DSP_PARAMETER_TYPE   type;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[]               name;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[]               label;
        public string               description;

        public DSP_PARAMETER_DESC_UNION desc;
    }

    public enum DSP_PARAMETER_DATA_TYPE
    {
        DSP_PARAMETER_DATA_TYPE_USER =                       0,
        DSP_PARAMETER_DATA_TYPE_OVERALLGAIN =               -1,
        DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES =              -2,
        DSP_PARAMETER_DATA_TYPE_SIDECHAIN =                 -3,
        DSP_PARAMETER_DATA_TYPE_FFT =                       -4,
        DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES_MULTI =        -5,
        DSP_PARAMETER_DATA_TYPE_ATTENUATION_RANGE =         -6,
        DSP_PARAMETER_DATA_TYPE_DYNAMIC_RESPONSE =          -7,
        DSP_PARAMETER_DATA_TYPE_FINITE_LENGTH =             -8
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_OVERALLGAIN
    {
        public float linear_gain;
        public float linear_gain_additive;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_3DATTRIBUTES
    {
        public ATTRIBUTES_3D relative;
        public ATTRIBUTES_3D absolute;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_3DATTRIBUTES_MULTI
    {
        public int            numlisteners;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public ATTRIBUTES_3D[] relative;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public float[] weight;
        public ATTRIBUTES_3D absolute;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_SIDECHAIN
    {
        public int sidechainenable;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FFT
    {
        public int     length;
        public int     numchannels;
        
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=32)]
        private IntPtr[] spectrum_internal;

        public float[][] spectrum
        {
            get
            {
                var buffer = new float[numchannels][];
                
                for (int i = 0; i < numchannels; ++i)
                {
                    buffer[i] = new float[length];
                    Marshal.Copy(spectrum_internal[i], buffer[i], 0, length);
                }
                
                return buffer;
            }
        }

        public void getSpectrum(ref float[][] buffer)
        {
            int bufferLength = Math.Min(buffer.Length, numchannels);
            for (int i = 0; i < bufferLength; ++i)
            {
                getSpectrum(i, ref buffer[i]);
            }
        }

        public void getSpectrum(int channel, ref float[] buffer)
        {
            int bufferLength = Math.Min(buffer.Length, length);
            Marshal.Copy(spectrum_internal[channel], buffer, 0, bufferLength);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DYNAMIC_RESPONSE
    {
        public int numchannels;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public float[] rms;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FINITE_LENGTH
    {
        public int finite;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_LOUDNESS_METER_INFO_TYPE
    {
        public float momentaryloudness;
        public float shorttermloudness;
        public float integratedloudness;
        public float loudness10thpercentile;
        public float loudness95thpercentile;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 66)]
        public float[] loudnesshistogram;
        public float maxtruepeak;
        public float maxmomentaryloudness;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_LOUDNESS_METER_WEIGHTING_TYPE
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public float[] channelweight;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_ATTENUATION_RANGE
    {
        public float min;
        public float max;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_DESCRIPTION
    {
        public uint                           pluginsdkversion;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public byte[]                         name;
        public uint                           version;
        public int                            numinputbuffers;
        public int                            numoutputbuffers;
        public DSP_CREATE_CALLBACK            create;
        public DSP_RELEASE_CALLBACK           release;
        public DSP_RESET_CALLBACK             reset;
        public DSP_READ_CALLBACK              read;
        public DSP_PROCESS_CALLBACK           process;
        public DSP_SETPOSITION_CALLBACK       setposition;

        public int                            numparameters;
        public IntPtr                         paramdesc;
        public DSP_SETPARAM_FLOAT_CALLBACK    setparameterfloat;
        public DSP_SETPARAM_INT_CALLBACK      setparameterint;
        public DSP_SETPARAM_BOOL_CALLBACK     setparameterbool;
        public DSP_SETPARAM_DATA_CALLBACK     setparameterdata;
        public DSP_GETPARAM_FLOAT_CALLBACK    getparameterfloat;
        public DSP_GETPARAM_INT_CALLBACK      getparameterint;
        public DSP_GETPARAM_BOOL_CALLBACK     getparameterbool;
        public DSP_GETPARAM_DATA_CALLBACK     getparameterdata;
        public DSP_SHOULDIPROCESS_CALLBACK    shouldiprocess;
        public IntPtr                         userdata;

        public DSP_SYSTEM_REGISTER_CALLBACK   sys_register;
        public DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister;
        public DSP_SYSTEM_MIX_CALLBACK        sys_mix;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_DFT_FUNCTIONS
    {
        public DSP_DFT_FFTREAL_FUNC  fftreal;
        public DSP_DFT_IFFTREAL_FUNC inversefftreal;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_PAN_FUNCTIONS
    {
        public DSP_PAN_SUMMONOMATRIX_FUNC             summonomatrix;
        public DSP_PAN_SUMSTEREOMATRIX_FUNC           sumstereomatrix;
        public DSP_PAN_SUMSURROUNDMATRIX_FUNC         sumsurroundmatrix;
        public DSP_PAN_SUMMONOTOSURROUNDMATRIX_FUNC   summonotosurroundmatrix;
        public DSP_PAN_SUMSTEREOTOSURROUNDMATRIX_FUNC sumstereotosurroundmatrix;
        public DSP_PAN_GETROLLOFFGAIN_FUNC            getrolloffgain;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_FUNCTIONS
    {
        public DSP_ALLOC_FUNC                  alloc;
        public DSP_REALLOC_FUNC                realloc;
        public DSP_FREE_FUNC                   free;
        public DSP_GETSAMPLERATE_FUNC          getsamplerate;
        public DSP_GETBLOCKSIZE_FUNC           getblocksize;
        public IntPtr                          dft_internal;
        public IntPtr                          pan_internal;
        public DSP_GETSPEAKERMODE_FUNC         getspeakermode;
        public DSP_GETCLOCK_FUNC               getclock;
        public DSP_GETLISTENERATTRIBUTES_FUNC  getlistenerattributes;
        public DSP_LOG_FUNC                    log;
        public DSP_GETUSERDATA_FUNC            getuserdata;
        public DSP_STATE_DFT_FUNCTIONS dft
        {
            get { return Marshal.PtrToStructure<FMOD.DSP_STATE_DFT_FUNCTIONS>(dft_internal); }
        }
        public DSP_STATE_PAN_FUNCTIONS pan
        {
            get { return Marshal.PtrToStructure<FMOD.DSP_STATE_PAN_FUNCTIONS>(pan_internal); }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE
    {
        public IntPtr     instance;
        public IntPtr     plugindata;
        public uint       channelmask;
        public int        source_speakermode;
        public IntPtr     sidechaindata;
        public int        sidechainchannels;
        private IntPtr    functions_internal;
        public int        systemobject;

        public DSP_STATE_FUNCTIONS functions
        {
            get { return Marshal.PtrToStructure<FMOD.DSP_STATE_FUNCTIONS>(functions_internal); }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_METERING_INFO
    {
        public int numsamples;
        public LEVEL_ARRAY peaklevel;
        public LEVEL_ARRAY rmslevel;
        public short numchannels;

        #region wrapperinternal

        [StructLayout(LayoutKind.Sequential)]
        public struct LEVEL_ARRAY
        {
            // Explicitly define level array elements to avoid allocation
            private float ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7;
            private float ch8, ch9, ch10, ch11, ch12, ch13, ch14, ch15;
            private float ch16, ch17, ch18, ch19, ch20, ch21, ch22, ch23;
            private float ch24, ch25, ch26, ch27, ch28, ch29, ch30, ch31;

            // Indexer for access to elements
            public float this[int index]
            {
                get
                {
                    switch (index)
                    {
                        case 0: return ch0;
                        case 1: return ch1;
                        case 2: return ch2;
                        case 3: return ch3;
                        case 4: return ch4;
                        case 5: return ch5;
                        case 6: return ch6;
                        case 7: return ch7;
                        case 8: return ch8;
                        case 9: return ch9;
                        case 10: return ch10;
                        case 11: return ch11;
                        case 12: return ch12;
                        case 13: return ch13;
                        case 14: return ch14;
                        case 15: return ch15;
                        case 16: return ch16;
                        case 17: return ch17;
                        case 18: return ch18;
                        case 19: return ch19;
                        case 20: return ch20;
                        case 21: return ch21;
                        case 22: return ch22;
                        case 23: return ch23;
                        case 24: return ch24;
                        case 25: return ch25;
                        case 26: return ch26;
                        case 27: return ch27;
                        case 28: return ch28;
                        case 29: return ch29;
                        case 30: return ch30;
                        case 31: return ch31;
                        default: throw new IndexOutOfRangeException();
                    }
                }
            }

            public readonly int Length => 32;

            // Implicit conversion for unchanged access to entire array
            public static implicit operator float[](LEVEL_ARRAY levels)
            {
                float[] buffer = new float[levels.Length];
                for (int i = 0; i < levels.Length; i++)
                {
                    buffer[i] = levels[i];
                }
                return buffer;
            }

            // Zero allocation copy-to
            public void CopyTo(float[] buffer)
            {
                int len = buffer.Length >= this.Length ? this.Length : buffer.Length;
                for (int i = 0; i < len; i++)
                {
                    buffer[i] = this[i];
                }
            }
        }

        #endregion
    }

    /*
        ==============================================================================================================

        FMOD built in effect parameters.
        Use DSP::setParameter with these enums for the 'index' parameter.

        ==============================================================================================================
    */

    public enum DSP_OSCILLATOR : int
    {
        TYPE,
        RATE
    }

    public enum DSP_LOWPASS : int
    {
        CUTOFF,
        RESONANCE
    }

    public enum DSP_ITLOWPASS : int
    {
        CUTOFF,
        RESONANCE
    }

    public enum DSP_HIGHPASS : int
    {
        CUTOFF,
        RESONANCE
    }

    public enum DSP_ECHO : int
    {
        DELAY,
        FEEDBACK,
        DRYLEVEL,
        WETLEVEL,
        DELAYCHANGEMODE
    }

    public enum DSP_ECHO_DELAYCHANGEMODE_TYPE : int
    {
        FADE,
        LERP,
        NONE
    }

    public enum DSP_FADER : int
    {
        GAIN,
        OVERALL_GAIN,
    }

    public enum DSP_DELAY : int
    {
        CH0,
        CH1,
        CH2,
        CH3,
        CH4,
        CH5,
        CH6,
        CH7,
        CH8,
        CH9,
        CH10,
        CH11,
        CH12,
        CH13,
        CH14,
        CH15,
        MAXDELAY,
    }

    public enum DSP_FLANGE : int
    {
        MIX,
        DEPTH,
        RATE
    }

    public enum DSP_TREMOLO : int
    {
        FREQUENCY,
        DEPTH,
        SHAPE,
        SKEW,
        DUTY,
        SQUARE,
        PHASE,
        SPREAD
    }

    public enum DSP_DISTORTION : int
    {
        LEVEL
    }

    public enum DSP_NORMALIZE : int
    {
        FADETIME,
        THRESHOLD,
        MAXAMP
    }

    public enum DSP_LIMITER : int
    {
        RELEASETIME,
        CEILING,
        MAXIMIZERGAIN,
        MODE,
    }

    public enum DSP_PARAMEQ : int
    {
        CENTER,
        BANDWIDTH,
        GAIN
    }

    public enum DSP_MULTIBAND_EQ : int
    {
        A_FILTER,
        A_FREQUENCY,
        A_Q,
        A_GAIN,
        B_FILTER,
        B_FREQUENCY,
        B_Q,
        B_GAIN,
        C_FILTER,
        C_FREQUENCY,
        C_Q,
        C_GAIN,
        D_FILTER,
        D_FREQUENCY,
        D_Q,
        D_GAIN,
        E_FILTER,
        E_FREQUENCY,
        E_Q,
        E_GAIN,
    }

    public enum DSP_MULTIBAND_EQ_FILTER_TYPE : int
    {
        DISABLED,
        LOWPASS_12DB,
        LOWPASS_24DB,
        LOWPASS_48DB,
        HIGHPASS_12DB,
        HIGHPASS_24DB,
        HIGHPASS_48DB,
        LOWSHELF,
        HIGHSHELF,
        PEAKING,
        BANDPASS,
        NOTCH,
        ALLPASS,
        LOWPASS_6DB,
        HIGHPASS_6DB,
    }

    public enum DSP_MULTIBAND_DYNAMICS : int
    {
        LOWER_FREQUENCY,
        UPPER_FREQUENCY,
        LINKED,
        USE_SIDECHAIN,
        A_MODE,
        A_GAIN,
        A_THRESHOLD,
        A_RATIO,
        A_ATTACK,
        A_RELEASE,
        A_GAIN_MAKEUP,
        A_RESPONSE_DATA,
        B_MODE,
        B_GAIN,
        B_THRESHOLD,
        B_RATIO,
        B_ATTACK,
        B_RELEASE,
        B_GAIN_MAKEUP,
        B_RESPONSE_DATA,
        C_MODE,
        C_GAIN,
        C_THRESHOLD,
        C_RATIO,
        C_ATTACK,
        C_RELEASE,
        C_GAIN_MAKEUP,
        C_RESPONSE_DATA,
    }

    public enum DSP_MULTIBAND_DYNAMICS_MODE_TYPE : int
    {
        DISABLED,
        COMPRESS_UP,
        COMPRESS_DOWN,
        EXPAND_UP,
        EXPAND_DOWN
    }

    public enum DSP_PITCHSHIFT : int
    {
        PITCH,
        FFTSIZE,
        OVERLAP,
        MAXCHANNELS
    }

    public enum DSP_CHORUS : int
    {
        MIX,
        RATE,
        DEPTH,
    }

    public enum DSP_ITECHO : int
    {
        WETDRYMIX,
        FEEDBACK,
        LEFTDELAY,
        RIGHTDELAY,
        PANDELAY
    }

    public enum DSP_COMPRESSOR : int
    {
        THRESHOLD,
        RATIO,
        ATTACK,
        RELEASE,
        GAINMAKEUP,
        USESIDECHAIN,
        LINKED
    }

    public enum DSP_SFXREVERB : int
    {
        DECAYTIME,
        EARLYDELAY,
        LATEDELAY,
        HFREFERENCE,
        HFDECAYRATIO,
        DIFFUSION,
        DENSITY,
        LOWSHELFFREQUENCY,
        LOWSHELFGAIN,
        HIGHCUT,
        EARLYLATEMIX,
        WETLEVEL,
        DRYLEVEL
    }

    public enum DSP_LOWPASS_SIMPLE : int
    {
        CUTOFF
    }

    public enum DSP_SEND : int
    {
        RETURNID,
        LEVEL,
    }

    public enum DSP_RETURN : int
    {
        ID,
        INPUT_SPEAKER_MODE
    }

    public enum DSP_HIGHPASS_SIMPLE : int
    {
        CUTOFF
    }

    public enum DSP_PAN_2D_STEREO_MODE_TYPE : int
    {
        DISTRIBUTED,
        DISCRETE
    }

    public enum DSP_PAN_MODE_TYPE : int
    {
        MONO,
        STEREO,
        SURROUND
    }

    public enum DSP_PAN_3D_ROLLOFF_TYPE : int
    {
        LINEARSQUARED,
        LINEAR,
        INVERSE,
        INVERSETAPERED,
        CUSTOM
    }

    public enum DSP_PAN_3D_EXTENT_MODE_TYPE : int
    {
        AUTO,
        USER,
        OFF
    }

    public enum DSP_PAN : int
    {
        MODE,
        _2D_STEREO_POSITION,
        _2D_DIRECTION,
        _2D_EXTENT,
        _2D_ROTATION,
        _2D_LFE_LEVEL,
        _2D_STEREO_MODE,
        _2D_STEREO_SEPARATION,
        _2D_STEREO_AXIS,
        ENABLED_SPEAKERS,
        _3D_POSITION,
        _3D_ROLLOFF,
        _3D_MIN_DISTANCE,
        _3D_MAX_DISTANCE,
        _3D_EXTENT_MODE,
        _3D_SOUND_SIZE,
        _3D_MIN_EXTENT,
        _3D_PAN_BLEND,
        LFE_UPMIX_ENABLED,
        OVERALL_GAIN,
        SURROUND_SPEAKER_MODE,
        _2D_HEIGHT_BLEND,
        ATTENUATION_RANGE,
        OVERRIDE_RANGE
    }

    public enum DSP_THREE_EQ_CROSSOVERSLOPE_TYPE : int
    {
        _12DB,
        _24DB,
        _48DB
    }

    public enum DSP_THREE_EQ : int
    {
        LOWGAIN,
        MIDGAIN,
        HIGHGAIN,
        LOWCROSSOVER,
        HIGHCROSSOVER,
        CROSSOVERSLOPE
    }

    public enum DSP_FFT_WINDOW_TYPE : int
    {
        RECT,
        TRIANGLE,
        HAMMING,
        HANNING,
        BLACKMAN,
        BLACKMANHARRIS
    }

    public enum DSP_FFT_DOWNMIX_TYPE : int
    {
        NONE,
        MONO
    }

    public enum DSP_FFT : int
    {
        WINDOWSIZE,
        WINDOW,
        BAND_START_FREQ,
        BAND_STOP_FREQ,
        SPECTRUMDATA,
        RMS,
        SPECTRAL_CENTROID,
        IMMEDIATE_MODE,
        DOWNMIX,
        CHANNEL
    }


    public enum DSP_LOUDNESS_METER : int
    {
        STATE,
        WEIGHTING,
        INFO
    }


    public enum DSP_LOUDNESS_METER_STATE_TYPE : int
    {
        RESET_INTEGRATED = -3,
        RESET_MAXPEAK = -2,
        RESET_ALL = -1,
        PAUSED = 0,
        ANALYZING = 1
    }

    public enum DSP_CONVOLUTION_REVERB : int
    {
        IR,
        WET,
        DRY,
        LINKED
    }

    public enum DSP_CHANNELMIX_OUTPUT : int
    {
        DEFAULT,
        ALLMONO,
        ALLSTEREO,
        ALLQUAD,
        ALL5POINT1,
        ALL7POINT1,
        ALLLFE,
        ALL7POINT1POINT4
    }

    public enum DSP_CHANNELMIX : int
    {
        OUTPUTGROUPING,
        GAIN_CH0,
        GAIN_CH1,
        GAIN_CH2,
        GAIN_CH3,
        GAIN_CH4,
        GAIN_CH5,
        GAIN_CH6,
        GAIN_CH7,
        GAIN_CH8,
        GAIN_CH9,
        GAIN_CH10,
        GAIN_CH11,
        GAIN_CH12,
        GAIN_CH13,
        GAIN_CH14,
        GAIN_CH15,
        GAIN_CH16,
        GAIN_CH17,
        GAIN_CH18,
        GAIN_CH19,
        GAIN_CH20,
        GAIN_CH21,
        GAIN_CH22,
        GAIN_CH23,
        GAIN_CH24,
        GAIN_CH25,
        GAIN_CH26,
        GAIN_CH27,
        GAIN_CH28,
        GAIN_CH29,
        GAIN_CH30,
        GAIN_CH31,
        OUTPUT_CH0,
        OUTPUT_CH1,
        OUTPUT_CH2,
        OUTPUT_CH3,
        OUTPUT_CH4,
        OUTPUT_CH5,
        OUTPUT_CH6,
        OUTPUT_CH7,
        OUTPUT_CH8,
        OUTPUT_CH9,
        OUTPUT_CH10,
        OUTPUT_CH11,
        OUTPUT_CH12,
        OUTPUT_CH13,
        OUTPUT_CH14,
        OUTPUT_CH15,
        OUTPUT_CH16,
        OUTPUT_CH17,
        OUTPUT_CH18,
        OUTPUT_CH19,
        OUTPUT_CH20,
        OUTPUT_CH21,
        OUTPUT_CH22,
        OUTPUT_CH23,
        OUTPUT_CH24,
        OUTPUT_CH25,
        OUTPUT_CH26,
        OUTPUT_CH27,
        OUTPUT_CH28,
        OUTPUT_CH29,
        OUTPUT_CH30,
        OUTPUT_CH31,
    }

    public enum DSP_TRANSCEIVER_SPEAKERMODE : int
    {
        AUTO = -1,
        MONO = 0,
        STEREO,
        SURROUND,
    }

    public enum DSP_TRANSCEIVER : int
    {
        TRANSMIT,
        GAIN,
        CHANNEL,
        TRANSMITSPEAKERMODE
    }

    public enum DSP_OBJECTPAN : int
    {
        _3D_POSITION,
        _3D_ROLLOFF,
        _3D_MIN_DISTANCE,
        _3D_MAX_DISTANCE,
        _3D_EXTENT_MODE,
        _3D_SOUND_SIZE,
        _3D_MIN_EXTENT,
        OVERALL_GAIN,
        OUTPUTGAIN,
        ATTENUATION_RANGE,
        OVERRIDE_RANGE
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/fmod_dsp.cs.meta
================================================
fileFormatVersion: 2
guid: b7b10c26cf550794183b926ffae615a7
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/fmod_errors.cs
================================================
/* ==============================================================================================  */
/* FMOD Core / Studio API - Error string header file.                                              */
/* Copyright (c), Firelight Technologies Pty, Ltd. 2004-2026.                                      */
/*                                                                                                 */
/* Use this header if you want to store or display a string version / english explanation          */
/* of the FMOD error codes.                                                                        */
/*                                                                                                 */
/* For more detail visit:                                                                          */
/* https://fmod.com/docs/2.03/api/core-api-common.html#fmod_result                                 */
/* =============================================================================================== */

namespace FMOD
{
    public class Error
    {
        public static string String(FMOD.RESULT errcode)
        {
            switch (errcode)
            {
                case FMOD.RESULT.OK:                            return "No errors.";
                case FMOD.RESULT.ERR_BADCOMMAND:                return "Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound).";
                case FMOD.RESULT.ERR_CHANNEL_ALLOC:             return "Error trying to allocate a channel.";
                case FMOD.RESULT.ERR_CHANNEL_STOLEN:            return "The specified channel has been reused to play another sound.";
                case FMOD.RESULT.ERR_DMA:                       return "DMA Failure.  See debug output for more information.";
                case FMOD.RESULT.ERR_DSP_CONNECTION:            return "DSP connection error.  Connection possibly caused a cyclic dependency or connected dsps with incompatible buffer counts.";
                case FMOD.RESULT.ERR_DSP_DONTPROCESS:           return "DSP return code from a DSP process query callback.  Tells mixer not to call the process callback and therefore not consume CPU.  Use this to optimize the DSP graph.";
                case FMOD.RESULT.ERR_DSP_FORMAT:                return "DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format, or a matrix may have been set with the wrong size if the target unit has a specified channel map.";
                case FMOD.RESULT.ERR_DSP_INUSE:                 return "DSP is already in the mixer's DSP network. It must be removed before being reinserted or released.";
                case FMOD.RESULT.ERR_DSP_NOTFOUND:              return "DSP connection error.  Couldn't find the DSP unit specified.";
                case FMOD.RESULT.ERR_DSP_RESERVED:              return "DSP operation error.  Cannot perform operation on this DSP as it is reserved by the system.";
                case FMOD.RESULT.ERR_DSP_SILENCE:               return "DSP return code from a DSP process query callback.  Tells mixer silence would be produced from read, so go idle and not consume CPU.  Use this to optimize the DSP graph.";
                case FMOD.RESULT.ERR_DSP_TYPE:                  return "DSP operation cannot be performed on a DSP of this type.";
                case FMOD.RESULT.ERR_FILE_BAD:                  return "Error loading file.";
                case FMOD.RESULT.ERR_FILE_COULDNOTSEEK:         return "Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format.";
                case FMOD.RESULT.ERR_FILE_DISKEJECTED:          return "Media was ejected while reading.";
                case FMOD.RESULT.ERR_FILE_EOF:                  return "End of file unexpectedly reached while trying to read essential data (truncated?).";
                case FMOD.RESULT.ERR_FILE_ENDOFDATA:            return "End of current chunk reached while trying to read data.";
                case FMOD.RESULT.ERR_FILE_NOTFOUND:             return "File not found.";
                case FMOD.RESULT.ERR_FORMAT:                    return "Unsupported file or audio format.";
                case FMOD.RESULT.ERR_HEADER_MISMATCH:           return "There is a version mismatch between the FMOD header and either the FMOD Studio library or the FMOD Low Level library.";
                case FMOD.RESULT.ERR_HTTP:                      return "A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere.";
                case FMOD.RESULT.ERR_HTTP_ACCESS:               return "The specified resource requires authentication or is forbidden.";
                case FMOD.RESULT.ERR_HTTP_PROXY_AUTH:           return "Proxy authentication is required to access the specified resource.";
                case FMOD.RESULT.ERR_HTTP_SERVER_ERROR:         return "A HTTP server error occurred.";
                case FMOD.RESULT.ERR_HTTP_TIMEOUT:              return "The HTTP request timed out.";
                case FMOD.RESULT.ERR_INITIALIZATION:            return "FMOD was not initialized correctly to support this function.";
                case FMOD.RESULT.ERR_INITIALIZED:               return "Cannot call this command after System::init.";
                case FMOD.RESULT.ERR_INTERNAL:                  return "An error occured in the FMOD system. Use the logging version of FMOD for more information.";
                case FMOD.RESULT.ERR_INVALID_FLOAT:             return "Value passed in was a NaN, Inf or denormalized float.";
                case FMOD.RESULT.ERR_INVALID_HANDLE:            return "An invalid object handle was used.";
                case FMOD.RESULT.ERR_INVALID_PARAM:             return "An invalid parameter was passed to this function.";
                case FMOD.RESULT.ERR_INVALID_POSITION:          return "An invalid seek position was passed to this function.";
                case FMOD.RESULT.ERR_INVALID_SPEAKER:           return "An invalid speaker was passed to this function based on the current speaker mode.";
                case FMOD.RESULT.ERR_INVALID_SYNCPOINT:         return "The syncpoint did not come from this sound handle.";
                case FMOD.RESULT.ERR_INVALID_THREAD:            return "Tried to call a function on a thread that is not supported.";
                case FMOD.RESULT.ERR_INVALID_VECTOR:            return "The vectors passed in are not unit length, or perpendicular.";
                case FMOD.RESULT.ERR_MAXAUDIBLE:                return "Reached maximum audible playback count for this sound's soundgroup.";
                case FMOD.RESULT.ERR_MEMORY:                    return "Not enough memory or resources.";
                case FMOD.RESULT.ERR_MEMORY_CANTPOINT:          return "Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if FMOD_CREATECOMPRESSEDSAMPLE was used.";
                case FMOD.RESULT.ERR_NEEDS3D:                   return "Tried to call a command on a 2d sound when the command was meant for 3d sound.";
                case FMOD.RESULT.ERR_NEEDSHARDWARE:             return "Tried to use a feature that requires hardware support.";
                case FMOD.RESULT.ERR_NET_CONNECT:               return "Couldn't connect to the specified host.";
                case FMOD.RESULT.ERR_NET_SOCKET_ERROR:          return "A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere.";
                case FMOD.RESULT.ERR_NET_URL:                   return "The specified URL couldn't be resolved.";
                case FMOD.RESULT.ERR_NET_WOULD_BLOCK:           return "Operation on a non-blocking socket could not complete immediately.";
                case FMOD.RESULT.ERR_NOTREADY:                  return "Operation could not be performed because specified sound/DSP connection is not ready.";
                case FMOD.RESULT.ERR_OUTPUT_ALLOCATED:          return "Error initializing output device, but more specifically, the output device is already in use and cannot be reused.";
                case FMOD.RESULT.ERR_OUTPUT_CREATEBUFFER:       return "Error creating hardware sound buffer.";
                case FMOD.RESULT.ERR_OUTPUT_DRIVERCALL:         return "A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted.";
                case FMOD.RESULT.ERR_OUTPUT_FORMAT:             return "Soundcard does not support the specified format.";
                case FMOD.RESULT.ERR_OUTPUT_INIT:               return "Error initializing output device.";
                case FMOD.RESULT.ERR_OUTPUT_NODRIVERS:          return "The output device has no drivers installed.  If pre-init, FMOD_OUTPUT_NOSOUND is selected as the output mode.  If post-init, the function just fails.";
                case FMOD.RESULT.ERR_PLUGIN:                    return "An unspecified error has been returned from a plugin.";
                case FMOD.RESULT.ERR_PLUGIN_MISSING:            return "A requested output, dsp unit type or codec was not available.";
                case FMOD.RESULT.ERR_PLUGIN_RESOURCE:           return "A resource that the plugin requires cannot be allocated or found. (ie the DLS file for MIDI playback)";
                case FMOD.RESULT.ERR_PLUGIN_VERSION:            return "A plugin was built with an unsupported SDK version.";
                case FMOD.RESULT.ERR_RECORD:                    return "An error occurred trying to initialize the recording device.";
                case FMOD.RESULT.ERR_REVERB_CHANNELGROUP:       return "Reverb properties cannot be set on this channel because a parent channelgroup owns the reverb connection.";
                case FMOD.RESULT.ERR_REVERB_INSTANCE:           return "Specified instance in FMOD_REVERB_PROPERTIES couldn't be set. Most likely because it is an invalid instance number or the reverb doesn't exist.";
                case FMOD.RESULT.ERR_SUBSOUNDS:                 return "The error occurred because the sound referenced contains subsounds when it shouldn't have, or it doesn't contain subsounds when it should have.  The operation may also not be able to be performed on a parent sound.";
                case FMOD.RESULT.ERR_SUBSOUND_ALLOCATED:        return "This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first.";
                case FMOD.RESULT.ERR_SUBSOUND_CANTMOVE:         return "Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file.";
                case FMOD.RESULT.ERR_TAGNOTFOUND:               return "The specified tag could not be found or there are no tags.";
                case FMOD.RESULT.ERR_TOOMANYCHANNELS:           return "The sound created exceeds the allowable input channel count.  This can be increased using the 'maxinputchannels' parameter in System::setSoftwareFormat.";
                case FMOD.RESULT.ERR_TRUNCATED:                 return "The retrieved string is too long to fit in the supplied buffer and has been truncated.";
                case FMOD.RESULT.ERR_UNIMPLEMENTED:             return "Something in FMOD hasn't been implemented when it should be. Contact support.";
                case FMOD.RESULT.ERR_UNINITIALIZED:             return "This command failed because System::init or System::setDriver was not called.";
                case FMOD.RESULT.ERR_UNSUPPORTED:               return "A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified.";
                case FMOD.RESULT.ERR_VERSION:                   return "The version number of this file format is not supported.";
                case FMOD.RESULT.ERR_EVENT_ALREADY_LOADED:      return "The specified bank has already been loaded.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_BUSY:     return "The live update connection failed due to the game already being connected.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_MISMATCH: return "The live update connection failed due to the game data being out of sync with the tool.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_TIMEOUT:  return "The live update connection timed out.";
                case FMOD.RESULT.ERR_EVENT_NOTFOUND:            return "The requested event, bus or vca could not be found.";
                case FMOD.RESULT.ERR_STUDIO_UNINITIALIZED:      return "The Studio::System object is not yet initialized.";
                case FMOD.RESULT.ERR_STUDIO_NOT_LOADED:         return "The specified resource is not loaded, so it can't be unloaded.";
                case FMOD.RESULT.ERR_INVALID_STRING:            return "An invalid string was passed to this function.";
                case FMOD.RESULT.ERR_ALREADY_LOCKED:            return "The specified resource is already locked.";
                case FMOD.RESULT.ERR_NOT_LOCKED:                return "The specified resource is not locked, so it can't be unlocked.";
                case FMOD.RESULT.ERR_RECORD_DISCONNECTED:       return "The specified recording driver has been disconnected.";
                case FMOD.RESULT.ERR_TOOMANYSAMPLES:            return "The length provided exceed the allowable limit.";
                default:                                        return "Unknown error.";
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/fmod_errors.cs.meta
================================================
fileFormatVersion: 2
guid: 6e0992509b0077e479d2da05c8f52eb0
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/fmod_studio.cs.meta
================================================
fileFormatVersion: 2
guid: ae7eb0b6a2bff364b9c1fae52173e74c
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/FMODEventPlayable.cs
================================================
﻿#if UNITY_TIMELINE_EXIST

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;
using UnityEngine.Serialization;

namespace FMODUnity
{
    [System.Serializable]
    public class FMODEventPlayable : PlayableAsset, ITimelineClipAsset
    {
        [FormerlySerializedAs("template")]
        public FMODEventPlayableBehavior Template = new FMODEventPlayableBehavior();

        [FormerlySerializedAs("eventLength")]
        public float EventLength; //In seconds.

        [Obsolete("Use the eventReference field instead")]
        [SerializeField]
        public string eventName;

        [FormerlySerializedAs("eventReference")]
        [SerializeField]
        public EventReference EventReference;

        [FormerlySerializedAs("stopType")]
        [SerializeField]
        public STOP_MODE StopType;

        [FormerlySerializedAs("parameters")]
        [SerializeField]
        public ParamRef[] Parameters = new ParamRef[0];

        [NonSerialized]
        public bool CachedParameters = false;

        public static event System.EventHandler<EventArgs> OnCreatePlayable;

        private FMODEventPlayableBehavior behavior;

        public GameObject TrackTargetObject { get; set; }

        public override double duration
        {
            get
            {
                if (EventReference.IsNull)
                {
                    return base.duration;
                }
                else
                {
                    return EventLength;
                }
            }
        }

        public ClipCaps clipCaps
        {
            get { return ClipCaps.None; }
        }

        public TimelineClip OwningClip { get; set; }

        public void LinkParameters(FMOD.Studio.EventDescription eventDescription)
        {
#if UNITY_EDITOR
            if (!EventReference.IsNull)
#else
            if (!CachedParameters && !EventReference.IsNull)
#endif
            {
                for (int i = 0; i < Parameters.Length; i++)
                {
                    FMOD.Studio.PARAMETER_DESCRIPTION parameterDescription;
                    eventDescription.getParameterDescriptionByName(Parameters[i].Name, out parameterDescription);
                    Parameters[i].ID = parameterDescription.id;
                }

                List<ParameterAutomationLink> parameterLinks = Template.ParameterLinks;

                for (int i = 0; i < parameterLinks.Count; i++)
                {
                    FMOD.Studio.PARAMETER_DESCRIPTION parameterDescription;
                    eventDescription.getParameterDescriptionByName(parameterLinks[i].Name, out parameterDescription);
                    parameterLinks[i].ID = parameterDescription.id;
                }

                CachedParameters = true;
            }
        }

        public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
        {
            if (Application.isPlaying)
            {
                LinkParameters(RuntimeManager.GetEventDescription(EventReference));
            }
            else
            {
                // Handled by the editor auditioning system.
                EventArgs args = new EventArgs();
                OnCreatePlayable.Invoke(this, args);
            }

            var playable = ScriptPlayable<FMODEventPlayableBehavior>.Create(graph, Template);
            behavior = playable.GetBehaviour();

            behavior.TrackTargetObject = TrackTargetObject;
            behavior.EventReference = EventReference;
            behavior.StopType = StopType;
            behavior.Parameters = Parameters;
            behavior.OwningClip = OwningClip;

            return playable;
        }

#if UNITY_EDITOR
        public void UpdateEventDuration(float duration)
        {
            EventLength = duration / 1000f;
        }

        public void OnValidate()
        {
            if (OwningClip != null)
            {
                if (EventReference.IsNull)
                {
                    OwningClip.displayName = "FMODEventPlayable";
                }
                else
                {
                    if (EventReference.Path == null)
                    {
                        EventReference.Path = "";
                    }
                    else
                    {
                        int index = EventReference.Path.LastIndexOf("/");
                        OwningClip.displayName = EventReference.Path.Substring(index + 1);
                    }
                }
            }
            if (behavior != null)
            {
                behavior.EventReference = EventReference;
            }
        }
#endif //UNITY_EDITOR
    }

    public enum STOP_MODE : int
    {
        AllowFadeout,
        Immediate,
        None
    }

    [Serializable]
    public class ParameterAutomationLink
    {
        public string Name;
        public FMOD.Studio.PARAMETER_ID ID;
        public int Slot;
    }

    [Serializable]
    public class FMODEventPlayableBehavior : PlayableBehaviour
    {
        public FMODEventPlayableBehavior()
        {
            CurrentVolume = 1;
        }

        public class EventArgs : System.EventArgs
        {
            public FMOD.Studio.EventInstance eventInstance { get; set; }
        }

        public static event System.EventHandler<EventArgs> Enter;
        public static event System.EventHandler<EventArgs> Exit;
        public static event System.EventHandler<EventArgs> GraphStop;

        [FormerlySerializedAs("eventReference")]
        public EventReference EventReference;

        [FormerlySerializedAs("stopType")]
        public STOP_MODE StopType = STOP_MODE.AllowFadeout;

        [FormerlySerializedAs("parameters")]
        [NotKeyable]
        public ParamRef[] Parameters = new ParamRef[0];

        [FormerlySerializedAs("parameterLinks")]
        public List<ParameterAutomationLink> ParameterLinks = new List<ParameterAutomationLink>();

        [NonSerialized]
        public GameObject TrackTargetObject;

        [NonSerialized]
        public TimelineClip OwningClip;

        [FormerlySerializedAs("parameterAutomation")]
        public AutomatableSlots ParameterAutomation;

        private bool isPlayheadInside = false;

        private FMOD.Studio.EventInstance eventInstance;

        public float ClipStartTime { get; private set; } = 0.0f;

        public float CurrentVolume { get; private set; }

        protected void PlayEvent()
        {
            if (!EventReference.IsNull)
            {
                eventInstance = RuntimeManager.CreateInstance(EventReference);

                // Only attach to object if the game is actually playing, not auditioning.
                if (Application.isPlaying && TrackTargetObject)
                {
#if UNITY_PHYSICS_EXIST
                    if (TrackTargetObject.GetComponent<Rigidbody>())
                    {
                        RuntimeManager.AttachInstanceToGameObject(eventInstance, TrackTargetObject, TrackTargetObject.GetComponent<Rigidbody>());
                    }
                    else
#endif
#if UNITY_PHYSICS2D_EXIST
                    if (TrackTargetObject.GetComponent<Rigidbody2D>())
                    {
                        RuntimeManager.AttachInstanceToGameObject(eventInstance, TrackTargetObject, TrackTargetObject.GetComponent<Rigidbody2D>());
                    }
                    else
#endif
                    {
                        RuntimeManager.AttachInstanceToGameObject(eventInstance, TrackTargetObject);
                    }
                }
                else
                {
                    eventInstance.set3DAttributes(RuntimeUtils.To3DAttributes(Vector3.zero));
                }

                foreach (var param in Parameters)
                {
                    eventInstance.setParameterByID(param.ID, param.Value);
                }

                eventInstance.setVolume(CurrentVolume);
                eventInstance.setTimelinePosition((int)(ClipStartTime * 1000.0f));
                eventInstance.start();
            }
        }

        protected virtual void OnEnter()
        {
            if (!isPlayheadInside)
            {
                isPlayheadInside = true;

                if (Application.isPlaying)
                {
                    PlayEvent();
                }
                else
                {
                    // Handled by the editor auditioning system.
                    EventArgs args = new EventArgs();
                    Enter.Invoke(this, args);
                    eventInstance = args.eventInstance;
                }
            }
        }

        protected virtual void OnExit()
        {
            if (isPlayheadInside)
            {
                isPlayheadInside = false;

                if (Application.isPlaying)
                {
                    if (eventInstance.isValid())
                    {
                        if (StopType != STOP_MODE.None)
                        {
                            eventInstance.stop(StopType == STOP_MODE.Immediate ? FMOD.Studio.STOP_MODE.IMMEDIATE : FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
                        }
                        eventInstance.release();
                        eventInstance.clearHandle();
                    }
                }
                else
                {
                    // Handled by the editor auditioning system.
                    EventArgs args = new EventArgs();
                    args.eventInstance = eventInstance;
                    Exit.Invoke(this, args);
                }
            }
        }

        public override void ProcessFrame(Playable playable, FrameData info, object playerData)
        {
            if (eventInstance.isValid())
            {
                foreach (ParameterAutomationLink link in ParameterLinks)
                {
                    float value = ParameterAutomation.GetValue(link.Slot);
                    eventInstance.setParameterByID(link.ID, value);
                }
            }
        }

        public void UpdateBehavior(float time, float volume)
        {
            if (volume != CurrentVolume)
            {
                CurrentVolume = volume;

                if (eventInstance.isValid())
                {
                    eventInstance.setVolume(volume);
                }
            }

            if ((time >= OwningClip.start) && (time < OwningClip.end))
            {
                ClipStartTime = time - (float)OwningClip.start;
                OnEnter();
            }
            else
            {
                OnExit();
            }
        }

        public override void OnGraphStop(Playable playable)
        {
            isPlayheadInside = false;

            if (Application.isPlaying)
            {
                if (eventInstance.isValid())
                {
                    eventInstance.stop(FMOD.Studio.STOP_MODE.IMMEDIATE);
                    eventInstance.release();
                    RuntimeManager.StudioSystem.update();
                }
            }
            else
            {
                // Handled by the editor auditioning system.
                EventArgs args = new EventArgs();
                args.eventInstance = eventInstance;
                GraphStop.Invoke(this, args);
            }
        }
    }
}
#endif



================================================
FILE: Assets/Plugins/FMOD/src/FMODEventPlayable.cs.meta
================================================
fileFormatVersion: 2
guid: 987a467495df9d942b56b1b51381d095
timeCreated: 1523230466
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: 392af304825cbe847bbf4e603852e4dd, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/FMODEventTrack.cs
================================================
﻿#if UNITY_TIMELINE_EXIST

using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace FMODUnity
{
    [TrackColor(0.066f, 0.134f, 0.244f)]
    [TrackClipType(typeof(FMODEventPlayable))]
    [TrackBindingType(typeof(GameObject))]
    [DisplayName("FMOD/Event Track")]
    public class FMODEventTrack : TrackAsset
    {
        public FMODEventMixerBehaviour template = new FMODEventMixerBehaviour();

        public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
        {
            var director = go.GetComponent<PlayableDirector>();
            var trackTargetObject = director.GetGenericBinding(this) as GameObject;

            foreach (var clip in GetClips())
            {
                var playableAsset = clip.asset as FMODEventPlayable;

                if (playableAsset)
                {
                    playableAsset.TrackTargetObject = trackTargetObject;
                    playableAsset.OwningClip = clip;
                }
            }

            var scriptPlayable = ScriptPlayable<FMODEventMixerBehaviour>.Create(graph, template, inputCount);
            return scriptPlayable;
        }
    }

    [Serializable]
    public class FMODEventMixerBehaviour : PlayableBehaviour
    {
        [Range(0, 1)]
        public float volume = 1;

        public override void ProcessFrame(Playable playable, FrameData info, object playerData)
        {
#if UNITY_EDITOR
            /*
             * Process frame is called from OnGUI() when auditioning.
             * Check playing to avoid retriggering sounds while scrubbing or repainting.
             */
            bool playing = playable.GetGraph().IsPlaying();
            if (!playing)
            {
                return;
            }
#endif //UNITY_EDITOR

            int inputCount = playable.GetInputCount();
            float time = (float)playable.GetGraph().GetRootPlayable(0).GetTime();

            for (int i = 0; i < inputCount; i++)
            {
                ScriptPlayable<FMODEventPlayableBehavior> inputPlayable = (ScriptPlayable<FMODEventPlayableBehavior>)playable.GetInput(i);
                FMODEventPlayableBehavior input = inputPlayable.GetBehaviour();

                input.UpdateBehavior(time, volume);
            }
        }
    }
}
#endif



================================================
FILE: Assets/Plugins/FMOD/src/FMODEventTrack.cs.meta
================================================
fileFormatVersion: 2
guid: 133253f56854570409c222a87786b263
timeCreated: 1523230466
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {fileID: 2800000, guid: a4edfa5854cdec34b98b1c55f0562bdd, type: 3}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/FMODRuntimeManagerOnGUIHelper.cs
================================================
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace FMODUnity
{
    public class FMODRuntimeManagerOnGUIHelper : MonoBehaviour
    {
        public RuntimeManager TargetRuntimeManager = null;

        private void OnGUI()
        {
            if (TargetRuntimeManager)
            {
                TargetRuntimeManager.ExecuteOnGUI();
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/FMODRuntimeManagerOnGUIHelper.cs.meta
================================================
fileFormatVersion: 2
guid: 4417faacebce0de4fbde25ec23055cf4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/ParamRef.cs
================================================
﻿using System;

namespace FMODUnity
{
    [Serializable]
    public class ParamRef
    {
        public string Name;
        public float Value;
        public FMOD.Studio.PARAMETER_ID ID;
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/ParamRef.cs.meta
================================================
fileFormatVersion: 2
guid: 00e1a9817a5d9844796d7c313b1ab197
timeCreated: 1444192631
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/ParamRefAttribute.cs
================================================
﻿using UnityEngine;

namespace FMODUnity
{
    public class ParamRefAttribute : PropertyAttribute
    {
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/ParamRefAttribute.cs.meta
================================================
fileFormatVersion: 2
guid: 7ae6224668d1647429723f89e10d593f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Platform.cs
================================================
﻿using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMODUnity
{
    public class PlatformCallbackHandler : ScriptableObject
    {
        // A hook for custom initialization logic. RuntimeManager.Initialize calls this
        // just before calling system.Initialize.
        // Call reportResult() with the result of each FMOD call to use FMOD's error handling logic.
        public virtual void PreInitialize(FMOD.Studio.System system, Action<FMOD.RESULT, string> reportResult)
        {
        }
    }

    // This class holds per-platform settings and provides hooks for platform-specific behaviour.
    // Each platform has a parent platform, forming a hierarchy that is rooted at PlatformDefault.
    // By default a platform inherits all of its properties from its parent platform; this behaviour
    // can be overridden for each property.
    //
    // There is at least one concrete derived class for each supported platform; these classes use
    // [InitializeOnLoad] and a static constructor to register themselves as supported platforms by
    // calling Settings.AddPlatformTemplate. The user can also create instances of the PlatformGroup
    // class and use them to group platforms that have settings in common.
    public abstract class Platform : ScriptableObject
    {
        internal const float DefaultPriority = 0;

#if UNITY_EDITOR
        internal const int MaximumCoreCount = 16;

        internal static readonly FileLayout[] OldFileLayouts = {
            FileLayout.Release_1_10,
            FileLayout.Release_2_0,
            FileLayout.Release_2_1,
        };
#endif

        // These need to match the function called by LoadStaticPlugins
        internal const string RegisterStaticPluginsClassName = "StaticPluginManager";
        internal const string RegisterStaticPluginsFunctionName = "Register";

        // This is a persistent identifier. It is used:
        // * To link platforms together at load time
        // * To avoid creating duplicate platforms from templates (in Settings.OnEnable)
        // * As a key for SettingsEditor UI state
        // It should be kept stable for concrete platforms (like PlatformWindows) to support
        // settings migration in the future.
        [SerializeField]
        private string identifier;

        [SerializeField]
        private string parentIdentifier;

        [SerializeField]
        private bool active = false;

        [SerializeField]
        protected PropertyStorage Properties = new PropertyStorage();

        [SerializeField]
        [FormerlySerializedAs("outputType")]
        internal string OutputTypeName;

        private static List<ThreadAffinityGroup> StaticThreadAffinities = new List<ThreadAffinityGroup>();

        [SerializeField]
        private PropertyThreadAffinityList threadAffinities = new PropertyThreadAffinityList();

#if UNITY_EDITOR
        [SerializeField]
        private float displaySortOrder;

        [SerializeField]
        private List<string> childIdentifiers = new List<string>();
#else
        // The parent platform from which this platform inherits its property values.
        [NonSerialized]
        public Platform Parent;
#endif

        internal string Identifier
        {
            get
            {
                return identifier;
            }

            set
            {
                identifier = value;
            }
        }

        // The display name to show for this platform in the UI.
        internal abstract string DisplayName { get; }

        // Declares the Unity RuntimePlatforms this platform implements.
        internal abstract void DeclareRuntimePlatforms(Settings settings);

#if UNITY_EDITOR
        // The Unity BuildTargets this platform implements.
        // Returns BuildTarget.NoTarget if the correct value is not defined, as some BuildTarget
        // values are only defined in specific circumstances (e.g. Stadia required Unity 2019.3).
        internal abstract IEnumerable<BuildTarget> GetBuildTargets();

        // The old FMOD platform identifier that this platform corresponds to, for settings migration.
        internal abstract Legacy.Platform LegacyIdentifier { get; }
#endif

        // The priority to use when finding a platform to support the current Unity runtime
        // platform (higher priorities are tried first).
        internal virtual float Priority { get { return DefaultPriority; } }

        // Determines whether this platform matches the current environment. When more than one
        // platform implements the current Unity runtime platform, FMOD for Unity will use the
        // highest-priority platform that returns true from MatchesCurrentEnvironment.
        internal virtual bool MatchesCurrentEnvironment { get { return true; } }

        // Whether this platform is a fixed part of the FMOD for Unity settings, or can be
        // added/removed by the user.
        internal virtual bool IsIntrinsic { get { return false; } }

        // A hook for platform-specific initialization logic. RuntimeManager.Initialize calls this
        // before calling FMOD.Studio.System.create.
        internal virtual void PreSystemCreate(Action<FMOD.RESULT, string> reportResult)
        {
        }

        // A hook for platform-specific initialization logic. RuntimeManager.Initialize calls this
        // just before calling studioSystem.Initialize.
        internal virtual void PreInitialize(FMOD.Studio.System studioSystem)
        {
        }

        // The folder in which FMOD .bank files are stored. Used when loading banks.
        internal virtual string GetBankFolder()
        {
            return Application.streamingAssetsPath;
        }

#if UNITY_EDITOR
        [Flags]
        public enum BinaryType
        {
            Release = 1,
            Logging = 2,
            Optional = 4,
            AllVariants = 8,
            All = Release | Logging | Optional | AllVariants
        }

        protected virtual IEnumerable<string> GetBinaryPaths(BuildTarget buildTarget, BinaryType binaryType, string prefix)
        {
            foreach (BinaryFileInfo info in GetBinaryFileInfo(buildTarget, binaryType))
            {
                yield return info.LatestLocation();
            }
        }

        internal abstract class FileInfo
        {
            public FileInfo(FileRecord fileRecord, BinaryType type)
            {
                this.fileRecord = fileRecord;
                this.type = type;
            }

            public readonly BinaryType type;

            private readonly FileRecord fileRecord;

            public string LatestLocation()
            {
                return GetLocation(FileLayout.Latest);
            }

            public IEnumerable<string> OldLocations()
            {
                foreach (FileLayout layout in OldFileLayouts)
                {
                    string location = GetLocation(layout);

                    if (location != null)
                    {
                        yield return location;
                    }
                }
            }

            private string GetLocation(FileLayout layout)
            {
                string basePath = GetBasePath(layout);

                if (basePath == null)
                {
                    return null;
                }

                bool absolute;
                string path;
                fileRecord.GetPath(layout, out path, out absolute);

                if (absolute)
                {
                    return path;
                }
                else
                {
                    return string.Format("{0}/{1}", basePath, path);
                }
            }

            protected abstract string GetBasePath(FileLayout layout);
        }

        internal class BinaryFileInfo : FileInfo
        {
            public BinaryFileInfo(Platform platform, FileRecord fileRecord, BuildTarget buildTarget, BinaryType type)
                : base(fileRecord, type)
            {
                this.platform = platform;
                this.buildTarget = buildTarget;
            }

            private readonly Platform platform;
            private readonly BuildTarget buildTarget;

            protected override string GetBasePath(FileLayout layout)
            {
                BinaryAssetFolderInfo info = platform.GetBinaryAssetFolder(buildTarget);

                if (layout < info.oldestLayout)
                {
                    return null;
                }

                switch (layout)
                {
                    case FileLayout.Release_1_10:
                        return info.path_1_10;
                    case FileLayout.Release_2_0:
                        return string.Format("Assets/Plugins/FMOD/lib/{0}", info.baseName);
                    case FileLayout.Release_2_1:
                    case FileLayout.Release_2_2:
                        return $"{RuntimeUtils.PluginBasePath}/platforms/{info.baseName}/lib";
                    default:
                        throw new ArgumentException("Unrecognised file layout: " + layout);
                }
            }
        }

        public struct FileRecord
        {
            public FileRecord(string latestPath)
            {
                this.latestPath = latestPath;
                pathVersions = null;
            }

            public FileRecord WithAbsoluteVersion(FileLayout layout, string path)
            {
                AddVersion(layout, path, true);
                return this;
            }

            public FileRecord WithRelativeVersion(FileLayout layout, string path)
            {
                AddVersion(layout, path, false);
                return this;
            }

            private void AddVersion(FileLayout layout, string path, bool absolute)
            {
                if (pathVersions == null)
                {
                    pathVersions = new Dictionary<FileLayout, PathInfo>();
                }

                pathVersions.Add(layout, new PathInfo() { path = path, absolute = absolute });
            }

            public void GetPath(FileLayout layout, out string path, out bool absolute)
            {
                if (pathVersions != null)
                {
                    PathInfo pathForLayout;

                    if (pathVersions.TryGetValue(layout, out pathForLayout))
                    {
                        absolute = pathForLayout.absolute;
                        path = pathForLayout.path;
                        return;
                    }
                }

                absolute = false;
                path = latestPath;
            }

            private struct PathInfo
            {
                public string path;
                public bool absolute;
            }

            private readonly string latestPath;
            private Dictionary<FileLayout, PathInfo> pathVersions;
        }

        internal IEnumerable<BinaryFileInfo> GetBinaryFileInfo(BuildTarget buildTarget, BinaryType binaryType)
        {
            bool allVariants = (binaryType & BinaryType.AllVariants) == BinaryType.AllVariants;

            if ((binaryType & BinaryType.Release) == BinaryType.Release)
            {
                foreach (FileRecord record in GetBinaryFiles(buildTarget, allVariants, ""))
                {
                    yield return CreateFileInfo(record, buildTarget, BinaryType.Release);
                }
            }

            if ((binaryType & BinaryType.Logging) == BinaryType.Logging)
            {
                foreach (FileRecord record in GetBinaryFiles(buildTarget, allVariants, "L"))
                {
                    yield return CreateFileInfo(record, buildTarget, BinaryType.Logging);
                }
            }

            if ((binaryType & BinaryType.Optional) == BinaryType.Optional)
            {
                foreach (FileRecord record in GetOptionalBinaryFiles(buildTarget, allVariants))
                {
                    yield return CreateFileInfo(record, buildTarget, BinaryType.Optional);
                }
            }
        }

        internal class SourceFileInfo : FileInfo
        {
            public SourceFileInfo(Platform platform, FileRecord fileRecord)
                : base(fileRecord, BinaryType.Optional)
            {
                this.platform = platform;
            }

            private readonly Platform platform;

            protected override string GetBasePath(FileLayout layout)
            {
                BinaryAssetFolderInfo info = platform.GetBinaryAssetFolder(platform.GetBuildTargets().First());

                if (layout < info.oldestLayout)
                {
                    return null;
                }

                switch (layout)
                {
                    case FileLayout.Release_1_10:
                        return "Plugins/FMOD/Wrapper";
                    case FileLayout.Release_2_0:
                        return "Plugins/FMOD/src/Runtime/wrapper";
                    case FileLayout.Release_2_1:
                    case FileLayout.Release_2_2:
                        return $"{RuntimeUtils.PluginBasePath}/platforms/{info.baseName}/src";
                    default:
                        throw new ArgumentException("Unrecognised file layout: " + layout);
                }
            }
        }

        internal IEnumerable<SourceFileInfo> GetSourceFileInfo()
        {
            foreach (FileRecord record in GetSourceFiles())
            {
                yield return new SourceFileInfo(this, record);
            }
        }

        internal BinaryFileInfo CreateFileInfo(FileRecord record, BuildTarget buildTarget, BinaryType binaryType)
        {
            return new BinaryFileInfo(this, record, buildTarget, binaryType);
        }

        internal virtual IEnumerable<string> GetObsoleteAssetPaths()
        {
            foreach (string path in GetObsoleteFiles())
            {
                yield return $"{RuntimeUtils.PluginBasePath}/{path}";
                yield return $"{RuntimeUtils.PluginBasePathDefault}/{path}";
            }
        }

        // Called by Settings.CanBuildTarget to get the required binaries for the current
        // build target and logging state.
        internal virtual IEnumerable<string> GetBinaryFilePaths(BuildTarget buildTarget, BinaryType binaryType)
        {
            return GetBinaryPaths(buildTarget, binaryType, RuntimeUtils.PluginBasePath);
        }

        // Called by Settings.SelectBinaries to get:
        // * The required and optional binaries for the current build target and logging state;
        //   these get enabled.
        // * All binaries; any that weren't enabled in the previous step get disabled.
        internal virtual IEnumerable<string> GetBinaryAssetPaths(BuildTarget buildTarget, BinaryType binaryType)
        {
            return GetBinaryPaths(buildTarget, binaryType, RuntimeUtils.PluginBasePath);
        }

        public enum FileLayout : uint
        {
            Release_1_10,
            Release_2_0,
            Release_2_1,
            Release_2_2,
            Latest = Release_2_2,
        }

        protected class BinaryAssetFolderInfo
        {
            public BinaryAssetFolderInfo(string baseName, string path_1_10)
            {
                this.baseName = baseName;
                this.path_1_10 = path_1_10;
                this.oldestLayout = FileLayout.Release_1_10;
            }

            public BinaryAssetFolderInfo(string baseName, FileLayout oldestLayout)
            {
                this.baseName = baseName;
                this.path_1_10 = null;
                this.oldestLayout = oldestLayout;
            }

            public string baseName { get; private set; }
            public string path_1_10 { get; private set; }
            public FileLayout oldestLayout { get; private set; }
        }

        protected abstract BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget);

        protected abstract IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix);

        protected virtual IEnumerable<FileRecord> GetOptionalBinaryFiles(BuildTarget buildTarget, bool allVariants)
        {
            yield break;
        }

        protected virtual IEnumerable<FileRecord> GetSourceFiles()
        {
            yield break;
        }

        protected virtual IEnumerable<string> GetObsoleteFiles()
        {
            yield break;
        }

        internal virtual bool IsFMODStaticallyLinked { get { return false; } }

        internal virtual bool SupportsAdditionalCPP(BuildTarget target)
        {
            return true;
        }
#endif

        // The base path for FMOD plugins when in a standalone player.
        protected virtual string GetPluginBasePath()
        {
            return string.Format("{0}/Plugins", Application.dataPath);
        }

        // Returns the full path for an FMOD plugin.
        internal virtual string GetPluginPath(string pluginName)
        {
            throw new NotImplementedException(string.Format("Plugins are not implemented on platform {0}", Identifier));
        }

        // Loads static and dynamic FMOD plugins for this platform.
        internal virtual void LoadPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            LoadDynamicPlugins(coreSystem, reportResult);
            LoadStaticPlugins(coreSystem, reportResult);
        }

        // Loads dynamic FMOD plugins for this platform.
        internal virtual void LoadDynamicPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            List<string> pluginNames = Plugins;

            if (pluginNames == null)
            {
                return;
            }

            foreach (string pluginName in pluginNames)
            {
                if (string.IsNullOrEmpty(pluginName))
                {
                    continue;
                }

                string pluginPath = GetPluginPath(pluginName);
                uint handle;

                FMOD.RESULT result = coreSystem.loadPlugin(pluginPath, out handle);

                if (result == FMOD.RESULT.ERR_FILE_BAD || result == FMOD.RESULT.ERR_FILE_NOTFOUND)
                {
                    if (Environment.Is64BitProcess)
                    {
                        // Add a "64" suffix and try again
                        string pluginPath64 = GetPluginPath(pluginName + "64");
                        result = coreSystem.loadPlugin(pluginPath64, out handle);
                    }
                }

                reportResult(result, string.Format("Loading plugin '{0}' from '{1}'", pluginName, pluginPath));
            }
        }

        // Loads static FMOD plugins for this platform.
        internal virtual void LoadStaticPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            if (StaticPlugins.Count > 0)
            {
#if !UNITY_EDITOR && ENABLE_IL2CPP
                // We use reflection here to avoid compile errors if the plugin registration code doesn't exist.
                // It should be generated by Settings.PreprocessStaticPlugins(), which is called from
                // IPreprocessBuildWithReport.OnPreprocessBuild(). However, some compilation scenarios
                // (such as AddressableAssetSettings.BuildPlayerContent()) don't call OnPreprocessBuild(),
                // so we can't generate the plugin registration code.

                string className = string.Format("FMODUnity.{0}", RegisterStaticPluginsClassName);
                Type type = Type.GetType(className);

                if (type == null)
                {
                    RuntimeUtils.DebugLogWarningFormat(
                        "FMOD: {0} static plugins specified, but the {1} class was not found.",
                        StaticPlugins.Count, className);
                    return;
                }

                MethodInfo method = type.GetMethod(RegisterStaticPluginsFunctionName,
                    BindingFlags.Public | BindingFlags.Static);

                if (method == null)
                {
                    RuntimeUtils.DebugLogWarningFormat(
                        "FMOD: {0} static plugins specified, but the {1}.{2} method was not found.",
                        StaticPlugins.Count, className, RegisterStaticPluginsFunctionName);
                    return;
                }

                method.Invoke(null, new object[] { coreSystem, reportResult });
#else
                RuntimeUtils.DebugLogWarningFormat(
                    "FMOD: {0} static plugins specified, but static plugins are only supported on the IL2CPP scripting backend",
                    StaticPlugins.Count);
#endif
            }
        }

        // Ensures that this platform has properties.
        internal void AffirmProperties()
        {
            if (!active)
            {
                Properties = new PropertyStorage();
                InitializeProperties();
                active = true;
            }
        }

        // Clears this platform's properties.
        internal void ClearProperties()
        {
            if (active)
            {
                Properties = new PropertyStorage();
                active = false;
#if UNITY_EDITOR
                DisplaySortOrder = 0;
#endif
            }
        }

        // Initializes this platform's properties to their default values.
        internal virtual void InitializeProperties()
        {
            if (!IsIntrinsic)
            {
                ParentIdentifier = PlatformDefault.ConstIdentifier;
            }
        }

        // Ensures that this platform's properties are valid after loading from file.
        internal virtual void EnsurePropertiesAreValid()
        {
            if (!IsIntrinsic && string.IsNullOrEmpty(ParentIdentifier))
            {
                ParentIdentifier = PlatformDefault.ConstIdentifier;
            }
        }

        internal string ParentIdentifier
        {
            get
            {
                return parentIdentifier;
            }

            set
            {
                parentIdentifier = value;
            }
        }

#if UNITY_EDITOR
        internal float DisplaySortOrder
        {
            get
            {
                return displaySortOrder;
            }

            set
            {
                displaySortOrder = value;
            }
        }
#endif

        internal bool IsLiveUpdateEnabled
        {
            get
            {
#if DEVELOPMENT_BUILD || UNITY_EDITOR
                return LiveUpdate != TriStateBool.Disabled;
#else
                return LiveUpdate == TriStateBool.Enabled;
#endif
            }
        }

        internal bool IsOverlayEnabled
        {
            get
            {
#if DEVELOPMENT_BUILD || UNITY_EDITOR
                return Overlay != TriStateBool.Disabled;
#else
                return Overlay == TriStateBool.Enabled;
#endif
            }
        }

        // A property value that can be inherited from the parent or overridden.
        public class Property<T>
        {
            public T Value;
            public bool HasValue;
        }

        // These stub classes are needed because Unity can't serialize generic classes
        [Serializable]
        public class PropertyBool : Property<TriStateBool>
        {
        }

        [Serializable]
        public class PropertyScreenPosition : Property<ScreenPosition>
        {
        }

        [Serializable]
        public class PropertyInt : Property<int>
        {
        }

        [Serializable]
        public class PropertySpeakerMode : Property<FMOD.SPEAKERMODE>
        {
        }

        [Serializable]
        public class PropertyString : Property<string>
        {
        }

        [Serializable]
        public class PropertyStringList : Property<List<string>>
        {
        }

        [Serializable]
        public class PropertyCallbackHandler : Property<PlatformCallbackHandler>
        {
        }

        internal interface PropertyOverrideControl
        {
            bool HasValue(Platform platform);
            void Clear(Platform platform);
        }

        // This class provides access to a specific property on any Platform object; the property to
        // operate on is determined by the Getter function. This allows client code to operate on
        // platform properties in a generic manner.
        internal struct PropertyAccessor<T> : PropertyOverrideControl
        {
            private readonly Func<PropertyStorage, Property<T>> Getter;
            private readonly T DefaultValue;

            public PropertyAccessor(Func<PropertyStorage, Property<T>> getter, T defaultValue)
            {
                Getter = getter;
                DefaultValue = defaultValue;
            }

            // Determine whether the property has a value in the given platform, or is inherited
            // from the parent.
            public bool HasValue(Platform platform)
            {
                return platform.Active && Getter(platform.Properties).HasValue;
            }

            // Get the (possibly inherited) value of the property for the given platform.
            public T Get(Platform platform)
            {
                for (Platform current = platform; current != null; current = current.Parent)
                {
                    if (current.Active)
                    {
                        Property<T> property = Getter(current.Properties);

                        if (property.HasValue)
                        {
                            return property.Value;
                        }
                    }
                }

#if UNITY_EDITOR
                if (platform is PlatformPlayInEditor)
                {
                    return Get(Settings.EditorSettings.CurrentEditorPlatform);
                }
#endif

                return DefaultValue;
            }

            // Set the value of the property in the given platform, so it is not inherited from the
            // platform's parent.
            public void Set(Platform platform, T value)
            {
                Property<T> property = Getter(platform.Properties);

                property.Value = value;
                property.HasValue = true;
            }

            // Clear the value of the property in the given platform, so it is inherited from the
            // platform's parent.
            public void Clear(Platform platform)
            {
                Getter(platform.Properties).HasValue = false;
            }
        }

        // This class stores all of the inheritable properties for a platform.
        [Serializable]
        public class PropertyStorage
        {
            public PropertyBool LiveUpdate = new PropertyBool();
            public PropertyInt LiveUpdatePort = new PropertyInt();
            public PropertyBool Overlay = new PropertyBool();
            public PropertyScreenPosition OverlayPosition = new PropertyScreenPosition();
            public PropertyInt OverlayFontSize = new PropertyInt();
            public PropertyBool Logging = new PropertyBool();
            public PropertyInt SampleRate = new PropertyInt();
            public PropertyString BuildDirectory = new PropertyString();
            public PropertySpeakerMode SpeakerMode = new PropertySpeakerMode();
            public PropertyInt VirtualChannelCount = new PropertyInt();
            public PropertyInt RealChannelCount = new PropertyInt();
            public PropertyInt DSPBufferLength = new PropertyInt();
            public PropertyInt DSPBufferCount = new PropertyInt();
            public PropertyStringList Plugins = new PropertyStringList();
            public PropertyStringList StaticPlugins = new PropertyStringList();
            public PropertyCallbackHandler CallbackHandler = new PropertyCallbackHandler();
        }

        // Whether this platform is active in the settings UI.
        internal bool Active { get { return active; } }

        // Whether this platform has any properties that are not inherited from the parent.
        internal bool HasAnyOverriddenProperties
        {
            get
            {
                return active &&
                    (
                        Properties.LiveUpdate.HasValue
                        || Properties.LiveUpdatePort.HasValue
                        || Properties.Overlay.HasValue
                        || Properties.OverlayPosition.HasValue
                        || Properties.OverlayFontSize.HasValue
                        || Properties.Logging.HasValue
                        || Properties.SampleRate.HasValue
                        || Properties.BuildDirectory.HasValue
                        || Properties.SpeakerMode.HasValue
                        || Properties.VirtualChannelCount.HasValue
                        || Properties.RealChannelCount.HasValue
                        || Properties.DSPBufferLength.HasValue
                        || Properties.DSPBufferCount.HasValue
                        || Properties.Plugins.HasValue
                        || Properties.StaticPlugins.HasValue
                    );
            }
        }

        // These accessors provide (possibly inherited) property values.
        public TriStateBool LiveUpdate { get { return PropertyAccessors.LiveUpdate.Get(this); } }
        public int LiveUpdatePort { get { return PropertyAccessors.LiveUpdatePort.Get(this); } }
        public TriStateBool Overlay { get { return PropertyAccessors.Overlay.Get(this); } }
        public ScreenPosition OverlayRect { get { return PropertyAccessors.OverlayPosition.Get(this); } }
        public int OverlayFontSize { get { return PropertyAccessors.OverlayFontSize.Get(this); } }
        public void SetOverlayFontSize(int size) { PropertyAccessors.OverlayFontSize.Set(this, size); }
        public TriStateBool Logging { get { return PropertyAccessors.Logging.Get(this); } }
        public int SampleRate { get { return PropertyAccessors.SampleRate.Get(this); } }
        public string BuildDirectory { get { return PropertyAccessors.BuildDirectory.Get(this); } }
        public FMOD.SPEAKERMODE SpeakerMode { get { return PropertyAccessors.SpeakerMode.Get(this); } }
        public int VirtualChannelCount { get { return PropertyAccessors.VirtualChannelCount.Get(this); } }
        public int RealChannelCount { get { return PropertyAccessors.RealChannelCount.Get(this); } }
        public int DSPBufferLength { get { return PropertyAccessors.DSPBufferLength.Get(this); } }
        public int DSPBufferCount { get { return PropertyAccessors.DSPBufferCount.Get(this); } }
        public List<string> Plugins { get { return PropertyAccessors.Plugins.Get(this); } }
        public List<string> StaticPlugins { get { return PropertyAccessors.StaticPlugins.Get(this); } }
        public PlatformCallbackHandler CallbackHandler { get { return PropertyAccessors.CallbackHandler.Get(this); } }

        // These accessors provide full access to properties.
        internal static class PropertyAccessors
        {
            public static readonly PropertyAccessor<TriStateBool> LiveUpdate
                    = new PropertyAccessor<TriStateBool>(properties => properties.LiveUpdate, TriStateBool.Disabled);

            public static readonly PropertyAccessor<int> LiveUpdatePort
                    = new PropertyAccessor<int>(properties => properties.LiveUpdatePort, 9264);

            public static readonly PropertyAccessor<TriStateBool> Overlay
                    = new PropertyAccessor<TriStateBool>(properties => properties.Overlay, TriStateBool.Disabled);

            public static readonly PropertyAccessor<ScreenPosition> OverlayPosition = new PropertyAccessor<ScreenPosition>(properties => properties.OverlayPosition, ScreenPosition.TopLeft);

            public static readonly PropertyAccessor<int> OverlayFontSize = new PropertyAccessor<int>(properties => properties.OverlayFontSize, 14);

            public static readonly PropertyAccessor<TriStateBool> Logging
                    = new PropertyAccessor<TriStateBool>(properties => properties.Logging, TriStateBool.Disabled);

            public static readonly PropertyAccessor<int> SampleRate
                    = new PropertyAccessor<int>(properties => properties.SampleRate, 0);

            public static readonly PropertyAccessor<string> BuildDirectory
                    = new PropertyAccessor<string>(properties => properties.BuildDirectory, "Desktop");

            public static readonly PropertyAccessor<FMOD.SPEAKERMODE> SpeakerMode
                    = new PropertyAccessor<FMOD.SPEAKERMODE>(properties => properties.SpeakerMode, FMOD.SPEAKERMODE.STEREO);

            public static readonly PropertyAccessor<int> VirtualChannelCount
                    = new PropertyAccessor<int>(properties => properties.VirtualChannelCount, 128);

            public static readonly PropertyAccessor<int> RealChannelCount
                    = new PropertyAccessor<int>(properties => properties.RealChannelCount, 32);

            public static readonly PropertyAccessor<int> DSPBufferLength
                    = new PropertyAccessor<int>(properties => properties.DSPBufferLength, 0);

            public static readonly PropertyAccessor<int> DSPBufferCount
                    = new PropertyAccessor<int>(properties => properties.DSPBufferCount, 0);

            public static readonly PropertyAccessor<List<string>> Plugins
                    = new PropertyAccessor<List<string>>(properties => properties.Plugins, null);

            public static readonly PropertyAccessor<List<string>> StaticPlugins
                    = new PropertyAccessor<List<string>>(properties => properties.StaticPlugins, null);

            public static readonly PropertyAccessor<PlatformCallbackHandler> CallbackHandler
                    = new PropertyAccessor<PlatformCallbackHandler>(properties => properties.CallbackHandler, null);
        }

#if UNITY_EDITOR
        // The parent platform from which this platform inherits its property values.
        internal Platform Parent
        {
            get
            {
                return (ParentIdentifier != null) ? Settings.Instance.FindPlatform(ParentIdentifier) : null;
            }
        }

        // The platforms which inherit their property values from this platform.
        internal List<string> ChildIdentifiers { get { return childIdentifiers; } }
#endif

        // Checks whether this platform inherits from the given platform, so we can avoid creating
        // inheritance loops.
        internal bool InheritsFrom(Platform platform)
        {
            if (platform == this)
            {
                return true;
            }
            else if (Parent != null)
            {
                return Parent.InheritsFrom(platform);
            }
            else
            {
                return false;
            }
        }

        internal FMOD.OUTPUTTYPE GetOutputType()
        {
            if (Enum.IsDefined(typeof(FMOD.OUTPUTTYPE), OutputTypeName))
            {
                return (FMOD.OUTPUTTYPE)Enum.Parse(typeof(FMOD.OUTPUTTYPE), OutputTypeName);
            }
            return FMOD.OUTPUTTYPE.AUTODETECT;
        }

#if UNITY_EDITOR
        public struct OutputType
        {
            public string displayName;
            public FMOD.OUTPUTTYPE outputType;
        }

        internal abstract OutputType[] ValidOutputTypes { get; }

        internal virtual int CoreCount { get { return 0; } }
#endif

        internal virtual List<ThreadAffinityGroup> DefaultThreadAffinities { get { return StaticThreadAffinities; } }

        [Serializable]
        public class PropertyThreadAffinityList : Property<List<ThreadAffinityGroup>>
        {
        }

        public IEnumerable<ThreadAffinityGroup> ThreadAffinities
        {
            get
            {
                if (threadAffinities.HasValue)
                {
                    return threadAffinities.Value;
                }
                else
                {
                    return DefaultThreadAffinities;
                }
            }
        }

        internal PropertyThreadAffinityList ThreadAffinitiesProperty { get { return threadAffinities; } }

        internal virtual List<CodecChannelCount> DefaultCodecChannels { get { return staticCodecChannels; } }

        private static List<CodecChannelCount> staticCodecChannels = new List<CodecChannelCount>()
        {
            new CodecChannelCount { format = CodecType.FADPCM, channels = 32 },
            new CodecChannelCount { format = CodecType.Vorbis, channels = 0 },
        };

        [Serializable]
        internal class PropertyCodecChannels : Property<List<CodecChannelCount>>
        {
        }

        [SerializeField]
        private PropertyCodecChannels codecChannels = new PropertyCodecChannels();

        internal List<CodecChannelCount> CodecChannels
        {
            get
            {
                if (codecChannels.HasValue)
                {
                    return codecChannels.Value;
                }
                else
                {
                    return DefaultCodecChannels;
                }
            }
        }

        internal PropertyCodecChannels CodecChannelsProperty { get { return codecChannels; } }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Platform.cs.meta
================================================
fileFormatVersion: 2
guid: e7df340ba8041134888b271ea2124fcd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/PlatformDefault.cs
================================================
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMODUnity
{
    public class PlatformDefault : Platform
    {
        public const string ConstIdentifier = "default";

        public PlatformDefault()
        {
            Identifier = ConstIdentifier;
        }

        internal override string DisplayName { get { return "Default"; } }
        internal override void DeclareRuntimePlatforms(Settings settings) { }
#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield break;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.Default; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return null;
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield break;
        }
#endif

        internal override bool IsIntrinsic { get { return true; } }

        internal override void InitializeProperties()
        {
            base.InitializeProperties();

            PropertyAccessors.Plugins.Set(this, new List<string>());
            PropertyAccessors.StaticPlugins.Set(this, new List<string>());
        }

        internal override void EnsurePropertiesAreValid()
        {
            base.EnsurePropertiesAreValid();

            if (StaticPlugins == null)
            {
                PropertyAccessors.StaticPlugins.Set(this, new List<string>());
            }
        }

        // null means no valid output types - don't display the field in the UI
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes { get { return null; } }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/PlatformDefault.cs.meta
================================================
fileFormatVersion: 2
guid: 9587379c972e4a54da1949613f11e1c6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/PlatformGroup.cs
================================================
﻿using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMODUnity
{
    public class PlatformGroup : Platform
    {
        [SerializeField]
        private string displayName;

        [SerializeField]
        private Legacy.Platform legacyIdentifier;

        internal override string DisplayName { get { return displayName; } }
        internal override void DeclareRuntimePlatforms(Settings settings) { }
#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield break;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return legacyIdentifier; } }

        internal static PlatformGroup Create(string displayName, Legacy.Platform legacyIdentifier)
        {
            PlatformGroup group = CreateInstance<PlatformGroup>();
            group.Identifier = GUID.Generate().ToString();
            group.displayName = displayName;
            group.legacyIdentifier = legacyIdentifier;
            group.AffirmProperties();

            return group;
        }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return null;
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield break;
        }

        internal override OutputType[] ValidOutputTypes { get { return null; } }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/PlatformGroup.cs.meta
================================================
fileFormatVersion: 2
guid: 6d049eb0281db9c4abd635ba1c79cb7b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/PlatformMobileHigh.cs
================================================
﻿using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformMobileHigh : PlatformMobileLow
    {
        static PlatformMobileHigh()
        {
            Settings.AddPlatformTemplate<PlatformMobileHigh>("fd7c55dab0fce234b8c25f6ffca523c1");
        }

        internal override string DisplayName { get { return "High-End Mobile"; } }
#if UNITY_EDITOR
        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.MobileHigh; } }
#endif

        internal override float Priority { get { return base.Priority + 1; } }

        internal override bool MatchesCurrentEnvironment
        {
            get
            {
                if (!Active)
                {
                    return false;
                }

#if UNITY_IOS
                switch (UnityEngine.iOS.Device.generation)
                {
                    case UnityEngine.iOS.DeviceGeneration.iPad1Gen:
                    case UnityEngine.iOS.DeviceGeneration.iPad2Gen:
                    case UnityEngine.iOS.DeviceGeneration.iPad3Gen:
                    case UnityEngine.iOS.DeviceGeneration.iPadMini1Gen:
                    case UnityEngine.iOS.DeviceGeneration.iPhone:
                    case UnityEngine.iOS.DeviceGeneration.iPhone3G:
                    case UnityEngine.iOS.DeviceGeneration.iPhone3GS:
                    case UnityEngine.iOS.DeviceGeneration.iPhone4:
                    case UnityEngine.iOS.DeviceGeneration.iPhone4S:
                        return false;
                    default:
                        return true;
                }
#elif UNITY_ANDROID
                if (SystemInfo.processorCount <= 2)
                {
                    return false;
                }
                else if (SystemInfo.processorCount >= 8)
                {
                    return true;
                }
                else
                {
                    // check the clock rate on quad core systems
                    string freqinfo = "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq";
                    try
                    {
                        using (System.IO.TextReader reader = new System.IO.StreamReader(freqinfo))
                        {
                            string line = reader.ReadLine();
                            int khz = int.Parse(line) / 1000;
                            if (khz >= 1600)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                    catch
                    {
                        return false;
                    }
                }
#else
                return false;
#endif
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/PlatformMobileHigh.cs.meta
================================================
fileFormatVersion: 2
guid: 93a382382f106584e8f8f62412fee177
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/PlatformMobileLow.cs
================================================
﻿using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMODUnity
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public class PlatformMobileLow : Platform
    {
        static PlatformMobileLow()
        {
            Settings.AddPlatformTemplate<PlatformMobileLow>("c88d16e5272a4e241b0ef0ac2e53b73d");
        }

        internal override string DisplayName { get { return "Low-End Mobile"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.IPhonePlayer, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.Android, this);
        }

#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield break;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.MobileLow; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return null;
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield break;
        }

        internal override bool SupportsAdditionalCPP(BuildTarget target)
        {
            if (target == BuildTarget.iOS)
            {
                return PlatformIOS.StaticSupportsAdditionalCpp();
            }
            else
            {
                return base.SupportsAdditionalCPP(target);
            }
        }
#endif

        internal override float Priority { get { return DefaultPriority + 1; } }

        internal override bool MatchesCurrentEnvironment
        {
            get
            {
                return Active;
            }
        }

#if UNITY_IOS
        internal override void LoadPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            PlatformIOS.StaticLoadPlugins(this, coreSystem, reportResult);
        }
#elif UNITY_ANDROID
        internal override string GetBankFolder()
        {
            return PlatformAndroid.StaticGetBankFolder();
        }

        internal override string GetPluginPath(string pluginName)
        {
            return PlatformAndroid.StaticGetPluginPath(pluginName);
        }
#endif

#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes { get { return null; } }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/PlatformMobileLow.cs.meta
================================================
fileFormatVersion: 2
guid: 3abeb1429547a134480f4f2f1efc7e21
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/PlatformPlayInEditor.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

#if UNITY_EDITOR
namespace FMOD
{
    public partial class VERSION
    {
        public const string dll = "fmodstudioL";
    }
}

namespace FMOD.Studio
{
    public partial class STUDIO_VERSION
    {
        public const string dll = "fmodstudioL";
    }
}
#endif

namespace FMODUnity
{
    public class PlatformPlayInEditor : Platform
    {
        public PlatformPlayInEditor()
        {
            Identifier = "playInEditor";
        }

        internal override string DisplayName { get { return "Editor"; } }
        internal override void DeclareRuntimePlatforms(Settings settings)
        {
            settings.DeclareRuntimePlatform(RuntimePlatform.OSXEditor, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.WindowsEditor, this);
            settings.DeclareRuntimePlatform(RuntimePlatform.LinuxEditor, this);
        }
#if UNITY_EDITOR
        internal override IEnumerable<BuildTarget> GetBuildTargets()
        {
            yield break;
        }

        internal override Legacy.Platform LegacyIdentifier { get { return Legacy.Platform.PlayInEditor; } }

        protected override BinaryAssetFolderInfo GetBinaryAssetFolder(BuildTarget buildTarget)
        {
            return null;
        }

        protected override IEnumerable<FileRecord> GetBinaryFiles(BuildTarget buildTarget, bool allVariants, string suffix)
        {
            yield break;
        }
#endif

        internal override bool IsIntrinsic { get { return true; } }

        internal override string GetBankFolder()
        {
            // Use original asset location because streaming asset folder will contain platform specific banks
            Settings globalSettings = Settings.Instance;

            string bankFolder = globalSettings.SourceBankPath;
            if (globalSettings.HasPlatforms)
            {
                bankFolder = RuntimeUtils.GetCommonPlatformPath(Path.Combine(bankFolder, BuildDirectory));
            }

            return bankFolder;
        }

#if UNITY_EDITOR
        internal override string GetPluginPath(string pluginName)
        {
            string platformsFolder = Path.GetFullPath($"{RuntimeUtils.PluginBasePath}/platforms");
#if UNITY_EDITOR_WIN
            return string.Format("{0}/win/lib/{1}/{2}.dll", platformsFolder, RuntimeUtils.GetPluginArchitectureFolder(), pluginName);
#elif UNITY_EDITOR_OSX
            string pluginPath = string.Format("{0}/mac/lib/{1}.bundle", platformsFolder, pluginName);
            if (System.IO.Directory.Exists(pluginPath))
            {
                return pluginPath;
            }
            else
            {
                return string.Format("{0}/mac/lib/{1}.dylib", platformsFolder, pluginName);
            }
#elif UNITY_EDITOR_LINUX
            if (Environment.Is64BitProcess)
            {
                return string.Format("{0}/linux/lib/x86_64/lib{1}.so", platformsFolder, pluginName);
            }
            else
            {
                return string.Format("{0}/linux/lib/x86/lib{1}.so", platformsFolder, pluginName);
            }
#endif
        }
#endif

        internal override void LoadStaticPlugins(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)
        {
            // Ignore static plugins when playing in the editor
        }

        internal override void InitializeProperties()
        {
            base.InitializeProperties();

            PropertyAccessors.LiveUpdate.Set(this, TriStateBool.Enabled);
            PropertyAccessors.Overlay.Set(this, TriStateBool.Enabled);
            PropertyAccessors.SampleRate.Set(this, 48000);
            PropertyAccessors.RealChannelCount.Set(this, 256);
            PropertyAccessors.VirtualChannelCount.Set(this, 1024);
        }
#if UNITY_EDITOR
        internal override OutputType[] ValidOutputTypes { get { return null; } }
#endif

        internal override List<CodecChannelCount> DefaultCodecChannels { get { return staticCodecChannels; } }

        private static List<CodecChannelCount> staticCodecChannels = new List<CodecChannelCount>()
        {
            new CodecChannelCount { format = CodecType.FADPCM, channels = 0 },
            new CodecChannelCount { format = CodecType.Vorbis, channels = 256 },
        };
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/PlatformPlayInEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 335f0a4b26fb46942858ea029e030d2a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/RuntimeManager.cs.meta
================================================
fileFormatVersion: 2
guid: 5e5fb8ce07f0ce84b9d1852869527ea5
timeCreated: 1444628977
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 100
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/RuntimeUtils.cs
================================================
using System;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FMOD
{
    [Serializable]
    public partial struct GUID : IEquatable<GUID>
    {
        public GUID(Guid guid)
        {
            byte[] bytes = guid.ToByteArray();

            Data1 = BitConverter.ToInt32(bytes,  0);
            Data2 = BitConverter.ToInt32(bytes,  4);
            Data3 = BitConverter.ToInt32(bytes,  8);
            Data4 = BitConverter.ToInt32(bytes, 12);
        }

        public static GUID Parse(string s)
        {
            return new GUID(new Guid(s));
        }

        public bool IsNull
        {
            get
            {
                return Data1 == 0
                    && Data2 == 0
                    && Data3 == 0
                    && Data4 == 0;
            }
        }

        public override bool Equals(object other)
        {
            return (other is GUID) && Equals((GUID)other);
        }

        public bool Equals(GUID other)
        {
            return Data1 == other.Data1
                && Data2 == other.Data2
                && Data3 == other.Data3
                && Data4 == other.Data4;
        }

        public static bool operator==(GUID a, GUID b)
        {
            return a.Equals(b);
        }

        public static bool operator!=(GUID a, GUID b)
        {
            return !a.Equals(b);
        }

        public override int GetHashCode()
        {
            return Data1 ^ Data2 ^ Data3 ^ Data4;
        }

        public static implicit operator Guid(GUID guid)
        {
            return new Guid(guid.Data1,
                    (short) ((guid.Data2 >>  0) & 0xFFFF),
                    (short) ((guid.Data2 >> 16) & 0xFFFF),
                    (byte)  ((guid.Data3 >>  0) & 0xFF),
                    (byte)  ((guid.Data3 >>  8) & 0xFF),
                    (byte)  ((guid.Data3 >> 16) & 0xFF),
                    (byte)  ((guid.Data3 >> 24) & 0xFF),
                    (byte)  ((guid.Data4 >>  0) & 0xFF),
                    (byte)  ((guid.Data4 >>  8) & 0xFF),
                    (byte)  ((guid.Data4 >> 16) & 0xFF),
                    (byte)  ((guid.Data4 >> 24) & 0xFF)
                );
        }

        public override string ToString()
        {
            return ((Guid)this).ToString("B");
        }
    }
}

namespace FMODUnity
{
    public class EventNotFoundException : Exception
    {
        public FMOD.GUID Guid;
        public string Path;

        public EventNotFoundException(string path)
            : base("[FMOD] Event not found: '" + path + "'")
        {
            Path = path;
        }

        public EventNotFoundException(FMOD.GUID guid)
            : base("[FMOD] Event not found: " + guid)
        {
            Guid = guid;
        }

        public EventNotFoundException(EventReference eventReference)
            : base("[FMOD] Event not found: " + eventReference.ToString())
        {
            Guid = eventReference.Guid;

#if UNITY_EDITOR
#if !FMOD_SERIALIZE_GUID_ONLY
            Path = eventReference.Path;
#endif
#endif
        }
    }

    public class BusNotFoundException : Exception
    {
        public string Path;

        public BusNotFoundException(string path)
            : base("[FMOD] Bus not found '" + path + "'")
        {
            Path = path;
        }
    }

    public class VCANotFoundException : Exception
    {
        public string Path;

        public VCANotFoundException(string path)
            : base("[FMOD] VCA not found '" + path + "'")
        {
            Path = path;
        }
    }

    public class BankLoadException : Exception
    {
        public string Path;
        public FMOD.RESULT Result;

        public BankLoadException(string path, FMOD.RESULT result)
            : base(string.Format("[FMOD] Could not load bank '{0}' : {1} : {2}", path, result.ToString(), FMOD.Error.String(result)))
        {
            Path = path;
            Result = result;
        }
        public BankLoadException(string path, string error)
            : base(string.Format("[FMOD] Could not load bank '{0}' : {1}", path, error))
        {
            Path = path;
            Result = FMOD.RESULT.ERR_INTERNAL;
        }
    }

    public class SystemNotInitializedException : Exception
    {
        public FMOD.RESULT Result;
        public string Location;

        public SystemNotInitializedException(FMOD.RESULT result, string location)
            : base(string.Format("[FMOD] Initialization failed : {2} : {0} : {1}", result.ToString(), FMOD.Error.String(result), location))
        {
            Result = result;
            Location = location;
        }

        public SystemNotInitializedException(Exception inner)
            : base("[FMOD] Initialization failed", inner)
        {
        }
    }

    public enum EmitterGameEvent : int
    {
        None,
        ObjectStart,
        ObjectDestroy,
        TriggerEnter,
        TriggerExit,
        TriggerEnter2D,
        TriggerExit2D,
        CollisionEnter,
        CollisionExit,
        CollisionEnter2D,
        CollisionExit2D,
        ObjectEnable,
        ObjectDisable,
        ObjectMouseEnter,
        ObjectMouseExit,
        ObjectMouseDown,
        ObjectMouseUp,
        UIMouseEnter,
        UIMouseExit,
        UIMouseDown,
        UIMouseUp,
    }

    public enum LoaderGameEvent : int
    {
        None,
        ObjectStart,
        ObjectDestroy,
        TriggerEnter,
        TriggerExit,
        TriggerEnter2D,
        TriggerExit2D,
        ObjectEnable,
        ObjectDisable,
    }

    // We use our own enum to avoid serialization issues if FMOD.THREAD_TYPE changes
    public enum ThreadType
    {
        Mixer,
        Feeder,
        Stream,
        File,
        Nonblocking,
        Record,
        Geometry,
        Profiler,
        Studio_Update,
        Studio_Load_Bank,
        Studio_Load_Sample,
        Convolution_1,
        Convolution_2,
    }

    // We use our own enum to avoid serialization issues if FMOD.THREAD_AFFINITY changes
    [Flags]
    public enum ThreadAffinity : uint
    {
        Any = 0,
        Core0 = 1 << 0,
        Core1 = 1 << 1,
        Core2 = 1 << 2,
        Core3 = 1 << 3,
        Core4 = 1 << 4,
        Core5 = 1 << 5,
        Core6 = 1 << 6,
        Core7 = 1 << 7,
        Core8 = 1 << 8,
        Core9 = 1 << 9,
        Core10 = 1 << 10,
        Core11 = 1 << 11,
        Core12 = 1 << 12,
        Core13 = 1 << 13,
        Core14 = 1 << 14,
        Core15 = 1 << 15,
    }

    // Using a separate enum to avoid serialization issues if FMOD.SOUND_TYPE changes.
    public enum CodecType : int
    {
        FADPCM,
        Vorbis,
        AT9,
        XMA,
        Opus
    }

    [Serializable]
    public class ThreadAffinityGroup
    {
        public List<ThreadType> threads = new List<ThreadType>();
        public ThreadAffinity affinity = ThreadAffinity.Any;

        public ThreadAffinityGroup()
        {
        }

        public ThreadAffinityGroup(ThreadAffinityGroup other)
        {
            threads = new List<ThreadType>(other.threads);
            affinity = other.affinity;
        }

        public ThreadAffinityGroup(ThreadAffinity affinity, params ThreadType[] threads)
        {
            this.threads = new List<ThreadType>(threads);
            this.affinity = affinity;
        }
    }

    [Serializable]
    public class CodecChannelCount
    {
        public CodecType format;
        public int channels;

        public CodecChannelCount() { }

        public CodecChannelCount(CodecChannelCount other)
        {
            format = other.format;
            channels = other.channels;
        }
    }

    public static class RuntimeUtils
    {
#if UNITY_EDITOR
        private static string pluginBasePath;

        public const string BaseFolderGUID = "06ae579381df01a4a87bb149dec89954";
        public const string PluginBasePathDefault = "Assets/Plugins/FMOD";

        public static string PluginBasePath
        {
            get
            {
                if (pluginBasePath == null)
                {
                    pluginBasePath = AssetDatabase.GUIDToAssetPath(BaseFolderGUID);

                    if (string.IsNullOrEmpty(pluginBasePath))
                    {
                        pluginBasePath = PluginBasePathDefault;

                        DebugLogWarningFormat("FMOD: Couldn't find base folder with GUID {0}; defaulting to {1}",
                            BaseFolderGUID, pluginBasePath);
                    }
                }

                return pluginBasePath;
            }
        }
#endif

        public static string GetCommonPlatformPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return path;
            }

            return path.Replace('\\', '/');
        }

        public static FMOD.VECTOR ToFMODVector(this Vector3 vec)
        {
            FMOD.VECTOR temp;
            temp.x = vec.x;
            temp.y = vec.y;
            temp.z = vec.z;

            return temp;
        }

        public static FMOD.ATTRIBUTES_3D To3DAttributes(this Vector3 pos)
        {
            FMOD.ATTRIBUTES_3D attributes = new FMOD.ATTRIBUTES_3D();
            attributes.forward = ToFMODVector(Vector3.forward);
            attributes.up = ToFMODVector(Vector3.up);
            attributes.position = ToFMODVector(pos);

            return attributes;
        }

        public static FMOD.ATTRIBUTES_3D To3DAttributes(this Transform transform)
        {
            FMOD.ATTRIBUTES_3D attributes = new FMOD.ATTRIBUTES_3D();
            attributes.forward = transform.forward.ToFMODVector();
            attributes.up = transform.up.ToFMODVector();
            attributes.position = transform.position.ToFMODVector();

            return attributes;
        }

        public static FMOD.ATTRIBUTES_3D To3DAttributes(this Transform transform, Vector3 velocity)
        {
            FMOD.ATTRIBUTES_3D attributes = new FMOD.ATTRIBUTES_3D();
            attributes.forward = transform.forward.ToFMODVector();
            attributes.up = transform.up.ToFMODVector();
            attributes.position = transform.position.ToFMODVector();
            attributes.velocity = velocity.ToFMODVector();

            return attributes;
        }

        public static FMOD.ATTRIBUTES_3D To3DAttributes(this GameObject go)
        {
            return go.transform.To3DAttributes();
        }

#if UNITY_PHYSICS_EXIST
        public static FMOD.ATTRIBUTES_3D To3DAttributes(Transform transform, Rigidbody rigidbody = null)
        {
            FMOD.ATTRIBUTES_3D attributes = transform.To3DAttributes();

            if (rigidbody)
            {
#if UNITY_6000_0_OR_NEWER
                attributes.velocity = rigidbody.linearVelocity.ToFMODVector();
#else
                attributes.velocity = rigidbody.velocity.ToFMODVector();
#endif
            }

            return attributes;
        }

        public static FMOD.ATTRIBUTES_3D To3DAttributes(GameObject go, Rigidbody rigidbody)
        {
            FMOD.ATTRIBUTES_3D attributes = go.transform.To3DAttributes();

            if (rigidbody)
            {
#if UNITY_6000_0_OR_NEWER
                attributes.velocity = rigidbody.linearVelocity.ToFMODVector();
#else
                attributes.velocity = rigidbody.velocity.ToFMODVector();
#endif
            }

            return attributes;
        }
#endif

#if UNITY_PHYSICS2D_EXIST
        public static FMOD.ATTRIBUTES_3D To3DAttributes(Transform transform, Rigidbody2D rigidbody)
        {
            FMOD.ATTRIBUTES_3D attributes = transform.To3DAttributes();

            if (rigidbody)
            {
                FMOD.VECTOR vel;
#if UNITY_6000_1_OR_NEWER
                vel.x = rigidbody.linearVelocity.x;
                vel.y = rigidbody.linearVelocity.y;
#else
#pragma warning disable CS0618
                vel.x = rigidbody.velocity.x;
                vel.y = rigidbody.velocity.y;
#pragma warning restore CS0618
#endif
                vel.z = 0;
                attributes.velocity = vel;
            }

            return attributes;
        }


        public static FMOD.ATTRIBUTES_3D To3DAttributes(GameObject go, Rigidbody2D rigidbody)
        {
            FMOD.ATTRIBUTES_3D attributes = go.transform.To3DAttributes();

            if (rigidbody)
            {
                FMOD.VECTOR vel;
#if UNITY_6000_1_OR_NEWER
                vel.x = rigidbody.linearVelocity.x;
                vel.y = rigidbody.linearVelocity.y;
#else
#pragma warning disable CS0618
                vel.x = rigidbody.velocity.x;
                vel.y = rigidbody.velocity.y;
#pragma warning restore CS0618
#endif
                vel.z = 0;
                attributes.velocity = vel;
            }

            return attributes;
        }
#endif

        public static FMOD.THREAD_TYPE ToFMODThreadType(ThreadType threadType)
        {
            switch (threadType)
            {
                case ThreadType.Mixer:
                    return FMOD.THREAD_TYPE.MIXER;
                case ThreadType.Feeder:
                    return FMOD.THREAD_TYPE.FEEDER;
                case ThreadType.Stream:
                    return FMOD.THREAD_TYPE.STREAM;
                case ThreadType.File:
                    return FMOD.THREAD_TYPE.FILE;
                case ThreadType.Nonblocking:
                    return FMOD.THREAD_TYPE.NONBLOCKING;
                case ThreadType.Record:
                    return FMOD.THREAD_TYPE.RECORD;
                case ThreadType.Geometry:
                    return FMOD.THREAD_TYPE.GEOMETRY;
                case ThreadType.Profiler:
                    return FMOD.THREAD_TYPE.PROFILER;
                case ThreadType.Studio_Update:
                    return FMOD.THREAD_TYPE.STUDIO_UPDATE;
                case ThreadType.Studio_Load_Bank:
                    return FMOD.THREAD_TYPE.STUDIO_LOAD_BANK;
                case ThreadType.Studio_Load_Sample:
                    return FMOD.THREAD_TYPE.STUDIO_LOAD_SAMPLE;
                case ThreadType.Convolution_1:
                    return FMOD.THREAD_TYPE.CONVOLUTION1;
                case ThreadType.Convolution_2:
                    return FMOD.THREAD_TYPE.CONVOLUTION2;
                default:
                    throw new ArgumentException("Unrecognised thread type '" + threadType.ToString() + "'");
            }
        }

        public static string DisplayName(this ThreadType thread)
        {
            return thread.ToString().Replace('_', ' ');
        }

        public static FMOD.THREAD_AFFINITY ToFMODThreadAffinity(ThreadAffinity affinity)
        {
            FMOD.THREAD_AFFINITY fmodAffinity = FMOD.THREAD_AFFINITY.CORE_ALL;

            SetFMODAffinityBit(affinity, ThreadAffinity.Core0, FMOD.THREAD_AFFINITY.CORE_0, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core1, FMOD.THREAD_AFFINITY.CORE_1, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core2, FMOD.THREAD_AFFINITY.CORE_2, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core3, FMOD.THREAD_AFFINITY.CORE_3, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core4, FMOD.THREAD_AFFINITY.CORE_4, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core5, FMOD.THREAD_AFFINITY.CORE_5, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core6, FMOD.THREAD_AFFINITY.CORE_6, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core7, FMOD.THREAD_AFFINITY.CORE_7, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core8, FMOD.THREAD_AFFINITY.CORE_8, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core9, FMOD.THREAD_AFFINITY.CORE_9, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core10, FMOD.THREAD_AFFINITY.CORE_10, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core11, FMOD.THREAD_AFFINITY.CORE_11, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core12, FMOD.THREAD_AFFINITY.CORE_12, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core13, FMOD.THREAD_AFFINITY.CORE_13, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core14, FMOD.THREAD_AFFINITY.CORE_14, ref fmodAffinity);
            SetFMODAffinityBit(affinity, ThreadAffinity.Core15, FMOD.THREAD_AFFINITY.CORE_15, ref fmodAffinity);

            return fmodAffinity;
        }

        private static void SetFMODAffinityBit(ThreadAffinity affinity, ThreadAffinity mask,
            FMOD.THREAD_AFFINITY fmodMask, ref FMOD.THREAD_AFFINITY fmodAffinity)
        {
            if ((affinity & mask) != 0)
            {
                fmodAffinity |= fmodMask;
            }
        }

        public static void EnforceLibraryOrder()
        {
            // Call a function in fmod.dll to make sure it's loaded before fmodstudio.dll
            int temp1, temp2;
            FMOD.Memory.GetStats(out temp1, out temp2);

            FMOD.GUID temp3;
            FMOD.Studio.Util.parseID("", out temp3);
        }

        public static void DebugLog(string message)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel == FMOD.DEBUG_FLAGS.LOG)
            {
                Debug.Log(message);
            }
        }

        public static void DebugLogFormat(string format, params object[] args)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel == FMOD.DEBUG_FLAGS.LOG)
            {
                Debug.LogFormat(format, args);
            }
        }

        public static void DebugLogWarning(string message)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel >= FMOD.DEBUG_FLAGS.WARNING)
            {
                Debug.LogWarning(message);
            }
        }

        public static void DebugLogWarningFormat(string format, params object[] args)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel >= FMOD.DEBUG_FLAGS.WARNING)
            {
                Debug.LogWarningFormat(format, args);
            }
        }

        public static void DebugLogError(string message)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel >= FMOD.DEBUG_FLAGS.ERROR)
            {
                Debug.LogError(message);
            }
        }

        public static void DebugLogErrorFormat(string format, params object[] args)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel >= FMOD.DEBUG_FLAGS.ERROR)
            {
                Debug.LogErrorFormat(format, args);
            }
        }

        public static void DebugLogException(Exception e)
        {
            if (!Settings.IsInitialized() || Settings.Instance.LoggingLevel >= FMOD.DEBUG_FLAGS.ERROR)
            {
                Debug.LogException(e);
            }
        }

        public static string GetPluginArchitectureFolder()
        {
            switch (System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture)
            {
                case System.Runtime.InteropServices.Architecture.Arm:
                    throw new System.NotSupportedException("[FMOD] Attempted to load FMOD plugins on a 32 bit ARM platform.");
                case System.Runtime.InteropServices.Architecture.Arm64:
                    return "arm64";
                case System.Runtime.InteropServices.Architecture.X86:
                    return "x86";
                default:
                    return "x86_64";
            }
        }

#if UNITY_EDITOR
        public static string WritableAssetPath(string subPath)
        {
            if (RuntimeUtils.PluginBasePath.StartsWith("Assets/"))
            {
                return $"{RuntimeUtils.PluginBasePath}/{subPath}.asset";
            }
            else
            {
                return $"Assets/Plugins/FMOD/{subPath}.asset";
            }
        }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/RuntimeUtils.cs.meta
================================================
fileFormatVersion: 2
guid: 6e349601408e423499e7b9f75216091d
timeCreated: 1433225261
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Settings.cs
================================================
﻿using UnityEngine;
using System.Collections.Generic;
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine.Serialization;
using System.Runtime.CompilerServices;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
#endif

[assembly: InternalsVisibleTo("FMODUnityEditor")]
namespace FMODUnity
{
    [Serializable]
    public enum ImportType
    {
        StreamingAssets,
        AssetBundle,
    }

    [Serializable]
    public enum BankLoadType
    {
        All,
        Specified,
        None
    }

    [Serializable]
    public enum MeterChannelOrderingType
    {
        Standard,
        SeparateLFE,
        Positional
    }

    public enum EventLinkage
    {
        Path,
        GUID,
    }

    public enum TriStateBool
    {
        Disabled,
        Enabled,
        Development,
    }

    public enum ScreenPosition
    {
        TopLeft,
        TopCenter,
        TopRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
        Center,
        VR,
    }

    public interface IEditorSettings
    {
#if UNITY_EDITOR
        Settings RuntimeSettings { get; set; }
        bool ForceLoggingBinaries { get; set; }
        Platform CurrentEditorPlatform { get; }
        void Clear();
        void ResetPlatformSettings();
        void ReimportLegacyPlatforms();
        void CreateSettingsAsset(string assetName);
        void AddMissingPlatforms();
        void AddPlatformsToAsset();
        void AddPlatformForBuildTargets(Platform platform);
        void UpdateMigratedPlatform(Platform platform);
        Platform GetPlatform(BuildTarget buildTarget);
        void SetPlatformParent(Platform platform, Platform newParent);
        PlatformGroup AddPlatformGroup(string displayName, int sortOrder);
        void PreprocessBuild(BuildTarget target, Platform.BinaryType binaryType);
        void CleanTemporaryFiles();
        void DeleteTemporaryFile(string assetPath);
        bool CanBuildTarget(BuildTarget target, Platform.BinaryType binaryType, out string error);
        void CheckActiveBuildTarget();
#endif
    }

    // This class stores all of the FMOD for Unity cross-platform settings, as well as a collection
    // of Platform objects that hold the platform-specific settings. The Platform objects are stored
    // in the same asset as the Settings object using AssetDatabase.AddObjectToAsset.
    public class Settings : ScriptableObject
    {
#if UNITY_EDITOR
        [FormerlySerializedAs("SwitchSettingsMigration")]
        [SerializeField]
        private bool switchSettingsMigration = false;
#endif

        internal const string SettingsAssetName = "FMODStudioSettings";

        private static Settings instance = null;
        private static IEditorSettings editorSettings = null;
        private static bool isInitializing = false;

        [SerializeField]
        public bool HasSourceProject = true;

        [SerializeField]
        public bool HasPlatforms = true;

        [SerializeField]
        private string sourceProjectPath;

        [SerializeField]
        private string sourceBankPath;

        [FormerlySerializedAs("SourceBankPathUnformatted")]
        [SerializeField]
        private string sourceBankPathUnformatted; // Kept as to not break existing projects

        [SerializeField]
        public int BankRefreshCooldown = 5;

        [SerializeField]
        public bool ShowBankRefreshWindow = true;

        internal const int BankRefreshPrompt = -1;
        internal const int BankRefreshManual = -2;

        [SerializeField]
        public bool AutomaticEventLoading;

        [SerializeField]
        public BankLoadType BankLoadType;

        [SerializeField]
        public bool AutomaticSampleLoading;

        [SerializeField]
        public string EncryptionKey;

        [SerializeField]
        public ImportType ImportType;

        [SerializeField]
        public string TargetAssetPath = "FMODBanks";

        [SerializeField]
        public string TargetBankFolder = "";

        [SerializeField]
#if FMOD_SERIALIZE_GUID_ONLY
        public EventLinkage EventLinkage = EventLinkage.GUID;
#else
        public EventLinkage EventLinkage = EventLinkage.Path;
#endif

        [SerializeField]
        public bool SerializeGUIDsOnly;

        [SerializeField]
        public FMOD.DEBUG_FLAGS LoggingLevel = FMOD.DEBUG_FLAGS.WARNING;

        [SerializeField]
        internal List<Legacy.PlatformIntSetting> SpeakerModeSettings;

        [SerializeField]
        internal List<Legacy.PlatformIntSetting> SampleRateSettings;

        [SerializeField]
        internal List<Legacy.PlatformBoolSetting> LiveUpdateSettings;

        [SerializeField]
        internal List<Legacy.PlatformBoolSetting> OverlaySettings;

        [SerializeField]
        internal List<Legacy.PlatformStringSetting> BankDirectorySettings;

        [SerializeField]
        internal List<Legacy.PlatformIntSetting> VirtualChannelSettings;

        [SerializeField]
        internal List<Legacy.PlatformIntSetting> RealChannelSettings;

        [SerializeField]
        internal List<string> Plugins = new List<string>();

        [SerializeField]
        public List<string> MasterBanks;

        [SerializeField]
        public List<string> Banks;

        [SerializeField]
        public List<string> BanksToLoad;

        [SerializeField]
        public ushort LiveUpdatePort = 9264;

        [SerializeField]
        public bool EnableMemoryTracking;

        [SerializeField]
        public bool AndroidUseOBB = false;

        [SerializeField]
        public bool AndroidPatchBuild = false;

        [SerializeField]
        public MeterChannelOrderingType MeterChannelOrdering;

        [SerializeField]
        public bool StopEventsOutsideMaxDistance = false;

        [SerializeField]
        internal bool BoltUnitOptionsBuildPending = false;

        [SerializeField]
        public bool EnableErrorCallback = false;

        [SerializeField]
        internal SharedLibraryUpdateStages SharedLibraryUpdateStage = SharedLibraryUpdateStages.Start;

        [SerializeField]
        internal double SharedLibraryTimeSinceStart = 0.0;

        [SerializeField]
        internal int CurrentVersion;

        [SerializeField]
        public bool HideSetupWizard;

        [SerializeField]
        internal int LastEventReferenceScanVersion;

        // This holds all known platforms, but only those that have settings are shown in the UI.
        // It is populated at load time from the Platform objects in the settings asset.
        // It is serializable to facilitate undo support.
        [SerializeField]
        public List<Platform> Platforms = new List<Platform>();

        // This is used to find the platform that matches the current Unity runtime platform.
        internal Dictionary<RuntimePlatform, List<Platform>> PlatformForRuntimePlatform = new Dictionary<RuntimePlatform, List<Platform>>();

        // Default platform settings.
        [NonSerialized]
        public Platform DefaultPlatform;

        // Play In Editor platform settings.
        [NonSerialized]
        public Platform PlayInEditorPlatform;

#if UNITY_EDITOR
        // We store a persistent list so we don't try to re-migrate platforms if the user deletes them.
        [SerializeField]
        internal List<Legacy.Platform> MigratedPlatforms = new List<Legacy.Platform>();
#endif

        // A collection of templates for constructing known platforms.
        internal static List<PlatformTemplate> PlatformTemplates = new List<PlatformTemplate>();

        [NonSerialized]
        private bool hasLoaded = false;

        public static Settings Instance
        {
            get
            {
                if (isInitializing)
                {
                    return null;
                }

                Initialize();

                return instance;
            }
        }

        internal static void Initialize()
        {
            if (instance == null)
            {
                isInitializing = true;

                instance = Resources.Load(SettingsAssetName) as Settings;

                if (instance == null)
                {
                    RuntimeUtils.DebugLog("[FMOD] Cannot find integration settings, creating default settings");
                    instance = CreateInstance<Settings>();
                    instance.name = "FMOD Studio Integration Settings";
                    instance.CurrentVersion = FMOD.VERSION.number;
                    instance.LastEventReferenceScanVersion = FMOD.VERSION.number;

#if UNITY_EDITOR
                    if (editorSettings != null)
                    {
                        editorSettings.CreateSettingsAsset(SettingsAssetName);
                    }
                    else
                    {
                        // editorSettings is populated via the static constructor of FMODUnity.EditorSettings when in the Unity editor.
                        RuntimeUtils.DebugLogError("[FMOD] Attempted to instantiate Settings before EditorSettings was populated. " +
                            "Ensure that Settings.Instance is not being called from an InitializeOnLoad method or class.");
                    }
#endif
                }
                else
                {
#if UNITY_EDITOR
                    if (AssetDatabase.GetAssetPath(instance).StartsWith("Packages"))
                    {
                        RuntimeUtils.DebugLogError($"[FMOD] {SettingsAssetName} initialization failed. {SettingsAssetName} located in \"Packages\" folder. Please delete {SettingsAssetName} in file explorer.");
                        instance = CreateInstance<Settings>();
                    }
#endif
                }

                isInitializing = false;
            }
        }

        internal static bool IsInitialized()
        {
            return !(instance == null || isInitializing);
        }

        internal static IEditorSettings EditorSettings
        {
            get
            {
                return editorSettings;
            }
            set
            {
                editorSettings = value;
            }
        }

        public string SourceProjectPath
        {
            get
            {
                return sourceProjectPath;
            }
            set
            {
                sourceProjectPath = value;
            }
        }

        public string SourceBankPath
        {
            get
            {
                return sourceBankPath;
            }
            set
            {
                sourceBankPath = value;
            }
        }

        internal string TargetPath
        {
            get
            {
                if (ImportType == ImportType.AssetBundle)
                {
                    if (string.IsNullOrEmpty(TargetAssetPath))
                    {
                        return Application.dataPath;
                    }
                    else
                    {
                        return Application.dataPath + "/" + TargetAssetPath;
                    }
                }
                else
                {
                    if (string.IsNullOrEmpty(TargetBankFolder))
                    {
                        return Application.streamingAssetsPath;
                    }
                    else
                    {
                        return Application.streamingAssetsPath + "/" + TargetBankFolder;
                    }
                }
            }
        }

        public string TargetSubFolder
        {
            get
            {
                if (ImportType == ImportType.AssetBundle)
                {
                    return TargetAssetPath;
                }
                else
                {
                    return TargetBankFolder;
                }
            }
            set
            {
                if (ImportType == ImportType.AssetBundle)
                {
                    TargetAssetPath = value;
                }
                else
                {
                    TargetBankFolder = value;
                }
            }
        }

        internal enum SharedLibraryUpdateStages
        {
            Start = 0,
            DisableExistingLibraries,
            RestartUnity,
            CopyNewLibraries,
        };

        internal Platform FindPlatform(string identifier)
        {
            foreach (Platform platform in Platforms)
            {
                if (platform.Identifier == identifier)
                {
                    return platform;
                }
            }

            return null;
        }

        internal bool PlatformExists(string identifier)
        {
            return FindPlatform(identifier) != null;
        }

        internal void AddPlatform(Platform platform)
        {
            if (PlatformExists(platform.Identifier))
            {
                throw new ArgumentException(string.Format("Duplicate platform identifier: {0}", platform.Identifier));
            }

            Platforms.Add(platform);
        }

        internal void RemovePlatform(string identifier)
        {
            Platforms.RemoveAll(p => p.Identifier == identifier);
        }

        // Links the platform to its parent, and to the BuildTargets and RuntimePlatforms it implements.
        internal void LinkPlatform(Platform platform)
        {
            LinkPlatformToParent(platform);

            platform.DeclareRuntimePlatforms(this);

#if UNITY_EDITOR
            if (editorSettings != null)
            {
                editorSettings.AddPlatformForBuildTargets(platform);
            }
#endif
        }

        internal void DeclareRuntimePlatform(RuntimePlatform runtimePlatform, Platform platform)
        {
            List<Platform> platforms;

            if (!PlatformForRuntimePlatform.TryGetValue(runtimePlatform, out platforms))
            {
                platforms = new List<Platform>();
                PlatformForRuntimePlatform.Add(runtimePlatform, platforms);
            }

            platforms.Add(platform);

            // Highest priority goes first
            platforms.Sort((a, b) => b.Priority.CompareTo(a.Priority));
        }

        // Links the given platform to its parent, if it has one.
        private void LinkPlatformToParent(Platform platform)
        {
            if (!string.IsNullOrEmpty(platform.ParentIdentifier))
            {
                SetPlatformParent(platform, FindPlatform(platform.ParentIdentifier));
            }
        }

        // The highest-priority platform that matches the current environment.
        internal Platform FindCurrentPlatform()
        {
            List<Platform> platforms;

            if (PlatformForRuntimePlatform.TryGetValue(Application.platform, out platforms))
            {
                foreach (Platform platform in platforms)
                {
                    if (platform.MatchesCurrentEnvironment)
                    {
                        return platform;
                    }
                }
            }

            return DefaultPlatform;
        }

        private Settings()
        {
            MasterBanks = new List<string>();
            Banks = new List<string>();
            BanksToLoad = new List<string>();
            RealChannelSettings = new List<Legacy.PlatformIntSetting>();
            VirtualChannelSettings = new List<Legacy.PlatformIntSetting>();
            LiveUpdateSettings = new List<Legacy.PlatformBoolSetting>();
            OverlaySettings = new List<Legacy.PlatformBoolSetting>();
            SampleRateSettings = new List<Legacy.PlatformIntSetting>();
            SpeakerModeSettings = new List<Legacy.PlatformIntSetting>();
            BankDirectorySettings = new List<Legacy.PlatformStringSetting>();

            ImportType = ImportType.StreamingAssets;
            AutomaticEventLoading = true;
            AutomaticSampleLoading = false;
            EnableMemoryTracking = false;
        }

        // Adds properties to a platform, thus revealing it in the UI.
        internal void AddPlatformProperties(Platform platform)
        {
            platform.AffirmProperties();
            LinkPlatformToParent(platform);
        }

#if UNITY_EDITOR
        internal void SetPlatformParent(Platform platform, Platform newParent)
        {
            if (editorSettings != null)
            {
                editorSettings.SetPlatformParent(platform, newParent);
            }
        }
#else
        public void SetPlatformParent(Platform platform, Platform newParent)
        {
            platform.Parent = newParent;
        }
#endif

        // A template for constructing a platform from an identifier.
        internal struct PlatformTemplate
        {
            public string Identifier;
            public Func<Platform> CreateInstance;
        };

        // Adds a platform to the collection of templates. Platforms register themselves by using
        // [InitializeOnLoad] and calling this function from a static constructor.
        internal static void AddPlatformTemplate<T>(string identifier) where T : Platform
        {
            PlatformTemplates.Add(new PlatformTemplate() {
                    Identifier = identifier,
                    CreateInstance = () => CreatePlatformInstance<T>(identifier)
                });
        }

        private static Platform CreatePlatformInstance<T>(string identifier) where T : Platform
        {
            Platform platform = CreateInstance<T>();
            platform.InitializeProperties();
            platform.Identifier = identifier;

            return platform;
        }

        internal void OnEnable()
        {
            if (hasLoaded)
            {
                // Already loaded
                return;
            }

            hasLoaded = true;

#if UNITY_EDITOR
            if (editorSettings != null)
            {
                // Clear the EditorSettings object in case it has not been reloaded (this can happen
                // if the settings asset is modified on disk).
                editorSettings.Clear();

                editorSettings.RuntimeSettings = this;
            }
#endif

            PopulatePlatformsFromAsset();

            DefaultPlatform = Platforms.FirstOrDefault(platform => platform is PlatformDefault);
            PlayInEditorPlatform = Platforms.FirstOrDefault(platform => platform is PlatformPlayInEditor);

#if UNITY_EDITOR
            if (editorSettings != null)
            {
                if (switchSettingsMigration == false)
                {
                    // Create Switch settings from the legacy Mobile settings, if they exist
                    Legacy.CopySetting(LiveUpdateSettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);
                    Legacy.CopySetting(OverlaySettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);

                    Legacy.CopySetting(RealChannelSettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);
                    Legacy.CopySetting(VirtualChannelSettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);
                    Legacy.CopySetting(SampleRateSettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);
                    Legacy.CopySetting(SpeakerModeSettings, Legacy.Platform.Mobile, Legacy.Platform.Switch);
                    switchSettingsMigration = true;
                }

                // Fix up slashes for old settings meta data.
                SourceProjectPath = RuntimeUtils.GetCommonPlatformPath(SourceProjectPath);
                sourceBankPathUnformatted = RuntimeUtils.GetCommonPlatformPath(sourceBankPathUnformatted);

                // Remove the FMODStudioCache if in the old location
                string oldCache = "Assets/Plugins/FMOD/Resources/FMODStudioCache.asset";
                if (File.Exists(oldCache))
                {
                    AssetDatabase.DeleteAsset(oldCache);
                }

                editorSettings.AddMissingPlatforms();

                // Add all known platforms to the settings asset. We can only do this if the Settings
                // object is already in the asset database, which won't be the case if we're inside the
                // CreateInstance call in the Instance accessor above.
                if (AssetDatabase.Contains(this))
                {
                    editorSettings.AddPlatformsToAsset();
                }
            }
#endif

            // Link all known platforms
            Platforms.ForEach(LinkPlatform);
        }

        private void PopulatePlatformsFromAsset()
        {
            Platforms.Clear();

#if UNITY_EDITOR
            string assetPath = AssetDatabase.GetAssetPath(this);
            UnityEngine.Object[] assets = AssetDatabase.LoadAllAssetsAtPath(assetPath);
            Platform[] assetPlatforms = assets.OfType<Platform>().ToArray();
#else
            Platform[] assetPlatforms = Resources.LoadAll<Platform>(SettingsAssetName);
#endif

            foreach (Platform newPlatform in assetPlatforms)
            {
                Platform existingPlatform = FindPlatform(newPlatform.Identifier);

                if (existingPlatform != null)
                {
                    // Duplicate platform; clean one of them up
                    Platform platformToDestroy;

                    if (newPlatform.Active && !existingPlatform.Active)
                    {
                        RemovePlatform(existingPlatform.Identifier);

                        platformToDestroy = existingPlatform;
                        existingPlatform = null;
                    }
                    else
                    {
                        platformToDestroy = newPlatform;
                    }

                    RuntimeUtils.DebugLogWarningFormat("FMOD: Cleaning up duplicate platform: ID  = {0}, name = '{1}', type = {2}",
                        platformToDestroy.Identifier, platformToDestroy.DisplayName, platformToDestroy.GetType().Name);

                    DestroyImmediate(platformToDestroy, true);
                }

                if (existingPlatform == null)
                {
                    newPlatform.EnsurePropertiesAreValid();
                    AddPlatform(newPlatform);
                }
            }

#if UNITY_EDITOR
            // Remove any invalid child platforms (ie. deprecated platforms).
            foreach (Platform newPlatform in assetPlatforms)
            {
                if (newPlatform.ChildIdentifiers.RemoveAll(x => FindPlatform(x) == null) > 0)
                {
                    EditorUtility.SetDirty(newPlatform);
                }
            }

            if (editorSettings != null)
            {
                Platforms.ForEach(editorSettings.UpdateMigratedPlatform);
            }
#endif
        }
    }

    // This class stores data types and code used for migrating old settings.
    internal static class Legacy
    {
#if UNITY_EDITOR
        private const string RegisterStaticPluginsAssetPathRelative =
            "/Plugins/FMOD/Cache/fmod_register_static_plugins.cpp";
        private const string RegisterStaticPluginsAssetPathFull = "Assets" + RegisterStaticPluginsAssetPathRelative;

        public static void CleanTemporaryChanges()
        {
            CleanIl2CppArgs();
            CleanTemporaryFiles();
        }

        private static IEnumerable<string> AdditionalIl2CppFiles()
        {
            yield return Application.dataPath + RegisterStaticPluginsAssetPathRelative;
            yield return Application.dataPath + "/Plugins/FMOD/src/Runtime/fmod_static_plugin_support.h";
        }

        public static void CleanIl2CppArgs()
        {
            const string Il2CppCommand_AdditionalCpp = "--additional-cpp";

            string arguments = PlayerSettings.GetAdditionalIl2CppArgs();
            string newArguments = arguments;

            foreach (string path in AdditionalIl2CppFiles())
            {
                // Match on basename only in case the temp file location has moved
                string basename = Regex.Escape(Path.GetFileName(path));
                Regex regex = new Regex(Il2CppCommand_AdditionalCpp + "=\"[^\"]*" + basename + "\"");

                for (int startIndex = 0; startIndex < newArguments.Length; )
                {
                    Match match = regex.Match(newArguments, startIndex);

                    if (!match.Success)
                    {
                        break;
                    }

                    RuntimeUtils.DebugLogFormat("FMOD: Removing Il2CPP argument '{0}'", match.Value);

                    int matchStart = match.Index;
                    int matchEnd = match.Index + match.Length;

                    // Consume an adjacent space if there is one
                    if (matchStart > 0 && newArguments[matchStart - 1] == ' ')
                    {
                        --matchStart;
                    }
                    else if (matchEnd < newArguments.Length && newArguments[matchEnd] == ' ')
                    {
                        ++matchEnd;
                    }

                    newArguments = newArguments.Substring(0, matchStart) + newArguments.Substring(matchEnd);
                    startIndex = matchStart;
                }
            }

            if (newArguments != arguments)
            {
                PlayerSettings.SetAdditionalIl2CppArgs(newArguments);
            }
        }

        public static void CleanTemporaryFiles()
        {
            if (EditorApplication.isPlayingOrWillChangePlaymode)
            {
                // Messing with the asset database while entering play mode causes a NullReferenceException
                return;
            }

            string[] TemporaryFiles = {
                RegisterStaticPluginsAssetPathFull,
            };

            foreach (string path in TemporaryFiles)
            {
                if (Settings.EditorSettings != null)
                {
                    Settings.EditorSettings.DeleteTemporaryFile(path);
                }
            }
        }
#endif

        [Serializable]
        public enum Platform
        {
            None,
            PlayInEditor,
            Default,
            Desktop,
            Mobile,
            MobileHigh,
            MobileLow,
            Console,
            Windows,
            Mac,
            Linux,
            iOS,
            Android,
            Deprecated_1,
            XboxOne,
            PS4,
            Deprecated_2,
            Deprecated_3,
            AppleTV,
            UWP,
            Switch,
            WebGL,
            Deprecated_4,
            Reserved_1,
            Reserved_2,
            Reserved_3,
            Count,
        }

        public class PlatformSettingBase
        {
            public Platform Platform;
        }

        public class PlatformSetting<T> : PlatformSettingBase
        {
            public T Value;
        }

        [Serializable]
        public class PlatformIntSetting : PlatformSetting<int>
        {
        }

        [Serializable]
        public class PlatformStringSetting : PlatformSetting<string>
        {
        }

        [Serializable]
        public class PlatformBoolSetting : PlatformSetting<TriStateBool>
        {
        }

        // Copies a setting from one platform to another.
        public static void CopySetting<T, U>(List<T> list, Platform fromPlatform, Platform toPlatform)
            where T : PlatformSetting<U>, new()
        {
            T fromSetting = list.Find((x) => x.Platform == fromPlatform);
            T toSetting = list.Find((x) => x.Platform == toPlatform);

            if (fromSetting != null)
            {
                if (toSetting == null)
                {
                    toSetting = new T() { Platform = toPlatform };
                    list.Add(toSetting);
                }

                toSetting.Value = fromSetting.Value;
            }
            else if (toSetting != null)
            {
                list.Remove(toSetting);
            }
        }

        public static void CopySetting(List<PlatformBoolSetting> list, Platform fromPlatform, Platform toPlatform)
        {
            CopySetting<PlatformBoolSetting, TriStateBool>(list, fromPlatform, toPlatform);
        }

        public static void CopySetting(List<PlatformIntSetting> list, Platform fromPlatform, Platform toPlatform)
        {
            CopySetting<PlatformIntSetting, int>(list, fromPlatform, toPlatform);
        }

        // Returns the UI display name for the given platform.
        public static string DisplayName(Platform platform)
        {
            switch (platform)
            {
                case Platform.Linux:
                    return "Linux";
                case Platform.Desktop:
                    return "Desktop";
                case Platform.Console:
                    return "Console";
                case Platform.iOS:
                    return "iOS";
                case Platform.Mac:
                    return "OSX";
                case Platform.Mobile:
                    return "Mobile";
                case Platform.PS4:
                    return "PS4";
                case Platform.Windows:
                    return "Windows";
                case Platform.UWP:
                    return "UWP";
                case Platform.XboxOne:
                    return "XBox One";
                case Platform.Android:
                    return "Android";
                case Platform.AppleTV:
                    return "Apple TV";
                case Platform.MobileHigh:
                    return "High-End Mobile";
                case Platform.MobileLow:
                    return "Low-End Mobile";
                case Platform.Switch:
                    return "Switch";
                case Platform.WebGL:
                    return "WebGL";
            }
            return "Unknown";
        }

        // Returns the UI sort order for the given platform.
        public static float SortOrder(Platform legacyPlatform)
        {
            switch (legacyPlatform)
            {
                case Platform.Desktop:
                    return 1;
                case Platform.Windows:
                    return 1.1f;
                case Platform.Mac:
                    return 1.2f;
                case Platform.Linux:
                    return 1.3f;
                case Platform.Mobile:
                    return 2;
                case Platform.MobileHigh:
                    return 2.1f;
                case Platform.MobileLow:
                    return 2.2f;
                case Platform.AppleTV:
                    return 2.3f;
                case Platform.Console:
                    return 3;
                case Platform.XboxOne:
                    return 3.1f;
                case Platform.PS4:
                    return 3.2f;
                case Platform.Switch:
                    return 3.3f;
                default:
                    return 0;
            }
        }

        // Returns the parent for the given platform.
        public static Platform Parent(Platform platform)
        {
            switch (platform)
            {
                case Platform.Windows:
                case Platform.Linux:
                case Platform.Mac:
                case Platform.UWP:
                case Platform.WebGL:
                    return Platform.Desktop;
                case Platform.MobileHigh:
                case Platform.MobileLow:
                case Platform.iOS:
                case Platform.Android:
                case Platform.AppleTV:
                    return Platform.Mobile;
                case Platform.Switch:
                case Platform.XboxOne:
                case Platform.PS4:
                case Platform.Reserved_1:
                case Platform.Reserved_2:
                case Platform.Reserved_3:
                    return Platform.Console;
                case Platform.Desktop:
                case Platform.Console:
                case Platform.Mobile:
                    return Platform.Default;
                case Platform.PlayInEditor:
                case Platform.Default:
                default:
                    return Platform.None;
            }
        }

        // Determines whether the given platform is a group
        public static bool IsGroup(Platform platform)
        {
            switch (platform)
            {
                case Platform.Desktop:
                case Platform.Mobile:
                case Platform.Console:
                    return true;
                default:
                    return false;
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Settings.cs.meta
================================================
fileFormatVersion: 2
guid: eef8d824ea7b63742966aaa0e94ac383
timeCreated: 1435215721
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -400
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/StudioBankLoader.cs
================================================
﻿using UnityEngine;
using System.Collections.Generic;

namespace FMODUnity
{
    [AddComponentMenu("FMOD Studio/FMOD Studio Bank Loader")]
    public class StudioBankLoader : MonoBehaviour
    {
        public LoaderGameEvent LoadEvent;
        public LoaderGameEvent UnloadEvent;
        [BankRef]
        public List<string> Banks;
        public string CollisionTag;
        public bool PreloadSamples;
        private bool isQuitting;

        private void HandleGameEvent(LoaderGameEvent gameEvent)
        {
            if (LoadEvent == gameEvent)
            {
                Load();
            }
            if (UnloadEvent == gameEvent)
            {
                Unload();
            }
        }

        private void Start()
        {
            RuntimeUtils.EnforceLibraryOrder();
            HandleGameEvent(LoaderGameEvent.ObjectStart);
        }

        private void OnApplicationQuit()
        {
            isQuitting = true;
        }

        private void OnDestroy()
        {
            if (!isQuitting)
            {
                HandleGameEvent(LoaderGameEvent.ObjectDestroy);
            }
        }

#if UNITY_PHYSICS_EXIST
        private void OnTriggerEnter(Collider other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(LoaderGameEvent.TriggerEnter);
            }
        }

        private void OnTriggerExit(Collider other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(LoaderGameEvent.TriggerExit);
            }
        }
#endif

#if UNITY_PHYSICS2D_EXIST
        private void OnTriggerEnter2D(Collider2D other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(LoaderGameEvent.TriggerEnter2D);
            }
        }

        private void OnTriggerExit2D(Collider2D other)
        {
            if (string.IsNullOrEmpty(CollisionTag) || other.CompareTag(CollisionTag))
            {
                HandleGameEvent(LoaderGameEvent.TriggerExit2D);
            }
        }
#endif

        private void OnEnable()
        {
            HandleGameEvent(LoaderGameEvent.ObjectEnable);
        }

        private void OnDisable()
        {
            HandleGameEvent(LoaderGameEvent.ObjectDisable);
        }

        public void Load()
        {
            foreach (var bankRef in Banks)
            {
                try
                {
                    RuntimeManager.LoadBank(bankRef, PreloadSamples);
                }
                catch (BankLoadException e)
                {
                    RuntimeUtils.DebugLogException(e);
                }
            }

            if (PreloadSamples)
            {
                RuntimeManager.WaitForAllSampleLoading();
            }
        }

        public void Unload()
        {
            foreach (var bankRef in Banks)
            {
                RuntimeManager.UnloadBank(bankRef);
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/StudioBankLoader.cs.meta
================================================
fileFormatVersion: 2
guid: b9468c5f457ace64f8d4df6d642b107f
timeCreated: 1440562167
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -250
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/StudioEventEmitter.cs
================================================
﻿using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace FMODUnity
{
    [AddComponentMenu("FMOD Studio/FMOD Studio Event Emitter")]
    public class StudioEventEmitter : EventHandler
    {
        public EventReference EventReference;

        [Obsolete("Use the EventReference field instead")]
        public string Event = "";

        [FormerlySerializedAs("PlayEvent")]
        public EmitterGameEvent EventPlayTrigger = EmitterGameEvent.None;
        [Obsolete("Use the EventPlayTrigger field instead")]
        public EmitterGameEvent PlayEvent
        {
            get { return EventPlayTrigger; }
            set { EventPlayTrigger = value; }
        }
        [FormerlySerializedAs("StopEvent")]
        public EmitterGameEvent EventStopTrigger = EmitterGameEvent.None;
        [Obsolete("Use the EventStopTrigger field instead")]
        public EmitterGameEvent StopEvent
        {
            get { return EventStopTrigger; }
            set { EventStopTrigger = value; }
        }
        public bool AllowFadeout = true;
        public bool TriggerOnce = false;
        public bool Preload = false;
        [FormerlySerializedAs("AllowNonRigidbodyDoppler")]
        public bool NonRigidbodyVelocity = false;
        public ParamRef[] Params = new ParamRef[0];
        public bool OverrideAttenuation = false;
        public float OverrideMinDistance = -1.0f;
        public float OverrideMaxDistance = -1.0f;

        protected FMOD.Studio.EventDescription eventDescription;

        protected FMOD.Studio.EventInstance instance;

        private bool hasTriggered = false;
        private bool isQuitting = false;
        private bool isOneshot = false;
        private List<ParamRef> cachedParams = new List<ParamRef>();

        private static List<StudioEventEmitter> activeEmitters = new List<StudioEventEmitter>();

        private const string SnapshotString = "snapshot";

        public FMOD.Studio.EventDescription EventDescription { get { return eventDescription; } }

        public FMOD.Studio.EventInstance EventInstance { get { return instance; } }

        public bool IsActive { get; private set; }

        private float MaxDistance
        {
            get
            {
                if (OverrideAttenuation)
                {
                    return OverrideMaxDistance;
                }

                if (!eventDescription.isValid())
                {
                    Lookup();
                }

                float minDistance, maxDistance;
                eventDescription.getMinMaxDistance(out minDistance, out maxDistance);
                return maxDistance;
            }
        }

        public static void UpdateActiveEmitters()
        {
            foreach (StudioEventEmitter emitter in activeEmitters)
            {
                emitter.UpdatePlayingStatus();
            }
        }

        private static void RegisterActiveEmitter(StudioEventEmitter emitter)
        {
            if (!activeEmitters.Contains(emitter))
            {
                activeEmitters.Add(emitter);
            }
        }

        private static void DeregisterActiveEmitter(StudioEventEmitter emitter)
        {
            activeEmitters.Remove(emitter);
        }

        private void UpdatePlayingStatus(bool force = false)
        {
            // If at least one listener is within the max distance, ensure an event instance is playing
            bool playInstance = StudioListener.DistanceSquaredToNearestListener(transform.position) <= (MaxDistance * MaxDistance);

            if (force || playInstance != IsPlaying())
            {
                if (playInstance)
                {
                    PlayInstance();
                }
                else
                {
                    StopInstance();
                }
            }
        }

        protected override void Start()
        {
            RuntimeUtils.EnforceLibraryOrder();
            if (Preload)
            {
                Lookup();
                eventDescription.loadSampleData();
            }

            HandleGameEvent(EmitterGameEvent.ObjectStart);

            // If a Rigidbody or Rigidbody2D is present on this GameObject, turn off "NonRigidbodyVelocity"
#if UNITY_PHYSICS_EXIST
            if (NonRigidbodyVelocity && GetComponent<Rigidbody>())
            {
                Debug.LogWarning(string.Format("[FMOD] Non-Rigidbody Velocity is enabled on Emitter attached to GameObject \"{0}\", which also has a Rigidbody component attached - this will be disabled in favor of velocity from Rigidbody component.", this.name));
                NonRigidbodyVelocity = false;
            }
#endif
#if UNITY_PHYSICS2D_EXIST
            if (NonRigidbodyVelocity && GetComponent<Rigidbody2D>())
            {
                Debug.LogWarning(string.Format("[FMOD] Non-Rigidbody Velocity is enabled on Emitter attached to GameObject \"{0}\", which also has a Rigidbody2D component attached - this will be disabled in favor of velocity from Rigidbody2D component.", this.name));
                NonRigidbodyVelocity = false;
            }
#endif
        }

        private void OnApplicationQuit()
        {
            isQuitting = true;
        }

        protected override void OnDestroy()
        {
            if (!isQuitting)
            {
                HandleGameEvent(EmitterGameEvent.ObjectDestroy);

                if (instance.isValid())
                {
                    RuntimeManager.DetachInstanceFromGameObject(instance);
                    if (eventDescription.isValid() && isOneshot)
                    {
                        instance.release();
                        instance.clearHandle();
                    }
                }

                DeregisterActiveEmitter(this);

                if (Preload)
                {
                    eventDescription.unloadSampleData();
                }
            }
        }

        protected override void HandleGameEvent(EmitterGameEvent gameEvent)
        {
            if (EventPlayTrigger == gameEvent)
            {
                Play();
            }
            if (EventStopTrigger == gameEvent)
            {
                Stop();
            }
        }

        private void Lookup()
        {
            eventDescription = RuntimeManager.GetEventDescription(EventReference);

            if (eventDescription.isValid())
            {
                for (int i = 0; i < Params.Length; i++)
                {
                    FMOD.Studio.PARAMETER_DESCRIPTION param;
                    eventDescription.getParameterDescriptionByName(Params[i].Name, out param);
                    Params[i].ID = param.id;
                }
            }
        }

        public void Play()
        {
            if (TriggerOnce && hasTriggered)
            {
                return;
            }

            if (EventReference.IsNull)
            {
                return;
            }

            cachedParams.Clear();

            if (!eventDescription.isValid())
            {
                Lookup();
            }

            bool isSnapshot;
            eventDescription.isSnapshot(out isSnapshot);

            if (!isSnapshot)
            {
                eventDescription.isOneshot(out isOneshot);
            }

            bool is3D;
            eventDescription.is3D(out is3D);

            IsActive = true;

            if (is3D && Settings.Instance.StopEventsOutsideMaxDistance)
            {
                if (!isOneshot)
                {
                    RegisterActiveEmitter(this);
                }

                UpdatePlayingStatus(true);
            }
            else
            {
                PlayInstance();
            }
        }

        private void PlayInstance()
        {
            if (!instance.isValid())
            {
                instance.clearHandle();
            }

            // Let previous oneshot instances play out
            if (isOneshot && instance.isValid())
            {
                instance.release();
                instance.clearHandle();
            }

            bool is3D;
            eventDescription.is3D(out is3D);

            if (!instance.isValid())
            {
                eventDescription.createInstance(out instance);

                // Only want to update if we need to set 3D attributes
                if (is3D)
                {
                    var transform = GetComponent<Transform>();
#if UNITY_PHYSICS_EXIST
                    if (GetComponent<Rigidbody>())
                    {
                        Rigidbody rigidBody = GetComponent<Rigidbody>();
                        instance.set3DAttributes(RuntimeUtils.To3DAttributes(gameObject, rigidBody));
                        RuntimeManager.AttachInstanceToGameObject(instance, gameObject, rigidBody);
                    }
                    else
#endif
#if UNITY_PHYSICS2D_EXIST
                    if (GetComponent<Rigidbody2D>())
                    {
                        var rigidBody2D = GetComponent<Rigidbody2D>();
                        instance.set3DAttributes(RuntimeUtils.To3DAttributes(gameObject, rigidBody2D));
                        RuntimeManager.AttachInstanceToGameObject(instance, gameObject, rigidBody2D);
                    }
                    else
#endif
                    {
                        instance.set3DAttributes(RuntimeUtils.To3DAttributes(gameObject));
                        RuntimeManager.AttachInstanceToGameObject(instance, gameObject, NonRigidbodyVelocity);
                    }
                }
            }

            foreach (var param in Params)
            {
                instance.setParameterByID(param.ID, param.Value);
            }

            foreach (var cachedParam in cachedParams)
            {
                instance.setParameterByID(cachedParam.ID, cachedParam.Value);
            }

            if (is3D && OverrideAttenuation)
            {
                instance.setProperty(FMOD.Studio.EVENT_PROPERTY.MINIMUM_DISTANCE, OverrideMinDistance);
                instance.setProperty(FMOD.Studio.EVENT_PROPERTY.MAXIMUM_DISTANCE, OverrideMaxDistance);
            }

            instance.start();

            hasTriggered = true;
        }

        public void Stop()
        {
            DeregisterActiveEmitter(this);
            IsActive = false;
            cachedParams.Clear();
            StopInstance();
        }

        private void StopInstance()
        {
            if (TriggerOnce && hasTriggered)
            {
                DeregisterActiveEmitter(this);
            }

            if (instance.isValid())
            {
                instance.stop(AllowFadeout ? FMOD.Studio.STOP_MODE.ALLOWFADEOUT : FMOD.Studio.STOP_MODE.IMMEDIATE);
                instance.release();
                if (!AllowFadeout)
                {
                    instance.clearHandle();
                }
            }
        }

        public void SetParameter(string name, float value, bool ignoreseekspeed = false)
        {
            if (Settings.Instance.StopEventsOutsideMaxDistance && IsActive)
            {
                string findName = name;
                ParamRef cachedParam = cachedParams.Find(x => x.Name == findName);

                if (cachedParam == null)
                {
                    FMOD.Studio.PARAMETER_DESCRIPTION paramDesc;
                    eventDescription.getParameterDescriptionByName(name, out paramDesc);

                    cachedParam = new ParamRef();
                    cachedParam.ID = paramDesc.id;
                    cachedParam.Name = paramDesc.name;
                    cachedParams.Add(cachedParam);
                }

                cachedParam.Value = value;
            }

            if (instance.isValid())
            {
                instance.setParameterByName(name, value, ignoreseekspeed);
            }
        }

        public void SetParameter(FMOD.Studio.PARAMETER_ID id, float value, bool ignoreseekspeed = false)
        {
            if (Settings.Instance.StopEventsOutsideMaxDistance && IsActive)
            {
                FMOD.Studio.PARAMETER_ID findId = id;
                ParamRef cachedParam = cachedParams.Find(x => x.ID.Equals(findId));

                if (cachedParam == null)
                {
                    FMOD.Studio.PARAMETER_DESCRIPTION paramDesc;
                    eventDescription.getParameterDescriptionByID(id, out paramDesc);

                    cachedParam = new ParamRef();
                    cachedParam.ID = paramDesc.id;
                    cachedParam.Name = paramDesc.name;
                    cachedParams.Add(cachedParam);
                }

                cachedParam.Value = value;
            }

            if (instance.isValid())
            {
                instance.setParameterByID(id, value, ignoreseekspeed);
            }
        }

        public bool IsPlaying()
        {
            if (instance.isValid())
            {
                FMOD.Studio.PLAYBACK_STATE playbackState;
                instance.getPlaybackState(out playbackState);
                return (playbackState != FMOD.Studio.PLAYBACK_STATE.STOPPED);
            }
            return false;
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/StudioEventEmitter.cs.meta
================================================
fileFormatVersion: 2
guid: 9a6610d2e704f1648819acc8d7460285
timeCreated: 1444629021
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: -220
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/StudioGlobalParameterTrigger.cs
================================================
﻿using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace FMODUnity
{
    [AddComponentMenu("FMOD Studio/FMOD Studio Global Parameter Trigger")]
    public class StudioGlobalParameterTrigger: EventHandler
    {
        [ParamRef]
        [FormerlySerializedAs("parameter")]
        public string Parameter;

        public EmitterGameEvent TriggerEvent;

        [FormerlySerializedAs("value")]
        public float Value;

        private FMOD.Studio.PARAMETER_DESCRIPTION parameterDescription;
        public FMOD.Studio.PARAMETER_DESCRIPTION ParameterDescription { get { return parameterDescription; } }

        protected override void HandleGameEvent(EmitterGameEvent gameEvent)
        {
            if (TriggerEvent == gameEvent)
            {
                TriggerParameters();
            }
        }

        public void TriggerParameters()
        {
            bool paramNameSpecified = !string.IsNullOrEmpty(Parameter);
            if (paramNameSpecified)
            {
                FMOD.RESULT result = FMOD.RESULT.OK;
                bool paramIDNeedsLookup = string.IsNullOrEmpty(parameterDescription.name);
                if (paramIDNeedsLookup)
                {
                    result = RuntimeManager.StudioSystem.getParameterDescriptionByName(Parameter, out parameterDescription);
                    if (result != FMOD.RESULT.OK)
                    {
                        RuntimeUtils.DebugLogError(string.Format(("[FMOD] StudioGlobalParameterTrigger failed to lookup parameter {0} : result = {1}"), Parameter, result));
                        return;
                    }
                }

                result = RuntimeManager.StudioSystem.setParameterByID(parameterDescription.id, Value);
                if (result != FMOD.RESULT.OK)
                {
                    RuntimeUtils.DebugLogError(string.Format(("[FMOD] StudioGlobalParameterTrigger failed to set parameter {0} : result = {1}"), Parameter, result));
                    return;
                }
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/StudioGlobalParameterTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 9b0e04e2572f9a940a47465f6f3c2f00
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/StudioListener.cs
================================================
using System.Collections.Generic;
using UnityEngine;

namespace FMODUnity
{
    [AddComponentMenu("FMOD Studio/FMOD Studio Listener")]
    public class StudioListener : MonoBehaviour
    {
        [SerializeField]
        private bool nonRigidbodyVelocity = false;

        [SerializeField]
        private GameObject attenuationObject = null;

        public GameObject AttenuationObject
        {
            get { return attenuationObject; }
            set { attenuationObject = value; }
        }

        private Vector3 lastFramePosition = Vector3.zero;

#if UNITY_PHYSICS_EXIST
        private Rigidbody rigidBody;
#endif
#if UNITY_PHYSICS2D_EXIST
        private Rigidbody2D rigidBody2D;
#endif
        private static List<StudioListener> listeners = new List<StudioListener>();

        public static int ListenerCount
        {
            get
            {
                return listeners.Count;
            }
        }

        public int ListenerNumber
        {
            get
            {
                return listeners.IndexOf(this);
            }
        }

        public static float DistanceToNearestListener(Vector3 position)
        {
            float result = float.MaxValue;
            for (int i = 0; i < listeners.Count; i++)
            {
                if (listeners[i].attenuationObject == null)
                {
                    result = Mathf.Min(result, Vector3.Distance(position, listeners[i].transform.position));
                }
                else
                {
                    result = Mathf.Min(result, Vector3.Distance(position, listeners[i].attenuationObject.transform.position));
                }
            }
            return result;
        }

        public static float DistanceSquaredToNearestListener(Vector3 position)
        {
            float result = float.MaxValue;
            for (int i = 0; i < listeners.Count; i++)
            {
                if (listeners[i].attenuationObject == null)
                {
                    result = Mathf.Min(result, (position - listeners[i].transform.position).sqrMagnitude);
                }
                else
                {
                    result = Mathf.Min(result, (position - listeners[i].attenuationObject.transform.position).sqrMagnitude);
                }
            }
            return result;
        }

        private static void AddListener(StudioListener listener)
        {
            // Is the listener already in the list?
            if (listeners.Contains(listener))
            {
                Debug.LogWarning(string.Format(("[FMOD] Listener has already been added at index {0}."), listener.ListenerNumber));
                return;
            }

            // If already at the max numListeners
            if (listeners.Count >= FMOD.CONSTANTS.MAX_LISTENERS)
            {
                Debug.LogWarning(string.Format(("[FMOD] Max number of listeners reached : {0}."), FMOD.CONSTANTS.MAX_LISTENERS));
            }

            listeners.Add(listener);
            RuntimeManager.StudioSystem.setNumListeners(Mathf.Clamp(listeners.Count, 1, FMOD.CONSTANTS.MAX_LISTENERS));
        }

        private static void RemoveListener(StudioListener listener)
        {
            listeners.Remove(listener);
            RuntimeManager.StudioSystem.setNumListeners(Mathf.Clamp(listeners.Count, 1, FMOD.CONSTANTS.MAX_LISTENERS));
        }

        private void OnEnable()
        {
            RuntimeUtils.EnforceLibraryOrder();
#if UNITY_PHYSICS_EXIST
            rigidBody = gameObject.GetComponent<Rigidbody>();

            if (nonRigidbodyVelocity && rigidBody)
            {
                Debug.LogWarning(string.Format("[FMOD] Non-Rigidbody Velocity is enabled on Listener attached to GameObject \"{0}\", which also has a Rigidbody component attached - this will be disabled in favor of velocity from Rigidbody component.", this.name));
                nonRigidbodyVelocity = false;
            }
#endif
#if UNITY_PHYSICS2D_EXIST
            rigidBody2D = gameObject.GetComponent<Rigidbody2D>();

            if (nonRigidbodyVelocity && rigidBody2D)
            {
                Debug.LogWarning(string.Format("[FMOD] Non-Rigidbody Velocity is enabled on Listener attached to GameObject \"{0}\", which also has a Rigidbody2D component attached - this will be disabled in favor of velocity from Rigidbody2D component.", this.name));
                nonRigidbodyVelocity = false;
            }
#endif
            AddListener(this);

            lastFramePosition = transform.position;
        }

        private void OnDisable()
        {
            RemoveListener(this);
        }

        private void Update()
        {
            if (ListenerNumber < 0 || ListenerNumber >= FMOD.CONSTANTS.MAX_LISTENERS)
            {
                return;
            }

            if (nonRigidbodyVelocity)
            {
                var velocity = Vector3.zero;
                var position = transform.position;

                if (Time.deltaTime != 0)
                {
                    velocity = (position - lastFramePosition) / Time.deltaTime;
                    velocity = Vector3.ClampMagnitude(velocity, 20.0f);
                }

                lastFramePosition = position;

                RuntimeManager.SetListenerLocation(ListenerNumber, gameObject, attenuationObject, velocity);
            }
            else
            {
#if UNITY_PHYSICS_EXIST
                if (rigidBody)
                {
                    RuntimeManager.SetListenerLocation(ListenerNumber, gameObject, rigidBody, attenuationObject);
                }
                else
#endif
#if UNITY_PHYSICS2D_EXIST
                if (rigidBody2D)
                {
                    RuntimeManager.SetListenerLocation(ListenerNumber, gameObject, rigidBody2D, attenuationObject);
                }
                else
#endif
                {
                    RuntimeManager.SetListenerLocation(ListenerNumber, gameObject, attenuationObject);
                }
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/StudioListener.cs.meta
================================================
fileFormatVersion: 2
guid: 86c6556701af9e04380698b89f691b6e
timeCreated: 1449016511
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 80
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/StudioParameterTrigger.cs
================================================
﻿using System;
using UnityEngine;

namespace FMODUnity
{
    [Serializable]
    public class EmitterRef
    {
        public StudioEventEmitter Target;
        public ParamRef[] Params;
    }

    [AddComponentMenu("FMOD Studio/FMOD Studio Parameter Trigger")]
    public class StudioParameterTrigger: EventHandler
    {
        public EmitterRef[] Emitters;
        public EmitterGameEvent TriggerEvent;

        private void Awake()
        {
            for (int i = 0; i < Emitters.Length; i++)
            {
                var emitterRef = Emitters[i];
                if (emitterRef.Target != null && !emitterRef.Target.EventReference.IsNull)
                {
                    FMOD.Studio.EventDescription eventDesc = RuntimeManager.GetEventDescription(emitterRef.Target.EventReference);
                    if (eventDesc.isValid())
                    {
                        for (int j = 0; j < Emitters[i].Params.Length; j++)
                        {
                            FMOD.Studio.PARAMETER_DESCRIPTION param;
                            eventDesc.getParameterDescriptionByName(emitterRef.Params[j].Name, out param);
                            emitterRef.Params[j].ID = param.id;
                        }
                    }
                }
            }
        }

        protected override void HandleGameEvent(EmitterGameEvent gameEvent)
        {
            if (TriggerEvent == gameEvent)
            {
                TriggerParameters();
            }
        }

        public void TriggerParameters()
        {
            for (int i = 0; i < Emitters.Length; i++)
            {
                var emitterRef = Emitters[i];
                if (emitterRef.Target != null && emitterRef.Target.EventInstance.isValid())
                {
                    for (int j = 0; j < Emitters[i].Params.Length; j++)
                    {
                        emitterRef.Target.EventInstance.setParameterByID(Emitters[i].Params[j].ID, Emitters[i].Params[j].Value);
                    }
                }
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/StudioParameterTrigger.cs.meta
================================================
fileFormatVersion: 2
guid: 744a208c85da6d04c861d81b992e4ead
timeCreated: 1451968823
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefDrawer.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomPropertyDrawer(typeof(BankRefAttribute))]
    public class BankRefDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            Texture browseIcon = EditorUtils.LoadImage("SearchIconBlack.png");

            SerializedProperty pathProperty = property;

            EditorGUI.BeginProperty(position, label, property);

            Event e = Event.current;
            if (e.type == EventType.DragPerform && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorBankRef))
                {
                    pathProperty.stringValue = ((EditorBankRef)DragAndDrop.objectReferences[0]).Name;

                    e.Use();
                }
            }
            if (e.type == EventType.DragUpdated && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorBankRef))
                {
                    DragAndDrop.visualMode = DragAndDropVisualMode.Move;
                    DragAndDrop.AcceptDrag();
                    e.Use();
                }
            }

            float baseHeight = GUI.skin.textField.CalcSize(new GUIContent()).y;

            position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);

            var buttonStyle = new GUIStyle(GUI.skin.button);
            buttonStyle.padding.top = buttonStyle.padding.bottom = 1;

            Rect searchRect = new Rect(position.x + position.width - browseIcon.width - 15, position.y, browseIcon.width + 10, baseHeight);
            Rect pathRect = new Rect(position.x, position.y, searchRect.x - position.x - 5, baseHeight);

            EditorGUI.PropertyField(pathRect, pathProperty, GUIContent.none);
            if (GUI.Button(searchRect, new GUIContent(browseIcon, "Select FMOD Bank"), buttonStyle))
            {
                var eventBrowser = ScriptableObject.CreateInstance<EventBrowser>();

                eventBrowser.ChooseBank(property);
                var windowRect = position;
                windowRect.position = GUIUtility.GUIToScreenPoint(windowRect.position);
                windowRect.height = searchRect.height + 1;
                eventBrowser.ShowAsDropDown(windowRect, new Vector2(windowRect.width, 400));
            }

            EditorGUI.EndProperty();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefDrawer.cs.meta
================================================
fileFormatVersion: 2
guid: 49ebe6fea5e4bfc4bb492bba062b2afe
timeCreated: 1433209573
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefresher.cs
================================================
﻿using System;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    public class BankRefresher
    {
        private static string currentWatchPath;
        private static FileSystemWatcher sourceFileWatcher;
        private static bool sourceFilesChanged = false;
        private static float lastSourceFileChange = float.MaxValue;
        private static bool autoRefresh = true;
        private static float nextFilePollTime = float.MinValue;

        private const int FilePollPeriod = 5;

        public static void DisableAutoRefresh()
        {
            autoRefresh = false;
        }

        public static void Startup()
        {
            sourceFileWatcher = new FileSystemWatcher();
            sourceFileWatcher.IncludeSubdirectories = true;
            sourceFileWatcher.NotifyFilter = NotifyFilters.LastWrite;

            sourceFileWatcher.Changed += OnSourceFileChanged;
            sourceFileWatcher.Created += OnSourceFileChanged;
            sourceFileWatcher.Deleted += OnSourceFileChanged;

            EditorApplication.update += Update;
        }

        private static void OnSourceFileChanged(object source, FileSystemEventArgs e)
        {
            sourceFilesChanged = true;
        }

        private static void Update()
        {
            UpdateFileWatcherPath();
            CheckSourceFilesChanged();
            CheckCacheFileExists();
            RefreshBanksIfReady();
        }

        private static void UpdateFileWatcherPath()
        {
            string sourceBankPath = Settings.Instance.SourceBankPath;

            string pathToWatch;

            if (Path.IsPathRooted(sourceBankPath))
            {
                pathToWatch = Path.GetFullPath(sourceBankPath);
            }
            else
            {
                pathToWatch = Path.GetFullPath(Environment.CurrentDirectory + "/" + sourceBankPath);
            }

            if (currentWatchPath != pathToWatch)
            {
                currentWatchPath = pathToWatch;

                try {
                    sourceFileWatcher.EnableRaisingEvents = false;
                    sourceFilesChanged = false;

                    if (!string.IsNullOrEmpty(sourceBankPath))
                    {
                        sourceFileWatcher.Path = pathToWatch;
                        sourceFileWatcher.EnableRaisingEvents = true;
                    }
                }
                catch (ArgumentException e)
                {
                    RuntimeUtils.DebugLogWarningFormat("Error watching {0}: {1}", pathToWatch, e.Message);
                }
            }
        }

        private static void CheckSourceFilesChanged()
        {
            if (sourceFilesChanged)
            {
                lastSourceFileChange = Time.realtimeSinceStartup;
                sourceFilesChanged = false;

                if (!BankRefreshWindow.IsVisible)
                {
                    autoRefresh = true;
                }

                if (IsWindowEnabled())
                {
                    BankRefreshWindow.ShowWindow();
                }
            }
        }

        private static void CheckCacheFileExists()
        {
            if (Time.realtimeSinceStartup >= nextFilePollTime)
            {
                if (!File.Exists(EventManager.CacheAssetFullName))
                {
                    EventManager.RefreshBanks();
                }

                nextFilePollTime = Time.realtimeSinceStartup + FilePollPeriod;
            }
        }

        private static void RefreshBanksIfReady()
        {
            if (TimeUntilBankRefresh() == 0 && BankRefreshWindow.ReadyToRefreshBanks)
            {
                EventManager.RefreshBanks();
            }
        }

        public static void HandleBankRefresh(string result)
        {
            lastSourceFileChange = float.MaxValue;
            BankRefreshWindow.HandleBankRefresh(result);
        }

        private static bool IsWindowEnabled()
        {
            Settings settings = Settings.Instance;

            return settings.BankRefreshCooldown == Settings.BankRefreshPrompt
                || (settings.BankRefreshCooldown >= 0 && settings.ShowBankRefreshWindow);
        }

        public static float TimeSinceSourceFileChange()
        {
            if (lastSourceFileChange == float.MaxValue)
            {
                return float.MaxValue;
            }
            else
            {
                return Mathf.Max(0, Time.realtimeSinceStartup - lastSourceFileChange);
            }
        }

        public static float TimeUntilBankRefresh()
        {
            if (!autoRefresh
                || lastSourceFileChange == float.MaxValue
                || Settings.Instance.BankRefreshCooldown < 0)
            {
                return float.MaxValue;
            }
            else
            {
                float nextRefreshTime = lastSourceFileChange + Settings.Instance.BankRefreshCooldown;
                return Mathf.Max(0, nextRefreshTime - Time.realtimeSinceStartup);
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefresher.cs.meta
================================================
fileFormatVersion: 2
guid: e564c074e96205b49b91ff80126983c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefreshWindow.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    public class BankRefreshWindow : EditorWindow
    {
        private static BankRefreshWindow instance = null;

        private SerializedObject serializedSettings;
        private SerializedProperty cooldown;
        private SerializedProperty showWindow;

        private bool readyToRefreshBanks = false;
        private float closeTime = float.MaxValue;
        private string lastRefreshError = null;

        private const float CloseDelay = 5;

        public static bool IsVisible { get { return instance != null; } }

        public static bool ReadyToRefreshBanks { get { return instance == null || instance.readyToRefreshBanks; } }

        public static void ShowWindow()
        {
            if (instance == null)
            {
                instance = CreateInstance<BankRefreshWindow>();
                instance.titleContent = new GUIContent(L10n.Tr("FMOD Bank Refresh Status"));
                instance.minSize = new Vector2(400, 200);
                instance.maxSize = new Vector2(1000, 200);

                instance.ShowUtility();
            }
        }

        private void OnEnable()
        {
            serializedSettings = new SerializedObject(Settings.Instance);
            cooldown = serializedSettings.FindProperty("BankRefreshCooldown");
            showWindow = serializedSettings.FindProperty("ShowBankRefreshWindow");

            // instance is set to null when scripts are recompiled
            if (instance == null)
            {
                instance = this;
            }
            else if (instance != this)
            {
                Close();
            }
        }

        private void OnDestroy()
        {
            if (instance == this)
            {
                instance = null;
            }
        }

        private void OnInspectorUpdate()
        {
            Repaint();

            if (BankRefresher.TimeUntilBankRefresh() != float.MaxValue)
            {
                closeTime = float.MaxValue;
            }

            if (Time.realtimeSinceStartup > closeTime)
            {
                Close();
            }
        }

        public static void HandleBankRefresh(string error)
        {
            if (error != null)
            {
                RuntimeUtils.DebugLogErrorFormat("FMOD: Bank refresh failed: {0}", error);
            }

            if (instance != null)
            {
                instance.readyToRefreshBanks = false;
                instance.lastRefreshError = error;

                if (error == null)
                {
                    instance.closeTime = Time.realtimeSinceStartup + CloseDelay;
                }
            }
        }

        private void OnGUI()
        {
            serializedSettings.Update();

            DrawStatus();

            GUILayout.FlexibleSpace();

            SettingsEditor.DisplayBankRefreshSettings(cooldown, showWindow, false);

            DrawButtons();

            serializedSettings.ApplyModifiedProperties();
        }

        private bool ConsumeEscapeKey()
        {
            if ((focusedWindow == this) && Event.current.isKey && Event.current.keyCode == KeyCode.Escape)
            {
                Event.current.Use();
                return true;
            }
            else
            {
                return false;
            }
        }

        private void DrawStatus()
        {
            GUIStyle labelStyle = new GUIStyle(EditorStyles.whiteLargeLabel);
            labelStyle.alignment = TextAnchor.MiddleCenter;

            GUIStyle largeErrorStyle = new GUIStyle(labelStyle);
            largeErrorStyle.normal.textColor = Color.red;

            GUIStyle errorStyle = new GUIStyle(GUI.skin.box);
            errorStyle.alignment = TextAnchor.UpperLeft;
            errorStyle.wordWrap = true;
            errorStyle.normal.textColor = Color.red;

            float timeSinceFileChange = BankRefresher.TimeSinceSourceFileChange();

            if (timeSinceFileChange != float.MaxValue)
            {
                GUILayout.Label(string.Format(L10n.Tr("The FMOD source banks changed {0} ago."),
                    EditorUtils.DurationString(timeSinceFileChange)), labelStyle);

                float timeUntilBankRefresh = BankRefresher.TimeUntilBankRefresh();

                if (timeUntilBankRefresh == 0)
                {
                    GUILayout.Label(L10n.Tr("Refreshing banks now..."), labelStyle);
                    readyToRefreshBanks = true;
                }
                else if (timeUntilBankRefresh != float.MaxValue)
                {
                    if (DrawCountdown(L10n.Tr("Refreshing banks"), timeUntilBankRefresh, Settings.Instance.BankRefreshCooldown, labelStyle)
                        || ConsumeEscapeKey())
                    {
                        BankRefresher.DisableAutoRefresh();
                    }
                }
                else
                {
                    GUILayout.Label(L10n.Tr("Would you like to refresh banks?"), labelStyle);
                }
            }
            else
            {
                if (lastRefreshError == null)
                {
                    GUILayout.Label(L10n.Tr("The FMOD banks are up to date."), labelStyle);
                }
                else
                {
                    GUILayout.Label(L10n.Tr("Bank refresh failed:"), largeErrorStyle);
                    GUILayout.Box(lastRefreshError, errorStyle, GUILayout.ExpandWidth(true));
                }
            }

            if (closeTime != float.MaxValue)
            {
                float timeUntilClose = Mathf.Max(0, closeTime - Time.realtimeSinceStartup);

                if (DrawCountdown(L10n.Tr("Closing"), timeUntilClose, CloseDelay, labelStyle) || ConsumeEscapeKey())
                {
                    closeTime = float.MaxValue;
                }
            }
        }

        private static bool DrawCountdown(string text, float remainingTime, float totalTime, GUIStyle labelStyle)
        {
            GUILayout.Label(string.Format(L10n.Tr("{0} in {1}..."), text, EditorUtils.DurationString(remainingTime)), labelStyle);

            const float boxHeight = 2;

            Rect controlRect = EditorGUILayout.GetControlRect(false, boxHeight * 2);

            Rect boxRect = controlRect;
            boxRect.width *= remainingTime / totalTime;
            boxRect.x += (controlRect.width - boxRect.width) / 2;
            boxRect.height = 2;

            GUI.DrawTexture(boxRect, EditorGUIUtility.whiteTexture);

            GUIContent cancelContent = new GUIContent(L10n.Tr("Cancel"));

            controlRect = EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight * 2);

            Rect buttonRect = controlRect;
            buttonRect.width = 100;
            buttonRect.x += (controlRect.width - buttonRect.width) / 2;

            return GUI.Button(buttonRect, cancelContent);
        }

        private void DrawButtons()
        {
            Rect rect = EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight * 2);

            int buttonCount = 2;

            Rect closeRect = rect;
            closeRect.width = rect.width / buttonCount;

            Rect refreshRect = rect;
            refreshRect.xMin = closeRect.xMax;

            if (GUI.Button(closeRect, L10n.Tr("Close")))
            {
                Close();
            }

            if (GUI.Button(refreshRect, L10n.Tr("Refresh Banks Now")))
            {
                EventManager.RefreshBanks();
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BankRefreshWindow.cs.meta
================================================
fileFormatVersion: 2
guid: 40a1ca322d08d704eacd449863718b31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BoltIntegration.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEditor;
using UnityEditor.Build;

#if (UNITY_VISUALSCRIPTING_EXIST)
using Unity.VisualScripting;
#elif (UNITY_BOLT_EXIST)
using Ludiq;
using Bolt;
#endif

namespace FMODUnity
{
    public class BoltIntegration : MonoBehaviour
    {
        [MenuItem("FMOD/Generate Visual Scripting Units")]
        public static void GenerateBoltUnitOptions()
        {
#if (UNITY_BOLT_EXIST || UNITY_VISUALSCRIPTING_EXIST)
            BuildBoltUnitOptions();
#else
            TriggerBuild();
#endif
        }

#if !(UNITY_BOLT_EXIST || UNITY_VISUALSCRIPTING_EXIST)
        [MenuItem("FMOD/Generate Visual Scripting Units", true)]
        private static bool IsBoltPresent()
        {
            Assembly ludiqCoreRuntimeAssembly = null;
            Assembly boltFlowEditorAssembly = null;

            try
            {
                ludiqCoreRuntimeAssembly = Assembly.Load("Ludiq.Core.Runtime");
                boltFlowEditorAssembly = Assembly.Load("Bolt.Flow.Editor");
            }
            catch (FileNotFoundException)
            {
                return false;
            }

            return true;
        }

        private static void TriggerBuild()
        {
            BuildTarget target = EditorUserBuildSettings.activeBuildTarget;
            BuildTargetGroup group = BuildPipeline.GetBuildTargetGroup(target);
            NamedBuildTarget namedBuildTarget = NamedBuildTarget.FromBuildTargetGroup(group);
            string previousSymbols = PlayerSettings.GetScriptingDefineSymbols(namedBuildTarget);

            if (!previousSymbols.Contains("UNITY_BOLT_EXIST"))
            {
                PlayerSettings.SetScriptingDefineSymbols(namedBuildTarget, previousSymbols + ";UNITY_BOLT_EXIST");
            }
            Settings.Instance.BoltUnitOptionsBuildPending = true;
            AssetDatabase.Refresh();
        }

#else
        private static void BuildBoltUnitOptions()
        {
#if (UNITY_BOLT_EXIST)
            DictionaryAsset projectSettings = AssetDatabase.LoadAssetAtPath(PathUtility.FromProject(LudiqCore.Paths.projectSettings), typeof(DictionaryAsset)) as DictionaryAsset;
            List<LooseAssemblyName> assemblyOptions = projectSettings.dictionary["assemblyOptions"] as List<LooseAssemblyName>;
#else
            List<LooseAssemblyName> assemblyOptions = BoltCore.Configuration.assemblyOptions;
#endif

            if (!assemblyOptions.Contains("FMODUnity"))
            {
                assemblyOptions.Add("FMODUnity");
            }

            if (!assemblyOptions.Contains("FMODUnityResonance"))
            {
                assemblyOptions.Add("FMODUnityResonance");
            }
#if (UNITY_BOLT_EXIST)
            List<Type> typeOptions = projectSettings.dictionary["typeOptions"] as List<Type>;
#else
            List<Type> typeOptions = BoltCore.Configuration.typeOptions;
#endif
            Assembly fmodUnityAssembly = Assembly.Load("FMODUnity");
            Assembly fmodUnityResonanceAssembly = Assembly.Load("FMODUnityResonance");

            List<Type> allTypes = new List<Type>(GetTypesForNamespace(fmodUnityAssembly, "FMOD"));
            allTypes.AddRange(GetTypesForNamespace(fmodUnityAssembly, "FMOD.Studio"));
            allTypes.AddRange(GetTypesForNamespace(fmodUnityAssembly, "FMODUnity"));
            allTypes.AddRange(GetTypesForNamespace(fmodUnityResonanceAssembly, "FMODUnityResonance"));

            foreach (Type type in allTypes)
            {
                if (!typeOptions.Contains(type))
                {
                    typeOptions.Add(type);
                }
            }

            Codebase.UpdateSettings();
#if (UNITY_BOLT_EXIST)
            UnitBase.Build();
#else
            BoltCore.Configuration.Save();
            UnitBase.Rebuild();
#endif
        }

        private static IEnumerable<Type> GetTypesForNamespace(Assembly assembly, string requestedNamespace)
        {
            return assembly.GetTypes()
                    .Where(t => string.Equals(t.Namespace, requestedNamespace, StringComparison.Ordinal));
        }
#endif

        public static void Startup()
        {
#if (UNITY_BOLT_EXIST || UNITY_VISUALSCRIPTING_EXIST)
            if (Settings.Instance.BoltUnitOptionsBuildPending)
            {
                Settings.Instance.BoltUnitOptionsBuildPending = false;
                BuildBoltUnitOptions();
            }
#endif
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/BoltIntegration.cs.meta
================================================
fileFormatVersion: 2
guid: f876942dd549ef444a82ab923e75ccb1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/CodeGeneration.cs
================================================
﻿#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace FMODUnity
{
    public static class CodeGeneration
    {
        public static void GenerateStaticPluginRegistration(string filePath, Platform platform,
            Action<string> reportError)
        {
            List<string> validatedPlugins = ValidateStaticPlugins(platform.StaticPlugins, reportError);

            using (StreamWriter file = new StreamWriter(filePath))
            {
                WriteStaticPluginRegistration(file, platform.IsFMODStaticallyLinked, validatedPlugins);
            }
        }

        private static void WriteStaticPluginRegistration(StreamWriter file, bool isFMODStaticallyLinked,
            IEnumerable<string> pluginFunctions)
        {
            file.WriteLine("#if ENABLE_IL2CPP");
            file.WriteLine();
            file.WriteLine("// This file was generated by FMOD for Unity from the Static Plugins list in the FMOD settings.");
            file.WriteLine();

            file.WriteLine("using System;");
            file.WriteLine("using System.Runtime.InteropServices;");
            file.WriteLine();

            file.WriteLine("namespace FMODUnity");
            file.WriteLine("{");

            file.WriteLine("    class {0}", Platform.RegisterStaticPluginsClassName);
            file.WriteLine("    {");

            // Import the plugin functions
            foreach (string pluginFunction in pluginFunctions)
            {
                file.WriteLine("        [DllImport(\"__Internal\")]");
                file.WriteLine("        private static extern IntPtr {0}();", pluginFunction);
                file.WriteLine();
            }

            // Import the RegisterDSP function
            file.WriteLine("        [DllImport(FMOD.VERSION.dll)]");
            file.WriteLine("        private static extern FMOD.RESULT FMOD5_System_RegisterDSP(IntPtr system, IntPtr description, IntPtr handle);");
            file.WriteLine();

            file.WriteLine("        public static void {0}(FMOD.System coreSystem, Action<FMOD.RESULT, string> reportResult)",
                Platform.RegisterStaticPluginsFunctionName);
            file.WriteLine("        {");

            if (pluginFunctions.Any())
            {
                file.WriteLine("            FMOD.RESULT result;");

                foreach (string pluginFunction in pluginFunctions)
                {
                    file.WriteLine();
                    file.WriteLine("            result = FMOD5_System_RegisterDSP(coreSystem.handle, {0}(), IntPtr.Zero);", pluginFunction);
                    file.WriteLine("            reportResult(result, \"Registering static plugin '{0}'\");", pluginFunction);
                }
            }

            file.WriteLine("        }");
            file.WriteLine("    }");
            file.WriteLine("}");
            file.WriteLine("");
            file.WriteLine("#endif // ENABLE_IL2CPP");
        }

        private static List<string> ValidateStaticPlugins(List<string> staticPlugins, Action<string> reportError)
        {
            List<string> result = new List<string>();

            for (int i = 0; i < staticPlugins.Count; ++i)
            {
                string functionName = staticPlugins[i];

                string trimmedName = (functionName != null) ? functionName.Trim() : null;

                if (string.IsNullOrEmpty(trimmedName))
                {
                    reportError(string.Format("Static plugin {0} has no name and will be ignored.", i + 1));
                }
                else if (IsValidFunctionName(trimmedName, reportError))
                {
                    result.Add(trimmedName);
                }
            }

            return result;
        }

        private static bool IsValidFunctionName(string name, Action<string> reportError)
        {
            if (!(char.IsLetter(name[0]) || name[0] == '_'))
            {
                reportError(string.Format(
                    "Plugin name '{0}' is not valid. Names must start with a letter or an underscore ('_').", name));
                return false;
            }

            for (int i = 1; i < name.Length; ++i)
            {
                if (!(char.IsLetterOrDigit(name[i]) || name[i] == '_'))
                {
                    reportError(string.Format(
                        "Plugin name '{0}' is not valid. " +
                        "Character '{1}' at position {2} is invalid - it must be a letter, a number, or an underscore ('_').",
                        name, name[i], i));
                    return false;
                }
            }

            return true;
        }
    }
}
#endif



================================================
FILE: Assets/Plugins/FMOD/src/Editor/CodeGeneration.cs.meta
================================================
fileFormatVersion: 2
guid: 438155f6a2d689e45b5cc7701d412b80
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/CreateEventPopup.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEditor;

namespace FMODUnity
{
    public class CreateEventPopup : EditorWindow
    {
        private class FolderEntry
        {
            public FolderEntry parent;
            public string name;
            public string guid;
            public List<FolderEntry> entries = new List<FolderEntry>();
            public Rect rect;
        }

        private SerializedProperty outputProperty;

        private FolderEntry rootFolder;
        private FolderEntry currentFolder;
        private List<BankEntry> banks;

        private int lastHover = 0;
        private string eventFolder = "/";
        private string eventName = "";
        private string currentFilter = "";
        private int selectedBank = 0;
        private bool resetCursor = true;
        private Vector2 scrollPos = new Vector2();
        private Rect scrollRect = new Rect();
        private bool isConnected = false;

        internal void SelectEvent(SerializedProperty property)
        {
            outputProperty = property;
        }

        private class BankEntry
        {
            public string name;
            public string guid;
        }

        public CreateEventPopup()
        {
        }

        private void BuildTree()
        {
            var rootGuid = EditorUtils.GetScriptOutput("studio.project.workspace.masterEventFolder.id");
            rootFolder = new FolderEntry();
            rootFolder.guid = rootGuid;
            BuildTreeItem(rootFolder);
            wantsMouseMove = true;
            banks = new List<BankEntry>();

            const string buildBankTreeFunc =
                @"function() {
                    var output = """";
                    const items = [ studio.project.workspace.masterBankFolder ];
                    while (items.length > 0) {
                        var currentItem = items.shift();
                        if (currentItem.isOfType(""BankFolder"")) {
                            currentItem.items.reverse().forEach(function(val) {
                                items.unshift(val);
                            });
                        } else {
                            output += "","" + currentItem.id + currentItem.getPath().replace(""bank:/"", """");
                        }
                    }
                    return output;
                }";

            string bankList = EditorUtils.GetScriptOutput(string.Format("({0})()", buildBankTreeFunc));
            string[] bankListSplit = bankList.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (var bank in bankListSplit)
            {
                var entry = new BankEntry();
                entry.guid = bank.Substring(0, 38);
                entry.name = bank.Substring(38);
                banks.Add(entry);
            }
        }

        private void BuildTreeItem(FolderEntry entry)
        {
            // lookup the entry
            EditorUtils.GetScriptOutput(string.Format("cur = studio.project.lookup(\"{0}\");", entry.guid));

            // get child count
            string itemCountString = EditorUtils.GetScriptOutput("cur.items.length;");
            int itemCount;
            Int32.TryParse(itemCountString, out itemCount);

            // iterate children looking for folder
            for (int item = 0; item < itemCount; item++)
            {
                EditorUtils.GetScriptOutput(String.Format("child = cur.items[{0}]", item));

                // check if it's a folder
                string isFolder = EditorUtils.GetScriptOutput("child.isOfExactType(\"EventFolder\")");
                if (isFolder == "false")
                {
                    continue;
                }

                // Get guid and name
                string info = EditorUtils.GetScriptOutput("child.id + child.name");

                var childEntry = new FolderEntry();
                childEntry.guid = info.Substring(0, 38);
                childEntry.name = info.Substring(38);
                childEntry.parent = entry;
                entry.entries.Add(childEntry);
            }

            // Recurse for child entries
            foreach(var childEntry in entry.entries)
            {
                BuildTreeItem(childEntry);
            }
        }

        public void OnGUI()
        {
            var borderIcon = EditorUtils.LoadImage("Border.png");
            var border = new GUIStyle(GUI.skin.box);
            border.normal.background = borderIcon;
            GUI.Box(new Rect(1, 1, position.width - 1, position.height - 1), GUIContent.none, border);

            if (Event.current.type == EventType.Layout)
            {
                isConnected = EditorUtils.IsConnectedToStudio();
            }

            if (!isConnected)
            {
                this.ShowNotification(new GUIContent("FMOD Studio not running"));
                return;
            }

            this.RemoveNotification();

            if (rootFolder == null)
            {
                BuildTree();
                currentFolder = rootFolder;
            }

            var arrowIcon = EditorUtils.LoadImage("ArrowIcon.png");
            var hoverIcon = EditorUtils.LoadImage("SelectedAlt.png");

            var nextEntry = currentFolder;

            var filteredEntries = currentFolder.entries.FindAll((x) => x.name.StartsWith(currentFilter, StringComparison.CurrentCultureIgnoreCase));

            // Process key strokes for the folder list
            {
                if (Event.current.keyCode == KeyCode.UpArrow)
                {
                    if (Event.current.type == EventType.KeyDown)
                    {
                        lastHover = Math.Max(lastHover - 1, 0);
                        if (filteredEntries[lastHover].rect.y < scrollPos.y)
                        {
                            scrollPos.y = filteredEntries[lastHover].rect.y;
                        }
                    }
                    Event.current.Use();
                }
                if (Event.current.keyCode == KeyCode.DownArrow)
                {
                    if (Event.current.type == EventType.KeyDown)
                    {
                        lastHover = Math.Min(lastHover + 1, filteredEntries.Count - 1);
                        if (filteredEntries[lastHover].rect.y + filteredEntries[lastHover].rect.height > scrollPos.y + scrollRect.height)
                        {
                            scrollPos.y = filteredEntries[lastHover].rect.y - scrollRect.height + filteredEntries[lastHover].rect.height * 2;
                        }
                    }
                    Event.current.Use();
                }
                if (Event.current.keyCode == KeyCode.RightArrow)
                {
                    if (Event.current.type == EventType.KeyDown)
                        nextEntry = filteredEntries[lastHover];
                    Event.current.Use();
                }
                if (Event.current.keyCode == KeyCode.LeftArrow)
                {
                    if (Event.current.type == EventType.KeyDown)
                        if (currentFolder.parent != null)
                        {
                            nextEntry = currentFolder.parent;
                        }
                    Event.current.Use();
                }
            }

            bool disabled = eventName.Length == 0;
            EditorGUI.BeginDisabledGroup(disabled);
            if (GUILayout.Button("Create Event"))
            {
                CreateEventInStudio();
                this.Close();
            }
            EditorGUI.EndDisabledGroup();

            {
                GUI.SetNextControlName("name");

                EditorGUILayout.LabelField("Name");
                eventName = EditorGUILayout.TextField(eventName);
            }

            {
                EditorGUILayout.LabelField("Bank");
                selectedBank = EditorGUILayout.Popup(selectedBank, banks.Select(x => x.name).ToArray());
            }

            bool updateEventPath = false;
            {
                GUI.SetNextControlName("folder");
                EditorGUI.BeginChangeCheck();
                EditorGUILayout.LabelField("Path");
                eventFolder = GUILayout.TextField(eventFolder);
                if (EditorGUI.EndChangeCheck())
                {
                    updateEventPath = true;
                }
            }

            if (resetCursor)
            {
                resetCursor = false;

                var textEditor = (TextEditor)GUIUtility.GetStateObject(typeof(TextEditor), GUIUtility.keyboardControl);
                if (textEditor != null)
                {
                    textEditor.MoveCursorToPosition(new Vector2(9999, 9999));
                }
            }

            // Draw the current folder as a title bar, click to go back one level
            {
                Rect currentRect = EditorGUILayout.GetControlRect();

                var bg = new GUIStyle(GUI.skin.box);
                Rect bgRect = new Rect(currentRect);
                bgRect.x = 2;
                bgRect.width = position.width-4;
                GUI.Box(bgRect, GUIContent.none, bg);

                Rect textureRect = currentRect;
                textureRect.width = arrowIcon.width;
                if (currentFolder.name != null)
                {
                    GUI.DrawTextureWithTexCoords(textureRect, arrowIcon, new Rect(1, 1, -1, -1));
                }

                Rect labelRect = currentRect;
                labelRect.x += arrowIcon.width;
                labelRect.width -= arrowIcon.width;
                GUI.Label(labelRect, currentFolder.name != null ? currentFolder.name : "Folders", EditorStyles.boldLabel);

                if (Event.current.type == EventType.MouseDown && currentRect.Contains(Event.current.mousePosition) &&
                    currentFolder.parent != null)
                {
                    nextEntry = currentFolder.parent;
                    Event.current.Use();
                }
            }

            var normal = new GUIStyle(GUI.skin.label);
            normal.padding.left = 14;
            var hover = new GUIStyle(normal);
            hover.normal.background = hoverIcon;

            scrollPos = EditorGUILayout.BeginScrollView(scrollPos, false, false);

            for (int i = 0; i < filteredEntries.Count; i++)
            {
                var entry = filteredEntries[i];
                var content = new GUIContent(entry.name);
                var rect = EditorGUILayout.GetControlRect();
                if ((rect.Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseMove) || i == lastHover)
                {
                    lastHover = i;

                    GUI.Label(rect, content, hover);
                    if (rect.Contains(Event.current.mousePosition) && Event.current.type == EventType.MouseDown)
                    {
                        nextEntry = entry;
                    }
                }
                else
                {
                    GUI.Label(rect, content, normal);
                }

                Rect textureRect = rect;
                textureRect.x = textureRect.width - arrowIcon.width;
                textureRect.width = arrowIcon.width;
                GUI.DrawTexture(textureRect, arrowIcon);

                if (Event.current.type == EventType.Repaint)
                {
                    entry.rect = rect;
                }
            }
            EditorGUILayout.EndScrollView();

            if (Event.current.type == EventType.Repaint)
            {
                scrollRect = GUILayoutUtility.GetLastRect();
            }

            if (currentFolder != nextEntry)
            {
                lastHover = 0;
                currentFolder = nextEntry;
                UpdateTextFromList();
                Repaint();
            }

            if (updateEventPath)
            {
                UpdateListFromText();
            }

            if (Event.current.type == EventType.MouseMove)
            {
                Repaint();
            }
        }

        private void CreateEventInStudio()
        {
            string eventGuid = EditorUtils.CreateStudioEvent(eventFolder, eventName);

            if (!string.IsNullOrEmpty(eventGuid))
            {
                EditorUtils.GetScriptOutput(String.Format("studio.project.lookup(\"{0}\").relationships.banks.add(studio.project.lookup(\"{1}\"));", eventGuid, banks[selectedBank].guid));
                EditorUtils.GetScriptOutput("studio.project.build();");

                if (!eventFolder.EndsWith("/"))
                {
                    eventFolder += "/";
                }

                string fullPath = "event:" + eventFolder + eventName;
                outputProperty.SetEventReference(FMOD.GUID.Parse(eventGuid), fullPath);
                EditorUtils.UpdateParamsOnEmitter(outputProperty.serializedObject, fullPath);
                outputProperty.serializedObject.ApplyModifiedProperties();
            }
        }

        private void UpdateListFromText()
        {
            int endFolders = eventFolder.LastIndexOf("/");
            currentFilter = eventFolder.Substring(endFolders + 1);

            var folders = eventFolder.Split(new char[] { '/' }, StringSplitOptions.RemoveEmptyEntries);
            FolderEntry entry = rootFolder;
            int i;
            for (i = 0; i < folders.Length; i++)
            {
                var newEntry = entry.entries.Find((x) => x.name.Equals(folders[i], StringComparison.CurrentCultureIgnoreCase));
                if (newEntry == null)
                {
                    break;
                }
                entry = newEntry;
            }
            currentFolder = entry;

            // Treat an exact filter match as being in that folder and clear the filter
            if (entry.name != null && entry.name.Equals(currentFilter, StringComparison.CurrentCultureIgnoreCase))
            {
                currentFilter = "";
            }
        }

        private void UpdateTextFromList()
        {
            string path = "";
            var entry = currentFolder;
            while (entry.parent != null)
            {
                path = entry.name + "/" + path;
                entry = entry.parent;
            }

            eventFolder = "/" + path;
            resetCursor = true;
            currentFilter = "";
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/CreateEventPopup.cs.meta
================================================
fileFormatVersion: 2
guid: 9c9773a32ed4a2b429fd42645175c32b
timeCreated: 1455063674
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorBankRef.cs
================================================
﻿using System;
using System.Collections.Generic;
using UnityEngine;
namespace FMODUnity
{
    public class EditorBankRef : ScriptableObject
    {
        [SerializeField]
        public string Path;

        [SerializeField]
        public string Name;

        [SerializeField]
        public string StudioPath;

        [SerializeField]
        private Int64 lastModified;

        [SerializeField]
        public List<NameValuePair> FileSizes;

        public bool Exists;

        public DateTime LastModified
        {
            get { return new DateTime(lastModified); }
            set { lastModified = value.Ticks; }
        }

        public static string CalculateName(string filePath, string basePath)
        {
            string relativePath = filePath.Substring(basePath.Length + 1);
            string extension = System.IO.Path.GetExtension(relativePath);

            string name = relativePath.Substring(0, relativePath.Length - extension.Length);
            name = RuntimeUtils.GetCommonPlatformPath(name);

            return name;
        }

        public void SetPath(string filePath, string basePath)
        {
            Path = RuntimeUtils.GetCommonPlatformPath(filePath);
            Name = CalculateName(filePath, basePath);
            base.name = "bank:/" + Name + System.IO.Path.GetExtension(filePath);
        }

        public void SetStudioPath(string studioPath)
        {
            string stringCmp;
            stringCmp = System.IO.Path.GetFileName(Name);
            if (!studioPath.Contains(stringCmp))
            {
                // No match means localization
                studioPath = studioPath.Substring(0, studioPath.LastIndexOf("/") + 1);
                studioPath += stringCmp;
            }
            StudioPath = studioPath;
        }

        [Serializable]
        public class NameValuePair
        {
            public string Name;
            public long Value;

            public NameValuePair(string name, long value)
            {
                Name = name;
                Value = value;
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorBankRef.cs.meta
================================================
fileFormatVersion: 2
guid: c18180ecb35941f4682ae60107b85b7c
timeCreated: 1432775088
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorEventRef.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEditor;

namespace FMODUnity
{
    public class EditorEventRef : ScriptableObject
    {
        [SerializeField]
        public string Path;

        [SerializeField]
        public FMOD.GUID Guid;

        [SerializeField]
        public List<EditorBankRef> Banks;
        [SerializeField]
        public bool IsStream;
        [SerializeField]
        public bool Is3D;
        [SerializeField]
        public bool IsOneShot;
        [SerializeField]
        public List<EditorParamRef> Parameters;
        [SerializeField]
        public float MinDistance;
        [SerializeField]
        public float MaxDistance;
        [SerializeField]
        public int Length;

        public List<EditorParamRef> LocalParameters
        {
            get { return Parameters.Where(p => p.IsGlobal == false).OrderBy(p => p.Name).ToList(); }
        }

        public List<EditorParamRef> GlobalParameters
        {
            get { return Parameters.Where(p => p.IsGlobal == true).OrderBy(p => p.Name).ToList(); }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorEventRef.cs.meta
================================================
fileFormatVersion: 2
guid: ceb653cd98e289a4e8697a1af55201f2
timeCreated: 1432775088
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorParamRef.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    public enum ParameterType
    {
        Continuous,
        Discrete,
        Labeled,
    }

    public class EditorParamRef : ScriptableObject
    {
        [SerializeField]
        public string Name;
        [SerializeField]
        public string StudioPath;
        [SerializeField]
        public float Min;
        [SerializeField]
        public float Max;
        [SerializeField]
        public float Default;
        [SerializeField]
        public ParameterID ID;
        [SerializeField]
        public ParameterType Type;
        [SerializeField]
        public bool IsGlobal;
        [SerializeField]
        public string[] Labels = { };

        public bool Exists;

        [Serializable]
        public struct ParameterID
        {
            public static implicit operator ParameterID(FMOD.Studio.PARAMETER_ID source)
            {
                return new ParameterID {
                    data1 = source.data1,
                    data2 = source.data2,
                };
            }

            public static implicit operator FMOD.Studio.PARAMETER_ID(ParameterID source)
            {
                return new FMOD.Studio.PARAMETER_ID {
                    data1 = source.data1,
                    data2 = source.data2,
                };
            }

            public bool Equals(FMOD.Studio.PARAMETER_ID other)
            {
                return data1 == other.data1 && data2 == other.data2;
            }

            public uint data1;
            public uint data2;
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorParamRef.cs.meta
================================================
fileFormatVersion: 2
guid: fecb8ef7f94ca804a8ab72049b86782e
timeCreated: 1432775088
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorSettings.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEngine;

namespace FMODUnity
{
    [InitializeOnLoad]
    public class EditorSettings : IEditorSettings
    {
        static EditorSettings()
        {
            Settings.EditorSettings = new EditorSettings();
        }

        public const string DownloadURL = "https://www.fmod.com/download";

        // This is used to find the platform that implements the current Unity build target.
        private Dictionary<BuildTarget, Platform> PlatformForBuildTarget = new Dictionary<BuildTarget, Platform>();

        private static string FMODFolderFull => RuntimeUtils.PluginBasePath;

        private const string CacheFolderName = "Cache";
        private static string CacheFolderRelative => $"{RuntimeUtils.PluginBasePath}/{CacheFolderName}";
        private static string CacheFolderFull => $"{FMODFolderFull}/{CacheFolderName}";

        private const string RegisterStaticPluginsFile = "RegisterStaticPlugins.cs";
        private static string RegisterStaticPluginsAssetPathRelative => $"{CacheFolderRelative}/{RegisterStaticPluginsFile}";
        private static string RegisterStaticPluginsAssetPathFull => $"{CacheFolderFull}/{RegisterStaticPluginsFile}";

        [NonSerialized]
        private Dictionary<string, bool> binaryCompatibilitiesBeforeBuild;

        public static EditorSettings Instance
        {
            get
            {
                return Settings.EditorSettings as EditorSettings;
            }
        }

        public Settings RuntimeSettings { get; set; }

        [MenuItem("FMOD/Edit Settings", priority = 0)]
        public static void EditSettings()
        {
            Selection.activeObject = Settings.Instance;
            EditorApplication.ExecuteMenuItem("Window/General/Inspector");
        }

        public void Clear()
        {
            PlatformForBuildTarget.Clear();
            binaryCompatibilitiesBeforeBuild = null;
        }

        public void CreateSettingsAsset(string assetName)
        {
            string resourcesPath = $"{FMODFolderFull}/Resources";

            bool inPackagesFolder = resourcesPath.StartsWith("Packages/");
            if (inPackagesFolder)
            {
                resourcesPath = "Assets/Plugins/FMOD/Resources";
            }
            EditorUtils.EnsureFolderExists(resourcesPath);
            AssetDatabase.CreateAsset(RuntimeSettings, $"{resourcesPath}/{assetName}.asset");

            AddPlatformsToAsset();
        }

        public void AddPlatformForBuildTargets(Platform platform)
        {
            foreach (BuildTarget buildTarget in platform.GetBuildTargets())
            {
                if (buildTarget != BuildTarget.NoTarget)
                {
                    try
                    {
                        PlatformForBuildTarget.Add(buildTarget, platform);
                    }
                    catch (Exception e)
                    {
                        RuntimeUtils.DebugLogWarningFormat("FMOD: Error platform {0} already added to build targets. : {1}", buildTarget, e.Message);
                    }
                }
            }
        }

        // Adds a new platform group to the set of platforms.
        public PlatformGroup AddPlatformGroup(string displayName, int sortOrder)
        {
            PlatformGroup group = PlatformGroup.Create(displayName, Legacy.Platform.None);
            group.DisplaySortOrder = sortOrder;

            RuntimeSettings.AddPlatform(group);
            AssetDatabase.AddObjectToAsset(group, RuntimeSettings);

            RuntimeSettings.LinkPlatform(group);

            return group;
        }

        private void ClearPlatformSettings()
        {
            RemovePlatformFromAsset(RuntimeSettings.DefaultPlatform);
            RemovePlatformFromAsset(RuntimeSettings.PlayInEditorPlatform);

            RuntimeSettings.Platforms.ForEach(RemovePlatformFromAsset);

            foreach (Platform platform in Resources.LoadAll<Platform>(Settings.SettingsAssetName))
            {
                RemovePlatformFromAsset(platform);
            }

            RuntimeSettings.DefaultPlatform = null;
            RuntimeSettings.PlayInEditorPlatform = null;

            RuntimeSettings.Platforms.Clear();
            PlatformForBuildTarget.Clear();
            RuntimeSettings.PlatformForRuntimePlatform.Clear();
        }

        // Testing function: Resets all platform settings.
        public void ResetPlatformSettings()
        {
            ClearPlatformSettings();
            RuntimeSettings.OnEnable();
        }

        // Testing function: Reimports legacy platform settings.
        public void ReimportLegacyPlatforms()
        {
            ClearPlatformSettings();
            RuntimeSettings.MigratedPlatforms.Clear();
            RuntimeSettings.OnEnable();
        }

        public void UpdateMigratedPlatform(Platform platform)
        {
            if (!RuntimeSettings.MigratedPlatforms.Contains(platform.LegacyIdentifier))
            {
                RuntimeSettings.MigratedPlatforms.Add(platform.LegacyIdentifier);
            }
        }

        // Adds any missing platforms:
        // * From the template collection
        // * From the legacy settings
        public void AddMissingPlatforms()
        {
            var newPlatforms = new List<Platform>();

            foreach (Settings.PlatformTemplate template in Settings.PlatformTemplates)
            {
                if (!RuntimeSettings.PlatformExists(template.Identifier))
                {
                    newPlatforms.Add(template.CreateInstance());
                }
            }

            // Ensure that the default platform exists
            if (!RuntimeSettings.DefaultPlatform)
            {
                RuntimeSettings.DefaultPlatform = ScriptableObject.CreateInstance<PlatformDefault>();
                newPlatforms.Add(RuntimeSettings.DefaultPlatform);
            }

            // Ensure that the Play In Editor platform exists
            if (!RuntimeSettings.PlayInEditorPlatform)
            {
                RuntimeSettings.PlayInEditorPlatform = ScriptableObject.CreateInstance<PlatformPlayInEditor>();
                newPlatforms.Add(RuntimeSettings.PlayInEditorPlatform);
            }

            // Ensure that the default and Play In Editor platforms have properties
            AffirmPlatformProperties(RuntimeSettings.DefaultPlatform);
            AffirmPlatformProperties(RuntimeSettings.PlayInEditorPlatform);

            // Migrate plugins if necessary
            var PluginsProperty = Platform.PropertyAccessors.Plugins;

            if (!RuntimeSettings.MigratedPlatforms.Contains(RuntimeSettings.DefaultPlatform.LegacyIdentifier))
            {
                PluginsProperty.Set(RuntimeSettings.DefaultPlatform, RuntimeSettings.Plugins);
            }
            else if (!PluginsProperty.HasValue(RuntimeSettings.DefaultPlatform))
            {
                PluginsProperty.Set(RuntimeSettings.DefaultPlatform, new List<string>());
            }

            // Migrate LiveUpdatePort
            if (!Platform.PropertyAccessors.LiveUpdatePort.HasValue(RuntimeSettings.DefaultPlatform))
            {
                Platform.PropertyAccessors.LiveUpdatePort.Set(RuntimeSettings.DefaultPlatform, RuntimeSettings.LiveUpdatePort);
            }

            // Create a map for migrating legacy settings
            var platformMap = new Dictionary<Legacy.Platform, Platform>();

            foreach (Platform platform in RuntimeSettings.Platforms.Concat(newPlatforms))
            {
                if (platform.LegacyIdentifier != Legacy.Platform.None)
                {
                    platformMap.Add(platform.LegacyIdentifier, platform);
                }
            }

            Func<Legacy.Platform, Platform> AffirmPlatform = null;

            // Ensures that all of the platform's ancestors exist.
            Action<Platform> AffirmAncestors = (platform) =>
            {
                Legacy.Platform legacyParent = Legacy.Parent(platform.LegacyIdentifier);

                if (legacyParent != Legacy.Platform.None)
                {
                    platform.ParentIdentifier = AffirmPlatform(legacyParent).Identifier;
                }
            };

            // Gets the platform corresponding to legacyPlatform (or creates it if it is a group),
            // and ensures that it has properties and all of its ancestors exist.
            // Returns null if legacyPlatform is unknown.
            AffirmPlatform = (legacyPlatform) =>
            {
                Platform platform;

                if (platformMap.TryGetValue(legacyPlatform, out platform))
                {
                    platform.AffirmProperties();
                }
                else if (Legacy.IsGroup(legacyPlatform))
                {
                    PlatformGroup group = PlatformGroup.Create(Legacy.DisplayName(legacyPlatform), legacyPlatform);
                    platformMap.Add(legacyPlatform, group);
                    newPlatforms.Add(group);

                    platform = group;
                }
                else
                {
                    // This is an unknown platform
                    return null;
                }

                AffirmAncestors(platform);

                return platform;
            };

            // Gets the target plaform to use when migrating settings from legacyPlatform.
            // Returns null if legacyPlatform is unknown or has already been migrated.
            Func<Legacy.Platform, Platform> getMigrationTarget = (legacyPlatform) =>
            {
                if (RuntimeSettings.MigratedPlatforms.Contains(legacyPlatform))
                {
                    // Already migrated
                    return null;
                }

                return AffirmPlatform(legacyPlatform);
            };

            var speakerModeSettings = RuntimeSettings.SpeakerModeSettings.ConvertAll(
                setting => new Legacy.PlatformSetting<FMOD.SPEAKERMODE>()
                {
                    Value = (FMOD.SPEAKERMODE)setting.Value,
                    Platform = setting.Platform
                }
                );

            // Migrate all the legacy settings, creating platforms as we need them via AffirmPlatform
            MigrateLegacyPlatforms(speakerModeSettings, Platform.PropertyAccessors.SpeakerMode, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.SampleRateSettings, Platform.PropertyAccessors.SampleRate, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.LiveUpdateSettings, Platform.PropertyAccessors.LiveUpdate, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.OverlaySettings, Platform.PropertyAccessors.Overlay, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.BankDirectorySettings, Platform.PropertyAccessors.BuildDirectory, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.VirtualChannelSettings, Platform.PropertyAccessors.VirtualChannelCount, getMigrationTarget);
            MigrateLegacyPlatforms(RuntimeSettings.RealChannelSettings, Platform.PropertyAccessors.RealChannelCount, getMigrationTarget);

            // Now we ensure that if a legacy group has settings, all of its descendants exist
            // and inherit from it (even if they have no settings of their own), so that the
            // inheritance structure matches the old system.
            // We look at all groups (not just newly created ones), because a newly created platform
            // may need to inherit from a preexisting group.
            var groupsToProcess = new Queue<Platform>(platformMap.Values.Where(
                platform => platform is PlatformGroup
                    && platform.LegacyIdentifier != Legacy.Platform.None
                    && platform.HasAnyOverriddenProperties));

            while (groupsToProcess.Count > 0)
            {
                Platform group = groupsToProcess.Dequeue();

                // Ensure that all descendants exist
                foreach (var child in platformMap.Values)
                {
                    if (child.Active)
                    {
                        // Don't overwrite existing settings
                        continue;
                    }

                    var legacyPlatform = child.LegacyIdentifier;

                    if (legacyPlatform == Legacy.Platform.iOS || legacyPlatform == Legacy.Platform.Android)
                    {
                        // These platforms were overridden by MobileHigh and MobileLow in the old system
                        continue;
                    }

                    if (RuntimeSettings.MigratedPlatforms.Contains(legacyPlatform))
                    {
                        // The user may have deleted this platform since migration, so don't mess with it
                        continue;
                    }

                    if (Legacy.Parent(legacyPlatform) == group.LegacyIdentifier)
                    {
                        child.AffirmProperties();
                        child.ParentIdentifier = group.Identifier;

                        if (child is PlatformGroup)
                        {
                            groupsToProcess.Enqueue(child as PlatformGroup);
                        }
                    }
                }
            }

            // Add all of the new platforms to the set of known platforms
            foreach (Platform platform in newPlatforms)
            {
                RuntimeSettings.AddPlatform(platform);
            }

            RuntimeSettings.Platforms.ForEach(UpdateMigratedPlatform);
        }

        private void MigrateLegacyPlatforms<TValue, TSetting>(List<TSetting> settings,
            Platform.PropertyAccessor<TValue> property, Func<Legacy.Platform, Platform> getMigrationTarget)
            where TSetting : Legacy.PlatformSetting<TValue>
        {
            foreach (TSetting setting in settings)
            {
                Platform platform = getMigrationTarget(setting.Platform);

                if (platform != null)
                {
                    property.Set(platform, setting.Value);
                }
            }
        }

        // The platform that implements the current Unity build target.
        public Platform CurrentEditorPlatform
        {
            get
            {
                return GetPlatform(EditorUserBuildSettings.activeBuildTarget);
            }
        }

        public Platform GetPlatform(BuildTarget buildTarget)
        {
            if (PlatformForBuildTarget.ContainsKey(buildTarget))
            {
                return PlatformForBuildTarget[buildTarget];
            }
            else
            {
                return RuntimeSettings.DefaultPlatform;
            }
        }

        public void SetPlatformParent(Platform platform, Platform newParent)
        {
            Platform oldParent = RuntimeSettings.FindPlatform(platform.ParentIdentifier);

            if (oldParent != null)
            {
                oldParent.ChildIdentifiers.Remove(platform.Identifier);
            }

            if (newParent != null)
            {
                platform.ParentIdentifier = newParent.Identifier;

                newParent.ChildIdentifiers.Add(platform.Identifier);
                SortPlatformChildren(newParent);
            }
            else
            {
                platform.ParentIdentifier = null;
            }
        }

        public void SetPlatformSortOrder(Platform platform, float sortOrder)
        {
            if (platform.DisplaySortOrder != sortOrder)
            {
                platform.DisplaySortOrder = sortOrder;

                if (platform.Parent != null)
                {
                    SortPlatformChildren(platform.Parent);
                }
            }
        }

        public void SortPlatformChildren(Platform platform)
        {
            platform.ChildIdentifiers.Sort((a, b) => {
                Platform platformA = RuntimeSettings.FindPlatform(a);
                Platform platformB = RuntimeSettings.FindPlatform(b);

                return platformA.DisplaySortOrder.CompareTo(platformB.DisplaySortOrder);
            });
        }

        // Ensures that the given platform has valid properties.
        private void AffirmPlatformProperties(Platform platform)
        {
            if (!platform.Active)
            {
                RuntimeUtils.DebugLogFormat("[FMOD] Cannot find properties for platform {0}, creating default properties", platform.Identifier);
                RuntimeSettings.AddPlatformProperties(platform);
            }
        }

        private void RemovePlatformFromAsset(Platform platform)
        {
            if (AssetDatabase.Contains(platform))
            {
                UnityEngine.Object.DestroyImmediate(platform, true);
            }
        }

        public bool CanBuildTarget(BuildTarget target, Platform.BinaryType binaryType, out string error)
        {
            if (Settings.Instance == null)
            {
                error = "Settings instance has not been initialized. Unable to continue build.";
                return false;
            }

            Platform platform;

            if (!PlatformForBuildTarget.TryGetValue(target, out platform))
            {
                error = string.Format("No FMOD platform found for build target {0}. " +
                            "You may need to install a platform specific integration package from {1}.",
                            target, DownloadURL);
                return false;
            }

            IEnumerable<string> missingPathsQuery = platform.GetBinaryFilePaths(target, binaryType)
                .Where(path => !File.Exists(path) && !Directory.Exists(path));

            if (missingPathsQuery.Any())
            {
                string[] missingPaths = missingPathsQuery.Select(path => "- " + path).ToArray();

                string summary;

                if (missingPaths.Length == 1)
                {
                    summary = string.Format("There is an FMOD binary missing for build target {0}", target);
                }
                else
                {
                    summary = string.Format("There are {0} FMOD binaries missing for build target {1}",
                        missingPaths.Length, target);
                }

                if (binaryType == Platform.BinaryType.Logging)
                {
                    summary += " (development build)";
                }

                error = string.Format(
                    "{0}:\n" +
                    "{1}\n" +
                    "Please run the {2} menu command.\n",
                    summary, string.Join("\n", missingPaths), FileReorganizer.ReorganizerMenuItemPath);
                return false;
            }

            error = null;
            return true;
        }

        public void PreprocessBuild(BuildTarget target, Platform.BinaryType binaryType)
        {
            Platform platform = PlatformForBuildTarget[target];

            PreprocessStaticPlugins(platform, target);

            SelectBinaries(platform, target, binaryType);
        }

        private void PostprocessBuild(BuildTarget target)
        {
            foreach(string path in binaryCompatibilitiesBeforeBuild.Keys)
            {
                PluginImporter importer = AssetImporter.GetAtPath(path) as PluginImporter;

                if (importer != null)
                {
                    importer.SetCompatibleWithPlatform(target, binaryCompatibilitiesBeforeBuild[path]);
                }
            }
        }

        private void PreprocessStaticPlugins(Platform platform, BuildTarget target)
        {
            // Ensure we don't have leftover temporary changes from a previous build.
            CleanTemporaryFiles();

            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(target);
            NamedBuildTarget namedBuildTarget = NamedBuildTarget.FromBuildTargetGroup(buildTargetGroup);
            ScriptingImplementation scriptingBackend = PlayerSettings.GetScriptingBackend(namedBuildTarget);

            if (platform.StaticPlugins.Count > 0)
            {
                if (scriptingBackend == ScriptingImplementation.IL2CPP)
                {
                    Action<string> reportError = message => {
                        RuntimeUtils.DebugLogWarningFormat("FMOD: Error processing static plugins for platform {0}: {1}",
                            platform.DisplayName, message);
                    };

                    if (!AssetDatabase.IsValidFolder(CacheFolderFull))
                    {
                        RuntimeUtils.DebugLogFormat("Creating {0}", CacheFolderFull);
                        AssetDatabase.CreateFolder(FMODFolderFull, CacheFolderName);
                    }

                    // Generate registration code and import it so it's included in the build.
                    RuntimeUtils.DebugLogFormat("FMOD: Generating static plugin registration code in {0}", RegisterStaticPluginsAssetPathFull);

                    string filePath = RegisterStaticPluginsAssetPathRelative.Replace("Assets", Application.dataPath);
                    CodeGeneration.GenerateStaticPluginRegistration(filePath, platform, reportError);
                    AssetDatabase.ImportAsset(RegisterStaticPluginsAssetPathFull);
                }
                else
                {
                    RuntimeUtils.DebugLogWarningFormat(
                        "FMOD: Platform {0} has {1} static plugins specified, " +
                        "but static plugins are only supported on the IL2CPP scripting backend",
                        platform.DisplayName, platform.StaticPlugins.Count);
                }
            }
        }

        public void CleanTemporaryFiles()
        {
            DeleteTemporaryFile(RegisterStaticPluginsAssetPathFull);
        }

        public void DeleteTemporaryFile(string assetPath)
        {
            bool assetExists = !string.IsNullOrEmpty(AssetDatabase.AssetPathToGUID(assetPath));

            if (assetExists && AssetDatabase.DeleteAsset(assetPath))
            {
                RuntimeUtils.DebugLogFormat("FMOD: Removed temporary file {0}", assetPath);
            }
        }

        private static void SelectBinaries(Platform platform, BuildTarget target, Platform.BinaryType binaryType)
        {
            string message = string.Format("FMOD: Selected binaries for platform {0}{1}:", target,
                (binaryType == Platform.BinaryType.Logging) ? " (development build)" : string.Empty);

            Instance.binaryCompatibilitiesBeforeBuild = new Dictionary<string, bool>();

            HashSet<string> enabledPaths = new HashSet<string>();

            foreach (string path in platform.GetBinaryAssetPaths(target, binaryType | Platform.BinaryType.Optional))
            {
                PluginImporter importer = AssetImporter.GetAtPath(path) as PluginImporter;

                if (importer is PluginImporter)
                {
                    Instance.binaryCompatibilitiesBeforeBuild.Add(path, importer.GetCompatibleWithPlatform(target));

                    importer.SetCompatibleWithPlatform(target, true);

                    enabledPaths.Add(path);

                    message += string.Format("\n- Enabled {0}", path);
                }
            }

            foreach (string path in platform.GetBinaryAssetPaths(target, Platform.BinaryType.All))
            {
                if (!enabledPaths.Contains(path))
                {
                    PluginImporter importer = AssetImporter.GetAtPath(path) as PluginImporter;

                    if (importer is PluginImporter)
                    {
                        Instance.binaryCompatibilitiesBeforeBuild.Add(path, importer.GetCompatibleWithPlatform(target));

                        importer.SetCompatibleWithPlatform(target, false);

                        message += string.Format("\n- Disabled {0}", path);
                    }
                }
            }

            RuntimeUtils.DebugLog(message);
        }

        public bool ForceLoggingBinaries { get; set; } = false;

        public class BuildProcessor : IPreprocessBuildWithReport, IPostprocessBuildWithReport
        {
            public int callbackOrder { get { return 0; } }

            public void OnPreprocessBuild(BuildReport report)
            {
                Platform.BinaryType binaryType;

                if ((report.summary.options & BuildOptions.Development) == BuildOptions.Development
                    || EditorSettings.Instance.ForceLoggingBinaries)
                {
                    binaryType = Platform.BinaryType.Logging;
                }
                else
                {
                    binaryType = Platform.BinaryType.Release;
                }

                string error;
                if (!EditorSettings.Instance.CanBuildTarget(report.summary.platform, binaryType, out error))
                {
                    throw new BuildFailedException(error);
                }

                bool androidPatchBuildPrevious = Settings.Instance.AndroidPatchBuild;
                if ((report.summary.options & BuildOptions.PatchPackage) == BuildOptions.PatchPackage)
                {
                    Settings.Instance.AndroidPatchBuild = true;
                }
                else
                {
                    Settings.Instance.AndroidPatchBuild = false;
                }
                if (androidPatchBuildPrevious != Settings.Instance.AndroidPatchBuild)
                {
                    EditorUtility.SetDirty(Settings.Instance);
                }

                EditorSettings.Instance.PreprocessBuild(report.summary.platform, binaryType);
            }

            public void OnPostprocessBuild(BuildReport report)
            {
                Instance.PostprocessBuild(report.summary.platform);
                Settings.Instance.AndroidPatchBuild = false;
            }
        }

        public void CheckActiveBuildTarget()
        {
            Settings.EditorSettings.CleanTemporaryFiles();

            Platform.BinaryType binaryType = EditorUserBuildSettings.development
                ? Platform.BinaryType.Logging
                : Platform.BinaryType.Release;

            string error;
            if (!CanBuildTarget(EditorUserBuildSettings.activeBuildTarget, binaryType, out error))
            {
                RuntimeUtils.DebugLogWarning(error);

                if (EditorWindow.HasOpenInstances<BuildPlayerWindow>())
                {
                    GUIContent message =
                        new GUIContent("FMOD detected issues with this platform!\nSee the Console for details.");
                    EditorWindow.GetWindow<BuildPlayerWindow>().ShowNotification(message, 10);
                }
            }
        }

        // Adds all platforms to the settings asset, so they get stored in the same file as the main
        // Settings object.
        public void AddPlatformsToAsset()
        {
            RuntimeSettings.Platforms.ForEach(AddPlatformToAsset);
        }

        private void AddPlatformToAsset(Platform platform)
        {
            if (!AssetDatabase.Contains(platform))
            {
                platform.name = "FMODStudioSettingsPlatform";
                AssetDatabase.AddObjectToAsset(platform, RuntimeSettings);
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorSettings.cs.meta
================================================
fileFormatVersion: 2
guid: 3c9e3e2137498d343a2e31906a12dec2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EditorUtils.cs.meta
================================================
fileFormatVersion: 2
guid: 2bb4068641d1f71478f95a9b73533f51
timeCreated: 1432608272
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventBrowser.cs.meta
================================================
fileFormatVersion: 2
guid: 5332ad2baabb58844975479e906001c8
timeCreated: 1432613753
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventCache.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace FMODUnity
{
    public class EventCache : ScriptableObject, ISerializationCallbackReceiver
    {
        [SerializeField]
        public List<EditorBankRef> EditorBanks;
        [SerializeField]
        public List<EditorEventRef> EditorEvents;
        public Dictionary<string, int> EditorEventsDict;
        [SerializeField]
        public List<EditorParamRef> EditorParameters;
        [SerializeField]
        public List<EditorBankRef> MasterBanks;
        [SerializeField]
        public List<EditorBankRef> StringsBanks;
        [SerializeField]
        public int cacheVersion;
        [SerializeField]
        private Int64 cacheTime;
        [SerializeField]
        private List<DictionaryEntry> SerializableEventsDict;
        [Serializable]
        private struct DictionaryEntry
        {
            [SerializeField]
            public string key;
            [SerializeField]
            public int index;
        }

        public DateTime CacheTime
        {
            get { return new DateTime(cacheTime); }
            set { cacheTime = value.Ticks; }
        }

        public EventCache()
        {
            EditorBanks = new List<EditorBankRef>();
            EditorEvents = new List<EditorEventRef>();
            SerializableEventsDict = new List<DictionaryEntry>();
            EditorEventsDict = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            EditorParameters = new List<EditorParamRef>();
            MasterBanks = new List<EditorBankRef>();
            StringsBanks = new List<EditorBankRef>();
            cacheTime = 0;
        }

        public void OnBeforeSerialize()
        {
            if (SerializableEventsDict.Count == 0)
            {
                SerializableEventsDict = EditorEventsDict.Select(item => new DictionaryEntry { key = item.Key, index = item.Value}).ToList();
            }
        }

        public void OnAfterDeserialize()
        {
            if (SerializableEventsDict.Count > 0)
            {
                SerializableEventsDict.ForEach((item) =>
                {
                    EditorEventsDict.Add(item.key, item.index);
                });
                SerializableEventsDict.Clear();
            }
        }

        public void BuildDictionary()
        {
            EditorEventsDict.Clear();
            int index = 0;

            EditorEvents.ForEach((eventRef) => {
                if (!EditorEventsDict.ContainsKey(eventRef.Path))
                {
                    EditorEventsDict.Add(eventRef.Path, index);
                }
                index++;
            });
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventCache.cs.meta
================================================
fileFormatVersion: 2
guid: d32cf7c32a3ed8347bac48ef5ed56d82
timeCreated: 1432775088
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventManager.cs.meta
================================================
fileFormatVersion: 2
guid: 1fc38201a5edb994c874a4a61e96053b
timeCreated: 1432600216
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventRefDrawer.cs
================================================
﻿using System;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEditor;

namespace FMODUnity
{
    [CustomPropertyDrawer(typeof(EventReference))]
    public class EventReferenceDrawer : PropertyDrawer
    {
        private static readonly Texture RepairIcon = EditorUtils.LoadImage("Wrench.png");
        private static readonly Texture WarningIcon = EditorUtils.LoadImage("NotFound.png");
        private static readonly GUIContent NotFoundWarning = new GUIContent(L10n.Tr("Event Not Found"), WarningIcon);

        private static GUIStyle buttonStyle;

        private static Vector2 WarningSize()
        {
            return GUI.skin.label.CalcSize(NotFoundWarning);
        }

        private static float GetBaseHeight()
        {
            return GUI.skin.textField.CalcSize(GUIContent.none).y;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (buttonStyle == null)
            {
                buttonStyle = new GUIStyle(GUI.skin.button);
                buttonStyle.padding.top = 1;
                buttonStyle.padding.bottom = 1;
            }

            Texture browseIcon = EditorUtils.LoadImage("SearchIconBlack.png");
            Texture openIcon = EditorUtils.LoadImage("BrowserIcon.png");
            Texture addIcon = EditorUtils.LoadImage("AddIcon.png");
            Texture copyIcon = EditorUtils.LoadImage("CopyIcon.png");

            using (new EditorGUI.PropertyScope(position, label, property))
            {
                HandleDragEvents(position, property);

                EventReference eventReference = property.GetEventReference();
                EditorEventRef editorEventRef = GetEditorEventRef(eventReference);

                float baseHeight = GetBaseHeight();

                Rect headerRect = position;
                headerRect.width = EditorGUIUtility.labelWidth;
                headerRect.height = baseHeight;

                property.isExpanded = EditorGUI.Foldout(headerRect, property.isExpanded, label, true);

                Rect addRect = new Rect(position.xMax - addIcon.width - 7, position.y, addIcon.width + 7, baseHeight);
                Rect openRect = new Rect(addRect.x - openIcon.width - 7, position.y, openIcon.width + 6, baseHeight);
                Rect searchRect = new Rect(openRect.x - browseIcon.width - 9, position.y, browseIcon.width + 8, baseHeight);
                Rect pathRect = position;
                pathRect.xMin = headerRect.xMax;
                pathRect.xMax = searchRect.x - 3;
                pathRect.height = baseHeight;

#if FMOD_SERIALIZE_GUID_ONLY
                string path = property.GetEventReferencePath();
                EditorGUI.LabelField(pathRect, path, EditorStyles.textField);
#else
                SerializedProperty pathProperty = GetPathProperty(property);
                using (var scope = new EditorGUI.ChangeCheckScope())
                {
                    EditorGUI.PropertyField(pathRect, pathProperty, GUIContent.none);

                    if (scope.changed)
                    {
                        SetEvent(property, pathProperty.stringValue);
                    }
                }
#endif

                if (GUI.Button(searchRect, new GUIContent(browseIcon, L10n.Tr("Search")), buttonStyle))
                {
                    var eventBrowser = ScriptableObject.CreateInstance<EventBrowser>();

                    eventBrowser.ChooseEvent(property);
                    var windowRect = position;
                    windowRect.xMin = pathRect.xMin;
                    windowRect.position = GUIUtility.GUIToScreenPoint(windowRect.position);
                    windowRect.height = openRect.height + 1;
                    windowRect.width = Mathf.Max(windowRect.width, 300f);
                    eventBrowser.ShowAsDropDown(windowRect, new Vector2(windowRect.width, 400));

                }
                if (GUI.Button(addRect, new GUIContent(addIcon, L10n.Tr("Create New Event in Studio")), buttonStyle))
                {
                    var addDropdown = EditorWindow.CreateInstance<CreateEventPopup>();

                    addDropdown.SelectEvent(property);
                    var windowRect = position;
                    windowRect.xMin = pathRect.xMin;
                    windowRect.position = GUIUtility.GUIToScreenPoint(windowRect.position);
                    windowRect.height = openRect.height + 1;
                    windowRect.width = Mathf.Max(windowRect.width, 300f);
                    addDropdown.ShowAsDropDown(windowRect, new Vector2(windowRect.width, 500));

                }
                if (GUI.Button(openRect, new GUIContent(openIcon, L10n.Tr("Open In Browser")), buttonStyle))
                {
                    EventBrowser.ShowWindow();
                    EventBrowser eventBrowser = EditorWindow.GetWindow<EventBrowser>();
#if FMOD_SERIALIZE_GUID_ONLY
                    eventBrowser.FrameEvent(path);
#else
                    eventBrowser.FrameEvent(pathProperty.stringValue);
#endif
                }

                if (editorEventRef != null)
                {
                    float labelY = headerRect.y + baseHeight;

                    MismatchInfo mismatch = GetMismatch(eventReference, editorEventRef);

                    if (mismatch != null)
                    {
                        Rect warningRect = pathRect;
                        warningRect.xMax = position.xMax;
                        warningRect.y = labelY;
                        warningRect.height = WarningSize().y;

                        DrawMismatchUI(warningRect, openRect.x, openRect.width, mismatch, property);

                        labelY = warningRect.yMax;
                    }

                    if (property.isExpanded)
                    {
                        using (new EditorGUI.IndentLevelScope())
                        {
                            Rect labelRect = EditorGUI.IndentedRect(headerRect);
                            labelRect.y = labelY;

                            Rect valueRect = labelRect;
                            valueRect.xMin = labelRect.xMax;
                            valueRect.xMax = position.xMax - copyIcon.width - 7;

                            GUI.Label(labelRect, new GUIContent("GUID"));
                            GUI.Label(valueRect, eventReference.Guid.ToString());

                            Rect copyRect = valueRect;
                            copyRect.xMin = valueRect.xMax;
                            copyRect.xMax = position.xMax;

                            if (GUI.Button(copyRect, new GUIContent(copyIcon, L10n.Tr("Copy To Clipboard"))))
                            {
                                EditorGUIUtility.systemCopyBuffer = eventReference.Guid.ToString();
                            }

                            valueRect.xMax = position.xMax;

                            labelRect.y += baseHeight;
                            valueRect.y += baseHeight;

                            GUI.Label(labelRect, new GUIContent(L10n.Tr("Banks")));
                            GUI.Label(valueRect, string.Join(", ", editorEventRef.Banks.Select(x => x.Name).ToArray()));
                            labelRect.y += baseHeight;
                            valueRect.y += baseHeight;

                            GUI.Label(labelRect, new GUIContent(L10n.Tr("Panning")));
                            GUI.Label(valueRect, editorEventRef.Is3D ? "3D" : "2D");
                            labelRect.y += baseHeight;
                            valueRect.y += baseHeight;

                            GUI.Label(labelRect, new GUIContent(L10n.Tr("Stream")));
                            GUI.Label(valueRect, editorEventRef.IsStream.ToString());
                            labelRect.y += baseHeight;
                            valueRect.y += baseHeight;

                            GUI.Label(labelRect, new GUIContent(L10n.Tr("Oneshot")));
                            GUI.Label(valueRect, editorEventRef.IsOneShot.ToString());
                            labelRect.y += baseHeight;
                            valueRect.y += baseHeight;
                        }
                    }
                }
                else
                {
                    EditorEventRef renamedEvent = GetRenamedEventRef(eventReference);

                    if (renamedEvent != null)
                    {
                        MismatchInfo mismatch = new MismatchInfo() {
                            Message = string.Format(L10n.Tr("Moved to {0}"), renamedEvent.Path),
                            HelpText = string.Format(
                                L10n.Tr("This event has been moved in FMOD Studio.\nYou can click the repair button to update the path to the new location, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."),
                                EventReferenceUpdater.MenuPath),
                            RepairTooltip = string.Format(L10n.Tr("Repair: set path to {0}"), renamedEvent.Path),
                            RepairAction = (p) => {
                                p.FindPropertyRelative("Path").stringValue = renamedEvent.Path;
                            },
                        };

                        using (new EditorGUI.IndentLevelScope())
                        {
                            Rect mismatchRect = pathRect;

                            mismatchRect.xMin = position.xMin;
                            mismatchRect.xMax = position.xMax;
                            mismatchRect.y += baseHeight;
                            mismatchRect.height = baseHeight;

                            mismatchRect = EditorGUI.IndentedRect(mismatchRect);

                            DrawMismatchUI(mismatchRect, openRect.x, openRect.width, mismatch, property);
                        }
                    }
                    else
                    {
                        Rect labelRect = pathRect;
                        labelRect.xMax = position.xMax;
                        labelRect.y += baseHeight;
                        labelRect.height = WarningSize().y;

                        GUI.Label(labelRect, NotFoundWarning);
                    }
                }
            }
        }

        private static void HandleDragEvents(Rect position, SerializedProperty property)
        {
            Event e = Event.current;

            if (e.type == EventType.DragPerform && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorEventRef))
                {
                    EditorEventRef eventRef = DragAndDrop.objectReferences[0] as EditorEventRef;

                    property.SetEventReference(eventRef.Guid, eventRef.Path);

                    GUI.changed = true;
                    e.Use();
                }
            }

            if (e.type == EventType.DragUpdated && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorEventRef))
                {
                    DragAndDrop.visualMode = DragAndDropVisualMode.Move;
                    DragAndDrop.AcceptDrag();
                    e.Use();
                }
            }
        }

        private class MismatchInfo
        {
            public string Message;
            public string HelpText;
            public string RepairTooltip;
            public Action<SerializedProperty> RepairAction;
        }

        private static void DrawMismatchUI(Rect rect, float repairButtonX, float repairButtonWidth,
            MismatchInfo mismatch, SerializedProperty property)
        {
            rect = EditorUtils.DrawHelpButton(rect, () => new SimpleHelp(mismatch.HelpText, 400));

            Rect repairRect = new Rect(repairButtonX, rect.y, repairButtonWidth, GetBaseHeight());

            if (GUI.Button(repairRect, new GUIContent(RepairIcon, mismatch.RepairTooltip), buttonStyle))
            {
                mismatch.RepairAction(property);
            }

            Rect labelRect = rect;
            labelRect.xMax = repairRect.xMin;

            GUI.Label(labelRect, new GUIContent(mismatch.Message, WarningIcon));
        }

        private static MismatchInfo GetMismatch(EventReference eventReference, EditorEventRef editorEventRef)
        {
            if (EventManager.GetEventLinkage(eventReference) == EventLinkage.Path)
            {
                if (eventReference.Guid != editorEventRef.Guid)
                {
                    return new MismatchInfo() {
                        Message = L10n.Tr("GUID doesn't match path"),
                        HelpText = string.Format(
                            L10n.Tr("The GUID on this EventReference doesn't match the path.\nYou can click the repair button to update the GUID to match the path, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."),
                            EventReferenceUpdater.MenuPath),
                        RepairTooltip = string.Format(L10n.Tr("Repair: set GUID to {0}"), editorEventRef.Guid),
                        RepairAction = (property) => {
                            property.FindPropertyRelative("Guid").SetGuid(editorEventRef.Guid);
                        },
                    };
                }
            }
            else // EventLinkage.GUID
            {
                if (eventReference.Path != editorEventRef.Path)
                {
                    return new MismatchInfo() {
                        Message = L10n.Tr("Path doesn't match GUID"),
                        HelpText = string.Format(
                            L10n.Tr("The path on this EventReference doesn't match the GUID.\nYou can click the repair button to update the path to match the GUID, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."),
                            EventReferenceUpdater.MenuPath),
                        RepairTooltip = string.Format(L10n.Tr("Repair: set path to '{0}'"), editorEventRef.Path),
                        RepairAction = (property) => {
                            property.FindPropertyRelative("Path").stringValue = editorEventRef.Path;
                        },
                    };
                }
            }

            return null;
        }

        private static void SetEvent(SerializedProperty property, string path)
        {
            EditorEventRef eventRef = EventManager.EventFromPath(path);

            if (eventRef != null)
            {
                property.SetEventReference(eventRef.Guid, eventRef.Path);
            }
            else
            {
                property.SetEventReference(new FMOD.GUID(), path);
            }
        }

        private static SerializedProperty GetGuidProperty(SerializedProperty property)
        {
            return property.FindPropertyRelative("Guid");
        }

        private static SerializedProperty GetPathProperty(SerializedProperty property)
        {
            return property.FindPropertyRelative("Path");
        }

        private static EditorEventRef GetEditorEventRef(EventReference eventReference)
        {
            if (EventManager.GetEventLinkage(eventReference) == EventLinkage.Path)
            {
                return EventManager.EventFromPath(eventReference.Path);
            }
            else // Assume EventLinkage.GUID
            {
                return EventManager.EventFromGUID(eventReference.Guid);
            }
        }

        private static EditorEventRef GetRenamedEventRef(EventReference eventReference)
        {
            if (Settings.Instance.EventLinkage == EventLinkage.Path && !eventReference.Guid.IsNull)
            {
                EditorEventRef editorEventRef = EventManager.EventFromGUID(eventReference.Guid);

                if (editorEventRef != null && editorEventRef.Path != eventReference.Path)
                {
                    return editorEventRef;
                }
            }

            return null;
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            float baseHeight = GetBaseHeight();

            EventReference eventReference = property.GetEventReference();
            EditorEventRef editorEventRef = GetEditorEventRef(eventReference);

            if (editorEventRef == null)
            {
                return baseHeight + WarningSize().y;
            }
            else
            {
                float height;

                if (property.isExpanded)
                {
                    height = baseHeight * 6; // 5 lines of info
                }
                else
                {
                    height = baseHeight;
                }

                if (GetMismatch(eventReference, editorEventRef) != null)
                {
                    height += WarningSize().y;
                }

                return height;
            }
        }
    }

#pragma warning disable 0618 // Suppress the warning about using the obsolete EventRefAttribute class
    [CustomPropertyDrawer(typeof(EventRefAttribute))]
#pragma warning restore 0618
    public class LegacyEventRefDrawer : PropertyDrawer
    {
        private GUIStyle RichTextStyle;

        private static readonly string HelpText =
        string.Format(L10n.Tr("This field has the <b>[FMODUnity.EventRef]</b> attribute, which is obsolete.\nTo resolve this issue:\n* Add a field of type <b>FMODUnity.EventReference</b> to this class\nSet the <b>MigrateTo</b> property on the <b>[FMODUnity.EventRef]</b> attribute: <b>[FMODUnity.EventRef(MigrateTo=\"<fieldname>\")]</b>\n Run the <b>{0}</b> command to automatically migrate values from this field to the <b>FMODUnity.EventReference</b> field"), EventReferenceUpdater.MenuPath);
        private static readonly Texture InfoIcon = EditorGUIUtility.IconContent("console.infoicon.sml").image;
        private static readonly Texture WarningIcon = EditorUtils.LoadImage("NotFound.png");

        private void AffirmStyles()
        {
            if (RichTextStyle == null)
            {
                RichTextStyle = new GUIStyle(GUI.skin.label) { richText = true };
            }
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            AffirmStyles();

            label = EditorGUI.BeginProperty(position, label, property);

            Rect pathRect = position;
            pathRect.height = EditorGUIUtility.singleLineHeight;

            pathRect = EditorGUI.PrefixLabel(pathRect, label);
            EditorGUI.PropertyField(pathRect, property, GUIContent.none);

            using (new EditorGUI.IndentLevelScope())
            {
                GUIContent content = StatusContent(property);

                Rect infoRect = EditorGUI.IndentedRect(position);
                infoRect.y = pathRect.yMax;
                infoRect.height = StatusSize(content).y;

                infoRect = EditorUtils.DrawHelpButton(infoRect, () => new SimpleHelp(HelpText, 400));

                GUI.Label(infoRect, content, RichTextStyle);
            }

            EditorGUI.EndProperty();
        }

        private GUIContent StatusContent(SerializedProperty property)
        {
#pragma warning disable 0618 // Suppress the warning about using the obsolete EventRefAttribute class
            string migrationTarget = (attribute as EventRefAttribute).MigrateTo;
#pragma warning restore 0618

            if (string.IsNullOrEmpty(migrationTarget))
            {
                return new GUIContent(L10n.Tr("<b>[FMODUnity.EventRef]</b> is obsolete - use the <b>FMODUnity.EventReference</b> type instead."),
                    WarningIcon);

            }
            else
            {
                int parentPathLength = property.propertyPath.LastIndexOf('.');

                if (parentPathLength >= 0)
                {
                    migrationTarget = string.Format("{0}.{1}", property.propertyPath.Remove(parentPathLength), migrationTarget);
                }

                SerializedProperty targetProperty = property.serializedObject.FindProperty(migrationTarget);

                if (targetProperty != null)
                {
                    return new GUIContent(string.Format(L10n.Tr("Will be migrated to <b>{0}</b>"), targetProperty.displayName),
                        InfoIcon);
                }
                else
                {
                    return new GUIContent(string.Format(L10n.Tr("Migration target <b>{0}</b> is missing"), migrationTarget),
                        WarningIcon);
                }
            }
        }

        private Vector2 StatusSize(GUIContent content)
        {
            AffirmStyles();

            return Vector2.Max(RichTextStyle.CalcSize(content), EditorUtils.GetHelpButtonSize());
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
        {
            return EditorGUIUtility.singleLineHeight + StatusSize(StatusContent(property)).y;
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventRefDrawer.cs.meta
================================================
fileFormatVersion: 2
guid: 29a86a77bf7568e499243d9b47b7e88e
timeCreated: 1432696197
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/EventReferenceUpdater.cs.meta
================================================
fileFormatVersion: 2
guid: 0b58df65bd3bb6649801b24a7a942ccb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FileReorganizer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

#if UNITY_6000_2_OR_NEWER
using TreeView = UnityEditor.IMGUI.Controls.TreeView<int>;
using TreeViewItem = UnityEditor.IMGUI.Controls.TreeViewItem<int>;
using TreeViewState = UnityEditor.IMGUI.Controls.TreeViewState<int>;
#endif

namespace FMODUnity
{
    public class FileReorganizer : EditorWindow, ISerializationCallbackReceiver
    {
        public const string ReorganizerMenuItemPath = "FMOD/Reorganize Plugin Files";

        [SerializeField]
        private List<Task> tasks = new List<Task>();

        [SerializeField]
        private int taskCount;

        [SerializeField]
        private int currentTask;

        private TaskView taskView;

        [SerializeField]
        private TreeViewState taskViewState = new TreeViewState();

        [SerializeField]
        private MultiColumnHeaderState taskHeaderState;

        [SerializeField]
        private bool reloadingFromSerializedState = false;

        [NonSerialized]
        private GUIContent statusContent = GUIContent.none;

        private IEnumerator<string> processingState;

        [MenuItem(ReorganizerMenuItemPath)]
        public static void ShowWindow()
        {
            FileReorganizer reorganizer = GetWindow<FileReorganizer>(L10n.Tr("FMOD File Reorganizer"));
            reorganizer.minSize = new Vector2(850, 600);

            reorganizer.PopulateTasks();

            reorganizer.Show();
        }

        [Serializable]
        private class Task
        {
            public int step = int.MaxValue;

            private Task()
            {
            }

            public static Task Move(string source, string destination, Platform platform)
            {
                return new Task() {
                    type = Type.Move,
                    status = Status.Pending,
                    platform = platform,
                    source = source,
                    destination = destination,
                    statusText = string.Format(L10n.Tr("{0} will be moved to\n{1}"), source, destination),
                };
            }

            public static Task RemoveFolder(string path)
            {
                return new Task() {
                    type = Type.RemoveFolder,
                    status = Status.Pending,
                    source = path,
                    statusText = string.Format(L10n.Tr("{0} will be removed if it is empty"), path),
                };
            }

            public static Task Missing(string path, Platform platform)
            {
                return new Task() {
                    type = Type.Missing,
                    status = Status.Missing,
                    platform = platform,
                    source = path,
                    statusText = string.Format(
                        L10n.Tr("{0} is missing.\nYou may need to reinstall the {1} support package from {2}."),
                        path, platform.DisplayName, EditorSettings.DownloadURL),
                };
            }

            public static Task RemoveAsset(string path, Platform platform)
            {
                return new Task() {
                    type = Type.RemoveAsset,
                    status = Status.Pending,
                    platform = platform,
                    source = path,
                    statusText = string.Format(L10n.Tr("{0} will be removed"), path),
                };
            }

            public Platform platform { get; private set; }
            public string source { get; private set; }
            public string destination { get; private set; }

            public enum Status
            {
                Pending,
                Succeeded,
                Failed,
                Missing,
            }

            public Status status { get; private set; }
            public string statusText { get; private set; }

            public void SetSucceeded(string message)
            {
                status = Status.Succeeded;
                statusText = message;
            }

            public void SetFailed(string message)
            {
                status = Status.Failed;
                statusText = message;
            }

            public enum Type
            {
                Move,
                RemoveFolder,
                RemoveAsset,
                Missing,
            }

            public Type type { get; private set; }

            public string platformName { get { return (platform != null) ? platform.DisplayName : string.Empty; } }
        }

        public void OnBeforeSerialize()
        {
            taskViewState = taskView.state;
            taskHeaderState = taskView.multiColumnHeader.state;
        }

        public void OnAfterDeserialize()
        {
        }

        private void OnEnable()
        {
            {
                MultiColumnHeaderState newHeaderState = TaskView.CreateHeaderState();

                if (MultiColumnHeaderState.CanOverwriteSerializedFields(taskHeaderState, newHeaderState))
                {
                    MultiColumnHeaderState.OverwriteSerializedFields(taskHeaderState, newHeaderState);
                }

                taskHeaderState = newHeaderState;
            }

            MultiColumnHeader taskHeader = new MultiColumnHeader(taskHeaderState);

            taskView = new TaskView(taskViewState, taskHeader, tasks);
            taskView.taskSelected += OnTaskSelected;

            taskView.Reload();

            if (reloadingFromSerializedState)
            {
                taskView.SortRows();
            }
            else
            {
                taskHeader.ResizeToFit();
                taskHeader.SetSorting((int)TaskView.Column.Step, true);
            }

            reloadingFromSerializedState = true;

            EditorApplication.update += ProcessNextTask;
        }

        private void OnDestroy()
        {
            EditorApplication.update -= ProcessNextTask;

            StopProcessing();
        }

        private void PopulateTasks()
        {
            tasks.Clear();

            TaskGenerator.Generate(tasks);

            SetTaskSequence();
            UpdateTaskCount();
            SetDefaultStatus();

            taskView.Reload();
            taskView.SortRows();
        }

        public static bool IsUpToDate()
        {
            List<Task> tasks = new List<Task>();

            TaskGenerator.Generate(tasks);

            return !tasks.Any(t => t.type != Task.Type.Missing);
        }

        private void SetDefaultStatus()
        {
            int missingCount = tasks.Count(t => t.type == Task.Type.Missing);

            if (missingCount > 0)
            {
                string message;

                if (missingCount == 1)
                {
                    message = L10n.Tr("There is a file missing. Select it above for more information.");
                }
                else
                {
                    message = string.Format(
                        L10n.Tr("There are {0} files missing. Select them above for more information."), missingCount);
                }

                statusContent = new GUIContent(message, Resources.StatusIcon[Task.Status.Missing]);
            }
            else
            {
                statusContent = GUIContent.none;
            }
        }

        private void SetTaskSequence()
        {
            int step = 1;

            foreach (Task task in tasks.Where(t => t.type == Task.Type.Move))
            {
                task.step = step;
                ++step;
            }

            foreach (Task task in tasks.Where(t => t.type == Task.Type.RemoveAsset))
            {
                task.step = step;
                ++step;
            }

            // Sort folder tasks in reverse path order, so subfolders are processed before their parents
            foreach (Task task in tasks.Where(t => t.type == Task.Type.RemoveFolder).OrderByDescending(t => t.source))
            {
                task.step = step;
                ++step;
            }

            tasks.Sort((a, b) => a.step.CompareTo(b.step));
        }

        private void UpdateTaskCount()
        {
            taskCount = tasks.Count(t => t.status == Task.Status.Pending);
        }

        private class TaskView : TreeView
        {
            private List<Task> tasks;

            public delegate void TaskSelectedHandler(Task task);

            public event TaskSelectedHandler taskSelected;

            public TaskView(TreeViewState state, MultiColumnHeader header, List<Task> tasks)
                : base(state, header)
            {
                this.tasks = tasks;

                showAlternatingRowBackgrounds = true;

                header.sortingChanged += SortRows;
            }

            public static MultiColumnHeaderState CreateHeaderState()
            {
                MultiColumnHeaderState.Column[] columns = new MultiColumnHeaderState.Column[] {
                    new MultiColumnHeaderState.Column()
                    {
                        headerContent = new GUIContent(L10n.Tr("Task #")),
                        width = 50,
                        autoResize = false,
                        allowToggleVisibility = false,
                    },
                    new MultiColumnHeaderState.Column()
                    {
                        headerContent = new GUIContent(L10n.Tr("Status")),
                        width = 100,
                        autoResize = false,
                        allowToggleVisibility = false,
                    },
                    new MultiColumnHeaderState.Column() {
                        headerContent = new GUIContent(L10n.Tr("Platform")),
                        width = 150,
                        autoResize = false,
                        allowToggleVisibility = false,
                    },
                    new MultiColumnHeaderState.Column()
                    {
                        headerContent = new GUIContent(L10n.Tr("Description")),
                        minWidth = 500,
                        allowToggleVisibility = false,
                    },
                };

                return new MultiColumnHeaderState(columns);
            }

            public enum Column
            {
                Step,
                Status,
                Platform,
                Description,
            }

            private class TaskItem : TreeViewItem
            {
                public Task task;
            }

            protected override TreeViewItem BuildRoot()
            {
                TreeViewItem root = new TreeViewItem(-1, -1);

                if (tasks.Count > 0)
                {
                    int index = 0;

                    foreach (Task task in tasks)
                    {
                        TreeViewItem taskItem = new TaskItem() {
                            id = index++,
                            task = task,
                        };

                        root.AddChild(taskItem);
                    }
                }
                else
                {
                    TreeViewItem item = new TreeViewItem(0);
                    item.displayName = L10n.Tr("Nothing to do here.");

                    root.AddChild(item);
                }

                SetupDepthsFromParentsAndChildren(root);

                return root;
            }

            protected override bool CanMultiSelect(TreeViewItem item)
            {
                return false;
            }

            protected override void SelectionChanged(IList<int> selectedIds)
            {
                base.SelectionChanged(selectedIds);

                if (taskSelected != null)
                {
                    if (selectedIds.Count > 0)
                    {
                        TaskItem item = FindItem(selectedIds[0], rootItem) as TaskItem;

                        if (item != null)
                        {
                            taskSelected(item.task);
                            return;
                        }
                    }

                    taskSelected(null);
                }
            }

            public void SortRows()
            {
                SortRows(multiColumnHeader);
            }

            private void SortRows(MultiColumnHeader header)
            {
                IList<TreeViewItem> rows = GetRows();
                int[] sortedColumns = header.state.sortedColumns;

                if (sortedColumns.Length > 0 && rows.Count > 1)
                {
                    int firstColumn = sortedColumns[0];

                    IOrderedEnumerable<TreeViewItem> query =
                        InitialQuery(rows, (Column)firstColumn, header.IsSortedAscending(firstColumn));

                    for (int i = 1; i < sortedColumns.Length; ++i)
                    {
                        query = SubQuery(query, sortedColumns[i], header.IsSortedAscending(sortedColumns[i]));
                    }

                    // We need to execute the query before clearing rows, otherwise it returns nothing
                    List<TreeViewItem> newRows = query.ToList();

                    rows.Clear();

                    foreach (TreeViewItem item in newRows)
                    {
                        rows.Add(item);
                    }
                }

                RefreshCustomRowHeights();
            }

            private IOrderedEnumerable<TreeViewItem> InitialQuery(IList<TreeViewItem> rows, Column column, bool ascending)
            {
                switch (column)
                {
                    case Column.Step:
                        return Sort(rows, r => (r as TaskItem).task.step, ascending);
                    case Column.Status:
                        return Sort(rows, r => (r as TaskItem).task.status, ascending);
                    case Column.Platform:
                        return Sort(rows, r => (r as TaskItem).task.platformName, ascending);
                    case Column.Description:
                        return Sort(rows, r => (r as TaskItem).task.source, ascending);
                    default:
                        throw new ArgumentException("Unrecognised column: " + column);
                }
            }

            private static IOrderedEnumerable<TreeViewItem> SubQuery(
                IOrderedEnumerable<TreeViewItem> query, int column, bool ascending)
            {
                switch ((Column)column)
                {
                    case Column.Step:
                        return SubSort(query, r => (r as TaskItem).task.step, ascending);
                    case Column.Status:
                        return SubSort(query, r => (r as TaskItem).task.status, ascending);
                    case Column.Platform:
                        return SubSort(query, r => (r as TaskItem).task.platformName, ascending);
                    case Column.Description:
                        return SubSort(query, r => (r as TaskItem).task.source, ascending);
                    default:
                        throw new ArgumentException("Unrecognised column: " + column);
                }
            }

            protected override float GetCustomRowHeight(int row, TreeViewItem item)
            {
                if (item is TaskItem)
                {
                    Task task = (item as TaskItem).task;

                    if (task.type == Task.Type.Move)
                    {
                        return EditorGUIUtility.singleLineHeight * 2;
                    }
                    else
                    {
                        return Resources.StatusHeight();
                    }
                }
                else
                {
                    return base.GetCustomRowHeight(row, item);
                }
            }

            protected override void RowGUI(RowGUIArgs args)
            {
                if (args.item is TaskItem)
                {
                    TaskItem taskItem = args.item as TaskItem;

                    for (int i = 0; i < args.GetNumVisibleColumns(); ++i)
                    {
                        CellGUI(args.GetCellRect(i), taskItem.task, args.GetColumn(i));
                    }
                }
                else
                {
                    base.RowGUI(args);
                }
            }

            private void CellGUI(Rect rect, Task task, int columnIndex)
            {
                switch ((Column)columnIndex)
                {
                    case Column.Step:
                        if (task.step != int.MaxValue)
                        {
                            GUI.Label(rect, task.step.ToString(), Resources.StepStyle());
                        }
                        break;
                    case Column.Status:
                        GUI.Label(rect, Resources.StatusContent[task.status], Resources.StatusColumnStyle());
                        break;
                    case Column.Platform:
                        GUI.Label(rect, task.platformName, Resources.PlatformStyle());
                        break;
                    case Column.Description:
                        DrawDescription(rect, task);
                        break;
                }
            }

            private void DrawDescription(Rect rect, Task task)
            {
                switch (task.type)
                {
                    case Task.Type.Move:
                        DrawMoveDescription(rect, task);
                        break;
                    case Task.Type.RemoveFolder:
                        DrawRemoveFolderDescription(rect, task);
                        break;
                    case Task.Type.RemoveAsset:
                        DrawRemoveAssetDescription(rect, task);
                        break;
                    case Task.Type.Missing:
                        DrawMissingDescription(rect, task);
                        break;
                }
            }

            private void DrawMoveDescription(Rect rect, Task task)
            {
                Rect sourcePrefixRect = new Rect(rect.x, rect.y, Resources.PrefixSize().x, Resources.PrefixSize().y);

                Rect destinationPrefixRect = sourcePrefixRect;
                destinationPrefixRect.y = sourcePrefixRect.yMax;

                Rect sourceRect = sourcePrefixRect;
                sourceRect.x = sourcePrefixRect.xMax;
                sourceRect.xMax = rect.xMax;

                Rect destinationRect = destinationPrefixRect;
                destinationRect.x = destinationPrefixRect.xMax;
                destinationRect.xMax = rect.xMax;

                EditorGUI.BeginDisabledGroup(true);

                GUI.Label(sourcePrefixRect, Resources.SourcePrefix, Resources.PrefixStyle());
                GUI.Label(destinationPrefixRect, Resources.DestinationPrefix, Resources.PrefixStyle());

                EditorGUI.EndDisabledGroup();

                DrawAssetPath(sourceRect, task.source);
                DrawAssetPath(destinationRect, task.destination);
            }

            private void DrawRemoveFolderDescription(Rect rect, Task task)
            {
                Rect prefixRect = new Rect(rect.x, rect.y, Resources.PrefixSize().x, Resources.PrefixSize().y);

                Rect pathRect = prefixRect;
                pathRect.x = prefixRect.xMax;
                pathRect.width = Resources.AssetPathStyle().CalcSize(new GUIContent(task.source)).x;

                Rect suffixRect = prefixRect;
                suffixRect.x = pathRect.xMax;
                suffixRect.xMax = rect.xMax;

                EditorGUI.BeginDisabledGroup(true);

                GUI.Label(prefixRect, Resources.RemovePrefix, Resources.PrefixStyle());

                EditorGUI.EndDisabledGroup();

                DrawAssetPath(pathRect, task.source);

                EditorGUI.BeginDisabledGroup(true);

                GUI.Label(suffixRect, L10n.Tr("if empty"), Resources.SuffixStyle());

                EditorGUI.EndDisabledGroup();
            }

            private void DrawRemoveAssetDescription(Rect rect, Task task)
            {
                Rect prefixRect = new Rect(rect.x, rect.y, Resources.PrefixSize().x, Resources.PrefixSize().y);

                Rect pathRect = prefixRect;
                pathRect.x = prefixRect.xMax;
                pathRect.width = Resources.AssetPathStyle().CalcSize(new GUIContent(task.source)).x;

                EditorGUI.BeginDisabledGroup(true);

                GUI.Label(prefixRect, Resources.RemovePrefix, Resources.PrefixStyle());

                EditorGUI.EndDisabledGroup();

                DrawAssetPath(pathRect, task.source);
            }

            private void DrawMissingDescription(Rect rect, Task task)
            {
                Rect sourceRect = rect;
                sourceRect.xMin += Resources.PrefixSize().x;

                DrawAssetPath(sourceRect, task.source);
            }
        }

        private static IOrderedEnumerable<T1> Sort<T1, T2>(IEnumerable<T1> enumerable,
            Func<T1, T2> keySelector, bool ascending)
        {
            if (ascending)
            {
                return enumerable.OrderBy(keySelector);
            }
            else
            {
                return enumerable.OrderByDescending(keySelector);
            }
        }

        private static IOrderedEnumerable<T1> SubSort<T1, T2>(IOrderedEnumerable<T1> enumerable,
            Func<T1, T2> keySelector, bool ascending)
        {
            if (ascending)
            {
                return enumerable.ThenBy(keySelector);
            }
            else
            {
                return enumerable.ThenByDescending(keySelector);
            }
        }

        private class Resources
        {
            private static GUIStyle statusColumnStyle;

            private static GUIStyle statusBarStyle;

            private static float statusHeight;

            private static GUIStyle stepStyle;

            public static readonly GUIContent SourcePrefix = new GUIContent("Move");
            public static readonly GUIContent DestinationPrefix = new GUIContent("to");
            public static readonly GUIContent RemovePrefix = new GUIContent(L10n.Tr("Remove"));

            private static Vector2 prefixSize;

            private static GUIStyle prefixStyle;

            private static GUIStyle suffixStyle;

            private static GUIStyle assetPathStyle;

            private static bool cacheInitialized = false;

            public static readonly Dictionary<Task.Status, Texture> StatusIcon =
                new Dictionary<Task.Status, Texture>() {
                {  Task.Status.Pending, EditorGUIUtility.FindTexture("TestNormal") },
                {  Task.Status.Succeeded, EditorGUIUtility.FindTexture("TestPassed") },
                {  Task.Status.Failed, EditorGUIUtility.FindTexture("TestFailed") },
                {  Task.Status.Missing, EditorGUIUtility.FindTexture("console.warnicon.sml") },
            };

            public static readonly Dictionary<Task.Status, GUIContent> StatusContent =
                new Dictionary<Task.Status, GUIContent>() {
                {  Task.Status.Pending, new GUIContent(L10n.Tr("Pending"), StatusIcon[Task.Status.Pending]) },
                {  Task.Status.Succeeded, new GUIContent(L10n.Tr("Succeeded"), StatusIcon[Task.Status.Succeeded]) },
                {  Task.Status.Failed, new GUIContent(L10n.Tr("Failed"), StatusIcon[Task.Status.Failed]) },
                {  Task.Status.Missing, new GUIContent(L10n.Tr("Missing"), StatusIcon[Task.Status.Missing]) },
            };

            public static GUIStyle StatusColumnStyle()
            {
                AffirmCache();
                return statusColumnStyle;
            }

            public static GUIStyle StatusBarStyle()
            {
                AffirmCache();
                return statusBarStyle;
            }

            public static GUIStyle PlatformStyle()
            {
                return StatusColumnStyle();
            }

            public static float StatusHeight()
            {
                if (statusHeight == 0)
                {
                    foreach (var current in StatusIcon)
                    {
                        statusHeight = Math.Max(statusHeight, current.Value.height + 4);
                    }
                }

                return statusHeight;
            }

            public static GUIStyle StepStyle()
            {
                AffirmCache();
                return stepStyle;
            }

            public static Vector2 PrefixSize()
            {
                AffirmCache();
                return prefixSize;
            }

            public static GUIStyle PrefixStyle()
            {
                AffirmCache();
                return prefixStyle;
            }

            public static GUIStyle SuffixStyle()
            {
                AffirmCache();
                return suffixStyle;
            }

            public static GUIStyle AssetPathStyle()
            {
                AffirmCache();
                return assetPathStyle;
            }

            private static void AffirmCache()
            {
                if (!cacheInitialized)
                {
                    cacheInitialized = true;

                    statusColumnStyle = new GUIStyle(GUI.skin.label) {
                        alignment = TextAnchor.MiddleLeft,
                    };

                    statusBarStyle = new GUIStyle(GUI.skin.label) {
                        alignment = TextAnchor.UpperLeft,
                        wordWrap = true,
                    };

                    stepStyle = new GUIStyle(GUI.skin.label) {
                        alignment = TextAnchor.MiddleRight,
                    };

                    prefixStyle = new GUIStyle(GUI.skin.label) {
                        alignment = TextAnchor.MiddleRight,
                    };

                    suffixStyle = new GUIStyle(GUI.skin.label) {
                        alignment = TextAnchor.MiddleLeft,
                    };

                    assetPathStyle = new GUIStyle(GUI.skin.label);

                    prefixSize = prefixStyle.CalcSize(SourcePrefix);
                    prefixSize = Vector2.Max(prefixSize, prefixStyle.CalcSize(DestinationPrefix));
                    prefixSize = Vector2.Max(prefixSize, prefixStyle.CalcSize(RemovePrefix));
                }
            }
        }

        private void OnTaskSelected(Task task)
        {
            if (task != null)
            {
                statusContent = new GUIContent(task.statusText, Resources.StatusIcon[task.status]);
            }
            else
            {
                SetDefaultStatus();
            }
        }

        private void OnGUI()
        {
            if (focusedWindow == this
                && Event.current.type == EventType.KeyDown
                && Event.current.keyCode == KeyCode.Escape)
            {
                Cancel();
                Event.current.Use();
            }

            // Task list
            GUILayout.BeginVertical(GUI.skin.box);

            Rect treeViewRect = GUILayoutUtility.GetRect(0, 0, GUILayout.ExpandWidth(true), GUILayout.ExpandHeight(true));

            taskView.OnGUI(treeViewRect);

            GUILayout.EndVertical();

            // Status bar
            GUILayout.BeginHorizontal(GUI.skin.box, GUILayout.Height(EditorGUIUtility.singleLineHeight * 2));

            GUILayout.Label(statusContent.image, GUILayout.ExpandWidth(false));
            EditorGUILayout.SelectableLabel(statusContent.text, Resources.StatusBarStyle());

            GUILayout.EndHorizontal();

            // Buttons
            float buttonHeight = EditorGUIUtility.singleLineHeight * 2;

            GUILayout.BeginHorizontal();

            if (GUILayout.Button(L10n.Tr("Cancel"), GUILayout.Height(buttonHeight)))
            {
                Cancel();
            }

            EditorGUI.BeginDisabledGroup(IsProcessing());

            if (GUILayout.Button(L10n.Tr("Refresh"), GUILayout.Height(buttonHeight)))
            {
                PopulateTasks();
            }

            EditorGUI.EndDisabledGroup();

            if (IsProcessing())
            {
                EditorGUI.BeginDisabledGroup(true);

                GUILayout.Button(string.Format(L10n.Tr("Processing Task {0} of {1}"), currentTask, taskCount), GUILayout.Height(buttonHeight));

                EditorGUI.EndDisabledGroup();
            }
            else
            {
                if (GUILayout.Button(string.Format(L10n.Tr("Process {0} Tasks"), taskCount), GUILayout.Height(buttonHeight)))
                {
                    StartProcessing();
                }
            }

            GUILayout.EndHorizontal();
        }

        private void Cancel()
        {
            if (IsProcessing())
            {
                StopProcessing();
            }
            else
            {
                Close();
            }
        }

        private static void DrawAssetPath(Rect rect, string path)
        {
            GUIStyle pathStyle = Resources.AssetPathStyle();
            GUIContent pathContent = new GUIContent(path);

            Rect pathRect = rect;
            pathRect.width = pathStyle.CalcSize(pathContent).x;

            GUI.Label(pathRect, pathContent, pathStyle);
            EditorGUIUtility.AddCursorRect(pathRect, MouseCursor.Link);

            if (Event.current.type == EventType.MouseDown
                && pathRect.Contains(Event.current.mousePosition))
            {
                SelectAssetOrParentFolder(path);
                Event.current.Use();
            }
        }

        private static void SelectAssetOrParentFolder(string path)
        {
            while (!AssetExists(path))
            {
                path = EditorUtils.GetParentFolder(path);

                if (string.IsNullOrEmpty(path))
                {
                    return;
                }
            }

            Selection.activeObject = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(path);
        }

        private void OnInspectorUpdate()
        {
            ProcessNextTask();
        }

        private struct TaskGenerator
        {
            private const string AssetsFolder = "Assets";
            private const string FMODRoot = "Assets/Plugins/FMOD";
            private const string FMODSource = FMODRoot + "/src";

            private static readonly string[] BaseFolders = {
                FMODSource,
                FMODRoot,
                "Assets/Plugins",
                "Assets",
            };

            private static readonly MoveRecord[] looseAssets = {
                // Release 1.10 layout
                new MoveRecord() { source = FMODRoot + "/fmodplugins.cpp", destination = "obsolete" },
                new MoveRecord() { source = "Assets/Editor/FMODMigrationUtil.cs", destination = "obsolete" },
                new MoveRecord() { source = "Assets/GoogleVR", destination = "addons" },
                new MoveRecord() { source = "Assets/ResonanceAudio", destination = "addons" },
                new MoveRecord() { source = "Assets/Resources/FMODStudioSettings.asset", destination = "Resources" },
                new MoveRecord() { source = "Assets/FMODStudioCache.asset", destination = "Resources" },

                // Release 2.0 layout
                new MoveRecord() { source = FMODRoot + "/src/Runtime/fmodplugins.cpp", destination = "obsolete" },

                // Release 2.1 layout
                new MoveRecord() { source = FMODRoot + "/src/Runtime/fmod_static_plugin_support.h", destination = "obsolete" },
                new MoveRecord() { source = FMODRoot + "/src/Runtime/CodeGeneration.cs", destination = "src/Editor" },

                // Release 2.2 layout
                new MoveRecord() { source = FMODRoot + "/src/fmodplugins.cpp", destination = "obsolete" },
                new MoveRecord() { source = FMODRoot + "/src/fmod_static_plugin_support.h", destination = "obsolete" },
                new MoveRecord() { source = FMODSource + "/CodeGeneration.cs", destination = "src/Editor" },

                // Release 2.3 layout
                new MoveRecord() { source = FMODRoot + "/platforms/html5/lib/libfmodstudiounityplugin.bc", destination = "obsolete" },
                new MoveRecord() { source = FMODRoot + "/platforms/html5/lib/libfmodstudiounitypluginL.bc", destination = "obsolete" },
            };

            private static readonly string[] fmodFoldersToCleanUp = {
                "Assets/Plugins/FMOD/Runtime",
                "Assets/Plugins/FMOD/lib",
            };
            private static readonly string[] publicFoldersToCleanUp = {
                "Assets/Plugins/Editor",
            };

            private List<Task> tasks;

            public static void Generate(List<Task> tasks)
            {
                TaskGenerator generator = new TaskGenerator() { tasks = tasks };

                Settings.Instance.Platforms.ForEach(generator.GenerateTasksForPlatform);
                generator.GenerateTasksForLooseAssets();
                generator.GenerateTasksForCodeFolders();
                generator.GenerateTasksForLegacyCodeFiles();
                generator.GenerateTasksForFolderCleanup();
            }

            private void GenerateTasksForPlatform(Platform platform)
            {
                IEnumerable<Platform.FileInfo> files = platform.GetSourceFileInfo().Cast<Platform.FileInfo>();

                foreach (BuildTarget buildTarget in platform.GetBuildTargets())
                {
                    files = files.Concat(platform.GetBinaryFileInfo(buildTarget, Platform.BinaryType.All).Cast<Platform.FileInfo>());
                }

                foreach (Platform.FileInfo info in files)
                {
                    string newPath = info.LatestLocation();

                    if (!AssetExists(newPath))
                    {
                        bool foundPath = false;
                        string oldPath = null;

                        foreach (string path in info.OldLocations())
                        {
                            oldPath = path;

                            if (tasks.Any(t => t.source == oldPath))
                            {
                                foundPath = true;
                                break;
                            }

                            if (AssetExists(oldPath))
                            {
                                tasks.Add(Task.Move(oldPath, newPath, platform));

                                foundPath = true;
                                break;
                            }
                        }

                        if (oldPath != null)
                        {
                            string oldFolder = EditorUtils.GetParentFolder(oldPath);
                            string newFolder = EditorUtils.GetParentFolder(newPath);

                            if (newFolder != oldFolder)
                            {
                                AddFolderTasks(oldFolder);
                            }
                        }

                        if (!foundPath && ((info.type & Platform.BinaryType.Optional) == 0)
                            && !tasks.Any(t => t.source == newPath))
                        {
                            tasks.Add(Task.Missing(newPath, platform));
                        }
                    }
                }

                foreach (string path in platform.GetObsoleteAssetPaths())
                {
                    if (AssetExists(path) && !tasks.Any(t => t.source == path))
                    {
                        tasks.Add(Task.RemoveAsset(path, platform));
                    }
                }
            }

           private void AddFolderTasks(string path)
            {
                string baseFolder = BaseFolders.First(f => path.StartsWith(f));

                string currentFolder = path;

                // Find the last folder in the path that exists, without leaving the base folder
                while (currentFolder.StartsWith(baseFolder) && !AssetDatabase.IsValidFolder(currentFolder))
                {
                    currentFolder = EditorUtils.GetParentFolder(currentFolder);
                }

                while (currentFolder.StartsWith(baseFolder) && currentFolder != baseFolder)
                {
                    AddFolderTask(currentFolder);
                    currentFolder = EditorUtils.GetParentFolder(currentFolder);
                }
            }

            private void AddFolderTask(string path)
            {
                if (!tasks.Any(t => t.type == Task.Type.RemoveFolder && t.source == path))
                {
                    tasks.Add(Task.RemoveFolder(path));
                }
            }

            private struct MoveRecord
            {
                public string source;
                public string destination;
            }

            private static readonly MoveRecord[] codeFolders = {
                // Release 2.0 layout
                new MoveRecord() { source = FMODSource + "/Runtime", destination = "src" },
                new MoveRecord() { source = FMODSource + "/Runtime/Timeline", destination = "src" },
                new MoveRecord() { source = FMODSource + "/Runtime/wrapper", destination = "src" },
                new MoveRecord() { source = FMODSource + "/Editor/Timeline", destination = "src/Editor" },

                // Release 1.10 layout
                new MoveRecord() { source = FMODRoot + "/Timeline", destination = "src" },
                new MoveRecord() { source = FMODRoot + "/Wrapper", destination = "src" },
                new MoveRecord() { source = "Assets/Plugins/Editor/FMOD", destination = "src/Editor" },
                new MoveRecord() { source = "Assets/Plugins/Editor/FMOD/Timeline", destination = "src/Editor" },
            };

            private void AddMoveTask(string source, string destination)
            {
                if (!tasks.Any(t => t.source == source))
                {
                    tasks.Add(Task.Move(source, destination, null));
                }
            }

            private void GenerateTasksForCodeFolders()
            {
                foreach (MoveRecord folder in codeFolders)
                {
                    if (AssetDatabase.IsValidFolder(folder.source))
                    {
                        foreach (string sourcePath in FindFileAssets(folder.source))
                        {
                            string filename = Path.GetFileName(sourcePath);

                            AddMoveTask(
                                sourcePath, $"{RuntimeUtils.PluginBasePath}/{folder.destination}/{filename}");

                        }

                        AddFolderTask(folder.source);
                    }
                }
            }

            private void GenerateTasksForLooseAssets()
            {
                foreach (MoveRecord asset in looseAssets)
                {
                    string filename = Path.GetFileName(asset.source);
                    string destinationPath = $"{RuntimeUtils.PluginBasePath}/{asset.destination}/{filename}";

                    if (AssetExists(asset.source) && !AssetExists(destinationPath))
                    {
                        AddMoveTask(asset.source, destinationPath);
                        AddFolderTasks(EditorUtils.GetParentFolder(asset.source));
                    }
                    else if (AssetDatabase.IsValidFolder(asset.source) && AssetDatabase.IsValidFolder(destinationPath))
                    {
                        GenerateFolderMergeTasks(asset.source, destinationPath);
                        AddFolderTasks(asset.source);
                    }
                }
            }

            private void GenerateFolderMergeTasks(string sourceFolder, string destinationFolder)
            {
                IEnumerable<string> assetPaths = AssetDatabase.FindAssets(string.Empty, new string[] { sourceFolder })
                    .Select(g => AssetDatabase.GUIDToAssetPath(g))
                    .Where(p => !AssetDatabase.IsValidFolder(p) || IsFolderEmpty(p));

                foreach (string sourcePath in assetPaths)
                {
                    int prefixLength = sourceFolder.Length;

                    if (!sourceFolder.EndsWith("/"))
                    {
                        ++prefixLength;
                    }

                    string relativePath = sourcePath.Substring(prefixLength);
                    string destinationPath = string.Format("{0}/{1}", destinationFolder, relativePath);

                    if (!AssetExists(destinationPath))
                    {
                        AddMoveTask(sourcePath, destinationPath);
                        AddFolderTasks(EditorUtils.GetParentFolder(sourcePath));
                    }
                    else if (AssetDatabase.IsValidFolder(sourcePath))
                    {
                        AddFolderTasks(sourcePath);
                    }
                }
            }

            private void GenerateTasksForLegacyCodeFiles()
            {
                foreach (string path in FindFileAssets(FMODRoot).Where(p => p.EndsWith(".cs")))
                {
                    string destinationPath = $"{RuntimeUtils.PluginBasePath}/src/{Path.GetFileName(path)}";

                    if (!AssetExists(destinationPath))
                    {
                        AddMoveTask(path, destinationPath);
                    }
                }
            }

            private void GenerateTasksForFolderCleanup()
            {
                foreach (string folder in publicFoldersToCleanUp)
                {
                    if (AssetDatabase.IsValidFolder(folder))
                    {
                        AddFolderTask(folder);
                    }
                }
                foreach (string folder in fmodFoldersToCleanUp)
                {
                    SearchSubFolders(folder);
                }
            }

            private void SearchSubFolders(string folder)
            {
                if (AssetDatabase.IsValidFolder(folder))
                {
                    var subdirs = AssetDatabase.GetSubFolders(folder);
                    foreach (var subfolder in subdirs)
                    {
                        SearchSubFolders(subfolder);
                        AddFolderTask(subfolder);
                    }
                    AddFolderTask(folder);
                }
            }

            private static IEnumerable<string> FindFileAssets(string folder)
            {
                if (AssetDatabase.IsValidFolder(folder))
                {
                    return AssetDatabase.FindAssets(string.Empty, new string[] { folder })
                        .Select(g => AssetDatabase.GUIDToAssetPath(g))
                        .Where(p => (EditorUtils.GetParentFolder(p) == folder) && !AssetDatabase.IsValidFolder(p));
                }
                else
                {
                    return Enumerable.Empty<string>();
                }
            }
        }

        private void StartProcessing()
        {
            if (!IsProcessing())
            {
                EditorApplication.LockReloadAssemblies();

                currentTask = 0;
                processingState = ProcessMoveTasks()
                    .Concat(ProcessRemoveAssetTasks())
                    .Concat(ProcessRemoveFolderTasks())
                    .GetEnumerator();
            }
        }

        private void StopProcessing()
        {
            if (IsProcessing())
            {
                processingState = null;
                UpdateTaskCount();
                SetDefaultStatus();

                EditorApplication.UnlockReloadAssemblies();

                if (taskCount == 0)
                {
                    SetupWizardWindow.SetUpdateTaskComplete(SetupWizardWindow.UpdateTaskType.ReorganizePluginFiles);
                }
            }
        }

        private bool IsProcessing()
        {
            return processingState != null;
        }

        private void ProcessNextTask()
        {
            if (processingState != null)
            {
                if (processingState.MoveNext())
                {
                    statusContent = new GUIContent(processingState.Current);
                    Repaint();
                }
                else
                {
                    StopProcessing();
                }
            }
        }

        private IEnumerable<string> ProcessMoveTasks()
        {
            foreach (Task task in tasks.Where(t => t.type == Task.Type.Move && t.status == Task.Status.Pending))
            {
                EditorUtils.EnsureFolderExists(EditorUtils.GetParentFolder(task.destination));

                currentTask = task.step;

                yield return string.Format(L10n.Tr("Moving {0} to {1}"), task.source, task.destination);

                string result = AssetDatabase.MoveAsset(task.source, task.destination);

                if (string.IsNullOrEmpty(result))
                {
                    task.SetSucceeded(string.Format(L10n.Tr("{0} was moved to\n{1}"), task.source, task.destination));
                }
                else
                {
                    task.SetFailed(string.Format(L10n.Tr("{0} could not be moved to\n{1}: '{2}'"),
                        task.source, task.destination, result));
                }

                yield return task.statusText;
            }
        }

        private static bool AssetExists(string path)
        {
            return EditorUtils.AssetExists(path);
        }

        private IEnumerable<string> ProcessRemoveAssetTasks()
        {
            foreach (Task task in tasks.Where(t => t.type == Task.Type.RemoveAsset && t.status == Task.Status.Pending))
            {
                currentTask = task.step;

                if (AssetDatabase.MoveAssetToTrash(task.source))
                {
                    task.SetSucceeded(string.Format(L10n.Tr("{0} was removed"), task.source));
                }
                else
                {
                    task.SetFailed(string.Format(L10n.Tr("{0} could not be removed"), task.source));
                }

                yield return task.statusText;
            }
        }

        private static bool IsFolderEmpty(string path)
        {
            return AssetDatabase.FindAssets(string.Empty, new string[] { path }).Length == 0;
        }

        private IEnumerable<string> ProcessRemoveFolderTasks()
        {
            foreach (Task task in tasks.Where(t => t.type == Task.Type.RemoveFolder && t.status == Task.Status.Pending))
            {
                currentTask = task.step;

                foreach (string result in RemoveFolderIfEmpty(task))
                {
                    yield return result;
                }
            }
        }

        private static IEnumerable<string> RemoveFolderIfEmpty(Task task)
        {
            if (!Directory.Exists(Application.dataPath + "/../" + task.source))
            {
                task.SetSucceeded(string.Format(L10n.Tr("{0} has already been removed"), task.source));
                yield break;
            }

            if (!AssetDatabase.IsValidFolder(task.source))
            {
                task.SetFailed(string.Format(L10n.Tr("{0} is not a valid folder"), task.source));
                yield break;
            }

            if (!IsFolderEmpty(task.source))
            {
                task.SetFailed(string.Format(L10n.Tr("{0} is not empty"), task.source));
                yield break;
            }

            yield return string.Format(L10n.Tr("Removing empty folder {0}"), task.source);

            if (AssetDatabase.MoveAssetToTrash(task.source))
            {
                task.SetSucceeded(string.Format(L10n.Tr("{0} was removed"), task.source));
            }
            else
            {
                task.SetFailed(string.Format(L10n.Tr("{0} could not be removed"), task.source));
            }

            yield return task.statusText;
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FileReorganizer.cs.meta
================================================
fileFormatVersion: 2
guid: 3349615af02d64e4e8d1026e228c4a25
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FindAndReplace.cs
================================================
﻿using System;
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace FMODUnity
{
    public class FindAndReplace : EditorWindow
    {
#if !FMOD_SERIALIZE_GUID_ONLY
        private bool levelScope = true;
        private bool prefabScope;
        private string findText;
        private string replaceText;
        private string message = "";
        private MessageType messageType = MessageType.None;
        private int lastMatch = -1;
        private List<StudioEventEmitter> emitters;

        private bool first = true;

        [MenuItem("FMOD/Find and Replace", priority = 2)]
        private static void ShowFindAndReplace()
        {
            var window = CreateInstance<FindAndReplace>();
            window.titleContent = new GUIContent(L10n.Tr("FMOD Find and Replace"));
            window.OnHierarchyChange();
            var position = window.position;
            window.maxSize = window.minSize = position.size = new Vector2(400, 170);
            window.position = position;
            window.ShowUtility();
        }

        private void OnHierarchyChange()
        {
            emitters = new List<StudioEventEmitter>(Resources.FindObjectsOfTypeAll<StudioEventEmitter>());

            if (!levelScope)
            {
                emitters.RemoveAll(x => PrefabUtility.GetPrefabAssetType(x) == PrefabAssetType.NotAPrefab);
            }

            if (!prefabScope)
            {
                emitters.RemoveAll(x => PrefabUtility.GetPrefabAssetType(x) != PrefabAssetType.NotAPrefab);
            }
        }

        private void OnGUI()
        {
            bool doFind = false;
            if ((Event.current.type == EventType.KeyDown && Event.current.keyCode == KeyCode.Return))
            {
                Event.current.Use();
                doFind = true;
            }

            GUI.SetNextControlName(L10n.Tr("find"));
            EditorGUILayout.PrefixLabel(L10n.Tr("Find:"));
            EditorGUI.BeginChangeCheck();
            findText = EditorGUILayout.TextField(findText);
            if (EditorGUI.EndChangeCheck())
            {
                lastMatch = -1;
                message = null;
            }
            EditorGUILayout.PrefixLabel(L10n.Tr("Replace:"));
            replaceText = EditorGUILayout.TextField(replaceText);

            EditorGUILayout.BeginHorizontal();
            EditorGUI.BeginChangeCheck();
            levelScope = EditorGUILayout.ToggleLeft(L10n.Tr("Current Level"), levelScope, GUILayout.ExpandWidth(false));
            prefabScope = EditorGUILayout.ToggleLeft(L10n.Tr("Prefabs"), prefabScope, GUILayout.ExpandWidth(false));
            if (EditorGUI.EndChangeCheck())
            {
                OnHierarchyChange();
            }
            EditorGUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            if (GUILayout.Button(L10n.Tr("Find")) || doFind)
            {
                message = "";
                {
                    FindNext();
                }
                if (lastMatch == -1)
                {
                    message = L10n.Tr("Finished Search");
                    messageType = MessageType.Warning;
                }
            }
            if (GUILayout.Button(L10n.Tr("Replace")))
            {
                message = "";
                if (lastMatch == -1)
                {
                    FindNext();
                }
                else
                {
                    Replace();
                }
                if (lastMatch == -1)
                {
                    message = L10n.Tr("Finished Search");
                    messageType = MessageType.Warning;
                }
            }
            if (GUILayout.Button(L10n.Tr("Replace All")))
            {
                if (EditorUtility.DisplayDialog(L10n.Tr("Replace All"), L10n.Tr("Are you sure you wish to replace all in the current hierachy?"), L10n.Tr("yes"), L10n.Tr("no")))
                {
                    ReplaceAll();
                }
            }
            GUILayout.EndHorizontal();
            if (!string.IsNullOrEmpty(message))
            {
                EditorGUILayout.HelpBox(message, messageType);
            }
            else
            {
                EditorGUILayout.HelpBox("\n\n", MessageType.None);
            }

            if (first)
            {
                first = false;
                EditorGUI.FocusTextInControl(L10n.Tr("find"));
            }
        }

        private void FindNext()
        {
            for (int i = lastMatch + 1; i < emitters.Count; i++)
            {
                if (emitters[i].EventReference.Path.IndexOf(findText, 0, StringComparison.CurrentCultureIgnoreCase) >= 0)
                {
                    lastMatch = i;
                    EditorGUIUtility.PingObject(emitters[i]);
                    Selection.activeGameObject = emitters[i].gameObject;
                    message = L10n.Tr("Found object");
                    messageType = MessageType.Info;
                    return;
                }
            }
            lastMatch = -1;
        }

        private void ReplaceAll()
        {
            int replaced = 0;
            for (int i = 0; i < emitters.Count; i++)
            {
                if (ReplaceText(emitters[i]))
                {
                    replaced++;
                }
            }

            message = string.Format(L10n.Tr("{0} replaced"), replaced);
            messageType = MessageType.Info;
        }

        private bool ReplaceText(StudioEventEmitter emitter)
        {
            int findLength = findText.Length;
            int replaceLength = replaceText.Length;
            int position = 0;
            var serializedObject = new SerializedObject(emitter);
            var eventReferenceProperty = serializedObject.FindProperty("EventReference");
            var pathProperty = eventReferenceProperty.FindPropertyRelative("Path");
            string path = pathProperty.stringValue;
            position = path.IndexOf(findText, position, StringComparison.CurrentCultureIgnoreCase);
            while (position >= 0)
            {
                path = path.Remove(position, findLength).Insert(position, replaceText);
                position += replaceLength;
                position = path.IndexOf(findText, position, StringComparison.CurrentCultureIgnoreCase);
            }
            EventReference newEventReference = EventReference.Find(path);
            eventReferenceProperty.SetEventReference(newEventReference.Guid, newEventReference.Path);
            return serializedObject.ApplyModifiedProperties();
        }

        private void Replace()
        {
            ReplaceText(emitters[lastMatch]);
            FindNext();
        }
#endif
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FindAndReplace.cs.meta
================================================
fileFormatVersion: 2
guid: a3d0ed60438564241a4e62b152836893
timeCreated: 1453876443
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODEventPlayableEditor.cs
================================================
﻿#if UNITY_TIMELINE_EXIST

using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Timeline;
using UnityEngine;
using UnityEngine.Timeline;
using System;
using System.Linq;
using System.Reflection;

namespace FMODUnity
{
    [CustomEditor(typeof(FMODEventPlayable))]
    public class FMODEventPlayableEditor : Editor
    {
        private FMODEventPlayable eventPlayable;
        private EditorEventRef editorEventRef;
        private List<EditorParamRef> missingInitialParameterValues = new List<EditorParamRef>();
        private List<EditorParamRef> missingParameterAutomations = new List<EditorParamRef>();

        private SerializedProperty parametersProperty;
        private SerializedProperty parameterLinksProperty;
        private SerializedProperty parameterAutomationProperty;

        private ListView parameterLinksView;
        private ListView initialParameterValuesView;

        private string eventPath;

        public void OnEnable()
        {
            eventPlayable = target as FMODEventPlayable;

            parametersProperty = serializedObject.FindProperty("Parameters");
            parameterLinksProperty = serializedObject.FindProperty("Template.ParameterLinks");
            parameterAutomationProperty = serializedObject.FindProperty("Template.ParameterAutomation");

            parameterLinksView = new ListView(parameterLinksProperty);
            parameterLinksView.drawElementWithLabelCallback = DrawParameterLink;
            parameterLinksView.onCanAddCallback = (list) => missingParameterAutomations.Count > 0;
            parameterLinksView.onAddDropdownCallback = DoAddParameterLinkMenu;
            parameterLinksView.onRemoveCallback = (list) => DeleteParameterAutomation(list.index);

            initialParameterValuesView = new ListView(parametersProperty);
            initialParameterValuesView.drawElementWithLabelCallback = DrawInitialParameterValue;
            initialParameterValuesView.onCanAddCallback = (list) => missingInitialParameterValues.Count > 0;
            initialParameterValuesView.onAddDropdownCallback = DoAddInitialParameterValueMenu;
            initialParameterValuesView.onRemoveCallback = (list) => DeleteInitialParameterValue(list.index);

            RefreshEventRef();

            Undo.undoRedoPerformed += OnUndoRedo;
        }

        public void OnDestroy()
        {
            Undo.undoRedoPerformed -= OnUndoRedo;
        }

        private void OnUndoRedo()
        {
            RefreshMissingParameterLists();

            // This is in case the undo/redo modified any curves on the Playable's clip
            RefreshTimelineEditor();
        }

        private void RefreshEventRef()
        {
            string path;
#if FMOD_SERIALIZE_GUID_ONLY
            path = EditorUtils.PathFromGUID(eventPlayable.EventReference.Guid);
#else
            path = eventPlayable.EventReference.Path;
#endif
            if (eventPath != path)
            {
                eventPath = path;
                if (!string.IsNullOrEmpty(eventPath))
                {
                    editorEventRef = EventManager.EventFromPath(eventPath);
                }
                else
                {
                    editorEventRef = null;
                }

                if (editorEventRef != null)
                {
                    eventPlayable.UpdateEventDuration(
                        editorEventRef.IsOneShot ? editorEventRef.Length : float.PositiveInfinity);
                }

                ValidateParameterSettings();
                RefreshMissingParameterLists();
            }
        }

        private void ValidateParameterSettings()
        {
            if (editorEventRef != null)
            {
                List<string> namesToDelete = new List<string>();

                for (int i = 0; i < parametersProperty.arraySize; ++i)
                {
                    SerializedProperty current = parametersProperty.GetArrayElementAtIndex(i);
                    SerializedProperty name = current.FindPropertyRelative("Name");

                    EditorParamRef paramRef = editorEventRef.LocalParameters.FirstOrDefault(p => p.Name == name.stringValue);

                    if (paramRef != null)
                    {
                        SerializedProperty value = current.FindPropertyRelative("Value");
                        value.floatValue = Mathf.Clamp(value.floatValue, paramRef.Min, paramRef.Max);
                    }
                    else
                    {
                        namesToDelete.Add(name.stringValue);
                    }
                }

                foreach(string name in namesToDelete)
                {
                    DeleteInitialParameterValue(name);
                }

                namesToDelete.Clear();

                for (int i = 0; i < parameterLinksProperty.arraySize; ++i)
                {
                    SerializedProperty current = parameterLinksProperty.GetArrayElementAtIndex(i);
                    SerializedProperty name = current.FindPropertyRelative("Name");

                    if (!editorEventRef.LocalParameters.Any(p => p.Name == name.stringValue))
                    {
                        namesToDelete.Add(name.stringValue);
                    }
                }

                foreach(string name in namesToDelete)
                {
                    DeleteParameterAutomation(name);
                }
            }
        }

        private void RefreshMissingParameterLists()
        {
            if (editorEventRef != null)
            {
                serializedObject.Update();

                missingInitialParameterValues =
                    editorEventRef.LocalParameters.Where(p => !InitialParameterValueExists(p.Name)).ToList();
                missingParameterAutomations =
                    editorEventRef.LocalParameters.Where(p => !ParameterLinkExists(p.Name)).ToList();
            }
            else
            {
                missingInitialParameterValues.Clear();
                missingParameterAutomations.Clear();
            }
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            RefreshEventRef();

            var eventReference = serializedObject.FindProperty("EventReference");
            var stopType = serializedObject.FindProperty("StopType");

            const string EventReferenceLabel = "Event";

            EditorUtils.DrawLegacyEvent(serializedObject.FindProperty("eventName"), EventReferenceLabel);

            EditorGUILayout.PropertyField(eventReference, new GUIContent(EventReferenceLabel));
            EditorGUILayout.PropertyField(stopType, new GUIContent("Stop Mode"));

            DrawInitialParameterValues();
            DrawParameterAutomations();

            eventPlayable.OnValidate();

            serializedObject.ApplyModifiedProperties();
        }

        private void DrawInitialParameterValues()
        {
            if (editorEventRef != null)
            {
                parametersProperty.isExpanded =
                    EditorGUILayout.Foldout(parametersProperty.isExpanded, "Initial Parameter Values", true);

                if (parametersProperty.isExpanded)
                {
                    initialParameterValuesView.DrawLayout();
                }
            }
        }

        private void DoAddInitialParameterValueMenu(Rect rect, UnityEditorInternal.ReorderableList list)
        {
            GenericMenu menu = new GenericMenu();
            menu.AddItem(new GUIContent("All"), false, () =>
                {
                    foreach (EditorParamRef parameter in missingInitialParameterValues)
                    {
                        AddInitialParameterValue(parameter);
                    }
                });

            menu.AddSeparator(string.Empty);

            foreach (EditorParamRef parameter in missingInitialParameterValues)
            {
                string text = parameter.Name;

                if (ParameterLinkExists(parameter.Name))
                {
                    text += " (automated)";
                }

                menu.AddItem(new GUIContent(text), false,
                    (userData) =>
                    {
                        AddInitialParameterValue(userData as EditorParamRef);
                    },
                    parameter);
            }

            menu.DropDown(rect);
        }

        private void DrawInitialParameterValue(Rect rect, float labelRight, int index, bool active, bool focused)
        {
            if (editorEventRef == null)
            {
                return;
            }

            SerializedProperty property = parametersProperty.GetArrayElementAtIndex(index);

            string name = property.FindPropertyRelative("Name").stringValue;

            EditorParamRef paramRef = editorEventRef.LocalParameters.FirstOrDefault(p => p.Name == name);

            if (paramRef == null)
            {
                return;
            }

            Rect nameLabelRect = rect;
            nameLabelRect.xMax = labelRight;

            Rect sliderRect = rect;
            sliderRect.xMin = nameLabelRect.xMax;

            SerializedProperty valueProperty = property.FindPropertyRelative("Value");

            GUI.Label(nameLabelRect, name);

            using (new NoIndentScope())
            {
                valueProperty.floatValue =
                    EditorGUI.Slider(sliderRect, valueProperty.floatValue, paramRef.Min, paramRef.Max);
            }
        }

        private void DrawParameterAutomations()
        {
            if (editorEventRef != null)
            {
                parameterLinksProperty.isExpanded =
                    EditorGUILayout.Foldout(parameterLinksProperty.isExpanded, "Parameter Automations", true);

                if (parameterLinksProperty.isExpanded)
                {
                    parameterLinksView.DrawLayout();
                }
            }
        }

        private void DoAddParameterLinkMenu(Rect rect, UnityEditorInternal.ReorderableList list)
        {
            GenericMenu menu = new GenericMenu();
            menu.AddItem(new GUIContent("All"), false, () =>
                {
                    foreach (EditorParamRef parameter in missingParameterAutomations)
                    {
                        AddParameterAutomation(parameter.Name);
                    }
                });

            menu.AddSeparator(string.Empty);

            foreach (EditorParamRef parameter in missingParameterAutomations)
            {
                string text = parameter.Name;

                if (InitialParameterValueExists(parameter.Name))
                {
                    text += " (has initial value)";
                }

                menu.AddItem(new GUIContent(text), false,
                    (userData) =>
                    {
                        AddParameterAutomation(userData as string);
                    },
                    parameter.Name);
            }

            menu.DropDown(rect);
        }

        private void DrawParameterLink(Rect rect, float labelRight, int index, bool active, bool focused)
        {
            if (editorEventRef == null)
            {
                return;
            }

            SerializedProperty linkProperty = parameterLinksProperty.GetArrayElementAtIndex(index);

            string name = linkProperty.FindPropertyRelative("Name").stringValue;

            EditorParamRef paramRef = editorEventRef.LocalParameters.FirstOrDefault(p => p.Name == name);

            if (paramRef == null)
            {
                return;
            }

            int slot = linkProperty.FindPropertyRelative("Slot").intValue;

            string slotName = string.Format("Slot{0:D2}", slot);
            SerializedProperty valueProperty = parameterAutomationProperty.FindPropertyRelative(slotName);

            GUIStyle slotStyle = GUI.skin.label;

            Rect slotRect = rect;
            slotRect.width = slotStyle.CalcSize(new GUIContent("slot 00:")).x;

            Rect nameRect = rect;
            nameRect.xMin = slotRect.xMax;
            nameRect.xMax = labelRight;

            Rect valueRect = rect;
            valueRect.xMin = nameRect.xMax;

            using (new EditorGUI.PropertyScope(rect, GUIContent.none, valueProperty))
            {
                GUI.Label(slotRect, string.Format("slot {0:D2}:", slot), slotStyle);
                GUI.Label(nameRect, name);

                using (new NoIndentScope())
                {
                    valueProperty.floatValue =
                        EditorGUI.Slider(valueRect, valueProperty.floatValue, paramRef.Min, paramRef.Max);
                }
            }
        }

        private bool InitialParameterValueExists(string name)
        {
            return parametersProperty.ArrayContains("Name", p => p.stringValue == name);
        }

        private bool ParameterLinkExists(string name)
        {
            return parameterLinksProperty.ArrayContains("Name", p => p.stringValue == name);
        }

        private void AddInitialParameterValue(EditorParamRef editorParamRef)
        {
            serializedObject.Update();

            if (!InitialParameterValueExists(editorParamRef.Name))
            {
                DeleteParameterAutomation(editorParamRef.Name);

                parametersProperty.ArrayAdd(p => {
                    p.FindPropertyRelative("Name").stringValue = editorParamRef.Name;
                    p.FindPropertyRelative("Value").floatValue = editorParamRef.Default;
                });

                serializedObject.ApplyModifiedProperties();

                RefreshMissingParameterLists();
            }
        }

        private void DeleteInitialParameterValue(string name)
        {
            serializedObject.Update();

            int index = parametersProperty.FindArrayIndex("Name", p => p.stringValue == name);

            if (index >= 0)
            {
                DeleteInitialParameterValue(index);
            }
        }

        private void DeleteInitialParameterValue(int index)
        {
            serializedObject.Update();

            parametersProperty.DeleteArrayElementAtIndex(index);

            serializedObject.ApplyModifiedProperties();
            RefreshMissingParameterLists();
        }

        private void AddParameterAutomation(string name)
        {
            serializedObject.Update();

            if (!ParameterLinkExists(name))
            {
                int slot = -1;

                for (int i = 0; i < AutomatableSlots.Count; ++i)
                {
                    if (!parameterLinksProperty.ArrayContains("Slot", p => p.intValue == i))
                    {
                        slot = i;
                        break;
                    }
                }

                if (slot >= 0)
                {
                    DeleteInitialParameterValue(name);

                    parameterLinksProperty.ArrayAdd(p => {
                        p.FindPropertyRelative("Name").stringValue = name;
                        p.FindPropertyRelative("Slot").intValue = slot;
                    });

                    serializedObject.ApplyModifiedProperties();

                    RefreshMissingParameterLists();
                    RefreshTimelineEditor();
                }
            }
        }

        private void DeleteParameterAutomation(string name)
        {
            serializedObject.Update();

            int index = parameterLinksProperty.FindArrayIndex("Name", p => p.stringValue == name);

            if (index >= 0)
            {
                DeleteParameterAutomation(index);
            }
        }

        private void DeleteParameterAutomation(int index)
        {
            serializedObject.Update();

            if (eventPlayable.OwningClip.hasCurves)
            {
                SerializedProperty linkProperty = parameterLinksProperty.GetArrayElementAtIndex(index);
                SerializedProperty slotProperty = linkProperty.FindPropertyRelative("Slot");

                AnimationClip curvesClip = eventPlayable.OwningClip.curves;

                Undo.RecordObject(curvesClip, string.Empty);
                AnimationUtility.SetEditorCurve(curvesClip, GetParameterCurveBinding(slotProperty.intValue), null);
            }

            parameterLinksProperty.DeleteArrayElementAtIndex(index);

            serializedObject.ApplyModifiedProperties();

            RefreshMissingParameterLists();

            RefreshTimelineEditor();
        }

        private static EditorCurveBinding GetParameterCurveBinding(int index)
        {
            EditorCurveBinding result = new EditorCurveBinding() {
                path = string.Empty,
                type = typeof(FMODEventPlayable),
                propertyName = string.Format("parameterAutomation.slot{0:D2}", index),
            };

            return result;
        }

        private static void RefreshTimelineEditor()
        {
            TimelineEditor.Refresh(RefreshReason.ContentsAddedOrRemoved);
        }
    }
}
#endif



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODEventPlayableEditor.cs.meta
================================================
fileFormatVersion: 2
guid: fa325be8441506c4bb1462c8333ccce9
timeCreated: 1523230773
licenseType: Free
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODEventTrackEditor.cs
================================================
﻿#if UNITY_TIMELINE_EXIST

using UnityEditor;
using UnityEditor.Timeline;
using UnityEngine;
using UnityEngine.Timeline;

namespace FMODUnity
{
    [CustomTimelineEditor(typeof(FMODEventTrack))]
    public class FMODEventTrackEditor : TrackEditor
    {
        private static readonly Texture2D icon = EditorUtils.LoadImage("StudioIcon.png");

        public override TrackDrawOptions GetTrackOptions(TrackAsset track, Object binding)
        {
            TrackDrawOptions options = base.GetTrackOptions(track, binding);
            options.icon = icon;

            return options;
        }
    }

    // This custom property drawer is here to draw the volume property at the
    // top level of the inspector, rather than in a Template foldout.
    [CustomPropertyDrawer(typeof(FMODEventMixerBehaviour))]
    public class FMODEventMixerBehaviourInspector : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            SerializedProperty volumeProperty = property.FindPropertyRelative("volume");

            EditorGUI.PropertyField(position, volumeProperty);
        }
    }
}

#endif



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODEventTrackEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 31e1c5e7d70e58f45ae86764f7c3ec2f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODUnityEditor.asmdef
================================================
{
    "name": "FMODUnityEditor",
    "references": [
        "FMODUnity",
        "Unity.Timeline.Editor",
        "Unity.Timeline",
        "Unity.VisualScripting.Core",
        "Unity.VisualScripting.Core.Editor",
        "Unity.VisualScripting.Flow.Editor",
        "Unity.ScriptableBuildPipeline.Editor",
        "Unity.InputSystem"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [
        "UNITY_2021_3_OR_NEWER"
    ],
    "versionDefines": [
        {
            "name": "com.unity.timeline",
            "expression": "1.0.0",
            "define": "UNITY_TIMELINE_EXIST"
        },
        {
            "name": "com.unity.addressables",
            "expression": "1.0.0",
            "define": "UNITY_ADDRESSABLES_EXIST"
        },
        {
            "name": "com.unity.visualscripting",
            "expression": "1.0.0",
            "define": "UNITY_VISUALSCRIPTING_EXIST"
        },
        {
            "name": "com.unity.inputsystem",
            "expression": "1.0.0",
            "define": "UNITY_INPUTSYSTEM_EXIST"
        }
    ],
    "noEngineReferences": false
}


================================================
FILE: Assets/Plugins/FMOD/src/Editor/FMODUnityEditor.asmdef.meta
================================================
fileFormatVersion: 2
guid: aab3caaf43456d6449a3e035348ff798
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/ListView.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    public class ListView : UnityEditorInternal.ReorderableList
    {
        private const float ElementPadding = 2;

        public DrawElementWithLabelDelegate drawElementWithLabelCallback;

        public delegate void DrawElementWithLabelDelegate(Rect rect, float labelRight, int index,
            bool active, bool focused);

        private float labelRight;

        public ListView(SerializedProperty property)
            : base(property.serializedObject, property, true, false, true, true)
        {
            headerHeight = 3;
            elementHeight = EditorGUIUtility.singleLineHeight + ElementPadding;
            drawElementCallback = DrawElementWrapper;
        }

        public void DrawLayout()
        {
            Rect rect = EditorGUILayout.GetControlRect(false, GetHeight());

            labelRight = rect.x + EditorGUIUtility.labelWidth;

            DoList(EditorGUI.IndentedRect(rect));
        }

        private void DrawElementWrapper(Rect rect, int index, bool active, bool focused)
        {
            if (drawElementWithLabelCallback != null)
            {
                rect.height -= ElementPadding;

                drawElementWithLabelCallback(rect, labelRight, index, active, focused);
            }
        }
    }
}




================================================
FILE: Assets/Plugins/FMOD/src/Editor/ListView.cs.meta
================================================
fileFormatVersion: 2
guid: 1573bef36bd46e34f8f2b4dad628a461
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/Localization.cs
================================================
#if UNITY_2020_2_OR_NEWER
[assembly: UnityEditor.Localization]
#endif


================================================
FILE: Assets/Plugins/FMOD/src/Editor/Localization.cs.meta
================================================
fileFormatVersion: 2
guid: 3090e47fa3df08f469c1d65999e47956
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/ParamRefDrawer.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomPropertyDrawer(typeof(ParamRefAttribute))]
    public class ParamRefDrawer : PropertyDrawer
    {
        public bool MouseDrag(Event e)
        {
            bool isDragging = false;

            if (e.type == EventType.DragPerform)
            {
                isDragging = true;
            }

            return isDragging;
        }

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            Texture browseIcon = EditorUtils.LoadImage("SearchIconBlack.png");
            Texture openIcon = EditorUtils.LoadImage("BrowserIcon.png");
            Texture addIcon = EditorUtils.LoadImage("AddIcon.png");

            EditorGUI.BeginProperty(position, label, property);
            SerializedProperty pathProperty = property;

            Event e = Event.current;
            if (MouseDrag(e) && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorParamRef))
                {
                    pathProperty.stringValue = ((EditorParamRef)DragAndDrop.objectReferences[0]).Name;
                    GUI.changed = true;
                    e.Use();
                }
            }
            if (e.type == EventType.DragUpdated && position.Contains(e.mousePosition))
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorParamRef))
                {
                    DragAndDrop.visualMode = DragAndDropVisualMode.Move;
                    DragAndDrop.AcceptDrag();
                    e.Use();
                }
            }

            float baseHeight = GUI.skin.textField.CalcSize(new GUIContent()).y;

            position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);

            GUIStyle buttonStyle = new GUIStyle(GUI.skin.button);
            buttonStyle.padding.top = 1;
            buttonStyle.padding.bottom = 1;

            Rect addRect = new Rect(position.x + position.width - addIcon.width - 7, position.y, addIcon.width + 7, baseHeight);
            Rect openRect = new Rect(addRect.x - openIcon.width - 7, position.y, openIcon.width + 6, baseHeight);
            Rect searchRect = new Rect(openRect.x - browseIcon.width - 9, position.y, browseIcon.width + 8, baseHeight);
            Rect pathRect = new Rect(position.x, position.y, searchRect.x - position.x - 3, baseHeight);

            EditorGUI.PropertyField(pathRect, pathProperty, GUIContent.none);

            if (GUI.Button(searchRect, new GUIContent(browseIcon, "Search"), buttonStyle))
            {
                var eventBrowser = ScriptableObject.CreateInstance<EventBrowser>();

                eventBrowser.ChooseParameter(property);
                var windowRect = position;
                windowRect.position = GUIUtility.GUIToScreenPoint(windowRect.position);
                windowRect.height = openRect.height + 1;
                eventBrowser.ShowAsDropDown(windowRect, new Vector2(windowRect.width, 400));
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/ParamRefDrawer.cs.meta
================================================
fileFormatVersion: 2
guid: ea88808aa26cd614db1c5c1dcbb14d4e
timeCreated: 1444197074
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/SettingsEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 353a9c870c318f74fa5fdcd475129bae
timeCreated: 1432530253
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/SetupWizard.cs
================================================
﻿using FMOD.Studio;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

#if UNITY_6000_2_OR_NEWER
using TreeView = UnityEditor.IMGUI.Controls.TreeView<int>;
using TreeViewItem = UnityEditor.IMGUI.Controls.TreeViewItem<int>;
using TreeViewState = UnityEditor.IMGUI.Controls.TreeViewState<int>;
#endif

namespace FMODUnity
{
    public class SetupWizardWindow : EditorWindow
    {
        private static SetupWizardWindow instance;

        private static readonly List<string> pageNames = new List<string>
        {
            L10n.Tr("Welcome"),
            L10n.Tr("Updating"),
            L10n.Tr("Linking"),
            L10n.Tr("Listener"),
            L10n.Tr("Unity Audio"),
            L10n.Tr("Unity Sources"),
            L10n.Tr("Source Control"),
            L10n.Tr("End")
        };

        private static readonly List<bool> pageComplete = new List<bool>(new bool[(int)PAGES.Max]);

        private static readonly List<UpdateTask> updateTasks = new List<UpdateTask>() {
            UpdateTask.Create(
                type: UpdateTaskType.ReorganizePluginFiles,
                name: L10n.Tr("Reorganize Plugin Files"),
                description: L10n.Tr("Move FMOD for Unity files to match the latest layout."),
                execute: FileReorganizer.ShowWindow,
                checkComplete: FileReorganizer.IsUpToDate
            ),
            UpdateTask.Create(
                type: UpdateTaskType.UpdateEventReferences,
                name: L10n.Tr("Update Event References"),
                description: L10n.Tr("Find event references that use the obsolete [FMODUnity.EventRef] attribute and update them to use the FMODUnity.EventReference type."),
                execute: EventReferenceUpdater.ShowWindow,
                checkComplete: EventReferenceUpdater.IsUpToDate
            ),
        };

        private static bool updateTaskStatusChecked = false;

        private PAGES currentPage = PAGES.Welcome;

        private AudioListener[] unityListeners;
        private StudioListener[] fmodListeners;
        private Vector2 scroll1, scroll2, pageScrollPos;
        private Vector2 stagingDetailsScroll;
        private bool bFoundUnityListener;
        private bool bFoundFmodListener;

        private AudioSource[] unityAudioSources;

        private GUIStyle titleStyle;
        private GUIStyle titleLeftStyle;
        private GUIStyle bodyStyle;
        private GUIStyle buttonStyle;
        private GUIStyle navButtonStyle;
        private GUIStyle sourceButtonStyle;
        private GUIStyle descriptionStyle;
        private GUIStyle crumbStyle;
        private GUIStyle columnStyle;
        private Color crumbDefault;
        private Color crumbHighlight;

        private const string logoBlack = "FMODLogoBlack.png";
        private const string logoWhite = "FMODLogoWhite.png";

        private Texture2D logoTexture;
        private Texture2D tickTexture;
        private Texture2D crossTexture;
        private GUIStyle iconStyle;

        private SimpleTreeView m_SimpleTreeView;
        private TreeViewState m_TreeViewState;

        private bool bStudioLinked;
        private bool isValidSource = true;
        private string invalidMessage;

        private static StagingSystem.UpdateStep nextStagingStep;

        private static bool IsStagingUpdateInProgress => nextStagingStep != null;

        private Vector2 ignoreFileScrollPosition = Vector2.zero;

        private const string IgnoreFileText =
@"# Never ignore DLLs in the FMOD subfolder.
!/[Aa]ssets/Plugins/FMOD/**/lib/*

# Don't ignore images and gizmos used by FMOD in the Unity Editor.
!/[Aa]ssets/Gizmos/FMOD/*
!/[Aa]ssets/Editor Default Resources/FMOD/*

# Ignore the Cache folder since it is updated locally.
/[Aa]ssets/Plugins/FMOD/Cache/*

# Ignore bank files in the StreamingAssets folder.
/[Aa]ssets/StreamingAssets/**/*.bank
/[Aa]ssets/StreamingAssets/**/*.bank.meta

# If the source bank files are kept outside of the StreamingAssets folder then these can be ignored.
# Log files can be ignored.
fmod_editor.log";

        private const string GitAttributesText =
@"Assets/Plugins/FMOD/**/*.bundle text eol=lf
Assets/Plugins/FMOD/**/Info.plist text eol=lf";

        private enum PAGES : int
        {
            Welcome = 0,
            Updating,
            Linking,
            Listener,
            UnityAudio,
            UnitySources,
            SourceControl,
            End,
            Max
        }

        public enum UpdateTaskType
        {
            ReorganizePluginFiles,
            UpdateEventReferences,
        }

        private class UpdateTask
        {
            public UpdateTaskType Type;
            public string Name;
            public string Description;
            public bool IsComplete;
            public Action Execute;
            public Func<bool> CheckComplete;

            public static UpdateTask Create(UpdateTaskType type, string name, string description,
                Action execute, Func<bool> checkComplete)
            {
                return new UpdateTask() {
                    Type = type,
                    Name = name,
                    Description = description,
                    Execute = execute,
                    CheckComplete = checkComplete
                };
            }
        }

        public static void SetUpdateTaskComplete(UpdateTaskType type)
        {
            foreach (UpdateTask task in updateTasks.Where(t => t.Type == type))
            {
                task.IsComplete = true;
            }
        }

        private static void CheckUpdateTaskStatus()
        {
            if (!updateTaskStatusChecked)
            {
                updateTaskStatusChecked = true;

                foreach (UpdateTask task in updateTasks)
                {
                    task.IsComplete = task.CheckComplete();
                }
            }
        }

        private static void DoNextStagingStep()
        {
            nextStagingStep.Execute();
            nextStagingStep = StagingSystem.GetNextUpdateStep();
        }

        public static void Startup()
        {
            if (EditorApplication.isPlayingOrWillChangePlaymode)
                return;

            Settings settings = Settings.Instance;

            if (settings.CurrentVersion != FMOD.VERSION.number)
            {
                // We're updating an existing installation; unhide the setup wizard if needed

                CheckUpdateTaskStatus();

                if (settings.HideSetupWizard && updateTasks.Any(t => !t.IsComplete))
                {
                    settings.HideSetupWizard = false;
                }

                settings.CurrentVersion = FMOD.VERSION.number;
                EditorUtility.SetDirty(settings);
            }

            nextStagingStep = StagingSystem.Startup();

            if (!settings.HideSetupWizard || IsStagingUpdateInProgress)
            {
                ShowAssistant();
            }
        }

        [MenuItem("FMOD/Setup Wizard")]
        public static void ShowAssistant()
        {
            instance = (SetupWizardWindow)GetWindow(typeof(SetupWizardWindow), true, L10n.Tr("FMOD Setup Wizard"));
            instance.ShowUtility();
            instance.minSize = new Vector2(600, 400);
            var position = new Rect(Vector2.zero, new Vector2(800, 600));
            Vector2 screenCenter = new Vector2(Screen.currentResolution.width, Screen.currentResolution.height) / 2;
            position.center = screenCenter / EditorGUIUtility.pixelsPerPoint;
            instance.position = position;
        }

        private void OnEnable()
        {
            CheckUpdateTaskStatus();

            logoTexture = EditorUtils.LoadImage(EditorGUIUtility.isProSkin ? logoWhite : logoBlack);

            crossTexture = EditorUtils.LoadImage("CrossYellow.png");
            tickTexture = EditorUtils.LoadImage("TickGreen.png");

            titleStyle = new GUIStyle();
            titleStyle.normal.textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black;
            titleStyle.wordWrap = true;
            titleStyle.fontStyle = FontStyle.Bold;
            titleStyle.alignment = TextAnchor.MiddleCenter;

            bodyStyle = new GUIStyle(titleStyle);
            crumbStyle = new GUIStyle(titleStyle);
            crumbDefault = EditorGUIUtility.isProSkin ? Color.gray : Color.gray;
            crumbHighlight = EditorGUIUtility.isProSkin ? Color.white : Color.black;

            scroll1 = scroll2 = new Vector2();

            iconStyle = new GUIStyle();
            iconStyle.alignment = TextAnchor.MiddleCenter;

            EditorUtils.ValidateSource(out isValidSource, out invalidMessage);

            CheckUpdatesComplete();
            CheckStudioLinked();
            CheckListeners();
            CheckSources();
            CheckUnityAudio();
        }

        private void OnGUI()
        {
            if (buttonStyle == null)
            {
                buttonStyle = new GUIStyle("Button");
                buttonStyle.fixedHeight = 30;

                sourceButtonStyle = new GUIStyle("button");
                sourceButtonStyle.fixedWidth = 150;
                sourceButtonStyle.fixedHeight = 35;
                sourceButtonStyle.margin = new RectOffset();

                descriptionStyle = new GUIStyle(titleStyle);
                descriptionStyle.fontStyle = FontStyle.Normal;
                descriptionStyle.alignment = TextAnchor.MiddleLeft;
                descriptionStyle.margin = new RectOffset(5,0,0,0);

                titleLeftStyle = new GUIStyle(descriptionStyle);
                titleLeftStyle.fontStyle = FontStyle.Bold;

                descriptionStyle.fixedWidth = 350;
                columnStyle = new GUIStyle();
                columnStyle.margin.left = 50;
                columnStyle.margin.right = 50;
            }

            // Draw Header
            EditorGUILayout.Space();
            GUILayout.Box(logoTexture, titleStyle);
            EditorGUILayout.Space();

            if (IsStagingUpdateInProgress)
            {
                StagingUpdatePage();
                return;
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                Breadcrumbs();

                // Draw Body
                using (new EditorGUILayout.VerticalScope("box", GUILayout.ExpandHeight(true), GUILayout.ExpandWidth(true)))
                {
                    using (var scrollView = new EditorGUILayout.ScrollViewScope(pageScrollPos))
                    {
                        pageScrollPos = scrollView.scrollPosition;

                        EditorGUILayout.Space();
                        EditorGUILayout.Space();
                        EditorGUILayout.Space();

                        switch (currentPage)
                        {
                            case PAGES.Welcome: WelcomePage(); break;
                            case PAGES.Updating: UpdatingPage(); break;
                            case PAGES.Linking: LinkingPage(); break;
                            case PAGES.Listener: ListenerPage(); break;
                            case PAGES.UnityAudio: DisableUnityAudioPage(); break;
                            case PAGES.UnitySources: UnitySources(); break;
                            case PAGES.SourceControl: SourceControl(); break;
                            case PAGES.End: EndPage(); break;
                        }
                    }

                    Buttons();

                    if (currentPage == PAGES.Welcome)
                    {
                        EditorGUILayout.Space();
                        EditorGUILayout.Space();
                        using (new EditorGUILayout.HorizontalScope())
                        {
                            GUILayout.FlexibleSpace();

                            using (var check = new EditorGUI.ChangeCheckScope())
                            {
                                bool hide = Settings.Instance.HideSetupWizard;

                                hide = EditorGUILayout.Toggle(L10n.Tr("Do not display this again"), hide);

                                if (check.changed)
                                {
                                    Settings.Instance.HideSetupWizard = hide;
                                    EditorUtility.SetDirty(Settings.Instance);
                                }
                            }
                            GUILayout.FlexibleSpace();
                        }
                    }
                    else
                    {
                        EditorGUILayout.Space();
                        EditorGUILayout.Space();
                    }
                    EditorGUILayout.Space();
                    EditorGUILayout.Space();
                }
            }
        }

        private void OnInspectorUpdate()
        {
            switch (currentPage)
            {
                case PAGES.Welcome:                         break;
                case PAGES.Updating: CheckUpdatesComplete();break;
                case PAGES.Linking:     CheckStudioLinked();break;
                case PAGES.Listener:    CheckListeners();   break;
                case PAGES.UnityAudio:                      break;
                case PAGES.UnitySources:CheckSources();     break;
                case PAGES.SourceControl:                   break;
                case PAGES.End:                             break;
                case PAGES.Max:                             break;
                default:                                    break;
            }
        }

        private void CheckUpdatesComplete()
        {
            pageComplete[(int)PAGES.Updating] = updateTasks.All(t => t.IsComplete);
        }

        private void CheckStudioLinked()
        {
            pageComplete[(int)PAGES.Linking] = isValidSource;
        }

        private bool IsStudioLinked()
        {
            return !string.IsNullOrEmpty(Settings.Instance.SourceBankPath);
        }

        private void CheckListeners()
        {
            var UListeners = Resources.FindObjectsOfTypeAll<AudioListener>();
            var FListeners = Resources.FindObjectsOfTypeAll<StudioListener>();
            if ((unityListeners == null || fmodListeners == null) || (!unityListeners.SequenceEqual(UListeners) || !fmodListeners.SequenceEqual(FListeners)))
            {
                unityListeners = UListeners;
                bFoundUnityListener = unityListeners.Length > 0;
                fmodListeners = FListeners;
                bFoundFmodListener = fmodListeners.Length > 0;
                Repaint();
            }
            pageComplete[(int)PAGES.Listener] = (!bFoundUnityListener && bFoundFmodListener);
        }

        private void CheckSources()
        {
            var ASources = Resources.FindObjectsOfTypeAll<AudioSource>();
            if (unityAudioSources == null || !ASources.SequenceEqual(unityAudioSources))
            {
                unityAudioSources = ASources;
                if (m_SimpleTreeView != null && unityAudioSources.Length > 0)
                {
                    m_SimpleTreeView.Reload();
                }
            }
            pageComplete[(int)PAGES.UnitySources] = ASources != null ? (ASources.Length == 0) : true;
        }

        private void CheckUnityAudio()
        {
            var audioManager = AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/AudioManager.asset")[0];
            var serializedManager = new SerializedObject(audioManager);
            var prop = serializedManager.FindProperty("m_DisableAudio");
            pageComplete[(int)PAGES.UnityAudio] = prop.boolValue;
        }

        private void WelcomePage()
        {
            GUILayout.FlexibleSpace();

            string message = string.Format(L10n.Tr("Welcome to FMOD for Unity {0}."),
                EditorUtils.VersionString(FMOD.VERSION.number));

            EditorGUILayout.LabelField(message, titleStyle);

            EditorGUILayout.Space();

            EditorGUILayout.LabelField(L10n.Tr("This setup wizard will help you configure your project to use FMOD."), titleStyle);

            GUILayout.FlexibleSpace();
        }

        private void Breadcrumbs()
        {
            using (new EditorGUILayout.VerticalScope("box", GUILayout.Width(150)))
            {
                crumbStyle.alignment = TextAnchor.MiddleCenter;
                Color oldColor = GUI.backgroundColor;
                EditorGUILayout.Space();

                for (int i = 0; i < pageNames.Count; i++)
                {
                    if (i > 0 && i < pageNames.Count - 1)
                    {
                        GUI.backgroundColor = (pageComplete[i] ? Color.green : Color.yellow);
                    }
                    crumbStyle.normal.textColor = (i == (int)currentPage ? crumbHighlight : crumbDefault);
                    using (var b = new EditorGUILayout.HorizontalScope("button", GUILayout.Height(22)))
                    {
                        if (GUI.Button(b.rect, pageNames[i], crumbStyle))
                        {
                            currentPage = (PAGES)i;
                        }
                        EditorGUILayout.Space();
                    }
                    GUI.backgroundColor = oldColor;
                }
                GUILayout.FlexibleSpace();
            }
        }

        private void UpdatingPage()
        {
            EditorGUILayout.LabelField(L10n.Tr("If you are updating an existing FMOD installation, you may need to perform some update tasks."), titleLeftStyle);

            GUILayout.FlexibleSpace();

            EditorGUILayout.LabelField(L10n.Tr("Choose an update task to perform:"), titleStyle);

            EditorGUILayout.Space();

            using (new EditorGUILayout.VerticalScope("box"))
            {
                float buttonWidth = 0;

                foreach (UpdateTask task in updateTasks)
                {
                    buttonWidth = Math.Max(buttonWidth, buttonStyle.CalcSize(new GUIContent(task.Name)).x);
                }

                float buttonHeight = buttonStyle.CalcSize(GUIContent.none).y;

                foreach (UpdateTask task in updateTasks)
                {
                    using (new GUILayout.HorizontalScope())
                    {
                        EditorGUILayout.Space();

                        GUILayout.Label(task.IsComplete ? tickTexture : crossTexture, iconStyle,
                            GUILayout.Height(buttonHeight));

                        if (GUILayout.Button(task.Name, buttonStyle, GUILayout.Width(buttonWidth)))
                        {
                            task.Execute();
                        }

                        GUILayout.Label(task.Description, descriptionStyle, GUILayout.MinHeight(buttonHeight));

                        GUILayout.FlexibleSpace();
                    }
                    EditorGUILayout.Space();
                }
            }

            GUILayout.FlexibleSpace();
        }

        private void LinkingPage()
        {
            EditorGUILayout.LabelField(L10n.Tr("In order to access your FMOD Studio content you need to locate the FMOD Studio Project or the .bank files that FMOD Studio produces, and configure a few other settings."), titleLeftStyle);
            GUILayout.FlexibleSpace();

            EditorGUILayout.LabelField(L10n.Tr("Choose how to access your FMOD Studio content:"), titleLeftStyle);

            EditorGUILayout.Space();
            using (new GUILayout.VerticalScope("box"))
            {
                float indent = 5;
                var serializedObject = new SerializedObject(Settings.Instance);

                var boxStyle = new GUIStyle();
                boxStyle.fixedHeight = 10;
                using (new GUILayout.HorizontalScope())
                {
                    GUILayout.Space(indent);
                    if (GUILayout.Button(L10n.Tr("FMOD Studio Project"), sourceButtonStyle))
                    {
                        isValidSource = SettingsEditor.BrowseForSourceProjectPath(serializedObject);
                    }
                    GUILayout.Label(L10n.Tr("If you have the complete FMOD Studio Project."), descriptionStyle, GUILayout.Height(sourceButtonStyle.fixedHeight));

                    GUILayout.FlexibleSpace();
                }
                EditorGUILayout.Space();
                using (new GUILayout.HorizontalScope())
                {
                    GUILayout.Space(indent);
                    if (GUILayout.Button("Single Platform Build", sourceButtonStyle))
                    {
                        SettingsEditor.BrowseForSourceBankPath(serializedObject, false);
                        EditorUtils.ValidateSource(out isValidSource, out invalidMessage);
                    }
                    EditorGUILayout.LabelField(L10n.Tr("If you have the contents of the Build folder for a single platform."),
                        descriptionStyle, GUILayout.Height(sourceButtonStyle.fixedHeight));
                    GUILayout.FlexibleSpace();
                }
                EditorGUILayout.Space();

                using (new GUILayout.HorizontalScope())
                {
                    GUILayout.Space(indent);
                    if (GUILayout.Button(L10n.Tr("Multiple Platform Build"), sourceButtonStyle))
                    {
                        SettingsEditor.BrowseForSourceBankPath(serializedObject, true);
                        EditorUtils.ValidateSource(out isValidSource, out invalidMessage);
                    }
                    EditorGUILayout.LabelField(L10n.Tr("If you have the contents of the Build folder for multiple platforms, with each platform in its own subdirectory."), descriptionStyle, GUILayout.Height(sourceButtonStyle.fixedHeight));
                    GUILayout.FlexibleSpace();
                }
                EditorGUILayout.Space();
            }

            if (IsStudioLinked() || invalidMessage.Length != 0)
            {
                EditorGUILayout.Space();

                Color oldColor = GUI.backgroundColor;
                GUI.backgroundColor = isValidSource ? Color.green : Color.red;

                using (new GUILayout.HorizontalScope("box"))
                {
                    GUILayout.FlexibleSpace();

                    GUILayout.Label(isValidSource ? tickTexture : crossTexture, iconStyle, GUILayout.Height(EditorGUIUtility.singleLineHeight * 2));

                    EditorGUILayout.Space();

                    using (new GUILayout.VerticalScope())
                    {
                        Settings settings = Settings.Instance;

                        if (settings.HasSourceProject)
                        {
                            EditorGUILayout.LabelField(L10n.Tr(String.Format("Using the FMOD Studio project at: {0}", settings.SourceBankPath)), descriptionStyle);
                        }
                        else if (settings.HasPlatforms)
                        {
                            EditorGUILayout.LabelField(L10n.Tr(isValidSource ? String.Format("Using the multiple platform build at: {0}", settings.SourceBankPath) : invalidMessage), descriptionStyle);
                        }
                        else
                        {
                            EditorGUILayout.LabelField(L10n.Tr(isValidSource ? String.Format("Using the single platform build at: {0}", settings.SourceBankPath) : invalidMessage), descriptionStyle);
                        }
                    }

                    GUILayout.FlexibleSpace();
                }

                GUI.backgroundColor = oldColor;
            }

            GUILayout.FlexibleSpace();
        }

        private void ListenerPage()
        {
            EditorGUILayout.LabelField(L10n.Tr("If you do not intend to use the built in Unity audio, you can choose to replace the Audio Listener with the FMOD Studio Listener.\n"), titleLeftStyle);
            EditorGUILayout.LabelField(L10n.Tr("Adding the FMOD Studio Listener component to the main camera provides the FMOD Engine with the information it needs to play 3D events correctly."), titleLeftStyle);
            EditorGUILayout.Space();
            GUILayout.FlexibleSpace();

            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();

                // Display found objects containing Unity listeners
                DisplayListeners(unityListeners, ref scroll1);

                // Show FMOD Listeners
                DisplayListeners(fmodListeners, ref scroll2);

                GUILayout.FlexibleSpace();
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                using (new EditorGUI.DisabledGroupScope(!bFoundUnityListener))
                {
                    GUILayout.FlexibleSpace();

                    if (GUILayout.Button(L10n.Tr("Replace Unity Listener(s) with FMOD Audio Listener."), buttonStyle))
                    {
                        for (int i = 0; i < unityListeners.Length; i++)
                        {
                            var listener = unityListeners[i];
                            if (listener)
                            {
                                RuntimeUtils.DebugLog("[FMOD Assistant] Replacing Unity Listener with FMOD Listener on " + listener.gameObject.name);
                                if (listener.GetComponent<StudioListener>() == null)
                                {
                                    listener.gameObject.AddComponent(typeof(StudioListener));
                                }
                                DestroyImmediate(unityListeners[i]);
                                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());
                                Repaint();
                            }
                        }
                    }
                }
                GUILayout.FlexibleSpace();
            }
        }

        private void DisplayListeners<T>(T[] listeners, ref Vector2 scrollPos)
        {
            using (new EditorGUILayout.VerticalScope("box"))
            {
                bool bUnityListenerType = false;
                if (typeof(T) == typeof(AudioListener))
                {
                    bUnityListenerType = true;
                }

                if (listeners != null && listeners.Length > 0)
                {
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        GUILayout.FlexibleSpace();
                        EditorGUILayout.LabelField((bUnityListenerType ? "Unity" : "FMOD") + L10n.Tr(" Listener(s) found: ") + listeners.Length, titleStyle, GUILayout.ExpandWidth(true));
                        GUILayout.FlexibleSpace();
                    }

                    using (var scrollView = new EditorGUILayout.ScrollViewScope(scrollPos, GUILayout.ExpandWidth(true)))
                    {
                        scrollPos = scrollView.scrollPosition;
                        foreach (T l in listeners)
                        {
                            var listener = l as Component;
                            if (listener != null && GUILayout.Button(listener.gameObject.name, GUILayout.ExpandWidth(true)))
                            {
                                Selection.activeGameObject = listener.gameObject;
                                EditorGUIUtility.PingObject(listener);
                            }
                        }
                    }
                    GUILayout.FlexibleSpace();
                }
                else
                {
                    using (new EditorGUILayout.HorizontalScope())
                    {
                        GUILayout.FlexibleSpace();
                        EditorGUILayout.LabelField((bUnityListenerType ? "Unity" : "FMOD") + L10n.Tr(" Listener(s) found: ") + listeners.Length, titleStyle);
                        GUILayout.FlexibleSpace();
                    }
                    GUILayout.FlexibleSpace();
                }
            }
        }

        private void DisableUnityAudioPage()
        {
            EditorGUILayout.LabelField(L10n.Tr("We recommend that you disable the built-in Unity audio for all platforms, to prevent it from consuming system audio resources that the FMOD Engine needs."), titleStyle);
            GUILayout.FlexibleSpace();

            var audioManager = AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/AudioManager.asset")[0];
            var serializedManager = new SerializedObject(audioManager);
            var prop = serializedManager.FindProperty("m_DisableAudio");

            using (new EditorGUILayout.HorizontalScope())
            {
                using (new EditorGUI.DisabledGroupScope(prop.boolValue))
                {
                    GUILayout.FlexibleSpace();
                    if (GUILayout.Button(prop.boolValue ? L10n.Tr("Built in audio has been disabled") : L10n.Tr("Disable built in audio"), buttonStyle))
                    {
                        prop.boolValue = true;
                        serializedManager.ApplyModifiedProperties();
                        RuntimeUtils.DebugLog("[FMOD Assistant] Built in Unity audio has been disabled.");
                        Repaint();
                    }

                }
                GUILayout.FlexibleSpace();
            }
            pageComplete[(int)PAGES.UnityAudio] = prop.boolValue;

            GUILayout.FlexibleSpace();
        }

        private void UnitySources()
        {
            if (unityAudioSources != null && unityAudioSources.Length > 0)
            {
                EditorGUILayout.LabelField(L10n.Tr("Listed below are all the Unity Audio Sources found in the currently loaded scenes and the Assets directory.\nSelect an Audio Source and replace it with an FMOD Studio Event Emitter."), titleStyle);
                EditorGUILayout.Space();

                if (m_SimpleTreeView == null)
                {
                    if (m_TreeViewState == null)
                    {
                        m_TreeViewState = new TreeViewState();
                    }
                    m_SimpleTreeView = new SimpleTreeView(m_TreeViewState);
                }

                m_SimpleTreeView.Drawlayout();
            }
            else
            {
                GUILayout.FlexibleSpace();
                EditorGUILayout.LabelField(L10n.Tr("No Unity Audio Sources have been found!"), titleStyle);
                GUILayout.FlexibleSpace();
            }
        }

        private void SourceControl()
        {
            EditorGUILayout.LabelField(L10n.Tr("There are a number of files produced by FMOD for Unity that should be ignored by source control. Here is an example of what you should add to your source control ignore file:"), titleLeftStyle);

            using (new EditorGUILayout.VerticalScope("box"))
            {
                ignoreFileScrollPosition = EditorGUILayout.BeginScrollView(ignoreFileScrollPosition, GUILayout.Height(200));
                EditorGUILayout.TextArea(IgnoreFileText);
                EditorGUILayout.EndScrollView();
            }

            EditorGUILayout.LabelField(
                "Add line ending requirements to a .gitattributes file to avoid issues:",
                titleLeftStyle
            );

            using (new EditorGUILayout.VerticalScope("box"))
            {
                EditorGUILayout.TextArea(GitAttributesText, GUILayout.Width(568));
            }

            pageComplete[(int)PAGES.SourceControl] = true;
        }

        private void EndPage()
        {
            GUILayout.FlexibleSpace();
            bool completed = true;
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                using (new EditorGUILayout.VerticalScope())
                {
                    for (int i = 1; i < pageNames.Count - 1; i++)
                    {
                        using (new EditorGUILayout.HorizontalScope())
                        {
                            EditorGUILayout.LabelField(pageNames[i], titleStyle);
                            EditorGUILayout.Space();
                            GUILayout.Label(pageComplete[i] ? tickTexture : crossTexture, iconStyle, GUILayout.ExpandWidth(false));

                            if (pageComplete[i] == false)
                            {
                                completed = false;
                            }
                        }
                        GUILayout.Space(8);
                    }
                }
                GUILayout.FlexibleSpace();
            }

            string msg = "";
            if (completed)
            {
                // All complete
                msg = L10n.Tr("FMOD for Unity has been set up successfully!");
            }
            // Essential
            else if (pageComplete[(int)PAGES.Linking])
            {
                // Partial complete (linking done)
                msg = L10n.Tr("FMOD for Unity has been partially set up.");
            }
            else
            {
                // Linking not done
                msg = L10n.Tr("FMOD for Unity has not finished being set up.\nLinking to a project or banks is required.");
            }

            GUILayout.FlexibleSpace();
            EditorGUILayout.LabelField(msg, titleStyle);
            GUILayout.FlexibleSpace();

            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();

                if (GUILayout.Button(L10n.Tr(" Integration Manual "), buttonStyle))
                {
                    EditorUtils.OnlineManual();
                }


                if (GUILayout.Button(L10n.Tr(" FMOD Settings "), buttonStyle))
                {
                    EditorSettings.EditSettings();
                }
                GUILayout.Space(18);

                GUILayout.FlexibleSpace();
            }

            if (completed)
            {
                Settings.Instance.HideSetupWizard = true;
            }
        }

        private void Buttons()
        {
            GUILayout.FlexibleSpace();
            using (new EditorGUILayout.HorizontalScope())
            {
                navButtonStyle = new GUIStyle("Button");
                navButtonStyle.fixedHeight = 45;
                navButtonStyle.fixedWidth = 75;

                GUILayout.FlexibleSpace();
                if (currentPage != 0)
                {
                    if (GUILayout.Button(L10n.Tr("Back"), navButtonStyle))
                    {
                        if (currentPage != 0)
                        {
                            currentPage--;
                        }
                    }
                }

                string button2Text = "Next";
                if (currentPage == 0) button2Text = L10n.Tr("Start");
                else if (currentPage == PAGES.End) button2Text = L10n.Tr("Close");
                else button2Text = L10n.Tr("Next");

                if (GUILayout.Button(button2Text, navButtonStyle))
                {
                    if (currentPage == PAGES.End)
                    {
                        this.Close();
                    }
                    currentPage++;
                }

                GUILayout.FlexibleSpace();
            }
        }

        private void StagingUpdatePage()
        {
            GUILayout.Space(25);

            string message = string.Format(L10n.Tr("Welcome to FMOD for Unity {0}."),
                EditorUtils.VersionString(FMOD.VERSION.number));

            EditorGUILayout.LabelField(message, titleStyle);

            EditorGUILayout.Space();

            EditorGUILayout.LabelField(
                L10n.Tr("To complete the installation, we need to update the FMOD native libraries.\n") +
                L10n.Tr("This involves a few steps:"), titleStyle);

            EditorGUILayout.Space();

            float nameWidth = 200;

            using (new GUILayout.VerticalScope(columnStyle))
            {

                foreach (StagingSystem.UpdateStep step in StagingSystem.UpdateSteps)
                {
                    bool complete = step.Stage < nextStagingStep.Stage;

                    Color oldColor = GUI.backgroundColor;
                    GUI.backgroundColor = complete ? Color.green : Color.yellow;

                    using (new GUILayout.HorizontalScope(GUI.skin.box))
                    {
                        GUILayout.Label(complete ? tickTexture : crossTexture, iconStyle);

                        EditorGUILayout.LabelField(step.Name, titleLeftStyle, GUILayout.Width(nameWidth));
                        EditorGUILayout.LabelField(step.Description, descriptionStyle);
                    }

                    GUI.backgroundColor = oldColor;
                }

                EditorGUILayout.Space();

                EditorGUILayout.LabelField(L10n.Tr("Next step:"), titleStyle);

                using (new GUILayout.HorizontalScope())
                {
                    GUILayout.FlexibleSpace();

                    if (GUILayout.Button(nextStagingStep.Name, buttonStyle, GUILayout.ExpandWidth(false)))
                    {
                        EditorApplication.delayCall += DoNextStagingStep;
                    }

                    GUILayout.FlexibleSpace();
                }

                EditorGUILayout.Space();

                using (var scope = new EditorGUILayout.ScrollViewScope(stagingDetailsScroll))
                {
                    stagingDetailsScroll = scope.scrollPosition;
                    GUIStyle longDescStyle = descriptionStyle;
                    longDescStyle.fixedWidth = 0;
                    EditorGUILayout.LabelField(nextStagingStep.Details, longDescStyle);
                }
            }
        }
    }

    public class SimpleTreeView : TreeView
    {
        private const float BodyHeight = 200;

        public SimpleTreeView(TreeViewState state) : base(state)
        {
            Reload();
            Repaint();
            ExpandAll();
        }

        protected override bool CanMultiSelect(TreeViewItem item)
        {
            return false;
        }

        protected override bool CanChangeExpandedState(TreeViewItem item)
        {
            return !(item is AudioSourceItem);
        }

        protected override void SelectionChanged(IList<int> selectedIds)
        {
            base.SelectionChanged(selectedIds);

            if (selectedIds.Count > 0)
            {
                var item = FindItem(selectedIds[0], rootItem);
                GameObject go = null;
                if (item.hasChildren)
                {
                    if (item is ParentItem)
                    {
                        go = ((ParentItem)item).gameObject;
                    }
                }
                else
                {
                    go = ((ParentItem)((AudioSourceItem)item).parent).gameObject;
                }
                Selection.activeGameObject = go;
            }
        }

        protected override TreeViewItem BuildRoot()
        {
            var root = new TreeViewItem (-1, -1);

            CreateItems(root, Resources.FindObjectsOfTypeAll<AudioSource>());
            showAlternatingRowBackgrounds = true;
            showBorder = true;
            SetupDepthsFromParentsAndChildren(root);

            return root;
        }

        private class AudioSourceItem : TreeViewItem
        {
            const string audioIcon = "AudioSource Icon";
            public AudioSourceItem(AudioSource source) : base(source.GetHashCode())
            {
                displayName = (source.clip ? source.clip.name : "None");
                icon = (Texture2D)EditorGUIUtility.IconContent(audioIcon).image;
            }
        }

        private class ParentItem : TreeViewItem
        {
            public GameObject gameObject;
            const string goIcon = "GameObject Icon";
            const string prefabIcon = "Prefab Icon";
            const string prefabModelIcon = "PrefabModel Icon";
            const string prefabVariantIcon = "PrefabVariant Icon";

            public ParentItem(GameObject go) : base(go.GetHashCode(), 0, go.name)
            {
                gameObject = go;
                var foundAudio = gameObject.GetComponents<AudioSource>();
                for (int i = 0; i < foundAudio.Length; i++)
                {
                    AddChild(new AudioSourceItem(foundAudio[i]));
                }

                switch (PrefabUtility.GetPrefabAssetType(go))
                {
                    case PrefabAssetType.NotAPrefab:
                    icon = (Texture2D)EditorGUIUtility.IconContent(goIcon).image;
                        break;
                    case PrefabAssetType.Regular:
                    icon = (Texture2D)EditorGUIUtility.IconContent(prefabIcon).image;
                        break;
                    case PrefabAssetType.Model:
                    icon = (Texture2D)EditorGUIUtility.IconContent(prefabModelIcon).image;
                        break;
                    case PrefabAssetType.Variant:
                    icon = (Texture2D)EditorGUIUtility.IconContent(prefabVariantIcon).image;
                        break;
                }
            }
        }

        private class SceneItem : TreeViewItem
        {
            public Scene m_scene;
            const string sceneIcon = "SceneAsset Icon";
            const string folderIcon = "Folder Icon";

            public SceneItem(Scene scene) : base (scene.GetHashCode())
            {
                m_scene = scene;
                if (m_scene.IsValid())
                {
                    displayName = m_scene.name;
                    icon = (Texture2D)EditorGUIUtility.IconContent(sceneIcon).image;
                }
                else
                {
                    displayName = "Assets";
                    icon = (Texture2D)EditorGUIUtility.IconContent(folderIcon).image;
                }
            }
        }

        private void CreateItems(TreeViewItem root, AudioSource[] audioSources)
        {
            for(int i = 0; i < audioSources.Length; i++)
            {
                AudioSource audioSource = audioSources[i];

                GameObject obj = audioSource.gameObject;
                var sourceItem = FindItem(obj.GetHashCode(), root);
                if (sourceItem == null)
                {
                    List<GameObject> gameObjects = new List<GameObject>();
                    gameObjects.Add(obj);
                    while (obj.transform.parent != null)
                    {
                        obj = obj.transform.parent.gameObject;
                        gameObjects.Add(obj);
                    }
                    gameObjects.Reverse();

                    var parentItem = FindItem(obj.scene.GetHashCode(), root);
                    if (parentItem == null)
                    {
                        parentItem = new SceneItem(obj.scene);
                        root.AddChild(parentItem);
                    }

                    foreach (var go in gameObjects)
                    {
                        var objItem = FindItem(go.GetHashCode(), root);
                        if (objItem == null)
                        {
                            objItem = new ParentItem(go);
                            parentItem.AddChild(objItem);
                        }
                        parentItem = objItem;
                    }
                }
            }
        }

        public void Drawlayout()
        {
            Rect rect = EditorGUILayout.GetControlRect(false, BodyHeight);
            rect = EditorGUI.IndentedRect(rect);

            OnGUI(rect);
            Toolbar();
        }

        public void Toolbar()
        {
            using (new EditorGUILayout.HorizontalScope())
            {
                var style = "miniButton";
                if (GUILayout.Button(L10n.Tr("Expand All"), style))
                {
                    ExpandAll();
                }

                if (GUILayout.Button(L10n.Tr("Collapse All"), style))
                {
                    CollapseAll();
                }
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/SetupWizard.cs.meta
================================================
fileFormatVersion: 2
guid: aa9a0c70fef01fb43b8eff668bfa0e9c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioBankLoaderEditor.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomEditor(typeof(StudioBankLoader))]
    [CanEditMultipleObjects]
    public class StudioBankLoaderEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            var load = serializedObject.FindProperty("LoadEvent");
            var unload = serializedObject.FindProperty("UnloadEvent");
            var tag = serializedObject.FindProperty("CollisionTag");
            var banks = serializedObject.FindProperty("Banks");
            var preload = serializedObject.FindProperty("PreloadSamples");

            EditorGUILayout.PropertyField(load, new GUIContent(L10n.Tr("Load")));
            EditorGUILayout.PropertyField(unload, new GUIContent(L10n.Tr("Unload")));

            if ((load.enumValueIndex >= 3 && load.enumValueIndex <= 6) ||
                (unload.enumValueIndex >= 3 && unload.enumValueIndex <= 6))
            {
                tag.stringValue = EditorGUILayout.TagField("Collision Tag", tag.stringValue);
            }

            EditorGUILayout.PropertyField(preload, new GUIContent(L10n.Tr("Preload Sample Data")));

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.PrefixLabel(L10n.Tr("Banks"));
            EditorGUILayout.BeginVertical();
            if (GUILayout.Button(L10n.Tr("Add Bank"), GUILayout.ExpandWidth(false)))
            {
                banks.InsertArrayElementAtIndex(banks.arraySize);
                SerializedProperty newBank = banks.GetArrayElementAtIndex(banks.arraySize - 1);
                newBank.stringValue = "";

                EventBrowser browser = CreateInstance<EventBrowser>();

                browser.titleContent = new GUIContent(L10n.Tr("Select FMOD Bank"));

                browser.ChooseBank(newBank);
                browser.ShowUtility();
            }

            Texture deleteTexture = EditorUtils.LoadImage("Delete.png");
            GUIContent deleteContent = new GUIContent(deleteTexture, "Delete Bank");

            var buttonStyle = new GUIStyle(GUI.skin.button);
            buttonStyle.padding.top = buttonStyle.padding.bottom = 1;
            buttonStyle.margin.top = 2;
            buttonStyle.padding.left = buttonStyle.padding.right = 4;
            buttonStyle.fixedHeight = GUI.skin.textField.CalcSize(new GUIContent()).y;

            for (int i = 0; i < banks.arraySize; i++)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.PropertyField(banks.GetArrayElementAtIndex(i), GUIContent.none);

                if (GUILayout.Button(deleteContent, buttonStyle, GUILayout.ExpandWidth(false)))
                {
                    banks.DeleteArrayElementAtIndex(i);
                }
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndVertical();

            EditorGUILayout.EndHorizontal();

            Event e = Event.current;
            if (e.type == EventType.DragPerform)
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorBankRef))
                {
                    int pos = banks.arraySize;
                    banks.InsertArrayElementAtIndex(pos);
                    var pathProperty = banks.GetArrayElementAtIndex(pos);

                    pathProperty.stringValue = ((EditorBankRef)DragAndDrop.objectReferences[0]).Name;

                    e.Use();
                }
            }
            if (e.type == EventType.DragUpdated)
            {
                if (DragAndDrop.objectReferences.Length > 0 &&
                    DragAndDrop.objectReferences[0] != null &&
                    DragAndDrop.objectReferences[0].GetType() == typeof(EditorBankRef))
                {
                    DragAndDrop.visualMode = DragAndDropVisualMode.Move;
                    DragAndDrop.AcceptDrag();
                    e.Use();
                }
            }

            serializedObject.ApplyModifiedProperties();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioBankLoaderEditor.cs.meta
================================================
fileFormatVersion: 2
guid: f7f61e03a350e1e428dba6c562f3d64a
timeCreated: 1434691856
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioEventEmitterEditor.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomEditor(typeof(StudioEventEmitter))]
    [CanEditMultipleObjects]
    public class StudioEventEmitterEditor : Editor
    {
        private ParameterValueView parameterValueView;

        public void OnEnable()
        {
            parameterValueView = new ParameterValueView(serializedObject);
        }

        public void OnSceneGUI()
        {
            var emitter = target as StudioEventEmitter;

            EditorEventRef editorEvent = EventManager.EventFromGUID(emitter.EventReference.Guid);
            if (editorEvent != null && editorEvent.Is3D)
            {
                EditorGUI.BeginChangeCheck();
                float minDistance = emitter.OverrideAttenuation ? emitter.OverrideMinDistance : editorEvent.MinDistance;
                float maxDistance = emitter.OverrideAttenuation ? emitter.OverrideMaxDistance : editorEvent.MaxDistance;
                minDistance = Handles.RadiusHandle(Quaternion.identity, emitter.transform.position, minDistance);
                maxDistance = Handles.RadiusHandle(Quaternion.identity, emitter.transform.position, maxDistance);
                if (EditorGUI.EndChangeCheck() && emitter.OverrideAttenuation)
                {
                    Undo.RecordObject(emitter, "Change Emitter Bounds");
                    emitter.OverrideMinDistance = Mathf.Clamp(minDistance, 0, emitter.OverrideMaxDistance);
                    emitter.OverrideMaxDistance = Mathf.Max(emitter.OverrideMinDistance, maxDistance);
                }
            }
        }

        public override void OnInspectorGUI()
        {
            var begin = serializedObject.FindProperty("EventPlayTrigger");
            var end = serializedObject.FindProperty("EventStopTrigger");
            var tag = serializedObject.FindProperty("CollisionTag");
            var eventReference = serializedObject.FindProperty("EventReference");
#if FMOD_SERIALIZE_GUID_ONLY
            FMOD.GUID guid = eventReference.FindPropertyRelative("Guid").GetGuid();
            EditorEventRef editorEventRef = EventManager.EventFromGUID(guid);
            var eventPath = "";
            if (editorEventRef != null)
            {
                eventPath = editorEventRef.Path;
            }
#else
            var eventPath = eventReference.FindPropertyRelative("Path");
#endif
            var fadeout = serializedObject.FindProperty("AllowFadeout");
            var once = serializedObject.FindProperty("TriggerOnce");
            var preload = serializedObject.FindProperty("Preload");
            var nonRigidbodyVelocity = serializedObject.FindProperty("NonRigidbodyVelocity");
            var overrideAtt = serializedObject.FindProperty("OverrideAttenuation");
            var minDistance = serializedObject.FindProperty("OverrideMinDistance");
            var maxDistance = serializedObject.FindProperty("OverrideMaxDistance");

            EditorGUILayout.PropertyField(begin, new GUIContent(L10n.Tr("Event Play Trigger")));
            EditorGUILayout.PropertyField(end, new GUIContent(L10n.Tr("Event Stop Trigger")));

            if ((begin.enumValueIndex >= (int)EmitterGameEvent.TriggerEnter && begin.enumValueIndex <= (int)EmitterGameEvent.TriggerExit2D) ||
            (end.enumValueIndex >= (int)EmitterGameEvent.TriggerEnter && end.enumValueIndex <= (int)EmitterGameEvent.TriggerExit2D))
            {
                tag.stringValue = EditorGUILayout.TagField("Collision Tag", tag.stringValue);
            }

            EditorGUI.BeginChangeCheck();

            const string EventReferenceLabel = "Event";

            EditorUtils.DrawLegacyEvent(serializedObject.FindProperty("Event"), EventReferenceLabel);

            EditorGUILayout.PropertyField(eventReference, new GUIContent(L10n.Tr(EventReferenceLabel)));
#if FMOD_SERIALIZE_GUID_ONLY
            EditorEventRef editorEvent = EventManager.EventFromPath(eventPath);
#else
            EditorEventRef editorEvent = EventManager.EventFromPath(eventPath.stringValue);
#endif


            if (EditorGUI.EndChangeCheck())
            {
#if FMOD_SERIALIZE_GUID_ONLY
                EditorUtils.UpdateParamsOnEmitter(serializedObject, eventPath);
#else
                EditorUtils.UpdateParamsOnEmitter(serializedObject, eventPath.stringValue);
#endif
            }

            // Attenuation
            if (editorEvent != null)
            {
                {
                    EditorGUI.BeginDisabledGroup(editorEvent == null || !editorEvent.Is3D);
                    EditorGUILayout.BeginHorizontal();
                    EditorGUI.BeginChangeCheck();
                    EditorGUILayout.PropertyField(overrideAtt, new GUIContent(L10n.Tr("Override Attenuation")));
                    if (EditorGUI.EndChangeCheck() ||
                        (minDistance.floatValue == -1 && maxDistance.floatValue == -1) || // never been initialiased
                            !overrideAtt.boolValue &&
                            (minDistance.floatValue != editorEvent.MinDistance || maxDistance.floatValue != editorEvent.MaxDistance)
                        )
                    {
                        minDistance.floatValue = editorEvent.MinDistance;
                        maxDistance.floatValue = editorEvent.MaxDistance;
                    }
                    EditorGUI.BeginDisabledGroup(!overrideAtt.boolValue);
                    EditorGUIUtility.labelWidth = 30;
                    EditorGUI.BeginChangeCheck();
                    EditorGUILayout.PropertyField(minDistance, new GUIContent("Min"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        minDistance.floatValue = Mathf.Clamp(minDistance.floatValue, 0, maxDistance.floatValue);
                    }
                    EditorGUI.BeginChangeCheck();
                    EditorGUILayout.PropertyField(maxDistance, new GUIContent("Max"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        maxDistance.floatValue = Mathf.Max(minDistance.floatValue, maxDistance.floatValue);
                    }
                    EditorGUIUtility.labelWidth = 0;
                    EditorGUI.EndDisabledGroup();
                    EditorGUILayout.EndHorizontal();
                    EditorGUI.EndDisabledGroup();
                }

                parameterValueView.OnGUI(editorEvent, !eventReference.hasMultipleDifferentValues);

                fadeout.isExpanded = EditorGUILayout.Foldout(fadeout.isExpanded, L10n.Tr("Advanced Controls"));
                if (fadeout.isExpanded)
                {
                    EditorGUILayout.PropertyField(preload, new GUIContent(L10n.Tr("Preload Sample Data")));
                    EditorGUILayout.PropertyField(fadeout, new GUIContent(L10n.Tr("Allow Fadeout When Stopping")));
                    EditorGUILayout.PropertyField(once, new GUIContent(L10n.Tr("Trigger Once")));
                    EditorGUILayout.PropertyField(nonRigidbodyVelocity, new GUIContent(L10n.Tr("Non-Rigidbody Velocity")));
                }
            }

            serializedObject.ApplyModifiedProperties();
        }

        private class ParameterValueView
        {
            // The "Params" property from the SerializedObject we're editing in the inspector,
            // so we can expand/collapse it or revert to prefab.
            private SerializedProperty paramsProperty;

            // This holds one SerializedObject for each object in the current selection.
            private List<SerializedObject> serializedTargets = new List<SerializedObject>();

            // Mappings from EditorParamRef to initial parameter value property for all properties
            // found in the current selection.
            private List<PropertyRecord> propertyRecords = new List<PropertyRecord>();

            // Any parameters that are in the current event but are missing from some objects in
            // the current selection, so we can put them in the "Add" menu.
            private List<EditorParamRef> missingParameters = new List<EditorParamRef>();

            // A mapping from EditorParamRef to the initial parameter value properties in the
            // current selection that have the same name.
            // We need this because some objects may be missing some properties, and properties with
            // the same name may be at different array indices in different objects.
            private class PropertyRecord
            {
                public string name { get { return paramRef.Name; } }
                public EditorParamRef paramRef;
                public List<SerializedProperty> valueProperties;
            }

            public ParameterValueView(SerializedObject serializedObject)
            {
                paramsProperty = serializedObject.FindProperty("Params");

                foreach (UnityEngine.Object target in serializedObject.targetObjects)
                {
                    serializedTargets.Add(new SerializedObject(target));
                }
            }

            // Rebuilds the propertyRecords and missingParameters collections.
            private void RefreshPropertyRecords(EditorEventRef eventRef)
            {
                propertyRecords.Clear();

                foreach (SerializedObject serializedTarget in serializedTargets)
                {
                    SerializedProperty paramsProperty = serializedTarget.FindProperty("Params");

                    foreach (SerializedProperty parameterProperty in paramsProperty)
                    {
                        string name = parameterProperty.FindPropertyRelative("Name").stringValue;
                        SerializedProperty valueProperty = parameterProperty.FindPropertyRelative("Value");

                        PropertyRecord record = propertyRecords.Find(r => r.name == name);

                        if (record != null)
                        {
                            record.valueProperties.Add(valueProperty);
                        }
                        else
                        {
                            EditorParamRef paramRef = eventRef.LocalParameters.Find(p => p.Name == name);

                            if (paramRef != null)
                            {
                                propertyRecords.Add(
                                    new PropertyRecord() {
                                        paramRef = paramRef,
                                        valueProperties = new List<SerializedProperty>() { valueProperty },
                                    });
                            }
                        }
                    }
                }

                // Only sort if there is a multi-selection. If there is only one object selected,
                // the user can revert to prefab, and the behaviour depends on the array order,
                // so it's helpful to show the true order.
                if (serializedTargets.Count > 1)
                {
                    propertyRecords.Sort((a, b) => EditorUtility.NaturalCompare(a.name, b.name));
                }

                missingParameters.Clear();
                missingParameters.AddRange(eventRef.LocalParameters.Where(
                    p => {
                        PropertyRecord record = propertyRecords.Find(r => r.name == p.Name);
                        return record == null || record.valueProperties.Count < serializedTargets.Count;
                    }));
            }

            public void OnGUI(EditorEventRef eventRef, bool matchingEvents)
            {
                foreach (SerializedObject serializedTarget in serializedTargets)
                {
                    serializedTarget.Update();
                }

                if (Event.current.type == EventType.Layout)
                {
                    RefreshPropertyRecords(eventRef);
                }

                DrawHeader(matchingEvents);

                if (paramsProperty.isExpanded)
                {
                    if (matchingEvents)
                    {
                        DrawValues();
                    }
                    else
                    {
                        GUILayout.Box("Cannot change parameters when different events are selected", GUILayout.ExpandWidth(true));
                    }
                }

                foreach (SerializedObject serializedTarget in serializedTargets)
                {
                    serializedTarget.ApplyModifiedProperties();
                }
            }

            private void DrawHeader(bool enableAddButton)
            {
                Rect controlRect = EditorGUILayout.GetControlRect();

                Rect titleRect = controlRect;
                titleRect.width = EditorGUIUtility.labelWidth;

                // Let the user revert the whole Params array to prefab by context-clicking the title.
                EditorGUI.BeginProperty(titleRect, GUIContent.none, paramsProperty);

                paramsProperty.isExpanded = EditorGUI.Foldout(titleRect, paramsProperty.isExpanded,
                    L10n.Tr("Initial Parameter Values"));

                EditorGUI.EndProperty();

                Rect buttonRect = controlRect;
                buttonRect.xMin = titleRect.xMax;

                EditorGUI.BeginDisabledGroup(!enableAddButton);

                DrawAddButton(buttonRect);

                EditorGUI.EndDisabledGroup();
            }

            private void DrawAddButton(Rect position)
            {
                EditorGUI.BeginDisabledGroup(missingParameters.Count == 0);

                if (EditorGUI.DropdownButton(position, new GUIContent(L10n.Tr("Add")), FocusType.Passive))
                {
                    GenericMenu menu = new GenericMenu();
                    menu.AddItem(new GUIContent(L10n.Tr("All")), false, () =>
                        {
                            foreach (EditorParamRef parameter in missingParameters)
                            {
                                AddParameter(parameter);
                            }
                        });

                    menu.AddSeparator(string.Empty);

                    foreach (EditorParamRef parameter in missingParameters)
                    {
                        menu.AddItem(new GUIContent(parameter.Name), false,
                            (userData) =>
                            {
                                AddParameter(userData as EditorParamRef);
                            },
                            parameter);
                    }

                    menu.DropDown(position);
                }

                EditorGUI.EndDisabledGroup();
            }

            private void DrawValues()
            {
                // We use this to defer deletion so we don't mess with arrays while using
                // SerializedProperties that refer to array elements, as this can throw exceptions.
                string parameterToDelete = null;

                foreach (PropertyRecord record in propertyRecords)
                {
                    if (record.valueProperties.Count == serializedTargets.Count)
                    {
                        bool delete;
                        DrawValue(record, out delete);

                        if (delete)
                        {
                            parameterToDelete = record.name;
                        }
                    }
                }

                if (parameterToDelete != null)
                {
                    DeleteParameter(parameterToDelete);
                }
            }

            private void DrawValue(PropertyRecord record, out bool delete)
            {
                delete = false;

                GUIContent removeLabel = new GUIContent(L10n.Tr("Remove"));

                Rect position = EditorGUILayout.GetControlRect();

                Rect nameLabelRect = position;
                nameLabelRect.width = EditorGUIUtility.labelWidth;

                Rect removeButtonRect = position;
                removeButtonRect.width = EditorStyles.miniButton.CalcSize(removeLabel).x;
                removeButtonRect.x = position.xMax - removeButtonRect.width;

                Rect sliderRect = position;
                sliderRect.xMin = nameLabelRect.xMax;
                sliderRect.xMax = removeButtonRect.xMin - EditorStyles.miniButton.margin.left;

                GUIContent nameLabel = new GUIContent(record.name);

                float value = 0;
                bool mixedValues = false;

                // We use EditorGUI.BeginProperty when there is a single object selected, so
                // the user can revert the value to prefab by context-clicking the name.
                // We handle multi-selections ourselves, so that we can deal with
                // mismatched arrays nicely.
                if (record.valueProperties.Count == 1)
                {
                    value = record.valueProperties[0].floatValue;
                    EditorGUI.BeginProperty(position, nameLabel, record.valueProperties[0]);
                }
                else
                {
                    bool first = true;

                    foreach (SerializedProperty property in record.valueProperties)
                    {
                        if (first)
                        {
                            value = property.floatValue;
                            first = false;
                        }
                        else if (property.floatValue != value)
                        {
                            mixedValues = true;
                            break;
                        }
                    }
                }

                EditorGUI.LabelField(nameLabelRect, nameLabel);

                if (record.paramRef.Type == ParameterType.Labeled)
                {
                    EditorGUI.BeginChangeCheck();

                    EditorGUI.showMixedValue = mixedValues;

                    int newValue = EditorGUI.Popup(sliderRect, (int)value, record.paramRef.Labels);

                    EditorGUI.showMixedValue = false;

                    if (EditorGUI.EndChangeCheck())
                    {
                        foreach (SerializedProperty property in record.valueProperties)
                        {
                            property.floatValue = newValue;
                        }
                    }
                }
                else if (record.paramRef.Type == ParameterType.Discrete)
                {
                    EditorGUI.BeginChangeCheck();

                    EditorGUI.showMixedValue = mixedValues;

                    int newValue = EditorGUI.IntSlider(sliderRect, (int)value, (int)record.paramRef.Min, (int)record.paramRef.Max);

                    EditorGUI.showMixedValue = false;

                    if (EditorGUI.EndChangeCheck())
                    {
                        foreach (SerializedProperty property in record.valueProperties)
                        {
                            property.floatValue = newValue;
                        }
                    }
                }
                else
                {
                    EditorGUI.BeginChangeCheck();

                    EditorGUI.showMixedValue = mixedValues;

                    float newValue = EditorGUI.Slider(sliderRect, value, record.paramRef.Min, record.paramRef.Max);

                    EditorGUI.showMixedValue = false;

                    if (EditorGUI.EndChangeCheck())
                    {
                        foreach (SerializedProperty property in record.valueProperties)
                        {
                            property.floatValue = newValue;
                        }
                    }
                }

                delete = GUI.Button(removeButtonRect, removeLabel, EditorStyles.miniButton);

                if (record.valueProperties.Count == 1)
                {
                    EditorGUI.EndProperty();
                }
                else
                {
                    // Context menu to set all values from one object in the multi-selection.
                    if (mixedValues && Event.current.type == EventType.ContextClick
                        && nameLabelRect.Contains(Event.current.mousePosition))
                    {
                        GenericMenu menu = new GenericMenu();

                        foreach (SerializedProperty sourceProperty in record.valueProperties)
                        {
                            UnityEngine.Object targetObject = sourceProperty.serializedObject.targetObject;

                            menu.AddItem(new GUIContent(string.Format(L10n.Tr("Set to Value of '{0}'"), targetObject.name)), false,
                                (userData) => CopyValueToAll(userData as SerializedProperty, record.valueProperties),
                                sourceProperty);
                        }

                        menu.DropDown(position);

                    }
                }
            }

            // Copy the value from the source property to all target properties.
            private void CopyValueToAll(SerializedProperty sourceProperty, List<SerializedProperty> targetProperties)
            {
                foreach (SerializedProperty targetProperty in targetProperties)
                {
                    if (targetProperty != sourceProperty)
                    {
                        targetProperty.floatValue = sourceProperty.floatValue;
                        targetProperty.serializedObject.ApplyModifiedProperties();
                    }
                }
            }

            // Add an initial value for the given parameter to all selected objects that don't have one.
            private void AddParameter(EditorParamRef parameter)
            {
                foreach (SerializedObject serializedTarget in serializedTargets)
                {
                    StudioEventEmitter emitter = serializedTarget.targetObject as StudioEventEmitter;

                    if (Array.FindIndex(emitter.Params, p => p.Name == parameter.Name) < 0)
                    {
                        SerializedProperty paramsProperty = serializedTarget.FindProperty("Params");

                        int index = paramsProperty.arraySize;
                        paramsProperty.InsertArrayElementAtIndex(index);

                        SerializedProperty arrayElement = paramsProperty.GetArrayElementAtIndex(index);

                        arrayElement.FindPropertyRelative("Name").stringValue = parameter.Name;
                        arrayElement.FindPropertyRelative("Value").floatValue = parameter.Default;

                        serializedTarget.ApplyModifiedProperties();
                    }
                }
            }

            // Delete initial parameter values for the given name from all selected objects.
            private void DeleteParameter(string name)
            {
                foreach (SerializedObject serializedTarget in serializedTargets)
                {
                    SerializedProperty paramsProperty = serializedTarget.FindProperty("Params");

                    foreach (SerializedProperty child in paramsProperty)
                    {
                        if (child.FindPropertyRelative("Name").stringValue == name)
                        {
                            child.DeleteCommand();
                            break;
                        }
                    }
                }
            }
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioEventEmitterEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 2b044fd4ebf2c42468e1f41d5e2b879c
timeCreated: 1434696182
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioEventEmitterGizmoDrawer.cs
================================================
﻿using UnityEngine;
using UnityEditor;

namespace FMODUnity
{
    public class StudioEventEmitterGizoDrawer
    {
        [DrawGizmo(GizmoType.Selected | GizmoType.Active | GizmoType.NotInSelectionHierarchy | GizmoType.Pickable)]
        private static void DrawGizmo(StudioEventEmitter studioEmitter, GizmoType gizmoType)
        {
            Gizmos.DrawIcon(studioEmitter.transform.position, "AudioSource Gizmo", true, Color.yellow);
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioEventEmitterGizmoDrawer.cs.meta
================================================
fileFormatVersion: 2
guid: f09ba26caab55e048a2e596ff75b3eab
timeCreated: 1433142677
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioGlobalParameterTriggerEditor.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomEditor(typeof(StudioGlobalParameterTrigger))]
    public class StudioGlobalParameterTriggerEditor : Editor
    {
        private SerializedProperty param;
        private SerializedProperty trigger;
        private SerializedProperty tag;
        private SerializedProperty value;

        private SerializedProperty data1, data2;

        private static GUIContent NotFoundWarning;

        private string currentPath;

        [SerializeField]
        private EditorParamRef editorParamRef;

        private void OnEnable()
        {
            param = serializedObject.FindProperty("Parameter");
            trigger = serializedObject.FindProperty("TriggerEvent");
            tag = serializedObject.FindProperty("CollisionTag");
            value = serializedObject.FindProperty("Value");
        }

        public override void OnInspectorGUI()
        {
            if (NotFoundWarning == null)
            {
                Texture warningIcon = EditorUtils.LoadImage("NotFound.png");
                NotFoundWarning = new GUIContent(L10n.Tr("Parameter Not Found"), warningIcon);
            }

            EditorGUILayout.PropertyField(trigger, new GUIContent(L10n.Tr("Trigger")));
            if (trigger.enumValueIndex >= (int)EmitterGameEvent.TriggerEnter && trigger.enumValueIndex <= (int)EmitterGameEvent.TriggerExit2D)
            {
                tag.stringValue = EditorGUILayout.TagField("Collision Tag", tag.stringValue);
            }

            EditorGUILayout.PropertyField(param, new GUIContent(L10n.Tr("Parameter")));

            if (param.stringValue != currentPath)
            {
                currentPath = param.stringValue;

                if (string.IsNullOrEmpty(param.stringValue))
                {
                    editorParamRef = null;
                }
                else
                {
                    editorParamRef = EventManager.ParamFromPath(param.stringValue);
                    value.floatValue = Mathf.Clamp(value.floatValue, editorParamRef.Min, editorParamRef.Max);
                }
            }

            if (editorParamRef != null)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    EditorGUILayout.PrefixLabel(L10n.Tr("Override Value"));
                    value.floatValue = EditorUtils.DrawParameterValueLayout(value.floatValue, editorParamRef);
                }
            }
            else
            {
                Rect rect = EditorGUILayout.GetControlRect();
                rect.xMin += EditorGUIUtility.labelWidth;

                GUI.Label(rect, NotFoundWarning);
            }

            serializedObject.ApplyModifiedProperties();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioGlobalParameterTriggerEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 0a901681b5558f247b4c227fb425c010
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioListenerEditor.cs
================================================
﻿using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomEditor(typeof(StudioListener))]
    [CanEditMultipleObjects]
    public class StudioListenerEditor : Editor
    {
        private SerializedProperty attenuationObject;
        private SerializedProperty nonRigidbodyVelocity;

        private void OnEnable()
        {
            attenuationObject = serializedObject.FindProperty("attenuationObject");
            nonRigidbodyVelocity = serializedObject.FindProperty("nonRigidbodyVelocity");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            EditorGUI.BeginDisabledGroup(true);
            int index = ((StudioListener)serializedObject.targetObject).ListenerNumber;
            EditorGUILayout.IntSlider(L10n.Tr("Listener Index"), index, 0, FMOD.CONSTANTS.MAX_LISTENERS - 1);
            EditorGUI.EndDisabledGroup();

            EditorGUILayout.PropertyField(attenuationObject, new GUIContent(L10n.Tr("Attenuation Object")));
            EditorGUILayout.PropertyField(nonRigidbodyVelocity, new GUIContent(L10n.Tr("Non-Rigidbody Velocity")));
            serializedObject.ApplyModifiedProperties();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioListenerEditor.cs.meta
================================================
fileFormatVersion: 2
guid: 847f8505c25f5cf42adba68a26f2cda6
timeCreated: 1445576758
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioParameterTriggerEditor.cs
================================================
﻿using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace FMODUnity
{
    [CustomEditor(typeof(StudioParameterTrigger))]
    public class StudioParameterTriggerEditor : Editor
    {
        private StudioEventEmitter targetEmitter;
        private SerializedProperty emitters;
        private SerializedProperty trigger;
        private SerializedProperty tag;

        private bool[] expanded;

        private void OnEnable()
        {
            emitters = serializedObject.FindProperty("Emitters");
            trigger = serializedObject.FindProperty("TriggerEvent");
            tag = serializedObject.FindProperty("CollisionTag");
            targetEmitter = null;
            for (int i = 0; i < emitters.arraySize; i++)
            {
                targetEmitter = emitters.GetArrayElementAtIndex(i).FindPropertyRelative("Target").objectReferenceValue as StudioEventEmitter;
                if (targetEmitter != null)
                {
                    expanded = new bool[targetEmitter.GetComponents<StudioEventEmitter>().Length];
                    break;
                }
            }
        }

        public override void OnInspectorGUI()
        {
            var newTargetEmitter = EditorGUILayout.ObjectField(L10n.Tr("Target"), targetEmitter, typeof(StudioEventEmitter), true) as StudioEventEmitter;
            if (newTargetEmitter != targetEmitter)
            {
                emitters.ClearArray();
                targetEmitter = newTargetEmitter;

                if (targetEmitter == null)
                {
                    serializedObject.ApplyModifiedProperties();
                    return;
                }

                List<StudioEventEmitter> newEmitters = new List<StudioEventEmitter>();
                targetEmitter.GetComponents(newEmitters);
                expanded = new bool[newEmitters.Count];
                foreach (var emitter in newEmitters)
                {
                    emitters.InsertArrayElementAtIndex(0);
                    emitters.GetArrayElementAtIndex(0).FindPropertyRelative("Target").objectReferenceValue = emitter;
                }
            }

            if (targetEmitter == null)
            {
                return;
            }

            EditorGUILayout.PropertyField(trigger, new GUIContent(L10n.Tr("Trigger")));

            if (trigger.enumValueIndex >= (int)EmitterGameEvent.TriggerEnter && trigger.enumValueIndex <= (int)EmitterGameEvent.TriggerExit2D)
            {
                tag.stringValue = EditorGUILayout.TagField("Collision Tag", tag.stringValue);
            }

            var localEmitters = new List<StudioEventEmitter>();
            targetEmitter.GetComponents(localEmitters);

            int emitterIndex = 0;
            foreach (var emitter in localEmitters)
            {
                SerializedProperty emitterProperty = null;
                for(int i = 0; i < emitters.arraySize; i++)
                {
                    if (emitters.GetArrayElementAtIndex(i).FindPropertyRelative("Target").objectReferenceValue == emitter)
                    {
                        emitterProperty = emitters.GetArrayElementAtIndex(i);
                        break;
                    }
                }

                // New emitter component added to game object since we last looked
                if (emitterProperty == null)
                {
                    emitters.InsertArrayElementAtIndex(0);
                    emitterProperty = emitters.GetArrayElementAtIndex(0);
                    emitterProperty.FindPropertyRelative("Target").objectReferenceValue = emitter;
                }

                if (!emitter.EventReference.IsNull)
                {
                    expanded[emitterIndex] = EditorGUILayout.Foldout(expanded[emitterIndex], emitter.EventReference.Path);
                    if (expanded[emitterIndex])
                    {
                        var eventRef = EventManager.EventFromGUID(emitter.EventReference.Guid);

                        foreach (var paramRef in eventRef.LocalParameters)
                        {
                            bool set = false;
                            int index = -1;
                            for (int i = 0; i < emitterProperty.FindPropertyRelative("Params").arraySize; i++)
                            {
                                if (emitterProperty.FindPropertyRelative("Params").GetArrayElementAtIndex(i).FindPropertyRelative("Name").stringValue == paramRef.Name)
                                {
                                    index = i;
                                    set = true;
                                    break;
                                }
                            }
                            EditorGUILayout.BeginHorizontal();
                            EditorGUILayout.PrefixLabel(paramRef.Name);
                            bool newSet = GUILayout.Toggle(set, "");
                            if (!set && newSet)
                            {
                                index = 0;
                                emitterProperty.FindPropertyRelative("Params").InsertArrayElementAtIndex(0);
                                emitterProperty.FindPropertyRelative("Params").GetArrayElementAtIndex(0).FindPropertyRelative("Name").stringValue = paramRef.Name;
                                emitterProperty.FindPropertyRelative("Params").GetArrayElementAtIndex(0).FindPropertyRelative("Value").floatValue = 0;
                            }
                            if (set && !newSet)
                            {
                                emitterProperty.FindPropertyRelative("Params").DeleteArrayElementAtIndex(index);
                            }
                            set = newSet;

                            if (set)
                            {
                                var valueProperty = emitterProperty.FindPropertyRelative("Params")
                                    .GetArrayElementAtIndex(index).FindPropertyRelative("Value");
                                valueProperty.floatValue =
                                    EditorUtils.DrawParameterValueLayout(valueProperty.floatValue, paramRef);
                            }
                            else
                            {
                                using (new EditorGUI.DisabledScope(true))
                                {
                                    EditorUtils.DrawParameterValueLayout(0, paramRef);
                                }
                            }
                            EditorGUILayout.EndHorizontal();
                        }
                    }
                }
                emitterIndex++;
            }
            serializedObject.ApplyModifiedProperties();
        }
    }
}



================================================
FILE: Assets/Plugins/FMOD/src/Editor/StudioParameterTriggerEditor.cs.meta
================================================
fileFormatVersion: 2
guid: dc94d213814ef1a42b0ca8ee00dd4728
timeCreated: 1451968823
licenseType: Free
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: Assets/Plugins/FMOD/src/Editor/zh_hans.po
================================================
﻿msgid ""
msgstr ""
"Project-Id-Version: FMOD for Unity\n"
"POT-Creation-Date: 2024-12-12 11:21+1100\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.5\n"
"X-Poedit-KeywordsList: ;L10n.Tr\n"
"X-Poedit-Basepath: .\n"
"X-Poedit-SearchPath-0: .\n"

#: BankRefreshWindow.cs:29
msgid "FMOD Bank Refresh Status"
msgstr "FMOD 事件库刷新状态"

#: BankRefreshWindow.cs:141
#, csharp-format
msgid "The FMOD source banks changed {0} ago."
msgstr "FMOD 源事件库在 {0} 前发生了更改。"

#: BankRefreshWindow.cs:148
msgid "Refreshing banks now..."
msgstr "正在刷新事件库..."

#: BankRefreshWindow.cs:153
msgid "Refreshing banks"
msgstr "刷新事件库中"

#: BankRefreshWindow.cs:161
msgid "Would you like to refresh banks?"
msgstr "是否刷新事件库？"

#: BankRefreshWindow.cs:168
msgid "The FMOD banks are up to date."
msgstr "FMOD 事件库已是最新。"

#: BankRefreshWindow.cs:172
msgid "Bank refresh failed:"
msgstr "事件库刷新失败："

#: BankRefreshWindow.cs:181
msgid "Closing"
msgstr "关闭中"

#: BankRefreshWindow.cs:190
#, csharp-format
msgid "{0} in {1}..."
msgstr "{0} 在 {1} 内..."

#: BankRefreshWindow.cs:203 EventReferenceUpdater.cs:151
#: EventReferenceUpdater.cs:2055 FileReorganizer.cs:835
msgid "Cancel"
msgstr "取消"

#: BankRefreshWindow.cs:226 SetupWizard.cs:874
msgid "Close"
msgstr "关闭"

#: BankRefreshWindow.cs:231
msgid "Refresh Banks Now"
msgstr "立即刷新事件库"

#: EditorUtils.cs:58
msgid "The FMOD Studio project path must be set to an .fspro file."
msgstr "FMOD Studio 项目路径必须设置为 .fspro 文件。"

#: EditorUtils.cs:64
#, csharp-format
msgid "The FMOD Studio project path '{0}' does not exist."
msgstr "FMOD Studio 项目路径 '{0}' 不存在。"

#: EditorUtils.cs:77
#, csharp-format
msgid "The FMOD Studio project '{0}' does not contain any built banks. Please build your project in FMOD Studio."
msgstr "FMOD Studio 项目 '{0}' 不包含任何已构建的事件库。请在 FMOD Studio 中构建您的项目。"

#: EditorUtils.cs:86
msgid "The build path has not been set."
msgstr "构建路径尚未设置。"

#: EditorUtils.cs:92
#, csharp-format
msgid "The build path '{0}' does not exist."
msgstr "构建路径 '{0}' 不存在。"

#: EditorUtils.cs:101
#, csharp-format
msgid "Build path '{0}' does not contain any platform sub-directories. Please check that the build path is correct."
msgstr "构建路径 '{0}' 不包含任何平台子目录。请检查构建路径是否正确。"

#: EditorUtils.cs:110
#, csharp-format
msgid "Build path '{0}' does not contain any built banks."
msgstr "构建路径 '{0}' 不包含任何已构建的事件库。"

#: EditorUtils.cs:155
msgid "hour"
msgstr "小时"

#: EditorUtils.cs:155
msgid "hours"
msgstr "小时"

#: EditorUtils.cs:159
msgid "minute"
msgstr "分钟"

#: EditorUtils.cs:159
msgid "minutes"
msgstr "分钟"

#: EditorUtils.cs:163
msgid "second"
msgstr "秒"

#: EditorUtils.cs:163
msgid "seconds"
msgstr "秒"

#: EditorUtils.cs:167
msgid "a moment"
msgstr "片刻"

#: EditorUtils.cs:270
msgid "Legacy Event"
msgstr "旧版事件"

#: EditorUtils.cs:275 EventRefDrawer.cs:476
#, csharp-format
msgid "Will be migrated to <b>{0}</b>"
msgstr "将迁移到 <b>{0}</b>"

#: EditorUtils.cs:688
#, csharp-format
msgid ""
"Version: {0}\n"
"Build Number: {1}\n"
"\n"
"Copyright © Firelight Technologies Pty, Ltd. 2014-2026 \n"
"\n"
"See LICENSE.TXT for additional license information."
msgstr ""
"版本号: {0}\n"
"构建编号: {1}\n"
"\n"
"版权所有 © Firelight Technologies Pty, Ltd. 2014-2026 \n"
"\n"
"有关更多许可信息，请参见 LICENSE.TXT。"

#: EditorUtils.cs:692
msgid "FMOD Studio Unity Integration"
msgstr "FMOD Studio Unity 集成"

#: EditorUtils.cs:1028
msgid "Name Conflict"
msgstr "名称冲突"

#: EditorUtils.cs:1028
#, csharp-format
msgid "The event {0} already exists under {1}"
msgstr "事件 {0} 已经存在于 {1} 下"

#: EditorUtils.cs:1387
msgid "Disable Existing Native Libraries"
msgstr "禁用现有的原生库"

#: EditorUtils.cs:1388
msgid "Disable the existing FMOD native libraries so that Unity will not load them at startup time."
msgstr "禁用现有的 FMOD 原生库，以防 Unity 在启动时加载它们。"

#: EditorUtils.cs:1400
#, csharp-format
msgid "This will disable these native libraries:{0}"
msgstr "这将禁用以下原生库：{0}"

#: EditorUtils.cs:1423
msgid "Restart Unity"
msgstr "重启 Unity"

#: EditorUtils.cs:1424
msgid "Restart Unity so that it releases its lock on the existing FMOD native libraries."
msgstr "重启 Unity 以释放其对现有 FMOD 原生库的锁定。"

#: EditorUtils.cs:1426
msgid "This will restart Unity. You will be prompted to save your work if you have unsaved scene modifications."
msgstr "这将重启 Unity。系统将会提示您保存你的工作，如果你有未保存的场景修改。"

#: EditorUtils.cs:1438
msgid "Copy New Native Libraries"
msgstr "复制新的原生库"

#: EditorUtils.cs:1439
msgid "Copy the new FMOD native libraries to the correct location and enable them."
msgstr "将新的 FMOD 原生库复制到正确的位置并启用它们。"

#: EditorUtils.cs:1468
#, csharp-format
msgid ""
"This will do the following:\n"
"* {0}"
msgstr ""
"这将执行以下操作:\n"
"* {0}"

#: EventBrowser.cs:263
msgid "Events"
msgstr "事件"

#: EventBrowser.cs:266
msgid "Snapshots"
msgstr "快照"

#: EventBrowser.cs:272 EventBrowser.cs:917 EventRefDrawer.cs:156
#: StudioBankLoaderEditor.cs:30
msgid "Banks"
msgstr "事件库"

#: EventBrowser.cs:277 EventBrowser.cs:1249
msgid "Global Parameters"
msgstr "全局参数"

#: EventBrowser.cs:492
msgid "New FMOD Studio Emitter"
msgstr "新 FMOD Studio Emitter"

#: EventBrowser.cs:496
msgid "New FMOD Studio Bank Loader"
msgstr "新增 Studio Bank Loader"

#: EventBrowser.cs:500
msgid "New FMOD Studio Global Parameter Trigger"
msgstr "新 FMOD Studio Global Parameter Trigger"

#: EventBrowser.cs:915 EventBrowser.cs:935 EventBrowser.cs:942
msgid "Full Path"
msgstr "完整路径"

#: EventBrowser.cs:920 EventRefDrawer.cs:161
msgid "Panning"
msgstr "声像"

#: EventBrowser.cs:921 EventRefDrawer.cs:171
msgid "Oneshot"
msgstr "一次性"

#: EventBrowser.cs:924
msgid "Length"
msgstr "长度"

#: EventBrowser.cs:926 EventBrowser.cs:928
msgid "Streaming"
msgstr "流式传输"

#: EventBrowser.cs:946
msgid "Platform Bank Sizes"
msgstr "平台事件库大小"

#: EventBrowser.cs:971
msgid "Name"
msgstr "名称"

#: EventBrowser.cs:974
msgid "Minimum"
msgstr "最小值"

#: EventBrowser.cs:975
msgid "Maximum"
msgstr "最大值"

#: EventBrowser.cs:1083
msgid "Show Event in FMOD Studio"
msgstr "在 FMOD Studio 中显示事件"

#: EventBrowser.cs:1566
msgid "Path"
msgstr "路径"

#: EventBrowser.cs:1682
msgid "Add Studio Event Emitter"
msgstr "新增 Studio Event Emitter"

#: EventBrowser.cs:1692
msgid "Add Studio Bank Loader"
msgstr "新增 Studio Bank Loader"

#: EventBrowser.cs:1700
msgid "Add Studio Global Parameter Trigger"
msgstr "新增 Studio Global Parameter Triggerr"

#: EventBrowser.cs:1735
msgid "Create Studio Event Emitter"
msgstr "新建 Studio Event Emitter"

#: EventBrowser.cs:1745
msgid "Create Studio Bank Loader"
msgstr "新建 Studio Bank Loader"

#: EventBrowser.cs:1756
msgid "Create Studio Global Parameter Trigger"
msgstr "新建 Studio Global Parameter Triggerr"

#: EventRefDrawer.cs:14
msgid "Event Not Found"
msgstr "未找到事件"

#: EventRefDrawer.cs:77
msgid "Search"
msgstr "搜寻"

#: EventRefDrawer.cs:90
msgid "Create New Event in Studio"
msgstr "在 Studio 里创建新事件"

#: EventRefDrawer.cs:103
msgid "Open In Browser"
msgstr "在浏览器里打开"

#: EventRefDrawer.cs:146
msgid "Copy To Clipboard"
msgstr "复制到剪贴板"

#: EventRefDrawer.cs:166 SettingsEditor.cs:49
msgid "Stream"
msgstr "流"

#: EventRefDrawer.cs:185
#, csharp-format
msgid "Moved to {0}"
msgstr "移动到 {0}"

#: EventRefDrawer.cs:187
#, csharp-format
msgid ""
"This event has been moved in FMOD Studio.\n"
"You can click the repair button to update the path to the new location, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."
msgstr ""
"此事件在 FMOD Studio 中已被移动。\n"
"您可以点击修复按钮来更新路径到新位置，或者运行 <b>{0}</b> 命令来扫描您的项目中类似的问题并全部修复。"

#: EventRefDrawer.cs:189
#, csharp-format
msgid "Repair: set path to {0}"
msgstr "修复：将路径设置为 {0}"

#: EventRefDrawer.cs:287
msgid "GUID doesn't match path"
msgstr "GUID 与路径不匹配"

#: EventRefDrawer.cs:289
#, csharp-format
msgid ""
"The GUID on this EventReference doesn't match the path.\n"
"You can click the repair button to update the GUID to match the path, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."
msgstr ""
"此 EventReference 上的 GUID 与路径不匹配。\n"
"您可以点击修复按钮来更新 GUID 以匹配路径，或者运行 <b>{0}</b> 命令扫描项目中的类似问题并全部修复。"

#: EventRefDrawer.cs:291
#, csharp-format
msgid "Repair: set GUID to {0}"
msgstr "修复：将GUID设置为 {0}"

#: EventRefDrawer.cs:303
msgid "Path doesn't match GUID"
msgstr "路径与 GUID 不匹配"

#: EventRefDrawer.cs:305
#, csharp-format
msgid ""
"The path on this EventReference doesn't match the GUID.\n"
"You can click the repair button to update the path to match the GUID, or run the <b>{0}</b> command to scan your project for similar issues and fix them all."
msgstr ""
"此 EventReference 上的路径与 GUID 不匹配。\n"
"您可以点击修复按钮来更新路径以匹配 GUID，或者运行 <b>{0}</b> 命令扫描项目中的类似问题并全部修复。"

#: EventRefDrawer.cs:307
#, csharp-format
msgid "Repair: set path to '{0}'"
msgstr "修复：将路径设置为 '{0}'"

#: EventRefDrawer.cs:411
#, csharp-format
msgid ""
"This field has the <b>[EventRef]</b> attribute, which is obsolete.\n"
"To resolve this issue:\n"
"* Add a field of type <b>EventReference</b> to this class\n"
"Set the <b>MigrateTo</b> property on the <b>[EventRef]</b> attribute: <b>[EventRef(MigrateTo=\"<fieldname>\")]</b>\n"
" Run the <b>{0}</b> command to automatically migrate values from this field to the <b>EventReference</b> field"
msgstr ""
"此字段具有 <b>[EventRef]</b> 属性，该属性已过时。\n"
"要解决此问题：\n"
"* 在此类中添加一个类型为 <b>EventReference</b> 的字段\n"
"* 在 <b>[EventRef]</b> 属性上设置 <b>MigrateTo</b> 属性：<b>[EventRef(MigrateTo=\"<fieldname>\")]</b>\n"
" 运行 <b>{0}</b> 命令以自动将此字段中的值迁移到 <b>EventReference</b> 字段"

#: EventRefDrawer.cs:459
msgid "<b>[EventRef]</b> is obsolete - use the <b>EventReference</b> type instead."
msgstr "<b>[EventRef]</b> 已过时 - 请改用 <b>EventReference</b> 类型。"

#: EventRefDrawer.cs:481
#, csharp-format
msgid "Migration target <b>{0}</b> is missing"
msgstr "迁移目标 <b>{0}</b> 丢失"

#: EventReferenceUpdater.cs:27
msgid "Click Scan to search your project for obsolete event references."
msgstr "点击扫描搜索该项目中的过时事件引用。"

#: EventReferenceUpdater.cs:66
msgid "Asset"
msgstr "资产"

#: EventReferenceUpdater.cs:67
msgid "Component Type"
msgstr "组件类型"

#: EventReferenceUpdater.cs:68
msgid "Game Object"
msgstr "游戏对象"

#: EventReferenceUpdater.cs:72
#, csharp-format
msgid "Execute {0} Selected Tasks"
msgstr "执行 {0} 个已选择的任务"

#: EventReferenceUpdater.cs:78
msgid "FMOD Event Reference Updater"
msgstr "FMOD 事件引用更新器"

#: EventReferenceUpdater.cs:112
msgid "No required tasks found. Event references are up to date."
msgstr "未找到所需任务。事件引用已是最新。"

#: EventReferenceUpdater.cs:120
msgid "Finished executing tasks. New tasks may now be required. Please re-scan your project."
msgstr "任务执行完毕。现在可能会有新的任务需要被执行。请重新扫描您的项目。。"

#: EventReferenceUpdater.cs:124
msgid "Finished scanning. Please execute the tasks above."
msgstr "扫描完成。请执行上方的任务。"

#: EventReferenceUpdater.cs:129
msgid "Cancelled."
msgstr "已取消。"

#: EventReferenceUpdater.cs:148
#, csharp-format
msgid ""
"Executing these {0} tasks will change {1} prefabs and {2} scenes on disk.\n"
"\n"
"Please ensure you have committed any outstanding changes to source control before continuing!"
msgstr ""
"执行这 {0} 项任务将更改磁盘上的 {1} 个预制体和 {2} 个场景。\n"
"\n"
"在继续之前，请确保您已提交任何未完成的更改到版本控制中！"

#: EventReferenceUpdater.cs:151
msgid "Confirm Bulk Changes"
msgstr "确认批量更改"

#: EventReferenceUpdater.cs:224 EventReferenceUpdater.cs:252
#: EventReferenceUpdater.cs:294
#, csharp-format
msgid "Searching {0}"
msgstr "正在搜索 {0}"

#: EventReferenceUpdater.cs:739
#, csharp-format
msgid "Executing: {0}"
msgstr "执行 {0} 中"

#: EventReferenceUpdater.cs:1011 EventReferenceUpdater.cs:1125
#, csharp-format
msgid "Clear <b>'{0}'</b> from the <b>{1}</b> field"
msgstr "从 <b>{1}</b> 字段中清除 <b>‘{0}’</b>"

#: EventReferenceUpdater.cs:1026 EventReferenceUpdater.cs:1140
#: EventReferenceUpdater.cs:1223
#, csharp-format
msgid "Move <b>'{0}'</b> from <b>{1}</b> to <b>{2}</b>"
msgstr "将 <b>‘{0}’</b> 从 <b>{1}</b> 移动到 <b>{2}</b>"

#: EventReferenceUpdater.cs:1051
#, csharp-format
msgid "Move prefab override <b>'{0}'</b> from <b>{1}</b> to <b>{2}</b>"
msgstr "将预制体覆盖 <b>‘{0}’</b> 从 <b>{1}</b> 移动到 <b>{2}</b>"

#: EventReferenceUpdater.cs:1166
#, csharp-format
msgid "Remove field <b>{0}</b>"
msgstr "移除字段 <b>{0}</b>"

#: EventReferenceUpdater.cs:1177
#, csharp-format
msgid ""
"The {0} field on component {1} has value '{2}', but the corresponding EventReference field already has a value.\n"
"* Ensure no other instances of the {3} type are using the {4} field\n"
"* Edit the definition of the {3} type and remove the {4} field"
msgstr ""
"组件 {1} 上的 {0} 字段的值为‘{2}’，但对应的 EventReference 字段已经有值。\n"
"* 确保没有其他 {3} 类型的实例在使用 {4} 字段\n"
"* 编辑 {3} 类型的定义并移除 {4} 字段"

#: EventReferenceUpdater.cs:1192
#, csharp-format
msgid "Remove empty field <b>{0}</b>"
msgstr "移除空字段 <b>{0}</b>"

#: EventReferenceUpdater.cs:1202
#, csharp-format
msgid ""
"The {0} field on component {1} is empty.\n"
"* Ensure no other instances of the {2} type are using the {3} field\n"
"* Edit the definition of the {2} type and remove the {3} field"
msgstr ""
"组件 {1} 上的 {0} 字段为空。\n"
"* 确保没有其他 {2} 类型的实例在使用 {3} 字段\n"
"* 编辑 {2} 类型的定义并移除 {3} 字段"

#: EventReferenceUpdater.cs:1286
#, csharp-format
msgid "Add an <b>EventReference</b> field named <b>{0}</b> to hold <b>'{1}'</b> from <b>{2}</b>"
msgstr "添加一个名为 <b>{0}</b> 的 <b>EventReference</b> 字段，用于保存来源于 <b>{2}</b> 的 <b>‘{1}’</b>"

#: EventReferenceUpdater.cs:1291
#, csharp-format
msgid "Add an <b>EventReference</b> field to hold <b>'{0}'</b> from <b>{1}</b>"
msgstr "添加一个 <b>EventReference</b> 字段，用于保存来源于 <b>{1}</b> 的 <b>‘{0}’</b>"

#: EventReferenceUpdater.cs:1305
#, csharp-format
msgid "the definition of the {0} type"
msgstr "{0} 类型的定义"

#: EventReferenceUpdater.cs:1315
#, csharp-format
msgid ""
"The {0} field on component {1} has an [EventRef(MigrateTo=\"{2}\")] attribute, but the {2} field doesn't exist.\n"
"* Edit {3} and add an EventReference field named {2}:\n"
"    public EventReference {2};\n"
"* Re-scan your project"
msgstr ""
"组件 {1} 上的 {0} 字段具有 [EventRef(MigrateTo=\"{2}\")] 属性，但 {2} 字段不存在。\n"
"* 编辑 {3} 并添加一个名为 {2} 的 EventReference 字段：\n"
"    public EventReference {2};\n"
"* 重新扫描您的项目"

#: EventReferenceUpdater.cs:1321
#, csharp-format
msgid ""
"The {0} field on component {1} has an [EventRef] attribute with no migration target specified.\n"
"* Edit {2} and add an EventReference field:\n"
"    public EventReference <fieldname>;\n"
"* Change the [EventRef] attribute on the {3} field to:\n"
"    [EventRef(MigrateTo=\"<fieldname>\")]\n"
"* Re-scan your project."
msgstr ""
"组件 {1} 上的 {0} 字段具有 [EventRef] 属性，但未指定迁移目标。\n"
"* 编辑 {2} 并添加一个 EventReference 字段：\n"
"    public EventReference <字段名>;\n"
"* 将 {3} 字段上的 [EventRef] 属性更改为：\n"
" [EventRef(MigrateTo=\"<fieldname>\")]\n"
"* 重新扫描您的项目。"

#: EventReferenceUpdater.cs:1342
#, csharp-format
msgid "Change the path on field <b>{0}</b> from <b>'{1}'</b> to <b>'{2}'</b> (to match GUID <b>{3}</b>)"
msgstr "将字段 <b>{0}</b> 的路径从 <b>‘{1}’</b> 更改为 <b>‘{2}’</b>（以匹配 GUID <b>{3}</b>）"

#: EventReferenceUpdater.cs:1377
#, csharp-format
msgid "Change the GUID on field <b>{0}</b> from <b>{1}</b> to <b>{2}</b> (to match path <b>'{3}'</b>)"
msgstr "将字段 <b>{0}</b> 的 GUID 从 <b>‘{1}’</b> 更改为 <b>‘{2}’</b>（以匹配 路径 <b>{3}</b>）"

#: EventReferenceUpdater.cs:1414
#, csharp-format
msgid "Fix conflicting migration targets on fields <b>{0}</b>"
msgstr "修复字段 <b>{0}</b> 上的迁移目标冲突"

#: EventReferenceUpdater.cs:1415
msgid "</b> and <b>"
msgstr "</b> 以及 <b>"

#: EventReferenceUpdater.cs:1419
#, csharp-format
msgid ""
"Fields {0} on the {1} type have [EventRef] attributes with the same MigrateTo value.\n"
"* Edit the definition of the {1} type and make sure all [EventRef] attributes have different MigrateTo values\n"
"* Re-scan your project"
msgstr ""
"{1} 类型中的字段 {0} 具有相同的 [EventRef] 属性 MigrateTo 值。\n"
"* 编辑 {1} 类型的定义，确保所有 [EventRef] 属性具有不同的 MigrateTo 值\n"
"* 重新扫描您的项目"

#: EventReferenceUpdater.cs:1420
msgid " and "
msgstr " 以及 "

#: EventReferenceUpdater.cs:1997
msgid "Open "
msgstr "打开 "

#: EventReferenceUpdater.cs:2008
msgid "View Documentation"
msgstr "查看文档"

#: EventReferenceUpdater.cs:2028
msgid "Execute"
msgstr "执行"

#: EventReferenceUpdater.cs:2045 FindAndReplace.cs:72
msgid "Prefabs"
msgstr "预制体"

#: EventReferenceUpdater.cs:2046
msgid "ScriptableObjects"
msgstr "可编程对象"

#: EventReferenceUpdater.cs:2047
msgid "Scenes"
msgstr "场景"

#: EventReferenceUpdater.cs:2062
msgid "Scan"
msgstr "扫描"

#: EventReferenceUpdater.cs:2133 StudioParameterTriggerEditor.cs:36
msgid "Target"
msgstr "目标"

#: EventReferenceUpdater.cs:2140
msgid "Task"
msgstr "任务"

#: EventReferenceUpdater.cs:2147 FileReorganizer.cs:308
msgid "Status"
msgstr "状态"

#: EventReferenceUpdater.cs:2219
msgid "No tasks."
msgstr "无任务。"

#: EventReferenceUpdater.cs:2392
msgid " on"
msgstr " 在"

#: EventReferenceUpdater.cs:2424
msgid "Manual task: "
msgstr "手动任务：\t"

#: EventReferenceUpdater.cs:2435
msgid "Manual Changes Required"
msgstr "需要手动更改"

#: EventReferenceUpdater.cs:2439
msgid "Complete"
msgstr "完成"

#: EventReferenceUpdater.cs:2439 FileReorganizer.cs:689
msgid "Pending"
msgstr "待处理"

#: FileReorganizer.cs:43
msgid "FMOD File Reorganizer"
msgstr "FMOD 文件重组器"

#: FileReorganizer.cs:68
#, csharp-format
msgid ""
"{0} will be moved to\n"
"{1}"
msgstr ""
"{0} 将被移动到\n"
"{1}"

#: FileReorganizer.cs:78
#, csharp-format
msgid "{0} will be removed if it is empty"
msgstr "如果 {0} 为空，将被移除"

#: FileReorganizer.cs:90
#, csharp-format
msgid ""
"{0} is missing.\n"
"You may need to reinstall the {1} support package from {2}."
msgstr ""
"未找到 {0}。\n"
"您可能需要从 {2} 重新安装 {1} 支持包。"

#: FileReorganizer.cs:102
#, csharp-format
msgid "{0} will be removed"
msgstr "{0} 将被移除"

#: FileReorganizer.cs:231
msgid "There is a file missing. Select it above for more information."
msgstr "有文件丢失。请在上方选择以获取更多信息。"

#: FileReorganizer.cs:236
#, csharp-format
msgid "There are {0} files missing. Select them above for more information."
msgstr "有 {0} 个文件丢失。请在上方选择以获取更多信息。"

#: FileReorganizer.cs:301
msgid "Task #"
msgstr "任务编号"

#: FileReorganizer.cs:314
msgid "Platform"
msgstr "平台"

#: FileReorganizer.cs:321
msgid "Description"
msgstr "描述"

#: FileReorganizer.cs:364
msgid "Nothing to do here."
msgstr "无需要处理的内容。"

#: FileReorganizer.cs:598
msgid "if empty"
msgstr "如果为空"

#: FileReorganizer.cs:667 StudioEventEmitterEditor.cs:342
msgid "Remove"
msgstr "移除"

#: FileReorganizer.cs:690
msgid "Succeeded"
msgstr "成功"

#: FileReorganizer.cs:691
msgid "Failed"
msgstr "失败"

#: FileReorganizer.cs:692
msgid "Missing"
msgstr "丢失"

#: FileReorganizer.cs:842
msgid "Refresh"
msgstr "刷新"

#: FileReorganizer.cs:853
#, csharp-format
msgid "Processing Task {0} of {1}"
msgstr "正在处理任务 {0}/{1}"

#: FileReorganizer.cs:859
#, csharp-format
msgid "Process {0} Tasks"
msgstr "处理 {0} 个任务"

#: FileReorganizer.cs:1286
#, csharp-format
msgid "Moving {0} to {1}"
msgstr "正在将 {0} 移动到 {1}"

#: FileReorganizer.cs:1292
#, csharp-format
msgid ""
"{0} was moved to\n"
"{1}"
msgstr ""
"{0} 已被移动到\n"
"{1}"

#: FileReorganizer.cs:1296
#, csharp-format
msgid ""
"{0} could not be moved to\n"
"{1}: '{2}'"
msgstr ""
"无法将 {0} 移动到\n"
"{1}: '{2}'"

#: FileReorganizer.cs:1317 FileReorganizer.cs:1370
#, csharp-format
msgid "{0} was removed"
msgstr "{0} 被移除"

#: FileReorganizer.cs:1321 FileReorganizer.cs:1374
#, csharp-format
msgid "{0} could not be removed"
msgstr "{0} 无法被移除"

#: FileReorganizer.cs:1350
#, csharp-format
msgid "{0} has already been removed"
msgstr "{0} 已被移除"

#: FileReorganizer.cs:1356
#, csharp-format
msgid "{0} is not a valid folder"
msgstr "{0} 不是有效的文件夹"

#: FileReorganizer.cs:1362
#, csharp-format
msgid "{0} is not empty"
msgstr "{0} 不为空"

#: FileReorganizer.cs:1366
#, csharp-format
msgid "Removing empty folder {0}"
msgstr "正在移除空文件夹 {0}"

#: FindAndReplace.cs:25
msgid "FMOD Find and Replace"
msgstr "FMOD 查找与替换"

#: FindAndReplace.cs:57 FindAndReplace.cs:129
msgid "find"
msgstr "查找"

#: FindAndReplace.cs:58
msgid "Find:"
msgstr "查找 :"

#: FindAndReplace.cs:66
msgid "Replace:"
msgstr "替换 :"

#: FindAndReplace.cs:71
msgid "Current Level"
msgstr "当前场景"

#: FindAndReplace.cs:80
msgid "Find"
msgstr "查找"

#: FindAndReplace.cs:88 FindAndReplace.cs:105
msgid "Finished Search"
msgstr "查找完成"

#: FindAndReplace.cs:92
msgid "Replace"
msgstr "替换"

#: FindAndReplace.cs:109 FindAndReplace.cs:111
msgid "Replace All"
msgstr "替换全部"

#: FindAndReplace.cs:111
msgid "Are you sure you wish to replace all in the current hierachy?"
msgstr "您确定要替换当前层级中的所有内容吗？"

#: FindAndReplace.cs:111
msgid "yes"
msgstr "是"

#: FindAndReplace.cs:111
msgid "no"
msgstr "否"

#: FindAndReplace.cs:142
msgid "Found object"
msgstr "找到的对象"

#: FindAndReplace.cs:161
#, csharp-format
msgid "{0} replaced"
msgstr "已替换 {0}"

#: FindAndReplace.cs:171
msgid "Event"
msgstr "事件"

#: SettingsEditor.cs:17
msgid "Disabled"
msgstr "已禁用"

#: SettingsEditor.cs:17
msgid "Enabled"
msgstr "已启用"

#: SettingsEditor.cs:17
msgid "Development Build Only"
msgstr "仅限开发版本"

#: SettingsEditor.cs:19
msgid "TopLeft"
msgstr "左上角"

#: SettingsEditor.cs:19
msgid "TopCenter"
msgstr "顶部中央"

#: SettingsEditor.cs:19
msgid "TopRight"
msgstr "右上角"

#: SettingsEditor.cs:19
msgid "BottomLeft"
msgstr "左下角"

#: SettingsEditor.cs:19
msgid "BottomCenter"
msgstr "底部中央"

#: SettingsEditor.cs:19
msgid "BottomRight"
msgstr "右下角"

#: SettingsEditor.cs:19
msgid "Center"
msgstr "中央"

#: SettingsEditor.cs:19
msgid "VR"
msgstr "VR"

#: SettingsEditor.cs:22
msgid "Platform Default"
msgstr "平台默认值"

#: SettingsEditor.cs:33
msgid "Stereo"
msgstr "立体声"

#: SettingsEditor.cs:34
msgid "Surround 5.1"
msgstr "环绕声 5.1"

#: SettingsEditor.cs:35
msgid "Surround 7.1"
msgstr "环绕声 7.1"

#: SettingsEditor.cs:36
msgid "Surround 7.1.4"
msgstr "环绕声 7.1.4"

#: SettingsEditor.cs:47
msgid "Mixer"
msgstr "混音器"

#: SettingsEditor.cs:48
msgid "Feeder"
msgstr "馈送器"

#: SettingsEditor.cs:50
msgid "File"
msgstr "文件"

#: SettingsEditor.cs:51
msgid "Nonblocking"
msgstr "非阻塞"

#: SettingsEditor.cs:52
msgid "Record"
msgstr "录音"

#: SettingsEditor.cs:53
msgid "Geometry"
msgstr "几何处理"

#: SettingsEditor.cs:54
msgid "Profiler"
msgstr "性能分析"

#: SettingsEditor.cs:55
msgid "Studio Update"
msgstr "Studio 更新"

#: SettingsEditor.cs:56
msgid "Studio Load Bank"
msgstr "Studio 加载事件库"

#: SettingsEditor.cs:57
msgid "Studio Load Sample"
msgstr "Studio 加载样本"

#: SettingsEditor.cs:58
msgid "Convolution 1"
msgstr "卷积处理1"

#: SettingsEditor.cs:59
msgid "Convolution 2"
msgstr "卷积处理2"

#: SettingsEditor.cs:124 SettingsEditor.cs:139
msgid "None"
msgstr "无"

#: SettingsEditor.cs:125
msgid "Error"
msgstr "错误"

#: SettingsEditor.cs:126
msgid "Warning"
msgstr "警告"

#: SettingsEditor.cs:127
msgid "Log"
msgstr "日志"

#: SettingsEditor.cs:137 StudioEventEmitterEditor.cs:286
msgid "All"
msgstr "全部"

#: SettingsEditor.cs:138
msgid "Specified"
msgstr "指定的事件库"

#: SettingsEditor.cs:149
msgid "Standard"
msgstr "标准"

#: SettingsEditor.cs:150
msgid "SeparateLFE"
msgstr "独立低频通道"

#: SettingsEditor.cs:151
msgid "Positional"
msgstr "位置相关的"

#: SettingsEditor.cs:160
msgid "Refresh Banks"
msgstr "刷新事件库"

#: SettingsEditor.cs:163
msgid "After 1 second"
msgstr "1秒后"

#: SettingsEditor.cs:164
msgid "After 5 seconds"
msgstr "5秒后"

#: SettingsEditor.cs:165
msgid "After 10 seconds"
msgstr "10秒后"

#: SettingsEditor.cs:166
msgid "After 20 seconds"
msgstr "20秒后"

#: SettingsEditor.cs:167
msgid "After 30 seconds"
msgstr "30秒后"

#: SettingsEditor.cs:168
msgid "After 1 minute"
msgstr "1分钟后"

#: SettingsEditor.cs:169
msgid "Prompt Me"
msgstr "提示我"

#: SettingsEditor.cs:170
msgid "Manually"
msgstr "手动"

#: SettingsEditor.cs:230 SettingsEditor.cs:1507 SettingsEditor.cs:1533
msgid "Browse"
msgstr "浏览"

#: SettingsEditor.cs:231
msgid "Add All"
msgstr "添加全部"

#: SettingsEditor.cs:376
msgid "Revert"
msgstr "恢复"

#: SettingsEditor.cs:381
msgid "Revert FMOD Platform Properties"
msgstr "恢复FMOD平台属性"

#: SettingsEditor.cs:449 SettingsEditor.cs:1308
msgid "Auto"
msgstr "自动"

#: SettingsEditor.cs:450
msgid "No Sound"
msgstr "无声"

#: SettingsEditor.cs:451
msgid "Wav Writer"
msgstr "Wav 写入器"

#: SettingsEditor.cs:498 SettingsEditor.cs:850
msgid "Use Defaults"
msgstr "使用默认值"

#: SettingsEditor.cs:527
msgid "Any"
msgstr "任何"

#: SettingsEditor.cs:567
msgid "List is Empty"
msgstr "列表为空"

#: SettingsEditor.cs:576 StudioEventEmitterEditor.cs:283
msgid "Add"
msgstr "添加"

#: SettingsEditor.cs:592
msgid "Threads"
msgstr "线程"

#: SettingsEditor.cs:598
msgid "Cores"
msgstr "核心"

#: SettingsEditor.cs:609
msgid "Edit"
msgstr "编辑"

#: SettingsEditor.cs:703
msgid "Delete"
msgstr "删除"

#: SettingsEditor.cs:824
msgid "Edit Codec Channels"
msgstr "编辑编解码通道"

#: SettingsEditor.cs:914
msgid "Output sub-directory:"
msgstr "输出子目录:"

#: SettingsEditor.cs:915
msgid "Surround speaker mode:"
msgstr "环绕声扬声器模式:"

#: SettingsEditor.cs:1000 SettingsEditor.cs:1028
msgid "Edit FMOD Platform Settings"
msgstr "编辑FMOD平台属性"

#: SettingsEditor.cs:1041
msgid "Select the output sub-directory and surround speaker mode that match the project platform settings in the FMOD Studio build preferences."
msgstr "选择与 FMOD Studio 构建首选项中的项目平台设置相匹配的输出子目录和环绕扬声器模式。"

#: SettingsEditor.cs:1047
msgid "Select the speaker mode that matches the project platform settings in the FMOD Studio build preferences."
msgstr "选择与 FMOD Studio 构建首选项中的项目平台设置相匹配的扬声器模式。"

#: SettingsEditor.cs:1106
msgid "Reset"
msgstr "重置"

#: SettingsEditor.cs:1148
msgid "Live Update"
msgstr "实时更新"

#: SettingsEditor.cs:1152
msgid "Live Update Port"
msgstr "实时更新端口"

#: SettingsEditor.cs:1155
msgid "Debug Overlay"
msgstr "调试覆盖层"

#: SettingsEditor.cs:1158
msgid "Debug Location"
msgstr "调试位置"

#: SettingsEditor.cs:1159
msgid "Font size"
msgstr "字体大小"

#: SettingsEditor.cs:1162
msgid "Output Mode"
msgstr "输出模式"

#: SettingsEditor.cs:1163
msgid "Sample Rate"
msgstr "采样率"

#: SettingsEditor.cs:1167
msgid "Project Platform"
msgstr "项目平台"

#: SettingsEditor.cs:1171
msgid "Speaker Mode"
msgstr "扬声器模式"

#: SettingsEditor.cs:1174
msgid "Callback Handler"
msgstr "回调处理程序"

#: SettingsEditor.cs:1176
msgid "Virtual Channel Count"
msgstr "虚拟声道数量"

#: SettingsEditor.cs:1177
msgid "Real Channel Count"
msgstr "实际声道数量"

#: SettingsEditor.cs:1179
msgid "Codec Counts"
msgstr "编解码器计数"

#: SettingsEditor.cs:1192
msgid "Only supported on the IL2CPP scripting backend"
msgstr "仅支持 IL2CPP 脚本后端"

#: SettingsEditor.cs:1195
msgid "Static Plugins"
msgstr "静态插件"

#: SettingsEditor.cs:1197
msgid "Dynamic Plugins"
msgstr "动态插件"

#: SettingsEditor.cs:1199
msgid "Thread Affinity"
msgstr "线程亲和性"

#: SettingsEditor.cs:1214
msgid "platform group"
msgstr "平台组"

#: SettingsEditor.cs:1218
msgid "built-in platform"
msgstr "内置平台"

#: SettingsEditor.cs:1222
msgid "platform"
msgstr "平台"

#: SettingsEditor.cs:1232
msgid "inheriting from Unity build target: "
msgstr "继承自 Unity 构建目标："

#: SettingsEditor.cs:1243
msgid "inheriting from"
msgstr "继承自"

#: SettingsEditor.cs:1290
msgid "DSP Buffer Settings"
msgstr "DSP 缓冲设置"

#: SettingsEditor.cs:1345
msgid "DSP Buffer Length"
msgstr "DSP 缓冲区长度"

#: SettingsEditor.cs:1346
msgid "DSP Buffer Count"
msgstr "DSP 缓冲区数量"

#: SettingsEditor.cs:1384
msgid "FMOD Settings"
msgstr "FMOD 设置"

#: SettingsEditor.cs:1463
msgid "Bank Import"
msgstr "导入事件库"

#: SettingsEditor.cs:1489
msgid "Source Type"
msgstr "源类型"

#: SettingsEditor.cs:1498
msgid "Studio Project Path"
msgstr "项目路径"

#: SettingsEditor.cs:1531
msgid "Build Path"
msgstr "构建路径"

#: SettingsEditor.cs:1586
msgid ""
"\n"
"\n"
"For detailed setup instructions, please see the FMOD/Help/Getting Started menu item."
msgstr ""
"\n"
"\n"
"有关详细的设置说明, 请参见 FMOD/Help/Getting Started menu item."

#: SettingsEditor.cs:1594 SetupWizard.cs:512
msgid "Choose how to access your FMOD Studio content:"
msgstr "选择如何访问您的 FMOD Studio 内容："

#: SettingsEditor.cs:1597 SetupWizard.cs:527
msgid "FMOD Studio Project"
msgstr "FMOD Studio 项目"

#: SettingsEditor.cs:1598
msgid "If you have the complete FMOD Studio project."
msgstr "如果您拥有完整的 FMOD Studio 项目。"

#: SettingsEditor.cs:1600 SetupWizard.cs:538
msgid "Single Platform Build"
msgstr "单平台构建"

#: SettingsEditor.cs:1601
msgid "If you have the contents of the <b>Build</b> folder for a single platform."
msgstr "如果您拥有单平台的<b>构建</b>文件夹内容。"

#: SettingsEditor.cs:1603 SetupWizard.cs:550
msgid "Multiple Platform Build"
msgstr "多平台构建"

#: SettingsEditor.cs:1604
msgid "If you have the contents of the <b>Build</b> folder for multiple platforms, with each platform in its own subdirectory."
msgstr "如果您拥有多个平台的<b>构建</b>文件夹内容，并且每个平台在其各自的子目录中。"

#: SettingsEditor.cs:1687
msgid "Streaming Asset"
msgstr "流媒体资产"

#: SettingsEditor.cs:1687
msgid "Asset Bundle"
msgstr "资产包"

#: SettingsEditor.cs:1690
msgid "Import Type"
msgstr "导入类型"

#: SettingsEditor.cs:1695
msgid "FMOD Bank Import Type Changed"
msgstr "FMOD 事件库的导入类型发生变化"

#: SettingsEditor.cs:1696
#, csharp-format
msgid "Do you want to delete the {0} banks in {1} "
msgstr "您确定要删除位于 {1} 的 {0} 事件库吗？"

#: SettingsEditor.cs:1697
msgid "Yes"
msgstr "是"

#: SettingsEditor.cs:1697
msgid "No"
msgstr "否"

#: SettingsEditor.cs:1716
msgid "FMOD Asset Sub Folder"
msgstr "FMOD 资产子文件夹"

#: SettingsEditor.cs:1721
msgid "FMOD Bank Sub Folder"
msgstr "FMOD 事件库子文件夹"

#: SettingsEditor.cs:1735
msgid "Event Linkage"
msgstr "事件连接方式"

#: SettingsEditor.cs:1740
msgid "Behavior"
msgstr "行为"

#: SettingsEditor.cs:1745
msgid "Stop Events Outside Max Distance"
msgstr "停止超出最大距离的事件"

#: SettingsEditor.cs:1752
msgid "User Interface"
msgstr "用户界面"

#: SettingsEditor.cs:1758
msgid "Meter Channel Ordering"
msgstr "计量声道顺序"

#: SettingsEditor.cs:1771
msgid "Initialization"
msgstr "初始化"

#: SettingsEditor.cs:1775
msgid "Logging Level"
msgstr "日志级别"

#: SettingsEditor.cs:1779
msgid "Enable API Error Logging"
msgstr "启用 API 错误日志记录"

#: SettingsEditor.cs:1781
msgid "Enable Memory Tracking"
msgstr "启用内存追踪"

#: SettingsEditor.cs:1785
msgid "Load Banks"
msgstr "加载事件库"

#: SettingsEditor.cs:1805
msgid "Load Bank Sample Data"
msgstr "加载事件库样本数据"

#: SettingsEditor.cs:1808
msgid "Bank Encryption Key"
msgstr "事件库加密密钥"

#: SettingsEditor.cs:1816
msgid "Specified Banks"
msgstr "指定的事件库"

#: SettingsEditor.cs:1830
msgid "Locate Bank"
msgstr "定位事件库"

#: SettingsEditor.cs:1895
msgid "Platform Specific"
msgstr "平台设置"

#: SettingsEditor.cs:2046 SettingsEditor.cs:2089
msgid "New Group"
msgstr "新建组"

#: SettingsEditor.cs:2200
msgid "Double-click to rename"
msgstr "双击重命名"

#: SettingsEditor.cs:2362
msgid "Change FMOD Platform Inheritance"
msgstr "更改 FMOD 平台继承"

#: SettingsEditor.cs:2421 SettingsEditor.cs:2438
msgid "Set FMOD Platform Inheritance"
msgstr "设置 FMOD 平台继承"

#: SettingsEditor.cs:2691
msgid "Show Status Window"
msgstr "显示状态窗口"

#: SettingsEditor.cs:2713
msgid "Locate Studio Project"
msgstr "定位 Studio 项目"

#: SettingsEditor.cs:2739
msgid "Locate Build Folder"
msgstr "定位构建文件夹"

#: SetupWizard.cs:19
msgid "Welcome"
msgstr "欢迎"

#: SetupWizard.cs:20
msgid "Updating"
msgstr "更新"

#: SetupWizard.cs:21
msgid "Linking"
msgstr "连接"

#: SetupWizard.cs:22
msgid "Listener"
msgstr "监听器"

#: SetupWizard.cs:23
msgid "Unity Audio"
msgstr "Unity音频"

#: SetupWizard.cs:24
msgid "Unity Sources"
msgstr "Unity音频源"

#: SetupWizard.cs:25
msgid "Source Control"
msgstr "版本控制"

#: SetupWizard.cs:26
msgid "End"
msgstr "完成"

#: SetupWizard.cs:34
msgid "Reorganize Plugin Files"
msgstr "重新组织插件文件"

#: SetupWizard.cs:35
msgid "Move FMOD for Unity files to match the latest layout."
msgstr "移动 FMOD for Unity 文件以匹配最新布局。"

#: SetupWizard.cs:41
msgid "Update Event References"
msgstr "更新事件引用"

#: SetupWizard.cs:42
msgid "Find event references that use the obsolete [EventRef] attribute and update them to use the EventReference type."
msgstr "查找使用过时的 [EventRef] 属性的事件引用并将它们更新为使用 EventReference 类型。"

#: SetupWizard.cs:210
msgid "FMOD Setup Wizard"
msgstr "FMOD 设置向导"

#: SetupWizard.cs:325
msgid "Do not display this again"
msgstr "不再显示此消息"

#: SetupWizard.cs:420 SetupWizard.cs:895
#, csharp-format
msgid "Welcome to FMOD for Unity {0}."
msgstr "欢迎来到 FMOD for Unity {0}。"

#: SetupWizard.cs:427
msgid "This setup wizard will help you configure your project to use FMOD."
msgstr "此设置向导将帮助您配置项目以使用 FMOD。"

#: SetupWizard.cs:463
msgid "If you are updating an existing FMOD installation, you may need to perform some update tasks."
msgstr "如果您正在更新已安装的FMOD，您可能需要执行一些更新任务。"

#: SetupWizard.cs:467
msgid "Choose an update task to perform:"
msgstr "选择要执行的更新任务:"

#: SetupWizard.cs:509
msgid "In order to access your FMOD Studio content you need to locate the FMOD Studio Project or the .bank files that FMOD Studio produces, and configure a few other settings."
msgstr "要访问您的 FMOD Studio 内容，您需要找到 FMOD Studio 项目或 FMOD Studio 生成的 .bank 文件，并配置一些其他设置。"

#: SetupWizard.cs:531
msgid "If you have the complete FMOD Studio Project."
msgstr "如果您拥有完整的 FMOD Studio 项目。"

#: SetupWizard.cs:542
msgid "If you have the contents of the Build folder for a single platform."
msgstr "如果您拥有单平台的构建文件夹内容。"

#: SetupWizard.cs:554
msgid "If you have the contents of the Build folder for multiple platforms, with each platform in its own subdirectory."
msgstr "如果您拥有多平台的构建文件夹内容，且每个平台都有自己的子目录。"

#: SetupWizard.cs:581
msgid "Using the FMOD Studio project at:"
msgstr "使用 FMOD Studio 项目于："

#: SetupWizard.cs:586
msgid "Using the multiple platform build at:"
msgstr "使用多平台 Build 于："

#: SetupWizard.cs:591
msgid "Using the single platform build at:"
msgstr "使用单平台构建于："

#: SetupWizard.cs:607
msgid "If you do not intend to use the built in Unity audio, you can choose to replace the Audio Listener with the FMOD Studio Listener.\n"
msgstr "如果您不打算使用内置的 Unity 音频，您可以选择将 Audio 监听替换为 FMOD Studio 监听器。\n"

#: SetupWizard.cs:608
msgid "Adding the FMOD Studio Listener component to the main camera provides the FMOD Engine with the information it needs to play 3D events correctly."
msgstr "将 FMOD Studio 监听器组件添加到主摄像机中，可以为 FMOD 引擎提供正确播放 3D 事件所需的信息。"

#: SetupWizard.cs:631
msgid "Replace Unity Listener(s) with FMOD Audio Listener."
msgstr "将 Unity 监听器替换成 FMOD 监听器。"

#: SetupWizard.cs:669 SetupWizard.cs:693
msgid " Listener(s) found: "
msgstr "监听器数量："

#: SetupWizard.cs:703
msgid "We recommend that you disable the built-in Unity audio for all platforms, to prevent it from consuming system audio resources that the FMOD Engine needs."
msgstr "我们建议您为所有平台禁用内置的 Unity 音频，以防止它消耗 FMOD 引擎所需的系统音频资源。"

#: SetupWizard.cs:715
msgid "Built in audio has been disabled"
msgstr "内置音频已被禁用"

#: SetupWizard.cs:715
msgid "Disable built in audio"
msgstr "禁用内置音频"

#: SetupWizard.cs:735
msgid ""
"Listed below are all the Unity Audio Sources found in the currently loaded scenes and the Assets directory.\n"
"Select an Audio Source and replace it with an FMOD Studio Event Emitter."
msgstr ""
"以下列出了当前加载的场景和 Assets 目录中找到的所有 Unity 音频源。\n"
"选择一个音频源并将其替换为 FMOD Studio Event Emitter 。"

#: SetupWizard.cs:752
msgid "No Unity Audio Sources have been found!"
msgstr "未找到任何 Unity 音频源！"

#: SetupWizard.cs:759
msgid "There are a number of files produced by FMOD for Unity that should be ignored by source control. Here is an example of what you should add to your source control ignore file:"
msgstr "FMOD for Unity 生成的一些文件应被版本控制忽略。以下是您应添加到版本控制忽略文件中的示例："

#: SetupWizard.cs:802
msgid "FMOD for Unity has been set up successfully!"
msgstr "FMOD for Unity 已成功设置！"

#: SetupWizard.cs:808
msgid "FMOD for Unity has been partially set up."
msgstr "FMOD for Unity 已部分设置完成。"

#: SetupWizard.cs:813
msgid ""
"FMOD for Unity has not finished being set up.\n"
"Linking to a project or banks is required."
msgstr ""
"FMOD for Unity 尚未完成设置。\n"
"需要链接到项目或事件库。"

#: SetupWizard.cs:824
msgid " Integration Manual "
msgstr " 集成手册 "

#: SetupWizard.cs:837
msgid " FMOD Settings "
msgstr " FMOD 设置"

#: SetupWizard.cs:863
msgid "Back"
msgstr "返回"

#: SetupWizard.cs:873
msgid "Start"
msgstr "开始"

#: SetupWizard.cs:875
msgid "Next"
msgstr "下一项"

#: SetupWizard.cs:903
msgid "To complete the installation, we need to update the FMOD native libraries.\n"
msgstr "要完成安装，我们需要更新 FMOD 原生库。\n"

#: SetupWizard.cs:904
msgid "This involves a few steps:"
msgstr "这包括以下几个步骤："

#: SetupWizard.cs:933
msgid "Next step:"
msgstr "下一步:"

#: SetupWizard.cs:1135
msgid "Expand All"
msgstr "全部展开"

#: SetupWizard.cs:1140
msgid "Collapse All"
msgstr "全部折叠"

#: StudioBankLoaderEditor.cs:18
msgid "Load"
msgstr "加载"

#: StudioBankLoaderEditor.cs:19
msgid "Unload"
msgstr "卸载"

#: StudioBankLoaderEditor.cs:27 StudioEventEmitterEditor.cs:122
msgid "Preload Sample Data"
msgstr "预加载样本数据"

#: StudioBankLoaderEditor.cs:32
msgid "Add Bank"
msgstr "添加事件库"

#: StudioBankLoaderEditor.cs:40
msgid "Select FMOD Bank"
msgstr "选择 FMOD 事件库"

#: StudioEventEmitterEditor.cs:56
msgid "Event Play Trigger"
msgstr "事件播放触发器"

#: StudioEventEmitterEditor.cs:57
msgid "Event Stop Trigger"
msgstr "事件停止触发器"

#: StudioEventEmitterEditor.cs:87
msgid "Override Attenuation"
msgstr "覆盖衰减"

#: StudioEventEmitterEditor.cs:119
msgid "Advanced Controls"
msgstr "高级控制"

#: StudioEventEmitterEditor.cs:123
msgid "Allow Fadeout When Stopping"
msgstr "允许停止时淡出"

#: StudioEventEmitterEditor.cs:124
msgid "Trigger Once"
msgstr "触发一次"

#: StudioEventEmitterEditor.cs:125 StudioListenerEditor.cs:28
msgid "Non-Rigidbody Velocity"
msgstr "非刚体速度"

#: StudioEventEmitterEditor.cs:265
msgid "Initial Parameter Values"
msgstr "初始参数值"

#: StudioEventEmitterEditor.cs:465
#, csharp-format
msgid "Set to Value of '{0}'"
msgstr "设置为 '{0}' 的值"

#: StudioGlobalParameterTriggerEditor.cs:40
msgid "Parameter Not Found"
msgstr "未找到参数"

#: StudioGlobalParameterTriggerEditor.cs:43 StudioParameterTriggerEditor.cs:63
msgid "Trigger"
msgstr "触发器"

#: StudioGlobalParameterTriggerEditor.cs:49
msgid "Parameter"
msgstr "参数"

#: StudioGlobalParameterTriggerEditor.cs:70
msgid "Override Value"
msgstr "覆盖值"

#: StudioListenerEditor.cs:24
msgid "Listener Index"
msgstr "监听器索引"

#: StudioListenerEditor.cs:27
msgid "Attenuation Object"
msgstr "衰减对象"



================================================
FILE: Assets/Plugins/FMOD/src/Editor/zh_hans.po.meta
================================================
fileFormatVersion: 2
guid: 6bc0be9e3a234d3429dfe763083ef8a9
LocalizationImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 


