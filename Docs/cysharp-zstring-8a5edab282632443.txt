Directory structure:
└── cysharp-zstring/
    ├── README.md
    ├── Directory.Build.props
    ├── LICENSE
    ├── opensource.snk
    ├── ZString.sln
    ├── .editorconfig
    ├── docs/
    │   └── graph.xlsx
    ├── sandbox/
    │   ├── BenchmarkVsReleasedVersion/
    │   │   ├── BenchmarkVsReleasedVersion.csproj
    │   │   ├── BuiltinTypesBenchmark.cs
    │   │   ├── ConcatBenchmark.cs
    │   │   ├── FormatBenchmark.cs
    │   │   ├── MaximumArgsFormatBenchmark.cs
    │   │   ├── Program.cs
    │   │   └── runall.cmd
    │   ├── ConsoleApp/
    │   │   ├── ConsoleApp.csproj
    │   │   └── Program.cs
    │   ├── ConsoleAppNet472/
    │   │   ├── App.config
    │   │   ├── ConsoleAppNet472.csproj
    │   │   ├── packages.config
    │   │   ├── Program.cs
    │   │   └── Properties/
    │   │       └── AssemblyInfo.cs
    │   └── PerfBenchmark/
    │       ├── PerfBenchmark.csproj
    │       ├── Program.cs
    │       └── Benchmarks/
    │           ├── AppendPerformance.cs
    │           ├── FormatBenchmark.cs
    │           ├── ReplaceBenchmark.cs
    │           ├── SixObjectConcatBenchmark.cs
    │           ├── StringBuilderAppendFormat.cs
    │           ├── StringBuilderAppendJoin.cs
    │           ├── StringListJoinBenchmark.cs
    │           └── VSStringFormatter.cs
    ├── src/
    │   ├── ZString/
    │   │   ├── _InternalVisibleTo.cs
    │   │   ├── EnumUtil.cs
    │   │   ├── ExceptionUtil.cs
    │   │   ├── FastNumberWriter.cs
    │   │   ├── FormatHelper.cs
    │   │   ├── FormatHelper.tt
    │   │   ├── FormatParser.cs
    │   │   ├── IResettableBufferWriter.cs
    │   │   ├── NestedStringBuilderCreationException.cs
    │   │   ├── PreparedFormat.tt
    │   │   ├── PreparedFormatHelper.cs
    │   │   ├── ReadOnlyListAdaptor.cs
    │   │   ├── Shims.cs
    │   │   ├── StringBuilder.AppendJoin.cs
    │   │   ├── StringBuilder.AppendJoin.tt
    │   │   ├── T4Common.t4
    │   │   ├── Utf16ValueStringBuilder.cs
    │   │   ├── Utf8ValueStringBuilder.cs
    │   │   ├── ZString.Concat.tt
    │   │   ├── ZString.cs
    │   │   ├── ZString.csproj
    │   │   ├── ZString.Format.cs
    │   │   ├── ZString.Format.tt
    │   │   ├── ZString.Prepare.cs
    │   │   ├── ZString.Prepare.tt
    │   │   ├── ZString.Utf8Format.tt
    │   │   ├── ZStringWriter.cs
    │   │   ├── Number/
    │   │   │   ├── BitOperations.cs
    │   │   │   ├── BufferEx.cs
    │   │   │   ├── DecimalEx.cs
    │   │   │   ├── FloatEx.cs
    │   │   │   ├── FormattingHelpers.cs
    │   │   │   ├── GuidEx.cs
    │   │   │   ├── HexConverter.cs
    │   │   │   ├── InternalSpanEx.cs
    │   │   │   ├── MathEx.cs
    │   │   │   ├── Number.BigInteger.cs
    │   │   │   ├── Number.DiyFp.cs
    │   │   │   ├── Number.Dragon4.cs
    │   │   │   ├── Number.Grisu3.cs
    │   │   │   ├── Number.NumberBuffer.cs
    │   │   │   ├── Number.NumberToFloatingPointBits.cs
    │   │   │   ├── NumberFormatInfoEx.cs
    │   │   │   └── ValueStringBuilder.cs
    │   │   ├── Unity/
    │   │   │   ├── TextMeshProExtensions.cs
    │   │   │   └── TextMeshProExtensions.tt
    │   │   ├── Utf16/
    │   │   │   ├── Utf16ValueStringBuilder.AppendFormat.tt
    │   │   │   ├── Utf16ValueStringBuilder.CreateFormatter.cs
    │   │   │   ├── Utf16ValueStringBuilder.CreateFormatter.tt
    │   │   │   ├── Utf16ValueStringBuilder.SpanFormattableAppend.cs
    │   │   │   └── Utf16ValueStringBuilder.SpanFormattableAppend.tt
    │   │   └── Utf8/
    │   │       ├── Utf8ValueStringBuilder.AppendFormat.tt
    │   │       ├── Utf8ValueStringBuilder.CreateFormatter.cs
    │   │       ├── Utf8ValueStringBuilder.CreateFormatter.tt
    │   │       ├── Utf8ValueStringBuilder.SpanFormattableAppend.cs
    │   │       └── Utf8ValueStringBuilder.SpanFormattableAppend.tt
    │   └── ZString.Unity/
    │       ├── .vsconfig
    │       ├── Assets/
    │       │   ├── Plugins.meta
    │       │   ├── Resources.meta
    │       │   ├── Scenes.meta
    │       │   ├── Scripts.meta
    │       │   ├── Plugins/
    │       │   │   └── System.Runtime.CompilerServices.Unsafe.dll.meta
    │       │   ├── Resources/
    │       │   │   ├── BillingMode.json
    │       │   │   └── BillingMode.json.meta
    │       │   ├── Scenes/
    │       │   │   ├── SampleScene.unity
    │       │   │   ├── SampleScene.unity.meta
    │       │   │   ├── Test.cs
    │       │   │   └── Test.cs.meta
    │       │   └── Scripts/
    │       │       ├── Editor.meta
    │       │       ├── ZString.meta
    │       │       ├── Editor/
    │       │       │   ├── PackageExporter.cs
    │       │       │   └── PackageExporter.cs.meta
    │       │       └── ZString/
    │       │           ├── csc.rsp
    │       │           ├── csc.rsp.meta
    │       │           ├── EnumUtil.cs
    │       │           ├── EnumUtil.cs.meta
    │       │           ├── ExceptionUtil.cs
    │       │           ├── ExceptionUtil.cs.meta
    │       │           ├── FastNumberWriter.cs
    │       │           ├── FastNumberWriter.cs.meta
    │       │           ├── FormatHelper.cs
    │       │           ├── FormatHelper.cs.meta
    │       │           ├── FormatParser.cs
    │       │           ├── FormatParser.cs.meta
    │       │           ├── IResettableBufferWriter.cs
    │       │           ├── IResettableBufferWriter.cs.meta
    │       │           ├── NestedStringBuilderCreationException.cs
    │       │           ├── NestedStringBuilderCreationException.cs.meta
    │       │           ├── Number.meta
    │       │           ├── package.json
    │       │           ├── package.json.meta
    │       │           ├── PreparedFormat.cs.meta
    │       │           ├── PreparedFormatHelper.cs
    │       │           ├── PreparedFormatHelper.cs.meta
    │       │           ├── ReadOnlyListAdaptor.cs
    │       │           ├── ReadOnlyListAdaptor.cs.meta
    │       │           ├── Shims.cs
    │       │           ├── Shims.cs.meta
    │       │           ├── StringBuilder.AppendJoin.cs
    │       │           ├── StringBuilder.AppendJoin.cs.meta
    │       │           ├── Unity.meta
    │       │           ├── Utf16.meta
    │       │           ├── Utf16ValueStringBuilder.cs
    │       │           ├── Utf16ValueStringBuilder.cs.meta
    │       │           ├── Utf8.meta
    │       │           ├── Utf8ValueStringBuilder.cs
    │       │           ├── Utf8ValueStringBuilder.cs.meta
    │       │           ├── ZString.asmdef
    │       │           ├── ZString.asmdef.meta
    │       │           ├── ZString.Concat.cs.meta
    │       │           ├── ZString.cs
    │       │           ├── ZString.cs.meta
    │       │           ├── ZString.Format.cs
    │       │           ├── ZString.Format.cs.meta
    │       │           ├── ZString.Prepare.cs
    │       │           ├── ZString.Prepare.cs.meta
    │       │           ├── ZString.Utf8Format.cs.meta
    │       │           ├── ZStringWriter.cs
    │       │           ├── ZStringWriter.cs.meta
    │       │           ├── Number/
    │       │           │   ├── BitOperations.cs
    │       │           │   ├── BitOperations.cs.meta
    │       │           │   ├── BufferEx.cs
    │       │           │   ├── BufferEx.cs.meta
    │       │           │   ├── DecimalEx.cs
    │       │           │   ├── DecimalEx.cs.meta
    │       │           │   ├── FloatEx.cs
    │       │           │   ├── FloatEx.cs.meta
    │       │           │   ├── FormattingHelpers.cs
    │       │           │   ├── FormattingHelpers.cs.meta
    │       │           │   ├── GuidEx.cs
    │       │           │   ├── GuidEx.cs.meta
    │       │           │   ├── HexConverter.cs
    │       │           │   ├── HexConverter.cs.meta
    │       │           │   ├── InternalSpanEx.cs
    │       │           │   ├── InternalSpanEx.cs.meta
    │       │           │   ├── MathEx.cs
    │       │           │   ├── MathEx.cs.meta
    │       │           │   ├── Number.BigInteger.cs
    │       │           │   ├── Number.BigInteger.cs.meta
    │       │           │   ├── Number.DiyFp.cs
    │       │           │   ├── Number.DiyFp.cs.meta
    │       │           │   ├── Number.Dragon4.cs
    │       │           │   ├── Number.Dragon4.cs.meta
    │       │           │   ├── Number.Formatting.cs.meta
    │       │           │   ├── Number.Grisu3.cs
    │       │           │   ├── Number.Grisu3.cs.meta
    │       │           │   ├── Number.NumberBuffer.cs
    │       │           │   ├── Number.NumberBuffer.cs.meta
    │       │           │   ├── Number.NumberToFloatingPointBits.cs
    │       │           │   ├── Number.NumberToFloatingPointBits.cs.meta
    │       │           │   ├── Number.Parsing.cs.meta
    │       │           │   ├── NumberFormatInfoEx.cs
    │       │           │   ├── NumberFormatInfoEx.cs.meta
    │       │           │   ├── ValueStringBuilder.cs
    │       │           │   └── ValueStringBuilder.cs.meta
    │       │           ├── Unity/
    │       │           │   ├── TextMeshProExtensions.cs
    │       │           │   ├── TextMeshProExtensions.cs.meta
    │       │           │   ├── TextMeshProExtensions.SetStringBuilder.cs
    │       │           │   └── TextMeshProExtensions.SetStringBuilder.cs.meta
    │       │           ├── Utf16/
    │       │           │   ├── Utf16ValueStringBuilder.AppendFormat.cs.meta
    │       │           │   ├── Utf16ValueStringBuilder.CreateFormatter.cs
    │       │           │   ├── Utf16ValueStringBuilder.CreateFormatter.cs.meta
    │       │           │   ├── Utf16ValueStringBuilder.SpanFormattableAppend.cs
    │       │           │   └── Utf16ValueStringBuilder.SpanFormattableAppend.cs.meta
    │       │           └── Utf8/
    │       │               ├── Utf8ValueStringBuilder.AppendFormat.cs.meta
    │       │               ├── Utf8ValueStringBuilder.CreateFormatter.cs
    │       │               ├── Utf8ValueStringBuilder.CreateFormatter.cs.meta
    │       │               ├── Utf8ValueStringBuilder.SpanFormattableAppend.cs
    │       │               └── Utf8ValueStringBuilder.SpanFormattableAppend.cs.meta
    │       ├── ProjectSettings/
    │       │   ├── AudioManager.asset
    │       │   ├── boot.config
    │       │   ├── ClusterInputManager.asset
    │       │   ├── DynamicsManager.asset
    │       │   ├── EditorBuildSettings.asset
    │       │   ├── EditorSettings.asset
    │       │   ├── GraphicsSettings.asset
    │       │   ├── InputManager.asset
    │       │   ├── MemorySettings.asset
    │       │   ├── NavMeshAreas.asset
    │       │   ├── NetworkManager.asset
    │       │   ├── PackageManagerSettings.asset
    │       │   ├── Physics2DSettings.asset
    │       │   ├── PresetManager.asset
    │       │   ├── ProjectSettings.asset
    │       │   ├── ProjectVersion.txt
    │       │   ├── QualitySettings.asset
    │       │   ├── TagManager.asset
    │       │   ├── TimeManager.asset
    │       │   ├── UnityConnectSettings.asset
    │       │   ├── VersionControlSettings.asset
    │       │   ├── VFXManager.asset
    │       │   └── XRSettings.asset
    │       └── UserSettings/
    │           ├── EditorUserSettings.asset
    │           ├── Search.settings
    │           └── Layouts/
    │               └── default-2021.dwlt
    ├── tests/
    │   ├── ZString.NetCore2Tests/
    │   │   └── ZString.NetCore2Tests.csproj
    │   └── ZString.Tests/
    │       ├── AppendJoinTest.cs
    │       ├── CompositeFormatTest.cs
    │       ├── EnumTest.cs
    │       ├── FormatTest.cs
    │       ├── InsertTest.cs
    │       ├── JoinTest.cs
    │       ├── NestedStringBuilder.cs
    │       ├── Primitives.cs
    │       ├── RemoveTest.cs
    │       ├── ReplaceTest.cs
    │       ├── StringBuilderTest.cs
    │       ├── Utf8StringBuilderTest.cs
    │       ├── ZString.Tests.csproj
    │       └── ZStringWriterTest.cs
    └── .github/
        ├── dependabot.yaml
        └── workflows/
            ├── build-debug.yaml
            ├── build-release.yaml
            ├── prevent-github-change.yaml
            ├── stale.yaml
            └── toc.yaml

================================================
FILE: README.md
================================================
ZString
===
[![GitHub Actions](https://github.com/Cysharp/ZString/workflows/Build-Debug/badge.svg)](https://github.com/Cysharp/ZString/actions) [![Releases](https://img.shields.io/github/release/Cysharp/ZString.svg)](https://github.com/Cysharp/ZString/releases)

**Z**ero Allocation **String**Builder for .NET Core and Unity.

* Struct StringBuilder to avoid allocation of builder itself
* Rent write buffer from `ThreadStatic` or `ArrayPool`
* All append methods are generics(`Append<T>(T value)`) and write to buffer directly instead of concatenate `value.ToString`
* `T1`~`T16` AppendFormat(`AppendFormat<T1,...,T16>(string format, T1 arg1, ..., T16 arg16)` avoids boxing of struct argument
* Also `T1`~`T16` Concat(`Concat<T1,...,T16>(T1 arg1, ..., T16 arg16)`) avoid boxing and `value.ToString` allocation
* Convenient `ZString.Format/Concat/Join` methods can replace instead of `String.Format/Concat/Join`
* Can build both Utf16(`Span<char>`) and Utf8(`Span<byte>`) directly
* Can use inner buffer to avoid allocate final string
* Integrated with Unity TextMeshPro to avoid string allocation

![image](https://user-images.githubusercontent.com/46207/74473217-9061e200-4ee6-11ea-9a77-14d740886faa.png)

This graph compares following codes.

* `"x:" + x + " y:" + y + " z:" + z`
* `ZString.Concat("x:", x, " y:", y, " z:", z)`
* `string.Format("x:{0} y:{1} z:{2}", x, y, z)`
* `ZString.Format("x:{0} y:{1} z:{2}", x, y, z)`
* `new StringBuilder(), Append(), .ToString()`
* `ZString.CreateStringBuilder(), Append(), .ToString()`

`"x:" + x + " y:" + y + " z:" + z` is converted to `String.Concat(new []{ "x:", x.ToString(), " y:", y.ToString(), " z:", z.ToString() })` by C# compiler. It has each `.ToString` allocation and params array allocation. `string.Format` calls `String.Format(string, object, object, object)` so each arguments causes int -> object boxing.

All `ZString` methods only allocate final string. Also, `ZString` has enabled to access inner buffer so if output target has stringless api(like Unity TextMeshPro's `SetCharArray`), you can achieve completely zero allocation.

The blog post of detailed explanation by author: [medium@neuecc/ZString](https://medium.com/@neuecc/zstring-zero-allocation-stringbuilder-for-net-core-and-unity-f3163c88c887)

Related project for loggin using with ZString, [Cysharp/ZLogger](https://github.com/Cysharp/ZLogger) - Zero Allocation Text/Strcutured Logger.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
## Table of Contents

- [Getting Started](#getting-started)
- [Reference](#reference)
- [Unity](#unity)
- [Advanced Tips](#advanced-tips)
- [License](#license)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

Getting Started
---
For .NET Core, use NuGet.

> PM> Install-Package [ZString](https://www.nuget.org/packages/ZString)

For Unity, check the [releases](https://github.com/Cysharp/ZString/releases) page, download `ZString.Unity.unitypackage`.

```csharp
using Cysharp.Text; // namespace

async void Example(int x, int y, int z)
{
    // same as x + y + z
    _ = ZString.Concat(x, y, z);

    // also can use numeric format strings
    _ = ZString.Format("x:{0}, y:{1:000}, z:{2:P}",x, y, z);

    _ = ZString.Join(',', x, y, z);

    // for Unity, direct write(avoid string allocation completely) to TextMeshPro
    tmp.SetTextFormat("Position: {0}, {1}, {2}", x, y, z);

    // create StringBuilder
    using(var sb = ZString.CreateStringBuilder())
    {
        sb.Append("foo");
        sb.AppendLine(42);
        sb.AppendFormat("{0} {1:.###}", "bar", 123.456789);

        // and build final string
        var str = sb.ToString();

        // for Unity, direct write to TextMeshPro
        tmp.SetText(sb);

        // write to destination buffer
        sb.TryCopyTo(dest, out var written);
    }

    // prepare format, return value should store to field(like RegexOptions.Compile)
    var prepared = ZString.PrepareUtf16<int, int>("x:{0}, y:{1:000}");
    _ = prepared.Format(10, 20);

    // C# 8.0, Using declarations
    // create Utf8 StringBuilder that build Utf8 directly to avoid encoding
    using var sb2 = ZString.CreateUtf8StringBuilder();

    sb2.AppendFormat("foo:{0} bar:{1}", x, y);

    // directly write to steam or dest to avoid allocation
    await sb2.WriteToAsync(stream);
    sb2.CopyTo(bufferWritter);
    sb2.TryCopyTo(dest, out var written);
}
```

Reference
---
**static class ZString**

| method | returns | description |
| -- | -- | -- |
| CreateStringBuilder() | Utf16ValueStringBuilder | Create the Utf16 string StringBuilder. |
| CreateStringBuilder(bool notNested) | Utf16ValueStringBuilder | Create the Utf16 string StringBuilder, when true uses thread-static buffer that is faster but must return immediately. |
| CreateUtf8StringBuilder() | Utf8ValueStringBuilder | Create the Utf8(`Span<byte>`) StringBuilder. |
| CreateUtf8StringBuilder(bool notNested) | Utf8ValueStringBuilder | Create the Utf8(`Span<byte>`) StringBuilder, when true uses thread-static buffer that is faster but must return immediately. |
| `Join(char/string, T[]/IE<T>)` | string | Concatenates the elements of an array, using the specified seperator between each element. |
| `PrepareUtf16<T1,..,T16>(string)` | `Utf16PreparedFormat<T1,...,T16>` | Prepare string format to avoid parse template in each operation. |
| `PrepareUtf8<T1,..,T16>(string)` | `Utf8PreparedFormat<T1,...,T16>` | Prepare string format to avoid parse template in each operation. |
| `Concat<T1,..,T16>(T1,..,T16)` | string | Concatenates the string representation of some specified values. |
| `Format<T1,..,T16>(string, T1,..,T16)` | string | Replaces one or more format items in a string with the string representation of some specified values. |
| `Utf8Format<T1,..,T16>(IBufferWriter<byte>, T1,..,T16)` | void | Replaces one or more format items in a string with the string representation of some specified values. |

**struct Utf16ValueStringBuilder : `IBufferWriter<char>`, IDisposable**

| method | returns | description |
| -- | -- | -- |
| Length | int | Length of written buffer. |
| AsSpan() | `ReadOnlySpan<char>` | Get the written buffer data. |
| AsMemory() | `ReadOnlyMemory<char>` | Get the written buffer data. |
| AsArraySegment() | `ArraySegment<char>` | Get the written buffer data. |
| Dispose() | void | Return the inner buffer to pool. |
| `Append<T>(T value)` | void | Appends the string representation of a specified value to this instance. |
| `Append<T>(T value, string format)` | void | Appends the string representation of a specified value to this instance with numeric format strings. |
| `AppendJoin(char/string, T[]/IE<T>)`| void | Concatenates and appends the elements of an array, using the specified seperator between each element. |
| `AppendLine()` | void | Appends the default line terminator to the end of this instance. |
| `AppendLine<T>(T value)` | void | Appends the string representation of a specified value followed by the default line terminator to the end of this instance. |
| `AppendLine<T>(T value, string format)` | void | Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance. |
| `AppendFormat<T1,..,T16>(string, T1,..,T16)` | void | Appends the string returned by processing a composite format string, each format item is replaced by the string representation of arguments. |
| `TryCopyTo(Span<char>, out int)` | bool | Copy inner buffer to the destination span. |
| ToString() | string | Converts the value of this instance to a System.String. |
| GetMemory(int sizeHint) | `Memory<char>` | IBufferWriter.GetMemory. |
| GetSpan(int sizeHint) | `Span<char>` | IBufferWriter.GetSpan. |
| Advance(int count) | void | IBufferWriter.Advance. |
| static `RegisterTryFormat<T>(TryFormat<T>)` | void | Register custom formatter. |

**struct Utf8ValueStringBuilder : `IBufferWriter<byte>`, IDisposable**

| method | returns | description |
| -- | -- | -- |
| Length | int | Length of written buffer. |
| AsSpan() | `ReadOnlySpan<char>` | Get the written buffer data. |
| AsMemory() | `ReadOnlyMemory<char>` | Get the written buffer data. |
| AsArraySegment() | `ArraySegment<char>` | Get the written buffer data. |
| Dispose() | void | Return the inner buffer to pool. |
| `Append<T>(T value)` | void | Appends the string representation of a specified value to this instance. |
| `Append<T>(T value, StandardFormat format)` | void | Appends the string representation of a specified value to this instance with numeric format strings. |
| `AppendJoin(char/string, T[]/IE<T>)`| void | Concatenates and appends the elements of an array, using the specified seperator between each element. |
| `AppendLine()` | void | Appends the default line terminator to the end of this instance. |
| `AppendLine<T>(T value)` | void | Appends the string representation of a specified value followed by the default line terminator to the end of this instance. |
| `AppendLine<T>(T value, StandardFormat format)` | void | Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance. |
| `AppendFormat<T1,..,T16>(string, T1,..,T16)` | void | Appends the string returned by processing a composite format string, each format item is replaced by the string representation of arguments. |
| `CopyTo(IBufferWriter<byte>)` | void | Copy inner buffer to the buffer writer. |
| `TryCopyTo(Span<byte>, out int)` | bool | Copy inner buffer to the destination span. |
| WriteToAsync(Stream stream) | Task | Write inner buffer to stream. |
| ToString() | string | Encode the innner utf8 buffer to a System.String. |
| GetMemory(int sizeHint) | `Memory<char>` | IBufferWriter.GetMemory. |
| GetSpan(int sizeHint) | `Span<char>` | IBufferWriter.GetSpan. |
| Advance(int count) | void | IBufferWriter.Advance. |
| static `RegisterTryFormat<T>(TryFormat<T>)` | void | Register custom formatter. |

**class `Utf16PreparedFormat<T1,..,T16>`**

| method | returns | description |
| -- | -- | -- |
| `Format` | string | Replaces one or more format items in a string with the string representation of some specified values. |
| `FormatTo<TBufferWriter>(ref TBufferWriter, T1,..,T16)` | void | Replaces one or more format items in a string with the string representation of some specified values. |

**class `Utf8PreparedFormat<T1,..,T16>`**

| method | returns | description |
| -- | -- | -- |
| `Format` | string | Replaces one or more format items in a string with the string representation of some specified values. |
| `FormatTo<TBufferWriter>(ref TBufferWriter, T1,..,T16)` | void | Replaces one or more format items in a string with the string representation of some specified values. |

**class ZStringWriter : TextWriter**

A `TextWriter` implementation that is backed with `Utf16ValueStringBuilder`  
It's important to make sure the writer is always properly disposed.

**static class TextMeshProExtensions**(Unity only)

| method | returns | description |
| -- | -- | -- |
| SetText(Utf16ValueStringBuilder) | void | Set inner buffer to text mesh pro directly to avoid string allocation. |
| `SetTextFormat<T1,..,T16>(string, T1,..,T16)` | void | Set formatted string without string allocation. |

Unity
---
Install via UPM git URL package or asset package(ZString...*.unitypackage) available in [ZString/releases](https://github.com/Cysharp/ZString/releases) page.

* `https://github.com/Cysharp/ZString.git?path=src/ZString.Unity/Assets/Scripts/ZString`

If you want to set a target version, ZString uses the `*.*.*` release tag so you can specify a version like #2.4.0. For example `https://github.com/Cysharp/ZString.git?path=src/ZString.Unity/Assets/Scripts/ZString#2.4.0`.

Supporting minimum Unity version is 2021.3. The dependency managed DLL `System.Runtime.CompilerServices.Unsafe/6.0.0` is included with unitypackage. For git references, you will need to add them in another way as they are not included to avoid unnecessary dependencies; either extract the dll from unitypackage or download it from the [NuGet page](https://www.nuget.org/packages/System.Runtime.CompilerServices.Unsafe/6.0.0).

TextMeshPro support is automatically enabled when importing the `com.unity.textmeshpro` package from package manager. (If you do not use the package manager, define the scripting define symbol `ZSTRING_TEXTMESHPRO_SUPPORT` to enable it.)

Advanced Tips
---
`ZString.CreateStringBuilder(notNested:true)` is a special optimized parameter that uses `ThreadStatic` buffer instead of rent from `ArrayPool`. It is slightly faster but can not use in nested.

```csharp
using(var sb = ZString.CreateStringBuilder(true))
{
    sb.Append("foo");

    using var sb2 = ZString.CreateStringBuilder(true); // NG, nested stringbuilder uses conflicted same buffer
    var str = ZString.Concat("x", 100); // NG, ZString.Concat/Join/Format uses threadstatic buffer
}
```

```csharp
// OK, return buffer immediately.
using(var sb = ZString.CreateStringBuilder(true))
{
    sb.Append("foo");
    return sb.ToString();
}
```

`ZString.CreateStringBuilder()` is same as `ZString.CreateStringBuilder(notNested:false)`.

---

In default, `SByte`, `Int16`, `Int32`, `Int64`, `Byte`, `UInt16`, `UInt32`, `UInt64`, `Single`, `Double`, `TimeSpan`, `DateTime`, `DateTimeOffset`, `Decimal`, `Guid`, `String`, `Char` are used there own formatter to avoid `.ToString()` allocation, write directly to buffer. If not exists there list type, used `.ToString()` and copy string data.

If you want to avoid to convert string in custom type, you can register your own formatter.

```csharp
Utf16ValueStringBuilder.RegisterTryFormat((MyStruct value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format) =>
{
    // write value to destionation and set size to charsWritten.
    charsWritten = 0;
    return true;
});

Utf8ValueStringBuilder.RegisterTryFormat((MyStruct value, Span<byte> destination, out int written, StandardFormat format) =>
{
    written = 0;
    return true;
});
```

---

`CreateStringBuilder` and `CreateUtf8StringBuilder` must use with `using`. Because their builder rent 64K buffer from `ArrayPool`. If not return buffer, allocate 64K buffer when string builder is created.

---

`Utf16ValueStringBuilder` and `Utf8ValueStringBuilder` are mutable struct, be careful to copy by passing method. Use `ref` and `try-finally`.

```csharp
void Build()
{
    var sb = ZString.CreateStringBuilder();
    try
    {
        BuildHeader(ref sb);
        BuildMessage(ref sb);
    }
    finally
    {
        // when use with `ref`, can not use `using`.
        sb.Dispose();
    }
}


void BuildHeader(ref Utf16ValueStringBuilder builder)
{
    //..
}

void BuildMessage(ref Utf16ValueStringBuilder builder)
{
    //..
}
```

---

 Utf8Format, Utf8StringBuilder uses [Utf8Formatter.TryFormat](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat) and there format string is not same as standard format. It uses [StandardFormat](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.standardformat), combinate of symbol char and precision. Supported format string symbol can find in Utf8Formatter.TryFormat document(For example Int32 supports `G`, `D`, `N`, `X` and Boolean supports `G`, `I`). Precision(zero padding) can pass after symbol like `D2`. For example `sb.AppendFormat("{0:D2}:{1:D2}:{2:D2}", hour, minute, second)`.

[TryFormat(DateTime)](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=netcore-3.1#System_Buffers_Text_Utf8Formatter_TryFormat_System_DateTime_System_Span_System_Byte__System_Int32__System_Buffers_StandardFormat_) and [TryFormat(TimeSpan)](https://docs.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=netcore-3.1#System_Buffers_Text_Utf8Formatter_TryFormat_System_TimeSpan_System_Span_System_Byte__System_Int32__System_Buffers_StandardFormat_) symbol is too restricted than standard string format. If you want to use custom format, deconstruct there `Day`, `Hour`, etc.

---

`Utf8ValueStringBuilder` and `Utf16ValueStringBuilder` implements `IBufferWriter` so you can pass serializer(such as `JsonSerializer` of `System.Text.Json`). But be careful to boxing copy, `ValueStringBuilder` is mutable struct. For example,

```csharp
using var sb = ZString.CreateUtf8StringBuilder();
IBufferWriter<byte> boxed = sb;
var writer = new Utf8JsonWriter(boxed);
JsonSerializer.Serialize(writer, ....);

using var unboxed = (Utf8ValueStringBuilder)boxed;
var str = unboxed.ToString();
```

License
---
This library is licensed under the MIT License.

.NET Standard 2.0 and Unity version borrows [dotnet/runtime](https://github.com/dotnet/runtime) conversion methods, there exists under `ZString/Number` directory. This third-party license follows [runtime/LICENSE.TXT](https://github.com/dotnet/runtime/blob/master/LICENSE.TXT).



================================================
FILE: Directory.Build.props
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)opensource.snk</AssemblyOriginatorKeyFile>

    <!-- NuGet Package Information -->
    <IsPackable>false</IsPackable>
    <PackageVersion>$(Version)</PackageVersion>
    <Company>Cysharp</Company>
    <Authors>Cysharp</Authors>
    <Copyright>© Cysharp, Inc.</Copyright>
    <PackageTags>string;</PackageTags>
    <PackageProjectUrl>https://github.com/Cysharp/ZString</PackageProjectUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <RepositoryUrl>$(PackageProjectUrl)</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageIcon>Icon.png</PackageIcon>
  </PropertyGroup>

  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)Icon.png" Pack="true" PackagePath="\" />
    <None Include="$(MSBuildThisFileDirectory)README.md" Pack="true" PackagePath="\" />
    <EmbeddedResource Include="$(MSBuildThisFileDirectory)LICENSE" />
  </ItemGroup>
</Project>



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2020 Cysharp, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: opensource.snk
================================================
[Binary file]


================================================
FILE: ZString.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32901.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "docs", "docs", "{175A1317-7622-4CC3-9553-1E9E908FF085}"
	ProjectSection(SolutionItems) = preProject
		.gitignore = .gitignore
		.circleci\config.yml = .circleci\config.yml
		LICENSE = LICENSE
		README.md = README.md
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{B385367D-2EB5-49B3-A3EF-922151EC1904}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "sandbox", "sandbox", "{A7D7AA7D-9A79-48A8-978D-0C98EBD81ED0}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{0803618F-C4E8-4D37-831E-5D26C5574F49}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ZString", "src\ZString\ZString.csproj", "{7B09D422-D19A-457E-ADA0-4CDC2DC581BB}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ConsoleApp", "sandbox\ConsoleApp\ConsoleApp.csproj", "{9ADF67E1-1872-43D3-882E-607071726FE7}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ZString.Tests", "tests\ZString.Tests\ZString.Tests.csproj", "{62090C00-9727-4375-BE40-ABE2F4D41571}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "PerfBenchmark", "sandbox\PerfBenchmark\PerfBenchmark.csproj", "{D766AEB3-3609-4F1D-8D81-5549F748F372}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7B09D422-D19A-457E-ADA0-4CDC2DC581BB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7B09D422-D19A-457E-ADA0-4CDC2DC581BB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7B09D422-D19A-457E-ADA0-4CDC2DC581BB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7B09D422-D19A-457E-ADA0-4CDC2DC581BB}.Release|Any CPU.Build.0 = Release|Any CPU
		{9ADF67E1-1872-43D3-882E-607071726FE7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9ADF67E1-1872-43D3-882E-607071726FE7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9ADF67E1-1872-43D3-882E-607071726FE7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9ADF67E1-1872-43D3-882E-607071726FE7}.Release|Any CPU.Build.0 = Release|Any CPU
		{62090C00-9727-4375-BE40-ABE2F4D41571}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{62090C00-9727-4375-BE40-ABE2F4D41571}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{62090C00-9727-4375-BE40-ABE2F4D41571}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{62090C00-9727-4375-BE40-ABE2F4D41571}.Release|Any CPU.Build.0 = Release|Any CPU
		{D766AEB3-3609-4F1D-8D81-5549F748F372}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D766AEB3-3609-4F1D-8D81-5549F748F372}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D766AEB3-3609-4F1D-8D81-5549F748F372}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D766AEB3-3609-4F1D-8D81-5549F748F372}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{7B09D422-D19A-457E-ADA0-4CDC2DC581BB} = {B385367D-2EB5-49B3-A3EF-922151EC1904}
		{9ADF67E1-1872-43D3-882E-607071726FE7} = {A7D7AA7D-9A79-48A8-978D-0C98EBD81ED0}
		{62090C00-9727-4375-BE40-ABE2F4D41571} = {0803618F-C4E8-4D37-831E-5D26C5574F49}
		{D766AEB3-3609-4F1D-8D81-5549F748F372} = {A7D7AA7D-9A79-48A8-978D-0C98EBD81ED0}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DF39BF43-3E0E-4F7D-9943-7E50D301234D}
	EndGlobalSection
EndGlobal



================================================
FILE: .editorconfig
================================================
﻿# top-most EditorConfig file
root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

# Visual Studio Spell checker configs (https://learn.microsoft.com/en-us/visualstudio/ide/text-spell-checker?view=vs-2022#how-to-customize-the-spell-checker)
spelling_exclusion_path  = ./exclusion.dic

[*.cs]
indent_size = 4
charset = utf-8-bom
end_of_line = unset

# Solution files
[*.{sln,slnx}]
end_of_line = unset

# MSBuild project files
[*.{csproj,props,targets}]
end_of_line = unset

# Xml config files
[*.{ruleset,config,nuspec,resx,runsettings,DotSettings}]
end_of_line = unset

[*{_AssemblyInfo.cs,.notsupported.cs}]
generated_code = true

# C# code style settings
[*.{cs}]
dotnet_diagnostic.IDE0044.severity = none # IDE0044: Make field readonly

# https://stackoverflow.com/questions/79195382/how-to-disable-fading-unused-methods-in-visual-studio-2022-17-12-0
dotnet_diagnostic.IDE0051.severity = none # IDE0051: Remove unused private member
dotnet_diagnostic.IDE0130.severity = none # IDE0130: Namespace does not match folder structure



================================================
FILE: docs/graph.xlsx
================================================
[Binary file]


================================================
FILE: sandbox/BenchmarkVsReleasedVersion/BenchmarkVsReleasedVersion.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
   <TargetFramework>netcoreapp3.1</TargetFramework>
   <!-- <TargetFrameworks>netcoreapp3.1;netcoreapp2.1;net472</TargetFrameworks> -->
   <LangVersion>8.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
   <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="4.7.1" Condition="$(TargetFramework) != 'netstandard3.1'" />
   <PackageReference Include="ZString" Version="2.2.0" />
   <PackageReference Include="BenchmarkDotNet" Version="0.12.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\ZString\ZString.csproj">
     <Aliases>NewZString</Aliases>
    </ProjectReference>
  </ItemGroup>

</Project>



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/BuiltinTypesBenchmark.cs
================================================
﻿// Before use, You must change AssemblyName to "NewZString" of local ZString.csproj

extern alias NewZString;

using System;
using System.Collections.Generic;
using System.Text;
using Cysharp.Text;
using NZString = NewZString::Cysharp.Text.ZString;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;

using PF16 = Cysharp.Text.Utf16PreparedFormat<byte, System.DateTime, System.DateTimeOffset, decimal, double, System.Guid, short, float, System.TimeSpan, uint, ulong, object, string, bool, System.TypeCode, char>;
using NPF16 = NewZString::Cysharp.Text.Utf16PreparedFormat<byte, System.DateTime, System.DateTimeOffset, decimal, double, System.Guid, short, float, System.TimeSpan, uint, ulong, object, string, bool, System.TypeCode, char>;

using PF8 = Cysharp.Text.Utf8PreparedFormat<byte, System.DateTime, System.DateTimeOffset, decimal, double, System.Guid, short, float, System.TimeSpan, uint, ulong, object, string, bool, System.TypeCode, char>;
using NPF8 = NewZString::Cysharp.Text.Utf8PreparedFormat<byte, System.DateTime, System.DateTimeOffset, decimal, double, System.Guid, short, float, System.TimeSpan, uint, ulong, object, string, bool, System.TypeCode, char>;

namespace BenchmarkVsReleasedVersion
{
    [Config(typeof(BenchmarkConfig))]
    [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
    [DisassemblyDiagnoser]
    public class BuiltinTypesBenchmark
    {
        string _format;

        byte _byte;
        DateTime _dt;
        DateTimeOffset _dto;
        decimal _decimal;
        double _double;
        Guid _guid;
        short _short;
        sbyte _sbyte;
        float _float;
        TimeSpan _ts;
        ushort _ushort;
        uint _uint;
        ulong _ulong;
        object _null;
        string _string;
        bool _bool;
        TypeCode _enum;
        char _char;

        PF16 _utf16preparedFormat_;
        NPF16 _utf16preparedFormatN;

        PF8 _utf8preparedFormat_;
        NPF8 _utf8preparedFormatN;

        public BuiltinTypesBenchmark()
        {
            var rand = new Random();

            _format = "{0}-{1}-{2}-{3}-{4}-{5}-{6}-{7}-{8}-{9}-{10}-{11}-{12}-{13}-{14}-{15}";

            _utf16preparedFormat_ = new PF16(_format);
            _utf16preparedFormatN = new NPF16(_format);

            _utf8preparedFormat_ = new PF8(_format);
            _utf8preparedFormatN = new NPF8(_format);

            _byte = (byte)rand.Next();
            _dt = DateTime.Now;
            _dto = DateTimeOffset.Now;
            _decimal = (decimal)rand.NextDouble();
            _double = rand.NextDouble();
            _guid = Guid.NewGuid();
            _short = (short)rand.Next();
            _sbyte = (sbyte)rand.Next();
            _float = (float)rand.NextDouble();
            _ts = DateTime.Now - DateTime.Today;
            _ushort = (ushort)rand.Next();
            _uint = (uint)rand.Next();
            _ulong = (ulong)rand.Next();
            _null = null;
            _string = Guid.NewGuid().ToString();
            _bool = rand.Next() % 1 == 0;
            _enum = (TypeCode)rand.Next((int)TypeCode.DateTime);
            _char = (char)rand.Next();
        }

        [BenchmarkCategory("Format"), Benchmark(Baseline = true)]
        public string Format_()
        {
            return ZString.Format(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("Format"), Benchmark]
        public string FormatN()
        {
            return NZString.Format(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("CreateUtf16PreparedFormat"), Benchmark(Baseline = true)]
        public object CreateUtf16PreparedFormat_()
        {
            return new PF16(_format);
        }

        [BenchmarkCategory("CreateUtf16PreparedFormat"), Benchmark]
        public object CreateUtf16PreparedFormatN()
        {
            return new NPF16(_format);
        }

        [BenchmarkCategory("CreateUtf8PreparedFormat"), Benchmark(Baseline = true)]
        public object CreateUtf8PreparedFormat_()
        {
            return new PF8(_format);
        }

        [BenchmarkCategory("CreateUtf8PreparedFormat"), Benchmark]
        public object CreateUtf8PreparedFormatN()
        {
            return new NPF8(_format);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf16PreparedFormat_()
        {
            return _utf16preparedFormat_.Format(
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark]
        public string Utf16PreparedFormatN()
        {
            return _utf16preparedFormatN.Format(
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf8PreparedFormat_()
        {
            return _utf8preparedFormat_.Format(
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark]
        public string Utf8PreparedFormatN()
        {
            return _utf8preparedFormatN.Format(
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf16StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateStringBuilder();
            zsh.AppendFormat(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark]
        public int Utf16StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateStringBuilder();
            zsh.AppendFormat(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf8StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark]
        public int Utf8StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(_format,
                _byte, _dt, _dto, _decimal, _double, _guid, _short, _float, _ts, _uint, _ulong, _null, _string, _bool, _enum, _char);
            return zsh.Length;
        }
    }
}



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/ConcatBenchmark.cs
================================================
﻿extern alias NewZString;

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using Cysharp.Text;
using System;
using System.Text;

namespace BenchmarkVsReleasedVersion
{
    [Config(typeof(BenchmarkConfig))]
    [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
    [DisassemblyDiagnoser(maxDepth: 3)]
    public class ConcatBenchmark
    {
        int a;
        int b;
        int c;
        int x;
        int y;
        int z;

        public ConcatBenchmark()
        {
            a = int.Parse("000");
            b = int.Parse("111");
            c = int.Parse("222");
            x = int.Parse("333");
            y = int.Parse("444");
            z = int.Parse("555");
        }

        [BenchmarkCategory("FourParams"), Benchmark(Baseline = true)]
        public string FourParamsConcat_()
        {
            return ZString
                .Concat("x:", x, " y:", y);
        }

        [BenchmarkCategory("FourParams"), Benchmark]
        public string FourParamsConcatN()
        {
            return NewZString::Cysharp.Text.ZString
                .Concat("x:", x, " y:", y);
        }

        [BenchmarkCategory("SixParams"), Benchmark(Baseline = true)]
        public string SixParamsConcat_()
        {
            return ZString
                .Concat("a:", a, " b:", b, " c:", c);
        }

        [BenchmarkCategory("SixParams"), Benchmark]
        public string SixParamsConcatN()
        {
            return NewZString::Cysharp.Text.ZString
                .Concat("a:", a, " b:", b, " c:", c);
        }

        [BenchmarkCategory("EightParams"), Benchmark(Baseline = true)]
        public string EightParamsConcat_()
        {
            return ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x);
        }

        [BenchmarkCategory("EightParams"), Benchmark]
        public string EightParamsConcatN()
        {
            return NewZString::Cysharp.Text.ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x);
        }

        [BenchmarkCategory("TenParams"), Benchmark(Baseline = true)]
        public string TenParamsConcat_()
        {
            return ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x, " y:", y);
        }

        [BenchmarkCategory("TenParams"), Benchmark]
        public string TenParamsConcatN()
        {
            return NewZString::Cysharp.Text.ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x, " y:", y);
        }

        [BenchmarkCategory("TwelveParams"), Benchmark(Baseline = true)]
        public string TwelveParamsConcat_()
        {
            return ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x, " y:", y, " z:", z);
        }

        [BenchmarkCategory("TwelveParams"), Benchmark]
        public string TwelveParamsConcatN()
        {
            return NewZString::Cysharp.Text.ZString
                .Concat("a:", a, " b:", b, " c:", c, " x:", x, " y:", y, " z:", z);
        }
    }
}



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/FormatBenchmark.cs
================================================
﻿// Before use, You must change AssemblyName to "NewZString" of local ZString.csproj

extern alias NewZString;

using System;
using System.Collections.Generic;
using System.Text;
using Cysharp.Text;
using NZString = NewZString::Cysharp.Text.ZString;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;

namespace BenchmarkVsReleasedVersion
{
    [Config(typeof(BenchmarkConfig))]
    [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
    [DisassemblyDiagnoser(maxDepth:3)]
    public class FormatBenchmark
    {
        int x;
        int y;

        Utf16PreparedFormat<int, int> _utf16preparedFormat_;
        NewZString::Cysharp.Text.Utf16PreparedFormat<int, int> _utf16preparedFormatN;

        Utf8PreparedFormat<int, int> _utf8preparedFormat_;
        NewZString::Cysharp.Text.Utf8PreparedFormat<int, int> _utf8preparedFormatN;

        [Params(
            "x:{0}, y:{1}",
            "This is a test to see how{0} well {1}this does.  Hello, world."
            )]
        public string FormatString { get; set; }

        [GlobalSetup]
        public void GlobalSetup()
        {
            _utf16preparedFormat_ = new Utf16PreparedFormat<int, int>(FormatString);
            _utf16preparedFormatN = new NewZString::Cysharp.Text.Utf16PreparedFormat<int, int>(FormatString);

            _utf8preparedFormat_ = new Utf8PreparedFormat<int, int>(FormatString);
            _utf8preparedFormatN = new NewZString::Cysharp.Text.Utf8PreparedFormat<int, int>(FormatString);
        }


        public FormatBenchmark()
        {
            x = int.Parse("100");
            y = int.Parse("200");
        }

        [BenchmarkCategory("Format"), Benchmark(Baseline = true)]
        public string Format_()
        {
            return ZString.Format(FormatString, x, y);
        }

        [BenchmarkCategory("Format"), Benchmark]
        public string FormatN()
        {
            return NZString.Format(FormatString, x, y);
        }

        [BenchmarkCategory("CreateUtf16PreparedFormat"), Benchmark(Baseline = true)]
        public object CreateUtf16PreparedFormat_()
        {
            return new Utf16PreparedFormat<int, int>(FormatString);
        }

        [BenchmarkCategory("CreateUtf16PreparedFormat"), Benchmark]
        public object CreateUtf16PreparedFormatN()
        {
            return new NewZString::Cysharp.Text.Utf16PreparedFormat<int, int>(FormatString);
        }

        [BenchmarkCategory("CreateUtf8PreparedFormat"), Benchmark(Baseline = true)]
        public object CreateUtf8PreparedFormat_()
        {
            return new Utf8PreparedFormat<int, int>(FormatString);
        }

        [BenchmarkCategory("CreateUtf8PreparedFormat"), Benchmark]
        public object CreateUtf8PreparedFormatN()
        {
            return new NewZString::Cysharp.Text.Utf8PreparedFormat<int, int>(FormatString);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf16PreparedFormat_()
        {
            return _utf16preparedFormat_.Format(x, y);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark]
        public string Utf16PreparedFormatN()
        {
            return _utf16preparedFormatN.Format(x, y);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf8PreparedFormat_()
        {
            return _utf8preparedFormat_.Format(x, y);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark]
        public string Utf8PreparedFormatN()
        {
            return _utf8preparedFormatN.Format(x, y);
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf16StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateStringBuilder();
            zsh.AppendFormat(FormatString, x, y);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark]
        public int Utf16StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateStringBuilder();
            zsh.AppendFormat(FormatString, x, y);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf8StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(FormatString, x, y);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark]
        public int Utf8StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(FormatString, x, y);
            return zsh.Length;
        }
    }
}



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/MaximumArgsFormatBenchmark.cs
================================================
﻿// Before use, You must change AssemblyName to "NewZString" of local ZString.csproj

extern alias NewZString;

using System;
using System.Collections.Generic;
using System.Text;
using Cysharp.Text;
using NZString = NewZString::Cysharp.Text.ZString;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;

using PF16 = Cysharp.Text.Utf16PreparedFormat<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int>;
using NPF16 = NewZString::Cysharp.Text.Utf16PreparedFormat<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int>;

using PF8 = Cysharp.Text.Utf8PreparedFormat<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int>;
using NPF8 = NewZString::Cysharp.Text.Utf8PreparedFormat<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int>;

namespace BenchmarkVsReleasedVersion
{
    [Config(typeof(BenchmarkConfig))]
    [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
    [DisassemblyDiagnoser(maxDepth: 3)]
    public class MaximumArgsFormatBenchmark
    {
        readonly int[] _args;

        readonly string _format;
        PF16 _utf16preparedFormat_;
        NPF16 _utf16preparedFormatN;

        PF8 _utf8preparedFormat_;
        NPF8 _utf8preparedFormatN;

        public MaximumArgsFormatBenchmark() 
        {
            _args = new int[16];
            var rand = new Random();
            _format = "<";
            for (var i = 0; i < _args.Length; i++)
            {
                _args[i] = rand.Next();
                _format += "{" + i + "}, ";
            }
            _format += ">";

            _utf16preparedFormat_ = new PF16(_format);
            _utf16preparedFormatN = new NPF16(_format);

            _utf8preparedFormat_ = new PF8(_format);
            _utf8preparedFormatN = new NPF8(_format);
        }

        [BenchmarkCategory("Format"), Benchmark(Baseline = true)]
        public string Format_()
        {
            return ZString.Format(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("Format"), Benchmark]
        public string FormatN()
        {
            return NZString.Format(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("CreatePreparedFormat"), Benchmark(Baseline = true)]
        public object CreatePreparedFormat_()
        {
            return new PF16(_format);
        }

        [BenchmarkCategory("CreatePreparedFormat"), Benchmark]
        public object CreatePreparedFormatN()
        {
            return new NPF16(_format);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf16PreparedFormat_()
        {
            return _utf16preparedFormat_.Format(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("Utf16PreparedFormat"), Benchmark]
        public string Utf16PreparedFormatN()
        {
            return _utf16preparedFormatN.Format(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark(Baseline = true)]
        public string Utf8PreparedFormat_()
        {
            return _utf8preparedFormat_.Format(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("Utf8PreparedFormat"), Benchmark]
        public string Utf8PreparedFormatN()
        {
            return _utf8preparedFormatN.Format(_args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf16StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateStringBuilder();
            zsh.AppendFormat(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf16StringBuilderAppendFormat"), Benchmark]
        public int Utf16StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateStringBuilder();
            zsh.AppendFormat(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark(Baseline = true)]
        public int Utf8StringBuilderAppendFormat_()
        {
            using var zsh = ZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
            return zsh.Length;
        }

        [BenchmarkCategory("Utf8StringBuilderAppendFormat"), Benchmark]
        public int Utf8StringBuilderAppendFormatN()
        {
            using var zsh = NZString.CreateUtf8StringBuilder();
            zsh.AppendFormat(_format, _args[0], _args[1], _args[2], _args[3], _args[4], _args[5], _args[6], _args[7], _args[8], _args[9], _args[10], _args[11], _args[12], _args[13], _args[14], _args[15]);
            return zsh.Length;
        }
    }
}



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/Program.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Columns;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Cysharp.Text;
using System;
using System.Buffers;
using System.Reflection;
using System.Text;

namespace BenchmarkVsReleasedVersion
{
    internal class BenchmarkConfig : ManualConfig
    {
        public BenchmarkConfig()
        {
            AddDiagnoser(MemoryDiagnoser.Default);
            AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1));
        }
    }

    public class Program
    {
        static void Main(string[] args)
        {
            BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()).Run(args);
        }
    }
}



================================================
FILE: sandbox/BenchmarkVsReleasedVersion/runall.cmd
================================================
dotnet run -c Release --filter *



================================================
FILE: sandbox/ConsoleApp/ConsoleApp.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BenchmarkDotNet" Version="0.12.1" />
    <PackageReference Include="System.Text.Json" Version="8.0.4" />
    <ProjectReference Include="..\..\src\ZString\ZString.csproj">
      <SetTargetFramework>TargetFramework=netstandard2.1</SetTargetFramework>
    </ProjectReference>
  </ItemGroup>

</Project>



================================================
FILE: sandbox/ConsoleApp/Program.cs
================================================
﻿using Cysharp.Text;
using System;
using System.Text;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

namespace ConsoleApp
{
    public struct MyStruct
    {

    }

    class Program
    {
        static void Main(string[] args)
        {
            // BenchmarkRunner.Run<JoinBenchmark>();
            Run();
        }

        static void Run()
        {
            ZString.Join(",", "a", "b");
            TimeSpan span = new TimeSpan(12, 34, 56);
            Console.WriteLine($"string.Format: {string.Format(@"{0:h\,h\:mm\:ss}", span)}");
            Console.WriteLine($"ZString.Format: {ZString.Format(@"{0:h\,h\:mm\:ss}", span)}");
        }
    }
    
    public class JoinBenchmark
    {
        public string[] Source = new []{ "111", "222", "333"};
        public const string Sp = ",";

        [Benchmark]
        public string StringJoin()
        {
            return string.Join(Sp, Source);
        }

        [Benchmark]
        public string ZStringJoin() 
        {
            return ZString.Join(Sp, Source);
        }
    }

    public class FormatBenchmark
    {
        int x;
        int y;
        string format;
        StringBuilder stringBuilder;

        public FormatBenchmark()
        {
            x = int.Parse("100");
            y = int.Parse("200");
            format = "x:{0}, y:{1}";
            stringBuilder = new StringBuilder();
        }

        public string StringFormat()
        {
            return string.Format(format, x, y);
        }

        public string ZStringFormat()
        {
            return ZString.Format(format, x, y);
        }

        //public string StringFormatterFormat()
        //{
        //    return StringBuffer.Format(format, x, y);
        //}
    }
}



================================================
FILE: sandbox/ConsoleAppNet472/App.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.6.0" newVersion="4.0.6.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
FILE: sandbox/ConsoleAppNet472/ConsoleAppNet472.csproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
    <PropertyGroup>
        <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
        <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
        <ProjectGuid>{BE8A17AA-504A-410D-B86D-92431B0F5594}</ProjectGuid>
        <OutputType>Exe</OutputType>
        <RootNamespace>ConsoleAppNet472</RootNamespace>
        <AssemblyName>ConsoleAppNet472</AssemblyName>
        <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
        <FileAlignment>512</FileAlignment>
        <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
        <Deterministic>true</Deterministic>
        <SignAssembly>true</SignAssembly>
        <AssemblyOriginatorKeyFile>../../opensource.snk</AssemblyOriginatorKeyFile>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
        <PlatformTarget>AnyCPU</PlatformTarget>
        <DebugSymbols>true</DebugSymbols>
        <DebugType>full</DebugType>
        <Optimize>false</Optimize>
        <OutputPath>bin\Debug\</OutputPath>
        <DefineConstants>DEBUG;TRACE</DefineConstants>
        <ErrorReport>prompt</ErrorReport>
        <WarningLevel>4</WarningLevel>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
        <PlatformTarget>AnyCPU</PlatformTarget>
        <DebugType>pdbonly</DebugType>
        <Optimize>true</Optimize>
        <OutputPath>bin\Release\</OutputPath>
        <DefineConstants>TRACE</DefineConstants>
        <ErrorReport>prompt</ErrorReport>
        <WarningLevel>4</WarningLevel>
    </PropertyGroup>
    <ItemGroup>
        <Reference Include="System" />
        <Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
            <HintPath>..\..\packages\System.Buffers.4.5.0\lib\netstandard2.0\System.Buffers.dll</HintPath>
        </Reference>
        <Reference Include="System.Core" />
        <Reference Include="System.Memory, Version=4.0.1.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
            <HintPath>..\..\packages\System.Memory.4.5.3\lib\netstandard2.0\System.Memory.dll</HintPath>
        </Reference>
        <Reference Include="System.Numerics" />
        <Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
            <HintPath>..\..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
        </Reference>
        <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=4.0.6.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
            <HintPath>..\..\packages\System.Runtime.CompilerServices.Unsafe.4.7.0\lib\netstandard2.0\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
        </Reference>
        <Reference Include="System.Xml.Linq" />
        <Reference Include="System.Data.DataSetExtensions" />
        <Reference Include="Microsoft.CSharp" />
        <Reference Include="System.Data" />
        <Reference Include="System.Net.Http" />
        <Reference Include="System.Xml" />
    </ItemGroup>
    <ItemGroup>
        <Compile Include="Program.cs" />
        <Compile Include="Properties\AssemblyInfo.cs" />
    </ItemGroup>
    <ItemGroup>
        <None Include="App.config" />
        <None Include="packages.config" />
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\src\ZString\ZString.csproj">
            <Project>{7b09d422-d19a-457e-ada0-4cdc2dc581bb}</Project>
            <Name>ZString</Name>
        </ProjectReference>
    </ItemGroup>
    <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
FILE: sandbox/ConsoleAppNet472/packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="System.Buffers" version="4.5.0" targetFramework="net472" />
  <package id="System.Memory" version="4.5.3" targetFramework="net472" />
  <package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net472" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="4.7.0" targetFramework="net472" />
</packages>


================================================
FILE: sandbox/ConsoleAppNet472/Program.cs
================================================
﻿using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleAppNet472
{
    class Program
    {
        static void Main(string[] args)
        {
            var x = ZString.CreateStringBuilder();

            var sb = new StringBuilder();


            

            x.AppendFormat("hoge{0:.##}, tako{1:000}", 123.456, 9);
            Console.WriteLine(x.ToString());

            var utf7 = ZString.CreateUtf8StringBuilder();
            

        }
    }
}



================================================
FILE: sandbox/ConsoleAppNet472/Properties/AssemblyInfo.cs
================================================
[Binary file]


================================================
FILE: sandbox/PerfBenchmark/PerfBenchmark.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <LangVersion>8.0</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BenchmarkDotNet" Version="0.12.1" />
    <PackageReference Include="StringFormatter" Version="1.0.0.13" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\ZString\ZString.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: sandbox/PerfBenchmark/Program.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using Cysharp.Text;
using System;
using System.Buffers;
using System.Reflection;
using System.Text;

namespace PerfBenchmark
{
    internal class BenchmarkConfig : ManualConfig
    {
        public BenchmarkConfig()
        {
            AddDiagnoser(MemoryDiagnoser.Default);
            AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1).WithRuntime(CoreRuntime.Core50));

            // Add Targetframeworks net47 to csproj(removed for CI)
            //AddJob(Job.ShortRun.WithWarmupCount(1).WithIterationCount(1).WithRuntime(ClrRuntime.Net47));
        }
    }

    public class Program
    {
        static void Main(string[] args)
        {
            BenchmarkSwitcher.FromAssembly(Assembly.GetEntryAssembly()).Run(args);
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/AppendPerformance.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Text;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class AppendPerformance
    {
        List<string> strings;
        const int COUNT = 1000;

        public AppendPerformance()
        {
            strings = new List<string>();
            for (int i = 0; i < 100; i++)
            {
                strings.Add("123456789");
            }
        }

        [Benchmark]
        public void ZStringUtf16()
        {
            for (int i = 0; i < COUNT; i++)
            {
                using (var sb = ZString.CreateStringBuilder())
                {
                    for (int j = 0; j < strings.Count; j++)
                    {
                        sb.Append(strings[j]);
                    }

                    _ = sb.ToString();
                }
            }
        }

        //[Benchmark]
        //public void ZStringUtf16SpanBased()
        //{
        //    for (int i = 0; i < COUNT; i++)
        //    {
        //        using (var sb = ZString.CreateStringBuilder())
        //        {
        //            for (int j = 0; j < strings.Count; j++)
        //            {
        //                sb.AppendSlow(strings[j]);
        //            }

        //            _ = sb.ToString();
        //        }
        //    }
        //}

        [Benchmark(Baseline = true)]
        public void StringBuilder()
        {
            for (int i = 0; i < COUNT; i++)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                for (int j = 0; j < strings.Count; j++)
                {
                    sb.Append(strings[j]);
                }

                _ = sb.ToString();
            }
        }
    }


    [Config(typeof(BenchmarkConfig))]
    public class Utf8AppendPerformance
    {
        List<string> strings;
        const int COUNT = 1000;

        public Utf8AppendPerformance()
        {
            strings = new List<string>();
            for (int i = 0; i < 100; i++)
            {
                strings.Add("123456789");
            }
        }

        [Benchmark]
        public void ZStringUtf8()
        {
            for (int i = 0; i < COUNT; i++)
            {
                using (var sb = ZString.CreateUtf8StringBuilder())
                {
                    for (int j = 0; j < strings.Count; j++)
                    {
                        sb.Append(strings[j]);
                    }

                    _ = sb.AsSpan().ToArray();
                }
            }
        }

        [Benchmark(Baseline = true)]
        public void StringBuilder()
        {
            for (int i = 0; i < COUNT; i++)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                for (int j = 0; j < strings.Count; j++)
                {
                    sb.Append(strings[j]);
                }

                _ = sb.ToString();
            }
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/FormatBenchmark.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Formatting;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class FormatBenchmark
    {
        int x;
        int y;
        string format;
        StringBuilder stringBuilder;
        Utf16PreparedFormat<int, int> preparedFormat;

        public FormatBenchmark()
        {
            x = int.Parse("100");
            y = int.Parse("200");
            format = "x:{0}, y:{1}";
            stringBuilder = new StringBuilder();
            preparedFormat = new Utf16PreparedFormat<int,int>(format);
        }

        [Benchmark(Baseline = true)]
        public string StringFormat()
        {
            return string.Format(format, x, y);
        }

        [Benchmark]
        public string ZStringFormat()
        {
            return ZString.Format(format, x, y);
        }

        [Benchmark]
        public string ZStringPreparedFormat()
        {
            return preparedFormat.Format(x, y);
        }

        [Benchmark]
        public string StringFormatterFormat()
        {
            return StringBuffer.Format(format, x, y);
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/ReplaceBenchmark.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Formatting;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class ReplaceBenchmark
    {
        StringBuilder bcl;

        string text = "The quick brown fox jumped over the lazy dogs.";
        string largeText;

        string guid = Guid.NewGuid().ToString();

        readonly string[] csharpKeywords =
        {
            "abstract",
            "as",
            "async",
            "await",
            "base",
            "bool",
            "break",
            "byte",
            "case",
            "catch",
            "char",
            "checked",
            "class",
            "const",
            "continue",
            "decimal",
            "default",
            "delegate",
            "do",
            "double",
            "else",
            "enum",
            "event",
            "explicit",
            "extern",
            "false",
            "finally",
            "fixed",
            "float",
            "for",
            "foreach",
            "goto",
            "if",
            "implicit",
            "in",
            "int",
            "interface",
            "internal",
            "is",
            "lock",
            "long",
            "namespace",
            "new",
            "null",
            "object",
            "operator",
            "out",
            "override",
            "params",
            "private",
            "protected",
            "public",
            "readonly",
            "ref",
            "return",
            "sbyte",
            "sealed",
            "short",
            "sizeof",
            "stackalloc",
            "static",
            "string",
            "struct",
            "switch",
            "this",
            "throw",
            "true",
            "try",
            "typeof",
            "uint",
            "ulong",
            "unchecked",
            "unsafe",
            "ushort",
            "using",
            "virtual",
            "volatile",
            "void",
            "while",
        };

        private static string GetThisFilePath([System.Runtime.CompilerServices.CallerFilePath] string path = null) => path;

        public ReplaceBenchmark()
        {
            bcl = new StringBuilder();
            largeText = System.IO.File.ReadAllText(GetThisFilePath()); //read this file
            if (largeText.Length < 2048)
                throw new Exception();
        }

        [Benchmark]
        public int ReplaceChar()
        {
            bcl.Clear();
            return bcl.Append(text).Replace(' ', '\n').Length;
        }

        [Benchmark]
        public int ZReplaceChar()
        {
            using var zsb = ZString.CreateStringBuilder(true);
            zsb.Append(text);
            zsb.Replace(' ', '\n');
            return zsb.Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int ReplaceString()
        {
            bcl.Clear();
            return bcl.Append(text).Replace(" ", "\r\n").Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int ZReplaceString()
        {
            using var zsb = ZString.CreateStringBuilder(true);
            zsb.Append(text);
            zsb.Replace(" ", "\r\n");
            return zsb.Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int NotReplaced()
        {
            bcl.Clear();
            bcl.Append(largeText);
            bcl.Replace(guid, "XXXXXX"); // GUID value should not be included in this file.
            return bcl.Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int ZNotReplaced()
        {
            using var zsb = ZString.CreateStringBuilder(true);
            zsb.Append(text);
            zsb.Replace(guid, "XXXXXX"); // GUID value should not be included in this file.
            return zsb.Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int ManyTimesReplace()
        {
            bcl.Clear();
            bcl.Append(largeText);
            // remove all keywords
            foreach (var keyword in csharpKeywords)
            {
                bcl.Replace(keyword, "");
            }
            return bcl.Length; // Use Length to avoid omitting it
        }

        [Benchmark]
        public int ZManyTimesReplace()
        {
            using var zsb = ZString.CreateStringBuilder(true);
            zsb.Append(text);
            // remove all keywords
            foreach (var keyword in csharpKeywords)
            {
                zsb.Replace(keyword, "");
            }
            return zsb.Length; // Use Length to avoid omitting it
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/SixObjectConcatBenchmark.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Text;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class SixObjectConcatBenchmark
    {
        int x;
        int y;
        int z;

        public SixObjectConcatBenchmark()
        {
            x = int.Parse("333");
            y = int.Parse("444");
            z = int.Parse("555");
        }

        [Benchmark(Baseline = true)]
        public string StringPlus()
        {
            return "x:" + x + " y:" + y + " z:" + z;
        }

        [Benchmark]
        public string ZStringConcat()
        {
            return ZString.Concat("x:", x, " y:", y, " z:", z);
        }

        [Benchmark]
        public string StringFormat()
        {
            return string.Format("x:{0} y:{1} z:{2}", x, y, z);
        }

        [Benchmark]
        public string ZStringFormat()
        {
            return ZString.Format("x:{0} y:{1} z:{2}", x, y, z);
        }

        [Benchmark]
        public string StringBuilder()
        {
            var sb = new StringBuilder();
            sb.Append("x:");
            sb.Append(x);
            sb.Append(" y:");
            sb.Append(y);
            sb.Append(" z:");
            sb.Append(z);
            return sb.ToString();
        }

        [Benchmark]
        public string ZStringBuilder()
        {
            using var sb = ZString.CreateStringBuilder();
            sb.Append("x:");
            sb.Append(x);
            sb.Append(" y:");
            sb.Append(y);
            sb.Append(" z:");
            sb.Append(z);
            return sb.ToString();
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/StringBuilderAppendFormat.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Text;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class StringBuilderAppendFormat
    {
        double[] dValues;
        float[] fValues;
        decimal[] mValues;
        public StringBuilderAppendFormat()
        {
            dValues = new[] { 0d, double.MaxValue, double.MinValue };
            fValues = new[] { 0f, float.MaxValue, float.MinValue };
            mValues = new[] { 0m, decimal.MaxValue, decimal.MinValue };

#if NETCOREAPP || NETSTANDARD2_1
            if (StringBuilder() != ZStringBuilder())
                throw new Exception();
#endif
        }


#if NETCOREAPP || NETSTANDARD2_1
        [Benchmark(Baseline = true)]
        public int StringBuilder()
        {
            var sb = new StringBuilder();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "double", dValues[0], dValues[1], dValues[2], 1);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "float", fValues[0], fValues[1], fValues[2], 2);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "decimal", mValues[0], mValues[1], mValues[2], 3);
            sb.AppendLine();
            return sb.Length;
        }
#endif

        [Benchmark]
        public int ZStringBuilder()
        {
            using var sb = ZString.CreateStringBuilder();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "double", dValues[0], dValues[1], dValues[2], 1);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "float", fValues[0], fValues[1], fValues[2], 2);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "decimal", mValues[0], mValues[1], mValues[2], 3);
            sb.AppendLine();
            return sb.Length;
        }

        [Benchmark]
        public int ZStringBuilderUtf8()
        {
            using var sb = ZString.CreateUtf8StringBuilder();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "double", dValues[0], dValues[1], dValues[2], 1);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "float", fValues[0], fValues[1], fValues[2], 2);
            sb.AppendLine();
            sb.AppendFormat("{{ {0}: {1}, {2}, {3} }} - {4}", "decimal", mValues[0], mValues[1], mValues[2], 3);
            sb.AppendLine();
            return sb.Length;
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/StringBuilderAppendJoin.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Text;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class StringBuilderAppendJoin
    {
        double[] dValues;
        float[] fValues;
        decimal[] mValues;
        public StringBuilderAppendJoin()
        {
            dValues = new[] { 0d, double.MaxValue, double.MinValue };
            fValues = new[] { 0f, float.MaxValue, float.MinValue };
            mValues = new[] { 0m, decimal.MaxValue, decimal.MinValue };

#if NETCOREAPP || NETSTANDARD2_1
            if (StringBuilder() != ZStringBuilder())
                throw new Exception();
#endif
        }


#if NETCOREAPP || NETSTANDARD2_1
        [Benchmark(Baseline = true)]
        public int StringBuilder()
        {
            var sb = new StringBuilder();
            sb.Append("double: ");
            sb.AppendJoin(", ", dValues);
            sb.AppendLine();
            sb.Append("float: ");
            sb.AppendJoin(", ", fValues);
            sb.AppendLine();
            sb.Append("decimal: ");
            sb.AppendJoin(", ", mValues);
            sb.AppendLine();
            return sb.Length;
        }
#endif

        [Benchmark]
        public int ZStringBuilder()
        {
            using var sb = ZString.CreateStringBuilder();
            sb.Append("double: ");
            sb.AppendJoin(", ", dValues);
            sb.AppendLine();
            sb.Append("float: ");
            sb.AppendJoin(", ", fValues);
            sb.AppendLine();
            sb.Append("decimal: ");
            sb.AppendJoin(", ", mValues);
            sb.AppendLine();
            return sb.Length;
        }
    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/StringListJoinBenchmark.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Linq;
namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class StringListJoinBenchmark
    {
        //private const char Separator = ',';
        private const string Separator = ",";

        List<string> _emptyList;
        IEnumerable<string> _enum1;
        string[] _array1;
        List<string> _list1;
        IEnumerable<string> _enum2;
        string[] _array2;
        List<string> _list2;
        IEnumerable<string> _enum10;
        List<string> _list10;
        string[] _array10;

        public StringListJoinBenchmark()
        {
            _emptyList = new List<string>();
            _enum1 = Enumerable.Repeat(Guid.NewGuid().ToString(), 1);
            _list1 = _enum1.ToList();
            _array1 = _enum1.ToArray();
            _enum2 = Enumerable.Repeat(Guid.NewGuid().ToString(), 2);
            _list2 = _enum2.ToList();
            _array2 = _enum2.ToArray();
            _enum10 = Enumerable.Repeat(Guid.NewGuid().ToString(), 10);
            _list10 = _enum10.ToList();
            _array10 = _enum10.ToArray();
        }

        [Benchmark]
        public string JoinEmptyList() => String.Join(Separator, _emptyList);

        [Benchmark]
        public string ZJoinEmptyList() => ZString.Join(Separator, _emptyList);

        [Benchmark]
        public string JoinList1() => String.Join(Separator, _list1);

        [Benchmark]
        public string ZJoinList1() => ZString.Join(Separator, _list1);

        [Benchmark]
        public string JoinArray1() => String.Join(Separator, _array1);

        [Benchmark]
        public string ZJoinArray1() => ZString.Join(Separator, _array1);

        [Benchmark]
        public string JoinEnumerable1() => String.Join(Separator, _enum1);

        [Benchmark]
        public string ZJoinEnumerable1() => ZString.Join(Separator, _enum1);

        [Benchmark]
        public string JoinList2() => String.Join(Separator, _list2);

        [Benchmark]
        public string ZJoinList2() => ZString.Join(Separator, _list2);

        [Benchmark]
        public string JoinArray2() => String.Join(Separator, _array2);

        [Benchmark]
        public string ZJoinArray2() => ZString.Join(Separator, _array2);

        [Benchmark]
        public string JoinEnumerable2() => String.Join(Separator, _enum2);

        [Benchmark]
        public string ZJoinEnumerable2() => ZString.Join(Separator, _enum2);

        [Benchmark]
        public string JoinList10() => String.Join(Separator, _list10);

        [Benchmark]
        public string ZJoinList10() => ZString.Join(Separator, _list10);

        [Benchmark]
        public string JoinArray10() => String.Join(Separator, _array10);

        [Benchmark]
        public string ZJoinArray10() => ZString.Join(Separator, _array10);

        [Benchmark]
        public string JoinEnumerable10() => String.Join(Separator, _enum10);

        [Benchmark]
        public string ZJoinEnumerable10() => ZString.Join(Separator, _enum10);

    }
}



================================================
FILE: sandbox/PerfBenchmark/Benchmarks/VSStringFormatter.cs
================================================
﻿using BenchmarkDotNet.Attributes;
using Cysharp.Text;
using System;
using System.Collections.Generic;
using System.Text;

namespace PerfBenchmark.Benchmarks
{
    [Config(typeof(BenchmarkConfig))]
    public class VSStringFormatter
    {
        [Benchmark]
        public string ZStringConcatInt()
        {
            return ZString.Concat((int)1);
        }

        [Benchmark]
        public string ZStringBuilderInt()
        {
            using var builder = Cysharp.Text.ZString.CreateStringBuilder();
            builder.Append((int)1);
            return builder.ToString();
        }

        [Benchmark]
        public string StringFormatterInt()
        {
            var builder = new System.Text.Formatting.StringBuffer();
            builder.Append((int)1, System.Text.Formatting.StringView.Empty);
            return builder.ToString();
        }

        [Benchmark]
        public string BclStringBuilderInt()
        {
            var builder = new StringBuilder();
            builder.Append((int)1);
            return builder.ToString();
        }
    }
}



================================================
FILE: src/ZString/_InternalVisibleTo.cs
================================================
﻿using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("ConsoleApp, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]
[assembly: InternalsVisibleTo("ConsoleAppNet472, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]
[assembly: InternalsVisibleTo("ZString.Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]
[assembly: InternalsVisibleTo("ZString.NetCore2Tests, PublicKey=00240000048000009400000006020000002400005253413100040000010001000144ec28f1e9ef7b17dacc47425a7a153aea0a7baa590743a2d1a86f4b3e10a8a12712c6e647966bfd8bd6e830048b23bd42bbc56f179585c15b8c19cf86c0eed1b73c993dd7a93a30051dd50fdda0e4d6b65e6874e30f1c37cf8bcbc7fe02c7f2e6a0a3327c0ccc1631bf645f40732521fa0b41a30c178d08f7dd779d42a1ee")]


================================================
FILE: src/ZString/EnumUtil.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class EnumUtil<T>
        // where T : Enum
    {
        const string InvalidName = "$";

        static readonly Dictionary<T, string> names;
        static readonly Dictionary<T, byte[]> utf8names;

        static EnumUtil()
        {
            var enumNames = Enum.GetNames(typeof(T));
            var values =
#if NET7_0_OR_GREATER
                Enum.GetValuesAsUnderlyingType(typeof(T));
#else
                Enum.GetValues(typeof(T));
#endif
            names = new Dictionary<T, string>(enumNames.Length);
            utf8names = new Dictionary<T, byte[]>(enumNames.Length);
            for (int i = 0; i < enumNames.Length; i++)
            {
                var value = (T)values.GetValue(i)!;
                if (names.ContainsKey(value))
                {
                    // already registered = invalid.
                    names[value] = InvalidName;
                    utf8names[value] = Array.Empty<byte>(); // byte[0] == Invalid.
                }
                else
                {
                    names.Add(value, enumNames[i]);
                    utf8names.Add(value, Encoding.UTF8.GetBytes(enumNames[i]));
                }
            }
        }

        public static bool TryFormatUtf16(T value, Span<char> dest, out int written, ReadOnlySpan<char> _)
        {
            if (!names.TryGetValue(value, out var v) || v == InvalidName)
            {
                v = value!.ToString(); // T is Enum, not null always
            }

            written = v.Length;
            return v.AsSpan().TryCopyTo(dest);
        }

        public static bool TryFormatUtf8(T value, Span<byte> dest, out int written, StandardFormat _)
        {
            if (!utf8names.TryGetValue(value, out var v) || v.Length == 0)
            {
                v = Encoding.UTF8.GetBytes(value!.ToString());
            }

            written = v.Length;
            return v.AsSpan().TryCopyTo(dest);
        }
    }
}



================================================
FILE: src/ZString/ExceptionUtil.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class ExceptionUtil
    {
        internal static void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }

        internal static void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        internal static void ThrowFormatError()
        {
            throw new FormatException("Input string was not in a correct format.");
        }
    }
}



================================================
FILE: src/ZString/FastNumberWriter.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class FastNumberWriter
    {
        // Faster than .NET Core .TryFormat without format string.

        public static bool TryWriteInt64(Span<char> buffer, out int charsWritten, long value)
        {
            var offset = 0;
            charsWritten = 0;
            long num1 = value, num2, num3, num4, num5, div;

            if (value < 0)
            {
                if (value == long.MinValue) // -9223372036854775808
                {
                    if (buffer.Length < 20) { return false; }
                    buffer[offset++] = (char)'-';
                    buffer[offset++] = (char)'9';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'0';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'6';
                    buffer[offset++] = (char)'8';
                    buffer[offset++] = (char)'5';
                    buffer[offset++] = (char)'4';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'5';
                    buffer[offset++] = (char)'8';
                    buffer[offset++] = (char)'0';
                    buffer[offset++] = (char)'8';
                    charsWritten = offset;
                    return true;
                }

                if (buffer.Length < 1) { return false; }
                buffer[offset++] = (char)'-';
                num1 = unchecked(-value);
            }

            // WriteUInt64(inlined)

            if (num1 < 10000)
            {
                if (num1 < 10) { if (buffer.Length < 1) { return false; } goto L1; }
                if (num1 < 100) { if (buffer.Length < 2) { return false; } goto L2; }
                if (num1 < 1000) { if (buffer.Length < 3) { return false; } goto L3; }
                if (buffer.Length < 4) { return false; }
                goto L4;
            }
            else
            {
                num2 = num1 / 10000;
                num1 -= num2 * 10000;
                if (num2 < 10000)
                {
                    if (num2 < 10) { if (buffer.Length < 5) { return false; } goto L5; }
                    if (num2 < 100) { if (buffer.Length < 6) { return false; } goto L6; }
                    if (num2 < 1000) { if (buffer.Length < 7) { return false; } goto L7; }
                    if (buffer.Length < 8) { return false; }
                    goto L8;
                }
                else
                {
                    num3 = num2 / 10000;
                    num2 -= num3 * 10000;
                    if (num3 < 10000)
                    {
                        if (num3 < 10) { if (buffer.Length < 9) { return false; } goto L9; }
                        if (num3 < 100) { if (buffer.Length < 10) { return false; } goto L10; }
                        if (num3 < 1000) { if (buffer.Length < 11) { return false; } goto L11; }
                        if (buffer.Length < 12) { return false; }
                        goto L12;
                    }
                    else
                    {
                        num4 = num3 / 10000;
                        num3 -= num4 * 10000;
                        if (num4 < 10000)
                        {
                            if (num4 < 10) { if (buffer.Length < 13) { return false; } goto L13; }
                            if (num4 < 100) { if (buffer.Length < 14) { return false; } goto L14; }
                            if (num4 < 1000) { if (buffer.Length < 15) { return false; } goto L15; }
                            if (buffer.Length < 16) { return false; }
                            goto L16;
                        }
                        else
                        {
                            num5 = num4 / 10000;
                            num4 -= num5 * 10000;
                            if (num5 < 10000)
                            {
                                if (num5 < 10) { if (buffer.Length < 17) { return false; } goto L17; }
                                if (num5 < 100) { if (buffer.Length < 18) { return false; } goto L18; }
                                if (num5 < 1000) { if (buffer.Length < 19) { return false; } goto L19; }
                                if (buffer.Length < 20) { return false; }
                                goto L20;
                            }
                            L20:
                            buffer[offset++] = (char)('0' + (div = (num5 * 8389L) >> 23));
                            num5 -= div * 1000;
                            L19:
                            buffer[offset++] = (char)('0' + (div = (num5 * 5243L) >> 19));
                            num5 -= div * 100;
                            L18:
                            buffer[offset++] = (char)('0' + (div = (num5 * 6554L) >> 16));
                            num5 -= div * 10;
                            L17:
                            buffer[offset++] = (char)('0' + (num5));
                        }
                        L16:
                        buffer[offset++] = (char)('0' + (div = (num4 * 8389L) >> 23));
                        num4 -= div * 1000;
                        L15:
                        buffer[offset++] = (char)('0' + (div = (num4 * 5243L) >> 19));
                        num4 -= div * 100;
                        L14:
                        buffer[offset++] = (char)('0' + (div = (num4 * 6554L) >> 16));
                        num4 -= div * 10;
                        L13:
                        buffer[offset++] = (char)('0' + (num4));
                    }
                    L12:
                    buffer[offset++] = (char)('0' + (div = (num3 * 8389L) >> 23));
                    num3 -= div * 1000;
                    L11:
                    buffer[offset++] = (char)('0' + (div = (num3 * 5243L) >> 19));
                    num3 -= div * 100;
                    L10:
                    buffer[offset++] = (char)('0' + (div = (num3 * 6554L) >> 16));
                    num3 -= div * 10;
                    L9:
                    buffer[offset++] = (char)('0' + (num3));
                }
                L8:
                buffer[offset++] = (char)('0' + (div = (num2 * 8389L) >> 23));
                num2 -= div * 1000;
                L7:
                buffer[offset++] = (char)('0' + (div = (num2 * 5243L) >> 19));
                num2 -= div * 100;
                L6:
                buffer[offset++] = (char)('0' + (div = (num2 * 6554L) >> 16));
                num2 -= div * 10;
                L5:
                buffer[offset++] = (char)('0' + (num2));
            }
            L4:
            buffer[offset++] = (char)('0' + (div = (num1 * 8389L) >> 23));
            num1 -= div * 1000;
            L3:
            buffer[offset++] = (char)('0' + (div = (num1 * 5243L) >> 19));
            num1 -= div * 100;
            L2:
            buffer[offset++] = (char)('0' + (div = (num1 * 6554L) >> 16));
            num1 -= div * 10;
            L1:
            buffer[offset++] = (char)('0' + (num1));

            charsWritten = offset;
            return true;
        }

        public static bool TryWriteUInt64(Span<char> buffer, out int charsWritten, ulong value)
        {
            ulong num1 = value, num2, num3, num4, num5, div;
            charsWritten = 0;
            var offset = 0;

            if (num1 < 10000)
            {
                if (num1 < 10) { if (buffer.Length < 1) { return false; } goto L1; }
                if (num1 < 100) { if (buffer.Length < 2) { return false; } goto L2; }
                if (num1 < 1000) { if (buffer.Length < 3) { return false; } goto L3; }
                if (buffer.Length < 4) { return false; }
                goto L4;
            }
            else
            {
                num2 = num1 / 10000;
                num1 -= num2 * 10000;
                if (num2 < 10000)
                {
                    if (num2 < 10) { if (buffer.Length < 5) { return false; } goto L5; }
                    if (num2 < 100) { if (buffer.Length < 6) { return false; } goto L6; }
                    if (num2 < 1000) { if (buffer.Length < 7) { return false; } goto L7; }
                    if (buffer.Length < 8) { return false; }
                    goto L8;
                }
                else
                {
                    num3 = num2 / 10000;
                    num2 -= num3 * 10000;
                    if (num3 < 10000)
                    {
                        if (num3 < 10) { if (buffer.Length < 9) { return false; } goto L9; }
                        if (num3 < 100) { if (buffer.Length < 10) { return false; } goto L10; }
                        if (num3 < 1000) { if (buffer.Length < 11) { return false; } goto L11; }
                        if (buffer.Length < 12) { return false; }
                        goto L12;
                    }
                    else
                    {
                        num4 = num3 / 10000;
                        num3 -= num4 * 10000;
                        if (num4 < 10000)
                        {
                            if (num4 < 10) { if (buffer.Length < 13) { return false; } goto L13; }
                            if (num4 < 100) { if (buffer.Length < 14) { return false; } goto L14; }
                            if (num4 < 1000) { if (buffer.Length < 15) { return false; } goto L15; }
                            if (buffer.Length < 16) { return false; }
                            goto L16;
                        }
                        else
                        {
                            num5 = num4 / 10000;
                            num4 -= num5 * 10000;
                            if (num5 < 10000)
                            {
                                if (num5 < 10) { if (buffer.Length < 17) { return false; } goto L17; }
                                if (num5 < 100) { if (buffer.Length < 18) { return false; } goto L18; }
                                if (num5 < 1000) { if (buffer.Length < 19) { return false; } goto L19; }
                                if (buffer.Length < 20) { return false; }
                                goto L20;
                            }
                            L20:
                            buffer[offset++] = (char)('0' + (div = (num5 * 8389UL) >> 23));
                            num5 -= div * 1000;
                            L19:
                            buffer[offset++] = (char)('0' + (div = (num5 * 5243UL) >> 19));
                            num5 -= div * 100;
                            L18:
                            buffer[offset++] = (char)('0' + (div = (num5 * 6554UL) >> 16));
                            num5 -= div * 10;
                            L17:
                            buffer[offset++] = (char)('0' + (num5));
                        }
                        L16:
                        buffer[offset++] = (char)('0' + (div = (num4 * 8389UL) >> 23));
                        num4 -= div * 1000;
                        L15:
                        buffer[offset++] = (char)('0' + (div = (num4 * 5243UL) >> 19));
                        num4 -= div * 100;
                        L14:
                        buffer[offset++] = (char)('0' + (div = (num4 * 6554UL) >> 16));
                        num4 -= div * 10;
                        L13:
                        buffer[offset++] = (char)('0' + (num4));
                    }
                    L12:
                    buffer[offset++] = (char)('0' + (div = (num3 * 8389UL) >> 23));
                    num3 -= div * 1000;
                    L11:
                    buffer[offset++] = (char)('0' + (div = (num3 * 5243UL) >> 19));
                    num3 -= div * 100;
                    L10:
                    buffer[offset++] = (char)('0' + (div = (num3 * 6554UL) >> 16));
                    num3 -= div * 10;
                    L9:
                    buffer[offset++] = (char)('0' + (num3));
                }
                L8:
                buffer[offset++] = (char)('0' + (div = (num2 * 8389UL) >> 23));
                num2 -= div * 1000;
                L7:
                buffer[offset++] = (char)('0' + (div = (num2 * 5243UL) >> 19));
                num2 -= div * 100;
                L6:
                buffer[offset++] = (char)('0' + (div = (num2 * 6554UL) >> 16));
                num2 -= div * 10;
                L5:
                buffer[offset++] = (char)('0' + (num2));
            }
            L4:
            buffer[offset++] = (char)('0' + (div = (num1 * 8389UL) >> 23));
            num1 -= div * 1000;
            L3:
            buffer[offset++] = (char)('0' + (div = (num1 * 5243UL) >> 19));
            num1 -= div * 100;
            L2:
            buffer[offset++] = (char)('0' + (div = (num1 * 6554UL) >> 16));
            num1 -= div * 10;
            L1:
            buffer[offset++] = (char)('0' + (num1));

            charsWritten = offset;
            return true;
        }
    }
}



================================================
FILE: src/ZString/FormatHelper.cs
================================================
﻿using System;
using System.Text;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    internal static partial class Utf16FormatHelper
    {
        const char sp = (char)' ';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName)
            where TBufferWriter : IBufferWriter<char>
        {
            if (width <= 0) // leftJustify
            {
                var span = sb.GetSpan(0);
                if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var argWritten, format))
                {
                    sb.Advance(0);
                    span = sb.GetSpan(Math.Max(span.Length + 1, argWritten));
                    if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out argWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }
                sb.Advance(argWritten);

                width *= -1;
                int padding = width - argWritten;
                if (width > 0 && padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }
            }
            else
            {
                FormatToRightJustify(ref sb, arg, width, format, argName);
            }
        }

        private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName)
            where TBufferWriter : IBufferWriter<char>
        {
            if (typeof(T) == typeof(string))
            {
                var s = Unsafe.As<string>(arg);
                int padding = width - s.Length;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(s.Length);
                s.AsSpan().CopyTo(span);
                sb.Advance(s.Length);
            }
            else
            {
                Span<char> s = stackalloc char[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                {
                    s = stackalloc char[s.Length * 2];
                    if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                int padding = width - charsWritten;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(charsWritten);
                s.CopyTo(span);
                sb.Advance(charsWritten);
            }
        }
    }

    internal static partial class Utf8FormatHelper
    {
        const byte sp = (byte)' ';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName)
            where TBufferWriter : IBufferWriter<byte>
        {
            if (width <= 0) // leftJustify
            {
                var span = sb.GetSpan(0);
                if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var argWritten, format))
                {
                    sb.Advance(0);
                    span = sb.GetSpan(Math.Max(span.Length + 1, argWritten));
                    if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out argWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }
                sb.Advance(argWritten);

                width *= -1;
                int padding = width - argWritten;
                if (width > 0 && padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }
            }
            else
            {
                FormatToRightJustify(ref sb, arg, width, format, argName);
            }
        }

        private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName)
            where TBufferWriter : IBufferWriter<byte>
        {
            if (typeof(T) == typeof(string))
            {
                var s = Unsafe.As<string>(arg);
                int padding = width - s.Length;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                ZString.AppendChars(ref sb, s.AsSpan());
            }
            else
            {
                Span<byte> s = stackalloc byte[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                {
                    s = stackalloc byte[s.Length * 2];
                    if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                int padding = width - charsWritten;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(charsWritten);
                s.CopyTo(span);
                sb.Advance(charsWritten);
            }
        }
    }

}


================================================
FILE: src/ZString/FormatHelper.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Text;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
<# foreach(var utf in utfTypes ) { var isUtf16 = (utf == "Utf16"); var elemType = isUtf16 ? "char" : "byte"; #>
    internal static partial class <#= utf #>FormatHelper
    {
        const <#= elemType #> sp = (<#= elemType #>)' ';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, <#= isUtf16 ? "ReadOnlySpan<char>" : "StandardFormat" #> format, string argName)
            where TBufferWriter : IBufferWriter<<#= elemType #>>
        {
            if (width <= 0) // leftJustify
            {
                var span = sb.GetSpan(0);
                if (!<#= utf #>ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var argWritten, format))
                {
                    sb.Advance(0);
                    span = sb.GetSpan(Math.Max(span.Length + 1, argWritten));
                    if (!<#= utf #>ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out argWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }
                sb.Advance(argWritten);

                width *= -1;
                int padding = width - argWritten;
                if (width > 0 && padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }
            }
            else
            {
                FormatToRightJustify(ref sb, arg, width, format, argName);
            }
        }

        private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, <#= isUtf16 ? "ReadOnlySpan<char>" : "StandardFormat" #> format, string argName)
            where TBufferWriter : IBufferWriter<<#= elemType #>>
        {
            if (typeof(T) == typeof(string))
            {
                var s = Unsafe.As<string>(arg);
                int padding = width - s.Length;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

<# if(isUtf16) { #>
                var span = sb.GetSpan(s.Length);
                s.AsSpan().CopyTo(span);
                sb.Advance(s.Length);
<# }else { #>
                ZString.AppendChars(ref sb, s.AsSpan());
<# } #>
            }
            else
            {
                Span<<#= elemType #>> s = stackalloc <#= elemType #>[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                if (!<#= utf #>ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                {
                    s = stackalloc <#= elemType #>[s.Length * 2];
                    if (!<#= utf #>ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                int padding = width - charsWritten;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(charsWritten);
                s.CopyTo(span);
                sb.Advance(charsWritten);
            }
        }
    }

<# } // foreach(utf) #>
}


================================================
FILE: src/ZString/FormatParser.cs
================================================
using System;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    internal static class FormatParser
    {
        // {index[,alignment][:formatString]}

        public readonly ref struct ParseResult
        {
            public readonly int Index;
            public readonly ReadOnlySpan<char> FormatString;
            public readonly int LastIndex;
            public readonly int Alignment;

            public ParseResult(int index, ReadOnlySpan<char> formatString, int lastIndex, int alignment)
            {
                Index = index;
                FormatString = formatString;
                LastIndex = lastIndex;
                Alignment = alignment;
            }
        }

        internal const int ArgLengthLimit = 16;
        internal const int WidthLimit = 1000; // Note:  -WidthLimit <  ArgAlign < WidthLimit

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParserScanResult ScanFormatString(string format, ref int i)
        {
            var len = format.Length;
            char c = format[i];

            i++; // points netxt char
            if (c == '}')
            {
                // skip escaped '}'
                if (i < len && format[i] == '}')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    ExceptionUtil.ThrowFormatError();
                    return ParserScanResult.NormalChar; // NOTE Don't reached
                }
            }
            else if (c == '{')
            {
                // skip escaped '{'
                if (i < len && format[i] == '{')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    i--;
                    return ParserScanResult.BraceOpen;
                }
            }
            else
            {
                // ch is the normal char OR end of text
                return ParserScanResult.NormalChar;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParserScanResult ScanFormatString(ReadOnlySpan<char> format, ref int i)
        {
            var len = format.Length;
            char c = format[i];

            i++; // points netxt char
            if (c == '}')
            {
                // skip escaped '}'
                if (i < len && format[i] == '}')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    ExceptionUtil.ThrowFormatError();
                    return ParserScanResult.NormalChar; // NOTE Don't reached
                }
            }
            else if (c == '{')
            {
                // skip escaped '{'
                if (i < len && format[i] == '{')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    i--;
                    return ParserScanResult.BraceOpen;
                }
            }
            else
            {
                // ch is the normal char OR end of text
                return ParserScanResult.NormalChar;
            }
        }

        // Accept only non-unicode numbers
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsDigit(char c) => '0' <= c && c <= '9';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParseResult Parse(ReadOnlySpan<char> format, int i)
        {
            char c = default;
            var len = format.Length;

            i++; // Skip `{`

            //  === Index Component ===
            //   ('0'-'9')+ WS*

            if (i == len || !IsDigit(c = format[i]))
            {
                ExceptionUtil.ThrowFormatError();
            }

            int paramIndex = 0;
            do
            {
                paramIndex = (paramIndex * 10) + c - '0';

                if (++i == len)
                    ExceptionUtil.ThrowFormatError();

                c = format[i];
            }
            while (IsDigit(c) && paramIndex < ArgLengthLimit);

            if (paramIndex >= ArgLengthLimit)
            {
                ExceptionUtil.ThrowFormatException();
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Alignment Component ===
            //   comma WS* minus? ('0'-'9')+ WS*

            int alignment = 0;

            if (c == ',')
            {
                i++;

                // skip whitespace.
                while (i < len && (c = format[i]) == ' ')
                    i++;

                if (i == len)
                {
                    ExceptionUtil.ThrowFormatError();
                }

                var leftJustify = false;
                if (c == '-')
                {
                    leftJustify = true;

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }

                if (!IsDigit(c))
                {
                    ExceptionUtil.ThrowFormatError();
                }

                do
                {
                    alignment = (alignment * 10) + c - '0';

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }
                while (IsDigit(c) && alignment < WidthLimit);

                if (leftJustify)
                    alignment *= -1;
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Format String Component ===

            ReadOnlySpan<char> itemFormatSpan = default;

            if (c == ':')
            {
                i++;
                int formatStart = i;

                while (true)
                {
                    if (i == len)
                    {
                        ExceptionUtil.ThrowFormatError();
                    }
                    c = format[i];

                    if (c == '}')
                    {
                        break;
                    }
                    else if (c == '{')
                    {
                        ExceptionUtil.ThrowFormatError();
                    }

                    i++;
                }

                // has format
                if (i > formatStart)
                {
                    itemFormatSpan = format.Slice(formatStart, i - formatStart);
                }
            }
            else if (c != '}')
            {
                // Unexpected character
                ExceptionUtil.ThrowFormatError();
            }

            i++; // Skip `}`
            return new ParseResult(paramIndex, itemFormatSpan, i, alignment);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParseResult Parse(string format, int i)
        {
            char c = default;
            var len = format.Length;

            i++; // Skip `{`

            //  === Index Component ===
            //   ('0'-'9')+ WS*

            if (i == len || !IsDigit(c = format[i]))
            {
                ExceptionUtil.ThrowFormatError();
            }

            int paramIndex = 0;
            do
            {
                paramIndex = (paramIndex * 10) + c - '0';

                if (++i == len)
                    ExceptionUtil.ThrowFormatError();

                c = format[i];
            }
            while (IsDigit(c) && paramIndex < ArgLengthLimit);

            if (paramIndex >= ArgLengthLimit)
            {
                ExceptionUtil.ThrowFormatException();
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Alignment Component ===
            //   comma WS* minus? ('0'-'9')+ WS*

            int alignment = 0;

            if (c == ',')
            {
                i++;

                // skip whitespace.
                while (i < len && (c = format[i]) == ' ')
                    i++;

                if (i == len)
                {
                    ExceptionUtil.ThrowFormatError();
                }

                var leftJustify = false;
                if (c == '-')
                {
                    leftJustify = true;

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }

                if (!IsDigit(c))
                {
                    ExceptionUtil.ThrowFormatError();
                }

                do
                {
                    alignment = (alignment * 10) + c - '0';

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }
                while (IsDigit(c) && alignment < WidthLimit);

                if (leftJustify)
                    alignment *= -1;
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Format String Component ===

            ReadOnlySpan<char> itemFormatSpan = default;

            if (c == ':')
            {
                i++;
                int formatStart = i;

                while (true)
                {
                    if (i == len)
                    {
                        ExceptionUtil.ThrowFormatError();
                    }
                    c = format[i];

                    if (c == '}')
                    {
                        break;
                    }
                    else if (c == '{')
                    {
                        ExceptionUtil.ThrowFormatError();
                    }

                    i++;
                }

                // has format
                if (i > formatStart)
                {
                    itemFormatSpan = format.AsSpan(formatStart, i - formatStart);
                }
            }
            else if (c != '}')
            {
                // Unexpected character
                ExceptionUtil.ThrowFormatError();
            }

            i++; // Skip `}`
            return new ParseResult(paramIndex, itemFormatSpan, i, alignment);
        }
    }

    internal enum ParserScanResult
    {
        BraceOpen,
        EscapedChar,
        NormalChar,
    }

}



================================================
FILE: src/ZString/IResettableBufferWriter.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    public interface IResettableBufferWriter<T> : IBufferWriter<T>
    {
        void Reset();
    }
}



================================================
FILE: src/ZString/NestedStringBuilderCreationException.cs
================================================
using System;

namespace Cysharp.Text
{
    // Currently, this class is internals.
    internal class NestedStringBuilderCreationException : InvalidOperationException
    {
        internal protected NestedStringBuilderCreationException(string typeName, string extraMessage = "")
            : base($"A nested call with `notNested: true`, or Either You forgot to call {typeName}.Dispose() of  in the past.{extraMessage}")
        {
        }

        internal protected NestedStringBuilderCreationException(string message, Exception innerException) : base(message, innerException)
        {
        }

    }
}



================================================
FILE: src/ZString/PreparedFormat.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Text;
using System.Buffers;

namespace Cysharp.Text
{
<# foreach(var utf in utfTypes) { var isUtf16 = (utf == "Utf16"); #>
<# for(var i = 1; i <= TypeParamMax; i++) { #>
    public sealed partial class <#= utf #>PreparedFormat<<#= CreateTypeArgument(i) #>>
    {
        public string FormatString { get; }
        public int MinSize { get; }

        readonly <#= utf #>FormatSegment[] segments;
<# if(!isUtf16) { #>
        readonly byte[] utf8PreEncodedbuffer;
<# } #>

        public <#= utf #>PreparedFormat(string format)
        {
            this.FormatString = format;
            this.segments = PreparedFormatHelper.<#= utf #>Parse(format<#= (!isUtf16 ? ", out utf8PreEncodedbuffer" : "")  #>);

            var size = 0;
            foreach (var item in segments)
            {
                if (!item.IsFormatArgument)
                {
                    size += item.Count;
                }
            }
            this.MinSize = size;
        }

        public string Format(<#= CreateParameters(i) #>)
        {
            var sb = new <#= utf #>ValueStringBuilder(true);
            try
            {
                FormatTo(ref sb, <#= CreateParameterNames(i) #>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        public void FormatTo<TBufferWriter>(ref TBufferWriter sb, <#= CreateParameters(i) #>)
            where TBufferWriter : IBufferWriter<<#= isUtf16 ? "char" : "byte" #>>
        {
<# if(isUtf16) { #>
            var formatSpan = FormatString.AsSpan();
<# } else { #>
            var formatSpan = utf8PreEncodedbuffer.AsSpan();
<# } #>

            foreach (var item in segments)
            {
                switch (item.FormatIndex)
                {
                    case <#= utf #>FormatSegment.NotFormatIndex:
                        {
                            var strSpan = formatSpan.Slice(item.Offset, item.Count);
                            var span = sb.GetSpan(item.Count);
                            strSpan.TryCopyTo(span);
                            sb.Advance(item.Count);
                            break;
                        }
<# for(var j = 0; j < i; j++) { #>
                    case <#= j #>:
                        {
                            <#= utf #>FormatHelper.FormatTo(ref sb, arg<#= j + 1 #>, item.Alignment, <#= isUtf16 ? "formatSpan.Slice(item.Offset, item.Count)" : "item.StandardFormat" #>, nameof(arg<#= j + 1 #>));
                            break;
                        }
<# } // for(j) #>
                    default:
                        break;
                }
            }
        }
    }
<# } // for(i) #>
<# } // foreach(utf) #>
}



================================================
FILE: src/ZString/PreparedFormatHelper.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class PreparedFormatHelper
    {
        internal static Utf16FormatSegment[] Utf16Parse(string format)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            var list = new List<Utf16FormatSegment>();

            int i = 0;
            int len = format.Length;

            var copyFrom = 0;

            while (true)
            {
                while (i < len)
                {
                    var parserScanResult = FormatParser.ScanFormatString(format, ref i);

                    if (ParserScanResult.NormalChar == parserScanResult && i < len)
                    {
                        // skip normal char
                        continue;
                    }

                    var size = i - copyFrom;
                    if (ParserScanResult.EscapedChar == parserScanResult)
                    {
                        size--;
                    }

                    if (size != 0)
                    {
                        list.Add(new Utf16FormatSegment(copyFrom, size, Utf16FormatSegment.NotFormatIndex, 0));
                    }

                    copyFrom = i;

                    if (ParserScanResult.BraceOpen == parserScanResult)
                    {
                        break;
                    }
                }

                if (i >= len)
                {
                    break;
                }

                // Here it is before `{`.
                var indexParse = FormatParser.Parse(format, i);
                copyFrom = indexParse.LastIndex; // continue after '}'
                i = indexParse.LastIndex;

                list.Add(new Utf16FormatSegment(indexParse.LastIndex - indexParse.FormatString.Length - 1, indexParse.FormatString.Length, indexParse.Index, indexParse.Alignment));
            }

            return list.ToArray();
        }

        internal static Utf8FormatSegment[] Utf8Parse(string format, out byte[] utf8buffer)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            var list = new List<Utf8FormatSegment>();
            utf8buffer = new byte[Encoding.UTF8.GetMaxByteCount(format.Length)];
            var bufOffset = 0;

            int i = 0;
            int len = format.Length;

            var copyFrom = 0;

            while (true)
            {
                while (i < len)
                {
                    var parserScanResult = FormatParser.ScanFormatString(format, ref i);

                    if (ParserScanResult.NormalChar == parserScanResult && i < len)
                    {
                        // skip normal char
                        continue;
                    }

                    var size = i - copyFrom;
                    if (ParserScanResult.EscapedChar == parserScanResult)
                    {
                        size--;
                    }

                    if (size != 0)
                    {
                        var utf8size = Encoding.UTF8.GetBytes(format, copyFrom, size, utf8buffer, bufOffset);
                        list.Add(new Utf8FormatSegment(bufOffset, utf8size, Utf8FormatSegment.NotFormatIndex, default, 0));
                        bufOffset += utf8size;
                    }

                    copyFrom = i;

                    if (ParserScanResult.BraceOpen == parserScanResult)
                    {
                        break;
                    }
                }

                if (i >= len)
                {
                    break;
                }

                // Here it is before `{`.
                var indexParse = FormatParser.Parse(format, i);
                copyFrom = indexParse.LastIndex; // continue after '}'
                i = indexParse.LastIndex;
                list.Add(new Utf8FormatSegment(0, 0, indexParse.Index, StandardFormat.Parse(indexParse.FormatString), indexParse.Alignment));
            }

            return list.ToArray();
        }
    }

    internal readonly struct Utf8FormatSegment
    {
        public const int NotFormatIndex = -1;

        public readonly int Offset;
        public readonly int Count;
        public readonly int FormatIndex;
        public readonly StandardFormat StandardFormat;
        public readonly int Alignment;

        public bool IsFormatArgument => FormatIndex != NotFormatIndex;

        public Utf8FormatSegment(int offset, int count, int formatIndex, StandardFormat format, int alignment)
        {
            Offset = offset;
            Count = count;
            FormatIndex = formatIndex;
            StandardFormat = format;
            Alignment = alignment;
        }
    }

    internal readonly struct Utf16FormatSegment
    {
        public const int NotFormatIndex = -1;

        public readonly int Offset;
        public readonly int Count;
        public readonly int FormatIndex;
        public readonly int Alignment;

        public bool IsFormatArgument => FormatIndex != NotFormatIndex;

        public Utf16FormatSegment(int offset, int count, int formatIndex, int alignment)
        {
            Offset = offset;
            Count = count;
            FormatIndex = formatIndex;
            Alignment = alignment;
        }
    }
}



================================================
FILE: src/ZString/ReadOnlyListAdaptor.cs
================================================
﻿using System.Collections;
using System.Collections.Generic;

namespace Cysharp.Text
{
    /// <summary>
    /// Most IList interface-implementing classes implement the IReadOnlyList interface.
    /// This is for the rare class that does not implement the IList interface.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal readonly struct ReadOnlyListAdaptor<T> : IReadOnlyList<T>
    {
        readonly IList<T> _list;

        public ReadOnlyListAdaptor(IList<T> list) => _list = list;

        public T this[int index] => _list[index];

        public int Count => _list.Count;

        public IEnumerator<T> GetEnumerator() => _list.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }
}



================================================
FILE: src/ZString/Shims.cs
================================================
﻿#if NETSTANDARD

using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;

namespace Cysharp.Text
{
    internal static class Int32
    {
        /// <summary>0 ~ 9</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNumber(char c)
        {
            return '0' <= c && c <= '9';
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Parse(ReadOnlySpan<char> s)
        {
            var value = 0L;
            var sign = 1;

            if (s[0] == '-')
            {
                sign = -1;
            }

            for (int i = ((sign == -1) ? 1 : 0); i < s.Length; i++)
            {
                if (!IsNumber(s[i]))
                {
                    goto END;
                }

                // long.MinValue causes overflow so use unchecked.
                value = unchecked(value * 10 + ((byte)s[i] - '0'));
            }

            END:
            return checked((int)(unchecked(value * sign)));
        }
    }

    internal static class ShimsExtensions
    {
        public static unsafe int GetBytes(this Encoding encoding, ReadOnlySpan<char> span, Span<byte> bytes)
        {
            if (span.Length == 0) return 0;
            fixed (char* src = span)
            fixed (byte* dest = bytes)
            {
                return encoding.GetBytes(src, span.Length, dest, bytes.Length);
            }
        }

        public static bool TryFormat(this System.Guid value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Unsafe.As<Guid, GuidEx>(ref value).TryFormat(destination, out charsWritten, format);
        }

        public static bool TryFormat(this System.TimeSpan value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.DateTime value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.DateTimeOffset value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.Decimal value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatDecimal(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.Single value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatSingle(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.Double value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatDouble(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.SByte value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                if (value < 0 && format.Length > 0 && (format[0] == 'X' || format[0] == 'x'))
                {
                    uint temp = (uint)(value & 0x000000FF);
                    return Number.TryFormatUInt32(temp, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
                }
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int16 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                if (value < 0 && format.Length > 0 && (format[0] == 'X' || format[0] == 'x'))
                {
                    uint temp = (uint)(value & 0x0000FFFF);
                    return Number.TryFormatUInt32(temp, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
                }
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int32 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int64 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatInt64(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Byte value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt16 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt32 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt64 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt64(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        static string? GetFormat(ReadOnlySpan<char> format)
        {
            if (format.Length == 0)
            {
                return null;
            }

            return format.ToString();
        }
    }
}

#endif


================================================
FILE: src/ZString/StringBuilder.AppendJoin.cs
================================================
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal<T>(s, values.AsSpan());
        }

        public void AppendJoin<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified char separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        public void AppendJoin<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, params T[] values)
        {
            AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        public void AppendJoin<T>(string separator, List<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, IEnumerable<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, ICollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public void AppendJoin<T>(string separator, IList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            AppendJoinInternal(separator, readOnlyList);
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            var count = values.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var isFirst = true;
            foreach (var item in values)
            {
                if (!isFirst)
                {
                    Append(separator);
                }
                else
                {
                    isFirst = false;
                }

                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }
    }
    public partial struct Utf8ValueStringBuilder
    {
        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal<T>(s, values.AsSpan());
        }

        public void AppendJoin<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified char separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        public void AppendJoin<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, params T[] values)
        {
            AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        public void AppendJoin<T>(string separator, List<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, IEnumerable<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, ICollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public void AppendJoin<T>(string separator, IList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            AppendJoinInternal(separator, readOnlyList);
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            var count = values.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var isFirst = true;
            foreach (var item in values)
            {
                if (!isFirst)
                {
                    Append(separator);
                }
                else
                {
                    isFirst = false;
                }

                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }
    }
}



================================================
FILE: src/ZString/StringBuilder.AppendJoin.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
<# foreach(var utf in utfTypes) { #>
    public partial struct <#= utf #>ValueStringBuilder
    {
        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal<T>(s, values.AsSpan());
        }

        public void AppendJoin<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified char separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        public void AppendJoin<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, params T[] values)
        {
            AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        public void AppendJoin<T>(string separator, List<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, IEnumerable<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, ICollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public void AppendJoin<T>(string separator, IList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            AppendJoinInternal(separator, readOnlyList);
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            var count = values.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var isFirst = true;
            foreach (var item in values)
            {
                if (!isFirst)
                {
                    Append(separator);
                }
                else
                {
                    isFirst = false;
                }

                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }
    }
<# } // foreach(utf) #>
}



================================================
FILE: src/ZString/T4Common.t4
================================================
﻿<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const int TypeParamMax = 16;

    string[] utfTypes = new [] { "Utf16", "Utf8" };

    static string CreateTypeArgument(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + (x + 1)));
    }

    static string CreateParameters(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + (x + 1) + " arg" + (x + 1)));
    }
    
    static string CreateParameterNames(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "arg" + (x + 1)));
    }

    Type[] spanFormattables = new Type[]
    {
        typeof(Byte),
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(Decimal),
        typeof(Double),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(SByte),
        typeof(Single),
        typeof(TimeSpan),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(Guid),
        // typeof(Version),
    };
    
    var utf8spanFormattables = spanFormattables.Append(typeof(bool));
#>


================================================
FILE: src/ZString/Utf16ValueStringBuilder.cs
================================================
﻿using System;
using System.Buffers;
using System.IO;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder : IDisposable, IBufferWriter<char>, IResettableBufferWriter<char>
    {
        public delegate bool TryFormat<T>(T value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format);

        const int ThreadStaticBufferSize = 31111;
        const int DefaultBufferSize = 32768; // use 32K default buffer.

        static char newLine1;
        static char newLine2;
        static bool crlf;

        static Utf16ValueStringBuilder()
        {
            var newLine = Environment.NewLine.ToCharArray();
            if (newLine.Length == 1)
            {
                // cr or lf
                newLine1 = newLine[0];
                crlf = false;
            }
            else
            {
                // crlf(windows)
                newLine1 = newLine[0];
                newLine2 = newLine[1];
                crlf = true;
            }
        }

        [ThreadStatic]
        static char[]? scratchBuffer;

        [ThreadStatic]
        internal static bool scratchBufferUsed;

        char[]? buffer;
        int index;
        bool disposeImmediately;

        /// <summary>Length of written buffer.</summary>
        public int Length => index;
        /// <summary>Get the written buffer data.</summary>
        public ReadOnlySpan<char> AsSpan() => buffer.AsSpan(0, index);
        /// <summary>Get the written buffer data.</summary>
        public ReadOnlyMemory<char> AsMemory() => buffer.AsMemory(0, index);
        /// <summary>Get the written buffer data.</summary>
        public ArraySegment<char> AsArraySegment() => new ArraySegment<char>(buffer, 0, index);

        /// <summary>
        /// Initializes a new instance
        /// </summary>
        /// <param name="disposeImmediately">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateStringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Utf16ValueStringBuilder(bool disposeImmediately)
        {
            if (disposeImmediately && scratchBufferUsed)
            {
                ThrowNestedException();
            }

            char[]? buf;
            if (disposeImmediately)
            {
                buf = scratchBuffer;
                if (buf == null)
                {
                    buf = scratchBuffer = new char[ThreadStaticBufferSize];
                }
                scratchBufferUsed = true;
            }
            else
            {
                buf = ArrayPool<char>.Shared.Rent(DefaultBufferSize);
            }

            buffer = buf;
            index = 0;
            this.disposeImmediately = disposeImmediately;
        }

        /// <summary>
        /// Return the inner buffer to pool.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            if (buffer != null)
            {
                if (buffer.Length != ThreadStaticBufferSize)
                {
                    ArrayPool<char>.Shared.Return(buffer);
                }
                buffer = null;
                index = 0;
                if (disposeImmediately)
                {
                    scratchBufferUsed = false;
                }
            }
        }

        public void Clear()
        {
            index = 0;
        }

        public void TryGrow(int sizeHint)
        {

            if (buffer!.Length < index + sizeHint)
            {
                Grow(sizeHint);
            }
        }

        public void Grow(int sizeHint)
        {
            var nextSize = buffer!.Length * 2;
            if (sizeHint != 0)
            {
                nextSize = Math.Max(nextSize, index + sizeHint);
            }

            var newBuffer = ArrayPool<char>.Shared.Rent(nextSize);

            buffer.CopyTo(newBuffer, 0);
            if (buffer.Length != ThreadStaticBufferSize)
            {
                ArrayPool<char>.Shared.Return(buffer);
            }

            buffer = newBuffer;
        }

        /// <summary>Appends the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine()
        {
            if (crlf)
            {
                if (buffer!.Length - index < 2) Grow(2);
                buffer[index] = newLine1;
                buffer[index + 1] = newLine2;
                index += 2;
            }
            else
            {
                if (buffer!.Length - index < 1) Grow(1);
                buffer[index] = newLine1;
                index += 1;
            }
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value)
        {
            if (buffer!.Length - index < 1)
            {
                Grow(1);
            }

            buffer[index++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value, int repeatCount)
        {
            if (repeatCount < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(repeatCount));
            }

            GetSpan(repeatCount).Fill(value);
            Advance(repeatCount);
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(char value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value)
        {
            Append(value.AsSpan());
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(string value)
        {
            Append(value);
            AppendLine();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value, int startIndex, int count)
        {
            if (value == null)
            {
                if (startIndex == 0 && count == 0)
                {
                    return;
                }
                else
                {
                    throw new ArgumentNullException(nameof(value));
                }
            }

            Append(value.AsSpan(startIndex, count));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char[] value, int startIndex, int charCount)
        {
            if (buffer!.Length - index < charCount)
            {
                Grow(charCount);
            }
            Array.Copy(value, startIndex, buffer, index, charCount);
            index += charCount;
        }

        /// <summary>Appends a contiguous region of arbitrary memory to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(ReadOnlySpan<char> value)
        {
            if (buffer!.Length - index < value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(buffer.AsSpan(index));
            index += value.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(ReadOnlySpan<char> value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        public void Append<T>(T value)
        {
            if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var written, default))
            {
                Grow(written);
                if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out written, default))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        public void AppendLine<T>(T value)
        {
            Append(value);
            AppendLine();
        }

        static class ExceptionUtil
        {
            public static void ThrowArgumentOutOfRangeException(string paramName)
            {
                throw new ArgumentOutOfRangeException(paramName);
            }
        }

        /// <summary>
        /// Inserts a string 0 or more times into this builder at the specified position.
        /// </summary>
        /// <param name="index">The index to insert in this builder.</param>
        /// <param name="value">The string to insert.</param>
        /// <param name="count">The number of times to insert the string.</param>
        public void Insert(int index, string value, int count)
        {
            Insert(index, value.AsSpan(), count);
        }

        public void Insert(int index, string value)
        {
            Insert(index, value.AsSpan(), 1);
        }

        public void Insert(int index, ReadOnlySpan<char> value, int count)
        {
            if (count < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            int currentLength = Length;
            if ((uint)index > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(index));
            }

            if (value.Length == 0 || count == 0)
            {
                return;
            }

            var newSize = index + value.Length * count;
            var newBuffer = ArrayPool<char>.Shared.Rent(Math.Max(DefaultBufferSize, newSize));

            buffer.AsSpan(0, index).CopyTo(newBuffer);
            int newBufferIndex = index;

            for (int i = 0; i < count; i++)
            {
                value.CopyTo(newBuffer.AsSpan(newBufferIndex));
                newBufferIndex += value.Length;
            }

            int remainLnegth = this.index - index;
            buffer.AsSpan(index, remainLnegth).CopyTo(newBuffer.AsSpan(newBufferIndex));

            if (buffer!.Length != ThreadStaticBufferSize)
            {
                if (buffer != null)
                {
                    ArrayPool<char>.Shared.Return(buffer);
                }
            }

            buffer = newBuffer;
            this.index = newBufferIndex + remainLnegth;
        }

        /// <summary>
        /// Replaces all instances of one character with another in this builder.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
        public void Replace(char oldChar, char newChar) => Replace(oldChar, newChar, 0, Length);

        /// <summary>
        /// Replaces all instances of one character with another in this builder.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
        /// <param name="startIndex">The index to start in this builder.</param>
        /// <param name="count">The number of characters to read in this builder.</param>
        public void Replace(char oldChar, char newChar, int startIndex, int count)
        {
            int currentLength = Length;
            if ((uint)startIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (count < 0 || startIndex > currentLength - count)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            int endIndex = startIndex + count;

            for (int i = startIndex; i < endIndex; i++)
            {
                if (buffer![i] == oldChar)
                {
                    buffer[i] = newChar;
                }
            }
        }

        /// <summary>
        /// Replaces all instances of one string with another in this builder.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
        /// <remarks>
        /// If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
        /// are removed from this builder.
        /// </remarks>
        public void Replace(string oldValue, string newValue) => Replace(oldValue, newValue, 0, Length);

        public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue) => Replace(oldValue, newValue, 0, Length);

        /// <summary>
        /// Replaces all instances of one string with another in part of this builder.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
        /// <param name="startIndex">The index to start in this builder.</param>
        /// <param name="count">The number of characters to read in this builder.</param>
        /// <remarks>
        /// If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
        /// are removed from this builder.
        /// </remarks>
        public void Replace(string oldValue, string newValue, int startIndex, int count)
        {
            if (oldValue == null)
            {
                throw new ArgumentNullException(nameof(oldValue));
            }

            Replace(oldValue.AsSpan(), newValue.AsSpan(), startIndex, count);
        }

        public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue, int startIndex, int count)
        {
            int currentLength = Length;

            if ((uint)startIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (count < 0 || startIndex > currentLength - count)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            if (oldValue.Length == 0)
            {
                throw new ArgumentException("oldValue.Length is 0", nameof(oldValue));
            }

            var readOnlySpan = AsSpan();
            int endIndex = startIndex + count;
            int matchCount = 0;

            for (int i = startIndex; i < endIndex; i += oldValue.Length)
            {
                var span = readOnlySpan.Slice(i, endIndex - i);
                var pos = span.IndexOf(oldValue, StringComparison.Ordinal);
                if (pos == -1)
                {
                    break;
                }
                i += pos;
                matchCount++;
            }

            if (matchCount == 0)
                return;

            var newBuffer = ArrayPool<char>.Shared.Rent(Math.Max(DefaultBufferSize, Length + (newValue.Length - oldValue.Length) * matchCount));

            buffer.AsSpan(0, startIndex).CopyTo(newBuffer);
            int newBufferIndex = startIndex;

            for (int i = startIndex; i < endIndex; i += oldValue.Length)
            {
                var span = readOnlySpan.Slice(i, endIndex - i);
                var pos = span.IndexOf(oldValue, StringComparison.Ordinal);
                if (pos == -1)
                {
                    var remain = readOnlySpan.Slice(i);
                    remain.CopyTo(newBuffer.AsSpan(newBufferIndex));
                    newBufferIndex += remain.Length;
                    break;
                }
                readOnlySpan.Slice(i, pos).CopyTo(newBuffer.AsSpan(newBufferIndex));
                newValue.CopyTo(newBuffer.AsSpan(newBufferIndex + pos));
                newBufferIndex += pos + newValue.Length;
                i += pos;
            }

            if (buffer!.Length != ThreadStaticBufferSize)
            {
                ArrayPool<char>.Shared.Return(buffer);
            }
            buffer = newBuffer;
            index = newBufferIndex;
        }
        
        /// <summary>
        /// Replaces the contents of a single position within the builder.
        /// </summary>
        /// <param name="newChar">The character to use at the position.</param>
        /// <param name="replaceIndex">The index to replace.</param>
        public void ReplaceAt(char newChar, int replaceIndex)
        {
            int currentLength = Length;
            if ((uint)replaceIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(replaceIndex));
            }
            
            buffer![replaceIndex] = newChar;
        }

        /// <summary>
        /// Removes a range of characters from this builder.
        /// </summary>
        /// <remarks>
        /// This method does not reduce the capacity of this builder.
        /// </remarks>
        public void Remove(int startIndex, int length)
        {
            if (length < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(length));
            }

            if (startIndex < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (length > Length - startIndex)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(length));
            }

            if (Length == length && startIndex == 0)
            {
                index = 0;
                return;
            }

            if (length == 0)
            {
                return;
            }

            int remain = startIndex + length;
            buffer.AsSpan(remain, Length - remain).CopyTo(buffer.AsSpan(startIndex));
            index -= length;
        }


        // Output

        /// <summary>Copy inner buffer to the destination span.</summary>
        public bool TryCopyTo(Span<char> destination, out int charsWritten)
        {
            if (destination.Length < index)
            {
                charsWritten = 0;
                return false;
            }

            charsWritten = index;
            buffer.AsSpan(0, index).CopyTo(destination);
            return true;
        }

        /// <summary>Converts the value of this instance to a System.String.</summary>
        public override string ToString()
        {
            if (index == 0)
                return string.Empty;

            return new string(buffer, 0, index);
        }

        // IBufferWriter

        /// <summary>IBufferWriter.GetMemory.</summary>
        public Memory<char> GetMemory(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsMemory(index);
        }

        /// <summary>IBufferWriter.GetSpan.</summary>
        public Span<char> GetSpan(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsSpan(index);
        }

        /// <summary>IBufferWriter.Advance.</summary>
        public void Advance(int count)
        {
            index += count;
        }

        void IResettableBufferWriter<char>.Reset()
        {
            index = 0;
        }

        void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }
        static void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        void AppendFormatInternal<T>(T arg, int width, ReadOnlySpan<char> format, string argName)
        {
            if (width <= 0) // leftJustify
            {
                width *= -1;

                if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var charsWritten, format))
                {
                    Grow(charsWritten);
                    if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out charsWritten, format))
                    {
                        ThrowArgumentException(argName);
                    }
                }

                index += charsWritten;

                int padding = width - charsWritten;
                if (width > 0 && padding > 0)
                {
                    Append(' ', padding);  // TODO Fill Method is too slow.
                }
            }
            else // rightJustify
            {
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(arg);
                    int padding = width - s.Length;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s);
                }
                else
                {
                    Span<char> s = stackalloc char[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                    if (!FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                    {
                        s = stackalloc char[s.Length * 2];
                        if (!FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                        {
                            ThrowArgumentException(argName);
                        }
                    }

                    int padding = width - charsWritten;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s.Slice(0, charsWritten));
                }
            }
        }

        static void ThrowNestedException()
        {
            throw new NestedStringBuilderCreationException(nameof(Utf16ValueStringBuilder));
        }

        /// <summary>
        /// Register custom formatter
        /// </summary>
        public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
        {
            FormatterCache<T>.TryFormatDelegate = formatMethod;
        }

        static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
        {
            return new TryFormat<T?>((T? x, Span<char> dest, out int written, ReadOnlySpan<char> format) =>
            {
                if (x == null)
                {
                    written = 0;
                    return true;
                }
                return FormatterCache<T>.TryFormatDelegate(x.Value, dest, out written, format);
            });
        }

        /// <summary>
        /// Supports the Nullable type for a given struct type.
        /// </summary>
        public static void EnableNullableFormat<T>() where T : struct
        {
            RegisterTryFormat<T?>(CreateNullableFormatter<T>());
        }

        public static class FormatterCache<T>
        {
            public static TryFormat<T> TryFormatDelegate;
            static FormatterCache()
            {
                var formatter = (TryFormat<T>?)CreateFormatter(typeof(T));
                if (formatter == null)
                {
                    if (typeof(T).IsEnum)
                    {
                        formatter = new TryFormat<T>(EnumUtil<T>.TryFormatUtf16);
                    }
                    else if (typeof(T) == typeof(string))
                    {
                        formatter = new TryFormat<T>(TryFormatString);
                    }
                    else
                    {
                        formatter = new TryFormat<T>(TryFormatDefault);
                    }
                }

                TryFormatDelegate = formatter;
            }

            static bool TryFormatString(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
            {
                var s = value as string;

                if (s == null)
                {
                    written = 0;
                    return true;
                }

                // also use this length when result is false.
                written = s.Length;
                return s.AsSpan().TryCopyTo(dest);
            }

            static bool TryFormatDefault(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
            {
                if (value == null)
                {
                    written = 0;
                    return true;
                }

                var s = (value is IFormattable formattable && format.Length != 0) ?
                    formattable.ToString(format.ToString(), null) :
                    value.ToString();

                // also use this length when result is false.
                written = s.Length;
                return s.AsSpan().TryCopyTo(dest);
            }
        }
    }
}



================================================
FILE: src/ZString/Utf8ValueStringBuilder.cs
================================================
using System;
using System.Buffers;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder : IDisposable, IBufferWriter<byte>, IResettableBufferWriter<byte>
    {
        public delegate bool TryFormat<T>(T value, Span<byte> destination, out int written, StandardFormat format);

        const int ThreadStaticBufferSize = 64444;
        const int DefaultBufferSize = 65536; // use 64K default buffer.
        static Encoding UTF8NoBom = new UTF8Encoding(false);

        static byte newLine1;
        static byte newLine2;
        static bool crlf;

        static Utf8ValueStringBuilder()
        {
            var newLine = UTF8NoBom.GetBytes(Environment.NewLine);
            if (newLine.Length == 1)
            {
                // cr or lf
                newLine1 = newLine[0];
                crlf = false;
            }
            else
            {
                // crlf(windows)
                newLine1 = newLine[0];
                newLine2 = newLine[1];
                crlf = true;
            }
        }

        [ThreadStatic]
        static byte[]? scratchBuffer;

        [ThreadStatic]
        internal static bool scratchBufferUsed;

        byte[]? buffer;
        int index;
        bool disposeImmediately;

        /// <summary>Length of written buffer.</summary>
        public int Length => index;

        /// <summary>Get the written buffer data.</summary>
        public ReadOnlySpan<byte> AsSpan() => buffer.AsSpan(0, index);

        /// <summary>Get the written buffer data.</summary>
        public ReadOnlyMemory<byte> AsMemory() => buffer.AsMemory(0, index);

        /// <summary>Get the written buffer data.</summary>
        public ArraySegment<byte> AsArraySegment() => new ArraySegment<byte>(buffer, 0, index);

        /// <summary>
        /// Initializes a new instance
        /// </summary>
        /// <param name="disposeImmediately">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Utf8ValueStringBuilder(bool disposeImmediately)
        {
            if (disposeImmediately && scratchBufferUsed)
            {
                ThrowNestedException();
            }

            byte[]? buf;
            if (disposeImmediately)
            {
                buf = scratchBuffer;
                if (buf == null)
                {
                    buf = scratchBuffer = new byte[ThreadStaticBufferSize];
                }
                scratchBufferUsed = true;
            }
            else
            {
                buf = ArrayPool<byte>.Shared.Rent(DefaultBufferSize);
            }

            buffer = buf;
            index = 0;
            this.disposeImmediately = disposeImmediately;
        }

        /// <summary>
        /// Return the inner buffer to pool.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            if (buffer != null)
            {
                if (buffer.Length != ThreadStaticBufferSize)
                {
                    ArrayPool<byte>.Shared.Return(buffer);
                }
                buffer = null;
                index = 0;
                if (disposeImmediately)
                {
                    scratchBufferUsed = false;
                }
            }
        }

        public void Clear()
        {
            index = 0;
        }

        public void TryGrow(int sizeHint)
        {
            if (buffer!.Length < index + sizeHint)
            {
                Grow(sizeHint);
            }
        }

        public void Grow(int sizeHint)
        {
            var nextSize = buffer!.Length * 2;
            if (sizeHint != 0)
            {
                nextSize = Math.Max(nextSize, index + sizeHint);
            }

            var newBuffer = ArrayPool<byte>.Shared.Rent(nextSize);

            buffer.CopyTo(newBuffer, 0);
            if (buffer.Length != ThreadStaticBufferSize)
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }

            buffer = newBuffer;
        }

        /// <summary>Appends the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine()
        {
            if (crlf)
            {
                if (buffer!.Length - index < 2) Grow(2);
                buffer[index] = newLine1;
                buffer[index + 1] = newLine2;
                index += 2;
            }
            else
            {
                if (buffer!.Length - index < 1) Grow(1);
                buffer[index] = newLine1;
                index += 1;
            }
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe void Append(char value)
        {
            var maxLen = UTF8NoBom.GetMaxByteCount(1);
            if (buffer!.Length - index < maxLen)
            {
                Grow(maxLen);
            }

            fixed (byte* bp = &buffer[index])
            {
                index += UTF8NoBom.GetBytes(&value, 1, bp, maxLen);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value, int repeatCount)
        {
            if (repeatCount < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(repeatCount));
            }

            if (value <= 0x7F) // ASCII
            {
                GetSpan(repeatCount).Fill((byte)value);
                Advance(repeatCount);
            }
            else
            {
                var maxLen = UTF8NoBom.GetMaxByteCount(1);
                Span<byte> utf8Bytes = stackalloc byte[maxLen];
                ReadOnlySpan<char> chars = stackalloc char[1] { value };

                int len = UTF8NoBom.GetBytes(chars, utf8Bytes);

                TryGrow(len * repeatCount);

                for (int i = 0; i < repeatCount; i++)
                {
                    utf8Bytes.CopyTo(GetSpan(len));
                    Advance(len);
                }
            }
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(char value)
        {
            Append(value);
            AppendLine();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value, int startIndex, int count)
        {
            if (value == null)
            {
                if (startIndex == 0 && count == 0)
                {
                    return;
                }
                else
                {
                    throw new ArgumentNullException(nameof(value));
                }
            }

            Append(value.AsSpan(startIndex, count));
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value)
        {
            Append(value.AsSpan());
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(string value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends a contiguous region of arbitrary memory to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(ReadOnlySpan<char> value)
        {
            var maxLen = UTF8NoBom.GetMaxByteCount(value.Length);
            if (buffer!.Length - index < maxLen)
            {
                Grow(maxLen);
            }

            index += UTF8NoBom.GetBytes(value, buffer.AsSpan(index));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(ReadOnlySpan<char> value)
        {
            Append(value);
            AppendLine();
        }

        public void AppendLiteral(ReadOnlySpan<byte> value)
        {
            if ((buffer!.Length - index) < value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(buffer.AsSpan(index));
            index += value.Length;
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        public void Append<T>(T value)
        {
            if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var written, default))
            {
                Grow(written);
                if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out written, default))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        public void AppendLine<T>(T value)
        {
            Append(value);
            AppendLine();
        }

        // Output

        /// <summary>Copy inner buffer to the bufferWriter.</summary>
        public void CopyTo(IBufferWriter<byte> bufferWriter)
        {
            var destination = bufferWriter.GetSpan(index);
            TryCopyTo(destination, out var written);
            bufferWriter.Advance(written);
        }

        /// <summary>Copy inner buffer to the destination span.</summary>
        public bool TryCopyTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < index)
            {
                bytesWritten = 0;
                return false;
            }

            bytesWritten = index;
            buffer.AsSpan(0, index).CopyTo(destination);
            return true;
        }

        /// <summary>Write inner buffer to stream.</summary>
        public Task WriteToAsync(Stream stream)
        {
            return stream.WriteAsync(buffer, 0, index);
        }

        /// <summary>Write inner buffer to stream.</summary>
        public Task WriteToAsync(Stream stream, CancellationToken cancellationToken)
        {
            return stream.WriteAsync(buffer, 0, index, cancellationToken);
        }

        /// <summary>Encode the innner utf8 buffer to a System.String.</summary>
        public override string ToString()
        {
            if (index == 0)
                return string.Empty;

            return UTF8NoBom.GetString(buffer, 0, index);
        }

        // IBufferWriter

        /// <summary>IBufferWriter.GetMemory.</summary>
        public Memory<byte> GetMemory(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsMemory(index);
        }

        /// <summary>IBufferWriter.GetSpan.</summary>
        public Span<byte> GetSpan(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsSpan(index);
        }

        /// <summary>IBufferWriter.Advance.</summary>
        public void Advance(int count)
        {
            index += count;
        }

        void IResettableBufferWriter<byte>.Reset()
        {
            index = 0;
        }

        void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }

        void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        static void ThrowNestedException()
        {
            throw new NestedStringBuilderCreationException(nameof(Utf8ValueStringBuilder));
        }

        private void AppendFormatInternal<T>(T arg, int width, StandardFormat format, string argName)
        {
            if (width <= 0) // leftJustify
            {
                width *= -1;

                if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var charsWritten, format))
                {
                    Grow(charsWritten);
                    if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out charsWritten, format))
                    {
                        ThrowArgumentException(argName);
                    }
                }

                index += charsWritten;

                int padding = width - charsWritten;
                if (width > 0 && padding > 0)
                {
                    Append(' ', padding);  // TODO Fill Method is too slow.
                }
            }
            else // rightJustify
            {
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(arg);
                    int padding = width - s.Length;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s);
                }
                else
                {
                    Span<byte> s = stackalloc byte[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                    if (!FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                    {
                        s = stackalloc byte[s.Length * 2];
                        if (!FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                        {
                            ThrowArgumentException(argName);
                        }
                    }

                    int padding = width - charsWritten;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    s.CopyTo(GetSpan(charsWritten));
                    Advance(charsWritten);
                }
            }
        }

        /// <summary>
        /// Register custom formatter
        /// </summary>
        public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
        {
            FormatterCache<T>.TryFormatDelegate = formatMethod;
        }

        static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
        {
            return new TryFormat<T?>((T? x, Span<byte> destination, out int written, StandardFormat format) =>
            {
                if (x == null)
                {
                    written = 0;
                    return true;
                }
                return FormatterCache<T>.TryFormatDelegate(x.Value, destination, out written, format);
            });
        }

        /// <summary>
        /// Supports the Nullable type for a given struct type.
        /// </summary>
        public static void EnableNullableFormat<T>() where T : struct
        {
            RegisterTryFormat<T?>(CreateNullableFormatter<T>());
        }

        public static class FormatterCache<T>
        {
            public static TryFormat<T> TryFormatDelegate;
            static FormatterCache()
            {
                var formatter = (TryFormat<T>?)CreateFormatter(typeof(T));
                if (formatter == null)
                {
                    if (typeof(T).IsEnum)
                    {
                        formatter = new TryFormat<T>(EnumUtil<T>.TryFormatUtf8);
                    }
                    else
                    {
                        formatter = new TryFormat<T>(TryFormatDefault);
                    }
                }

                TryFormatDelegate = formatter;
            }

            static bool TryFormatDefault(T value, Span<byte> dest, out int written, StandardFormat format)
            {
                if (value == null)
                {
                    written = 0;
                    return true;
                }

                var s = typeof(T) == typeof(string) ? Unsafe.As<string>(value) :
                    (value is IFormattable formattable && format != default) ? formattable.ToString(format.ToString(), null) :
                    value.ToString();

                // also use this length when result is false.
                written = UTF8NoBom.GetMaxByteCount(s.Length);
                if (dest.Length < written)
                {
                    return false;
                }

                written = UTF8NoBom.GetBytes(s.AsSpan(), dest);
                return true;

            }
        }
    }
}



================================================
FILE: src/ZString/ZString.Concat.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public static partial class ZString
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<<#= CreateTypeArgument(i) #>>(<#= CreateParameters(i) #>)
        {
<# if(i == 1) { #>
            if (typeof(T1) == typeof(string))
            {
                return (arg1 != null) ? Unsafe.As<string>(arg1) : string.Empty;
            }

<# } #>
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
<# for(var j = 0; j < i; j++) { #>
                if (typeof(T<#= j + 1 #>) == typeof(string))
                {
                    if(arg<#= j + 1 #> != null)
                    {
                        sb.Append(Unsafe.As<T<#= j + 1 #>, string>(ref arg<#= j + 1 #>));
                    }
                }
                else if (typeof(T<#= j + 1 #>) == typeof(int))
                {
                    sb.Append(Unsafe.As<T<#= j + 1 #>, int>(ref arg<#= j + 1 #>));
                }
                else
                {
                    sb.Append(arg<#= j + 1 #>);
                }

<# } #>
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

<# } #>
    }
}


================================================
FILE: src/ZString/ZString.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        static Encoding UTF8NoBom = new UTF8Encoding(false);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void AppendChars<TBufferWriter>(ref TBufferWriter sb, ReadOnlySpan<char> chars)
            where TBufferWriter : System.Buffers.IBufferWriter<byte>
        {
            var span = sb.GetSpan(UTF8NoBom.GetMaxByteCount(chars.Length));
            sb.Advance(UTF8NoBom.GetBytes(chars, span));
        }

        /// <summary>Create the Utf16 string StringBuilder.</summary>
        public static Utf16ValueStringBuilder CreateStringBuilder()
        {
            return new Utf16ValueStringBuilder(false);
        }

        /// <summary>Create the Utf16 string StringBuilder, when true uses thread-static buffer that is faster but must return immediately.</summary>
        public static Utf8ValueStringBuilder CreateUtf8StringBuilder()
        {
            return new Utf8ValueStringBuilder(false);
        }

        /// <summary>Create the Utf8(`Span[byte]`) StringBuilder.</summary>
        /// <param name="notNested">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        public static Utf16ValueStringBuilder CreateStringBuilder(bool notNested)
        {
            return new Utf16ValueStringBuilder(notNested);
        }

        /// <summary>Create the Utf8(`Span[byte]`) StringBuilder, when true uses thread-static buffer that is faster but must return immediately.</summary>
        /// <param name="notNested">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        public static Utf8ValueStringBuilder CreateUtf8StringBuilder(bool notNested)
        {
            return new Utf8ValueStringBuilder(notNested);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal<T>(s, values.AsSpan());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, (IReadOnlyList<T>)values);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values.AsEnumerable());
        }

        public static string Join<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values.AsEnumerable());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, params T[] values)
        {
            return JoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, List<T> values)
        {
            return JoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, ReadOnlySpan<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, ICollection<T> values)
        {
            return JoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public static string Join<T>(string separator, IList<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, IReadOnlyList<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, IReadOnlyCollection<T> values)
        {
            return JoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, IEnumerable<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }
        
#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(char separator, ReadOnlySpan<string> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(char separator, params string[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, (ReadOnlySpan<string>)values.AsSpan());
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(string separator, params string[] values)
        {
            return JoinInternal(separator.AsSpan(), (ReadOnlySpan<string>)values.AsSpan());
        }
#endif
        
        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(params T[] values)
        {
            return JoinInternal<T>(default, values.AsSpan());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(List<T> values)
        {
            return JoinInternal(default, (IReadOnlyList<T>)values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(ReadOnlySpan<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(ICollection<T> values)
        {
            return JoinInternal(default, values.AsEnumerable());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IList<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IReadOnlyList<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IReadOnlyCollection<T> values)
        {
            return JoinInternal(default, values.AsEnumerable());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IEnumerable<T> values)
        {
            return JoinInternal(default, values);
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            return JoinInternal(separator, readOnlyList);
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            if (values.Count == 0)
            {
                return string.Empty;
            }
#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1            
            if (values is string[] valueArray)
            {
                return JoinInternal(separator, valueArray.AsSpan());
            }
#if NET5_0_OR_GREATER
            if (values is List<string> valueList)
            {
                return JoinInternal(separator, CollectionsMarshal.AsSpan(valueList));
            }
#endif
#endif
            
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            if (values.Length == 0)
            {
                return string.Empty;
            }
            else if (typeof(T) == typeof(string) && values.Length == 1)
            {
                return Unsafe.As<string>(values[0]);
            }

            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1
        static string JoinInternal(ReadOnlySpan<char> separator, ReadOnlySpan<string> values)
        {
            if (values.Length == 0)
            {
                return string.Empty;
            }
            if (values.Length == 1)
            {
                return values[0];
            }

            var totalSeparatorsLength = (values.Length - 1) * separator.Length;
            var totalLength = totalSeparatorsLength;
            for (var i = 0; i < values.Length; i++)
            {
                if (values[i] is { } value)
                {
                    totalLength += value.Length;
                }
            }
            
            if (totalLength == 0)
            {
                return string.Empty;
            }

            var resultString = string.Create(totalLength, 0, (_, _) => { });
            var writeBuffer = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(resultString.AsSpan()), resultString.Length);
            var copiedLength = 0;
            for (var i = 0; i < values.Length; i++)
            {
                if (values[i] is { } value)
                {
                    value.AsSpan().CopyTo(writeBuffer.Slice(copiedLength));
                    copiedLength += value.Length;
                }

                // Fill in the separator
                if (i < values.Length - 1)
                {
                    if (separator.Length == 1)
                    {
                        writeBuffer[copiedLength++] = separator[0];
                    }
                    else
                    {
                        separator.CopyTo(writeBuffer.Slice(copiedLength));
                        copiedLength += separator.Length;
                    }
                }
            }
            return resultString;
        }
#endif
    }
}



================================================
FILE: src/ZString/ZString.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.1;netstandard2.0;net6.0;net7.0</TargetFrameworks>
    <RootNamespace>Cysharp.Text</RootNamespace>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <NoWarn>1701;1702;1591</NoWarn>

    <!-- NuGet Packaging -->
    <IsPackable>true</IsPackable>
    <Description>Zero allocation StringBuilder for .NET Core and Unity.</Description>
  </PropertyGroup>

  <ItemGroup Condition="$(TargetFramework) == 'netstandard2.1'">
    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup Condition="$(TargetFramework) == 'netstandard2.0'">
    <PackageReference Include="System.Memory" Version="4.5.3" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="Number\**\*.cs" Condition="$(TargetFramework) == 'net6.0' or $(TargetFramework) == 'net7.0'" />
    <Compile Remove="Unity\**\**" />
    <None Remove="Unity\**\**" />
  </ItemGroup>

  <ItemGroup>
    <None Update="FormatHelper.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>FormatHelper.cs</LastGenOutput>
    </None>
    <None Update="PreparedFormat.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>PreparedFormat.cs</LastGenOutput>
    </None>
    <None Update="StringBuilder.AppendJoin.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>StringBuilder.AppendJoin.cs</LastGenOutput>
    </None>
    <None Update="Unity\TextMeshProExtensions.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>TextMeshProExtensions.cs</LastGenOutput>
    </None>
    <None Update="Utf16\Utf16ValueStringBuilder.AppendMany.tt">
      <LastGenOutput>Utf16ValueStringBuilder.AppendMany.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf16\Utf16ValueStringBuilder.CreateFormatter.tt">
      <LastGenOutput>Utf16ValueStringBuilder.CreateFormatter.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf16\Utf16ValueStringBuilder.SpanFormattableAppend.tt">
      <LastGenOutput>Utf16ValueStringBuilder.SpanFormattableAppend.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf8\Utf8ValueStringBuilder.AppendFormat.tt">
      <LastGenOutput>Utf8ValueStringBuilder.AppendFormat.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf8\Utf8ValueStringBuilder.AppendMany.tt">
      <LastGenOutput>Utf8ValueStringBuilder.AppendMany.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf8\Utf8ValueStringBuilder.CreateFormatter.tt">
      <LastGenOutput>Utf8ValueStringBuilder.CreateFormatter.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf8\Utf8ValueStringBuilder.SpanFormattableAppend.tt">
      <LastGenOutput>Utf8ValueStringBuilder.SpanFormattableAppend.cs</LastGenOutput>
      <Generator>TextTemplatingFileGenerator</Generator>
    </None>
    <None Update="Utf16\Utf16ValueStringBuilder.AppendFormat.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>Utf16ValueStringBuilder.AppendFormat.cs</LastGenOutput>
    </None>
    <None Update="ZString.Concat.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>ZString.Concat.cs</LastGenOutput>
    </None>
    <None Update="ZString.Format.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>ZString.Format.cs</LastGenOutput>
    </None>
    <None Update="ZString.Prepare.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>ZString.Prepare.cs</LastGenOutput>
    </None>
    <None Update="ZString.Utf8Format.tt">
      <Generator>TextTemplatingFileGenerator</Generator>
      <LastGenOutput>ZString.Utf8Format.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <ItemGroup>
    <Compile Update="FormatHelper.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>FormatHelper.tt</DependentUpon>
    </Compile>
    <Compile Update="PreparedFormat.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>PreparedFormat.tt</DependentUpon>
    </Compile>
    <Compile Update="StringBuilder.AppendJoin.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>StringBuilder.AppendJoin.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf16\Utf16ValueStringBuilder.AppendFormat.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf16ValueStringBuilder.AppendFormat.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf16\Utf16ValueStringBuilder.AppendMany.cs">
      <DependentUpon>Utf16ValueStringBuilder.AppendMany.tt</DependentUpon>
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
    </Compile>
    <Compile Update="Utf16\Utf16ValueStringBuilder.CreateFormatter.cs">
      <DependentUpon>Utf16ValueStringBuilder.CreateFormatter.tt</DependentUpon>
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
    </Compile>
    <Compile Update="Utf16\Utf16ValueStringBuilder.SpanFormattableAppend.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf16ValueStringBuilder.SpanFormattableAppend.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf8\Utf8ValueStringBuilder.AppendFormat.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf8ValueStringBuilder.AppendFormat.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf8\Utf8ValueStringBuilder.AppendMany.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf8ValueStringBuilder.AppendMany.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf8\Utf8ValueStringBuilder.CreateFormatter.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf8ValueStringBuilder.CreateFormatter.tt</DependentUpon>
    </Compile>
    <Compile Update="Utf8\Utf8ValueStringBuilder.SpanFormattableAppend.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Utf8ValueStringBuilder.SpanFormattableAppend.tt</DependentUpon>
    </Compile>
    <Compile Update="ZString.Concat.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ZString.Concat.tt</DependentUpon>
    </Compile>
    <Compile Update="ZString.Format.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ZString.Format.tt</DependentUpon>
    </Compile>
    <Compile Update="ZString.Prepare.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ZString.Prepare.tt</DependentUpon>
    </Compile>
    <Compile Update="ZString.Utf8Format.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ZString.Utf8Format.tt</DependentUpon>
    </Compile>

  </ItemGroup>

  <ItemGroup>
    <None Include="PreparedFormat.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>PreparedFormat.tt</DependentUpon>
    </None>
    <None Include="ZString.Utf8Format.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>ZString.Utf8Format.tt</DependentUpon>
    </None>
  </ItemGroup>

  <ItemGroup>
    <Service Include="{508349b6-6b84-4df5-91f0-309beebad82d}" />
  </ItemGroup>

  <!-- Copy files for Unity -->
  <PropertyGroup>
    <DestinationRoot>$(MSBuildProjectDirectory)\..\ZString.Unity\Assets\Scripts\ZString\</DestinationRoot>
  </PropertyGroup>
  <ItemGroup>
    <TargetFiles1 Include="$(MSBuildProjectDirectory)\**\*.cs" Exclude="**\bin\**\*.*;**\obj\**\*.*;_InternalVisibleTo.cs" />
  </ItemGroup>
  <Target Name="PostBuild" AfterTargets="PostBuildEvent" Condition="$(TargetFramework) == 'netstandard2.1'">
    <Copy SourceFiles="@(TargetFiles1)" DestinationFiles="$(DestinationRoot)\%(RecursiveDir)%(Filename)%(Extension)" SkipUnchangedFiles="true" />
  </Target>
</Project>



================================================
FILE: src/ZString/ZString.Format.cs
================================================
﻿using System.Runtime.CompilerServices;
using System;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1>(string format, T1 arg1)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1>(ReadOnlySpan<char> format, T1 arg1)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2>(string format, T1 arg1, T2 arg2)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2>(ReadOnlySpan<char> format, T1 arg1, T2 arg2)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
    }
}


================================================
FILE: src/ZString/ZString.Format.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System.Runtime.CompilerServices;
using System;

namespace Cysharp.Text
{
    public static partial class ZString
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<<#= CreateTypeArgument(i) #>>(string format, <#= CreateParameters(i) #>)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, <#= CreateParameterNames(i) #>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<<#= CreateTypeArgument(i) #>>(ReadOnlySpan<char> format, <#= CreateParameters(i) #>)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, <#= CreateParameterNames(i) #>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
<# } #>
    }
}


================================================
FILE: src/ZString/ZString.Prepare.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1> PrepareUtf16<T1>(string format)
        {
            return new Utf16PreparedFormat<T1>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1> PrepareUtf8<T1>(string format)
        {
            return new Utf8PreparedFormat<T1>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2> PrepareUtf16<T1, T2>(string format)
        {
            return new Utf16PreparedFormat<T1, T2>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2> PrepareUtf8<T1, T2>(string format)
        {
            return new Utf8PreparedFormat<T1, T2>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3> PrepareUtf16<T1, T2, T3>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3> PrepareUtf8<T1, T2, T3>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4> PrepareUtf16<T1, T2, T3, T4>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4> PrepareUtf8<T1, T2, T3, T4>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf16<T1, T2, T3, T4, T5>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf8<T1, T2, T3, T4, T5>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf16<T1, T2, T3, T4, T5, T6>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf8<T1, T2, T3, T4, T5, T6>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
        }

    }
}


================================================
FILE: src/ZString/ZString.Prepare.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public static partial class ZString
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<<#= CreateTypeArgument(i) #>> PrepareUtf16<<#= CreateTypeArgument(i) #>>(string format)
        {
            return new Utf16PreparedFormat<<#= CreateTypeArgument(i) #>>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<<#= CreateTypeArgument(i) #>> PrepareUtf8<<#= CreateTypeArgument(i) #>>(string format)
        {
            return new Utf8PreparedFormat<<#= CreateTypeArgument(i) #>>(format);
        }

<# } #>
    }
}


================================================
FILE: src/ZString/ZString.Utf8Format.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Buffers;
using System.Runtime.CompilerServices;

using static Cysharp.Text.Utf8ValueStringBuilder;

namespace Cysharp.Text
{
    public static partial class ZString
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Replaces one or more format items in a string with the string representation of some specified values.</summary>
        public static void Utf8Format<<#= CreateTypeArgument(i) #>>(IBufferWriter<byte> bufferWriter, string format, <#= CreateParameters(i) #>)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }
            
            var copyFrom = 0;
            for (int i = 0; i < format.Length; i++)
            {
                var c = format[i];
                if (c == '{')
                {
                    // escape.
                    if (i == format.Length - 1)
                    {
                        throw new FormatException("invalid format");
                    }

                    if (i != format.Length && format[i + 1] == '{')
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                        i = i + 1; // skip escaped '{'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                    }

                    // try to find range
                    var indexParse = FormatParser.Parse(format, i);
                    copyFrom = indexParse.LastIndex;
                    i = indexParse.LastIndex - 1;
                    var writeFormat = StandardFormat.Parse(indexParse.FormatString);
                    switch (indexParse.Index)
                    {
<# for(var j = 0; j < i; j++) { #>
                        case <#= j #>:
                            Utf8FormatHelper.FormatTo(ref bufferWriter, arg<#= j + 1 #>, indexParse.Alignment, writeFormat, nameof(arg<#= j + 1 #>));
                            continue;
<# } #>
                        default:
                            ExceptionUtil.ThrowFormatException();
                            break;
                    }

                    ExceptionUtil.ThrowFormatException();
                }
                else if (c == '}')
                {
                    if (i + 1 < format.Length && format[i + 1] == '}')
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                        i = i + 1; // skip escaped '}'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                    	ExceptionUtil.ThrowFormatException();
                    }
                }
            }

            {
                // copy final string
                var copyLength = format.Length - copyFrom;
                if (copyLength > 0)
                {
                    var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(copyLength));
                    var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, copyLength), buffer);
                    bufferWriter.Advance(written);
                }
            }
        }
<# } #>
    }
}



================================================
FILE: src/ZString/ZStringWriter.cs
================================================
using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.Text
{
    /// <summary>
    /// A <see cref="TextWriter"/> implementation that is backed with <see cref="Utf16ValueStringBuilder"/>.
    /// </summary>
    /// <remarks>
    /// It's important to make sure the writer is always properly disposed.
    /// </remarks>
    public sealed class ZStringWriter : TextWriter
    {
        private Utf16ValueStringBuilder sb;
        private bool isOpen;
        private UnicodeEncoding? encoding;

        /// <summary>
        /// Creates a new instance using <see cref="CultureInfo.CurrentCulture"/> as format provider.
        /// </summary>
        public ZStringWriter() : this(CultureInfo.CurrentCulture)
        {
        }

        /// <summary>
        /// Creates a new instance with given format provider.
        /// </summary>
        public ZStringWriter(IFormatProvider formatProvider) : base(formatProvider)
        {
            sb = ZString.CreateStringBuilder();
            isOpen = true;
        }

        /// <summary>
        /// Disposes this instance, operations are no longer allowed.
        /// </summary>
        public override void Close()
        {
            Dispose(true);
        }

        protected override void Dispose(bool disposing)
        {
            sb.Dispose();
            isOpen = false;
            base.Dispose(disposing);
        }

        public override Encoding Encoding => encoding = encoding ?? new UnicodeEncoding(false, false);

        public override void Write(char value)
        {
            AssertNotDisposed();

            sb.Append(value);
        }

        public override void Write(char[] buffer, int index, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count));
            }
            if (buffer.Length - index < count)
            {
                throw new ArgumentException();
            }
            AssertNotDisposed();

            sb.Append(buffer, index, count);
        }

        public override void Write(string value)
        {
            AssertNotDisposed();

            if (value != null)
            {
                sb.Append(value);
            }
        }

        public override Task WriteAsync(char value)
        {
            Write(value);
            return Task.CompletedTask;
        }

        public override Task WriteAsync(string value)
        {
            Write(value);
            return Task.CompletedTask;
        }

        public override Task WriteAsync(char[] buffer, int index, int count)
        {
            Write(buffer, index, count);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(char value)
        {
            WriteLine(value);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(string value)
        {
            WriteLine(value);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(char[] buffer, int index, int count)
        {
            WriteLine(buffer, index, count);
            return Task.CompletedTask;
        }

        public override void Write(bool value)
        {
            AssertNotDisposed();
            sb.Append(value);
        }

        public override void Write(decimal value)
        {
            AssertNotDisposed();
            sb.Append(value);
        }

        /// <summary>
        /// No-op.
        /// </summary>
        public override Task FlushAsync()
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Materializes the current state from underlying string builder.
        /// </summary>
        public override string ToString()
        {
            return sb.ToString();
        }

#if !NETSTANDARD2_0
#if !UNITY_2018_3_OR_NEWER

        public override void Write(ReadOnlySpan<char> buffer)
        {
            AssertNotDisposed();

            sb.Append(buffer);
        }

        public override void WriteLine(ReadOnlySpan<char> buffer)
        {
            AssertNotDisposed();

            sb.Append(buffer);
            WriteLine();
        }

        public override Task WriteAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken = default)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled(cancellationToken);
            }

            Write(buffer.Span);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken = default)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled(cancellationToken);
            }

            WriteLine(buffer.Span);
            return Task.CompletedTask;
        }
#endif
#endif

        private void AssertNotDisposed()
        {
            if (!isOpen)
            {
                throw new ObjectDisposedException(nameof(sb));
            }
        }
    }
}



================================================
FILE: src/ZString/Number/BitOperations.cs
================================================
﻿#if !NET6_0_OR_GREATER

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Some routines inspired by the Stanford Bit Twiddling Hacks by Sean Eron Anderson:
// http://graphics.stanford.edu/~seander/bithacks.html

namespace System.Numerics
{
    /// <summary>
    /// Utility methods for intrinsic bit-twiddling operations.
    /// The methods use hardware intrinsics when available on the underlying platform,
    /// otherwise they use optimized software fallbacks.
    /// </summary>
    internal static class BitOperations
    {
        // C# no-alloc optimization that directly wraps the data section of the dll (similar to string constants)
        // https://github.com/dotnet/roslyn/pull/24621

        private static ReadOnlySpan<byte> TrailingZeroCountDeBruijn => new byte[32]
        {
            00, 01, 28, 02, 29, 14, 24, 03,
            30, 22, 20, 15, 25, 17, 04, 08,
            31, 27, 13, 23, 21, 19, 16, 07,
            26, 12, 18, 06, 11, 05, 10, 09
        };

        private static ReadOnlySpan<byte> Log2DeBruijn => new byte[32]
        {
            00, 09, 01, 10, 13, 21, 02, 29,
            11, 14, 16, 18, 22, 25, 03, 30,
            08, 12, 20, 28, 15, 17, 24, 07,
            19, 27, 23, 06, 26, 05, 04, 31
        };

        /// <summary>
        /// Count the number of leading zero bits in a mask.
        /// Similar in behavior to the x86 instruction LZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int LeadingZeroCount(uint value)
        {
            // Unguarded fallback contract is 0->31
            if (value == 0)
            {
                return 32;
            }

            return 31 - Log2SoftwareFallback(value);
        }

        /// <summary>
        /// Count the number of leading zero bits in a mask.
        /// Similar in behavior to the x86 instruction LZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int LeadingZeroCount(ulong value)
        {
            uint hi = (uint)(value >> 32);

            if (hi == 0)
            {
                return 32 + LeadingZeroCount((uint)value);
            }

            return LeadingZeroCount(hi);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Log2(uint value)
        {
            // Fallback contract is 0->0
            return Log2SoftwareFallback(value);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Log2(ulong value)
        {
            uint hi = (uint)(value >> 32);

            if (hi == 0)
            {
                return Log2((uint)value);
            }

            return 32 + Log2(hi);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// Does not directly use any hardware intrinsics, nor does it incur branching.
        /// </summary>
        /// <param name="value">The value.</param>
        private static int Log2SoftwareFallback(uint value)
        {
            // No AggressiveInlining due to large method size
            // Has conventional contract 0->0 (Log(0) is undefined)

            // Fill trailing zeros with ones, eg 00010010 becomes 00011111
            value |= value >> 01;
            value |= value >> 02;
            value |= value >> 04;
            value |= value >> 08;
            value |= value >> 16;

            // uint.MaxValue >> 27 is always in range [0 - 31] so we use Unsafe.AddByteOffset to avoid bounds check
            return Unsafe.AddByteOffset(
                // Using deBruijn sequence, k=2, n=5 (2^5=32) : 0b_0000_0111_1100_0100_1010_1100_1101_1101u
                ref MemoryMarshal.GetReference(Log2DeBruijn),
                // uint|long -> IntPtr cast on 32-bit platforms does expensive overflow checks not needed here
                (IntPtr)(int)((value * 0x07C4ACDDu) >> 27));
        }

        /// <summary>
        /// Returns the population count (number of bits set) of a mask.
        /// Similar in behavior to the x86 instruction POPCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int PopCount(uint value)
        {
            const uint c1 = 0x_55555555u;
            const uint c2 = 0x_33333333u;
            const uint c3 = 0x_0F0F0F0Fu;
            const uint c4 = 0x_01010101u;

            value -= (value >> 1) & c1;
            value = (value & c2) + ((value >> 2) & c2);
            value = (((value + (value >> 4)) & c3) * c4) >> 24;

            return (int)value;
        }

        /// <summary>
        /// Returns the population count (number of bits set) of a mask.
        /// Similar in behavior to the x86 instruction POPCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int PopCount(ulong value)
        {
            if (IntPtr.Size == 4)
            {
                return PopCount((uint)value) // lo
                    + PopCount((uint)(value >> 32)); // hi
            }
            else
            {
                const ulong c1 = 0x_55555555_55555555ul;
                const ulong c2 = 0x_33333333_33333333ul;
                const ulong c3 = 0x_0F0F0F0F_0F0F0F0Ful;
                const ulong c4 = 0x_01010101_01010101ul;

                value -= (value >> 1) & c1;
                value = (value & c2) + ((value >> 2) & c2);
                value = (((value + (value >> 4)) & c3) * c4) >> 56;

                return (int)value;
            }
        }

        /// <summary>
        /// Count the number of trailing zero bits in an integer value.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(int value)
            => TrailingZeroCount((uint)value);

        /// <summary>
        /// Count the number of trailing zero bits in an integer value.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(uint value)
        {
            // Unguarded fallback contract is 0->0
            if (value == 0)
            {
                return 32;
            }

            // uint.MaxValue >> 27 is always in range [0 - 31] so we use Unsafe.AddByteOffset to avoid bounds check
            return Unsafe.AddByteOffset(
                // Using deBruijn sequence, k=2, n=5 (2^5=32) : 0b_0000_0111_0111_1100_1011_0101_0011_0001u
                ref MemoryMarshal.GetReference(TrailingZeroCountDeBruijn),
                // uint|long -> IntPtr cast on 32-bit platforms does expensive overflow checks not needed here
                (IntPtr)(int)(((value & (uint)-(int)value) * 0x077CB531u) >> 27)); // Multi-cast mitigates redundant conv.u8
        }

        /// <summary>
        /// Count the number of trailing zero bits in a mask.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(long value)
            => TrailingZeroCount((ulong)value);

        /// <summary>
        /// Count the number of trailing zero bits in a mask.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(ulong value)
        {
            uint lo = (uint)value;

            if (lo == 0)
            {
                return 32 + TrailingZeroCount((uint)(value >> 32));
            }

            return TrailingZeroCount(lo);
        }

        /// <summary>
        /// Rotates the specified value left by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROL.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint RotateLeft(uint value, int offset)
            => (value << offset) | (value >> (32 - offset));

        /// <summary>
        /// Rotates the specified value left by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROL.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..63] is treated as congruent mod 64.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong RotateLeft(ulong value, int offset)
            => (value << offset) | (value >> (64 - offset));

        /// <summary>
        /// Rotates the specified value right by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROR.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint RotateRight(uint value, int offset)
            => (value >> offset) | (value << (32 - offset));

        /// <summary>
        /// Rotates the specified value right by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROR.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..63] is treated as congruent mod 64.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong RotateRight(ulong value, int offset)
            => (value >> offset) | (value << (64 - offset));
    }
}

#endif



================================================
FILE: src/ZString/Number/BufferEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace System
{
    internal static class BufferEx
    {
        internal static unsafe void ZeroMemory(byte* dest, uint len)
        {
            if (len == 0) return;

            for (int i = 0; i < len; i++)
            {
                dest[i] = 0;
            }
        }

        internal static unsafe void Memcpy(byte* dest, byte* src, int len)
        {
            if (len == 0) return;
            for (int i = 0; i < len; i++)
            {
                dest[i] = src[i];
            }
        }
    }
}



================================================
FILE: src/ZString/Number/DecimalEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace System
{
    internal static class DecimalEx
    {
        [StructLayout(LayoutKind.Explicit)]
        private struct DecimalBits
        {
            [FieldOffset(0)]
            public int flags;
            [FieldOffset(4)]
            public int hi;
            [FieldOffset(8)]
            public int lo;
            [FieldOffset(12)]
            public int mid;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct DecCalc
        {
            private const uint TenToPowerNine = 1000000000;

            // NOTE: Do not change the offsets of these fields. This structure must have the same layout as Decimal.
            [FieldOffset(0)]
            public uint uflags;
            [FieldOffset(4)]
            public uint uhi;
            [FieldOffset(8)]
            public uint ulo;
            [FieldOffset(12)]
            public uint umid;

            /// <summary>
            /// The low and mid fields combined in little-endian order
            /// </summary>
            [FieldOffset(8)]
            private ulong ulomidLE;

            internal static uint DecDivMod1E9(ref DecCalc value)
            {
                ulong high64 = ((ulong)value.uhi << 32) + value.umid;
                ulong div64 = high64 / TenToPowerNine;
                value.uhi = (uint)(div64 >> 32);
                value.umid = (uint)div64;

                ulong num = ((high64 - (uint)div64 * TenToPowerNine) << 32) + value.ulo;
                uint div = (uint)(num / TenToPowerNine);
                value.ulo = div;
                return (uint)num - div * TenToPowerNine;
            }
        }

        private const int ScaleShift = 16;

        static ref DecCalc AsMutable(ref decimal d) => ref Unsafe.As<decimal, DecCalc>(ref d);

        internal static uint High(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).uhi;
        }

        internal static uint Low(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).ulo;
        }

        internal static uint Mid(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).umid;
        }

        internal static bool IsNegative(this decimal value)
        {
            return Unsafe.As<decimal, DecimalBits>(ref value).flags < 0;
        }

        internal static int Scale(this decimal value)
        {
            return (byte)(Unsafe.As<decimal, DecimalBits>(ref value).flags >> ScaleShift);
        }

        internal static uint DecDivMod1E9(ref decimal value)
        {
            return DecCalc.DecDivMod1E9(ref AsMutable(ref value));
        }
    }
}



================================================
FILE: src/ZString/Number/FloatEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static class FloatEx
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsFinite(double d)
        {
            long bits = BitConverter.DoubleToInt64Bits(d);
            return (bits & 0x7FFFFFFFFFFFFFFF) < 0x7FF0000000000000;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegative(double d)
        {
            return BitConverter.DoubleToInt64Bits(d) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(float f)
        {
            int bits = SingleToInt32Bits(f);
            return (bits & 0x7FFFFFFF) < 0x7F800000;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegative(float f)
        {
            return SingleToInt32Bits(f) < 0;
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int SingleToInt32Bits(float value)
        {
            return *((int*)&value);
        }
    }
}



================================================
FILE: src/ZString/Number/FormattingHelpers.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace System.Buffers.Text
{
    internal static partial class FormattingHelpers
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDigits(ulong value)
        {
            int digits = 1;
            uint part;
            if (value >= 10000000)
            {
                if (value >= 100000000000000)
                {
                    part = (uint)(value / 100000000000000);
                    digits += 14;
                }
                else
                {
                    part = (uint)(value / 10000000);
                    digits += 7;
                }
            }
            else
            {
                part = (uint)value;
            }

            if (part < 10)
            {
                // no-op
            }
            else if (part < 100)
            {
                digits++;
            }
            else if (part < 1000)
            {
                digits += 2;
            }
            else if (part < 10000)
            {
                digits += 3;
            }
            else if (part < 100000)
            {
                digits += 4;
            }
            else if (part < 1000000)
            {
                digits += 5;
            }
            else
            {
                Debug.Assert(part < 10000000);
                digits += 6;
            }

            return digits;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDigits(uint value)
        {
            int digits = 1;
            if (value >= 100000)
            {
                value /= 100000;
                digits += 5;
            }

            if (value < 10)
            {
                // no-op
            }
            else if (value < 100)
            {
                digits++;
            }
            else if (value < 1000)
            {
                digits += 2;
            }
            else if (value < 10000)
            {
                digits += 3;
            }
            else
            {
                Debug.Assert(value < 100000);
                digits += 4;
            }

            return digits;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountHexDigits(ulong value)
        {
            return (64 - BitOperations.LeadingZeroCount(value | 1) + 3) >> 2;
        }

        // Counts the number of trailing '0' digits in a decimal number.
        // e.g., value =      0 => retVal = 0, valueWithoutTrailingZeros = 0
        //       value =   1234 => retVal = 0, valueWithoutTrailingZeros = 1234
        //       value = 320900 => retVal = 2, valueWithoutTrailingZeros = 3209
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDecimalTrailingZeros(uint value, out uint valueWithoutTrailingZeros)
        {
            int zeroCount = 0;

            if (value != 0)
            {
                while (true)
                {
                    uint temp = value / 10;
                    if (value != (temp * 10))
                    {
                        break;
                    }

                    value = temp;
                    zeroCount++;
                }
            }

            valueWithoutTrailingZeros = value;
            return zeroCount;
        }
    }
}


================================================
FILE: src/ZString/Number/GuidEx.cs
================================================
﻿using System.Runtime.InteropServices;

namespace System
{
    [StructLayout(LayoutKind.Sequential)]
    internal struct GuidEx
    {
        private int _a;   // Do not rename (binary serialization)
        private short _b; // Do not rename (binary serialization)
        private short _c; // Do not rename (binary serialization)
        private byte _d;  // Do not rename (binary serialization)
        private byte _e;  // Do not rename (binary serialization)
        private byte _f;  // Do not rename (binary serialization)
        private byte _g;  // Do not rename (binary serialization)
        private byte _h;  // Do not rename (binary serialization)
        private byte _i;  // Do not rename (binary serialization)
        private byte _j;  // Do not rename (binary serialization)
        private byte _k;  // Do not rename (binary serialization)

        private static unsafe int HexsToChars(char* guidChars, int a, int b)
        {
            guidChars[0] = HexConverter.ToCharLower(a >> 4);
            guidChars[1] = HexConverter.ToCharLower(a);

            guidChars[2] = HexConverter.ToCharLower(b >> 4);
            guidChars[3] = HexConverter.ToCharLower(b);

            return 4;
        }

        private static unsafe int HexsToCharsHexOutput(char* guidChars, int a, int b)
        {
            guidChars[0] = '0';
            guidChars[1] = 'x';

            guidChars[2] = HexConverter.ToCharLower(a >> 4);
            guidChars[3] = HexConverter.ToCharLower(a);

            guidChars[4] = ',';
            guidChars[5] = '0';
            guidChars[6] = 'x';

            guidChars[7] = HexConverter.ToCharLower(b >> 4);
            guidChars[8] = HexConverter.ToCharLower(b);

            return 9;
        }

        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                format = "D".AsSpan();
            }
            // all acceptable format strings are of length 1
            if (format.Length != 1)
            {
                throw new FormatException("InvalidGuidFormatSpecification");
            }

            bool dash = true;
            bool hex = false;
            int braces = 0;

            int guidSize;

            switch (format[0])
            {
                case 'D':
                case 'd':
                    guidSize = 36;
                    break;
                case 'N':
                case 'n':
                    dash = false;
                    guidSize = 32;
                    break;
                case 'B':
                case 'b':
                    braces = '{' + ('}' << 16);
                    guidSize = 38;
                    break;
                case 'P':
                case 'p':
                    braces = '(' + (')' << 16);
                    guidSize = 38;
                    break;
                case 'X':
                case 'x':
                    braces = '{' + ('}' << 16);
                    dash = false;
                    hex = true;
                    guidSize = 68;
                    break;
                default:
                    throw new FormatException("InvalidGuidFormatSpecification");
            }

            if (destination.Length < guidSize)
            {
                charsWritten = 0;
                return false;
            }

            unsafe
            {
                fixed (char* guidChars = &MemoryMarshal.GetReference(destination))
                {
                    char* p = guidChars;

                    if (braces != 0)
                        *p++ = (char)braces;

                    if (hex)
                    {
                        // {0xdddddddd,0xdddd,0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _a >> 24, _a >> 16);
                        p += HexsToChars(p, _a >> 8, _a);
                        *p++ = ',';
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _b >> 8, _b);
                        *p++ = ',';
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _c >> 8, _c);
                        *p++ = ',';
                        *p++ = '{';
                        p += HexsToCharsHexOutput(p, _d, _e);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _f, _g);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _h, _i);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _j, _k);
                        *p++ = '}';
                    }
                    else
                    {
                        // [{|(]dddddddd[-]dddd[-]dddd[-]dddd[-]dddddddddddd[}|)]
                        p += HexsToChars(p, _a >> 24, _a >> 16);
                        p += HexsToChars(p, _a >> 8, _a);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _b >> 8, _b);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _c >> 8, _c);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _d, _e);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _f, _g);
                        p += HexsToChars(p, _h, _i);
                        p += HexsToChars(p, _j, _k);
                    }

                    if (braces != 0)
                        *p++ = (char)(braces >> 16);
                }
            }

            charsWritten = guidSize;
            return true;
        }
    }
}



================================================
FILE: src/ZString/Number/HexConverter.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;

namespace System
{
    internal static class HexConverter
    {
        public enum Casing : uint
        {
            // Output [ '0' .. '9' ] and [ 'A' .. 'F' ].
            Upper = 0,

            // Output [ '0' .. '9' ] and [ 'a' .. 'f' ].
            // This works because values in the range [ 0x30 .. 0x39 ] ([ '0' .. '9' ])
            // already have the 0x20 bit set, so ORing them with 0x20 is a no-op,
            // while outputs in the range [ 0x41 .. 0x46 ] ([ 'A' .. 'F' ])
            // don't have the 0x20 bit set, so ORing them maps to
            // [ 0x61 .. 0x66 ] ([ 'a' .. 'f' ]), which is what we want.
            Lower = 0x2020U,
        }

        // We want to pack the incoming byte into a single integer [ 0000 HHHH 0000 LLLL ],
        // where HHHH and LLLL are the high and low nibbles of the incoming byte. Then
        // subtract this integer from a constant minuend as shown below.
        //
        //   [ 1000 1001 1000 1001 ]
        // - [ 0000 HHHH 0000 LLLL ]
        // =========================
        //   [ *YYY **** *ZZZ **** ]
        //
        // The end result of this is that YYY is 0b000 if HHHH <= 9, and YYY is 0b111 if HHHH >= 10.
        // Similarly, ZZZ is 0b000 if LLLL <= 9, and ZZZ is 0b111 if LLLL >= 10.
        // (We don't care about the value of asterisked bits.)
        //
        // To turn a nibble in the range [ 0 .. 9 ] into hex, we calculate hex := nibble + 48 (ascii '0').
        // To turn a nibble in the range [ 10 .. 15 ] into hex, we calculate hex := nibble - 10 + 65 (ascii 'A').
        //                                                                => hex := nibble + 55.
        // The difference in the starting ASCII offset is (55 - 48) = 7, depending on whether the nibble is <= 9 or >= 10.
        // Since 7 is 0b111, this conveniently matches the YYY or ZZZ value computed during the earlier subtraction.

        // The commented out code below is code that directly implements the logic described above.

        // uint packedOriginalValues = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU);
        // uint difference = 0x8989U - packedOriginalValues;
        // uint add7Mask = (difference & 0x7070U) >> 4; // line YYY and ZZZ back up with the packed values
        // uint packedResult = packedOriginalValues + add7Mask + 0x3030U /* ascii '0' */;

        // The code below is equivalent to the commented out code above but has been tweaked
        // to allow codegen to make some extra optimizations.

        // The low byte of the packed result contains the hex representation of the incoming byte's low nibble.
        // The adjacent byte of the packed result contains the hex representation of the incoming byte's high nibble.

        // Finally, write to the output buffer starting with the *highest* index so that codegen can
        // elide all but the first bounds check. (This only works if 'startingIndex' is a compile-time constant.)

        // The JIT can elide bounds checks if 'startingIndex' is constant and if the caller is
        // writing to a span of known length (or the caller has already checked the bounds of the
        // furthest access).
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ToBytesBuffer(byte value, Span<byte> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
        {
            uint difference = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU) - 0x8989U;
            uint packedResult = ((((uint)(-(int)difference) & 0x7070U) >> 4) + difference + 0xB9B9U) | (uint)casing;

            buffer[startingIndex + 1] = (byte)packedResult;
            buffer[startingIndex] = (byte)(packedResult >> 8);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ToCharsBuffer(byte value, Span<char> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
        {
            uint difference = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU) - 0x8989U;
            uint packedResult = ((((uint)(-(int)difference) & 0x7070U) >> 4) + difference + 0xB9B9U) | (uint)casing;

            buffer[startingIndex + 1] = (char)(packedResult & 0xFF);
            buffer[startingIndex] = (char)(packedResult >> 8);
        }

        public static unsafe string ToString(ReadOnlySpan<byte> bytes, Casing casing = Casing.Upper)
        {
            Span<char> result = stackalloc char[0];
            if (bytes.Length > 16)
            {
                var array = new char[bytes.Length * 2];
                result = array.AsSpan();
            }
            else
            {
                result = stackalloc char[bytes.Length * 2];
            }
 
            int pos = 0;
            foreach (byte b in bytes)
            {
                ToCharsBuffer(b, result, pos, casing);
                pos += 2;
            }
            return result.ToString();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToCharUpper(int value)
        {
            value &= 0xF;
            value += '0';

            if (value > '9')
            {
                value += ('A' - ('9' + 1));
            }

            return (char)value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToCharLower(int value)
        {
            value &= 0xF;
            value += '0';

            if (value > '9')
            {
                value += ('a' - ('9' + 1));
            }

            return (char)value;
        }
    }
}


================================================
FILE: src/ZString/Number/InternalSpanEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace System
{
    internal static class InternalSpanEx
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool EqualsOrdinalIgnoreCase(this ReadOnlySpan<char> span, ReadOnlySpan<char> value)
        {
            if (span.Length != value.Length)
                return false;
            if (value.Length == 0)  // span.Length == value.Length == 0
                return true;
            
            

            return EqualsOrdinalIgnoreCase(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), span.Length);
        }

        static bool EqualsOrdinalIgnoreCase(ref char charA, ref char charB, int length)
        {
            IntPtr byteOffset = IntPtr.Zero;

            if (IntPtr.Size == 8)
            {
                // Read 4 chars (64 bits) at a time from each string
                while ((uint)length >= 4)
                {
                    ulong valueA = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, byteOffset)));
                    ulong valueB = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, byteOffset)));

                    // A 32-bit test - even with the bit-twiddling here - is more efficient than a 64-bit test.
                    ulong temp = valueA | valueB;
                    if (!AllCharsInUInt32AreAscii((uint)temp | (uint)(temp >> 32)))
                    {
                        goto NonAscii; // one of the inputs contains non-ASCII data
                    }

                    // Generally, the caller has likely performed a first-pass check that the input strings
                    // are likely equal. Consider a dictionary which computes the hash code of its key before
                    // performing a proper deep equality check of the string contents. We want to optimize for
                    // the case where the equality check is likely to succeed, which means that we want to avoid
                    // branching within this loop unless we're about to exit the loop, either due to failure or
                    // due to us running out of input data.

                    if (!UInt64OrdinalIgnoreCaseAscii(valueA, valueB))
                    {
                        return false;
                    }

                    byteOffset += 8;
                    length -= 4;
                }
            }

            // Read 2 chars (32 bits) at a time from each string
            while ((uint)length >= 2)
            {
                uint valueA = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, byteOffset)));
                uint valueB = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, byteOffset)));

                if (!AllCharsInUInt32AreAscii(valueA | valueB))
                {
                    goto NonAscii; // one of the inputs contains non-ASCII data
                }

                // Generally, the caller has likely performed a first-pass check that the input strings
                // are likely equal. Consider a dictionary which computes the hash code of its key before
                // performing a proper deep equality check of the string contents. We want to optimize for
                // the case where the equality check is likely to succeed, which means that we want to avoid
                // branching within this loop unless we're about to exit the loop, either due to failure or
                // due to us running out of input data.

                if (!UInt32OrdinalIgnoreCaseAscii(valueA, valueB))
                {
                    return false;
                }

                byteOffset += 4;
                length -= 2;
            }

            if (length != 0)
            {
                Debug.Assert(length == 1);

                uint valueA = Unsafe.AddByteOffset(ref charA, byteOffset);
                uint valueB = Unsafe.AddByteOffset(ref charB, byteOffset);

                if ((valueA | valueB) > 0x7Fu)
                {
                    goto NonAscii; // one of the inputs contains non-ASCII data
                }

                if (valueA == valueB)
                {
                    return true; // exact match
                }

                valueA |= 0x20u;
                if ((uint)(valueA - 'a') > (uint)('z' - 'a'))
                {
                    return false; // not exact match, and first input isn't in [A-Za-z]
                }

                // The ternary operator below seems redundant but helps RyuJIT generate more optimal code.
                // See https://github.com/dotnet/coreclr/issues/914.
                return (valueA == (valueB | 0x20u)) ? true : false;
            }

            Debug.Assert(length == 0);
            return true;

            NonAscii:
            // The non-ASCII case is factored out into its own helper method so that the JIT
            // doesn't need to emit a complex prolog for its caller (this method).
            return EqualsOrdinalIgnoreCaseNonAscii(ref Unsafe.AddByteOffset(ref charA, byteOffset), ref Unsafe.AddByteOffset(ref charB, byteOffset), length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AllCharsInUInt32AreAscii(uint value)
        {
            return (value & ~0x007F_007Fu) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AllCharsInUInt64AreAscii(ulong value)
        {
            return (value & ~0x007F_007F_007F_007Ful) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool UInt32OrdinalIgnoreCaseAscii(uint valueA, uint valueB)
        {
            // ASSUMPTION: Caller has validated that input values are ASCII.
            Debug.Assert(AllCharsInUInt32AreAscii(valueA));
            Debug.Assert(AllCharsInUInt32AreAscii(valueB));

            // a mask of all bits which are different between A and B
            uint differentBits = valueA ^ valueB;

            // the 0x80 bit of each word of 'lowerIndicator' will be set iff the word has value < 'A'
            uint lowerIndicator = valueA + 0x0100_0100u - 0x0041_0041u;

            // the 0x80 bit of each word of 'upperIndicator' will be set iff (word | 0x20) has value > 'z'
            uint upperIndicator = (valueA | 0x0020_0020u) + 0x0080_0080u - 0x007B_007Bu;

            // the 0x80 bit of each word of 'combinedIndicator' will be set iff the word is *not* [A-Za-z]
            uint combinedIndicator = lowerIndicator | upperIndicator;

            // Shift all the 0x80 bits of 'combinedIndicator' into the 0x20 positions, then set all bits
            // aside from 0x20. This creates a mask where all bits are set *except* for the 0x20 bits
            // which correspond to alpha chars (either lower or upper). For these alpha chars only, the
            // 0x20 bit is allowed to differ between the two input values. Every other char must be an
            // exact bitwise match between the two input values. In other words, (valueA & mask) will
            // convert valueA to uppercase, so (valueA & mask) == (valueB & mask) answers "is the uppercase
            // form of valueA equal to the uppercase form of valueB?" (Technically if valueA has an alpha
            // char in the same position as a non-alpha char in valueB, or vice versa, this operation will
            // result in nonsense, but it'll still compute as inequal regardless, which is what we want ultimately.)
            // The line below is a more efficient way of doing the same check taking advantage of the XOR
            // computation we performed at the beginning of the method.

            return (((combinedIndicator >> 2) | ~0x0020_0020u) & differentBits) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB)
        {
            // ASSUMPTION: Caller has validated that input values are ASCII.
            Debug.Assert(AllCharsInUInt64AreAscii(valueA));
            Debug.Assert(AllCharsInUInt64AreAscii(valueB));

            // the 0x80 bit of each word of 'lowerIndicator' will be set iff the word has value >= 'A'
            ulong lowerIndicator = valueA + 0x0080_0080_0080_0080ul - 0x0041_0041_0041_0041ul;

            // the 0x80 bit of each word of 'upperIndicator' will be set iff (word | 0x20) has value <= 'z'
            ulong upperIndicator = (valueA | 0x0020_0020_0020_0020ul) + 0x0100_0100_0100_0100ul - 0x007B_007B_007B_007Bul;

            // the 0x20 bit of each word of 'combinedIndicator' will be set iff the word is [A-Za-z]
            ulong combinedIndicator = (0x0080_0080_0080_0080ul & lowerIndicator & upperIndicator) >> 2;

            // Convert both values to lowercase (using the combined indicator from the first value)
            // and compare for equality. It's possible that the first value will contain an alpha character
            // where the second value doesn't (or vice versa), and applying the combined indicator will
            // create nonsensical data, but the comparison would have failed anyway in this case so it's
            // a safe operation to perform.
            //
            // This 64-bit method is similar to the 32-bit method, but it performs the equivalent of convert-to-
            // lowercase-then-compare rather than convert-to-uppercase-and-compare. This particular operation
            // happens to be faster on x64.

            return (valueA | combinedIndicator) == (valueB | combinedIndicator);
        }

        private static bool EqualsOrdinalIgnoreCaseNonAscii(ref char charA, ref char charB, int length)
        {
            //if (!GlobalizationMode.Invariant)
            //{
            //    return CompareStringOrdinalIgnoreCase(ref charA, length, ref charB, length) == 0;
            //}
            //else
            {
                // If we don't have localization tables to consult, we'll still perform a case-insensitive
                // check for ASCII characters, but if we see anything outside the ASCII range we'll immediately
                // fail if it doesn't have true bitwise equality.

                IntPtr byteOffset = IntPtr.Zero;
                while (length != 0)
                {
                    // Ordinal equals or lowercase equals if the result ends up in the a-z range
                    uint valueA = Unsafe.AddByteOffset(ref charA, byteOffset);
                    uint valueB = Unsafe.AddByteOffset(ref charB, byteOffset);

                    if (valueA == valueB ||
                        ((valueA | 0x20) == (valueB | 0x20) &&
                            (uint)((valueA | 0x20) - 'a') <= (uint)('z' - 'a')))
                    {
                        byteOffset += 2;
                        length--;
                    }
                    else
                    {
                        return false;
                    }
                }

                return true;
            }
        }
    }
}



================================================
FILE: src/ZString/Number/MathEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static class MathEx
    {
        public static uint DivRem(uint a, uint b, out uint result)
        {
            uint div = a / b;
            result = a - (div * b);
            return div;
        }

        public static ulong DivRem(ulong a, ulong b, out ulong result)
        {
            ulong div = a / b;
            result = a - (div * b);
            return div;
        }

        public static int DivRem(int a, int b, out int result)
        {
            int div = a / b;
            result = a - (div * b);
            return div;
        }

        public static long DivRem(long a, long b, out long result)
        {
            long div = a / b;
            result = a - (div * b);
            return div;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Clamp(byte value, byte min, byte max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static decimal Clamp(decimal value, decimal min, decimal max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Clamp(double value, double min, double max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short Clamp(short value, short min, short max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Clamp(int value, int min, int max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Clamp(long value, long min, long max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte Clamp(sbyte value, sbyte min, sbyte max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Clamp(float value, float min, float max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Clamp(ushort value, ushort min, ushort max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Clamp(uint value, uint min, uint max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Clamp(ulong value, ulong min, ulong max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        private static void ThrowMinMaxException<T>(T min, T max)
        {
            throw new ArgumentException($"Argument_MinMaxValue, min:{min} max:{max}");
        }
    }
}



================================================
FILE: src/ZString/Number/Number.BigInteger.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System
{
    internal static partial class Number
    {
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal unsafe ref struct BigInteger
        {
            // The longest binary mantissa requires: explicit mantissa bits + abs(min exponent)
            // * Half:     10 +    14 =    24
            // * Single:   23 +   126 =   149
            // * Double:   52 +  1022 =  1074
            // * Quad:    112 + 16382 = 16494
            private const int BitsForLongestBinaryMantissa = 1074;

            // The longest digit sequence requires: ceil(log2(pow(10, max significant digits + 1 rounding digit)))
            // * Half:    ceil(log2(pow(10,    21 + 1))) =    74
            // * Single:  ceil(log2(pow(10,   112 + 1))) =   376
            // * Double:  ceil(log2(pow(10,   767 + 1))) =  2552
            // * Quad:    ceil(log2(pow(10, 11563 + 1))) = 38415
            private const int BitsForLongestDigitSequence = 2552;

            // We require BitsPerBlock additional bits for shift space used during the pre-division preparation
            private const int MaxBits = BitsForLongestBinaryMantissa + BitsForLongestDigitSequence + BitsPerBlock;

            private const int BitsPerBlock = sizeof(int) * 8;
            private const int MaxBlockCount = (MaxBits + (BitsPerBlock - 1)) / BitsPerBlock;

            private static readonly uint[] s_Pow10UInt32Table = new uint[]
            {
                1,          // 10^0
                10,         // 10^1
                100,        // 10^2
                1000,       // 10^3
                10000,      // 10^4
                100000,     // 10^5
                1000000,    // 10^6
                10000000,   // 10^7
            };

            private static readonly int[] s_Pow10BigNumTableIndices = new int[]
            {
                0,          // 10^8
                2,          // 10^16
                5,          // 10^32
                10,         // 10^64
                18,         // 10^128
                33,         // 10^256
                61,         // 10^512
                116,        // 10^1024
            };

            private static readonly uint[] s_Pow10BigNumTable = new uint[]
            {
                // 10^8
                1,          // _length
                100000000,  // _blocks
 
                // 10^16
                2,          // _length
                0x6FC10000, // _blocks
                0x002386F2,
 
                // 10^32
                4,          // _length
                0x00000000, // _blocks
                0x85ACEF81,
                0x2D6D415B,
                0x000004EE,
 
                // 10^64
                7,          // _length
                0x00000000, // _blocks
                0x00000000,
                0xBF6A1F01,
                0x6E38ED64,
                0xDAA797ED,
                0xE93FF9F4,
                0x00184F03,
 
                // 10^128
                14,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x2E953E01,
                0x03DF9909,
                0x0F1538FD,
                0x2374E42F,
                0xD3CFF5EC,
                0xC404DC08,
                0xBCCDB0DA,
                0xA6337F19,
                0xE91F2603,
                0x0000024E,
 
                // 10^256
                27,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x982E7C01,
                0xBED3875B,
                0xD8D99F72,
                0x12152F87,
                0x6BDE50C6,
                0xCF4A6E70,
                0xD595D80F,
                0x26B2716E,
                0xADC666B0,
                0x1D153624,
                0x3C42D35A,
                0x63FF540E,
                0xCC5573C0,
                0x65F9EF17,
                0x55BC28F2,
                0x80DCC7F7,
                0xF46EEDDC,
                0x5FDCEFCE,
                0x000553F7,
 
                // 10^512
                54,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0xFC6CF801,
                0x77F27267,
                0x8F9546DC,
                0x5D96976F,
                0xB83A8A97,
                0xC31E1AD9,
                0x46C40513,
                0x94E65747,
                0xC88976C1,
                0x4475B579,
                0x28F8733B,
                0xAA1DA1BF,
                0x703ED321,
                0x1E25CFEA,
                0xB21A2F22,
                0xBC51FB2E,
                0x96E14F5D,
                0xBFA3EDAC,
                0x329C57AE,
                0xE7FC7153,
                0xC3FC0695,
                0x85A91924,
                0xF95F635E,
                0xB2908EE0,
                0x93ABADE4,
                0x1366732A,
                0x9449775C,
                0x69BE5B0E,
                0x7343AFAC,
                0xB099BC81,
                0x45A71D46,
                0xA2699748,
                0x8CB07303,
                0x8A0B1F13,
                0x8CAB8A97,
                0xC1D238D9,
                0x633415D4,
                0x0000001C,
 
                // 10^1024
                107,        // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x2919F001,
                0xF55B2B72,
                0x6E7C215B,
                0x1EC29F86,
                0x991C4E87,
                0x15C51A88,
                0x140AC535,
                0x4C7D1E1A,
                0xCC2CD819,
                0x0ED1440E,
                0x896634EE,
                0x7DE16CFB,
                0x1E43F61F,
                0x9FCE837D,
                0x231D2B9C,
                0x233E55C7,
                0x65DC60D7,
                0xF451218B,
                0x1C5CD134,
                0xC9635986,
                0x922BBB9F,
                0xA7E89431,
                0x9F9F2A07,
                0x62BE695A,
                0x8E1042C4,
                0x045B7A74,
                0x1ABE1DE3,
                0x8AD822A5,
                0xBA34C411,
                0xD814B505,
                0xBF3FDEB3,
                0x8FC51A16,
                0xB1B896BC,
                0xF56DEEEC,
                0x31FB6BFD,
                0xB6F4654B,
                0x101A3616,
                0x6B7595FB,
                0xDC1A47FE,
                0x80D98089,
                0x80BDA5A5,
                0x9A202882,
                0x31EB0F66,
                0xFC8F1F90,
                0x976A3310,
                0xE26A7B7E,
                0xDF68368A,
                0x3CE3A0B8,
                0x8E4262CE,
                0x75A351A2,
                0x6CB0B6C9,
                0x44597583,
                0x31B5653F,
                0xC356E38A,
                0x35FAABA6,
                0x0190FBA0,
                0x9FC4ED52,
                0x88BC491B,
                0x1640114A,
                0x005B8041,
                0xF4F3235E,
                0x1E8D4649,
                0x36A8DE06,
                0x73C55349,
                0xA7E6BD2A,
                0xC1A6970C,
                0x47187094,
                0xD2DB49EF,
                0x926C3F5B,
                0xAE6209D4,
                0x2D433949,
                0x34F4A3C6,
                0xD4305D94,
                0xD9D61A05,
                0x00000325,
 
                // 9 Trailing blocks to ensure MaxBlockCount
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
            };

            private int _length;
            private fixed uint _blocks[MaxBlockCount];

            public static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
            {
                // determine which operand has the smaller length
                ref BigInteger large = ref (lhs._length < rhs._length) ? ref rhs : ref lhs;
                ref BigInteger small = ref (lhs._length < rhs._length) ? ref lhs : ref rhs;

                int largeLength = large._length;
                int smallLength = small._length;

                // The output will be at least as long as the largest input
                result._length = largeLength;

                // Add each block and add carry the overflow to the next block
                ulong carry = 0;

                int largeIndex = 0;
                int smallIndex = 0;
                int resultIndex = 0;

                while (smallIndex < smallLength)
                {
                    ulong sum = carry + large._blocks[largeIndex] + small._blocks[smallIndex];
                    carry = sum >> 32;
                    result._blocks[resultIndex] = (uint)(sum);

                    largeIndex++;
                    smallIndex++;
                    resultIndex++;
                }

                // Add the carry to any blocks that only exist in the large operand
                while (largeIndex < largeLength)
                {
                    ulong sum = carry + large._blocks[largeIndex];
                    carry = sum >> 32;
                    result._blocks[resultIndex] = (uint)(sum);

                    largeIndex++;
                    resultIndex++;
                }

                // If there's still a carry, append a new block
                if (carry != 0)
                {
                    Debug.Assert(carry == 1);
                    Debug.Assert((resultIndex == largeLength) && (largeLength < MaxBlockCount));

                    result._blocks[resultIndex] = 1;
                    result._length++;
                }
            }

            public static int Compare(ref BigInteger lhs, ref BigInteger rhs)
            {
                Debug.Assert(unchecked((uint)(lhs._length)) <= MaxBlockCount);
                Debug.Assert(unchecked((uint)(rhs._length)) <= MaxBlockCount);

                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                int lengthDelta = (lhsLength - rhsLength);

                if (lengthDelta != 0)
                {
                    return lengthDelta;
                }

                if (lhsLength == 0)
                {
                    Debug.Assert(rhsLength == 0);
                    return 0;
                }

                for (int index = (lhsLength - 1); index >= 0; index--)
                {
                    long delta = (long)(lhs._blocks[index]) - rhs._blocks[index];

                    if (delta != 0)
                    {
                        return delta > 0 ? 1 : -1;
                    }
                }

                return 0;
            }

            public static uint CountSignificantBits(uint value)
            {
                return 32 - (uint)BitOperations.LeadingZeroCount(value);
            }

            public static uint CountSignificantBits(ulong value)
            {
                return 64 - (uint)BitOperations.LeadingZeroCount(value);
            }

            public static uint CountSignificantBits(ref BigInteger value)
            {
                if (value.IsZero())
                {
                    return 0;
                }

                // We don't track any unused blocks, so we only need to do a BSR on the
                // last index and add that to the number of bits we skipped.

                uint lastIndex = (uint)(value._length - 1);
                return (lastIndex * BitsPerBlock) + CountSignificantBits(value._blocks[lastIndex]);
            }

            public static void DivRem(ref BigInteger lhs, ref BigInteger rhs, out BigInteger quo, out BigInteger rem)
            {
                // This is modified from the libraries BigIntegerCalculator.DivRem.cs implementation:
                // https://github.com/dotnet/runtime/blob/master/src/libraries/System.Runtime.Numerics/src/System/Numerics/BigIntegerCalculator.DivRem.cs

                Debug.Assert(!rhs.IsZero());

                if (lhs.IsZero())
                {
                    SetZero(out quo);
                    SetZero(out rem);
                    return;
                }

                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                if ((lhsLength == 1) && (rhsLength == 1))
                {
                    uint quotient = MathEx.DivRem(lhs._blocks[0], rhs._blocks[0], out uint remainder);
                    SetUInt32(out quo, quotient);
                    SetUInt32(out rem, remainder);
                    return;
                }

                if (rhsLength == 1)
                {
                    // We can make the computation much simpler if the rhs is only one block

                    int quoLength = lhsLength;

                    ulong rhsValue = rhs._blocks[0];
                    ulong carry = 0;

                    for (int i = quoLength - 1; i >= 0; i--)
                    {
                        ulong value = (carry << 32) | lhs._blocks[i];
                        ulong digit = MathEx.DivRem(value, rhsValue, out carry);

                        if ((digit == 0) && (i == (quoLength - 1)))
                        {
                            quoLength--;
                        }
                        else
                        {
                            quo._blocks[i] = (uint)(digit);
                        }
                    }

                    quo._length = quoLength;
                    SetUInt32(out rem, (uint)(carry));

                    return;
                }
                else if (rhsLength > lhsLength)
                {
                    // Handle the case where we have no quotient
                    SetZero(out quo);
                    SetValue(out rem, ref lhs);
                    return;
                }
                else
                {
                    int quoLength = lhsLength - rhsLength + 1;
                    SetValue(out rem, ref lhs);
                    int remLength = lhsLength;

                    // Executes the "grammar-school" algorithm for computing q = a / b.
                    // Before calculating q_i, we get more bits into the highest bit
                    // block of the divisor. Thus, guessing digits of the quotient
                    // will be more precise. Additionally we'll get r = a % b.

                    uint divHi = rhs._blocks[rhsLength - 1];
                    uint divLo = rhs._blocks[rhsLength - 2];

                    // We measure the leading zeros of the divisor
                    int shiftLeft = BitOperations.LeadingZeroCount(divHi);
                    int shiftRight = 32 - shiftLeft;

                    // And, we make sure the most significant bit is set
                    if (shiftLeft > 0)
                    {
                        divHi = (divHi << shiftLeft) | (divLo >> shiftRight);
                        divLo <<= shiftLeft;

                        if (rhsLength > 2)
                        {
                            divLo |= (rhs._blocks[rhsLength - 3] >> shiftRight);
                        }
                    }

                    // Then, we divide all of the bits as we would do it using
                    // pen and paper: guessing the next digit, subtracting, ...
                    for (int i = lhsLength; i >= rhsLength; i--)
                    {
                        int n = i - rhsLength;
                        uint t = i < lhsLength ? rem._blocks[i] : 0;

                        ulong valHi = ((ulong)(t) << 32) | rem._blocks[i - 1];
                        uint valLo = i > 1 ? rem._blocks[i - 2] : 0;

                        // We shifted the divisor, we shift the dividend too
                        if (shiftLeft > 0)
                        {
                            valHi = (valHi << shiftLeft) | (valLo >> shiftRight);
                            valLo <<= shiftLeft;

                            if (i > 2)
                            {
                                valLo |= (rem._blocks[i - 3] >> shiftRight);
                            }
                        }

                        // First guess for the current digit of the quotient,
                        // which naturally must have only 32 bits...
                        ulong digit = valHi / divHi;

                        if (digit > uint.MaxValue)
                        {
                            digit = uint.MaxValue;
                        }

                        // Our first guess may be a little bit to big
                        while (DivideGuessTooBig(digit, valHi, valLo, divHi, divLo))
                        {
                            digit--;
                        }

                        if (digit > 0)
                        {
                            // Now it's time to subtract our current quotient
                            uint carry = SubtractDivisor(ref rem, n, ref rhs, digit);

                            if (carry != t)
                            {
                                Debug.Assert(carry == t + 1);

                                // Our guess was still exactly one too high
                                carry = AddDivisor(ref rem, n, ref rhs);
                                digit--;

                                Debug.Assert(carry == 1);
                            }
                        }

                        // We have the digit!
                        if (quoLength != 0)
                        {
                            if ((digit == 0) && (n == (quoLength - 1)))
                            {
                                quoLength--;
                            }
                            else
                            {
                                quo._blocks[n] = (uint)(digit);
                            }
                        }

                        if (i < remLength)
                        {
                            remLength--;
                        }
                    }

                    quo._length = quoLength;

                    // We need to check for the case where remainder is zero

                    for (int i = remLength - 1; i >= 0; i--)
                    {
                        if (rem._blocks[i] == 0)
                        {
                            remLength--;
                        }
                    }

                    rem._length = remLength;
                }
            }

            public static uint HeuristicDivide(ref BigInteger dividend, ref BigInteger divisor)
            {
                int divisorLength = divisor._length;

                if (dividend._length < divisorLength)
                {
                    return 0;
                }

                // This is an estimated quotient. Its error should be less than 2.
                // Reference inequality:
                // a/b - floor(floor(a)/(floor(b) + 1)) < 2
                int lastIndex = (divisorLength - 1);
                uint quotient = dividend._blocks[lastIndex] / (divisor._blocks[lastIndex] + 1);

                if (quotient != 0)
                {
                    // Now we use our estimated quotient to update each block of dividend.
                    // dividend = dividend - divisor * quotient
                    int index = 0;

                    ulong borrow = 0;
                    ulong carry = 0;

                    do
                    {
                        ulong product = ((ulong)(divisor._blocks[index]) * quotient) + carry;
                        carry = product >> 32;

                        ulong difference = (ulong)(dividend._blocks[index]) - (uint)(product) - borrow;
                        borrow = (difference >> 32) & 1;

                        dividend._blocks[index] = (uint)(difference);

                        index++;
                    }
                    while (index < divisorLength);

                    // Remove all leading zero blocks from dividend
                    while ((divisorLength > 0) && (dividend._blocks[divisorLength - 1] == 0))
                    {
                        divisorLength--;
                    }

                    dividend._length = divisorLength;
                }

                // If the dividend is still larger than the divisor, we overshot our estimate quotient. To correct,
                // we increment the quotient and subtract one more divisor from the dividend (Because we guaranteed the error range).
                if (Compare(ref dividend, ref divisor) >= 0)
                {
                    quotient++;

                    // dividend = dividend - divisor
                    int index = 0;
                    ulong borrow = 0;

                    do
                    {
                        ulong difference = (ulong)(dividend._blocks[index]) - divisor._blocks[index] - borrow;
                        borrow = (difference >> 32) & 1;

                        dividend._blocks[index] = (uint)(difference);

                        index++;
                    }
                    while (index < divisorLength);

                    // Remove all leading zero blocks from dividend
                    while ((divisorLength > 0) && (dividend._blocks[divisorLength - 1] == 0))
                    {
                        divisorLength--;
                    }

                    dividend._length = divisorLength;
                }

                return quotient;
            }

            public static void Multiply(ref BigInteger lhs, uint value, out BigInteger result)
            {
                if (lhs.IsZero() || (value == 1))
                {
                    SetValue(out result, ref lhs);
                    return;
                }

                if (value == 0)
                {
                    SetZero(out result);
                    return;
                }

                int lhsLength = lhs._length;
                int index = 0;
                uint carry = 0;

                while (index < lhsLength)
                {
                    ulong product = ((ulong)(lhs._blocks[index]) * value) + carry;
                    result._blocks[index] = (uint)(product);
                    carry = (uint)(product >> 32);

                    index++;
                }

                if (carry != 0)
                {
                    Debug.Assert(unchecked((uint)(lhsLength)) + 1 <= MaxBlockCount);
                    result._blocks[index] = carry;
                    result._length = (lhsLength + 1);
                }
                else
                {
                    result._length = lhsLength;
                }
            }

            public static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
            {
                if (lhs.IsZero() || rhs.IsOne())
                {
                    SetValue(out result, ref lhs);
                    return;
                }

                if (rhs.IsZero())
                {
                    SetZero(out result);
                    return;
                }

                ref readonly BigInteger large = ref lhs;
                int largeLength = lhs._length;

                ref readonly BigInteger small = ref rhs;
                int smallLength = rhs._length;

                if (largeLength < smallLength)
                {
                    large = ref rhs;
                    largeLength = rhs._length;

                    small = ref lhs;
                    smallLength = lhs._length;
                }

                int maxResultLength = smallLength + largeLength;
                Debug.Assert(unchecked((uint)(maxResultLength)) <= MaxBlockCount);

                // Zero out result internal blocks.
                result._length = maxResultLength;
                BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), (uint)maxResultLength * sizeof(uint));

                int smallIndex = 0;
                int resultStartIndex = 0;

                while (smallIndex < smallLength)
                {
                    // Multiply each block of large BigNum.
                    if (small._blocks[smallIndex] != 0)
                    {
                        int largeIndex = 0;
                        int resultIndex = resultStartIndex;

                        ulong carry = 0;

                        do
                        {
                            ulong product = result._blocks[resultIndex] + ((ulong)(small._blocks[smallIndex]) * large._blocks[largeIndex]) + carry;
                            carry = product >> 32;
                            result._blocks[resultIndex] = (uint)(product);

                            resultIndex++;
                            largeIndex++;
                        }
                        while (largeIndex < largeLength);

                        result._blocks[resultIndex] = (uint)(carry);
                    }

                    smallIndex++;
                    resultStartIndex++;
                }

                if ((maxResultLength > 0) && (result._blocks[maxResultLength - 1] == 0))
                {
                    result._length--;
                }
            }

            public static void Pow2(uint exponent, out BigInteger result)
            {
                uint blocksToShift = DivRem32(exponent, out uint remainingBitsToShift);
                result._length = (int)blocksToShift + 1;
                Debug.Assert(unchecked((uint)result._length) <= MaxBlockCount);
                if (blocksToShift > 0)
                {
                    BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), blocksToShift * sizeof(uint));
                }
                result._blocks[blocksToShift] = 1U << (int)(remainingBitsToShift);
            }

            public static void Pow10(uint exponent, out BigInteger result)
            {
                // We leverage two arrays - s_Pow10UInt32Table and s_Pow10BigNumTable to speed up the Pow10 calculation.
                //
                // s_Pow10UInt32Table stores the results of 10^0 to 10^7.
                // s_Pow10BigNumTable stores the results of 10^8, 10^16, 10^32, 10^64, 10^128, 10^256, and 10^512
                //
                // For example, let's say exp = 0b111111. We can split the exp to two parts, one is small exp,
                // which 10^smallExp can be represented as uint, another part is 10^bigExp, which must be represented as BigNum.
                // So the result should be 10^smallExp * 10^bigExp.
                //
                // Calculating 10^smallExp is simple, we just lookup the 10^smallExp from s_Pow10UInt32Table.
                // But here's a bad news: although uint can represent 10^9, exp 9's binary representation is 1001.
                // That means 10^(1011), 10^(1101), 10^(1111) all cannot be stored as uint, we cannot easily say something like:
                // "Any bits <= 3 is small exp, any bits > 3 is big exp". So instead of involving 10^8, 10^9 to s_Pow10UInt32Table,
                // consider 10^8 and 10^9 as a bigNum, so they fall into s_Pow10BigNumTable. Now we can have a simple rule:
                // "Any bits <= 3 is small exp, any bits > 3 is big exp".
                //
                // For 0b111111, we first calculate 10^(smallExp), which is 10^(7), now we can shift right 3 bits, prepare to calculate the bigExp part,
                // the exp now becomes 0b000111.
                //
                // Apparently the lowest bit of bigExp should represent 10^8 because we have already shifted 3 bits for smallExp, so s_Pow10BigNumTable[0] = 10^8.
                // Now let's shift exp right 1 bit, the lowest bit should represent 10^(8 * 2) = 10^16, and so on...
                //
                // That's why we just need the values of s_Pow10BigNumTable be power of 2.
                //
                // More details of this implementation can be found at: https://github.com/dotnet/coreclr/pull/12894#discussion_r128890596

                // Validate that `s_Pow10BigNumTable` has exactly enough trailing elements to fill a BigInteger (which contains MaxBlockCount + 1 elements)
                // We validate here, since this is the only current consumer of the array
                Debug.Assert((s_Pow10BigNumTableIndices[s_Pow10BigNumTableIndices.Length - 1] + MaxBlockCount + 2) == s_Pow10BigNumTable.Length);

                SetUInt32(out BigInteger temp1, s_Pow10UInt32Table[exponent & 0x7]);
                ref BigInteger lhs = ref temp1;

                SetZero(out BigInteger temp2);
                ref BigInteger product = ref temp2;

                exponent >>= 3;
                uint index = 0;

                while (exponent != 0)
                {
                    // If the current bit is set, multiply it with the corresponding power of 10
                    if ((exponent & 1) != 0)
                    {
                        // Multiply into the next temporary
                        fixed (uint* pBigNumEntry = &s_Pow10BigNumTable[s_Pow10BigNumTableIndices[index]])
                        {
                            ref BigInteger rhs = ref *(BigInteger*)(pBigNumEntry);
                            Multiply(ref lhs, ref rhs, out product);
                        }

                        // Swap to the next temporary
                        ref BigInteger temp = ref product;
                        product = ref lhs;
                        lhs = ref temp;
                    }

                    // Advance to the next bit
                    ++index;
                    exponent >>= 1;
                }

                SetValue(out result, ref lhs);
            }

            private static uint AddDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs)
            {
                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                Debug.Assert(lhsLength >= 0);
                Debug.Assert(rhsLength >= 0);
                Debug.Assert(lhsLength >= rhsLength);

                // Repairs the dividend, if the last subtract was too much

                ulong carry = 0UL;

                for (int i = 0; i < rhsLength; i++)
                {
                    ref uint lhsValue = ref lhs._blocks[lhsStartIndex + i];

                    ulong digit = lhsValue + carry + rhs._blocks[i];
                    lhsValue = unchecked((uint)digit);
                    carry = digit >> 32;
                }

                return (uint)(carry);
            }

            private static bool DivideGuessTooBig(ulong q, ulong valHi, uint valLo, uint divHi, uint divLo)
            {
                Debug.Assert(q <= 0xFFFFFFFF);

                // We multiply the two most significant limbs of the divisor
                // with the current guess for the quotient. If those are bigger
                // than the three most significant limbs of the current dividend
                // we return true, which means the current guess is still too big.

                ulong chkHi = divHi * q;
                ulong chkLo = divLo * q;

                chkHi += (chkLo >> 32);
                chkLo &= uint.MaxValue;

                if (chkHi < valHi)
                    return false;

                if (chkHi > valHi)
                    return true;

                if (chkLo < valLo)
                    return false;

                if (chkLo > valLo)
                    return true;

                return false;
            }

            private static uint SubtractDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs, ulong q)
            {
                int lhsLength = lhs._length - lhsStartIndex;
                int rhsLength = rhs._length;

                Debug.Assert(lhsLength >= 0);
                Debug.Assert(rhsLength >= 0);
                Debug.Assert(lhsLength >= rhsLength);
                Debug.Assert(q <= uint.MaxValue);

                // Combines a subtract and a multiply operation, which is naturally
                // more efficient than multiplying and then subtracting...

                ulong carry = 0;

                for (int i = 0; i < rhsLength; i++)
                {
                    carry += rhs._blocks[i] * q;
                    uint digit = unchecked((uint)carry);
                    carry >>= 32;

                    ref uint lhsValue = ref lhs._blocks[lhsStartIndex + i];

                    if (lhsValue < digit)
                    {
                        carry++;
                    }

                    lhsValue = unchecked(lhsValue - digit);
                }

                return (uint)(carry);
            }

            public void Add(uint value)
            {
                int length = _length;
                if (length == 0)
                {
                    SetUInt32(out this, value);
                    return;
                }

                _blocks[0] += value;
                if (_blocks[0] >= value)
                {
                    // No carry
                    return;
                }

                for (int index = 1; index < length; index++)
                {
                    _blocks[index]++;
                    if (_blocks[index] > 0)
                    {
                        // No carry
                        return;
                    }
                }

                Debug.Assert(unchecked((uint)(length)) + 1 <= MaxBlockCount);
                _blocks[length] = 1;
                _length = length + 1;
            }

            public uint GetBlock(uint index)
            {
                Debug.Assert(index < _length);
                return _blocks[index];
            }

            public int GetLength()
            {
                return _length;
            }

            public bool IsOne()
            {
                return (_length == 1)
                    && (_blocks[0] == 1);
            }

            public bool IsZero()
            {
                return _length == 0;
            }

            public void Multiply(uint value)
            {
                Multiply(ref this, value, out this);
            }

            public void Multiply(ref BigInteger value)
            {
                SetValue(out BigInteger temp, ref this);
                Multiply(ref temp, ref value, out this);
            }

            public void Multiply10()
            {
                if (IsZero())
                {
                    return;
                }

                int index = 0;
                int length = _length;
                ulong carry = 0;

                while (index < length)
                {
                    ulong block = (ulong)(_blocks[index]);
                    ulong product = (block << 3) + (block << 1) + carry;
                    carry = product >> 32;
                    _blocks[index] = (uint)(product);

                    index++;
                }

                if (carry != 0)
                {
                    Debug.Assert(unchecked((uint)(_length)) + 1 <= MaxBlockCount);
                    _blocks[index] = (uint)carry;
                    _length++;
                }
            }

            public void MultiplyPow10(uint exponent)
            {
                if (IsZero())
                {
                    return;
                }

                Pow10(exponent, out BigInteger poweredValue);

                if (poweredValue._length == 1)
                {
                    Multiply(poweredValue._blocks[0]);
                }
                else
                {
                    Multiply(ref poweredValue);
                }
            }

            public static void SetUInt32(out BigInteger result, uint value)
            {
                if (value == 0)
                {
                    SetZero(out result);
                }
                else
                {
                    result._blocks[0] = value;
                    result._length = 1;
                }
            }

            public static void SetUInt64(out BigInteger result, ulong value)
            {
                if (value <= uint.MaxValue)
                {
                    SetUInt32(out result, (uint)(value));
                }
                else
                {
                    result._blocks[0] = (uint)(value);
                    result._blocks[1] = (uint)(value >> 32);

                    result._length = 2;
                }
            }

            public static void SetValue(out BigInteger result, ref BigInteger value)
            {
                int rhsLength = value._length;
                result._length = rhsLength;
                BufferEx.Memcpy((byte*)result.GetBlocksPointer(), (byte*)value.GetBlocksPointer(), rhsLength * sizeof(uint));
            }

            public static void SetZero(out BigInteger result)
            {
                result._length = 0;
            }

            public void ShiftLeft(uint shift)
            {
                // Process blocks high to low so that we can safely process in place
                int length = _length;

                if ((length == 0) || (shift == 0))
                {
                    return;
                }

                uint blocksToShift = DivRem32(shift, out uint remainingBitsToShift);

                // Copy blocks from high to low
                int readIndex = (length - 1);
                int writeIndex = readIndex + (int)(blocksToShift);

                // Check if the shift is block aligned
                if (remainingBitsToShift == 0)
                {
                    Debug.Assert(writeIndex < MaxBlockCount);

                    while (readIndex >= 0)
                    {
                        _blocks[writeIndex] = _blocks[readIndex];
                        readIndex--;
                        writeIndex--;
                    }

                    _length += (int)(blocksToShift);

                    // Zero the remaining low blocks
                    BufferEx.ZeroMemory((byte*)GetBlocksPointer(), blocksToShift * sizeof(uint));
                }
                else
                {
                    // We need an extra block for the partial shift
                    writeIndex++;
                    Debug.Assert(writeIndex < MaxBlockCount);

                    // Set the length to hold the shifted blocks
                    _length = writeIndex + 1;

                    // Output the initial blocks
                    uint lowBitsShift = (32 - remainingBitsToShift);
                    uint highBits = 0;
                    uint block = _blocks[readIndex];
                    uint lowBits = block >> (int)(lowBitsShift);
                    while (readIndex > 0)
                    {
                        _blocks[writeIndex] = highBits | lowBits;
                        highBits = block << (int)(remainingBitsToShift);

                        --readIndex;
                        --writeIndex;

                        block = _blocks[readIndex];
                        lowBits = block >> (int)lowBitsShift;
                    }

                    // Output the final blocks
                    _blocks[writeIndex] = highBits | lowBits;
                    _blocks[writeIndex - 1] = block << (int)(remainingBitsToShift);

                    // Zero the remaining low blocks
                    BufferEx.ZeroMemory((byte*)GetBlocksPointer(), blocksToShift * sizeof(uint));

                    // Check if the terminating block has no set bits
                    if (_blocks[_length - 1] == 0)
                    {
                        _length--;
                    }
                }
            }

            public ulong ToUInt64()
            {
                if (_length > 1)
                {
                    return ((ulong)(_blocks[1]) << 32) + _blocks[0];
                }

                if (_length > 0)
                {
                    return _blocks[0];
                }

                return 0;
            }

            private uint* GetBlocksPointer()
            {
                // This is safe to do since we are a ref struct
                return (uint*)(Unsafe.AsPointer(ref _blocks[0]));
            }

            private static uint DivRem32(uint value, out uint remainder)
            {
                remainder = value & 31;
                return value >> 5;
            }
        }
    }
}


================================================
FILE: src/ZString/Number/Number.DiyFp.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;

namespace System
{
    internal static partial class Number
    {
        // This is a port of the `DiyFp` implementation here: https://github.com/google/double-conversion/blob/a711666ddd063eb1e4b181a6cb981d39a1fc8bac/double-conversion/diy-fp.h
        // The backing structure and how it is used is described in more detail here: http://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf

        // This "Do It Yourself Floating Point" class implements a floating-point number with a ulong significand and an int exponent.
        // Normalized DiyFp numbers will have the most significant bit of the significand set.
        // Multiplication and Subtraction do not normalize their results.
        // DiyFp are not designed to contain special doubles (NaN and Infinity).
        internal readonly ref struct DiyFp
        {
            public const int DoubleImplicitBitIndex = 52;
            public const int SingleImplicitBitIndex = 23;

            public const int SignificandSize = 64;

            public readonly ulong f;
            public readonly int e;

            // Computes the two boundaries of value.
            //
            // The bigger boundary (mPlus) is normalized.
            // The lower boundary has the same exponent as mPlus.
            //
            // Precondition:
            //  The value encoded by value must be greater than 0.
            public static DiyFp CreateAndGetBoundaries(double value, out DiyFp mMinus, out DiyFp mPlus)
            {
                var result = new DiyFp(value);
                result.GetBoundaries(DoubleImplicitBitIndex, out mMinus, out mPlus);
                return result;
            }

            // Computes the two boundaries of value.
            //
            // The bigger boundary (mPlus) is normalized.
            // The lower boundary has the same exponent as mPlus.
            //
            // Precondition:
            //  The value encoded by value must be greater than 0.
            public static DiyFp CreateAndGetBoundaries(float value, out DiyFp mMinus, out DiyFp mPlus)
            {
                var result = new DiyFp(value);
                result.GetBoundaries(SingleImplicitBitIndex, out mMinus, out mPlus);
                return result;
            }

            public DiyFp(double value)
            {
                //Debug.Assert(double.IsFinite(value));
                Debug.Assert(value > 0.0);
                f = ExtractFractionAndBiasedExponent(value, out e);
            }

            public DiyFp(float value)
            {
                //Debug.Assert(float.IsFinite(value));
                Debug.Assert(value > 0.0f);
                f = ExtractFractionAndBiasedExponent(value, out e);
            }

            public DiyFp(ulong f, int e)
            {
                this.f = f;
                this.e = e;
            }

            public DiyFp Multiply(in DiyFp other)
            {
                // Simply "emulates" a 128-bit multiplication
                //
                // However: the resulting number only contains 64-bits. The least
                // signficant 64-bits are only used for rounding the most significant
                // 64-bits.

                uint a = (uint)(f >> 32);
                uint b = (uint)(f);

                uint c = (uint)(other.f >> 32);
                uint d = (uint)(other.f);

                ulong ac = ((ulong)(a) * c);
                ulong bc = ((ulong)(b) * c);
                ulong ad = ((ulong)(a) * d);
                ulong bd = ((ulong)(b) * d);

                ulong tmp = (bd >> 32) + (uint)(ad) + (uint)(bc);

                // By adding (1UL << 31) to tmp, we round the final result.
                // Halfway cases will be rounded up.

                tmp += (1U << 31);

                return new DiyFp(ac + (ad >> 32) + (bc >> 32) + (tmp >> 32), e + other.e + SignificandSize);
            }

            public DiyFp Normalize()
            {
                // This method is mainly called for normalizing boundaries.
                //
                // We deviate from the reference implementation by just using
                // our LeadingZeroCount function so that we only need to shift
                // and subtract once.

                Debug.Assert(f != 0);
                int lzcnt = BitOperations.LeadingZeroCount(f);
                return new DiyFp(f << lzcnt, e - lzcnt);
            }

            // The exponents of both numbers must be the same.
            // The significand of 'this' must be bigger than the significand of 'other'.
            // The result will not be normalized.
            public DiyFp Subtract(in DiyFp other)
            {
                Debug.Assert(e == other.e);
                Debug.Assert(f >= other.f);
                return new DiyFp(f - other.f, e);
            }

            private void GetBoundaries(int implicitBitIndex, out DiyFp mMinus, out DiyFp mPlus)
            {
                mPlus = new DiyFp((f << 1) + 1, e - 1).Normalize();

                // The boundary is closer if the sigificand is of the form:
                //      f == 2^p-1
                //
                // Think of v = 1000e10 and v- = 9999e9
                // Then the boundary == (v - v-) / 2 is not just at a distance of 1e9 but at a distance of 1e8.
                // The only exception is for the smallest normal, where the largest denormal is at the same distance as its successor.
                //
                // Note: denormals have the same exponent as the smallest normals.

                // We deviate from the reference implementation by just checking if the significand has only the implicit bit set.
                // In this scenario, we know that all the explicit bits are 0 and that the unbiased exponent is non-zero.
                if (f == (1UL << implicitBitIndex))
                {
                    mMinus = new DiyFp((f << 2) - 1, e - 2);
                }
                else
                {
                    mMinus = new DiyFp((f << 1) - 1, e - 1);
                }

                mMinus = new DiyFp(mMinus.f << (mMinus.e - mPlus.e), mPlus.e);
            }
        }
    }
}


================================================
FILE: src/ZString/Number/Number.Dragon4.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace System
{
    // This is a port of the `Dragon4` implementation here: http://www.ryanjuckett.com/programming/printing-floating-point-numbers/part-2/
    // The backing algorithm and the proofs behind it are described in more detail here:  https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
    internal static partial class Number
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static unsafe bool IsNegative(double d)
        {
            return BitConverter.DoubleToInt64Bits(d) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegativeInfinity(float f)
        {
            return f == float.NegativeInfinity;
        }

        public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
        {
            double v = IsNegative(value) ? -value : value;

            Debug.Assert(v > 0);
            // Debug.Assert(double.IsFinite(v));

            ulong mantissa = ExtractFractionAndBiasedExponent(value, out int exponent);

            uint mantissaHighBitIdx;
            bool hasUnequalMargins = false;

            if ((mantissa >> DiyFp.DoubleImplicitBitIndex) != 0)
            {
                mantissaHighBitIdx = DiyFp.DoubleImplicitBitIndex;
                hasUnequalMargins = (mantissa == (1UL << DiyFp.DoubleImplicitBitIndex));
            }
            else
            {
                Debug.Assert(mantissa != 0);
                mantissaHighBitIdx = (uint)BitOperations.Log2(mantissa);
            }

            int length = (int)(Dragon4(mantissa, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out int decimalExponent));

            number.Scale = decimalExponent + 1;
            number.Digits[length] = (byte)('\0');
            number.DigitsCount = length;
        }

        public static unsafe void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
        {
            float v = IsNegative(value) ? -value : value;

            Debug.Assert(v > 0);
            // Debug.Assert(float.IsFinite(v));

            uint mantissa = ExtractFractionAndBiasedExponent(value, out int exponent);

            uint mantissaHighBitIdx;
            bool hasUnequalMargins = false;

            if ((mantissa >> DiyFp.SingleImplicitBitIndex) != 0)
            {
                mantissaHighBitIdx = DiyFp.SingleImplicitBitIndex;
                hasUnequalMargins = (mantissa == (1U << DiyFp.SingleImplicitBitIndex));
            }
            else
            {
                Debug.Assert(mantissa != 0);
                mantissaHighBitIdx = (uint)BitOperations.Log2(mantissa);
            }

            int length = (int)(Dragon4(mantissa, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out int decimalExponent));

            number.Scale = decimalExponent + 1;
            number.Digits[length] = (byte)('\0');
            number.DigitsCount = length;
        }

        // This is an implementation of the Dragon4 algorithm to convert a binary number in floating-point format to a decimal number in string format.
        // The function returns the number of digits written to the output buffer and the output is not NUL terminated.
        //
        // The floating point input value is (mantissa * 2^exponent).
        //
        // See the following papers for more information on the algorithm:
        //  "How to Print Floating-Point Numbers Accurately"
        //    Steele and White
        //    http://kurtstephens.com/files/p372-steele.pdf
        //  "Printing Floating-Point Numbers Quickly and Accurately"
        //    Burger and Dybvig
        //    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf
        private static unsafe uint Dragon4(ulong mantissa, int exponent, uint mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Span<byte> buffer, out int decimalExponent)
        {
            int curDigit = 0;

            Debug.Assert(buffer.Length > 0);

            // We deviate from the original algorithm and just assert that the mantissa
            // is not zero. Comparing to zero is fine since the caller should have set
            // the implicit bit of the mantissa, meaning it would only ever be zero if
            // the extracted exponent was also zero. And the assertion is fine since we
            // require that the DoubleToNumber handle zero itself.
            Debug.Assert(mantissa != 0);

            // Compute the initial state in integral form such that
            //      value     = scaledValue / scale
            //      marginLow = scaledMarginLow / scale

            BigInteger scale;           // positive scale applied to value and margin such that they can be represented as whole numbers
            BigInteger scaledValue;     // scale * mantissa
            BigInteger scaledMarginLow; // scale * 0.5 * (distance between this floating-point number and its immediate lower value)

            // For normalized IEEE floating-point values, each time the exponent is incremented the margin also doubles.
            // That creates a subset of transition numbers where the high margin is twice the size of the low margin.
            BigInteger* pScaledMarginHigh;
            BigInteger optionalMarginHigh;

            if (hasUnequalMargins)
            {
                if (exponent > 0)   // We have no fractional component
                {
                    // 1) Expand the input value by multiplying out the mantissa and exponent.
                    //    This represents the input value in its whole number representation.
                    // 2) Apply an additional scale of 2 such that later comparisons against the margin values are simplified.
                    // 3) Set the margin value to the loweset mantissa bit's scale.

                    // scaledValue      = 2 * 2 * mantissa * 2^exponent
                    BigInteger.SetUInt64(out scaledValue, 4 * mantissa);
                    scaledValue.ShiftLeft((uint)(exponent));

                    // scale            = 2 * 2 * 1
                    BigInteger.SetUInt32(out scale, 4);

                    // scaledMarginLow  = 2 * 2^(exponent - 1)
                    BigInteger.Pow2((uint)(exponent), out scaledMarginLow);

                    // scaledMarginHigh = 2 * 2 * 2^(exponent + 1)
                    BigInteger.Pow2((uint)(exponent + 1), out optionalMarginHigh);
                }
                else                // We have a fractional exponent
                {
                    // In order to track the mantissa data as an integer, we store it as is with a large scale

                    // scaledValue      = 2 * 2 * mantissa
                    BigInteger.SetUInt64(out scaledValue, 4 * mantissa);

                    // scale            = 2 * 2 * 2^(-exponent)
                    BigInteger.Pow2((uint)(-exponent + 2), out scale);

                    // scaledMarginLow  = 2 * 2^(-1)
                    BigInteger.SetUInt32(out scaledMarginLow, 1);

                    // scaledMarginHigh = 2 * 2 * 2^(-1)
                    BigInteger.SetUInt32(out optionalMarginHigh, 2);
                }

                // The high and low margins are different
                pScaledMarginHigh = &optionalMarginHigh;
            }
            else
            {
                if (exponent > 0)   // We have no fractional component
                {
                    // 1) Expand the input value by multiplying out the mantissa and exponent.
                    //    This represents the input value in its whole number representation.
                    // 2) Apply an additional scale of 2 such that later comparisons against the margin values are simplified.
                    // 3) Set the margin value to the lowest mantissa bit's scale.

                    // scaledValue     = 2 * mantissa*2^exponent
                    BigInteger.SetUInt64(out scaledValue, 2 * mantissa);
                    scaledValue.ShiftLeft((uint)(exponent));

                    // scale           = 2 * 1
                    BigInteger.SetUInt32(out scale, 2);

                    // scaledMarginLow = 2 * 2^(exponent-1)
                    BigInteger.Pow2((uint)(exponent), out scaledMarginLow);
                }
                else                // We have a fractional exponent
                {
                    // In order to track the mantissa data as an integer, we store it as is with a large scale

                    // scaledValue     = 2 * mantissa
                    BigInteger.SetUInt64(out scaledValue, 2 * mantissa);

                    // scale           = 2 * 2^(-exponent)
                    BigInteger.Pow2((uint)(-exponent + 1), out scale);

                    // scaledMarginLow = 2 * 2^(-1)
                    BigInteger.SetUInt32(out scaledMarginLow, 1);
                }

                // The high and low margins are equal
                pScaledMarginHigh = &scaledMarginLow;
            }

            // Compute an estimate for digitExponent that will be correct or undershoot by one.
            //
            // This optimization is based on the paper "Printing Floating-Point Numbers Quickly and Accurately" by Burger and Dybvig http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf
            //
            // We perform an additional subtraction of 0.69 to increase the frequency of a failed estimate because that lets us take a faster branch in the code.
            // 0.69 is chosen because 0.69 + log10(2) is less than one by a reasonable epsilon that will account for any floating point error.
            //
            // We want to set digitExponent to floor(log10(v)) + 1
            //      v = mantissa * 2^exponent
            //      log2(v) = log2(mantissa) + exponent;
            //      log10(v) = log2(v) * log10(2)
            //      floor(log2(v)) = mantissaHighBitIdx + exponent;
            //      log10(v) - log10(2) < (mantissaHighBitIdx + exponent) * log10(2) <= log10(v)
            //      log10(v) < (mantissaHighBitIdx + exponent) * log10(2) + log10(2) <= log10(v) + log10(2)
            //      floor(log10(v)) < ceil((mantissaHighBitIdx + exponent) * log10(2)) <= floor(log10(v)) + 1
            const double Log10V2 = 0.30102999566398119521373889472449;
            int digitExponent = (int)(Math.Ceiling(((int)(mantissaHighBitIdx) + exponent) * Log10V2 - 0.69));

            // Divide value by 10^digitExponent.
            if (digitExponent > 0)
            {
                // The exponent is positive creating a division so we multiply up the scale.
                scale.MultiplyPow10((uint)(digitExponent));
            }
            else if (digitExponent < 0)
            {
                // The exponent is negative creating a multiplication so we multiply up the scaledValue, scaledMarginLow and scaledMarginHigh.

                BigInteger.Pow10((uint)(-digitExponent), out BigInteger pow10);

                scaledValue.Multiply(ref pow10);
                scaledMarginLow.Multiply(ref pow10);

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            bool isEven = (mantissa % 2) == 0;
            bool estimateTooLow = false;

            if (cutoffNumber == -1)
            {
                // When printing the shortest possible string, we want to
                // take IEEE unbiased rounding into account so we can return
                // shorter strings for various edge case values like 1.23E+22

                BigInteger.Add(ref scaledValue, ref *pScaledMarginHigh, out BigInteger scaledValueHigh);
                int cmpHigh = BigInteger.Compare(ref scaledValueHigh, ref scale);
                estimateTooLow = isEven ? (cmpHigh >= 0) : (cmpHigh > 0);
            }
            else
            {
                estimateTooLow = BigInteger.Compare(ref scaledValue, ref scale) >= 0;
            }

            // Was our estimate for digitExponent was too low?
            if (estimateTooLow)
            {
                // The exponent estimate was incorrect.
                // Increment the exponent and don't perform the premultiply needed for the first loop iteration.
                digitExponent++;
            }
            else
            {
                // The exponent estimate was correct.
                // Multiply larger by the output base to prepare for the first loop iteration.
                scaledValue.Multiply10();
                scaledMarginLow.Multiply10();

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            // Compute the cutoff exponent (the exponent of the final digit to print).
            // Default to the maximum size of the output buffer.
            int cutoffExponent = digitExponent - buffer.Length;

            if (cutoffNumber != -1)
            {
                int desiredCutoffExponent = 0;

                if (isSignificantDigits)
                {
                    // We asked for a specific number of significant digits.
                    Debug.Assert(cutoffNumber > 0);
                    desiredCutoffExponent = digitExponent - cutoffNumber;
                }
                else
                {
                    // We asked for a specific number of fractional digits.
                    Debug.Assert(cutoffNumber >= 0);
                    desiredCutoffExponent = -cutoffNumber;
                }

                if (desiredCutoffExponent > cutoffExponent)
                {
                    // Only select the new cutoffExponent if it won't overflow the destination buffer.
                    cutoffExponent = desiredCutoffExponent;
                }
            }

            // Output the exponent of the first digit we will print
            decimalExponent = --digitExponent;

            // In preparation for calling BigInteger.HeuristicDivie(), we need to scale up our values such that the highest block of the denominator is greater than or equal to 8.
            // We also need to guarantee that the numerator can never have a length greater than the denominator after each loop iteration.
            // This requires the highest block of the denominator to be less than or equal to 429496729 which is the highest number that can be multiplied by 10 without overflowing to a new block.

            Debug.Assert(scale.GetLength() > 0);
            uint hiBlock = scale.GetBlock((uint)(scale.GetLength() - 1));

            if ((hiBlock < 8) || (hiBlock > 429496729))
            {
                // Perform a bit shift on all values to get the highest block of the denominator into the range [8,429496729].
                // We are more likely to make accurate quotient estimations in BigInteger.HeuristicDivide() with higher denominator values so we shift the denominator to place the highest bit at index 27 of the highest block.
                // This is safe because (2^28 - 1) = 268435455 which is less than 429496729.
                // This means that all values with a highest bit at index 27 are within range.
                Debug.Assert(hiBlock != 0);
                uint hiBlockLog2 = (uint)BitOperations.Log2(hiBlock);
                Debug.Assert((hiBlockLog2 < 3) || (hiBlockLog2 > 27));
                uint shift = (32 + 27 - hiBlockLog2) % 32;

                scale.ShiftLeft(shift);
                scaledValue.ShiftLeft(shift);
                scaledMarginLow.ShiftLeft(shift);

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            // These values are used to inspect why the print loop terminated so we can properly round the final digit.
            bool low;            // did the value get within marginLow distance from zero
            bool high;           // did the value get within marginHigh distance from one
            uint outputDigit;    // current digit being output

            if (cutoffNumber == -1)
            {
                Debug.Assert(isSignificantDigits);
                Debug.Assert(digitExponent >= cutoffExponent);

                // For the unique cutoff mode, we will try to print until we have reached a level of precision that uniquely distinguishes this value from its neighbors.
                // If we run out of space in the output buffer, we terminate early.

                while (true)
                {
                    // divide out the scale to extract the digit
                    outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                    Debug.Assert(outputDigit < 10);

                    // update the high end of the value
                    BigInteger.Add(ref scaledValue, ref *pScaledMarginHigh, out BigInteger scaledValueHigh);

                    // stop looping if we are far enough away from our neighboring values or if we have reached the cutoff digit
                    int cmpLow = BigInteger.Compare(ref scaledValue, ref scaledMarginLow);
                    int cmpHigh = BigInteger.Compare(ref scaledValueHigh, ref scale);

                    if (isEven)
                    {
                        low = (cmpLow <= 0);
                        high = (cmpHigh >= 0);
                    }
                    else
                    {
                        low = (cmpLow < 0);
                        high = (cmpHigh > 0);
                    }

                    if (low || high || (digitExponent == cutoffExponent))
                    {
                        break;
                    }

                    // store the output digit
                    buffer[curDigit] = (byte)('0' + outputDigit);
                    curDigit++;

                    // multiply larger by the output base
                    scaledValue.Multiply10();
                    scaledMarginLow.Multiply10();

                    if (pScaledMarginHigh != &scaledMarginLow)
                    {
                        BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                    }

                    digitExponent--;
                }
            }
            else if (digitExponent >= cutoffExponent)
            {
                Debug.Assert((cutoffNumber > 0) || ((cutoffNumber == 0) && !isSignificantDigits));

                // For length based cutoff modes, we will try to print until we have exhausted all precision (i.e. all remaining digits are zeros) or until we reach the desired cutoff digit.
                low = false;
                high = false;

                while (true)
                {
                    // divide out the scale to extract the digit
                    outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                    Debug.Assert(outputDigit < 10);

                    if (scaledValue.IsZero() || (digitExponent <= cutoffExponent))
                    {
                        break;
                    }

                    // store the output digit
                    buffer[curDigit] = (byte)('0' + outputDigit);
                    curDigit++;

                    // multiply larger by the output base
                    scaledValue.Multiply10();
                    digitExponent--;
                }
            }
            else
            {
                // In the scenario where the first significant digit is after the cutoff, we want to treat that
                // first significant digit as the rounding digit. If the first significant would cause the next
                // digit to round, we will increase the decimalExponent by one and set the previous digit to one.
                // This  ensures we correctly handle the case where the first significant digit is exactly one after
                // the cutoff, it is a 4, and the subsequent digit would round that to 5 inducing a double rounding
                // bug when NumberToString does its own rounding checks. However, if the first significant digit
                // would not cause the next one to round, we preserve that digit as is.

                // divide out the scale to extract the digit
                outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                Debug.Assert((0 < outputDigit) && (outputDigit < 10));

                if ((outputDigit > 5) || ((outputDigit == 5) && !scaledValue.IsZero()))
                {
                    decimalExponent++;
                    outputDigit = 1;
                }

                buffer[curDigit] = (byte)('0' + outputDigit);
                curDigit++;

                // return the number of digits output
                return (uint)curDigit;
            }

            // round off the final digit
            // default to rounding down if value got too close to 0
            bool roundDown = low;

            if (low == high)    // is it legal to round up and down
            {
                // round to the closest digit by comparing value with 0.5.
                //
                // To do this we need to convert the inequality to large integer values.
                //      compare(value, 0.5)
                //      compare(scale * value, scale * 0.5)
                //      compare(2 * scale * value, scale)
                scaledValue.ShiftLeft(1); // Multiply by 2
                int compare = BigInteger.Compare(ref scaledValue, ref scale);
                roundDown = compare < 0;

                // if we are directly in the middle, round towards the even digit (i.e. IEEE rouding rules)
                if (compare == 0)
                {
                    roundDown = (outputDigit & 1) == 0;
                }
            }

            // print the rounded digit
            if (roundDown)
            {
                buffer[curDigit] = (byte)('0' + outputDigit);
                curDigit++;
            }
            else if (outputDigit == 9)      // handle rounding up
            {
                // find the first non-nine prior digit
                while (true)
                {
                    // if we are at the first digit
                    if (curDigit == 0)
                    {
                        // output 1 at the next highest exponent

                        buffer[curDigit] = (byte)('1');
                        curDigit++;
                        decimalExponent++;

                        break;
                    }

                    curDigit--;

                    if (buffer[curDigit] != '9')
                    {
                        // increment the digit

                        buffer[curDigit]++;
                        curDigit++;

                        break;
                    }
                }
            }
            else
            {
                // values in the range [0,8] can perform a simple round up
                buffer[curDigit] = (byte)('0' + outputDigit + 1);
                curDigit++;
            }

            // return the number of digits output
            uint outputLen = (uint)curDigit;
            Debug.Assert(outputLen <= buffer.Length);
            return outputLen;
        }
    }
}


================================================
FILE: src/ZString/Number/Number.Grisu3.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace System
{
    internal static partial class Number
    {
        // This is a port of the `Grisu3` implementation here: https://github.com/google/double-conversion/blob/a711666ddd063eb1e4b181a6cb981d39a1fc8bac/double-conversion/fast-dtoa.cc
        // The backing algorithm and the proofs behind it are described in more detail here: http://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf
        // ========================================================================================================================================
        //
        // Overview:
        //
        // The general idea behind Grisu3 is to leverage additional bits and cached powers of ten to generate the correct digits.
        // The algorithm is imprecise for some numbers. Fortunately, the algorithm itself can determine this scenario and gives us
        // a result indicating success or failure. We must fallback to a different algorithm for the failing scenario.
        internal static class Grisu3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static unsafe bool IsNegative(double d)
            {
                return BitConverter.DoubleToInt64Bits(d) < 0;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static unsafe bool IsNegativeInfinity(float f)
            {
                return f == float.NegativeInfinity;
            }

            private const int CachedPowersDecimalExponentDistance = 8;
            private const int CachedPowersMinDecimalExponent = -348;
            private const int CachedPowersPowerMaxDecimalExponent = 340;
            private const int CachedPowersOffset = -CachedPowersMinDecimalExponent;

            // 1 / Log2(10)
            private const double D1Log210 = 0.301029995663981195;

            // The minimal and maximal target exponents define the range of w's binary exponent,
            // where w is the result of multiplying the input by a cached power of ten.
            //
            // A different range might be chosen on a different platform, to optimize digit generation,
            // but a smaller range requires more powers of ten to be cached.
            private const int MaximalTargetExponent = -32;
            private const int MinimalTargetExponent = -60;

            private static readonly short[] s_CachedPowersBinaryExponent = new short[]
            {
                -1220,
                -1193,
                -1166,
                -1140,
                -1113,
                -1087,
                -1060,
                -1034,
                -1007,
                -980,
                -954,
                -927,
                -901,
                -874,
                -847,
                -821,
                -794,
                -768,
                -741,
                -715,
                -688,
                -661,
                -635,
                -608,
                -582,
                -555,
                -529,
                -502,
                -475,
                -449,
                -422,
                -396,
                -369,
                -343,
                -316,
                -289,
                -263,
                -236,
                -210,
                -183,
                -157,
                -130,
                -103,
                -77,
                -50,
                -24,
                3,
                30,
                56,
                83,
                109,
                136,
                162,
                189,
                216,
                242,
                269,
                295,
                322,
                348,
                375,
                402,
                428,
                455,
                481,
                508,
                534,
                561,
                588,
                614,
                641,
                667,
                694,
                720,
                747,
                774,
                800,
                827,
                853,
                880,
                907,
                933,
                960,
                986,
                1013,
                1039,
                1066,
            };

            private static readonly short[] s_CachedPowersDecimalExponent = new short[]
            {
                CachedPowersMinDecimalExponent,
                -340,
                -332,
                -324,
                -316,
                -308,
                -300,
                -292,
                -284,
                -276,
                -268,
                -260,
                -252,
                -244,
                -236,
                -228,
                -220,
                -212,
                -204,
                -196,
                -188,
                -180,
                -172,
                -164,
                -156,
                -148,
                -140,
                -132,
                -124,
                -116,
                -108,
                -100,
                -92,
                -84,
                -76,
                -68,
                -60,
                -52,
                -44,
                -36,
                -28,
                -20,
                -12,
                -4,
                4,
                12,
                20,
                28,
                36,
                44,
                52,
                60,
                68,
                76,
                84,
                92,
                100,
                108,
                116,
                124,
                132,
                140,
                148,
                156,
                164,
                172,
                180,
                188,
                196,
                204,
                212,
                220,
                228,
                236,
                244,
                252,
                260,
                268,
                276,
                284,
                292,
                300,
                308,
                316,
                324,
                332,
                CachedPowersPowerMaxDecimalExponent,
            };

            private static readonly ulong[] s_CachedPowersSignificand = new ulong[]
            {
                0xFA8FD5A0081C0288,
                0xBAAEE17FA23EBF76,
                0x8B16FB203055AC76,
                0xCF42894A5DCE35EA,
                0x9A6BB0AA55653B2D,
                0xE61ACF033D1A45DF,
                0xAB70FE17C79AC6CA,
                0xFF77B1FCBEBCDC4F,
                0xBE5691EF416BD60C,
                0x8DD01FAD907FFC3C,
                0xD3515C2831559A83,
                0x9D71AC8FADA6C9B5,
                0xEA9C227723EE8BCB,
                0xAECC49914078536D,
                0x823C12795DB6CE57,
                0xC21094364DFB5637,
                0x9096EA6F3848984F,
                0xD77485CB25823AC7,
                0xA086CFCD97BF97F4,
                0xEF340A98172AACE5,
                0xB23867FB2A35B28E,
                0x84C8D4DFD2C63F3B,
                0xC5DD44271AD3CDBA,
                0x936B9FCEBB25C996,
                0xDBAC6C247D62A584,
                0xA3AB66580D5FDAF6,
                0xF3E2F893DEC3F126,
                0xB5B5ADA8AAFF80B8,
                0x87625F056C7C4A8B,
                0xC9BCFF6034C13053,
                0x964E858C91BA2655,
                0xDFF9772470297EBD,
                0xA6DFBD9FB8E5B88F,
                0xF8A95FCF88747D94,
                0xB94470938FA89BCF,
                0x8A08F0F8BF0F156B,
                0xCDB02555653131B6,
                0x993FE2C6D07B7FAC,
                0xE45C10C42A2B3B06,
                0xAA242499697392D3,
                0xFD87B5F28300CA0E,
                0xBCE5086492111AEB,
                0x8CBCCC096F5088CC,
                0xD1B71758E219652C,
                0x9C40000000000000,
                0xE8D4A51000000000,
                0xAD78EBC5AC620000,
                0x813F3978F8940984,
                0xC097CE7BC90715B3,
                0x8F7E32CE7BEA5C70,
                0xD5D238A4ABE98068,
                0x9F4F2726179A2245,
                0xED63A231D4C4FB27,
                0xB0DE65388CC8ADA8,
                0x83C7088E1AAB65DB,
                0xC45D1DF942711D9A,
                0x924D692CA61BE758,
                0xDA01EE641A708DEA,
                0xA26DA3999AEF774A,
                0xF209787BB47D6B85,
                0xB454E4A179DD1877,
                0x865B86925B9BC5C2,
                0xC83553C5C8965D3D,
                0x952AB45CFA97A0B3,
                0xDE469FBD99A05FE3,
                0xA59BC234DB398C25,
                0xF6C69A72A3989F5C,
                0xB7DCBF5354E9BECE,
                0x88FCF317F22241E2,
                0xCC20CE9BD35C78A5,
                0x98165AF37B2153DF,
                0xE2A0B5DC971F303A,
                0xA8D9D1535CE3B396,
                0xFB9B7CD9A4A7443C,
                0xBB764C4CA7A44410,
                0x8BAB8EEFB6409C1A,
                0xD01FEF10A657842C,
                0x9B10A4E5E9913129,
                0xE7109BFBA19C0C9D,
                0xAC2820D9623BF429,
                0x80444B5E7AA7CF85,
                0xBF21E44003ACDD2D,
                0x8E679C2F5E44FF8F,
                0xD433179D9C8CB841,
                0x9E19DB92B4E31BA9,
                0xEB96BF6EBADF77D9,
                0xAF87023B9BF0EE6B,
            };

            private static readonly uint[] s_SmallPowersOfTen = new uint[]
            {
                1,          // 10^0
                10,         // 10^1
                100,        // 10^2
                1000,       // 10^3
                10000,      // 10^4
                100000,     // 10^5
                1000000,    // 10^6
                10000000,   // 10^7
                100000000,  // 10^8
                1000000000, // 10^9
            };

            public static bool TryRunDouble(double value, int requestedDigits, ref NumberBuffer number)
            {
                double v = IsNegative(value) ? -value : value;

                Debug.Assert(v > 0);
                //Debug.Assert(double.IsFinite(v));

                int length;
                int decimalExponent;
                bool result;

                if (requestedDigits == -1)
                {
                    DiyFp w = DiyFp.CreateAndGetBoundaries(v, out DiyFp boundaryMinus, out DiyFp boundaryPlus).Normalize();
                    result = TryRunShortest(in boundaryMinus, in w, in boundaryPlus, number.Digits, out length, out decimalExponent);
                }
                else
                {
                    DiyFp w = new DiyFp(v).Normalize();
                    result = TryRunCounted(in w, requestedDigits, number.Digits, out length, out decimalExponent);
                }

                if (result)
                {
                    Debug.Assert((requestedDigits == -1) || (length == requestedDigits));

                    number.Scale = length + decimalExponent;
                    number.Digits[length] = (byte)('\0');
                    number.DigitsCount = length;
                }

                return result;
            }

            public static bool TryRunSingle(float value, int requestedDigits, ref NumberBuffer number)
            {
                float v = IsNegative(value) ? -value : value;

                Debug.Assert(v > 0);
                //Debug.Assert(float.IsFinite(v));

                int length;
                int decimalExponent;
                bool result;

                if (requestedDigits == -1)
                {
                    DiyFp w = DiyFp.CreateAndGetBoundaries(v, out DiyFp boundaryMinus, out DiyFp boundaryPlus).Normalize();
                    result = TryRunShortest(in boundaryMinus, in w, in boundaryPlus, number.Digits, out length, out decimalExponent);
                }
                else
                {
                    DiyFp w = new DiyFp(v).Normalize();
                    result = TryRunCounted(in w, requestedDigits, number.Digits, out length, out decimalExponent);
                }

                if (result)
                {
                    Debug.Assert((requestedDigits == -1) || (length == requestedDigits));

                    number.Scale = length + decimalExponent;
                    number.Digits[length] = (byte)('\0');
                    number.DigitsCount = length;
                }

                return result;
            }

            // The counted version of Grisu3 only generates requestedDigits number of digits.
            // This version does not generate the shortest representation, and with enough requested digits 0.1 will at some point print as 0.9999999...
            // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and therefore the rounding strategy for halfway cases is irrelevant.
            private static bool TryRunCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int decimalExponent)
            {
                Debug.Assert(requestedDigits > 0);

                int tenMkMinimalBinaryExponent = MinimalTargetExponent - (w.e + DiyFp.SignificandSize);
                int tenMkMaximalBinaryExponent = MaximalTargetExponent - (w.e + DiyFp.SignificandSize);

                DiyFp tenMk = GetCachedPowerForBinaryExponentRange(tenMkMinimalBinaryExponent, tenMkMaximalBinaryExponent, out int mk);

                Debug.Assert(MinimalTargetExponent <= (w.e + tenMk.e + DiyFp.SignificandSize));
                Debug.Assert(MaximalTargetExponent >= (w.e + tenMk.e + DiyFp.SignificandSize));

                // Note that tenMk is only an approximation of 10^-k.
                // A DiyFp only contains a 64-bit significand and tenMk is thus only precise up to 64-bits.

                // The DiyFp.Multiply procedure rounds its result and tenMk is approximated too.
                // The variable scaledW (as well as scaledBoundaryMinus/Plus) are now off by a small amount.
                //
                // In fact, scaledW - (w * 10^k) < 1ulp (unit in last place) of scaledW.
                // In other words, let f = scaledW.f and e = scaledW.e, then:
                //      (f - 1) * 2^e < (w * 10^k) < (f + 1) * 2^e

                DiyFp scaledW = w.Multiply(in tenMk);

                // We now have (double)(scaledW * 10^-mk).
                //
                // DigitGenCounted will generate the first requestedDigits of scaledW and return together with a kappa such that:
                //      scaledW ~= buffer * 10^kappa.
                //
                // It will not always be exactly the same since DigitGenCounted only produces a limited number of digits.

                bool result = TryDigitGenCounted(in scaledW, requestedDigits, buffer, out length, out int kappa);
                decimalExponent = -mk + kappa;
                return result;
            }

            // Provides a decimal representation of v.
            // Returns true if it succeeds; otherwise, the result cannot be trusted.
            //
            // There will be length digits inside the buffer (not null-terminated).
            // If the function returns true then:
            //      v == (double)(buffer * 10^decimalExponent)
            //
            // The digits in the buffer are the shortest represenation possible (no 0.09999999999999999 instead of 0.1).
            // The shorter representation will even be chosen if the longer one would be closer to v.
            //
            // The last digit will be closest to the actual v.
            // That is, even if several digits might correctly yield 'v' when read again, the closest will be computed.
            private static bool TryRunShortest(in DiyFp boundaryMinus, in DiyFp w, in DiyFp boundaryPlus, Span<byte> buffer, out int length, out int decimalExponent)
            {
                // boundaryMinus and boundaryPlus are the boundaries between v and its closest floating-point neighbors.
                // Any number strictly between boundaryMinus and boundaryPlus will round to v when converted to a double.
                // Grisu3 will never output representations that lie exactly on a boundary.

                Debug.Assert(boundaryPlus.e == w.e);

                int tenMkMinimalBinaryExponent = MinimalTargetExponent - (w.e + DiyFp.SignificandSize);
                int tenMkMaximalBinaryExponent = MaximalTargetExponent - (w.e + DiyFp.SignificandSize);

                DiyFp tenMk = GetCachedPowerForBinaryExponentRange(tenMkMinimalBinaryExponent, tenMkMaximalBinaryExponent, out int mk);

                Debug.Assert(MinimalTargetExponent <= (w.e + tenMk.e + DiyFp.SignificandSize));
                Debug.Assert(MaximalTargetExponent >= (w.e + tenMk.e + DiyFp.SignificandSize));

                // Note that tenMk is only an approximation of 10^-k.
                // A DiyFp only contains a 64-bit significan and tenMk is thus only precise up to 64-bits.

                // The DiyFp.Multiply procedure rounds its result and tenMk is approximated too.
                // The variable scaledW (as well as scaledBoundaryMinus/Plus) are now off by a small amount.
                //
                // In fact, scaledW - (w * 10^k) < 1ulp (unit in last place) of scaledW.
                // In other words, let f = scaledW.f and e = scaledW.e, then:
                //      (f - 1) * 2^e < (w * 10^k) < (f + 1) * 2^e

                DiyFp scaledW = w.Multiply(in tenMk);
                Debug.Assert(scaledW.e == (boundaryPlus.e + tenMk.e + DiyFp.SignificandSize));

                // In theory, it would be possible to avoid some recomputations by computing the difference between w
                // and boundaryMinus/Plus (a power of 2) and to compute scaledBoundaryMinus/Plus by subtracting/adding
                // from scaledW. However, the code becomes much less readable and the speed enhancements are not terrific.

                DiyFp scaledBoundaryMinus = boundaryMinus.Multiply(in tenMk);
                DiyFp scaledBoundaryPlus = boundaryPlus.Multiply(in tenMk);

                // DigitGen will generate the digits of scaledW. Therefore, we have:
                //      v == (double)(scaledW * 10^-mk)
                //
                // Set decimalExponent == -mk and pass it to DigitGen and if scaledW is not an integer than it will be updated.
                // For instance, if scaledW == 1.23 then the buffer will be filled with "123" and the decimalExponent will be decreased by 2.

                bool result = TryDigitGenShortest(in scaledBoundaryMinus, in scaledW, in scaledBoundaryPlus, buffer, out length, out int kappa);
                decimalExponent = -mk + kappa;
                return result;
            }

            // Returns the biggest power of ten that is less than or equal to the given number.
            // We furthermore receive the maximum number of bits 'number' has.
            //
            // Returns power == 10^(exponent) such that
            //      power <= number < power * 10
            // If numberBits == 0, then 0^(0-1) is returned.
            // The number of bits must be <= 32.
            //
            // Preconditions:
            //      number < (1 << (numberBits + 1))
            private static uint BiggestPowerTen(uint number, int numberBits, out int exponentPlusOne)
            {
                // Inspired by the method for finding an integer log base 10 from here:
                // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10

                Debug.Assert(number < (1U << (numberBits + 1)));

                // 1233/4096 is approximately 1/log2(10)
                int exponentGuess = ((numberBits + 1) * 1233) >> 12;
                Debug.Assert((uint)(exponentGuess) < s_SmallPowersOfTen.Length);

                uint power = s_SmallPowersOfTen[exponentGuess];

                // We don't have any guarantees that 2^numberBits <= number
                if (number < power)
                {
                    exponentGuess--;
                    power = s_SmallPowersOfTen[exponentGuess];
                }

                exponentPlusOne = exponentGuess + 1;
                return power;
            }

            // Generates (at most) requestedDigits of input number w.
            //
            // w is a floating-point number (DiyFp), consisting of a significand and an exponent.
            // Its exponent is bounded by MinimalTargetExponent and MaximalTargetExponent, hence:
            //      -60 <= w.e <= -32
            //
            // Returns false if it fails, in which case the generated digits in the buffer should not be used.
            //
            // Preconditions:
            //      w is correct up to 1 ulp (unit in last place). That is, its error must be strictly less than a unit of its last digit.
            //      MinimalTargetExponent <= w.e <= MaximalTargetExponent
            //
            // Postconditions:
            //      Returns false if the procedure fails; otherwise:
            //      * buffer is not null-terminated, but length contains the number of digits.
            //      * The representation in buffer is the most precise representation of requestedDigits digits.
            //      * buffer contains at most requestedDigits digits of w. If there are less than requestedDigits digits then some trailing '0's have been removed.
            //      * kappa is such that w = buffer * 10^kappa + eps with |eps| < 10^kappa / 2.
            //
            // This procedure takes into account the imprecision of its input numbers.
            // If the precision is not enough to guarantee all the postconditions, then false is returned.
            // This usually happens rarely, but the failure-rate increases with higher requestedDigits
            private static bool TryDigitGenCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int kappa)
            {
                Debug.Assert(MinimalTargetExponent <= w.e);
                Debug.Assert(w.e <= MaximalTargetExponent);
                Debug.Assert(MinimalTargetExponent >= -60);
                Debug.Assert(MaximalTargetExponent <= -32);

                // w is assumed to have an error less than 1 unit.
                // Whenever w is scaled we also scale its error.
                ulong wError = 1;

                // We cut the input number into two parts: the integral digits and the fractional digits.
                // We don't emit any decimal separator, but adapt kapp instead.
                // For example: instead of writing "1.2", we put "12" into the buffer and increase kappa by 1.
                var one = new DiyFp(1UL << -w.e, w.e);

                // Division by one is a shift.
                uint integrals = (uint)(w.f >> -one.e);

                // Modulo by one is an and.
                ulong fractionals = w.f & (one.f - 1);

                // We deviate from the original algorithm here and do some early checks to determine if we can satisfy requestedDigits.
                // If we determine that we can't, we exit early and avoid most of the heavy lifting that the algorithm otherwise does.
                //
                // When fractionals is zero, we can easily determine if integrals can satisfy requested digits:
                //      If requestedDigits >= 11, integrals is not able to exhaust the count by itself since 10^(11 -1) > uint.MaxValue >= integrals.
                //      If integrals < 10^(requestedDigits - 1), integrals cannot exhaust the count.
                //      Otherwise, integrals might be able to exhaust the count and we need to execute the rest of the code.
                if ((fractionals == 0) && ((requestedDigits >= 11) || (integrals < s_SmallPowersOfTen[requestedDigits - 1])))
                {
                    Debug.Assert(buffer[0] == '\0');
                    length = 0;
                    kappa = 0;
                    return false;
                }

                uint divisor = BiggestPowerTen(integrals, DiyFp.SignificandSize - (-one.e), out kappa);
                length = 0;

                // Loop invariant:
                //      buffer = w / 10^kappa (integer division)
                // These invariants hold for the first iteration:
                //      kappa has been initialized with the divisor exponent + 1
                //      The divisor is the biggest power of ten that is smaller than integrals
                while (kappa > 0)
                {
                    uint digit = MathEx.DivRem(integrals, divisor, out integrals);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    requestedDigits--;
                    kappa--;

                    // Note that kappa now equals the exponent of the
                    // divisor and that the invariant thus holds again.
                    if (requestedDigits == 0)
                    {
                        break;
                    }

                    divisor /= 10;
                }

                if (requestedDigits == 0)
                {
                    ulong rest = ((ulong)(integrals) << -one.e) + fractionals;
                    return TryRoundWeedCounted(
                        buffer,
                        length,
                        rest,
                        tenKappa: ((ulong)(divisor)) << -one.e,
                        unit: wError,
                        ref kappa
                    );
                }

                // The integrals have been generated and we are at the point of the decimal separator.
                // In the following loop, we simply multiply the remaining digits by 10 and divide by one.
                // We just need to pay attention to multiply associated data (the unit), too.
                // Note that the multiplication by 10 does not overflow because:
                //      w.e >= -60 and thus one.e >= -60

                Debug.Assert(one.e >= MinimalTargetExponent);
                Debug.Assert(fractionals < one.f);
                Debug.Assert((ulong.MaxValue / 10) >= one.f);

                while ((requestedDigits > 0) && (fractionals > wError))
                {
                    fractionals *= 10;
                    wError *= 10;

                    // Integer division by one.
                    uint digit = (uint)(fractionals >> -one.e);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    requestedDigits--;
                    kappa--;

                    // Modulo by one.
                    fractionals &= (one.f - 1);
                }

                if (requestedDigits != 0)
                {
                    buffer[0] = (byte)('\0');
                    length = 0;
                    kappa = 0;
                    return false;
                }

                return TryRoundWeedCounted(
                    buffer,
                    length,
                    rest: fractionals,
                    tenKappa: one.f,
                    unit: wError,
                    ref kappa
                );
            }

            // Generates the digits of input number w.
            //
            // w is a floating-point number (DiyFp), consisting of a significand and an exponent.
            // Its exponent is bounded by kMinimalTargetExponent and kMaximalTargetExponent, hence:
            //      -60 <= w.e() <= -32.
            //
            // Returns false if it fails, in which case the generated digits in the buffer should not be used.
            //
            // Preconditions:
            //      low, w and high are correct up to 1 ulp (unit in the last place). That is, their error must be less than a unit of their last digits.
            //      low.e() == w.e() == high.e()
            //      low < w < high, and taking into account their error: low~ <= high~
            //      kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent
            //
            // Postconditions:
            //      Returns false if procedure fails; otherwise:
            //      * buffer is not null-terminated, but len contains the number of digits.
            //      * buffer contains the shortest possible decimal digit-sequence such that LOW < buffer * 10^kappa < HIGH, where LOW and HIGH are the correct values of low and high (without their error).
            //      * If more than one decimal representation gives the minimal number of decimal digits then the one closest to W (where W is the correct value of w) is chosen.
            //
            // This procedure takes into account the imprecision of its input numbers.
            // If the precision is not enough to guarantee all the postconditions then false is returned.
            // This usually happens rarely (~0.5%).
            //
            // Say, for the sake of example, that:
            //      w.e() == -48, and w.f() == 0x1234567890abcdef
            //
            // w's value can be computed by w.f() * 2^w.e()
            //
            // We can obtain w's integral digits by simply shifting w.f() by -w.e().
            //      -> w's integral part is 0x1234
            //      w's fractional part is therefore 0x567890abcdef.
            //
            // Printing w's integral part is easy (simply print 0x1234 in decimal).
            //
            // In order to print its fraction we repeatedly multiply the fraction by 10 and get each digit.
            // For example, the first digit after the point would be computed by
            //      (0x567890abcdef * 10) >> 48. -> 3
            //
            // The whole thing becomes slightly more complicated because we want to stop once we have enough digits.
            // That is, once the digits inside the buffer represent 'w' we can stop.
            //
            // Everything inside the interval low - high represents w.
            // However we have to pay attention to low, high and w's imprecision.
            private static bool TryDigitGenShortest(in DiyFp low, in DiyFp w, in DiyFp high, Span<byte> buffer, out int length, out int kappa)
            {
                Debug.Assert(low.e == w.e);
                Debug.Assert(w.e == high.e);

                Debug.Assert((low.f + 1) <= (high.f - 1));

                Debug.Assert(MinimalTargetExponent <= w.e);
                Debug.Assert(w.e <= MaximalTargetExponent);

                // low, w, and high are imprecise, but by less than one ulp (unit in the last place).
                //
                // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that the new numbers
                // are outside of the interval we want the final representation to lie in.
                //
                // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield numbers that
                // are certain to lie in the interval. We will use this fact later on.
                //
                // We will now start by generating the digits within the uncertain interval.
                // Later, we will weed out representations that lie outside the safe interval and thus might lie outside the correct interval.

                ulong unit = 1;

                var tooLow = new DiyFp(low.f - unit, low.e);
                var tooHigh = new DiyFp(high.f + unit, high.e);

                // tooLow and tooHigh are guaranteed to lie outside the interval we want the generated number in.

                DiyFp unsafeInterval = tooHigh.Subtract(in tooLow);

                // We now cut the input number into two parts: the integral digits and the fractional digits.
                // We will not write any decimal separator, but adapt kappa instead.
                //
                // Reminder: we are currently computing the digits (Stored inside the buffer) such that:
                //      tooLow < buffer * 10^kappa < tooHigh
                //
                // We use tooHigh for the digitGeneration and stop as soon as possible.
                // If we stop early, we effectively round down.

                var one = new DiyFp(1UL << -w.e, w.e);

                // Division by one is a shift.
                uint integrals = (uint)(tooHigh.f >> -one.e);

                // Modulo by one is an and.
                ulong fractionals = tooHigh.f & (one.f - 1);

                uint divisor = BiggestPowerTen(integrals, DiyFp.SignificandSize - (-one.e), out kappa);
                length = 0;

                // Loop invariant:
                //      buffer = tooHigh / 10^kappa (integer division)
                // These invariants hold for the first iteration:
                //      kappa has been initialized with the divisor exponent + 1
                //      The divisor is the biggest power of ten that is smaller than integrals
                while (kappa > 0)
                {
                    uint digit = MathEx.DivRem(integrals, divisor, out integrals);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    kappa--;

                    // Note that kappa now equals the exponent of the
                    // divisor and that the invariant thus holds again.

                    ulong rest = ((ulong)(integrals) << -one.e) + fractionals;

                    // Invariant: tooHigh = buffer * 10^kappa + DiyFp(rest, one.e)
                    // Reminder: unsafeInterval.e == one.e

                    if (rest < unsafeInterval.f)
                    {
                        // Rounding down (by not emitting the remaining digits)
                        // yields a number that lies within the unsafe interval

                        return TryRoundWeedShortest(
                            buffer,
                            length,
                            tooHigh.Subtract(w).f,
                            unsafeInterval.f,
                            rest,
                            tenKappa: ((ulong)(divisor)) << -one.e,
                            unit
                        );
                    }

                    divisor /= 10;
                }

                // The integrals have been generated and we are at the point of the decimal separator.
                // In the following loop, we simply multiply the remaining digits by 10 and divide by one.
                // We just need to pay attention to multiply associated data (the unit), too.
                // Note that the multiplication by 10 does not overflow because:
                //      w.e >= -60 and thus one.e >= -60

                Debug.Assert(one.e >= MinimalTargetExponent);
                Debug.Assert(fractionals < one.f);
                Debug.Assert((ulong.MaxValue / 10) >= one.f);

                while (true)
                {
                    fractionals *= 10;
                    unit *= 10;

                    unsafeInterval = new DiyFp(unsafeInterval.f * 10, unsafeInterval.e);

                    // Integer division by one.
                    uint digit = (uint)(fractionals >> -one.e);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    kappa--;

                    // Modulo by one.
                    fractionals &= (one.f - 1);

                    if (fractionals < unsafeInterval.f)
                    {
                        return TryRoundWeedShortest(
                            buffer,
                            length,
                            tooHigh.Subtract(w).f * unit,
                            unsafeInterval.f,
                            rest: fractionals,
                            tenKappa: one.f,
                            unit
                        );
                    }
                }
            }

            // Returns a cached power-of-ten with a binary exponent in the range [minExponent; maxExponent] (boundaries included).
            private static DiyFp GetCachedPowerForBinaryExponentRange(int minExponent, int maxExponent, out int decimalExponent)
            {
                Debug.Assert(s_CachedPowersSignificand.Length == s_CachedPowersBinaryExponent.Length);
                Debug.Assert(s_CachedPowersSignificand.Length == s_CachedPowersDecimalExponent.Length);

                double k = Math.Ceiling((minExponent + DiyFp.SignificandSize - 1) * D1Log210);
                int index = ((CachedPowersOffset + (int)(k) - 1) / CachedPowersDecimalExponentDistance) + 1;

                Debug.Assert((uint)(index) < s_CachedPowersSignificand.Length);

                Debug.Assert(minExponent <= s_CachedPowersBinaryExponent[index]);
                Debug.Assert(s_CachedPowersBinaryExponent[index] <= maxExponent);

                decimalExponent = s_CachedPowersDecimalExponent[index];
                return new DiyFp(s_CachedPowersSignificand[index], s_CachedPowersBinaryExponent[index]);
            }

            // Rounds the buffer upwards if the result is closer to v by possibly adding 1 to the buffer.
            // If the precision of the calculation is not sufficient to round correctly, return false.
            //
            // The rounding might shift the whole buffer, in which case, the kappy is adjusted.
            // For example "99", kappa = 3 might become "10", kappa = 4.
            //
            // If (2 * rest) > tenKappa then the buffer needs to be round up.
            // rest can have an error of +/- 1 unit.
            // This function accounts for the imprecision and returns false if the rounding direction cannot be unambiguously determined.
            //
            // Preconditions:
            //      rest < tenKappa
            private static bool TryRoundWeedCounted(Span<byte> buffer, int length, ulong rest, ulong tenKappa, ulong unit, ref int kappa)
            {
                Debug.Assert(rest < tenKappa);

                // The following tests are done in a specific order to avoid overflows.
                // They will work correctly with any ulong values of rest < tenKappa and unit.
                //
                // If the unit is too big, then we don't know which way to round.
                // For example, a unit of 50 means that the real number lies within rest +/- 50.
                // If 10^kappa == 40, then there is no way to tell which way to round.
                //
                // Even if unit is just half the size of 10^kappa we are already completely lost.
                // And after the previous test, we know that the expression will not over/underflow.
                if ((unit >= tenKappa) || ((tenKappa - unit) <= unit))
                {
                    return false;
                }

                // If 2 * (rest + unit) <= 10^kappa, we can safely round down.
                if (((tenKappa - rest) > rest) && ((tenKappa - (2 * rest)) >= (2 * unit)))
                {
                    return true;
                }

                // If 2 * (rest - unit) >= 10^kappa, we can safely round up.
                if ((rest > unit) && (tenKappa <= (rest - unit) || ((tenKappa - (rest - unit)) <= (rest - unit))))
                {
                    // Increment the last digit recursively until we find a non '9' digit.
                    buffer[length - 1]++;

                    for (int i = (length - 1); i > 0; i--)
                    {
                        if (buffer[i] != ('0' + 10))
                        {
                            break;
                        }

                        buffer[i] = (byte)('0');
                        buffer[i - 1]++;
                    }

                    // If the first digit is now '0'+10, we had a buffer with all '9's.
                    // With the exception of the first digit, all digits are now '0'.
                    // Simply switch the first digit to '1' and adjust the kappa.
                    // For example, "99" becomes "10" and the power (the kappa) is increased.
                    if (buffer[0] == ('0' + 10))
                    {
                        buffer[0] = (byte)('1');
                        kappa++;
                    }

                    return true;
                }

                return false;
            }

            // Adjusts the last digit of the generated number and screens out generated solutions that may be inaccurate.
            // A solution may be inaccurate if it is outside the safe interval or if we cannot provide that it is closer to the input than a neighboring representation of the same length.
            //
            // Input:
            //      buffer containing the digits of tooHigh / 10^kappa
            //      the buffer's length
            //      distanceTooHighW == (tooHigh - w).f * unit
            //      unsafeInterval == (tooHigh - tooLow).f * unit
            //      rest = (tooHigh - buffer * 10^kapp).f * unit
            //      tenKappa = 10^kappa * unit
            //      unit = the common multiplier
            //
            // Output:
            //      Returns true if the buffer is guaranteed to contain the closest representable number to the input.
            //
            // Modifies the generated digits in the buffer to approach (round towards) w.
            private static bool TryRoundWeedShortest(Span<byte> buffer, int length, ulong distanceTooHighW, ulong unsafeInterval, ulong rest, ulong tenKappa, ulong unit)
            {
                ulong smallDistance = distanceTooHighW - unit;
                ulong bigDistance = distanceTooHighW + unit;

                // Let wLow = tooHigh - bigDistance, and wHigh = tooHigh - smallDistance.
                //
                // Note: wLow < w < wHigh
                //
                // The real w * unit must lie somewhere inside the interval
                //      ]w_low; w_high[ (often written as "(w_low; w_high)")

                // Basically the buffer currently contains a number in the unsafe interval
                //      ]too_low; too_high[ with too_low < w < too_high
                //
                //  tooHigh - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                //                    ^v 1 unit            ^      ^                 ^      ^
                //  boundaryHigh ---------------------     .      .                 .      .
                //                    ^v 1 unit            .      .                 .      .
                //  - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .
                //                                         .      .         ^       .      .
                //                                         .  bigDistance   .       .      .
                //                                         .      .         .       .    rest
                //                              smallDistance     .         .       .      .
                //                                         v      .         .       .      .
                //  wHigh - - - - - - - - - - - - - - - - - -     .         .       .      .
                //                    ^v 1 unit                   .         .       .      .
                //  w ---------------------------------------     .         .       .      .
                //                    ^v 1 unit                   v         .       .      .
                //  wLow  - - - - - - - - - - - - - - - - - - - - -         .       .      .
                //                                                          .       .      v
                //  buffer -------------------------------------------------+-------+--------
                //                                                          .       .
                //                                                  safeInterval    .
                //                                                          v       .
                //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .
                //                    ^v 1 unit                                     .
                //  boundaryLow -------------------------                     unsafeInterval
                //                    ^v 1 unit                                     v
                //  tooLow  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                //
                //
                // Note that the value of buffer could lie anywhere inside the range tooLow to tooHigh.
                //
                // boundaryLow, boundaryHigh and w are approximations of the real boundaries and v (the input number).
                // They are guaranteed to be precise up to one unit.
                // In fact the error is guaranteed to be strictly less than one unit.
                //
                // Anything that lies outside the unsafe interval is guaranteed not to round to v when read again.
                // Anything that lies inside the safe interval is guaranteed to round to v when read again.
                //
                // If the number inside the buffer lies inside the unsafe interval but not inside the safe interval
                // then we simply do not know and bail out (returning false).
                //
                // Similarly we have to take into account the imprecision of 'w' when finding the closest representation of 'w'.
                // If we have two potential representations, and one is closer to both wLow and wHigh, then we know it is closer to the actual value v.
                //
                // By generating the digits of tooHigh we got the largest (closest to tooHigh) buffer that is still in the unsafe interval.
                // In the case where wHigh < buffer < tooHigh we try to decrement the buffer.
                // This way the buffer approaches (rounds towards) w.
                //
                // There are 3 conditions that stop the decrementation process:
                //   1) the buffer is already below wHigh
                //   2) decrementing the buffer would make it leave the unsafe interval
                //   3) decrementing the buffer would yield a number below wHigh and farther away than the current number.
                //
                // In other words:
                //      (buffer{-1} < wHigh) && wHigh - buffer{-1} > buffer - wHigh
                //
                // Instead of using the buffer directly we use its distance to tooHigh.
                //
                // Conceptually rest ~= tooHigh - buffer
                //
                // We need to do the following tests in this order to avoid over- and underflows.

                Debug.Assert(rest <= unsafeInterval);

                while ((rest < smallDistance) && ((unsafeInterval - rest) >= tenKappa) && (((rest + tenKappa) < smallDistance) || ((smallDistance - rest) >= (rest + tenKappa - smallDistance))))
                {
                    buffer[length - 1]--;
                    rest += tenKappa;
                }

                // We have approached w+ as much as possible.
                // We now test if approaching w- would require changing the buffer.
                // If yes, then we have two possible representations close to w, but we cannot decide which one is closer.
                if ((rest < bigDistance) && ((unsafeInterval - rest) >= tenKappa) && (((rest + tenKappa) < bigDistance) || ((bigDistance - rest) > (rest + tenKappa - bigDistance))))
                {
                    return false;
                }

                // Weeding test.
                //
                // The safe interval is [tooLow + 2 ulp; tooHigh - 2 ulp]
                // Since tooLow = tooHigh - unsafeInterval this is equivalent to
                //      [tooHigh - unsafeInterval + 4 ulp; tooHigh - 2 ulp]
                //
                // Conceptually we have: rest ~= tooHigh - buffer
                return ((2 * unit) <= rest) && (rest <= (unsafeInterval - 4 * unit));
            }
        }
    }
}


================================================
FILE: src/ZString/Number/Number.NumberBuffer.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static partial class Number
    {
        // We need 1 additional byte, per length, for the terminating null
        internal const int DecimalNumberBufferLength = 29 + 1 + 1;  // 29 for the longest input + 1 for rounding
        internal const int DoubleNumberBufferLength = 767 + 1 + 1;  // 767 for the longest input + 1 for rounding: 4.9406564584124654E-324
        internal const int Int32NumberBufferLength = 10 + 1;    // 10 for the longest input: 2,147,483,647
        internal const int Int64NumberBufferLength = 19 + 1;    // 19 for the longest input: 9,223,372,036,854,775,807
        internal const int SingleNumberBufferLength = 112 + 1 + 1;  // 112 for the longest input + 1 for rounding: 1.40129846E-45
        internal const int UInt32NumberBufferLength = 10 + 1;   // 10 for the longest input: 4,294,967,295
        internal const int UInt64NumberBufferLength = 20 + 1;   // 20 for the longest input: 18,446,744,073,709,551,615

        internal unsafe ref struct NumberBuffer
        {
            public int DigitsCount;
            public int Scale;
            public bool IsNegative;
            public bool HasNonZeroTail;
            public NumberBufferKind Kind;
            public Span<byte> Digits;

            public NumberBuffer(NumberBufferKind kind, byte* digits, int digitsLength)
            {
                Debug.Assert(digits != null);
                Debug.Assert(digitsLength > 0);

                DigitsCount = 0;
                Scale = 0;
                IsNegative = false;
                HasNonZeroTail = false;
                Kind = kind;
                Digits = new Span<byte>(digits, digitsLength);

#if DEBUG
                Digits.Fill(0xCC);
#endif

                Digits[0] = (byte)('\0');
                CheckConsistency();
            }

            [Conditional("DEBUG")]
            public void CheckConsistency()
            {
#if DEBUG
                Debug.Assert((Kind == NumberBufferKind.Integer) || (Kind == NumberBufferKind.Decimal) || (Kind == NumberBufferKind.FloatingPoint));
                Debug.Assert(Digits[0] != '0', "Leading zeros should never be stored in a Number");
 
                int numDigits;
                for (numDigits = 0; numDigits < Digits.Length; numDigits++)
                {
                    byte digit = Digits[numDigits];
 
                    if (digit == 0)
                    {
                        break;
                    }
 
                    Debug.Assert((digit >= '0') && (digit <= '9'), "Unexpected character found in Number");
                }
 
                Debug.Assert(numDigits == DigitsCount, "Null terminator found in unexpected location in Number");
                Debug.Assert(numDigits < Digits.Length, "Null terminator not found in Number");
#endif // DEBUG
            }

            public byte* GetDigitsPointer()
            {
                // This is safe to do since we are a ref struct
                return (byte*)(Unsafe.AsPointer(ref Digits[0]));
            }

            //
            // Code coverage note: This only exists so that Number displays nicely in the VS watch window. So yes, I know it works.
            //
            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();

                sb.Append('[');
                sb.Append('"');

                for (int i = 0; i < Digits.Length; i++)
                {
                    byte digit = Digits[i];

                    if (digit == 0)
                    {
                        break;
                    }

                    sb.Append((char)(digit));
                }

                sb.Append('"');
                sb.Append(", Length = ").Append(DigitsCount);
                sb.Append(", Scale = ").Append(Scale);
                sb.Append(", IsNegative = ").Append(IsNegative);
                sb.Append(", HasNonZeroTail = ").Append(HasNonZeroTail);
                sb.Append(", Kind = ").Append(Kind);
                sb.Append(']');

                return sb.ToString();
            }
        }

        internal enum NumberBufferKind : byte
        {
            Unknown = 0,
            Integer = 1,
            Decimal = 2,
            FloatingPoint = 3,
        }
    }
}


================================================
FILE: src/ZString/Number/Number.NumberToFloatingPointBits.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace System
{
    internal unsafe partial class Number
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static unsafe int SingleToInt32Bits(float value)
        {
            return *((int*)&value);
        }

        public readonly struct FloatingPointInfo
        {
            public static readonly FloatingPointInfo Double = new FloatingPointInfo(
                denormalMantissaBits: 52,
                exponentBits: 11,
                maxBinaryExponent: 1023,
                exponentBias: 1023,
                infinityBits: 0x7FF00000_00000000
            );

            public static readonly FloatingPointInfo Single = new FloatingPointInfo(
                denormalMantissaBits: 23,
                exponentBits: 8,
                maxBinaryExponent: 127,
                exponentBias: 127,
                infinityBits: 0x7F800000
            );

            public ulong ZeroBits { get; }
            public ulong InfinityBits { get; }

            public ulong NormalMantissaMask { get; }
            public ulong DenormalMantissaMask { get; }

            public int MinBinaryExponent { get; }
            public int MaxBinaryExponent { get; }

            public int ExponentBias { get; }
            public int OverflowDecimalExponent { get; }

            public ushort NormalMantissaBits { get; }
            public ushort DenormalMantissaBits { get; }

            public ushort ExponentBits { get; }

            public FloatingPointInfo(ushort denormalMantissaBits, ushort exponentBits, int maxBinaryExponent, int exponentBias, ulong infinityBits)
            {
                ExponentBits = exponentBits;

                DenormalMantissaBits = denormalMantissaBits;
                NormalMantissaBits = (ushort)(denormalMantissaBits + 1); // we get an extra (hidden) bit for normal mantissas

                OverflowDecimalExponent = (maxBinaryExponent + 2 * NormalMantissaBits) / 3;
                ExponentBias = exponentBias;

                MaxBinaryExponent = maxBinaryExponent;
                MinBinaryExponent = 1 - maxBinaryExponent;

                DenormalMantissaMask = (1UL << denormalMantissaBits) - 1;
                NormalMantissaMask = (1UL << NormalMantissaBits) - 1;

                InfinityBits = infinityBits;
                ZeroBits = 0;
            }
        }

        private static readonly float[] s_Pow10SingleTable = new float[]
        {
            1e0f,   // 10^0
            1e1f,   // 10^1
            1e2f,   // 10^2
            1e3f,   // 10^3
            1e4f,   // 10^4
            1e5f,   // 10^5
            1e6f,   // 10^6
            1e7f,   // 10^7
            1e8f,   // 10^8
            1e9f,   // 10^9
            1e10f,  // 10^10
        };

        private static readonly double[] s_Pow10DoubleTable = new double[]
        {
            1e0,    // 10^0
            1e1,    // 10^1
            1e2,    // 10^2
            1e3,    // 10^3
            1e4,    // 10^4
            1e5,    // 10^5
            1e6,    // 10^6
            1e7,    // 10^7
            1e8,    // 10^8
            1e9,    // 10^9
            1e10,   // 10^10
            1e11,   // 10^11
            1e12,   // 10^12
            1e13,   // 10^13
            1e14,   // 10^14
            1e15,   // 10^15
            1e16,   // 10^16
            1e17,   // 10^17
            1e18,   // 10^18
            1e19,   // 10^19
            1e20,   // 10^20
            1e21,   // 10^21
            1e22,   // 10^22
        };

        private static void AccumulateDecimalDigitsIntoBigInteger(ref NumberBuffer number, uint firstIndex, uint lastIndex, out BigInteger result)
        {
            BigInteger.SetZero(out result);

            byte* src = number.GetDigitsPointer() + firstIndex;
            uint remaining = lastIndex - firstIndex;

            while (remaining != 0)
            {
                uint count = Math.Min(remaining, 9);
                uint value = DigitsToUInt32(src, (int)(count));

                result.MultiplyPow10(count);
                result.Add(value);

                src += count;
                remaining -= count;
            }
        }

        private static ulong AssembleFloatingPointBits(in FloatingPointInfo info, ulong initialMantissa, int initialExponent, bool hasZeroTail)
        {
            // number of bits by which we must adjust the mantissa to shift it into the
            // correct position, and compute the resulting base two exponent for the
            // normalized mantissa:
            uint initialMantissaBits = BigInteger.CountSignificantBits(initialMantissa);
            int normalMantissaShift = info.NormalMantissaBits - (int)(initialMantissaBits);
            int normalExponent = initialExponent - normalMantissaShift;

            ulong mantissa = initialMantissa;
            int exponent = normalExponent;

            if (normalExponent > info.MaxBinaryExponent)
            {
                // The exponent is too large to be represented by the floating point
                // type; report the overflow condition:
                return info.InfinityBits;
            }
            else if (normalExponent < info.MinBinaryExponent)
            {
                // The exponent is too small to be represented by the floating point
                // type as a normal value, but it may be representable as a denormal
                // value.  Compute the number of bits by which we need to shift the
                // mantissa in order to form a denormal number.  (The subtraction of
                // an extra 1 is to account for the hidden bit of the mantissa that
                // is not available for use when representing a denormal.)
                int denormalMantissaShift = normalMantissaShift + normalExponent + info.ExponentBias - 1;

                // Denormal values have an exponent of zero, so the debiased exponent is
                // the negation of the exponent bias:
                exponent = -info.ExponentBias;

                if (denormalMantissaShift < 0)
                {
                    // Use two steps for right shifts:  for a shift of N bits, we first
                    // shift by N-1 bits, then shift the last bit and use its value to
                    // round the mantissa.
                    mantissa = RightShiftWithRounding(mantissa, -denormalMantissaShift, hasZeroTail);

                    // If the mantissa is now zero, we have underflowed:
                    if (mantissa == 0)
                    {
                        return info.ZeroBits;
                    }

                    // When we round the mantissa, the result may be so large that the
                    // number becomes a normal value.  For example, consider the single
                    // precision case where the mantissa is 0x01ffffff and a right shift
                    // of 2 is required to shift the value into position. We perform the
                    // shift in two steps:  we shift by one bit, then we shift again and
                    // round using the dropped bit.  The initial shift yields 0x00ffffff.
                    // The rounding shift then yields 0x007fffff and because the least
                    // significant bit was 1, we add 1 to this number to round it.  The
                    // final result is 0x00800000.
                    //
                    // 0x00800000 is 24 bits, which is more than the 23 bits available
                    // in the mantissa.  Thus, we have rounded our denormal number into
                    // a normal number.
                    //
                    // We detect this case here and re-adjust the mantissa and exponent
                    // appropriately, to form a normal number:
                    if (mantissa > info.DenormalMantissaMask)
                    {
                        // We add one to the denormal_mantissa_shift to account for the
                        // hidden mantissa bit (we subtracted one to account for this bit
                        // when we computed the denormal_mantissa_shift above).
                        exponent = initialExponent - (denormalMantissaShift + 1) - normalMantissaShift;
                    }
                }
                else
                {
                    mantissa <<= denormalMantissaShift;
                }
            }
            else
            {
                if (normalMantissaShift < 0)
                {
                    // Use two steps for right shifts:  for a shift of N bits, we first
                    // shift by N-1 bits, then shift the last bit and use its value to
                    // round the mantissa.
                    mantissa = RightShiftWithRounding(mantissa, -normalMantissaShift, hasZeroTail);

                    // When we round the mantissa, it may produce a result that is too
                    // large.  In this case, we divide the mantissa by two and increment
                    // the exponent (this does not change the value).
                    if (mantissa > info.NormalMantissaMask)
                    {
                        mantissa >>= 1;
                        exponent++;

                        // The increment of the exponent may have generated a value too
                        // large to be represented.  In this case, report the overflow:
                        if (exponent > info.MaxBinaryExponent)
                        {
                            return info.InfinityBits;
                        }
                    }
                }
                else if (normalMantissaShift > 0)
                {
                    mantissa <<= normalMantissaShift;
                }
            }

            // Unset the hidden bit in the mantissa and assemble the floating point value
            // from the computed components:
            mantissa &= info.DenormalMantissaMask;

            Debug.Assert((info.DenormalMantissaMask & (1UL << info.DenormalMantissaBits)) == 0);
            ulong shiftedExponent = ((ulong)(exponent + info.ExponentBias)) << info.DenormalMantissaBits;
            Debug.Assert((shiftedExponent & info.DenormalMantissaMask) == 0);
            Debug.Assert((mantissa & ~info.DenormalMantissaMask) == 0);
            Debug.Assert((shiftedExponent & ~(((1UL << info.ExponentBits) - 1) << info.DenormalMantissaBits)) == 0); // exponent fits in its place

            return shiftedExponent | mantissa;
        }

        private static ulong ConvertBigIntegerToFloatingPointBits(ref BigInteger value, in FloatingPointInfo info, uint integerBitsOfPrecision, bool hasNonZeroFractionalPart)
        {
            int baseExponent = info.DenormalMantissaBits;

            // When we have 64-bits or less of precision, we can just get the mantissa directly
            if (integerBitsOfPrecision <= 64)
            {
                return AssembleFloatingPointBits(in info, value.ToUInt64(), baseExponent, !hasNonZeroFractionalPart);
            }

            uint topBlockIndex = MathEx.DivRem(integerBitsOfPrecision, 32, out uint topBlockBits);
            uint middleBlockIndex = topBlockIndex - 1;
            uint bottomBlockIndex = middleBlockIndex - 1;

            ulong mantissa;
            int exponent = baseExponent + ((int)(bottomBlockIndex) * 32);
            bool hasZeroTail = !hasNonZeroFractionalPart;

            // When the top 64-bits perfectly span two blocks, we can get those blocks directly
            if (topBlockBits == 0)
            {
                mantissa = ((ulong)(value.GetBlock(middleBlockIndex)) << 32) + value.GetBlock(bottomBlockIndex);
            }
            else
            {
                // Otherwise, we need to read three blocks and combine them into a 64-bit mantissa

                int bottomBlockShift = (int)(topBlockBits);
                int topBlockShift = 64 - bottomBlockShift;
                int middleBlockShift = topBlockShift - 32;

                exponent += (int)(topBlockBits);

                uint bottomBlock = value.GetBlock(bottomBlockIndex);
                uint bottomBits = bottomBlock >> bottomBlockShift;

                ulong middleBits = (ulong)(value.GetBlock(middleBlockIndex)) << middleBlockShift;
                ulong topBits = (ulong)(value.GetBlock(topBlockIndex)) << topBlockShift;

                mantissa = topBits + middleBits + bottomBits;

                uint unusedBottomBlockBitsMask = (1u << (int)(topBlockBits)) - 1;
                hasZeroTail &= (bottomBlock & unusedBottomBlockBitsMask) == 0;
            }

            for (uint i = 0; i != bottomBlockIndex; i++)
            {
                hasZeroTail &= (value.GetBlock(i) == 0);
            }

            return AssembleFloatingPointBits(in info, mantissa, exponent, hasZeroTail);
        }

        // get 32-bit integer from at most 9 digits
        private static uint DigitsToUInt32(byte* p, int count)
        {
            Debug.Assert((1 <= count) && (count <= 9));

            byte* end = (p + count);
            uint res = (uint)(p[0] - '0');

            for (p++; p < end; p++)
            {
                res = (10 * res) + p[0] - '0';
            }

            return res;
        }

        // get 64-bit integer from at most 19 digits
        private static ulong DigitsToUInt64(byte* p, int count)
        {
            Debug.Assert((1 <= count) && (count <= 19));

            byte* end = (p + count);
            ulong res = (ulong)(p[0] - '0');

            for (p++; p < end; p++)
            {
                res = (10 * res) + p[0] - '0';
            }

            return res;
        }

        private static ulong NumberToFloatingPointBits(ref NumberBuffer number, in FloatingPointInfo info)
        {
            Debug.Assert(number.GetDigitsPointer()[0] != '0');

            Debug.Assert(number.Scale <= FloatingPointMaxExponent);
            Debug.Assert(number.Scale >= FloatingPointMinExponent);

            Debug.Assert(number.DigitsCount != 0);

            // The input is of the form 0.Mantissa x 10^Exponent, where 'Mantissa' are
            // the decimal digits of the mantissa and 'Exponent' is the decimal exponent.
            // We decompose the mantissa into two parts: an integer part and a fractional
            // part.  If the exponent is positive, then the integer part consists of the
            // first 'exponent' digits, or all present digits if there are fewer digits.
            // If the exponent is zero or negative, then the integer part is empty.  In
            // either case, the remaining digits form the fractional part of the mantissa.

            uint totalDigits = (uint)(number.DigitsCount);
            uint positiveExponent = (uint)(Math.Max(0, number.Scale));

            uint integerDigitsPresent = Math.Min(positiveExponent, totalDigits);
            uint fractionalDigitsPresent = totalDigits - integerDigitsPresent;

            uint fastExponent = (uint)(Math.Abs(number.Scale - integerDigitsPresent - fractionalDigitsPresent));

            // When the number of significant digits is less than or equal to 15 and the
            // scale is less than or equal to 22, we can take some shortcuts and just rely
            // on floating-point arithmetic to compute the correct result. This is
            // because each floating-point precision values allows us to exactly represent
            // different whole integers and certain powers of 10, depending on the underlying
            // formats exact range. Additionally, IEEE operations dictate that the result is
            // computed to the infinitely precise result and then rounded, which means that
            // we can rely on it to produce the correct result when both inputs are exact.

            byte* src = number.GetDigitsPointer();

            if ((info.DenormalMantissaBits == 23) && (totalDigits <= 7) && (fastExponent <= 10))
            {
                // It is only valid to do this optimization for single-precision floating-point
                // values since we can lose some of the mantissa bits and would return the
                // wrong value when upcasting to double.

                float result = DigitsToUInt32(src, (int)(totalDigits));
                float scale = s_Pow10SingleTable[fastExponent];

                if (fractionalDigitsPresent != 0)
                {
                    result /= scale;
                }
                else
                {
                    result *= scale;
                }

                return (uint)(SingleToInt32Bits(result));
            }

            if ((totalDigits <= 15) && (fastExponent <= 22))
            {
                double result = DigitsToUInt64(src, (int)(totalDigits));
                double scale = s_Pow10DoubleTable[fastExponent];

                if (fractionalDigitsPresent != 0)
                {
                    result /= scale;
                }
                else
                {
                    result *= scale;
                }

                if (info.DenormalMantissaBits == 52)
                {
                    return (ulong)(BitConverter.DoubleToInt64Bits(result));
                }
                else
                {
                    Debug.Assert(info.DenormalMantissaBits == 23);
                    return (uint)(SingleToInt32Bits((float)(result)));
                }
            }

            return NumberToFloatingPointBitsSlow(ref number, in info, positiveExponent, integerDigitsPresent, fractionalDigitsPresent);
        }

        private static ulong NumberToFloatingPointBitsSlow(ref NumberBuffer number, in FloatingPointInfo info, uint positiveExponent, uint integerDigitsPresent, uint fractionalDigitsPresent)
        {
            // To generate an N bit mantissa we require N + 1 bits of precision.  The
            // extra bit is used to correctly round the mantissa (if there are fewer bits
            // than this available, then that's totally okay; in that case we use what we
            // have and we don't need to round).
            uint requiredBitsOfPrecision = (uint)(info.NormalMantissaBits + 1);

            uint totalDigits = (uint)(number.DigitsCount);
            uint integerDigitsMissing = positiveExponent - integerDigitsPresent;

            const uint IntegerFirstIndex = 0;
            uint integerLastIndex = integerDigitsPresent;

            uint fractionalFirstIndex = integerLastIndex;
            uint fractionalLastIndex = totalDigits;

            // First, we accumulate the integer part of the mantissa into a big_integer:
            AccumulateDecimalDigitsIntoBigInteger(ref number, IntegerFirstIndex, integerLastIndex, out BigInteger integerValue);

            if (integerDigitsMissing > 0)
            {
                if (integerDigitsMissing > info.OverflowDecimalExponent)
                {
                    return info.InfinityBits;
                }

                integerValue.MultiplyPow10(integerDigitsMissing);
            }

            // At this point, the integer_value contains the value of the integer part
            // of the mantissa.  If either [1] this number has more than the required
            // number of bits of precision or [2] the mantissa has no fractional part,
            // then we can assemble the result immediately:
            uint integerBitsOfPrecision = BigInteger.CountSignificantBits(ref integerValue);

            if ((integerBitsOfPrecision >= requiredBitsOfPrecision) || (fractionalDigitsPresent == 0))
            {
                return ConvertBigIntegerToFloatingPointBits(
                    ref integerValue,
                    in info,
                    integerBitsOfPrecision,
                    fractionalDigitsPresent != 0
                );
            }

            // Otherwise, we did not get enough bits of precision from the integer part,
            // and the mantissa has a fractional part.  We parse the fractional part of
            // the mantissa to obtain more bits of precision.  To do this, we convert
            // the fractional part into an actual fraction N/M, where the numerator N is
            // computed from the digits of the fractional part, and the denominator M is
            // computed as the power of 10 such that N/M is equal to the value of the
            // fractional part of the mantissa.

            uint fractionalDenominatorExponent = fractionalDigitsPresent;

            if (number.Scale < 0)
            {
                fractionalDenominatorExponent += (uint)(-number.Scale);
            }

            if ((integerBitsOfPrecision == 0) && (fractionalDenominatorExponent - (int)(totalDigits)) > info.OverflowDecimalExponent)
            {
                // If there were any digits in the integer part, it is impossible to
                // underflow (because the exponent cannot possibly be small enough),
                // so if we underflow here it is a true underflow and we return zero.
                return info.ZeroBits;
            }

            AccumulateDecimalDigitsIntoBigInteger(ref number, fractionalFirstIndex, fractionalLastIndex, out BigInteger fractionalNumerator);

            if (fractionalNumerator.IsZero())
            {
                return ConvertBigIntegerToFloatingPointBits(
                    ref integerValue,
                    in info,
                    integerBitsOfPrecision,
                    fractionalDigitsPresent != 0
                );
            }

            BigInteger.Pow10(fractionalDenominatorExponent, out BigInteger fractionalDenominator);

            // Because we are using only the fractional part of the mantissa here, the
            // numerator is guaranteed to be smaller than the denominator.  We normalize
            // the fraction such that the most significant bit of the numerator is in
            // the same position as the most significant bit in the denominator.  This
            // ensures that when we later shift the numerator N bits to the left, we
            // will produce N bits of precision.
            uint fractionalNumeratorBits = BigInteger.CountSignificantBits(ref fractionalNumerator);
            uint fractionalDenominatorBits = BigInteger.CountSignificantBits(ref fractionalDenominator);

            uint fractionalShift = 0;

            if (fractionalDenominatorBits > fractionalNumeratorBits)
            {
                fractionalShift = fractionalDenominatorBits - fractionalNumeratorBits;
            }

            if (fractionalShift > 0)
            {
                fractionalNumerator.ShiftLeft(fractionalShift);
            }

            uint requiredFractionalBitsOfPrecision = requiredBitsOfPrecision - integerBitsOfPrecision;
            uint remainingBitsOfPrecisionRequired = requiredFractionalBitsOfPrecision;

            if (integerBitsOfPrecision > 0)
            {
                // If the fractional part of the mantissa provides no bits of precision
                // and cannot affect rounding, we can just take whatever bits we got from
                // the integer part of the mantissa.  This is the case for numbers like
                // 5.0000000000000000000001, where the significant digits of the fractional
                // part start so far to the right that they do not affect the floating
                // point representation.
                //
                // If the fractional shift is exactly equal to the number of bits of
                // precision that we require, then no fractional bits will be part of the
                // result, but the result may affect rounding.  This is e.g. the case for
                // large, odd integers with a fractional part greater than or equal to .5.
                // Thus, we need to do the division to correctly round the result.
                if (fractionalShift > remainingBitsOfPrecisionRequired)
                {
                    return ConvertBigIntegerToFloatingPointBits(
                        ref integerValue,
                        in info,
                        integerBitsOfPrecision,
                        fractionalDigitsPresent != 0
                    );
                }

                remainingBitsOfPrecisionRequired -= fractionalShift;
            }

            // If there was no integer part of the mantissa, we will need to compute the
            // exponent from the fractional part.  The fractional exponent is the power
            // of two by which we must multiply the fractional part to move it into the
            // range [1.0, 2.0).  This will either be the same as the shift we computed
            // earlier, or one greater than that shift:
            uint fractionalExponent = fractionalShift;

            if (BigInteger.Compare(ref fractionalNumerator, ref fractionalDenominator) < 0)
            {
                fractionalExponent++;
            }

            fractionalNumerator.ShiftLeft(remainingBitsOfPrecisionRequired);

            BigInteger.DivRem(ref fractionalNumerator, ref fractionalDenominator, out BigInteger bigFractionalMantissa, out BigInteger fractionalRemainder);
            ulong fractionalMantissa = bigFractionalMantissa.ToUInt64();
            bool hasZeroTail = !number.HasNonZeroTail && fractionalRemainder.IsZero();

            // We may have produced more bits of precision than were required.  Check,
            // and remove any "extra" bits:
            uint fractionalMantissaBits = BigInteger.CountSignificantBits(fractionalMantissa);

            if (fractionalMantissaBits > requiredFractionalBitsOfPrecision)
            {
                int shift = (int)(fractionalMantissaBits - requiredFractionalBitsOfPrecision);
                hasZeroTail = hasZeroTail && (fractionalMantissa & ((1UL << shift) - 1)) == 0;
                fractionalMantissa >>= shift;
            }

            // Compose the mantissa from the integer and fractional parts:
            ulong integerMantissa = integerValue.ToUInt64();
            ulong completeMantissa = (integerMantissa << (int)(requiredFractionalBitsOfPrecision)) + fractionalMantissa;

            // Compute the final exponent:
            // * If the mantissa had an integer part, then the exponent is one less than
            //   the number of bits we obtained from the integer part.  (It's one less
            //   because we are converting to the form 1.11111, with one 1 to the left
            //   of the decimal point.)
            // * If the mantissa had no integer part, then the exponent is the fractional
            //   exponent that we computed.
            // Then, in both cases, we subtract an additional one from the exponent, to
            // account for the fact that we've generated an extra bit of precision, for
            // use in rounding.
            int finalExponent = (integerBitsOfPrecision > 0) ? (int)(integerBitsOfPrecision) - 2 : -(int)(fractionalExponent) - 1;

            return AssembleFloatingPointBits(in info, completeMantissa, finalExponent, hasZeroTail);
        }

        private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail)
        {
            // If we'd need to shift further than it is possible to shift, the answer
            // is always zero:
            if (shift >= 64)
            {
                return 0;
            }

            ulong extraBitsMask = (1UL << (shift - 1)) - 1;
            ulong roundBitMask = (1UL << (shift - 1));
            ulong lsbBitMask = 1UL << shift;

            bool lsbBit = (value & lsbBitMask) != 0;
            bool roundBit = (value & roundBitMask) != 0;
            bool hasTailBits = !hasZeroTail || (value & extraBitsMask) != 0;

            return (value >> shift) + (ShouldRoundUp(lsbBit, roundBit, hasTailBits) ? 1UL : 0);
        }

        private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits)
        {
            // If there are insignificant set bits, we need to round to the
            // nearest; there are two cases:
            // we round up if either [1] the value is slightly greater than the midpoint
            // between two exactly representable values or [2] the value is exactly the
            // midpoint between two exactly representable values and the greater of the
            // two is even (this is "round-to-even").
            return roundBit && (hasTailBits || lsbBit);
        }
    }
}


================================================
FILE: src/ZString/Number/NumberFormatInfoEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace System
{
    internal static class NumberFormatInfoEx
    {
        internal static bool HasInvariantNumberSigns(this NumberFormatInfo info)
        {
            return info.PositiveSign == "+" && info.NegativeSign == "-";
        }
    }
}



================================================
FILE: src/ZString/Number/ValueStringBuilder.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Text
{
    internal ref partial struct ValueStringBuilder
    {
        private char[]? _arrayToReturnToPool;
        private Span<char> _chars;
        private int _pos;

        public ValueStringBuilder(Span<char> initialBuffer)
        {
            _arrayToReturnToPool = null;
            _chars = initialBuffer;
            _pos = 0;
        }

        public ValueStringBuilder(int initialCapacity)
        {
            _arrayToReturnToPool = ArrayPool<char>.Shared.Rent(initialCapacity);
            _chars = _arrayToReturnToPool;
            _pos = 0;
        }

        public int Length
        {
            get => _pos;
            set
            {
                Debug.Assert(value >= 0);
                Debug.Assert(value <= _chars.Length);
                _pos = value;
            }
        }

        public int Capacity => _chars.Length;

        public void EnsureCapacity(int capacity)
        {
            if (capacity > _chars.Length)
            {
                Grow(capacity - _pos);
            }
        }

        /// <summary>
        /// Get a pinnable reference to the builder.
        /// Does not ensure there is a null char after <see cref="Length"/>
        /// This overload is pattern matched in the C# 7.3+ compiler so you can omit
        /// the explicit method call, and write eg "fixed (char* c = builder)"
        /// </summary>
        public ref char GetPinnableReference()
        {
            return ref MemoryMarshal.GetReference(_chars);
        }

        /// <summary>
        /// Get a pinnable reference to the builder.
        /// </summary>
        /// <param name="terminate">Ensures that the builder has a null char after <see cref="Length"/></param>
        public ref char GetPinnableReference(bool terminate)
        {
            if (terminate)
            {
                EnsureCapacity(Length + 1);
                _chars[Length] = '\0';
            }
            return ref MemoryMarshal.GetReference(_chars);
        }

        public ref char this[int index]
        {
            get
            {
                Debug.Assert(index < _pos);
                return ref _chars[index];
            }
        }

        public override string ToString()
        {
            string s = _chars.Slice(0, _pos).ToString();
            Dispose();
            return s;
        }

        /// <summary>Returns the underlying storage of the builder.</summary>
        public Span<char> RawChars => _chars;

        /// <summary>
        /// Returns a span around the contents of the builder.
        /// </summary>
        /// <param name="terminate">Ensures that the builder has a null char after <see cref="Length"/></param>
        public ReadOnlySpan<char> AsSpan(bool terminate)
        {
            if (terminate)
            {
                EnsureCapacity(Length + 1);
                _chars[Length] = '\0';
            }
            return _chars.Slice(0, _pos);
        }

        public ReadOnlySpan<char> AsSpan() => _chars.Slice(0, _pos);
        public ReadOnlySpan<char> AsSpan(int start) => _chars.Slice(start, _pos - start);
        public ReadOnlySpan<char> AsSpan(int start, int length) => _chars.Slice(start, length);

        public bool TryCopyTo(Span<char> destination, out int charsWritten)
        {
            if (_chars.Slice(0, _pos).TryCopyTo(destination))
            {
                charsWritten = _pos;
                Dispose();
                return true;
            }
            else
            {
                charsWritten = 0;
                Dispose();
                return false;
            }
        }

        public void Insert(int index, char value, int count)
        {
            if (_pos > _chars.Length - count)
            {
                Grow(count);
            }

            int remaining = _pos - index;
            _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count));
            _chars.Slice(index, count).Fill(value);
            _pos += count;
        }

        public void Insert(int index, string s)
        {
            if (s == null)
            {
                return;
            }

            int count = s.Length;

            if (_pos > (_chars.Length - count))
            {
                Grow(count);
            }

            int remaining = _pos - index;
            _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count));
            s.AsSpan().CopyTo(_chars.Slice(index));
            _pos += count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char c)
        {
            int pos = _pos;
            if ((uint)pos < (uint)_chars.Length)
            {
                _chars[pos] = c;
                _pos = pos + 1;
            }
            else
            {
                GrowAndAppend(c);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string s)
        {
            if (s == null)
            {
                return;
            }

            int pos = _pos;
            if (s.Length == 1 && (uint)pos < (uint)_chars.Length) // very common case, e.g. appending strings from NumberFormatInfo like separators, percent symbols, etc.
            {
                _chars[pos] = s[0];
                _pos = pos + 1;
            }
            else
            {
                AppendSlow(s);
            }
        }

        private void AppendSlow(string s)
        {
            int pos = _pos;
            if (pos > _chars.Length - s.Length)
            {
                Grow(s.Length);
            }

            s.AsSpan().CopyTo(_chars.Slice(pos));
            _pos += s.Length;
        }

        public void Append(char c, int count)
        {
            if (_pos > _chars.Length - count)
            {
                Grow(count);
            }

            Span<char> dst = _chars.Slice(_pos, count);
            for (int i = 0; i < dst.Length; i++)
            {
                dst[i] = c;
            }
            _pos += count;
        }

        public unsafe void Append(char* value, int length)
        {
            int pos = _pos;
            if (pos > _chars.Length - length)
            {
                Grow(length);
            }

            Span<char> dst = _chars.Slice(_pos, length);
            for (int i = 0; i < dst.Length; i++)
            {
                dst[i] = *value++;
            }
            _pos += length;
        }

        public void Append(ReadOnlySpan<char> value)
        {
            int pos = _pos;
            if (pos > _chars.Length - value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(_chars.Slice(_pos));
            _pos += value.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Span<char> AppendSpan(int length)
        {
            int origPos = _pos;
            if (origPos > _chars.Length - length)
            {
                Grow(length);
            }

            _pos = origPos + length;
            return _chars.Slice(origPos, length);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void GrowAndAppend(char c)
        {
            Grow(1);
            Append(c);
        }

        /// <summary>
        /// Resize the internal buffer either by doubling current buffer size or
        /// by adding <paramref name="additionalCapacityBeyondPos"/> to
        /// <see cref="_pos"/> whichever is greater.
        /// </summary>
        /// <param name="additionalCapacityBeyondPos">
        /// Number of chars requested beyond current position.
        /// </param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Grow(int additionalCapacityBeyondPos)
        {
            Debug.Assert(additionalCapacityBeyondPos > 0);
            Debug.Assert(_pos > _chars.Length - additionalCapacityBeyondPos, "Grow called incorrectly, no resize is needed.");

            char[] poolArray = ArrayPool<char>.Shared.Rent(Math.Max(_pos + additionalCapacityBeyondPos, _chars.Length * 2));

            _chars.Slice(0, _pos).CopyTo(poolArray);

            char[]? toReturn = _arrayToReturnToPool;
            _chars = _arrayToReturnToPool = poolArray;
            if (toReturn != null)
            {
                ArrayPool<char>.Shared.Return(toReturn);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            char[]? toReturn = _arrayToReturnToPool;
            this = default; // for safety, to avoid using pooled array if this instance is erroneously appended to again
            if (toReturn != null)
            {
                ArrayPool<char>.Shared.Return(toReturn);
            }
        }
    }
}


================================================
FILE: src/ZString/Unity/TextMeshProExtensions.cs
================================================
﻿#if ZSTRING_TEXTMESHPRO_SUPPORT
using System;
using TMPro;

namespace Cysharp.Text
{
    public static partial class TextMeshProExtensions
    {
        public static void SetText<T>(this TMP_Text text, T arg0)
        {
            using ( var sb = new Cysharp.Text.Utf16ValueStringBuilder( true ) )
            {
                sb.Append(arg0);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }
        
        public static void SetTextFormat<T0>(this TMP_Text text, string format, T0 arg0)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1>(this TMP_Text text, string format, T0 arg0, T1 arg1)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

    }
}
#endif



================================================
FILE: src/ZString/Unity/TextMeshProExtensions.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    static string CreateTypeArgument(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + x));
    }

    static string CreateParameters(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + x + " arg" + x));
    }


    static string CreateParameterNames(int i)
    {
        return string.Join(", ", Enumerable.Range(0, i).Select(x => "arg" + x));
    }
#>
#if ZSTRING_TEXTMESHPRO_SUPPORT
using System;
using TMPro;

namespace Cysharp.Text
{
    public static partial class TextMeshProExtensions
    {
        public static void SetText<T>(this TMP_Text text, T arg0)
        {
            using ( var sb = new Cysharp.Text.Utf16ValueStringBuilder( true ) )
            {
                sb.Append(arg0);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }
        
<# for(var i = 1; i <= 16; i++) { #>
        public static void SetTextFormat<<#= CreateTypeArgument(i) #>>(this TMP_Text text, string format, <#= CreateParameters(i) #>)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                sb.AppendFormat(format, <#= CreateParameterNames(i) #>);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

<# } #>
    }
}
#endif



================================================
FILE: src/ZString/Utf16/Utf16ValueStringBuilder.AppendFormat.tt
================================================
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
using System;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Appends the string returned by processing a composite format string, each format item is replaced by the string representation of arguments.</summary>
        public void AppendFormat<<#= CreateTypeArgument(i) #>>(string format, <#= CreateParameters(i) #>)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }
            
            var copyFrom = 0;
            for (int i = 0; i < format.Length; i++)
            {
                var c = format[i];
                if (c == '{')
                {
                    // escape.
                    if (i == format.Length - 1)
                    {
                        throw new FormatException("invalid format");
                    }

                    if (i != format.Length && format[i + 1] == '{')
                    {
                        var size = i - copyFrom;
                        Append(format, copyFrom, size);
                        i = i + 1; // skip escaped '{'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        var size = i - copyFrom;
                        Append(format, copyFrom, size);
                    }

                    // try to find range
                    var indexParse = FormatParser.Parse(format, i);
                    copyFrom = indexParse.LastIndex;
                    i = indexParse.LastIndex - 1;
                    switch (indexParse.Index)
                    {
<# for(var j = 0; j < i; j++) { #>
                        case <#= j #>:
                            AppendFormatInternal(arg<#= j + 1 #>, indexParse.Alignment, indexParse.FormatString, nameof(arg<#= j + 1 #>));
                            continue;
<# } #>
                        default:
                            ThrowFormatException();
                            break;
                    }
                }
                else if (c == '}')
                {
                    if (i + 1 < format.Length && format[i + 1] == '}')
                    {
                        var size = i - copyFrom;
                        Append(format, copyFrom, size);
                        i = i + 1; // skip escaped '}'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        ThrowFormatException();
                    }
                }
            }

            {
                // copy final string
                var copyLength = format.Length - copyFrom;
                if (copyLength > 0)
                {
                    Append(format, copyFrom, copyLength);
                }
            }
        }
        /// <summary>Appends the string returned by processing a composite format string, each format item is replaced by the string representation of arguments.</summary>
        public void AppendFormat<<#= CreateTypeArgument(i) #>>(ReadOnlySpan<char> format, <#= CreateParameters(i) #>)
        {            
            var copyFrom = 0;
            for (int i = 0; i < format.Length; i++)
            {
                var c = format[i];
                if (c == '{')
                {
                    // escape.
                    if (i == format.Length - 1)
                    {
                        throw new FormatException("invalid format");
                    }

                    if (i != format.Length && format[i + 1] == '{')
                    {
                        var size = i - copyFrom;
                        Append(format.Slice(copyFrom, size));
                        i = i + 1; // skip escaped '{'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        var size = i - copyFrom;
                        Append(format.Slice(copyFrom, size));
                    }

                    // try to find range
                    var indexParse = FormatParser.Parse(format, i);
                    copyFrom = indexParse.LastIndex;
                    i = indexParse.LastIndex - 1;
                    switch (indexParse.Index)
                    {
<# for(var j = 0; j < i; j++) { #>
                        case <#= j #>:
                            AppendFormatInternal(arg<#= j + 1 #>, indexParse.Alignment, indexParse.FormatString, nameof(arg<#= j + 1 #>));
                            continue;
<# } #>
                        default:
                            ThrowFormatException();
                            break;
                    }
                }
                else if (c == '}')
                {
                    if (i + 1 < format.Length && format[i + 1] == '}')
                    {
                        var size = i - copyFrom;
                        Append(format.Slice(copyFrom, size));
                        i = i + 1; // skip escaped '}'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        ThrowFormatException();
                    }
                }
            }

            {
                // copy final string
                var copyLength = format.Length - copyFrom;
                if (copyLength > 0)
                {
                    Append(format.Slice(copyFrom, copyLength));
                }
            }
        }
<# } #>
    }
}



================================================
FILE: src/ZString/Utf16/Utf16ValueStringBuilder.CreateFormatter.cs
================================================
﻿using System;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        static object? CreateFormatter(Type type)
        {
            if (type == typeof(System.SByte))
            {
                return new TryFormat<System.SByte>((System.SByte x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int16))
            {
                return new TryFormat<System.Int16>((System.Int16 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int32))
            {
                return new TryFormat<System.Int32>((System.Int32 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int64))
            {
                return new TryFormat<System.Int64>((System.Int64 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Byte))
            {
                return new TryFormat<System.Byte>((System.Byte x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt16))
            {
                return new TryFormat<System.UInt16>((System.UInt16 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt32))
            {
                return new TryFormat<System.UInt32>((System.UInt32 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt64))
            {
                return new TryFormat<System.UInt64>((System.UInt64 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Single))
            {
                return new TryFormat<System.Single>((System.Single x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Double))
            {
                return new TryFormat<System.Double>((System.Double x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.TimeSpan))
            {
                return new TryFormat<System.TimeSpan>((System.TimeSpan x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.DateTime))
            {
                return new TryFormat<System.DateTime>((System.DateTime x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.DateTimeOffset))
            {
                return new TryFormat<System.DateTimeOffset>((System.DateTimeOffset x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Decimal))
            {
                return new TryFormat<System.Decimal>((System.Decimal x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Guid))
            {
                return new TryFormat<System.Guid>((System.Guid x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Byte?))
            {
                return CreateNullableFormatter<System.Byte>();
            }
            if (type == typeof(System.DateTime?))
            {
                return CreateNullableFormatter<System.DateTime>();
            }
            if (type == typeof(System.DateTimeOffset?))
            {
                return CreateNullableFormatter<System.DateTimeOffset>();
            }
            if (type == typeof(System.Decimal?))
            {
                return CreateNullableFormatter<System.Decimal>();
            }
            if (type == typeof(System.Double?))
            {
                return CreateNullableFormatter<System.Double>();
            }
            if (type == typeof(System.Int16?))
            {
                return CreateNullableFormatter<System.Int16>();
            }
            if (type == typeof(System.Int32?))
            {
                return CreateNullableFormatter<System.Int32>();
            }
            if (type == typeof(System.Int64?))
            {
                return CreateNullableFormatter<System.Int64>();
            }
            if (type == typeof(System.SByte?))
            {
                return CreateNullableFormatter<System.SByte>();
            }
            if (type == typeof(System.Single?))
            {
                return CreateNullableFormatter<System.Single>();
            }
            if (type == typeof(System.TimeSpan?))
            {
                return CreateNullableFormatter<System.TimeSpan>();
            }
            if (type == typeof(System.UInt16?))
            {
                return CreateNullableFormatter<System.UInt16>();
            }
            if (type == typeof(System.UInt32?))
            {
                return CreateNullableFormatter<System.UInt32>();
            }
            if (type == typeof(System.UInt64?))
            {
                return CreateNullableFormatter<System.UInt64>();
            }
            if (type == typeof(System.Guid?))
            {
                return CreateNullableFormatter<System.Guid>();
            }
            if (type == typeof(System.Boolean?))
            {
                return CreateNullableFormatter<System.Boolean>();
            }
            if (type == typeof(System.IntPtr))
            {
                return new TryFormat<System.IntPtr>((System.IntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format) => System.IntPtr.Size == 4
                    ? x.ToInt32().TryFormat(dest, out written, format)
                    : x.ToInt64().TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UIntPtr))
            {
                return new TryFormat<System.UIntPtr>((System.UIntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format) => System.UIntPtr.Size == 4
                    ? x.ToUInt32().TryFormat(dest, out written, format)
                    : x.ToUInt64().TryFormat(dest, out written, format));
            }
            return null;
        }
    }
}


================================================
FILE: src/ZString/Utf16/Utf16ValueStringBuilder.CreateFormatter.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
<#
    var spanFormattablesA = new Type[]
    {
        typeof(SByte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
    };
    var spanFormattablesB = new Type[]
    {
        typeof(Byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
    };
    var spanFormattablesC = new Type[]
    {
        typeof(Single),
        typeof(Double),
        typeof(TimeSpan),
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(Decimal),
        typeof(Guid),
    };
#>
using System;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        static object CreateFormatter(Type type)
        {
<# foreach(var t in spanFormattablesA) { #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
<# } #>
<# foreach(var t in spanFormattablesB) { #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
<# } #>
<# foreach(var t in spanFormattablesC) { #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
<# } #>
<# foreach(var t in spanFormattables.Append(typeof(bool))) { #>
            if (type == typeof(<#= t.FullName #>?))
            {
                return CreateNullableFormatter<<#= t.FullName #>>();
            }
<# } #>
<# foreach(var t in new [] {typeof(IntPtr), typeof(UIntPtr)}) { var u = t == typeof(UIntPtr);  #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<char> dest, out int written, ReadOnlySpan<char> format) => <#= t #>.Size == 4
                    ? x.To<#= u ? "U" : "" #>Int32().TryFormat(dest, out written, format)
                    : x.To<#= u ? "U" : "" #>Int64().TryFormat(dest, out written, format));
            }
<# } #>
            return null;
        }
    }
}


================================================
FILE: src/ZString/Utf16/Utf16ValueStringBuilder.SpanFormattableAppend.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value, string format)
        {
            Append(value, format);
            AppendLine();
        }
    }
}



================================================
FILE: src/ZString/Utf16/Utf16ValueStringBuilder.SpanFormattableAppend.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
using System;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
<# foreach(var t in spanFormattables) { #>
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(<#= t.FullName #> value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(<#= t.FullName #> value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(<#= t.FullName #> value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(<#= t.FullName #> value, string format)
        {
            Append(value, format);
            AppendLine();
        }
<# } #>
    }
}



================================================
FILE: src/ZString/Utf8/Utf8ValueStringBuilder.AppendFormat.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
using System;
using System.Buffers;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Appends the string returned by processing a composite format string, each format item is replaced by the string representation of arguments.</summary>
        public void AppendFormat<<#= CreateTypeArgument(i) #>>(string format, <#= CreateParameters(i) #>)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }
            
            var copyFrom = 0;
            for (int i = 0; i < format.Length; i++)
            {
                var c = format[i];
                if (c == '{')
                {
                    // escape.
                    if (i == format.Length - 1)
                    {
                        throw new FormatException("invalid format");
                    }

                    if (i != format.Length && format[i + 1] == '{')
                    {
                        var size = i - copyFrom;
                        Append(format, copyFrom, size);
                        i = i + 1; // skip escaped '{'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        var size = i - copyFrom;
                        Append(format.AsSpan(copyFrom, size));
                    }

                    // try to find range
                    var indexParse = FormatParser.Parse(format, i);
                    copyFrom = indexParse.LastIndex;
                    i = indexParse.LastIndex - 1;
                    var writeFormat = StandardFormat.Parse(indexParse.FormatString);
                    switch (indexParse.Index)
                    {
<# for(var j = 0; j < i; j++) { #>
                        case <#= j #>:
                            AppendFormatInternal(arg<#= j + 1 #>, indexParse.Alignment, writeFormat, nameof(arg<#= j + 1 #>));
                            continue;
<# } #>
                        default:
                            ThrowFormatException();
                            break;
                    }
                }
                else if (c == '}')
                {
                    if (i + 1 < format.Length && format[i + 1] == '}')
                    {
                        var size = i - copyFrom;
                        Append(format, copyFrom, size);
                        i = i + 1; // skip escaped '}'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        ThrowFormatException();
                    }
                }

            }

            {
                // copy final string
                var copyLength = format.Length - copyFrom;
                if (copyLength > 0)
                {
                    Append(format, copyFrom, copyLength);
                }
            }
        }

<# } #>
    }
}



================================================
FILE: src/ZString/Utf8/Utf8ValueStringBuilder.CreateFormatter.cs
================================================
﻿using System;
using System.Buffers;
using System.Buffers.Text;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
        static object? CreateFormatter(Type type)
        {
            if (type == typeof(System.Byte))
            {
                return new TryFormat<System.Byte>((System.Byte x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.DateTime))
            {
                return new TryFormat<System.DateTime>((System.DateTime x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.DateTimeOffset))
            {
                return new TryFormat<System.DateTimeOffset>((System.DateTimeOffset x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Decimal))
            {
                return new TryFormat<System.Decimal>((System.Decimal x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Double))
            {
                return new TryFormat<System.Double>((System.Double x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int16))
            {
                return new TryFormat<System.Int16>((System.Int16 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int32))
            {
                return new TryFormat<System.Int32>((System.Int32 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int64))
            {
                return new TryFormat<System.Int64>((System.Int64 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.SByte))
            {
                return new TryFormat<System.SByte>((System.SByte x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Single))
            {
                return new TryFormat<System.Single>((System.Single x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.TimeSpan))
            {
                return new TryFormat<System.TimeSpan>((System.TimeSpan x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt16))
            {
                return new TryFormat<System.UInt16>((System.UInt16 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt32))
            {
                return new TryFormat<System.UInt32>((System.UInt32 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt64))
            {
                return new TryFormat<System.UInt64>((System.UInt64 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Guid))
            {
                return new TryFormat<System.Guid>((System.Guid x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Boolean))
            {
                return new TryFormat<System.Boolean>((System.Boolean x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Byte?))
            {
                return CreateNullableFormatter<System.Byte>();
            }
            if (type == typeof(System.DateTime?))
            {
                return CreateNullableFormatter<System.DateTime>();
            }
            if (type == typeof(System.DateTimeOffset?))
            {
                return CreateNullableFormatter<System.DateTimeOffset>();
            }
            if (type == typeof(System.Decimal?))
            {
                return CreateNullableFormatter<System.Decimal>();
            }
            if (type == typeof(System.Double?))
            {
                return CreateNullableFormatter<System.Double>();
            }
            if (type == typeof(System.Int16?))
            {
                return CreateNullableFormatter<System.Int16>();
            }
            if (type == typeof(System.Int32?))
            {
                return CreateNullableFormatter<System.Int32>();
            }
            if (type == typeof(System.Int64?))
            {
                return CreateNullableFormatter<System.Int64>();
            }
            if (type == typeof(System.SByte?))
            {
                return CreateNullableFormatter<System.SByte>();
            }
            if (type == typeof(System.Single?))
            {
                return CreateNullableFormatter<System.Single>();
            }
            if (type == typeof(System.TimeSpan?))
            {
                return CreateNullableFormatter<System.TimeSpan>();
            }
            if (type == typeof(System.UInt16?))
            {
                return CreateNullableFormatter<System.UInt16>();
            }
            if (type == typeof(System.UInt32?))
            {
                return CreateNullableFormatter<System.UInt32>();
            }
            if (type == typeof(System.UInt64?))
            {
                return CreateNullableFormatter<System.UInt64>();
            }
            if (type == typeof(System.Guid?))
            {
                return CreateNullableFormatter<System.Guid>();
            }
            if (type == typeof(System.Boolean?))
            {
                return CreateNullableFormatter<System.Boolean>();
            }
            if (type == typeof(System.IntPtr))
            {
                return new TryFormat<System.IntPtr>((System.IntPtr x, Span<byte> dest, out int written, StandardFormat format) => System.IntPtr.Size == 4
                    ? Utf8Formatter.TryFormat(x.ToInt32(),  dest, out written, format)
                    : Utf8Formatter.TryFormat(x.ToInt64(),  dest, out written, format));
            }
            if (type == typeof(System.UIntPtr))
            {
                return new TryFormat<System.UIntPtr>((System.UIntPtr x, Span<byte> dest, out int written, StandardFormat format) => System.UIntPtr.Size == 4
                    ? Utf8Formatter.TryFormat(x.ToUInt32(),  dest, out written, format)
                    : Utf8Formatter.TryFormat(x.ToUInt64(),  dest, out written, format));
            }

            return null;
        }
    }
}


================================================
FILE: src/ZString/Utf8/Utf8ValueStringBuilder.CreateFormatter.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
using System;
using System.Buffers;
using System.Buffers.Text;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
        static object CreateFormatter(Type type)
        {
<# foreach(var t in utf8spanFormattables) { #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
<# } #>
<# foreach(var t in utf8spanFormattables) { #>
            if (type == typeof(<#= t.FullName #>?))
            {
                return CreateNullableFormatter<<#= t.FullName #>>();
            }
<# } #>
<# foreach(var t in new [] {typeof(IntPtr), typeof(UIntPtr)} ) { var u = t == typeof(UIntPtr);  #>
            if (type == typeof(<#= t.FullName #>))
            {
                return new TryFormat<<#= t.FullName #>>((<#= t.FullName #> x, Span<byte> dest, out int written, StandardFormat format) => <#= t #>.Size == 4
                    ? Utf8Formatter.TryFormat(x.To<#= u ? "U" : "" #>Int32(),  dest, out written, format)
                    : Utf8Formatter.TryFormat(x.To<#= u ? "U" : "" #>Int64(),  dest, out written, format));
            }
<# } #>

            return null;
        }
    }
}


================================================
FILE: src/ZString/Utf8/Utf8ValueStringBuilder.SpanFormattableAppend.cs
================================================
﻿using System;
using System.Buffers;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Boolean value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Boolean value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Boolean value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Boolean value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

    }
}



================================================
FILE: src/ZString/Utf8/Utf8ValueStringBuilder.SpanFormattableAppend.tt
================================================
﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../T4Common.t4" once="true" #>
using System;
using System.Buffers;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
<# foreach(var t in utf8spanFormattables) { #>
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(<#= t.FullName #> value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(<#= t.FullName #> value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(<#= t.FullName #> value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(<#= t.FullName #> value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

<# } #>
    }
}



================================================
FILE: src/ZString.Unity/.vsconfig
================================================
﻿{
  "version": "1.0",
  "components": [
    "Microsoft.VisualStudio.Workload.ManagedGame"
  ]
}



================================================
FILE: src/ZString.Unity/Assets/Plugins.meta
================================================
fileFormatVersion: 2
guid: 7ddd3a1ff295f1440982cd97100549a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Resources.meta
================================================
fileFormatVersion: 2
guid: 16211642873b4344cb240f8630e96980
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scenes.meta
================================================
fileFormatVersion: 2
guid: 3e4672a57ce755a44805bc58b4ddea29
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts.meta
================================================
fileFormatVersion: 2
guid: 9add6c3081c1e8a4087afc4921eff3b7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Plugins/System.Runtime.CompilerServices.Unsafe.dll.meta
================================================
fileFormatVersion: 2
guid: faa5df203ffb85e4e81c6230b4bf1025
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Resources/BillingMode.json
================================================
{"androidStore":"GooglePlay"}


================================================
FILE: src/ZString.Unity/Assets/Resources/BillingMode.json.meta
================================================
fileFormatVersion: 2
guid: 4b42856c7aa4be24ba4a8f35e99b41d5
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scenes/SampleScene.unity
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 3
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 0
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 0
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 500
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 500
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 2
    m_PVRDenoiserTypeDirect: 0
    m_PVRDenoiserTypeIndirect: 0
    m_PVRDenoiserTypeAO: 0
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 0
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_UseShadowmask: 1
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &519420028
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 519420032}
  - component: {fileID: 519420031}
  - component: {fileID: 519420029}
  - component: {fileID: 519420030}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!81 &519420029
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
--- !u!114 &519420030
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: af7cb41eb6ddb6944ae4c758581eb5bc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  buttonA: {fileID: 1550728148}
--- !u!20 &519420031
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 2
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 1
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 0
  m_HDR: 1
  m_AllowMSAA: 0
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 0
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &519420032
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 519420028}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &558967754
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 558967755}
  - component: {fileID: 558967757}
  - component: {fileID: 558967756}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &558967755
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 558967754}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1550728147}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &558967756
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 558967754}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 14
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 10
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: Button
--- !u!222 &558967757
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 558967754}
  m_CullTransparentMesh: 0
--- !u!1 &1160431369
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1160431373}
  - component: {fileID: 1160431372}
  - component: {fileID: 1160431371}
  - component: {fileID: 1160431370}
  m_Layer: 5
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &1160431370
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1160431369}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &1160431371
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1160431369}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
--- !u!223 &1160431372
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1160431369}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_AdditionalShaderChannelsFlag: 0
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!224 &1160431373
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1160431369}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_Children:
  - {fileID: 1550728147}
  m_Father: {fileID: 0}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!1 &1550728146
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1550728147}
  - component: {fileID: 1550728150}
  - component: {fileID: 1550728149}
  - component: {fileID: 1550728148}
  m_Layer: 5
  m_Name: Button
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1550728147
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1550728146}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 558967755}
  m_Father: {fileID: 1160431373}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: -95, y: 171}
  m_SizeDelta: {x: 160, y: 30}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1550728148
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1550728146}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 1550728149}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!114 &1550728149
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1550728146}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &1550728150
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1550728146}
  m_CullTransparentMesh: 0
--- !u!1 &2082585984
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2082585987}
  - component: {fileID: 2082585986}
  - component: {fileID: 2082585985}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &2082585985
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2082585984}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &2082585986
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2082585984}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!4 &2082585987
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2082585984}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}



================================================
FILE: src/ZString.Unity/Assets/Scenes/SampleScene.unity.meta
================================================
fileFormatVersion: 2
guid: 2cda990e2423bbf4892e6590ba056729
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scenes/Test.cs
================================================
﻿
using Cysharp.Text;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.UI;

public class Test : MonoBehaviour
{
    public Button buttonA;

    private void Start()
    {
        buttonA.onClick.AddListener(() =>
        {
            int COUNT = 1000;
            List<string> strings = new List<string>();
            for (int i = 0; i < 100; i++)
                strings.Add("123456789");


            Profiler.BeginSample("Append/ZString.StringBuilder()");
            for (int i = 0; i < COUNT; i++)
            {
                using (var sb = ZString.CreateStringBuilder(true))
                {
                    for (int j = 0; j < strings.Count; j++)
                    {
                        sb.Append(strings[j]);
                    }

                    sb.ToString();
                }
            }
            Profiler.EndSample();


            Profiler.BeginSample("Append/SharedStringBuilderScope()");
            {
                for (int i = 0; i < COUNT; i++)
                {
                    System.Text.StringBuilder sb = new System.Text.StringBuilder();
                    for (int j = 0; j < strings.Count; j++)
                    {
                        sb.Append(strings[j]);
                    }

                    sb.ToString();
                    // sb.Clear();
                }
            }
            Profiler.EndSample();
        });
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scenes/Test.cs.meta
================================================
fileFormatVersion: 2
guid: af7cb41eb6ddb6944ae4c758581eb5bc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/Editor.meta
================================================
fileFormatVersion: 2
guid: fa1e5939638a14f4fa4681331ef65430
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString.meta
================================================
fileFormatVersion: 2
guid: 1260d4de3d15f5a45a5ef60c7fd826f0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/Editor/PackageExporter.cs
================================================
﻿using System;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

public static class PackageExporter
{
    [MenuItem("Tools/Export Unitypackage")]
    public static void Export()
    {
        var root = "Scripts/ZString";
        var version = GetVersion(root);

        var fileName = string.IsNullOrEmpty(version) ? "ZString.Unity.unitypackage" : $"ZString.Unity.{version}.unitypackage";
        var exportPath = "./" + fileName;

        var path = Path.Combine(Application.dataPath, root);
        var assets = Directory.EnumerateFiles(path, "*", SearchOption.AllDirectories)
            .Where(x => Path.GetExtension(x) == ".cs" || Path.GetExtension(x) == ".meta" || Path.GetExtension(x) == ".asmdef" || Path.GetExtension(x) == ".rsp")
            .Where(x => Path.GetFileNameWithoutExtension(x) != "_InternalVisibleTo")
            .Select(x => "Assets" + x.Replace(Application.dataPath, "").Replace(@"\", "/"))
            .ToArray();

        var netStandardsAsset = Directory.EnumerateFiles(Path.Combine(Application.dataPath, "Plugins/"), "*", SearchOption.AllDirectories)
            .Select(x => "Assets" + x.Replace(Application.dataPath, "").Replace(@"\", "/"))
            .ToArray();

        assets = assets.Concat(netStandardsAsset).ToArray();

        UnityEngine.Debug.Log("Export below files" + Environment.NewLine + string.Join(Environment.NewLine, assets));

        var dir = new FileInfo(exportPath).Directory;
        if (!dir.Exists) dir.Create();
        AssetDatabase.ExportPackage(
            assets,
            exportPath,
            ExportPackageOptions.Default);

        UnityEngine.Debug.Log("Export complete: " + Path.GetFullPath(exportPath));
    }

    static string GetVersion(string root)
    {
        var version = Environment.GetEnvironmentVariable("UNITY_PACKAGE_VERSION");
        var versionJson = Path.Combine(Application.dataPath, root, "package.json");

        if (File.Exists(versionJson))
        {
            var v = JsonUtility.FromJson<Version>(File.ReadAllText(versionJson));

            if (!string.IsNullOrEmpty(version))
            {
                if (v.version != version)
                {
                    var msg = $"package.json and env version are mismatched. UNITY_PACKAGE_VERSION:{version}, package.json:{v.version}";

                    if (Application.isBatchMode)
                    {
                        Console.WriteLine(msg);
                        Application.Quit(1);
                    }

                    throw new Exception("package.json and env version are mismatched.");
                }
            }

            version = v.version;
        }

        return version;
    }

    public class Version
    {
        public string version;
    }

}


================================================
FILE: src/ZString.Unity/Assets/Scripts/Editor/PackageExporter.cs.meta
================================================
fileFormatVersion: 2
guid: 0104ef67be3b9ca498ff698ad4e0bd71
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/csc.rsp
================================================
-nullable:enable


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/csc.rsp.meta
================================================
fileFormatVersion: 2
guid: 0b81dbb099c31f4448d950b4576ad6eb
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/EnumUtil.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class EnumUtil<T>
        // where T : Enum
    {
        const string InvalidName = "$";

        static readonly Dictionary<T, string> names;
        static readonly Dictionary<T, byte[]> utf8names;

        static EnumUtil()
        {
            var enumNames = Enum.GetNames(typeof(T));
            var values =
#if NET7_0_OR_GREATER
                Enum.GetValuesAsUnderlyingType(typeof(T));
#else
                Enum.GetValues(typeof(T));
#endif
            names = new Dictionary<T, string>(enumNames.Length);
            utf8names = new Dictionary<T, byte[]>(enumNames.Length);
            for (int i = 0; i < enumNames.Length; i++)
            {
                var value = (T)values.GetValue(i)!;
                if (names.ContainsKey(value))
                {
                    // already registered = invalid.
                    names[value] = InvalidName;
                    utf8names[value] = Array.Empty<byte>(); // byte[0] == Invalid.
                }
                else
                {
                    names.Add(value, enumNames[i]);
                    utf8names.Add(value, Encoding.UTF8.GetBytes(enumNames[i]));
                }
            }
        }

        public static bool TryFormatUtf16(T value, Span<char> dest, out int written, ReadOnlySpan<char> _)
        {
            if (!names.TryGetValue(value, out var v) || v == InvalidName)
            {
                v = value!.ToString(); // T is Enum, not null always
            }

            written = v.Length;
            return v.AsSpan().TryCopyTo(dest);
        }

        public static bool TryFormatUtf8(T value, Span<byte> dest, out int written, StandardFormat _)
        {
            if (!utf8names.TryGetValue(value, out var v) || v.Length == 0)
            {
                v = Encoding.UTF8.GetBytes(value!.ToString());
            }

            written = v.Length;
            return v.AsSpan().TryCopyTo(dest);
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/EnumUtil.cs.meta
================================================
fileFormatVersion: 2
guid: d12377b4cfb6e604592941b9cdfbcc92
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ExceptionUtil.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class ExceptionUtil
    {
        internal static void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }

        internal static void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        internal static void ThrowFormatError()
        {
            throw new FormatException("Input string was not in a correct format.");
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ExceptionUtil.cs.meta
================================================
fileFormatVersion: 2
guid: c69ccd87e4d4ef74eaf019d0603195e6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FastNumberWriter.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class FastNumberWriter
    {
        // Faster than .NET Core .TryFormat without format string.

        public static bool TryWriteInt64(Span<char> buffer, out int charsWritten, long value)
        {
            var offset = 0;
            charsWritten = 0;
            long num1 = value, num2, num3, num4, num5, div;

            if (value < 0)
            {
                if (value == long.MinValue) // -9223372036854775808
                {
                    if (buffer.Length < 20) { return false; }
                    buffer[offset++] = (char)'-';
                    buffer[offset++] = (char)'9';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'2';
                    buffer[offset++] = (char)'0';
                    buffer[offset++] = (char)'3';
                    buffer[offset++] = (char)'6';
                    buffer[offset++] = (char)'8';
                    buffer[offset++] = (char)'5';
                    buffer[offset++] = (char)'4';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'7';
                    buffer[offset++] = (char)'5';
                    buffer[offset++] = (char)'8';
                    buffer[offset++] = (char)'0';
                    buffer[offset++] = (char)'8';
                    charsWritten = offset;
                    return true;
                }

                if (buffer.Length < 1) { return false; }
                buffer[offset++] = (char)'-';
                num1 = unchecked(-value);
            }

            // WriteUInt64(inlined)

            if (num1 < 10000)
            {
                if (num1 < 10) { if (buffer.Length < 1) { return false; } goto L1; }
                if (num1 < 100) { if (buffer.Length < 2) { return false; } goto L2; }
                if (num1 < 1000) { if (buffer.Length < 3) { return false; } goto L3; }
                if (buffer.Length < 4) { return false; }
                goto L4;
            }
            else
            {
                num2 = num1 / 10000;
                num1 -= num2 * 10000;
                if (num2 < 10000)
                {
                    if (num2 < 10) { if (buffer.Length < 5) { return false; } goto L5; }
                    if (num2 < 100) { if (buffer.Length < 6) { return false; } goto L6; }
                    if (num2 < 1000) { if (buffer.Length < 7) { return false; } goto L7; }
                    if (buffer.Length < 8) { return false; }
                    goto L8;
                }
                else
                {
                    num3 = num2 / 10000;
                    num2 -= num3 * 10000;
                    if (num3 < 10000)
                    {
                        if (num3 < 10) { if (buffer.Length < 9) { return false; } goto L9; }
                        if (num3 < 100) { if (buffer.Length < 10) { return false; } goto L10; }
                        if (num3 < 1000) { if (buffer.Length < 11) { return false; } goto L11; }
                        if (buffer.Length < 12) { return false; }
                        goto L12;
                    }
                    else
                    {
                        num4 = num3 / 10000;
                        num3 -= num4 * 10000;
                        if (num4 < 10000)
                        {
                            if (num4 < 10) { if (buffer.Length < 13) { return false; } goto L13; }
                            if (num4 < 100) { if (buffer.Length < 14) { return false; } goto L14; }
                            if (num4 < 1000) { if (buffer.Length < 15) { return false; } goto L15; }
                            if (buffer.Length < 16) { return false; }
                            goto L16;
                        }
                        else
                        {
                            num5 = num4 / 10000;
                            num4 -= num5 * 10000;
                            if (num5 < 10000)
                            {
                                if (num5 < 10) { if (buffer.Length < 17) { return false; } goto L17; }
                                if (num5 < 100) { if (buffer.Length < 18) { return false; } goto L18; }
                                if (num5 < 1000) { if (buffer.Length < 19) { return false; } goto L19; }
                                if (buffer.Length < 20) { return false; }
                                goto L20;
                            }
                            L20:
                            buffer[offset++] = (char)('0' + (div = (num5 * 8389L) >> 23));
                            num5 -= div * 1000;
                            L19:
                            buffer[offset++] = (char)('0' + (div = (num5 * 5243L) >> 19));
                            num5 -= div * 100;
                            L18:
                            buffer[offset++] = (char)('0' + (div = (num5 * 6554L) >> 16));
                            num5 -= div * 10;
                            L17:
                            buffer[offset++] = (char)('0' + (num5));
                        }
                        L16:
                        buffer[offset++] = (char)('0' + (div = (num4 * 8389L) >> 23));
                        num4 -= div * 1000;
                        L15:
                        buffer[offset++] = (char)('0' + (div = (num4 * 5243L) >> 19));
                        num4 -= div * 100;
                        L14:
                        buffer[offset++] = (char)('0' + (div = (num4 * 6554L) >> 16));
                        num4 -= div * 10;
                        L13:
                        buffer[offset++] = (char)('0' + (num4));
                    }
                    L12:
                    buffer[offset++] = (char)('0' + (div = (num3 * 8389L) >> 23));
                    num3 -= div * 1000;
                    L11:
                    buffer[offset++] = (char)('0' + (div = (num3 * 5243L) >> 19));
                    num3 -= div * 100;
                    L10:
                    buffer[offset++] = (char)('0' + (div = (num3 * 6554L) >> 16));
                    num3 -= div * 10;
                    L9:
                    buffer[offset++] = (char)('0' + (num3));
                }
                L8:
                buffer[offset++] = (char)('0' + (div = (num2 * 8389L) >> 23));
                num2 -= div * 1000;
                L7:
                buffer[offset++] = (char)('0' + (div = (num2 * 5243L) >> 19));
                num2 -= div * 100;
                L6:
                buffer[offset++] = (char)('0' + (div = (num2 * 6554L) >> 16));
                num2 -= div * 10;
                L5:
                buffer[offset++] = (char)('0' + (num2));
            }
            L4:
            buffer[offset++] = (char)('0' + (div = (num1 * 8389L) >> 23));
            num1 -= div * 1000;
            L3:
            buffer[offset++] = (char)('0' + (div = (num1 * 5243L) >> 19));
            num1 -= div * 100;
            L2:
            buffer[offset++] = (char)('0' + (div = (num1 * 6554L) >> 16));
            num1 -= div * 10;
            L1:
            buffer[offset++] = (char)('0' + (num1));

            charsWritten = offset;
            return true;
        }

        public static bool TryWriteUInt64(Span<char> buffer, out int charsWritten, ulong value)
        {
            ulong num1 = value, num2, num3, num4, num5, div;
            charsWritten = 0;
            var offset = 0;

            if (num1 < 10000)
            {
                if (num1 < 10) { if (buffer.Length < 1) { return false; } goto L1; }
                if (num1 < 100) { if (buffer.Length < 2) { return false; } goto L2; }
                if (num1 < 1000) { if (buffer.Length < 3) { return false; } goto L3; }
                if (buffer.Length < 4) { return false; }
                goto L4;
            }
            else
            {
                num2 = num1 / 10000;
                num1 -= num2 * 10000;
                if (num2 < 10000)
                {
                    if (num2 < 10) { if (buffer.Length < 5) { return false; } goto L5; }
                    if (num2 < 100) { if (buffer.Length < 6) { return false; } goto L6; }
                    if (num2 < 1000) { if (buffer.Length < 7) { return false; } goto L7; }
                    if (buffer.Length < 8) { return false; }
                    goto L8;
                }
                else
                {
                    num3 = num2 / 10000;
                    num2 -= num3 * 10000;
                    if (num3 < 10000)
                    {
                        if (num3 < 10) { if (buffer.Length < 9) { return false; } goto L9; }
                        if (num3 < 100) { if (buffer.Length < 10) { return false; } goto L10; }
                        if (num3 < 1000) { if (buffer.Length < 11) { return false; } goto L11; }
                        if (buffer.Length < 12) { return false; }
                        goto L12;
                    }
                    else
                    {
                        num4 = num3 / 10000;
                        num3 -= num4 * 10000;
                        if (num4 < 10000)
                        {
                            if (num4 < 10) { if (buffer.Length < 13) { return false; } goto L13; }
                            if (num4 < 100) { if (buffer.Length < 14) { return false; } goto L14; }
                            if (num4 < 1000) { if (buffer.Length < 15) { return false; } goto L15; }
                            if (buffer.Length < 16) { return false; }
                            goto L16;
                        }
                        else
                        {
                            num5 = num4 / 10000;
                            num4 -= num5 * 10000;
                            if (num5 < 10000)
                            {
                                if (num5 < 10) { if (buffer.Length < 17) { return false; } goto L17; }
                                if (num5 < 100) { if (buffer.Length < 18) { return false; } goto L18; }
                                if (num5 < 1000) { if (buffer.Length < 19) { return false; } goto L19; }
                                if (buffer.Length < 20) { return false; }
                                goto L20;
                            }
                            L20:
                            buffer[offset++] = (char)('0' + (div = (num5 * 8389UL) >> 23));
                            num5 -= div * 1000;
                            L19:
                            buffer[offset++] = (char)('0' + (div = (num5 * 5243UL) >> 19));
                            num5 -= div * 100;
                            L18:
                            buffer[offset++] = (char)('0' + (div = (num5 * 6554UL) >> 16));
                            num5 -= div * 10;
                            L17:
                            buffer[offset++] = (char)('0' + (num5));
                        }
                        L16:
                        buffer[offset++] = (char)('0' + (div = (num4 * 8389UL) >> 23));
                        num4 -= div * 1000;
                        L15:
                        buffer[offset++] = (char)('0' + (div = (num4 * 5243UL) >> 19));
                        num4 -= div * 100;
                        L14:
                        buffer[offset++] = (char)('0' + (div = (num4 * 6554UL) >> 16));
                        num4 -= div * 10;
                        L13:
                        buffer[offset++] = (char)('0' + (num4));
                    }
                    L12:
                    buffer[offset++] = (char)('0' + (div = (num3 * 8389UL) >> 23));
                    num3 -= div * 1000;
                    L11:
                    buffer[offset++] = (char)('0' + (div = (num3 * 5243UL) >> 19));
                    num3 -= div * 100;
                    L10:
                    buffer[offset++] = (char)('0' + (div = (num3 * 6554UL) >> 16));
                    num3 -= div * 10;
                    L9:
                    buffer[offset++] = (char)('0' + (num3));
                }
                L8:
                buffer[offset++] = (char)('0' + (div = (num2 * 8389UL) >> 23));
                num2 -= div * 1000;
                L7:
                buffer[offset++] = (char)('0' + (div = (num2 * 5243UL) >> 19));
                num2 -= div * 100;
                L6:
                buffer[offset++] = (char)('0' + (div = (num2 * 6554UL) >> 16));
                num2 -= div * 10;
                L5:
                buffer[offset++] = (char)('0' + (num2));
            }
            L4:
            buffer[offset++] = (char)('0' + (div = (num1 * 8389UL) >> 23));
            num1 -= div * 1000;
            L3:
            buffer[offset++] = (char)('0' + (div = (num1 * 5243UL) >> 19));
            num1 -= div * 100;
            L2:
            buffer[offset++] = (char)('0' + (div = (num1 * 6554UL) >> 16));
            num1 -= div * 10;
            L1:
            buffer[offset++] = (char)('0' + (num1));

            charsWritten = offset;
            return true;
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FastNumberWriter.cs.meta
================================================
fileFormatVersion: 2
guid: dd857f99f11ce484c8a3b600614fd1d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FormatHelper.cs
================================================
﻿using System;
using System.Text;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    internal static partial class Utf16FormatHelper
    {
        const char sp = (char)' ';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName)
            where TBufferWriter : IBufferWriter<char>
        {
            if (width <= 0) // leftJustify
            {
                var span = sb.GetSpan(0);
                if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var argWritten, format))
                {
                    sb.Advance(0);
                    span = sb.GetSpan(Math.Max(span.Length + 1, argWritten));
                    if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out argWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }
                sb.Advance(argWritten);

                width *= -1;
                int padding = width - argWritten;
                if (width > 0 && padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }
            }
            else
            {
                FormatToRightJustify(ref sb, arg, width, format, argName);
            }
        }

        private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, ReadOnlySpan<char> format, string argName)
            where TBufferWriter : IBufferWriter<char>
        {
            if (typeof(T) == typeof(string))
            {
                var s = Unsafe.As<string>(arg);
                int padding = width - s.Length;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(s.Length);
                s.AsSpan().CopyTo(span);
                sb.Advance(s.Length);
            }
            else
            {
                Span<char> s = stackalloc char[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                {
                    s = stackalloc char[s.Length * 2];
                    if (!Utf16ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                int padding = width - charsWritten;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(charsWritten);
                s.CopyTo(span);
                sb.Advance(charsWritten);
            }
        }
    }

    internal static partial class Utf8FormatHelper
    {
        const byte sp = (byte)' ';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void FormatTo<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName)
            where TBufferWriter : IBufferWriter<byte>
        {
            if (width <= 0) // leftJustify
            {
                var span = sb.GetSpan(0);
                if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out var argWritten, format))
                {
                    sb.Advance(0);
                    span = sb.GetSpan(Math.Max(span.Length + 1, argWritten));
                    if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, span, out argWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }
                sb.Advance(argWritten);

                width *= -1;
                int padding = width - argWritten;
                if (width > 0 && padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }
            }
            else
            {
                FormatToRightJustify(ref sb, arg, width, format, argName);
            }
        }

        private static void FormatToRightJustify<TBufferWriter, T>(ref TBufferWriter sb, T arg, int width, StandardFormat format, string argName)
            where TBufferWriter : IBufferWriter<byte>
        {
            if (typeof(T) == typeof(string))
            {
                var s = Unsafe.As<string>(arg);
                int padding = width - s.Length;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                ZString.AppendChars(ref sb, s.AsSpan());
            }
            else
            {
                Span<byte> s = stackalloc byte[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                {
                    s = stackalloc byte[s.Length * 2];
                    if (!Utf8ValueStringBuilder.FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                int padding = width - charsWritten;
                if (padding > 0)
                {
                    var paddingSpan = sb.GetSpan(padding);
                    paddingSpan.Fill(sp);
                    sb.Advance(padding);
                }

                var span = sb.GetSpan(charsWritten);
                s.CopyTo(span);
                sb.Advance(charsWritten);
            }
        }
    }

}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FormatHelper.cs.meta
================================================
fileFormatVersion: 2
guid: 4e46453b986ebf4428a5c23fb3cbb175
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FormatParser.cs
================================================
using System;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    internal static class FormatParser
    {
        // {index[,alignment][:formatString]}

        public readonly ref struct ParseResult
        {
            public readonly int Index;
            public readonly ReadOnlySpan<char> FormatString;
            public readonly int LastIndex;
            public readonly int Alignment;

            public ParseResult(int index, ReadOnlySpan<char> formatString, int lastIndex, int alignment)
            {
                Index = index;
                FormatString = formatString;
                LastIndex = lastIndex;
                Alignment = alignment;
            }
        }

        internal const int ArgLengthLimit = 16;
        internal const int WidthLimit = 1000; // Note:  -WidthLimit <  ArgAlign < WidthLimit

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParserScanResult ScanFormatString(string format, ref int i)
        {
            var len = format.Length;
            char c = format[i];

            i++; // points netxt char
            if (c == '}')
            {
                // skip escaped '}'
                if (i < len && format[i] == '}')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    ExceptionUtil.ThrowFormatError();
                    return ParserScanResult.NormalChar; // NOTE Don't reached
                }
            }
            else if (c == '{')
            {
                // skip escaped '{'
                if (i < len && format[i] == '{')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    i--;
                    return ParserScanResult.BraceOpen;
                }
            }
            else
            {
                // ch is the normal char OR end of text
                return ParserScanResult.NormalChar;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParserScanResult ScanFormatString(ReadOnlySpan<char> format, ref int i)
        {
            var len = format.Length;
            char c = format[i];

            i++; // points netxt char
            if (c == '}')
            {
                // skip escaped '}'
                if (i < len && format[i] == '}')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    ExceptionUtil.ThrowFormatError();
                    return ParserScanResult.NormalChar; // NOTE Don't reached
                }
            }
            else if (c == '{')
            {
                // skip escaped '{'
                if (i < len && format[i] == '{')
                {
                    i++;
                    return ParserScanResult.EscapedChar;
                }
                else
                {
                    i--;
                    return ParserScanResult.BraceOpen;
                }
            }
            else
            {
                // ch is the normal char OR end of text
                return ParserScanResult.NormalChar;
            }
        }

        // Accept only non-unicode numbers
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsDigit(char c) => '0' <= c && c <= '9';

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParseResult Parse(ReadOnlySpan<char> format, int i)
        {
            char c = default;
            var len = format.Length;

            i++; // Skip `{`

            //  === Index Component ===
            //   ('0'-'9')+ WS*

            if (i == len || !IsDigit(c = format[i]))
            {
                ExceptionUtil.ThrowFormatError();
            }

            int paramIndex = 0;
            do
            {
                paramIndex = (paramIndex * 10) + c - '0';

                if (++i == len)
                    ExceptionUtil.ThrowFormatError();

                c = format[i];
            }
            while (IsDigit(c) && paramIndex < ArgLengthLimit);

            if (paramIndex >= ArgLengthLimit)
            {
                ExceptionUtil.ThrowFormatException();
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Alignment Component ===
            //   comma WS* minus? ('0'-'9')+ WS*

            int alignment = 0;

            if (c == ',')
            {
                i++;

                // skip whitespace.
                while (i < len && (c = format[i]) == ' ')
                    i++;

                if (i == len)
                {
                    ExceptionUtil.ThrowFormatError();
                }

                var leftJustify = false;
                if (c == '-')
                {
                    leftJustify = true;

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }

                if (!IsDigit(c))
                {
                    ExceptionUtil.ThrowFormatError();
                }

                do
                {
                    alignment = (alignment * 10) + c - '0';

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }
                while (IsDigit(c) && alignment < WidthLimit);

                if (leftJustify)
                    alignment *= -1;
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Format String Component ===

            ReadOnlySpan<char> itemFormatSpan = default;

            if (c == ':')
            {
                i++;
                int formatStart = i;

                while (true)
                {
                    if (i == len)
                    {
                        ExceptionUtil.ThrowFormatError();
                    }
                    c = format[i];

                    if (c == '}')
                    {
                        break;
                    }
                    else if (c == '{')
                    {
                        ExceptionUtil.ThrowFormatError();
                    }

                    i++;
                }

                // has format
                if (i > formatStart)
                {
                    itemFormatSpan = format.Slice(formatStart, i - formatStart);
                }
            }
            else if (c != '}')
            {
                // Unexpected character
                ExceptionUtil.ThrowFormatError();
            }

            i++; // Skip `}`
            return new ParseResult(paramIndex, itemFormatSpan, i, alignment);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ParseResult Parse(string format, int i)
        {
            char c = default;
            var len = format.Length;

            i++; // Skip `{`

            //  === Index Component ===
            //   ('0'-'9')+ WS*

            if (i == len || !IsDigit(c = format[i]))
            {
                ExceptionUtil.ThrowFormatError();
            }

            int paramIndex = 0;
            do
            {
                paramIndex = (paramIndex * 10) + c - '0';

                if (++i == len)
                    ExceptionUtil.ThrowFormatError();

                c = format[i];
            }
            while (IsDigit(c) && paramIndex < ArgLengthLimit);

            if (paramIndex >= ArgLengthLimit)
            {
                ExceptionUtil.ThrowFormatException();
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Alignment Component ===
            //   comma WS* minus? ('0'-'9')+ WS*

            int alignment = 0;

            if (c == ',')
            {
                i++;

                // skip whitespace.
                while (i < len && (c = format[i]) == ' ')
                    i++;

                if (i == len)
                {
                    ExceptionUtil.ThrowFormatError();
                }

                var leftJustify = false;
                if (c == '-')
                {
                    leftJustify = true;

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }

                if (!IsDigit(c))
                {
                    ExceptionUtil.ThrowFormatError();
                }

                do
                {
                    alignment = (alignment * 10) + c - '0';

                    if (++i == len)
                        ExceptionUtil.ThrowFormatError();

                    c = format[i];
                }
                while (IsDigit(c) && alignment < WidthLimit);

                if (leftJustify)
                    alignment *= -1;
            }

            // skip whitespace.
            while (i < len && (c = format[i]) == ' ')
                i++;

            //  === Format String Component ===

            ReadOnlySpan<char> itemFormatSpan = default;

            if (c == ':')
            {
                i++;
                int formatStart = i;

                while (true)
                {
                    if (i == len)
                    {
                        ExceptionUtil.ThrowFormatError();
                    }
                    c = format[i];

                    if (c == '}')
                    {
                        break;
                    }
                    else if (c == '{')
                    {
                        ExceptionUtil.ThrowFormatError();
                    }

                    i++;
                }

                // has format
                if (i > formatStart)
                {
                    itemFormatSpan = format.AsSpan(formatStart, i - formatStart);
                }
            }
            else if (c != '}')
            {
                // Unexpected character
                ExceptionUtil.ThrowFormatError();
            }

            i++; // Skip `}`
            return new ParseResult(paramIndex, itemFormatSpan, i, alignment);
        }
    }

    internal enum ParserScanResult
    {
        BraceOpen,
        EscapedChar,
        NormalChar,
    }

}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/FormatParser.cs.meta
================================================
fileFormatVersion: 2
guid: a3676d0a8288bd1469a9162fec83cf5a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/IResettableBufferWriter.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    public interface IResettableBufferWriter<T> : IBufferWriter<T>
    {
        void Reset();
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/IResettableBufferWriter.cs.meta
================================================
fileFormatVersion: 2
guid: c853a6364ab3cd3489eaaab75fbb2f5b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/NestedStringBuilderCreationException.cs
================================================
using System;

namespace Cysharp.Text
{
    // Currently, this class is internals.
    internal class NestedStringBuilderCreationException : InvalidOperationException
    {
        internal protected NestedStringBuilderCreationException(string typeName, string extraMessage = "")
            : base($"A nested call with `notNested: true`, or Either You forgot to call {typeName}.Dispose() of  in the past.{extraMessage}")
        {
        }

        internal protected NestedStringBuilderCreationException(string message, Exception innerException) : base(message, innerException)
        {
        }

    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/NestedStringBuilderCreationException.cs.meta
================================================
fileFormatVersion: 2
guid: c2e6121a89e941e4d8388e6842ad3551
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number.meta
================================================
fileFormatVersion: 2
guid: 18a14422421519445bb6bd0685394b3b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/package.json
================================================
{
	"name": "com.cysharp.zstring",
	"displayName": "ZString",
	"version": "2.6.0",
	"unity": "2018.4",
	"description": "Zero Allocation StringBuilder for .NET Core and Unity.",
	"keywords": [
		"String",
		"Performance"
	],
	"license": "MIT",
	"category": "Scripting",
	"dependencies": {},
	"samples": [
		{
			"displayName": "Required Managed DLLs",
			"description": "Import Required Managed DLLs",
			"path": "Samples~/RequiredManagedDLLs"
		}
	]
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/package.json.meta
================================================
fileFormatVersion: 2
guid: ba0803434cb80a14083de2d39cc00351
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/PreparedFormat.cs.meta
================================================
fileFormatVersion: 2
guid: b2d2a7b702a661244a4045fcf67fe6ca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/PreparedFormatHelper.cs
================================================
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;

namespace Cysharp.Text
{
    internal static class PreparedFormatHelper
    {
        internal static Utf16FormatSegment[] Utf16Parse(string format)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            var list = new List<Utf16FormatSegment>();

            int i = 0;
            int len = format.Length;

            var copyFrom = 0;

            while (true)
            {
                while (i < len)
                {
                    var parserScanResult = FormatParser.ScanFormatString(format, ref i);

                    if (ParserScanResult.NormalChar == parserScanResult && i < len)
                    {
                        // skip normal char
                        continue;
                    }

                    var size = i - copyFrom;
                    if (ParserScanResult.EscapedChar == parserScanResult)
                    {
                        size--;
                    }

                    if (size != 0)
                    {
                        list.Add(new Utf16FormatSegment(copyFrom, size, Utf16FormatSegment.NotFormatIndex, 0));
                    }

                    copyFrom = i;

                    if (ParserScanResult.BraceOpen == parserScanResult)
                    {
                        break;
                    }
                }

                if (i >= len)
                {
                    break;
                }

                // Here it is before `{`.
                var indexParse = FormatParser.Parse(format, i);
                copyFrom = indexParse.LastIndex; // continue after '}'
                i = indexParse.LastIndex;

                list.Add(new Utf16FormatSegment(indexParse.LastIndex - indexParse.FormatString.Length - 1, indexParse.FormatString.Length, indexParse.Index, indexParse.Alignment));
            }

            return list.ToArray();
        }

        internal static Utf8FormatSegment[] Utf8Parse(string format, out byte[] utf8buffer)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            var list = new List<Utf8FormatSegment>();
            utf8buffer = new byte[Encoding.UTF8.GetMaxByteCount(format.Length)];
            var bufOffset = 0;

            int i = 0;
            int len = format.Length;

            var copyFrom = 0;

            while (true)
            {
                while (i < len)
                {
                    var parserScanResult = FormatParser.ScanFormatString(format, ref i);

                    if (ParserScanResult.NormalChar == parserScanResult && i < len)
                    {
                        // skip normal char
                        continue;
                    }

                    var size = i - copyFrom;
                    if (ParserScanResult.EscapedChar == parserScanResult)
                    {
                        size--;
                    }

                    if (size != 0)
                    {
                        var utf8size = Encoding.UTF8.GetBytes(format, copyFrom, size, utf8buffer, bufOffset);
                        list.Add(new Utf8FormatSegment(bufOffset, utf8size, Utf8FormatSegment.NotFormatIndex, default, 0));
                        bufOffset += utf8size;
                    }

                    copyFrom = i;

                    if (ParserScanResult.BraceOpen == parserScanResult)
                    {
                        break;
                    }
                }

                if (i >= len)
                {
                    break;
                }

                // Here it is before `{`.
                var indexParse = FormatParser.Parse(format, i);
                copyFrom = indexParse.LastIndex; // continue after '}'
                i = indexParse.LastIndex;
                list.Add(new Utf8FormatSegment(0, 0, indexParse.Index, StandardFormat.Parse(indexParse.FormatString), indexParse.Alignment));
            }

            return list.ToArray();
        }
    }

    internal readonly struct Utf8FormatSegment
    {
        public const int NotFormatIndex = -1;

        public readonly int Offset;
        public readonly int Count;
        public readonly int FormatIndex;
        public readonly StandardFormat StandardFormat;
        public readonly int Alignment;

        public bool IsFormatArgument => FormatIndex != NotFormatIndex;

        public Utf8FormatSegment(int offset, int count, int formatIndex, StandardFormat format, int alignment)
        {
            Offset = offset;
            Count = count;
            FormatIndex = formatIndex;
            StandardFormat = format;
            Alignment = alignment;
        }
    }

    internal readonly struct Utf16FormatSegment
    {
        public const int NotFormatIndex = -1;

        public readonly int Offset;
        public readonly int Count;
        public readonly int FormatIndex;
        public readonly int Alignment;

        public bool IsFormatArgument => FormatIndex != NotFormatIndex;

        public Utf16FormatSegment(int offset, int count, int formatIndex, int alignment)
        {
            Offset = offset;
            Count = count;
            FormatIndex = formatIndex;
            Alignment = alignment;
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/PreparedFormatHelper.cs.meta
================================================
fileFormatVersion: 2
guid: 97f2a4c405b87a245ac38c1755f74a3b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ReadOnlyListAdaptor.cs
================================================
﻿using System.Collections;
using System.Collections.Generic;

namespace Cysharp.Text
{
    /// <summary>
    /// Most IList interface-implementing classes implement the IReadOnlyList interface.
    /// This is for the rare class that does not implement the IList interface.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal readonly struct ReadOnlyListAdaptor<T> : IReadOnlyList<T>
    {
        readonly IList<T> _list;

        public ReadOnlyListAdaptor(IList<T> list) => _list = list;

        public T this[int index] => _list[index];

        public int Count => _list.Count;

        public IEnumerator<T> GetEnumerator() => _list.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ReadOnlyListAdaptor.cs.meta
================================================
fileFormatVersion: 2
guid: 6bac71655584ae549bb144276ee22eed
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Shims.cs
================================================
﻿#if NETSTANDARD

using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;

namespace Cysharp.Text
{
    internal static class Int32
    {
        /// <summary>0 ~ 9</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNumber(char c)
        {
            return '0' <= c && c <= '9';
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Parse(ReadOnlySpan<char> s)
        {
            var value = 0L;
            var sign = 1;

            if (s[0] == '-')
            {
                sign = -1;
            }

            for (int i = ((sign == -1) ? 1 : 0); i < s.Length; i++)
            {
                if (!IsNumber(s[i]))
                {
                    goto END;
                }

                // long.MinValue causes overflow so use unchecked.
                value = unchecked(value * 10 + ((byte)s[i] - '0'));
            }

            END:
            return checked((int)(unchecked(value * sign)));
        }
    }

    internal static class ShimsExtensions
    {
        public static unsafe int GetBytes(this Encoding encoding, ReadOnlySpan<char> span, Span<byte> bytes)
        {
            if (span.Length == 0) return 0;
            fixed (char* src = span)
            fixed (byte* dest = bytes)
            {
                return encoding.GetBytes(src, span.Length, dest, bytes.Length);
            }
        }

        public static bool TryFormat(this System.Guid value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Unsafe.As<Guid, GuidEx>(ref value).TryFormat(destination, out charsWritten, format);
        }

        public static bool TryFormat(this System.TimeSpan value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.DateTime value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.DateTimeOffset value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            var f = GetFormat(format);
            var span = ((f == null) ? value.ToString() : value.ToString(f)).AsSpan();
            if (span.TryCopyTo(destination))
            {
                charsWritten = span.Length;
                return true;
            }
            else
            {
                charsWritten = 0;
                return false;
            }
        }

        public static bool TryFormat(this System.Decimal value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatDecimal(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.Single value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatSingle(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.Double value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            return Number.TryFormatDouble(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
        }

        public static bool TryFormat(this System.SByte value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                if (value < 0 && format.Length > 0 && (format[0] == 'X' || format[0] == 'x'))
                {
                    uint temp = (uint)(value & 0x000000FF);
                    return Number.TryFormatUInt32(temp, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
                }
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int16 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                if (value < 0 && format.Length > 0 && (format[0] == 'X' || format[0] == 'x'))
                {
                    uint temp = (uint)(value & 0x0000FFFF);
                    return Number.TryFormatUInt32(temp, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
                }
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int32 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Int64 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatInt64(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.Byte value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt16 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt32 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt32(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        public static bool TryFormat(this System.UInt64 value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                return FastNumberWriter.TryWriteUInt64(destination, out charsWritten, value);
            }
            else
            {
                return Number.TryFormatUInt64(value, format, NumberFormatInfo.CurrentInfo, destination, out charsWritten);
            }
        }

        static string? GetFormat(ReadOnlySpan<char> format)
        {
            if (format.Length == 0)
            {
                return null;
            }

            return format.ToString();
        }
    }
}

#endif


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Shims.cs.meta
================================================
fileFormatVersion: 2
guid: f69d4234282aeb44c988b029e96aaee1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/StringBuilder.AppendJoin.cs
================================================
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal<T>(s, values.AsSpan());
        }

        public void AppendJoin<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified char separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        public void AppendJoin<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, params T[] values)
        {
            AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        public void AppendJoin<T>(string separator, List<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, IEnumerable<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, ICollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public void AppendJoin<T>(string separator, IList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            AppendJoinInternal(separator, readOnlyList);
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            var count = values.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var isFirst = true;
            foreach (var item in values)
            {
                if (!isFirst)
                {
                    Append(separator);
                }
                else
                {
                    isFirst = false;
                }

                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }
    }
    public partial struct Utf8ValueStringBuilder
    {
        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal<T>(s, values.AsSpan());
        }

        public void AppendJoin<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified char separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        public void AppendJoin<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values);
        }

        public void AppendJoin<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            AppendJoinInternal(s, values.AsEnumerable());
        }

        /// <summary>
        /// Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, params T[] values)
        {
            AppendJoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        public void AppendJoin<T>(string separator, List<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }

        public void AppendJoin<T>(string separator, ReadOnlySpan<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        /// <summary>
        /// Concatenates and appends the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="separator"></param>
        /// <param name="values"></param>
        public void AppendJoin<T>(string separator, IEnumerable<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, ICollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public void AppendJoin<T>(string separator, IList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyList<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values);
        }

        public void AppendJoin<T>(string separator, IReadOnlyCollection<T> values)
        {
            AppendJoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            AppendJoinInternal(separator, readOnlyList);
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            var count = values.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                if (i != 0)
                {
                    Append(separator);
                }

                var item = values[i];
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }

        internal void AppendJoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var isFirst = true;
            foreach (var item in values)
            {
                if (!isFirst)
                {
                    Append(separator);
                }
                else
                {
                    isFirst = false;
                }

                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(item);
                    if (!string.IsNullOrEmpty(s))
                    {
                        Append(s);
                    }
                }
                else
                {
                    Append(item);
                }
            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/StringBuilder.AppendJoin.cs.meta
================================================
fileFormatVersion: 2
guid: 9e8eda83a35921f4ca67df72e7e5f3e9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Unity.meta
================================================
fileFormatVersion: 2
guid: 5a401e97d5c5c0b4699e384a5baf299c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16.meta
================================================
fileFormatVersion: 2
guid: 873812c508c6fd34bb7dce99fc1a640a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16ValueStringBuilder.cs
================================================
﻿using System;
using System.Buffers;
using System.IO;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder : IDisposable, IBufferWriter<char>, IResettableBufferWriter<char>
    {
        public delegate bool TryFormat<T>(T value, Span<char> destination, out int charsWritten, ReadOnlySpan<char> format);

        const int ThreadStaticBufferSize = 31111;
        const int DefaultBufferSize = 32768; // use 32K default buffer.

        static char newLine1;
        static char newLine2;
        static bool crlf;

        static Utf16ValueStringBuilder()
        {
            var newLine = Environment.NewLine.ToCharArray();
            if (newLine.Length == 1)
            {
                // cr or lf
                newLine1 = newLine[0];
                crlf = false;
            }
            else
            {
                // crlf(windows)
                newLine1 = newLine[0];
                newLine2 = newLine[1];
                crlf = true;
            }
        }

        [ThreadStatic]
        static char[]? scratchBuffer;

        [ThreadStatic]
        internal static bool scratchBufferUsed;

        char[]? buffer;
        int index;
        bool disposeImmediately;

        /// <summary>Length of written buffer.</summary>
        public int Length => index;
        /// <summary>Get the written buffer data.</summary>
        public ReadOnlySpan<char> AsSpan() => buffer.AsSpan(0, index);
        /// <summary>Get the written buffer data.</summary>
        public ReadOnlyMemory<char> AsMemory() => buffer.AsMemory(0, index);
        /// <summary>Get the written buffer data.</summary>
        public ArraySegment<char> AsArraySegment() => new ArraySegment<char>(buffer, 0, index);

        /// <summary>
        /// Initializes a new instance
        /// </summary>
        /// <param name="disposeImmediately">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateStringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Utf16ValueStringBuilder(bool disposeImmediately)
        {
            if (disposeImmediately && scratchBufferUsed)
            {
                ThrowNestedException();
            }

            char[]? buf;
            if (disposeImmediately)
            {
                buf = scratchBuffer;
                if (buf == null)
                {
                    buf = scratchBuffer = new char[ThreadStaticBufferSize];
                }
                scratchBufferUsed = true;
            }
            else
            {
                buf = ArrayPool<char>.Shared.Rent(DefaultBufferSize);
            }

            buffer = buf;
            index = 0;
            this.disposeImmediately = disposeImmediately;
        }

        /// <summary>
        /// Return the inner buffer to pool.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            if (buffer != null)
            {
                if (buffer.Length != ThreadStaticBufferSize)
                {
                    ArrayPool<char>.Shared.Return(buffer);
                }
                buffer = null;
                index = 0;
                if (disposeImmediately)
                {
                    scratchBufferUsed = false;
                }
            }
        }

        public void Clear()
        {
            index = 0;
        }

        public void TryGrow(int sizeHint)
        {

            if (buffer!.Length < index + sizeHint)
            {
                Grow(sizeHint);
            }
        }

        public void Grow(int sizeHint)
        {
            var nextSize = buffer!.Length * 2;
            if (sizeHint != 0)
            {
                nextSize = Math.Max(nextSize, index + sizeHint);
            }

            var newBuffer = ArrayPool<char>.Shared.Rent(nextSize);

            buffer.CopyTo(newBuffer, 0);
            if (buffer.Length != ThreadStaticBufferSize)
            {
                ArrayPool<char>.Shared.Return(buffer);
            }

            buffer = newBuffer;
        }

        /// <summary>Appends the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine()
        {
            if (crlf)
            {
                if (buffer!.Length - index < 2) Grow(2);
                buffer[index] = newLine1;
                buffer[index + 1] = newLine2;
                index += 2;
            }
            else
            {
                if (buffer!.Length - index < 1) Grow(1);
                buffer[index] = newLine1;
                index += 1;
            }
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value)
        {
            if (buffer!.Length - index < 1)
            {
                Grow(1);
            }

            buffer[index++] = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value, int repeatCount)
        {
            if (repeatCount < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(repeatCount));
            }

            GetSpan(repeatCount).Fill(value);
            Advance(repeatCount);
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(char value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value)
        {
            Append(value.AsSpan());
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(string value)
        {
            Append(value);
            AppendLine();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value, int startIndex, int count)
        {
            if (value == null)
            {
                if (startIndex == 0 && count == 0)
                {
                    return;
                }
                else
                {
                    throw new ArgumentNullException(nameof(value));
                }
            }

            Append(value.AsSpan(startIndex, count));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char[] value, int startIndex, int charCount)
        {
            if (buffer!.Length - index < charCount)
            {
                Grow(charCount);
            }
            Array.Copy(value, startIndex, buffer, index, charCount);
            index += charCount;
        }

        /// <summary>Appends a contiguous region of arbitrary memory to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(ReadOnlySpan<char> value)
        {
            if (buffer!.Length - index < value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(buffer.AsSpan(index));
            index += value.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(ReadOnlySpan<char> value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        public void Append<T>(T value)
        {
            if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var written, default))
            {
                Grow(written);
                if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out written, default))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        public void AppendLine<T>(T value)
        {
            Append(value);
            AppendLine();
        }

        static class ExceptionUtil
        {
            public static void ThrowArgumentOutOfRangeException(string paramName)
            {
                throw new ArgumentOutOfRangeException(paramName);
            }
        }

        /// <summary>
        /// Inserts a string 0 or more times into this builder at the specified position.
        /// </summary>
        /// <param name="index">The index to insert in this builder.</param>
        /// <param name="value">The string to insert.</param>
        /// <param name="count">The number of times to insert the string.</param>
        public void Insert(int index, string value, int count)
        {
            Insert(index, value.AsSpan(), count);
        }

        public void Insert(int index, string value)
        {
            Insert(index, value.AsSpan(), 1);
        }

        public void Insert(int index, ReadOnlySpan<char> value, int count)
        {
            if (count < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            int currentLength = Length;
            if ((uint)index > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(index));
            }

            if (value.Length == 0 || count == 0)
            {
                return;
            }

            var newSize = index + value.Length * count;
            var newBuffer = ArrayPool<char>.Shared.Rent(Math.Max(DefaultBufferSize, newSize));

            buffer.AsSpan(0, index).CopyTo(newBuffer);
            int newBufferIndex = index;

            for (int i = 0; i < count; i++)
            {
                value.CopyTo(newBuffer.AsSpan(newBufferIndex));
                newBufferIndex += value.Length;
            }

            int remainLnegth = this.index - index;
            buffer.AsSpan(index, remainLnegth).CopyTo(newBuffer.AsSpan(newBufferIndex));

            if (buffer!.Length != ThreadStaticBufferSize)
            {
                if (buffer != null)
                {
                    ArrayPool<char>.Shared.Return(buffer);
                }
            }

            buffer = newBuffer;
            this.index = newBufferIndex + remainLnegth;
        }

        /// <summary>
        /// Replaces all instances of one character with another in this builder.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
        public void Replace(char oldChar, char newChar) => Replace(oldChar, newChar, 0, Length);

        /// <summary>
        /// Replaces all instances of one character with another in this builder.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
        /// <param name="startIndex">The index to start in this builder.</param>
        /// <param name="count">The number of characters to read in this builder.</param>
        public void Replace(char oldChar, char newChar, int startIndex, int count)
        {
            int currentLength = Length;
            if ((uint)startIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (count < 0 || startIndex > currentLength - count)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            int endIndex = startIndex + count;

            for (int i = startIndex; i < endIndex; i++)
            {
                if (buffer![i] == oldChar)
                {
                    buffer[i] = newChar;
                }
            }
        }

        /// <summary>
        /// Replaces all instances of one string with another in this builder.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
        /// <remarks>
        /// If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
        /// are removed from this builder.
        /// </remarks>
        public void Replace(string oldValue, string newValue) => Replace(oldValue, newValue, 0, Length);

        public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue) => Replace(oldValue, newValue, 0, Length);

        /// <summary>
        /// Replaces all instances of one string with another in part of this builder.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
        /// <param name="startIndex">The index to start in this builder.</param>
        /// <param name="count">The number of characters to read in this builder.</param>
        /// <remarks>
        /// If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
        /// are removed from this builder.
        /// </remarks>
        public void Replace(string oldValue, string newValue, int startIndex, int count)
        {
            if (oldValue == null)
            {
                throw new ArgumentNullException(nameof(oldValue));
            }

            Replace(oldValue.AsSpan(), newValue.AsSpan(), startIndex, count);
        }

        public void Replace(ReadOnlySpan<char> oldValue, ReadOnlySpan<char> newValue, int startIndex, int count)
        {
            int currentLength = Length;

            if ((uint)startIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (count < 0 || startIndex > currentLength - count)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(count));
            }

            if (oldValue.Length == 0)
            {
                throw new ArgumentException("oldValue.Length is 0", nameof(oldValue));
            }

            var readOnlySpan = AsSpan();
            int endIndex = startIndex + count;
            int matchCount = 0;

            for (int i = startIndex; i < endIndex; i += oldValue.Length)
            {
                var span = readOnlySpan.Slice(i, endIndex - i);
                var pos = span.IndexOf(oldValue, StringComparison.Ordinal);
                if (pos == -1)
                {
                    break;
                }
                i += pos;
                matchCount++;
            }

            if (matchCount == 0)
                return;

            var newBuffer = ArrayPool<char>.Shared.Rent(Math.Max(DefaultBufferSize, Length + (newValue.Length - oldValue.Length) * matchCount));

            buffer.AsSpan(0, startIndex).CopyTo(newBuffer);
            int newBufferIndex = startIndex;

            for (int i = startIndex; i < endIndex; i += oldValue.Length)
            {
                var span = readOnlySpan.Slice(i, endIndex - i);
                var pos = span.IndexOf(oldValue, StringComparison.Ordinal);
                if (pos == -1)
                {
                    var remain = readOnlySpan.Slice(i);
                    remain.CopyTo(newBuffer.AsSpan(newBufferIndex));
                    newBufferIndex += remain.Length;
                    break;
                }
                readOnlySpan.Slice(i, pos).CopyTo(newBuffer.AsSpan(newBufferIndex));
                newValue.CopyTo(newBuffer.AsSpan(newBufferIndex + pos));
                newBufferIndex += pos + newValue.Length;
                i += pos;
            }

            if (buffer!.Length != ThreadStaticBufferSize)
            {
                ArrayPool<char>.Shared.Return(buffer);
            }
            buffer = newBuffer;
            index = newBufferIndex;
        }
        
        /// <summary>
        /// Replaces the contents of a single position within the builder.
        /// </summary>
        /// <param name="newChar">The character to use at the position.</param>
        /// <param name="replaceIndex">The index to replace.</param>
        public void ReplaceAt(char newChar, int replaceIndex)
        {
            int currentLength = Length;
            if ((uint)replaceIndex > (uint)currentLength)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(replaceIndex));
            }
            
            buffer![replaceIndex] = newChar;
        }

        /// <summary>
        /// Removes a range of characters from this builder.
        /// </summary>
        /// <remarks>
        /// This method does not reduce the capacity of this builder.
        /// </remarks>
        public void Remove(int startIndex, int length)
        {
            if (length < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(length));
            }

            if (startIndex < 0)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(startIndex));
            }

            if (length > Length - startIndex)
            {
                ExceptionUtil.ThrowArgumentOutOfRangeException(nameof(length));
            }

            if (Length == length && startIndex == 0)
            {
                index = 0;
                return;
            }

            if (length == 0)
            {
                return;
            }

            int remain = startIndex + length;
            buffer.AsSpan(remain, Length - remain).CopyTo(buffer.AsSpan(startIndex));
            index -= length;
        }


        // Output

        /// <summary>Copy inner buffer to the destination span.</summary>
        public bool TryCopyTo(Span<char> destination, out int charsWritten)
        {
            if (destination.Length < index)
            {
                charsWritten = 0;
                return false;
            }

            charsWritten = index;
            buffer.AsSpan(0, index).CopyTo(destination);
            return true;
        }

        /// <summary>Converts the value of this instance to a System.String.</summary>
        public override string ToString()
        {
            if (index == 0)
                return string.Empty;

            return new string(buffer, 0, index);
        }

        // IBufferWriter

        /// <summary>IBufferWriter.GetMemory.</summary>
        public Memory<char> GetMemory(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsMemory(index);
        }

        /// <summary>IBufferWriter.GetSpan.</summary>
        public Span<char> GetSpan(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsSpan(index);
        }

        /// <summary>IBufferWriter.Advance.</summary>
        public void Advance(int count)
        {
            index += count;
        }

        void IResettableBufferWriter<char>.Reset()
        {
            index = 0;
        }

        void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }
        static void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        void AppendFormatInternal<T>(T arg, int width, ReadOnlySpan<char> format, string argName)
        {
            if (width <= 0) // leftJustify
            {
                width *= -1;

                if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var charsWritten, format))
                {
                    Grow(charsWritten);
                    if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out charsWritten, format))
                    {
                        ThrowArgumentException(argName);
                    }
                }

                index += charsWritten;

                int padding = width - charsWritten;
                if (width > 0 && padding > 0)
                {
                    Append(' ', padding);  // TODO Fill Method is too slow.
                }
            }
            else // rightJustify
            {
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(arg);
                    int padding = width - s.Length;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s);
                }
                else
                {
                    Span<char> s = stackalloc char[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                    if (!FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                    {
                        s = stackalloc char[s.Length * 2];
                        if (!FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                        {
                            ThrowArgumentException(argName);
                        }
                    }

                    int padding = width - charsWritten;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s.Slice(0, charsWritten));
                }
            }
        }

        static void ThrowNestedException()
        {
            throw new NestedStringBuilderCreationException(nameof(Utf16ValueStringBuilder));
        }

        /// <summary>
        /// Register custom formatter
        /// </summary>
        public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
        {
            FormatterCache<T>.TryFormatDelegate = formatMethod;
        }

        static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
        {
            return new TryFormat<T?>((T? x, Span<char> dest, out int written, ReadOnlySpan<char> format) =>
            {
                if (x == null)
                {
                    written = 0;
                    return true;
                }
                return FormatterCache<T>.TryFormatDelegate(x.Value, dest, out written, format);
            });
        }

        /// <summary>
        /// Supports the Nullable type for a given struct type.
        /// </summary>
        public static void EnableNullableFormat<T>() where T : struct
        {
            RegisterTryFormat<T?>(CreateNullableFormatter<T>());
        }

        public static class FormatterCache<T>
        {
            public static TryFormat<T> TryFormatDelegate;
            static FormatterCache()
            {
                var formatter = (TryFormat<T>?)CreateFormatter(typeof(T));
                if (formatter == null)
                {
                    if (typeof(T).IsEnum)
                    {
                        formatter = new TryFormat<T>(EnumUtil<T>.TryFormatUtf16);
                    }
                    else if (typeof(T) == typeof(string))
                    {
                        formatter = new TryFormat<T>(TryFormatString);
                    }
                    else
                    {
                        formatter = new TryFormat<T>(TryFormatDefault);
                    }
                }

                TryFormatDelegate = formatter;
            }

            static bool TryFormatString(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
            {
                var s = value as string;

                if (s == null)
                {
                    written = 0;
                    return true;
                }

                // also use this length when result is false.
                written = s.Length;
                return s.AsSpan().TryCopyTo(dest);
            }

            static bool TryFormatDefault(T value, Span<char> dest, out int written, ReadOnlySpan<char> format)
            {
                if (value == null)
                {
                    written = 0;
                    return true;
                }

                var s = (value is IFormattable formattable && format.Length != 0) ?
                    formattable.ToString(format.ToString(), null) :
                    value.ToString();

                // also use this length when result is false.
                written = s.Length;
                return s.AsSpan().TryCopyTo(dest);
            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16ValueStringBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: a63cdeec02e3c54438967c859226bb32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8.meta
================================================
fileFormatVersion: 2
guid: 67d7f0242422cd6459b1e59c73ff46e8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8ValueStringBuilder.cs
================================================
using System;
using System.Buffers;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder : IDisposable, IBufferWriter<byte>, IResettableBufferWriter<byte>
    {
        public delegate bool TryFormat<T>(T value, Span<byte> destination, out int written, StandardFormat format);

        const int ThreadStaticBufferSize = 64444;
        const int DefaultBufferSize = 65536; // use 64K default buffer.
        static Encoding UTF8NoBom = new UTF8Encoding(false);

        static byte newLine1;
        static byte newLine2;
        static bool crlf;

        static Utf8ValueStringBuilder()
        {
            var newLine = UTF8NoBom.GetBytes(Environment.NewLine);
            if (newLine.Length == 1)
            {
                // cr or lf
                newLine1 = newLine[0];
                crlf = false;
            }
            else
            {
                // crlf(windows)
                newLine1 = newLine[0];
                newLine2 = newLine[1];
                crlf = true;
            }
        }

        [ThreadStatic]
        static byte[]? scratchBuffer;

        [ThreadStatic]
        internal static bool scratchBufferUsed;

        byte[]? buffer;
        int index;
        bool disposeImmediately;

        /// <summary>Length of written buffer.</summary>
        public int Length => index;

        /// <summary>Get the written buffer data.</summary>
        public ReadOnlySpan<byte> AsSpan() => buffer.AsSpan(0, index);

        /// <summary>Get the written buffer data.</summary>
        public ReadOnlyMemory<byte> AsMemory() => buffer.AsMemory(0, index);

        /// <summary>Get the written buffer data.</summary>
        public ArraySegment<byte> AsArraySegment() => new ArraySegment<byte>(buffer, 0, index);

        /// <summary>
        /// Initializes a new instance
        /// </summary>
        /// <param name="disposeImmediately">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Utf8ValueStringBuilder(bool disposeImmediately)
        {
            if (disposeImmediately && scratchBufferUsed)
            {
                ThrowNestedException();
            }

            byte[]? buf;
            if (disposeImmediately)
            {
                buf = scratchBuffer;
                if (buf == null)
                {
                    buf = scratchBuffer = new byte[ThreadStaticBufferSize];
                }
                scratchBufferUsed = true;
            }
            else
            {
                buf = ArrayPool<byte>.Shared.Rent(DefaultBufferSize);
            }

            buffer = buf;
            index = 0;
            this.disposeImmediately = disposeImmediately;
        }

        /// <summary>
        /// Return the inner buffer to pool.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            if (buffer != null)
            {
                if (buffer.Length != ThreadStaticBufferSize)
                {
                    ArrayPool<byte>.Shared.Return(buffer);
                }
                buffer = null;
                index = 0;
                if (disposeImmediately)
                {
                    scratchBufferUsed = false;
                }
            }
        }

        public void Clear()
        {
            index = 0;
        }

        public void TryGrow(int sizeHint)
        {
            if (buffer!.Length < index + sizeHint)
            {
                Grow(sizeHint);
            }
        }

        public void Grow(int sizeHint)
        {
            var nextSize = buffer!.Length * 2;
            if (sizeHint != 0)
            {
                nextSize = Math.Max(nextSize, index + sizeHint);
            }

            var newBuffer = ArrayPool<byte>.Shared.Rent(nextSize);

            buffer.CopyTo(newBuffer, 0);
            if (buffer.Length != ThreadStaticBufferSize)
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }

            buffer = newBuffer;
        }

        /// <summary>Appends the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine()
        {
            if (crlf)
            {
                if (buffer!.Length - index < 2) Grow(2);
                buffer[index] = newLine1;
                buffer[index + 1] = newLine2;
                index += 2;
            }
            else
            {
                if (buffer!.Length - index < 1) Grow(1);
                buffer[index] = newLine1;
                index += 1;
            }
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe void Append(char value)
        {
            var maxLen = UTF8NoBom.GetMaxByteCount(1);
            if (buffer!.Length - index < maxLen)
            {
                Grow(maxLen);
            }

            fixed (byte* bp = &buffer[index])
            {
                index += UTF8NoBom.GetBytes(&value, 1, bp, maxLen);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char value, int repeatCount)
        {
            if (repeatCount < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(repeatCount));
            }

            if (value <= 0x7F) // ASCII
            {
                GetSpan(repeatCount).Fill((byte)value);
                Advance(repeatCount);
            }
            else
            {
                var maxLen = UTF8NoBom.GetMaxByteCount(1);
                Span<byte> utf8Bytes = stackalloc byte[maxLen];
                ReadOnlySpan<char> chars = stackalloc char[1] { value };

                int len = UTF8NoBom.GetBytes(chars, utf8Bytes);

                TryGrow(len * repeatCount);

                for (int i = 0; i < repeatCount; i++)
                {
                    utf8Bytes.CopyTo(GetSpan(len));
                    Advance(len);
                }
            }
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(char value)
        {
            Append(value);
            AppendLine();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value, int startIndex, int count)
        {
            if (value == null)
            {
                if (startIndex == 0 && count == 0)
                {
                    return;
                }
                else
                {
                    throw new ArgumentNullException(nameof(value));
                }
            }

            Append(value.AsSpan(startIndex, count));
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string value)
        {
            Append(value.AsSpan());
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(string value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends a contiguous region of arbitrary memory to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(ReadOnlySpan<char> value)
        {
            var maxLen = UTF8NoBom.GetMaxByteCount(value.Length);
            if (buffer!.Length - index < maxLen)
            {
                Grow(maxLen);
            }

            index += UTF8NoBom.GetBytes(value, buffer.AsSpan(index));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(ReadOnlySpan<char> value)
        {
            Append(value);
            AppendLine();
        }

        public void AppendLiteral(ReadOnlySpan<byte> value)
        {
            if ((buffer!.Length - index) < value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(buffer.AsSpan(index));
            index += value.Length;
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        public void Append<T>(T value)
        {
            if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out var written, default))
            {
                Grow(written);
                if (!FormatterCache<T>.TryFormatDelegate(value, buffer.AsSpan(index), out written, default))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        public void AppendLine<T>(T value)
        {
            Append(value);
            AppendLine();
        }

        // Output

        /// <summary>Copy inner buffer to the bufferWriter.</summary>
        public void CopyTo(IBufferWriter<byte> bufferWriter)
        {
            var destination = bufferWriter.GetSpan(index);
            TryCopyTo(destination, out var written);
            bufferWriter.Advance(written);
        }

        /// <summary>Copy inner buffer to the destination span.</summary>
        public bool TryCopyTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < index)
            {
                bytesWritten = 0;
                return false;
            }

            bytesWritten = index;
            buffer.AsSpan(0, index).CopyTo(destination);
            return true;
        }

        /// <summary>Write inner buffer to stream.</summary>
        public Task WriteToAsync(Stream stream)
        {
            return stream.WriteAsync(buffer, 0, index);
        }

        /// <summary>Write inner buffer to stream.</summary>
        public Task WriteToAsync(Stream stream, CancellationToken cancellationToken)
        {
            return stream.WriteAsync(buffer, 0, index, cancellationToken);
        }

        /// <summary>Encode the innner utf8 buffer to a System.String.</summary>
        public override string ToString()
        {
            if (index == 0)
                return string.Empty;

            return UTF8NoBom.GetString(buffer, 0, index);
        }

        // IBufferWriter

        /// <summary>IBufferWriter.GetMemory.</summary>
        public Memory<byte> GetMemory(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsMemory(index);
        }

        /// <summary>IBufferWriter.GetSpan.</summary>
        public Span<byte> GetSpan(int sizeHint)
        {
            if ((buffer!.Length - index) < sizeHint)
            {
                Grow(sizeHint);
            }

            return buffer.AsSpan(index);
        }

        /// <summary>IBufferWriter.Advance.</summary>
        public void Advance(int count)
        {
            index += count;
        }

        void IResettableBufferWriter<byte>.Reset()
        {
            index = 0;
        }

        void ThrowArgumentException(string paramName)
        {
            throw new ArgumentException("Can't format argument.", paramName);
        }

        void ThrowFormatException()
        {
            throw new FormatException("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");
        }

        static void ThrowNestedException()
        {
            throw new NestedStringBuilderCreationException(nameof(Utf8ValueStringBuilder));
        }

        private void AppendFormatInternal<T>(T arg, int width, StandardFormat format, string argName)
        {
            if (width <= 0) // leftJustify
            {
                width *= -1;

                if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out var charsWritten, format))
                {
                    Grow(charsWritten);
                    if (!FormatterCache<T>.TryFormatDelegate(arg, buffer.AsSpan(index), out charsWritten, format))
                    {
                        ThrowArgumentException(argName);
                    }
                }

                index += charsWritten;

                int padding = width - charsWritten;
                if (width > 0 && padding > 0)
                {
                    Append(' ', padding);  // TODO Fill Method is too slow.
                }
            }
            else // rightJustify
            {
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(arg);
                    int padding = width - s.Length;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    Append(s);
                }
                else
                {
                    Span<byte> s = stackalloc byte[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                    if (!FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                    {
                        s = stackalloc byte[s.Length * 2];
                        if (!FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                        {
                            ThrowArgumentException(argName);
                        }
                    }

                    int padding = width - charsWritten;
                    if (padding > 0)
                    {
                        Append(' ', padding);  // TODO Fill Method is too slow.
                    }

                    s.CopyTo(GetSpan(charsWritten));
                    Advance(charsWritten);
                }
            }
        }

        /// <summary>
        /// Register custom formatter
        /// </summary>
        public static void RegisterTryFormat<T>(TryFormat<T> formatMethod)
        {
            FormatterCache<T>.TryFormatDelegate = formatMethod;
        }

        static TryFormat<T?> CreateNullableFormatter<T>() where T : struct
        {
            return new TryFormat<T?>((T? x, Span<byte> destination, out int written, StandardFormat format) =>
            {
                if (x == null)
                {
                    written = 0;
                    return true;
                }
                return FormatterCache<T>.TryFormatDelegate(x.Value, destination, out written, format);
            });
        }

        /// <summary>
        /// Supports the Nullable type for a given struct type.
        /// </summary>
        public static void EnableNullableFormat<T>() where T : struct
        {
            RegisterTryFormat<T?>(CreateNullableFormatter<T>());
        }

        public static class FormatterCache<T>
        {
            public static TryFormat<T> TryFormatDelegate;
            static FormatterCache()
            {
                var formatter = (TryFormat<T>?)CreateFormatter(typeof(T));
                if (formatter == null)
                {
                    if (typeof(T).IsEnum)
                    {
                        formatter = new TryFormat<T>(EnumUtil<T>.TryFormatUtf8);
                    }
                    else
                    {
                        formatter = new TryFormat<T>(TryFormatDefault);
                    }
                }

                TryFormatDelegate = formatter;
            }

            static bool TryFormatDefault(T value, Span<byte> dest, out int written, StandardFormat format)
            {
                if (value == null)
                {
                    written = 0;
                    return true;
                }

                var s = typeof(T) == typeof(string) ? Unsafe.As<string>(value) :
                    (value is IFormattable formattable && format != default) ? formattable.ToString(format.ToString(), null) :
                    value.ToString();

                // also use this length when result is false.
                written = UTF8NoBom.GetMaxByteCount(s.Length);
                if (dest.Length < written)
                {
                    return false;
                }

                written = UTF8NoBom.GetBytes(s.AsSpan(), dest);
                return true;

            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8ValueStringBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: ea8889d2a42dc824697d997531ea0c14
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.asmdef
================================================
{
    "name": "ZString",
    "references": [
        "Unity.TextMeshPro"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.textmeshpro",
            "expression": "",
            "define": "ZSTRING_TEXTMESHPRO_SUPPORT"
        },
        {
            "name": "com.unity.ugui",
            "expression": "2.0.0",
            "define": "ZSTRING_TEXTMESHPRO_SUPPORT"
        }
    ]
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.asmdef.meta
================================================
fileFormatVersion: 2
guid: 33661e06c33d31b4c9223810bf503247
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Concat.cs.meta
================================================
fileFormatVersion: 2
guid: 3cc4c8c9a298173488ac495332e11009
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        static Encoding UTF8NoBom = new UTF8Encoding(false);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void AppendChars<TBufferWriter>(ref TBufferWriter sb, ReadOnlySpan<char> chars)
            where TBufferWriter : System.Buffers.IBufferWriter<byte>
        {
            var span = sb.GetSpan(UTF8NoBom.GetMaxByteCount(chars.Length));
            sb.Advance(UTF8NoBom.GetBytes(chars, span));
        }

        /// <summary>Create the Utf16 string StringBuilder.</summary>
        public static Utf16ValueStringBuilder CreateStringBuilder()
        {
            return new Utf16ValueStringBuilder(false);
        }

        /// <summary>Create the Utf16 string StringBuilder, when true uses thread-static buffer that is faster but must return immediately.</summary>
        public static Utf8ValueStringBuilder CreateUtf8StringBuilder()
        {
            return new Utf8ValueStringBuilder(false);
        }

        /// <summary>Create the Utf8(`Span[byte]`) StringBuilder.</summary>
        /// <param name="notNested">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        public static Utf16ValueStringBuilder CreateStringBuilder(bool notNested)
        {
            return new Utf16ValueStringBuilder(notNested);
        }

        /// <summary>Create the Utf8(`Span[byte]`) StringBuilder, when true uses thread-static buffer that is faster but must return immediately.</summary>
        /// <param name="notNested">
        /// If true uses thread-static buffer that is faster but must return immediately.
        /// </param>
        /// <exception cref="InvalidOperationException">
        /// This exception is thrown when <c>new StringBuilder(disposeImmediately: true)</c> or <c>ZString.CreateUtf8StringBuilder(notNested: true)</c> is nested.
        /// See the README.md
        /// </exception>
        public static Utf8ValueStringBuilder CreateUtf8StringBuilder(bool notNested)
        {
            return new Utf8ValueStringBuilder(notNested);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, params T[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal<T>(s, values.AsSpan());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, List<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, (IReadOnlyList<T>)values);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, ReadOnlySpan<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(char separator, IEnumerable<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, ICollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values.AsEnumerable());
        }

        public static string Join<T>(char separator, IList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, IReadOnlyList<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }

        public static string Join<T>(char separator, IReadOnlyCollection<T> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values.AsEnumerable());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, params T[] values)
        {
            return JoinInternal<T>(separator.AsSpan(), values.AsSpan());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, List<T> values)
        {
            return JoinInternal(separator.AsSpan(), (IReadOnlyList<T>)values);
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, ReadOnlySpan<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, ICollection<T> values)
        {
            return JoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        public static string Join<T>(string separator, IList<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, IReadOnlyList<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }

        public static string Join<T>(string separator, IReadOnlyCollection<T> values)
        {
            return JoinInternal(separator.AsSpan(), values.AsEnumerable());
        }

        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join<T>(string separator, IEnumerable<T> values)
        {
            return JoinInternal(separator.AsSpan(), values);
        }
        
#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(char separator, ReadOnlySpan<string> values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, values);
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(char separator, params string[] values)
        {
            ReadOnlySpan<char> s = stackalloc char[1] { separator };
            return JoinInternal(s, (ReadOnlySpan<string>)values.AsSpan());
        }
        
        /// <summary>Concatenates the elements of an array, using the specified separator between each element.</summary>
        public static string Join(string separator, params string[] values)
        {
            return JoinInternal(separator.AsSpan(), (ReadOnlySpan<string>)values.AsSpan());
        }
#endif
        
        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(params T[] values)
        {
            return JoinInternal<T>(default, values.AsSpan());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(List<T> values)
        {
            return JoinInternal(default, (IReadOnlyList<T>)values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(ReadOnlySpan<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(ICollection<T> values)
        {
            return JoinInternal(default, values.AsEnumerable());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IList<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IReadOnlyList<T> values)
        {
            return JoinInternal(default, values);
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IReadOnlyCollection<T> values)
        {
            return JoinInternal(default, values.AsEnumerable());
        }

        /// <summary>Concatenates the string representation of some specified objects.</summary>
        public static string Concat<T>(IEnumerable<T> values)
        {
            return JoinInternal(default, values);
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IList<T> values)
        {
            var readOnlyList = values as IReadOnlyList<T>;
            // Boxing will occur, but JIT will be de-virtualized.
            readOnlyList = readOnlyList ?? new ReadOnlyListAdaptor<T>(values);
            return JoinInternal(separator, readOnlyList);
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IReadOnlyList<T> values)
        {
            if (values.Count == 0)
            {
                return string.Empty;
            }
#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1            
            if (values is string[] valueArray)
            {
                return JoinInternal(separator, valueArray.AsSpan());
            }
#if NET5_0_OR_GREATER
            if (values is List<string> valueList)
            {
                return JoinInternal(separator, CollectionsMarshal.AsSpan(valueList));
            }
#endif
#endif
            
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, ReadOnlySpan<T> values)
        {
            if (values.Length == 0)
            {
                return string.Empty;
            }
            else if (typeof(T) == typeof(string) && values.Length == 1)
            {
                return Unsafe.As<string>(values[0]);
            }

            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        static string JoinInternal<T>(ReadOnlySpan<char> separator, IEnumerable<T> values)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendJoinInternal(separator, values);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

#if NETSTANDARD2_1_OR_GREATER || NET_STANDARD_2_1
        static string JoinInternal(ReadOnlySpan<char> separator, ReadOnlySpan<string> values)
        {
            if (values.Length == 0)
            {
                return string.Empty;
            }
            if (values.Length == 1)
            {
                return values[0];
            }

            var totalSeparatorsLength = (values.Length - 1) * separator.Length;
            var totalLength = totalSeparatorsLength;
            for (var i = 0; i < values.Length; i++)
            {
                if (values[i] is { } value)
                {
                    totalLength += value.Length;
                }
            }
            
            if (totalLength == 0)
            {
                return string.Empty;
            }

            var resultString = string.Create(totalLength, 0, (_, _) => { });
            var writeBuffer = MemoryMarshal.CreateSpan(ref MemoryMarshal.GetReference(resultString.AsSpan()), resultString.Length);
            var copiedLength = 0;
            for (var i = 0; i < values.Length; i++)
            {
                if (values[i] is { } value)
                {
                    value.AsSpan().CopyTo(writeBuffer.Slice(copiedLength));
                    copiedLength += value.Length;
                }

                // Fill in the separator
                if (i < values.Length - 1)
                {
                    if (separator.Length == 1)
                    {
                        writeBuffer[copiedLength++] = separator[0];
                    }
                    else
                    {
                        separator.CopyTo(writeBuffer.Slice(copiedLength));
                        copiedLength += separator.Length;
                    }
                }
            }
            return resultString;
        }
#endif
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.cs.meta
================================================
fileFormatVersion: 2
guid: a82083d5baadea245b3adc1ffd14da2c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Format.cs
================================================
﻿using System.Runtime.CompilerServices;
using System;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1>(string format, T1 arg1)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1>(ReadOnlySpan<char> format, T1 arg1)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2>(string format, T1 arg1, T2 arg2)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2>(ReadOnlySpan<char> format, T1 arg1, T2 arg2)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>Replaces one or more format items in a string with the string representation of some specified objects.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string Format<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(ReadOnlySpan<char> format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            var sb = new Utf16ValueStringBuilder(true);
            try
            {
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Format.cs.meta
================================================
fileFormatVersion: 2
guid: 46c1d83e619838446ba528f658244b56
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Prepare.cs
================================================
﻿using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public static partial class ZString
    {
        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1> PrepareUtf16<T1>(string format)
        {
            return new Utf16PreparedFormat<T1>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1> PrepareUtf8<T1>(string format)
        {
            return new Utf8PreparedFormat<T1>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2> PrepareUtf16<T1, T2>(string format)
        {
            return new Utf16PreparedFormat<T1, T2>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2> PrepareUtf8<T1, T2>(string format)
        {
            return new Utf8PreparedFormat<T1, T2>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3> PrepareUtf16<T1, T2, T3>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3> PrepareUtf8<T1, T2, T3>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4> PrepareUtf16<T1, T2, T3, T4>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4> PrepareUtf8<T1, T2, T3, T4>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf16<T1, T2, T3, T4, T5>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5> PrepareUtf8<T1, T2, T3, T4, T5>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf16<T1, T2, T3, T4, T5, T6>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6> PrepareUtf8<T1, T2, T3, T4, T5, T6>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
        {
            return new Utf16PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
        }

        /// <summary>Prepare string format to avoid parse template in each operation.</summary>
        public static Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format)
        {
            return new Utf8PreparedFormat<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
        }

    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Prepare.cs.meta
================================================
fileFormatVersion: 2
guid: fca154d819b770049860ac2c8c621141
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZString.Utf8Format.cs.meta
================================================
fileFormatVersion: 2
guid: bdd4edf33de6a6c4b9911c8f3515cb8d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZStringWriter.cs
================================================
using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.Text
{
    /// <summary>
    /// A <see cref="TextWriter"/> implementation that is backed with <see cref="Utf16ValueStringBuilder"/>.
    /// </summary>
    /// <remarks>
    /// It's important to make sure the writer is always properly disposed.
    /// </remarks>
    public sealed class ZStringWriter : TextWriter
    {
        private Utf16ValueStringBuilder sb;
        private bool isOpen;
        private UnicodeEncoding? encoding;

        /// <summary>
        /// Creates a new instance using <see cref="CultureInfo.CurrentCulture"/> as format provider.
        /// </summary>
        public ZStringWriter() : this(CultureInfo.CurrentCulture)
        {
        }

        /// <summary>
        /// Creates a new instance with given format provider.
        /// </summary>
        public ZStringWriter(IFormatProvider formatProvider) : base(formatProvider)
        {
            sb = ZString.CreateStringBuilder();
            isOpen = true;
        }

        /// <summary>
        /// Disposes this instance, operations are no longer allowed.
        /// </summary>
        public override void Close()
        {
            Dispose(true);
        }

        protected override void Dispose(bool disposing)
        {
            sb.Dispose();
            isOpen = false;
            base.Dispose(disposing);
        }

        public override Encoding Encoding => encoding = encoding ?? new UnicodeEncoding(false, false);

        public override void Write(char value)
        {
            AssertNotDisposed();

            sb.Append(value);
        }

        public override void Write(char[] buffer, int index, int count)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException(nameof(buffer));
            }
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }
            if (count < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(count));
            }
            if (buffer.Length - index < count)
            {
                throw new ArgumentException();
            }
            AssertNotDisposed();

            sb.Append(buffer, index, count);
        }

        public override void Write(string value)
        {
            AssertNotDisposed();

            if (value != null)
            {
                sb.Append(value);
            }
        }

        public override Task WriteAsync(char value)
        {
            Write(value);
            return Task.CompletedTask;
        }

        public override Task WriteAsync(string value)
        {
            Write(value);
            return Task.CompletedTask;
        }

        public override Task WriteAsync(char[] buffer, int index, int count)
        {
            Write(buffer, index, count);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(char value)
        {
            WriteLine(value);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(string value)
        {
            WriteLine(value);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(char[] buffer, int index, int count)
        {
            WriteLine(buffer, index, count);
            return Task.CompletedTask;
        }

        public override void Write(bool value)
        {
            AssertNotDisposed();
            sb.Append(value);
        }

        public override void Write(decimal value)
        {
            AssertNotDisposed();
            sb.Append(value);
        }

        /// <summary>
        /// No-op.
        /// </summary>
        public override Task FlushAsync()
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Materializes the current state from underlying string builder.
        /// </summary>
        public override string ToString()
        {
            return sb.ToString();
        }

#if !NETSTANDARD2_0
#if !UNITY_2018_3_OR_NEWER

        public override void Write(ReadOnlySpan<char> buffer)
        {
            AssertNotDisposed();

            sb.Append(buffer);
        }

        public override void WriteLine(ReadOnlySpan<char> buffer)
        {
            AssertNotDisposed();

            sb.Append(buffer);
            WriteLine();
        }

        public override Task WriteAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken = default)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled(cancellationToken);
            }

            Write(buffer.Span);
            return Task.CompletedTask;
        }

        public override Task WriteLineAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken = default)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled(cancellationToken);
            }

            WriteLine(buffer.Span);
            return Task.CompletedTask;
        }
#endif
#endif

        private void AssertNotDisposed()
        {
            if (!isOpen)
            {
                throw new ObjectDisposedException(nameof(sb));
            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/ZStringWriter.cs.meta
================================================
fileFormatVersion: 2
guid: eb2ec9ac9521172449dbeac815854188
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/BitOperations.cs
================================================
﻿#if !NET6_0_OR_GREATER

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Some routines inspired by the Stanford Bit Twiddling Hacks by Sean Eron Anderson:
// http://graphics.stanford.edu/~seander/bithacks.html

namespace System.Numerics
{
    /// <summary>
    /// Utility methods for intrinsic bit-twiddling operations.
    /// The methods use hardware intrinsics when available on the underlying platform,
    /// otherwise they use optimized software fallbacks.
    /// </summary>
    internal static class BitOperations
    {
        // C# no-alloc optimization that directly wraps the data section of the dll (similar to string constants)
        // https://github.com/dotnet/roslyn/pull/24621

        private static ReadOnlySpan<byte> TrailingZeroCountDeBruijn => new byte[32]
        {
            00, 01, 28, 02, 29, 14, 24, 03,
            30, 22, 20, 15, 25, 17, 04, 08,
            31, 27, 13, 23, 21, 19, 16, 07,
            26, 12, 18, 06, 11, 05, 10, 09
        };

        private static ReadOnlySpan<byte> Log2DeBruijn => new byte[32]
        {
            00, 09, 01, 10, 13, 21, 02, 29,
            11, 14, 16, 18, 22, 25, 03, 30,
            08, 12, 20, 28, 15, 17, 24, 07,
            19, 27, 23, 06, 26, 05, 04, 31
        };

        /// <summary>
        /// Count the number of leading zero bits in a mask.
        /// Similar in behavior to the x86 instruction LZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int LeadingZeroCount(uint value)
        {
            // Unguarded fallback contract is 0->31
            if (value == 0)
            {
                return 32;
            }

            return 31 - Log2SoftwareFallback(value);
        }

        /// <summary>
        /// Count the number of leading zero bits in a mask.
        /// Similar in behavior to the x86 instruction LZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int LeadingZeroCount(ulong value)
        {
            uint hi = (uint)(value >> 32);

            if (hi == 0)
            {
                return 32 + LeadingZeroCount((uint)value);
            }

            return LeadingZeroCount(hi);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Log2(uint value)
        {
            // Fallback contract is 0->0
            return Log2SoftwareFallback(value);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Log2(ulong value)
        {
            uint hi = (uint)(value >> 32);

            if (hi == 0)
            {
                return Log2((uint)value);
            }

            return 32 + Log2(hi);
        }

        /// <summary>
        /// Returns the integer (floor) log of the specified value, base 2.
        /// Note that by convention, input value 0 returns 0 since Log(0) is undefined.
        /// Does not directly use any hardware intrinsics, nor does it incur branching.
        /// </summary>
        /// <param name="value">The value.</param>
        private static int Log2SoftwareFallback(uint value)
        {
            // No AggressiveInlining due to large method size
            // Has conventional contract 0->0 (Log(0) is undefined)

            // Fill trailing zeros with ones, eg 00010010 becomes 00011111
            value |= value >> 01;
            value |= value >> 02;
            value |= value >> 04;
            value |= value >> 08;
            value |= value >> 16;

            // uint.MaxValue >> 27 is always in range [0 - 31] so we use Unsafe.AddByteOffset to avoid bounds check
            return Unsafe.AddByteOffset(
                // Using deBruijn sequence, k=2, n=5 (2^5=32) : 0b_0000_0111_1100_0100_1010_1100_1101_1101u
                ref MemoryMarshal.GetReference(Log2DeBruijn),
                // uint|long -> IntPtr cast on 32-bit platforms does expensive overflow checks not needed here
                (IntPtr)(int)((value * 0x07C4ACDDu) >> 27));
        }

        /// <summary>
        /// Returns the population count (number of bits set) of a mask.
        /// Similar in behavior to the x86 instruction POPCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int PopCount(uint value)
        {
            const uint c1 = 0x_55555555u;
            const uint c2 = 0x_33333333u;
            const uint c3 = 0x_0F0F0F0Fu;
            const uint c4 = 0x_01010101u;

            value -= (value >> 1) & c1;
            value = (value & c2) + ((value >> 2) & c2);
            value = (((value + (value >> 4)) & c3) * c4) >> 24;

            return (int)value;
        }

        /// <summary>
        /// Returns the population count (number of bits set) of a mask.
        /// Similar in behavior to the x86 instruction POPCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int PopCount(ulong value)
        {
            if (IntPtr.Size == 4)
            {
                return PopCount((uint)value) // lo
                    + PopCount((uint)(value >> 32)); // hi
            }
            else
            {
                const ulong c1 = 0x_55555555_55555555ul;
                const ulong c2 = 0x_33333333_33333333ul;
                const ulong c3 = 0x_0F0F0F0F_0F0F0F0Ful;
                const ulong c4 = 0x_01010101_01010101ul;

                value -= (value >> 1) & c1;
                value = (value & c2) + ((value >> 2) & c2);
                value = (((value + (value >> 4)) & c3) * c4) >> 56;

                return (int)value;
            }
        }

        /// <summary>
        /// Count the number of trailing zero bits in an integer value.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(int value)
            => TrailingZeroCount((uint)value);

        /// <summary>
        /// Count the number of trailing zero bits in an integer value.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(uint value)
        {
            // Unguarded fallback contract is 0->0
            if (value == 0)
            {
                return 32;
            }

            // uint.MaxValue >> 27 is always in range [0 - 31] so we use Unsafe.AddByteOffset to avoid bounds check
            return Unsafe.AddByteOffset(
                // Using deBruijn sequence, k=2, n=5 (2^5=32) : 0b_0000_0111_0111_1100_1011_0101_0011_0001u
                ref MemoryMarshal.GetReference(TrailingZeroCountDeBruijn),
                // uint|long -> IntPtr cast on 32-bit platforms does expensive overflow checks not needed here
                (IntPtr)(int)(((value & (uint)-(int)value) * 0x077CB531u) >> 27)); // Multi-cast mitigates redundant conv.u8
        }

        /// <summary>
        /// Count the number of trailing zero bits in a mask.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(long value)
            => TrailingZeroCount((ulong)value);

        /// <summary>
        /// Count the number of trailing zero bits in a mask.
        /// Similar in behavior to the x86 instruction TZCNT.
        /// </summary>
        /// <param name="value">The value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TrailingZeroCount(ulong value)
        {
            uint lo = (uint)value;

            if (lo == 0)
            {
                return 32 + TrailingZeroCount((uint)(value >> 32));
            }

            return TrailingZeroCount(lo);
        }

        /// <summary>
        /// Rotates the specified value left by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROL.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint RotateLeft(uint value, int offset)
            => (value << offset) | (value >> (32 - offset));

        /// <summary>
        /// Rotates the specified value left by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROL.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..63] is treated as congruent mod 64.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong RotateLeft(ulong value, int offset)
            => (value << offset) | (value >> (64 - offset));

        /// <summary>
        /// Rotates the specified value right by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROR.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..31] is treated as congruent mod 32.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint RotateRight(uint value, int offset)
            => (value >> offset) | (value << (32 - offset));

        /// <summary>
        /// Rotates the specified value right by the specified number of bits.
        /// Similar in behavior to the x86 instruction ROR.
        /// </summary>
        /// <param name="value">The value to rotate.</param>
        /// <param name="offset">The number of bits to rotate by.
        /// Any value outside the range [0..63] is treated as congruent mod 64.</param>
        /// <returns>The rotated value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong RotateRight(ulong value, int offset)
            => (value >> offset) | (value << (64 - offset));
    }
}

#endif



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/BitOperations.cs.meta
================================================
fileFormatVersion: 2
guid: 84f68d164ca4db04082e956ba20ee5b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/BufferEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace System
{
    internal static class BufferEx
    {
        internal static unsafe void ZeroMemory(byte* dest, uint len)
        {
            if (len == 0) return;

            for (int i = 0; i < len; i++)
            {
                dest[i] = 0;
            }
        }

        internal static unsafe void Memcpy(byte* dest, byte* src, int len)
        {
            if (len == 0) return;
            for (int i = 0; i < len; i++)
            {
                dest[i] = src[i];
            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/BufferEx.cs.meta
================================================
fileFormatVersion: 2
guid: 02503aa3b1ee88741822361d3f10e8b7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/DecimalEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace System
{
    internal static class DecimalEx
    {
        [StructLayout(LayoutKind.Explicit)]
        private struct DecimalBits
        {
            [FieldOffset(0)]
            public int flags;
            [FieldOffset(4)]
            public int hi;
            [FieldOffset(8)]
            public int lo;
            [FieldOffset(12)]
            public int mid;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct DecCalc
        {
            private const uint TenToPowerNine = 1000000000;

            // NOTE: Do not change the offsets of these fields. This structure must have the same layout as Decimal.
            [FieldOffset(0)]
            public uint uflags;
            [FieldOffset(4)]
            public uint uhi;
            [FieldOffset(8)]
            public uint ulo;
            [FieldOffset(12)]
            public uint umid;

            /// <summary>
            /// The low and mid fields combined in little-endian order
            /// </summary>
            [FieldOffset(8)]
            private ulong ulomidLE;

            internal static uint DecDivMod1E9(ref DecCalc value)
            {
                ulong high64 = ((ulong)value.uhi << 32) + value.umid;
                ulong div64 = high64 / TenToPowerNine;
                value.uhi = (uint)(div64 >> 32);
                value.umid = (uint)div64;

                ulong num = ((high64 - (uint)div64 * TenToPowerNine) << 32) + value.ulo;
                uint div = (uint)(num / TenToPowerNine);
                value.ulo = div;
                return (uint)num - div * TenToPowerNine;
            }
        }

        private const int ScaleShift = 16;

        static ref DecCalc AsMutable(ref decimal d) => ref Unsafe.As<decimal, DecCalc>(ref d);

        internal static uint High(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).uhi;
        }

        internal static uint Low(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).ulo;
        }

        internal static uint Mid(this decimal value)
        {
            return Unsafe.As<decimal, DecCalc>(ref value).umid;
        }

        internal static bool IsNegative(this decimal value)
        {
            return Unsafe.As<decimal, DecimalBits>(ref value).flags < 0;
        }

        internal static int Scale(this decimal value)
        {
            return (byte)(Unsafe.As<decimal, DecimalBits>(ref value).flags >> ScaleShift);
        }

        internal static uint DecDivMod1E9(ref decimal value)
        {
            return DecCalc.DecDivMod1E9(ref AsMutable(ref value));
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/DecimalEx.cs.meta
================================================
fileFormatVersion: 2
guid: adc39bbd83ade844e9823e44bb8b5445
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/FloatEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static class FloatEx
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsFinite(double d)
        {
            long bits = BitConverter.DoubleToInt64Bits(d);
            return (bits & 0x7FFFFFFFFFFFFFFF) < 0x7FF0000000000000;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegative(double d)
        {
            return BitConverter.DoubleToInt64Bits(d) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(float f)
        {
            int bits = SingleToInt32Bits(f);
            return (bits & 0x7FFFFFFF) < 0x7F800000;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegative(float f)
        {
            return SingleToInt32Bits(f) < 0;
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe int SingleToInt32Bits(float value)
        {
            return *((int*)&value);
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/FloatEx.cs.meta
================================================
fileFormatVersion: 2
guid: e1bfcfb70d615f24fb88dc092457b6c8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/FormattingHelpers.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace System.Buffers.Text
{
    internal static partial class FormattingHelpers
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDigits(ulong value)
        {
            int digits = 1;
            uint part;
            if (value >= 10000000)
            {
                if (value >= 100000000000000)
                {
                    part = (uint)(value / 100000000000000);
                    digits += 14;
                }
                else
                {
                    part = (uint)(value / 10000000);
                    digits += 7;
                }
            }
            else
            {
                part = (uint)value;
            }

            if (part < 10)
            {
                // no-op
            }
            else if (part < 100)
            {
                digits++;
            }
            else if (part < 1000)
            {
                digits += 2;
            }
            else if (part < 10000)
            {
                digits += 3;
            }
            else if (part < 100000)
            {
                digits += 4;
            }
            else if (part < 1000000)
            {
                digits += 5;
            }
            else
            {
                Debug.Assert(part < 10000000);
                digits += 6;
            }

            return digits;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDigits(uint value)
        {
            int digits = 1;
            if (value >= 100000)
            {
                value /= 100000;
                digits += 5;
            }

            if (value < 10)
            {
                // no-op
            }
            else if (value < 100)
            {
                digits++;
            }
            else if (value < 1000)
            {
                digits += 2;
            }
            else if (value < 10000)
            {
                digits += 3;
            }
            else
            {
                Debug.Assert(value < 100000);
                digits += 4;
            }

            return digits;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountHexDigits(ulong value)
        {
            return (64 - BitOperations.LeadingZeroCount(value | 1) + 3) >> 2;
        }

        // Counts the number of trailing '0' digits in a decimal number.
        // e.g., value =      0 => retVal = 0, valueWithoutTrailingZeros = 0
        //       value =   1234 => retVal = 0, valueWithoutTrailingZeros = 1234
        //       value = 320900 => retVal = 2, valueWithoutTrailingZeros = 3209
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CountDecimalTrailingZeros(uint value, out uint valueWithoutTrailingZeros)
        {
            int zeroCount = 0;

            if (value != 0)
            {
                while (true)
                {
                    uint temp = value / 10;
                    if (value != (temp * 10))
                    {
                        break;
                    }

                    value = temp;
                    zeroCount++;
                }
            }

            valueWithoutTrailingZeros = value;
            return zeroCount;
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/FormattingHelpers.cs.meta
================================================
fileFormatVersion: 2
guid: 2e18ceaad90d7f5438604312d93b703b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/GuidEx.cs
================================================
﻿using System.Runtime.InteropServices;

namespace System
{
    [StructLayout(LayoutKind.Sequential)]
    internal struct GuidEx
    {
        private int _a;   // Do not rename (binary serialization)
        private short _b; // Do not rename (binary serialization)
        private short _c; // Do not rename (binary serialization)
        private byte _d;  // Do not rename (binary serialization)
        private byte _e;  // Do not rename (binary serialization)
        private byte _f;  // Do not rename (binary serialization)
        private byte _g;  // Do not rename (binary serialization)
        private byte _h;  // Do not rename (binary serialization)
        private byte _i;  // Do not rename (binary serialization)
        private byte _j;  // Do not rename (binary serialization)
        private byte _k;  // Do not rename (binary serialization)

        private static unsafe int HexsToChars(char* guidChars, int a, int b)
        {
            guidChars[0] = HexConverter.ToCharLower(a >> 4);
            guidChars[1] = HexConverter.ToCharLower(a);

            guidChars[2] = HexConverter.ToCharLower(b >> 4);
            guidChars[3] = HexConverter.ToCharLower(b);

            return 4;
        }

        private static unsafe int HexsToCharsHexOutput(char* guidChars, int a, int b)
        {
            guidChars[0] = '0';
            guidChars[1] = 'x';

            guidChars[2] = HexConverter.ToCharLower(a >> 4);
            guidChars[3] = HexConverter.ToCharLower(a);

            guidChars[4] = ',';
            guidChars[5] = '0';
            guidChars[6] = 'x';

            guidChars[7] = HexConverter.ToCharLower(b >> 4);
            guidChars[8] = HexConverter.ToCharLower(b);

            return 9;
        }

        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default)
        {
            if (format.Length == 0)
            {
                format = "D".AsSpan();
            }
            // all acceptable format strings are of length 1
            if (format.Length != 1)
            {
                throw new FormatException("InvalidGuidFormatSpecification");
            }

            bool dash = true;
            bool hex = false;
            int braces = 0;

            int guidSize;

            switch (format[0])
            {
                case 'D':
                case 'd':
                    guidSize = 36;
                    break;
                case 'N':
                case 'n':
                    dash = false;
                    guidSize = 32;
                    break;
                case 'B':
                case 'b':
                    braces = '{' + ('}' << 16);
                    guidSize = 38;
                    break;
                case 'P':
                case 'p':
                    braces = '(' + (')' << 16);
                    guidSize = 38;
                    break;
                case 'X':
                case 'x':
                    braces = '{' + ('}' << 16);
                    dash = false;
                    hex = true;
                    guidSize = 68;
                    break;
                default:
                    throw new FormatException("InvalidGuidFormatSpecification");
            }

            if (destination.Length < guidSize)
            {
                charsWritten = 0;
                return false;
            }

            unsafe
            {
                fixed (char* guidChars = &MemoryMarshal.GetReference(destination))
                {
                    char* p = guidChars;

                    if (braces != 0)
                        *p++ = (char)braces;

                    if (hex)
                    {
                        // {0xdddddddd,0xdddd,0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _a >> 24, _a >> 16);
                        p += HexsToChars(p, _a >> 8, _a);
                        *p++ = ',';
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _b >> 8, _b);
                        *p++ = ',';
                        *p++ = '0';
                        *p++ = 'x';
                        p += HexsToChars(p, _c >> 8, _c);
                        *p++ = ',';
                        *p++ = '{';
                        p += HexsToCharsHexOutput(p, _d, _e);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _f, _g);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _h, _i);
                        *p++ = ',';
                        p += HexsToCharsHexOutput(p, _j, _k);
                        *p++ = '}';
                    }
                    else
                    {
                        // [{|(]dddddddd[-]dddd[-]dddd[-]dddd[-]dddddddddddd[}|)]
                        p += HexsToChars(p, _a >> 24, _a >> 16);
                        p += HexsToChars(p, _a >> 8, _a);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _b >> 8, _b);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _c >> 8, _c);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _d, _e);
                        if (dash)
                            *p++ = '-';
                        p += HexsToChars(p, _f, _g);
                        p += HexsToChars(p, _h, _i);
                        p += HexsToChars(p, _j, _k);
                    }

                    if (braces != 0)
                        *p++ = (char)(braces >> 16);
                }
            }

            charsWritten = guidSize;
            return true;
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/GuidEx.cs.meta
================================================
fileFormatVersion: 2
guid: 1b4d23acb4f60434ea9257c7cc2a1815
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/HexConverter.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;

namespace System
{
    internal static class HexConverter
    {
        public enum Casing : uint
        {
            // Output [ '0' .. '9' ] and [ 'A' .. 'F' ].
            Upper = 0,

            // Output [ '0' .. '9' ] and [ 'a' .. 'f' ].
            // This works because values in the range [ 0x30 .. 0x39 ] ([ '0' .. '9' ])
            // already have the 0x20 bit set, so ORing them with 0x20 is a no-op,
            // while outputs in the range [ 0x41 .. 0x46 ] ([ 'A' .. 'F' ])
            // don't have the 0x20 bit set, so ORing them maps to
            // [ 0x61 .. 0x66 ] ([ 'a' .. 'f' ]), which is what we want.
            Lower = 0x2020U,
        }

        // We want to pack the incoming byte into a single integer [ 0000 HHHH 0000 LLLL ],
        // where HHHH and LLLL are the high and low nibbles of the incoming byte. Then
        // subtract this integer from a constant minuend as shown below.
        //
        //   [ 1000 1001 1000 1001 ]
        // - [ 0000 HHHH 0000 LLLL ]
        // =========================
        //   [ *YYY **** *ZZZ **** ]
        //
        // The end result of this is that YYY is 0b000 if HHHH <= 9, and YYY is 0b111 if HHHH >= 10.
        // Similarly, ZZZ is 0b000 if LLLL <= 9, and ZZZ is 0b111 if LLLL >= 10.
        // (We don't care about the value of asterisked bits.)
        //
        // To turn a nibble in the range [ 0 .. 9 ] into hex, we calculate hex := nibble + 48 (ascii '0').
        // To turn a nibble in the range [ 10 .. 15 ] into hex, we calculate hex := nibble - 10 + 65 (ascii 'A').
        //                                                                => hex := nibble + 55.
        // The difference in the starting ASCII offset is (55 - 48) = 7, depending on whether the nibble is <= 9 or >= 10.
        // Since 7 is 0b111, this conveniently matches the YYY or ZZZ value computed during the earlier subtraction.

        // The commented out code below is code that directly implements the logic described above.

        // uint packedOriginalValues = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU);
        // uint difference = 0x8989U - packedOriginalValues;
        // uint add7Mask = (difference & 0x7070U) >> 4; // line YYY and ZZZ back up with the packed values
        // uint packedResult = packedOriginalValues + add7Mask + 0x3030U /* ascii '0' */;

        // The code below is equivalent to the commented out code above but has been tweaked
        // to allow codegen to make some extra optimizations.

        // The low byte of the packed result contains the hex representation of the incoming byte's low nibble.
        // The adjacent byte of the packed result contains the hex representation of the incoming byte's high nibble.

        // Finally, write to the output buffer starting with the *highest* index so that codegen can
        // elide all but the first bounds check. (This only works if 'startingIndex' is a compile-time constant.)

        // The JIT can elide bounds checks if 'startingIndex' is constant and if the caller is
        // writing to a span of known length (or the caller has already checked the bounds of the
        // furthest access).
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ToBytesBuffer(byte value, Span<byte> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
        {
            uint difference = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU) - 0x8989U;
            uint packedResult = ((((uint)(-(int)difference) & 0x7070U) >> 4) + difference + 0xB9B9U) | (uint)casing;

            buffer[startingIndex + 1] = (byte)packedResult;
            buffer[startingIndex] = (byte)(packedResult >> 8);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ToCharsBuffer(byte value, Span<char> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
        {
            uint difference = (((uint)value & 0xF0U) << 4) + ((uint)value & 0x0FU) - 0x8989U;
            uint packedResult = ((((uint)(-(int)difference) & 0x7070U) >> 4) + difference + 0xB9B9U) | (uint)casing;

            buffer[startingIndex + 1] = (char)(packedResult & 0xFF);
            buffer[startingIndex] = (char)(packedResult >> 8);
        }

        public static unsafe string ToString(ReadOnlySpan<byte> bytes, Casing casing = Casing.Upper)
        {
            Span<char> result = stackalloc char[0];
            if (bytes.Length > 16)
            {
                var array = new char[bytes.Length * 2];
                result = array.AsSpan();
            }
            else
            {
                result = stackalloc char[bytes.Length * 2];
            }
 
            int pos = 0;
            foreach (byte b in bytes)
            {
                ToCharsBuffer(b, result, pos, casing);
                pos += 2;
            }
            return result.ToString();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToCharUpper(int value)
        {
            value &= 0xF;
            value += '0';

            if (value > '9')
            {
                value += ('A' - ('9' + 1));
            }

            return (char)value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static char ToCharLower(int value)
        {
            value &= 0xF;
            value += '0';

            if (value > '9')
            {
                value += ('a' - ('9' + 1));
            }

            return (char)value;
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/HexConverter.cs.meta
================================================
fileFormatVersion: 2
guid: bc55fbf8adb9a284398481db6426b327
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/InternalSpanEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace System
{
    internal static class InternalSpanEx
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool EqualsOrdinalIgnoreCase(this ReadOnlySpan<char> span, ReadOnlySpan<char> value)
        {
            if (span.Length != value.Length)
                return false;
            if (value.Length == 0)  // span.Length == value.Length == 0
                return true;
            
            

            return EqualsOrdinalIgnoreCase(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), span.Length);
        }

        static bool EqualsOrdinalIgnoreCase(ref char charA, ref char charB, int length)
        {
            IntPtr byteOffset = IntPtr.Zero;

            if (IntPtr.Size == 8)
            {
                // Read 4 chars (64 bits) at a time from each string
                while ((uint)length >= 4)
                {
                    ulong valueA = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, byteOffset)));
                    ulong valueB = Unsafe.ReadUnaligned<ulong>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, byteOffset)));

                    // A 32-bit test - even with the bit-twiddling here - is more efficient than a 64-bit test.
                    ulong temp = valueA | valueB;
                    if (!AllCharsInUInt32AreAscii((uint)temp | (uint)(temp >> 32)))
                    {
                        goto NonAscii; // one of the inputs contains non-ASCII data
                    }

                    // Generally, the caller has likely performed a first-pass check that the input strings
                    // are likely equal. Consider a dictionary which computes the hash code of its key before
                    // performing a proper deep equality check of the string contents. We want to optimize for
                    // the case where the equality check is likely to succeed, which means that we want to avoid
                    // branching within this loop unless we're about to exit the loop, either due to failure or
                    // due to us running out of input data.

                    if (!UInt64OrdinalIgnoreCaseAscii(valueA, valueB))
                    {
                        return false;
                    }

                    byteOffset += 8;
                    length -= 4;
                }
            }

            // Read 2 chars (32 bits) at a time from each string
            while ((uint)length >= 2)
            {
                uint valueA = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charA, byteOffset)));
                uint valueB = Unsafe.ReadUnaligned<uint>(ref Unsafe.As<char, byte>(ref Unsafe.AddByteOffset(ref charB, byteOffset)));

                if (!AllCharsInUInt32AreAscii(valueA | valueB))
                {
                    goto NonAscii; // one of the inputs contains non-ASCII data
                }

                // Generally, the caller has likely performed a first-pass check that the input strings
                // are likely equal. Consider a dictionary which computes the hash code of its key before
                // performing a proper deep equality check of the string contents. We want to optimize for
                // the case where the equality check is likely to succeed, which means that we want to avoid
                // branching within this loop unless we're about to exit the loop, either due to failure or
                // due to us running out of input data.

                if (!UInt32OrdinalIgnoreCaseAscii(valueA, valueB))
                {
                    return false;
                }

                byteOffset += 4;
                length -= 2;
            }

            if (length != 0)
            {
                Debug.Assert(length == 1);

                uint valueA = Unsafe.AddByteOffset(ref charA, byteOffset);
                uint valueB = Unsafe.AddByteOffset(ref charB, byteOffset);

                if ((valueA | valueB) > 0x7Fu)
                {
                    goto NonAscii; // one of the inputs contains non-ASCII data
                }

                if (valueA == valueB)
                {
                    return true; // exact match
                }

                valueA |= 0x20u;
                if ((uint)(valueA - 'a') > (uint)('z' - 'a'))
                {
                    return false; // not exact match, and first input isn't in [A-Za-z]
                }

                // The ternary operator below seems redundant but helps RyuJIT generate more optimal code.
                // See https://github.com/dotnet/coreclr/issues/914.
                return (valueA == (valueB | 0x20u)) ? true : false;
            }

            Debug.Assert(length == 0);
            return true;

            NonAscii:
            // The non-ASCII case is factored out into its own helper method so that the JIT
            // doesn't need to emit a complex prolog for its caller (this method).
            return EqualsOrdinalIgnoreCaseNonAscii(ref Unsafe.AddByteOffset(ref charA, byteOffset), ref Unsafe.AddByteOffset(ref charB, byteOffset), length);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AllCharsInUInt32AreAscii(uint value)
        {
            return (value & ~0x007F_007Fu) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool AllCharsInUInt64AreAscii(ulong value)
        {
            return (value & ~0x007F_007F_007F_007Ful) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool UInt32OrdinalIgnoreCaseAscii(uint valueA, uint valueB)
        {
            // ASSUMPTION: Caller has validated that input values are ASCII.
            Debug.Assert(AllCharsInUInt32AreAscii(valueA));
            Debug.Assert(AllCharsInUInt32AreAscii(valueB));

            // a mask of all bits which are different between A and B
            uint differentBits = valueA ^ valueB;

            // the 0x80 bit of each word of 'lowerIndicator' will be set iff the word has value < 'A'
            uint lowerIndicator = valueA + 0x0100_0100u - 0x0041_0041u;

            // the 0x80 bit of each word of 'upperIndicator' will be set iff (word | 0x20) has value > 'z'
            uint upperIndicator = (valueA | 0x0020_0020u) + 0x0080_0080u - 0x007B_007Bu;

            // the 0x80 bit of each word of 'combinedIndicator' will be set iff the word is *not* [A-Za-z]
            uint combinedIndicator = lowerIndicator | upperIndicator;

            // Shift all the 0x80 bits of 'combinedIndicator' into the 0x20 positions, then set all bits
            // aside from 0x20. This creates a mask where all bits are set *except* for the 0x20 bits
            // which correspond to alpha chars (either lower or upper). For these alpha chars only, the
            // 0x20 bit is allowed to differ between the two input values. Every other char must be an
            // exact bitwise match between the two input values. In other words, (valueA & mask) will
            // convert valueA to uppercase, so (valueA & mask) == (valueB & mask) answers "is the uppercase
            // form of valueA equal to the uppercase form of valueB?" (Technically if valueA has an alpha
            // char in the same position as a non-alpha char in valueB, or vice versa, this operation will
            // result in nonsense, but it'll still compute as inequal regardless, which is what we want ultimately.)
            // The line below is a more efficient way of doing the same check taking advantage of the XOR
            // computation we performed at the beginning of the method.

            return (((combinedIndicator >> 2) | ~0x0020_0020u) & differentBits) == 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB)
        {
            // ASSUMPTION: Caller has validated that input values are ASCII.
            Debug.Assert(AllCharsInUInt64AreAscii(valueA));
            Debug.Assert(AllCharsInUInt64AreAscii(valueB));

            // the 0x80 bit of each word of 'lowerIndicator' will be set iff the word has value >= 'A'
            ulong lowerIndicator = valueA + 0x0080_0080_0080_0080ul - 0x0041_0041_0041_0041ul;

            // the 0x80 bit of each word of 'upperIndicator' will be set iff (word | 0x20) has value <= 'z'
            ulong upperIndicator = (valueA | 0x0020_0020_0020_0020ul) + 0x0100_0100_0100_0100ul - 0x007B_007B_007B_007Bul;

            // the 0x20 bit of each word of 'combinedIndicator' will be set iff the word is [A-Za-z]
            ulong combinedIndicator = (0x0080_0080_0080_0080ul & lowerIndicator & upperIndicator) >> 2;

            // Convert both values to lowercase (using the combined indicator from the first value)
            // and compare for equality. It's possible that the first value will contain an alpha character
            // where the second value doesn't (or vice versa), and applying the combined indicator will
            // create nonsensical data, but the comparison would have failed anyway in this case so it's
            // a safe operation to perform.
            //
            // This 64-bit method is similar to the 32-bit method, but it performs the equivalent of convert-to-
            // lowercase-then-compare rather than convert-to-uppercase-and-compare. This particular operation
            // happens to be faster on x64.

            return (valueA | combinedIndicator) == (valueB | combinedIndicator);
        }

        private static bool EqualsOrdinalIgnoreCaseNonAscii(ref char charA, ref char charB, int length)
        {
            //if (!GlobalizationMode.Invariant)
            //{
            //    return CompareStringOrdinalIgnoreCase(ref charA, length, ref charB, length) == 0;
            //}
            //else
            {
                // If we don't have localization tables to consult, we'll still perform a case-insensitive
                // check for ASCII characters, but if we see anything outside the ASCII range we'll immediately
                // fail if it doesn't have true bitwise equality.

                IntPtr byteOffset = IntPtr.Zero;
                while (length != 0)
                {
                    // Ordinal equals or lowercase equals if the result ends up in the a-z range
                    uint valueA = Unsafe.AddByteOffset(ref charA, byteOffset);
                    uint valueB = Unsafe.AddByteOffset(ref charB, byteOffset);

                    if (valueA == valueB ||
                        ((valueA | 0x20) == (valueB | 0x20) &&
                            (uint)((valueA | 0x20) - 'a') <= (uint)('z' - 'a')))
                    {
                        byteOffset += 2;
                        length--;
                    }
                    else
                    {
                        return false;
                    }
                }

                return true;
            }
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/InternalSpanEx.cs.meta
================================================
fileFormatVersion: 2
guid: 35ddb60e00efb154aa26c3d822b656eb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/MathEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static class MathEx
    {
        public static uint DivRem(uint a, uint b, out uint result)
        {
            uint div = a / b;
            result = a - (div * b);
            return div;
        }

        public static ulong DivRem(ulong a, ulong b, out ulong result)
        {
            ulong div = a / b;
            result = a - (div * b);
            return div;
        }

        public static int DivRem(int a, int b, out int result)
        {
            int div = a / b;
            result = a - (div * b);
            return div;
        }

        public static long DivRem(long a, long b, out long result)
        {
            long div = a / b;
            result = a - (div * b);
            return div;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Clamp(byte value, byte min, byte max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static decimal Clamp(decimal value, decimal min, decimal max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Clamp(double value, double min, double max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short Clamp(short value, short min, short max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Clamp(int value, int min, int max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Clamp(long value, long min, long max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static sbyte Clamp(sbyte value, sbyte min, sbyte max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Clamp(float value, float min, float max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Clamp(ushort value, ushort min, ushort max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Clamp(uint value, uint min, uint max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Clamp(ulong value, ulong min, ulong max)
        {
            if (min > max)
            {
                ThrowMinMaxException(min, max);
            }

            if (value < min)
            {
                return min;
            }
            else if (value > max)
            {
                return max;
            }

            return value;
        }

        private static void ThrowMinMaxException<T>(T min, T max)
        {
            throw new ArgumentException($"Argument_MinMaxValue, min:{min} max:{max}");
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/MathEx.cs.meta
================================================
fileFormatVersion: 2
guid: 7b74132cfedcf0e428e2b0760181072f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.BigInteger.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System
{
    internal static partial class Number
    {
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        internal unsafe ref struct BigInteger
        {
            // The longest binary mantissa requires: explicit mantissa bits + abs(min exponent)
            // * Half:     10 +    14 =    24
            // * Single:   23 +   126 =   149
            // * Double:   52 +  1022 =  1074
            // * Quad:    112 + 16382 = 16494
            private const int BitsForLongestBinaryMantissa = 1074;

            // The longest digit sequence requires: ceil(log2(pow(10, max significant digits + 1 rounding digit)))
            // * Half:    ceil(log2(pow(10,    21 + 1))) =    74
            // * Single:  ceil(log2(pow(10,   112 + 1))) =   376
            // * Double:  ceil(log2(pow(10,   767 + 1))) =  2552
            // * Quad:    ceil(log2(pow(10, 11563 + 1))) = 38415
            private const int BitsForLongestDigitSequence = 2552;

            // We require BitsPerBlock additional bits for shift space used during the pre-division preparation
            private const int MaxBits = BitsForLongestBinaryMantissa + BitsForLongestDigitSequence + BitsPerBlock;

            private const int BitsPerBlock = sizeof(int) * 8;
            private const int MaxBlockCount = (MaxBits + (BitsPerBlock - 1)) / BitsPerBlock;

            private static readonly uint[] s_Pow10UInt32Table = new uint[]
            {
                1,          // 10^0
                10,         // 10^1
                100,        // 10^2
                1000,       // 10^3
                10000,      // 10^4
                100000,     // 10^5
                1000000,    // 10^6
                10000000,   // 10^7
            };

            private static readonly int[] s_Pow10BigNumTableIndices = new int[]
            {
                0,          // 10^8
                2,          // 10^16
                5,          // 10^32
                10,         // 10^64
                18,         // 10^128
                33,         // 10^256
                61,         // 10^512
                116,        // 10^1024
            };

            private static readonly uint[] s_Pow10BigNumTable = new uint[]
            {
                // 10^8
                1,          // _length
                100000000,  // _blocks
 
                // 10^16
                2,          // _length
                0x6FC10000, // _blocks
                0x002386F2,
 
                // 10^32
                4,          // _length
                0x00000000, // _blocks
                0x85ACEF81,
                0x2D6D415B,
                0x000004EE,
 
                // 10^64
                7,          // _length
                0x00000000, // _blocks
                0x00000000,
                0xBF6A1F01,
                0x6E38ED64,
                0xDAA797ED,
                0xE93FF9F4,
                0x00184F03,
 
                // 10^128
                14,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x2E953E01,
                0x03DF9909,
                0x0F1538FD,
                0x2374E42F,
                0xD3CFF5EC,
                0xC404DC08,
                0xBCCDB0DA,
                0xA6337F19,
                0xE91F2603,
                0x0000024E,
 
                // 10^256
                27,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x982E7C01,
                0xBED3875B,
                0xD8D99F72,
                0x12152F87,
                0x6BDE50C6,
                0xCF4A6E70,
                0xD595D80F,
                0x26B2716E,
                0xADC666B0,
                0x1D153624,
                0x3C42D35A,
                0x63FF540E,
                0xCC5573C0,
                0x65F9EF17,
                0x55BC28F2,
                0x80DCC7F7,
                0xF46EEDDC,
                0x5FDCEFCE,
                0x000553F7,
 
                // 10^512
                54,         // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0xFC6CF801,
                0x77F27267,
                0x8F9546DC,
                0x5D96976F,
                0xB83A8A97,
                0xC31E1AD9,
                0x46C40513,
                0x94E65747,
                0xC88976C1,
                0x4475B579,
                0x28F8733B,
                0xAA1DA1BF,
                0x703ED321,
                0x1E25CFEA,
                0xB21A2F22,
                0xBC51FB2E,
                0x96E14F5D,
                0xBFA3EDAC,
                0x329C57AE,
                0xE7FC7153,
                0xC3FC0695,
                0x85A91924,
                0xF95F635E,
                0xB2908EE0,
                0x93ABADE4,
                0x1366732A,
                0x9449775C,
                0x69BE5B0E,
                0x7343AFAC,
                0xB099BC81,
                0x45A71D46,
                0xA2699748,
                0x8CB07303,
                0x8A0B1F13,
                0x8CAB8A97,
                0xC1D238D9,
                0x633415D4,
                0x0000001C,
 
                // 10^1024
                107,        // _length
                0x00000000, // _blocks
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x2919F001,
                0xF55B2B72,
                0x6E7C215B,
                0x1EC29F86,
                0x991C4E87,
                0x15C51A88,
                0x140AC535,
                0x4C7D1E1A,
                0xCC2CD819,
                0x0ED1440E,
                0x896634EE,
                0x7DE16CFB,
                0x1E43F61F,
                0x9FCE837D,
                0x231D2B9C,
                0x233E55C7,
                0x65DC60D7,
                0xF451218B,
                0x1C5CD134,
                0xC9635986,
                0x922BBB9F,
                0xA7E89431,
                0x9F9F2A07,
                0x62BE695A,
                0x8E1042C4,
                0x045B7A74,
                0x1ABE1DE3,
                0x8AD822A5,
                0xBA34C411,
                0xD814B505,
                0xBF3FDEB3,
                0x8FC51A16,
                0xB1B896BC,
                0xF56DEEEC,
                0x31FB6BFD,
                0xB6F4654B,
                0x101A3616,
                0x6B7595FB,
                0xDC1A47FE,
                0x80D98089,
                0x80BDA5A5,
                0x9A202882,
                0x31EB0F66,
                0xFC8F1F90,
                0x976A3310,
                0xE26A7B7E,
                0xDF68368A,
                0x3CE3A0B8,
                0x8E4262CE,
                0x75A351A2,
                0x6CB0B6C9,
                0x44597583,
                0x31B5653F,
                0xC356E38A,
                0x35FAABA6,
                0x0190FBA0,
                0x9FC4ED52,
                0x88BC491B,
                0x1640114A,
                0x005B8041,
                0xF4F3235E,
                0x1E8D4649,
                0x36A8DE06,
                0x73C55349,
                0xA7E6BD2A,
                0xC1A6970C,
                0x47187094,
                0xD2DB49EF,
                0x926C3F5B,
                0xAE6209D4,
                0x2D433949,
                0x34F4A3C6,
                0xD4305D94,
                0xD9D61A05,
                0x00000325,
 
                // 9 Trailing blocks to ensure MaxBlockCount
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
                0x00000000,
            };

            private int _length;
            private fixed uint _blocks[MaxBlockCount];

            public static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
            {
                // determine which operand has the smaller length
                ref BigInteger large = ref (lhs._length < rhs._length) ? ref rhs : ref lhs;
                ref BigInteger small = ref (lhs._length < rhs._length) ? ref lhs : ref rhs;

                int largeLength = large._length;
                int smallLength = small._length;

                // The output will be at least as long as the largest input
                result._length = largeLength;

                // Add each block and add carry the overflow to the next block
                ulong carry = 0;

                int largeIndex = 0;
                int smallIndex = 0;
                int resultIndex = 0;

                while (smallIndex < smallLength)
                {
                    ulong sum = carry + large._blocks[largeIndex] + small._blocks[smallIndex];
                    carry = sum >> 32;
                    result._blocks[resultIndex] = (uint)(sum);

                    largeIndex++;
                    smallIndex++;
                    resultIndex++;
                }

                // Add the carry to any blocks that only exist in the large operand
                while (largeIndex < largeLength)
                {
                    ulong sum = carry + large._blocks[largeIndex];
                    carry = sum >> 32;
                    result._blocks[resultIndex] = (uint)(sum);

                    largeIndex++;
                    resultIndex++;
                }

                // If there's still a carry, append a new block
                if (carry != 0)
                {
                    Debug.Assert(carry == 1);
                    Debug.Assert((resultIndex == largeLength) && (largeLength < MaxBlockCount));

                    result._blocks[resultIndex] = 1;
                    result._length++;
                }
            }

            public static int Compare(ref BigInteger lhs, ref BigInteger rhs)
            {
                Debug.Assert(unchecked((uint)(lhs._length)) <= MaxBlockCount);
                Debug.Assert(unchecked((uint)(rhs._length)) <= MaxBlockCount);

                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                int lengthDelta = (lhsLength - rhsLength);

                if (lengthDelta != 0)
                {
                    return lengthDelta;
                }

                if (lhsLength == 0)
                {
                    Debug.Assert(rhsLength == 0);
                    return 0;
                }

                for (int index = (lhsLength - 1); index >= 0; index--)
                {
                    long delta = (long)(lhs._blocks[index]) - rhs._blocks[index];

                    if (delta != 0)
                    {
                        return delta > 0 ? 1 : -1;
                    }
                }

                return 0;
            }

            public static uint CountSignificantBits(uint value)
            {
                return 32 - (uint)BitOperations.LeadingZeroCount(value);
            }

            public static uint CountSignificantBits(ulong value)
            {
                return 64 - (uint)BitOperations.LeadingZeroCount(value);
            }

            public static uint CountSignificantBits(ref BigInteger value)
            {
                if (value.IsZero())
                {
                    return 0;
                }

                // We don't track any unused blocks, so we only need to do a BSR on the
                // last index and add that to the number of bits we skipped.

                uint lastIndex = (uint)(value._length - 1);
                return (lastIndex * BitsPerBlock) + CountSignificantBits(value._blocks[lastIndex]);
            }

            public static void DivRem(ref BigInteger lhs, ref BigInteger rhs, out BigInteger quo, out BigInteger rem)
            {
                // This is modified from the libraries BigIntegerCalculator.DivRem.cs implementation:
                // https://github.com/dotnet/runtime/blob/master/src/libraries/System.Runtime.Numerics/src/System/Numerics/BigIntegerCalculator.DivRem.cs

                Debug.Assert(!rhs.IsZero());

                if (lhs.IsZero())
                {
                    SetZero(out quo);
                    SetZero(out rem);
                    return;
                }

                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                if ((lhsLength == 1) && (rhsLength == 1))
                {
                    uint quotient = MathEx.DivRem(lhs._blocks[0], rhs._blocks[0], out uint remainder);
                    SetUInt32(out quo, quotient);
                    SetUInt32(out rem, remainder);
                    return;
                }

                if (rhsLength == 1)
                {
                    // We can make the computation much simpler if the rhs is only one block

                    int quoLength = lhsLength;

                    ulong rhsValue = rhs._blocks[0];
                    ulong carry = 0;

                    for (int i = quoLength - 1; i >= 0; i--)
                    {
                        ulong value = (carry << 32) | lhs._blocks[i];
                        ulong digit = MathEx.DivRem(value, rhsValue, out carry);

                        if ((digit == 0) && (i == (quoLength - 1)))
                        {
                            quoLength--;
                        }
                        else
                        {
                            quo._blocks[i] = (uint)(digit);
                        }
                    }

                    quo._length = quoLength;
                    SetUInt32(out rem, (uint)(carry));

                    return;
                }
                else if (rhsLength > lhsLength)
                {
                    // Handle the case where we have no quotient
                    SetZero(out quo);
                    SetValue(out rem, ref lhs);
                    return;
                }
                else
                {
                    int quoLength = lhsLength - rhsLength + 1;
                    SetValue(out rem, ref lhs);
                    int remLength = lhsLength;

                    // Executes the "grammar-school" algorithm for computing q = a / b.
                    // Before calculating q_i, we get more bits into the highest bit
                    // block of the divisor. Thus, guessing digits of the quotient
                    // will be more precise. Additionally we'll get r = a % b.

                    uint divHi = rhs._blocks[rhsLength - 1];
                    uint divLo = rhs._blocks[rhsLength - 2];

                    // We measure the leading zeros of the divisor
                    int shiftLeft = BitOperations.LeadingZeroCount(divHi);
                    int shiftRight = 32 - shiftLeft;

                    // And, we make sure the most significant bit is set
                    if (shiftLeft > 0)
                    {
                        divHi = (divHi << shiftLeft) | (divLo >> shiftRight);
                        divLo <<= shiftLeft;

                        if (rhsLength > 2)
                        {
                            divLo |= (rhs._blocks[rhsLength - 3] >> shiftRight);
                        }
                    }

                    // Then, we divide all of the bits as we would do it using
                    // pen and paper: guessing the next digit, subtracting, ...
                    for (int i = lhsLength; i >= rhsLength; i--)
                    {
                        int n = i - rhsLength;
                        uint t = i < lhsLength ? rem._blocks[i] : 0;

                        ulong valHi = ((ulong)(t) << 32) | rem._blocks[i - 1];
                        uint valLo = i > 1 ? rem._blocks[i - 2] : 0;

                        // We shifted the divisor, we shift the dividend too
                        if (shiftLeft > 0)
                        {
                            valHi = (valHi << shiftLeft) | (valLo >> shiftRight);
                            valLo <<= shiftLeft;

                            if (i > 2)
                            {
                                valLo |= (rem._blocks[i - 3] >> shiftRight);
                            }
                        }

                        // First guess for the current digit of the quotient,
                        // which naturally must have only 32 bits...
                        ulong digit = valHi / divHi;

                        if (digit > uint.MaxValue)
                        {
                            digit = uint.MaxValue;
                        }

                        // Our first guess may be a little bit to big
                        while (DivideGuessTooBig(digit, valHi, valLo, divHi, divLo))
                        {
                            digit--;
                        }

                        if (digit > 0)
                        {
                            // Now it's time to subtract our current quotient
                            uint carry = SubtractDivisor(ref rem, n, ref rhs, digit);

                            if (carry != t)
                            {
                                Debug.Assert(carry == t + 1);

                                // Our guess was still exactly one too high
                                carry = AddDivisor(ref rem, n, ref rhs);
                                digit--;

                                Debug.Assert(carry == 1);
                            }
                        }

                        // We have the digit!
                        if (quoLength != 0)
                        {
                            if ((digit == 0) && (n == (quoLength - 1)))
                            {
                                quoLength--;
                            }
                            else
                            {
                                quo._blocks[n] = (uint)(digit);
                            }
                        }

                        if (i < remLength)
                        {
                            remLength--;
                        }
                    }

                    quo._length = quoLength;

                    // We need to check for the case where remainder is zero

                    for (int i = remLength - 1; i >= 0; i--)
                    {
                        if (rem._blocks[i] == 0)
                        {
                            remLength--;
                        }
                    }

                    rem._length = remLength;
                }
            }

            public static uint HeuristicDivide(ref BigInteger dividend, ref BigInteger divisor)
            {
                int divisorLength = divisor._length;

                if (dividend._length < divisorLength)
                {
                    return 0;
                }

                // This is an estimated quotient. Its error should be less than 2.
                // Reference inequality:
                // a/b - floor(floor(a)/(floor(b) + 1)) < 2
                int lastIndex = (divisorLength - 1);
                uint quotient = dividend._blocks[lastIndex] / (divisor._blocks[lastIndex] + 1);

                if (quotient != 0)
                {
                    // Now we use our estimated quotient to update each block of dividend.
                    // dividend = dividend - divisor * quotient
                    int index = 0;

                    ulong borrow = 0;
                    ulong carry = 0;

                    do
                    {
                        ulong product = ((ulong)(divisor._blocks[index]) * quotient) + carry;
                        carry = product >> 32;

                        ulong difference = (ulong)(dividend._blocks[index]) - (uint)(product) - borrow;
                        borrow = (difference >> 32) & 1;

                        dividend._blocks[index] = (uint)(difference);

                        index++;
                    }
                    while (index < divisorLength);

                    // Remove all leading zero blocks from dividend
                    while ((divisorLength > 0) && (dividend._blocks[divisorLength - 1] == 0))
                    {
                        divisorLength--;
                    }

                    dividend._length = divisorLength;
                }

                // If the dividend is still larger than the divisor, we overshot our estimate quotient. To correct,
                // we increment the quotient and subtract one more divisor from the dividend (Because we guaranteed the error range).
                if (Compare(ref dividend, ref divisor) >= 0)
                {
                    quotient++;

                    // dividend = dividend - divisor
                    int index = 0;
                    ulong borrow = 0;

                    do
                    {
                        ulong difference = (ulong)(dividend._blocks[index]) - divisor._blocks[index] - borrow;
                        borrow = (difference >> 32) & 1;

                        dividend._blocks[index] = (uint)(difference);

                        index++;
                    }
                    while (index < divisorLength);

                    // Remove all leading zero blocks from dividend
                    while ((divisorLength > 0) && (dividend._blocks[divisorLength - 1] == 0))
                    {
                        divisorLength--;
                    }

                    dividend._length = divisorLength;
                }

                return quotient;
            }

            public static void Multiply(ref BigInteger lhs, uint value, out BigInteger result)
            {
                if (lhs.IsZero() || (value == 1))
                {
                    SetValue(out result, ref lhs);
                    return;
                }

                if (value == 0)
                {
                    SetZero(out result);
                    return;
                }

                int lhsLength = lhs._length;
                int index = 0;
                uint carry = 0;

                while (index < lhsLength)
                {
                    ulong product = ((ulong)(lhs._blocks[index]) * value) + carry;
                    result._blocks[index] = (uint)(product);
                    carry = (uint)(product >> 32);

                    index++;
                }

                if (carry != 0)
                {
                    Debug.Assert(unchecked((uint)(lhsLength)) + 1 <= MaxBlockCount);
                    result._blocks[index] = carry;
                    result._length = (lhsLength + 1);
                }
                else
                {
                    result._length = lhsLength;
                }
            }

            public static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
            {
                if (lhs.IsZero() || rhs.IsOne())
                {
                    SetValue(out result, ref lhs);
                    return;
                }

                if (rhs.IsZero())
                {
                    SetZero(out result);
                    return;
                }

                ref readonly BigInteger large = ref lhs;
                int largeLength = lhs._length;

                ref readonly BigInteger small = ref rhs;
                int smallLength = rhs._length;

                if (largeLength < smallLength)
                {
                    large = ref rhs;
                    largeLength = rhs._length;

                    small = ref lhs;
                    smallLength = lhs._length;
                }

                int maxResultLength = smallLength + largeLength;
                Debug.Assert(unchecked((uint)(maxResultLength)) <= MaxBlockCount);

                // Zero out result internal blocks.
                result._length = maxResultLength;
                BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), (uint)maxResultLength * sizeof(uint));

                int smallIndex = 0;
                int resultStartIndex = 0;

                while (smallIndex < smallLength)
                {
                    // Multiply each block of large BigNum.
                    if (small._blocks[smallIndex] != 0)
                    {
                        int largeIndex = 0;
                        int resultIndex = resultStartIndex;

                        ulong carry = 0;

                        do
                        {
                            ulong product = result._blocks[resultIndex] + ((ulong)(small._blocks[smallIndex]) * large._blocks[largeIndex]) + carry;
                            carry = product >> 32;
                            result._blocks[resultIndex] = (uint)(product);

                            resultIndex++;
                            largeIndex++;
                        }
                        while (largeIndex < largeLength);

                        result._blocks[resultIndex] = (uint)(carry);
                    }

                    smallIndex++;
                    resultStartIndex++;
                }

                if ((maxResultLength > 0) && (result._blocks[maxResultLength - 1] == 0))
                {
                    result._length--;
                }
            }

            public static void Pow2(uint exponent, out BigInteger result)
            {
                uint blocksToShift = DivRem32(exponent, out uint remainingBitsToShift);
                result._length = (int)blocksToShift + 1;
                Debug.Assert(unchecked((uint)result._length) <= MaxBlockCount);
                if (blocksToShift > 0)
                {
                    BufferEx.ZeroMemory((byte*)result.GetBlocksPointer(), blocksToShift * sizeof(uint));
                }
                result._blocks[blocksToShift] = 1U << (int)(remainingBitsToShift);
            }

            public static void Pow10(uint exponent, out BigInteger result)
            {
                // We leverage two arrays - s_Pow10UInt32Table and s_Pow10BigNumTable to speed up the Pow10 calculation.
                //
                // s_Pow10UInt32Table stores the results of 10^0 to 10^7.
                // s_Pow10BigNumTable stores the results of 10^8, 10^16, 10^32, 10^64, 10^128, 10^256, and 10^512
                //
                // For example, let's say exp = 0b111111. We can split the exp to two parts, one is small exp,
                // which 10^smallExp can be represented as uint, another part is 10^bigExp, which must be represented as BigNum.
                // So the result should be 10^smallExp * 10^bigExp.
                //
                // Calculating 10^smallExp is simple, we just lookup the 10^smallExp from s_Pow10UInt32Table.
                // But here's a bad news: although uint can represent 10^9, exp 9's binary representation is 1001.
                // That means 10^(1011), 10^(1101), 10^(1111) all cannot be stored as uint, we cannot easily say something like:
                // "Any bits <= 3 is small exp, any bits > 3 is big exp". So instead of involving 10^8, 10^9 to s_Pow10UInt32Table,
                // consider 10^8 and 10^9 as a bigNum, so they fall into s_Pow10BigNumTable. Now we can have a simple rule:
                // "Any bits <= 3 is small exp, any bits > 3 is big exp".
                //
                // For 0b111111, we first calculate 10^(smallExp), which is 10^(7), now we can shift right 3 bits, prepare to calculate the bigExp part,
                // the exp now becomes 0b000111.
                //
                // Apparently the lowest bit of bigExp should represent 10^8 because we have already shifted 3 bits for smallExp, so s_Pow10BigNumTable[0] = 10^8.
                // Now let's shift exp right 1 bit, the lowest bit should represent 10^(8 * 2) = 10^16, and so on...
                //
                // That's why we just need the values of s_Pow10BigNumTable be power of 2.
                //
                // More details of this implementation can be found at: https://github.com/dotnet/coreclr/pull/12894#discussion_r128890596

                // Validate that `s_Pow10BigNumTable` has exactly enough trailing elements to fill a BigInteger (which contains MaxBlockCount + 1 elements)
                // We validate here, since this is the only current consumer of the array
                Debug.Assert((s_Pow10BigNumTableIndices[s_Pow10BigNumTableIndices.Length - 1] + MaxBlockCount + 2) == s_Pow10BigNumTable.Length);

                SetUInt32(out BigInteger temp1, s_Pow10UInt32Table[exponent & 0x7]);
                ref BigInteger lhs = ref temp1;

                SetZero(out BigInteger temp2);
                ref BigInteger product = ref temp2;

                exponent >>= 3;
                uint index = 0;

                while (exponent != 0)
                {
                    // If the current bit is set, multiply it with the corresponding power of 10
                    if ((exponent & 1) != 0)
                    {
                        // Multiply into the next temporary
                        fixed (uint* pBigNumEntry = &s_Pow10BigNumTable[s_Pow10BigNumTableIndices[index]])
                        {
                            ref BigInteger rhs = ref *(BigInteger*)(pBigNumEntry);
                            Multiply(ref lhs, ref rhs, out product);
                        }

                        // Swap to the next temporary
                        ref BigInteger temp = ref product;
                        product = ref lhs;
                        lhs = ref temp;
                    }

                    // Advance to the next bit
                    ++index;
                    exponent >>= 1;
                }

                SetValue(out result, ref lhs);
            }

            private static uint AddDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs)
            {
                int lhsLength = lhs._length;
                int rhsLength = rhs._length;

                Debug.Assert(lhsLength >= 0);
                Debug.Assert(rhsLength >= 0);
                Debug.Assert(lhsLength >= rhsLength);

                // Repairs the dividend, if the last subtract was too much

                ulong carry = 0UL;

                for (int i = 0; i < rhsLength; i++)
                {
                    ref uint lhsValue = ref lhs._blocks[lhsStartIndex + i];

                    ulong digit = lhsValue + carry + rhs._blocks[i];
                    lhsValue = unchecked((uint)digit);
                    carry = digit >> 32;
                }

                return (uint)(carry);
            }

            private static bool DivideGuessTooBig(ulong q, ulong valHi, uint valLo, uint divHi, uint divLo)
            {
                Debug.Assert(q <= 0xFFFFFFFF);

                // We multiply the two most significant limbs of the divisor
                // with the current guess for the quotient. If those are bigger
                // than the three most significant limbs of the current dividend
                // we return true, which means the current guess is still too big.

                ulong chkHi = divHi * q;
                ulong chkLo = divLo * q;

                chkHi += (chkLo >> 32);
                chkLo &= uint.MaxValue;

                if (chkHi < valHi)
                    return false;

                if (chkHi > valHi)
                    return true;

                if (chkLo < valLo)
                    return false;

                if (chkLo > valLo)
                    return true;

                return false;
            }

            private static uint SubtractDivisor(ref BigInteger lhs, int lhsStartIndex, ref BigInteger rhs, ulong q)
            {
                int lhsLength = lhs._length - lhsStartIndex;
                int rhsLength = rhs._length;

                Debug.Assert(lhsLength >= 0);
                Debug.Assert(rhsLength >= 0);
                Debug.Assert(lhsLength >= rhsLength);
                Debug.Assert(q <= uint.MaxValue);

                // Combines a subtract and a multiply operation, which is naturally
                // more efficient than multiplying and then subtracting...

                ulong carry = 0;

                for (int i = 0; i < rhsLength; i++)
                {
                    carry += rhs._blocks[i] * q;
                    uint digit = unchecked((uint)carry);
                    carry >>= 32;

                    ref uint lhsValue = ref lhs._blocks[lhsStartIndex + i];

                    if (lhsValue < digit)
                    {
                        carry++;
                    }

                    lhsValue = unchecked(lhsValue - digit);
                }

                return (uint)(carry);
            }

            public void Add(uint value)
            {
                int length = _length;
                if (length == 0)
                {
                    SetUInt32(out this, value);
                    return;
                }

                _blocks[0] += value;
                if (_blocks[0] >= value)
                {
                    // No carry
                    return;
                }

                for (int index = 1; index < length; index++)
                {
                    _blocks[index]++;
                    if (_blocks[index] > 0)
                    {
                        // No carry
                        return;
                    }
                }

                Debug.Assert(unchecked((uint)(length)) + 1 <= MaxBlockCount);
                _blocks[length] = 1;
                _length = length + 1;
            }

            public uint GetBlock(uint index)
            {
                Debug.Assert(index < _length);
                return _blocks[index];
            }

            public int GetLength()
            {
                return _length;
            }

            public bool IsOne()
            {
                return (_length == 1)
                    && (_blocks[0] == 1);
            }

            public bool IsZero()
            {
                return _length == 0;
            }

            public void Multiply(uint value)
            {
                Multiply(ref this, value, out this);
            }

            public void Multiply(ref BigInteger value)
            {
                SetValue(out BigInteger temp, ref this);
                Multiply(ref temp, ref value, out this);
            }

            public void Multiply10()
            {
                if (IsZero())
                {
                    return;
                }

                int index = 0;
                int length = _length;
                ulong carry = 0;

                while (index < length)
                {
                    ulong block = (ulong)(_blocks[index]);
                    ulong product = (block << 3) + (block << 1) + carry;
                    carry = product >> 32;
                    _blocks[index] = (uint)(product);

                    index++;
                }

                if (carry != 0)
                {
                    Debug.Assert(unchecked((uint)(_length)) + 1 <= MaxBlockCount);
                    _blocks[index] = (uint)carry;
                    _length++;
                }
            }

            public void MultiplyPow10(uint exponent)
            {
                if (IsZero())
                {
                    return;
                }

                Pow10(exponent, out BigInteger poweredValue);

                if (poweredValue._length == 1)
                {
                    Multiply(poweredValue._blocks[0]);
                }
                else
                {
                    Multiply(ref poweredValue);
                }
            }

            public static void SetUInt32(out BigInteger result, uint value)
            {
                if (value == 0)
                {
                    SetZero(out result);
                }
                else
                {
                    result._blocks[0] = value;
                    result._length = 1;
                }
            }

            public static void SetUInt64(out BigInteger result, ulong value)
            {
                if (value <= uint.MaxValue)
                {
                    SetUInt32(out result, (uint)(value));
                }
                else
                {
                    result._blocks[0] = (uint)(value);
                    result._blocks[1] = (uint)(value >> 32);

                    result._length = 2;
                }
            }

            public static void SetValue(out BigInteger result, ref BigInteger value)
            {
                int rhsLength = value._length;
                result._length = rhsLength;
                BufferEx.Memcpy((byte*)result.GetBlocksPointer(), (byte*)value.GetBlocksPointer(), rhsLength * sizeof(uint));
            }

            public static void SetZero(out BigInteger result)
            {
                result._length = 0;
            }

            public void ShiftLeft(uint shift)
            {
                // Process blocks high to low so that we can safely process in place
                int length = _length;

                if ((length == 0) || (shift == 0))
                {
                    return;
                }

                uint blocksToShift = DivRem32(shift, out uint remainingBitsToShift);

                // Copy blocks from high to low
                int readIndex = (length - 1);
                int writeIndex = readIndex + (int)(blocksToShift);

                // Check if the shift is block aligned
                if (remainingBitsToShift == 0)
                {
                    Debug.Assert(writeIndex < MaxBlockCount);

                    while (readIndex >= 0)
                    {
                        _blocks[writeIndex] = _blocks[readIndex];
                        readIndex--;
                        writeIndex--;
                    }

                    _length += (int)(blocksToShift);

                    // Zero the remaining low blocks
                    BufferEx.ZeroMemory((byte*)GetBlocksPointer(), blocksToShift * sizeof(uint));
                }
                else
                {
                    // We need an extra block for the partial shift
                    writeIndex++;
                    Debug.Assert(writeIndex < MaxBlockCount);

                    // Set the length to hold the shifted blocks
                    _length = writeIndex + 1;

                    // Output the initial blocks
                    uint lowBitsShift = (32 - remainingBitsToShift);
                    uint highBits = 0;
                    uint block = _blocks[readIndex];
                    uint lowBits = block >> (int)(lowBitsShift);
                    while (readIndex > 0)
                    {
                        _blocks[writeIndex] = highBits | lowBits;
                        highBits = block << (int)(remainingBitsToShift);

                        --readIndex;
                        --writeIndex;

                        block = _blocks[readIndex];
                        lowBits = block >> (int)lowBitsShift;
                    }

                    // Output the final blocks
                    _blocks[writeIndex] = highBits | lowBits;
                    _blocks[writeIndex - 1] = block << (int)(remainingBitsToShift);

                    // Zero the remaining low blocks
                    BufferEx.ZeroMemory((byte*)GetBlocksPointer(), blocksToShift * sizeof(uint));

                    // Check if the terminating block has no set bits
                    if (_blocks[_length - 1] == 0)
                    {
                        _length--;
                    }
                }
            }

            public ulong ToUInt64()
            {
                if (_length > 1)
                {
                    return ((ulong)(_blocks[1]) << 32) + _blocks[0];
                }

                if (_length > 0)
                {
                    return _blocks[0];
                }

                return 0;
            }

            private uint* GetBlocksPointer()
            {
                // This is safe to do since we are a ref struct
                return (uint*)(Unsafe.AsPointer(ref _blocks[0]));
            }

            private static uint DivRem32(uint value, out uint remainder)
            {
                remainder = value & 31;
                return value >> 5;
            }
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.BigInteger.cs.meta
================================================
fileFormatVersion: 2
guid: 6ee7ab6f12adee945a329388c6efd7cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.DiyFp.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;

namespace System
{
    internal static partial class Number
    {
        // This is a port of the `DiyFp` implementation here: https://github.com/google/double-conversion/blob/a711666ddd063eb1e4b181a6cb981d39a1fc8bac/double-conversion/diy-fp.h
        // The backing structure and how it is used is described in more detail here: http://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf

        // This "Do It Yourself Floating Point" class implements a floating-point number with a ulong significand and an int exponent.
        // Normalized DiyFp numbers will have the most significant bit of the significand set.
        // Multiplication and Subtraction do not normalize their results.
        // DiyFp are not designed to contain special doubles (NaN and Infinity).
        internal readonly ref struct DiyFp
        {
            public const int DoubleImplicitBitIndex = 52;
            public const int SingleImplicitBitIndex = 23;

            public const int SignificandSize = 64;

            public readonly ulong f;
            public readonly int e;

            // Computes the two boundaries of value.
            //
            // The bigger boundary (mPlus) is normalized.
            // The lower boundary has the same exponent as mPlus.
            //
            // Precondition:
            //  The value encoded by value must be greater than 0.
            public static DiyFp CreateAndGetBoundaries(double value, out DiyFp mMinus, out DiyFp mPlus)
            {
                var result = new DiyFp(value);
                result.GetBoundaries(DoubleImplicitBitIndex, out mMinus, out mPlus);
                return result;
            }

            // Computes the two boundaries of value.
            //
            // The bigger boundary (mPlus) is normalized.
            // The lower boundary has the same exponent as mPlus.
            //
            // Precondition:
            //  The value encoded by value must be greater than 0.
            public static DiyFp CreateAndGetBoundaries(float value, out DiyFp mMinus, out DiyFp mPlus)
            {
                var result = new DiyFp(value);
                result.GetBoundaries(SingleImplicitBitIndex, out mMinus, out mPlus);
                return result;
            }

            public DiyFp(double value)
            {
                //Debug.Assert(double.IsFinite(value));
                Debug.Assert(value > 0.0);
                f = ExtractFractionAndBiasedExponent(value, out e);
            }

            public DiyFp(float value)
            {
                //Debug.Assert(float.IsFinite(value));
                Debug.Assert(value > 0.0f);
                f = ExtractFractionAndBiasedExponent(value, out e);
            }

            public DiyFp(ulong f, int e)
            {
                this.f = f;
                this.e = e;
            }

            public DiyFp Multiply(in DiyFp other)
            {
                // Simply "emulates" a 128-bit multiplication
                //
                // However: the resulting number only contains 64-bits. The least
                // signficant 64-bits are only used for rounding the most significant
                // 64-bits.

                uint a = (uint)(f >> 32);
                uint b = (uint)(f);

                uint c = (uint)(other.f >> 32);
                uint d = (uint)(other.f);

                ulong ac = ((ulong)(a) * c);
                ulong bc = ((ulong)(b) * c);
                ulong ad = ((ulong)(a) * d);
                ulong bd = ((ulong)(b) * d);

                ulong tmp = (bd >> 32) + (uint)(ad) + (uint)(bc);

                // By adding (1UL << 31) to tmp, we round the final result.
                // Halfway cases will be rounded up.

                tmp += (1U << 31);

                return new DiyFp(ac + (ad >> 32) + (bc >> 32) + (tmp >> 32), e + other.e + SignificandSize);
            }

            public DiyFp Normalize()
            {
                // This method is mainly called for normalizing boundaries.
                //
                // We deviate from the reference implementation by just using
                // our LeadingZeroCount function so that we only need to shift
                // and subtract once.

                Debug.Assert(f != 0);
                int lzcnt = BitOperations.LeadingZeroCount(f);
                return new DiyFp(f << lzcnt, e - lzcnt);
            }

            // The exponents of both numbers must be the same.
            // The significand of 'this' must be bigger than the significand of 'other'.
            // The result will not be normalized.
            public DiyFp Subtract(in DiyFp other)
            {
                Debug.Assert(e == other.e);
                Debug.Assert(f >= other.f);
                return new DiyFp(f - other.f, e);
            }

            private void GetBoundaries(int implicitBitIndex, out DiyFp mMinus, out DiyFp mPlus)
            {
                mPlus = new DiyFp((f << 1) + 1, e - 1).Normalize();

                // The boundary is closer if the sigificand is of the form:
                //      f == 2^p-1
                //
                // Think of v = 1000e10 and v- = 9999e9
                // Then the boundary == (v - v-) / 2 is not just at a distance of 1e9 but at a distance of 1e8.
                // The only exception is for the smallest normal, where the largest denormal is at the same distance as its successor.
                //
                // Note: denormals have the same exponent as the smallest normals.

                // We deviate from the reference implementation by just checking if the significand has only the implicit bit set.
                // In this scenario, we know that all the explicit bits are 0 and that the unbiased exponent is non-zero.
                if (f == (1UL << implicitBitIndex))
                {
                    mMinus = new DiyFp((f << 2) - 1, e - 2);
                }
                else
                {
                    mMinus = new DiyFp((f << 1) - 1, e - 1);
                }

                mMinus = new DiyFp(mMinus.f << (mMinus.e - mPlus.e), mPlus.e);
            }
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.DiyFp.cs.meta
================================================
fileFormatVersion: 2
guid: 18a3c3c91bd4899498562233c482e696
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Dragon4.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace System
{
    // This is a port of the `Dragon4` implementation here: http://www.ryanjuckett.com/programming/printing-floating-point-numbers/part-2/
    // The backing algorithm and the proofs behind it are described in more detail here:  https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
    internal static partial class Number
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static unsafe bool IsNegative(double d)
        {
            return BitConverter.DoubleToInt64Bits(d) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe bool IsNegativeInfinity(float f)
        {
            return f == float.NegativeInfinity;
        }

        public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
        {
            double v = IsNegative(value) ? -value : value;

            Debug.Assert(v > 0);
            // Debug.Assert(double.IsFinite(v));

            ulong mantissa = ExtractFractionAndBiasedExponent(value, out int exponent);

            uint mantissaHighBitIdx;
            bool hasUnequalMargins = false;

            if ((mantissa >> DiyFp.DoubleImplicitBitIndex) != 0)
            {
                mantissaHighBitIdx = DiyFp.DoubleImplicitBitIndex;
                hasUnequalMargins = (mantissa == (1UL << DiyFp.DoubleImplicitBitIndex));
            }
            else
            {
                Debug.Assert(mantissa != 0);
                mantissaHighBitIdx = (uint)BitOperations.Log2(mantissa);
            }

            int length = (int)(Dragon4(mantissa, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out int decimalExponent));

            number.Scale = decimalExponent + 1;
            number.Digits[length] = (byte)('\0');
            number.DigitsCount = length;
        }

        public static unsafe void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, ref NumberBuffer number)
        {
            float v = IsNegative(value) ? -value : value;

            Debug.Assert(v > 0);
            // Debug.Assert(float.IsFinite(v));

            uint mantissa = ExtractFractionAndBiasedExponent(value, out int exponent);

            uint mantissaHighBitIdx;
            bool hasUnequalMargins = false;

            if ((mantissa >> DiyFp.SingleImplicitBitIndex) != 0)
            {
                mantissaHighBitIdx = DiyFp.SingleImplicitBitIndex;
                hasUnequalMargins = (mantissa == (1U << DiyFp.SingleImplicitBitIndex));
            }
            else
            {
                Debug.Assert(mantissa != 0);
                mantissaHighBitIdx = (uint)BitOperations.Log2(mantissa);
            }

            int length = (int)(Dragon4(mantissa, exponent, mantissaHighBitIdx, hasUnequalMargins, cutoffNumber, isSignificantDigits, number.Digits, out int decimalExponent));

            number.Scale = decimalExponent + 1;
            number.Digits[length] = (byte)('\0');
            number.DigitsCount = length;
        }

        // This is an implementation of the Dragon4 algorithm to convert a binary number in floating-point format to a decimal number in string format.
        // The function returns the number of digits written to the output buffer and the output is not NUL terminated.
        //
        // The floating point input value is (mantissa * 2^exponent).
        //
        // See the following papers for more information on the algorithm:
        //  "How to Print Floating-Point Numbers Accurately"
        //    Steele and White
        //    http://kurtstephens.com/files/p372-steele.pdf
        //  "Printing Floating-Point Numbers Quickly and Accurately"
        //    Burger and Dybvig
        //    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf
        private static unsafe uint Dragon4(ulong mantissa, int exponent, uint mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Span<byte> buffer, out int decimalExponent)
        {
            int curDigit = 0;

            Debug.Assert(buffer.Length > 0);

            // We deviate from the original algorithm and just assert that the mantissa
            // is not zero. Comparing to zero is fine since the caller should have set
            // the implicit bit of the mantissa, meaning it would only ever be zero if
            // the extracted exponent was also zero. And the assertion is fine since we
            // require that the DoubleToNumber handle zero itself.
            Debug.Assert(mantissa != 0);

            // Compute the initial state in integral form such that
            //      value     = scaledValue / scale
            //      marginLow = scaledMarginLow / scale

            BigInteger scale;           // positive scale applied to value and margin such that they can be represented as whole numbers
            BigInteger scaledValue;     // scale * mantissa
            BigInteger scaledMarginLow; // scale * 0.5 * (distance between this floating-point number and its immediate lower value)

            // For normalized IEEE floating-point values, each time the exponent is incremented the margin also doubles.
            // That creates a subset of transition numbers where the high margin is twice the size of the low margin.
            BigInteger* pScaledMarginHigh;
            BigInteger optionalMarginHigh;

            if (hasUnequalMargins)
            {
                if (exponent > 0)   // We have no fractional component
                {
                    // 1) Expand the input value by multiplying out the mantissa and exponent.
                    //    This represents the input value in its whole number representation.
                    // 2) Apply an additional scale of 2 such that later comparisons against the margin values are simplified.
                    // 3) Set the margin value to the loweset mantissa bit's scale.

                    // scaledValue      = 2 * 2 * mantissa * 2^exponent
                    BigInteger.SetUInt64(out scaledValue, 4 * mantissa);
                    scaledValue.ShiftLeft((uint)(exponent));

                    // scale            = 2 * 2 * 1
                    BigInteger.SetUInt32(out scale, 4);

                    // scaledMarginLow  = 2 * 2^(exponent - 1)
                    BigInteger.Pow2((uint)(exponent), out scaledMarginLow);

                    // scaledMarginHigh = 2 * 2 * 2^(exponent + 1)
                    BigInteger.Pow2((uint)(exponent + 1), out optionalMarginHigh);
                }
                else                // We have a fractional exponent
                {
                    // In order to track the mantissa data as an integer, we store it as is with a large scale

                    // scaledValue      = 2 * 2 * mantissa
                    BigInteger.SetUInt64(out scaledValue, 4 * mantissa);

                    // scale            = 2 * 2 * 2^(-exponent)
                    BigInteger.Pow2((uint)(-exponent + 2), out scale);

                    // scaledMarginLow  = 2 * 2^(-1)
                    BigInteger.SetUInt32(out scaledMarginLow, 1);

                    // scaledMarginHigh = 2 * 2 * 2^(-1)
                    BigInteger.SetUInt32(out optionalMarginHigh, 2);
                }

                // The high and low margins are different
                pScaledMarginHigh = &optionalMarginHigh;
            }
            else
            {
                if (exponent > 0)   // We have no fractional component
                {
                    // 1) Expand the input value by multiplying out the mantissa and exponent.
                    //    This represents the input value in its whole number representation.
                    // 2) Apply an additional scale of 2 such that later comparisons against the margin values are simplified.
                    // 3) Set the margin value to the lowest mantissa bit's scale.

                    // scaledValue     = 2 * mantissa*2^exponent
                    BigInteger.SetUInt64(out scaledValue, 2 * mantissa);
                    scaledValue.ShiftLeft((uint)(exponent));

                    // scale           = 2 * 1
                    BigInteger.SetUInt32(out scale, 2);

                    // scaledMarginLow = 2 * 2^(exponent-1)
                    BigInteger.Pow2((uint)(exponent), out scaledMarginLow);
                }
                else                // We have a fractional exponent
                {
                    // In order to track the mantissa data as an integer, we store it as is with a large scale

                    // scaledValue     = 2 * mantissa
                    BigInteger.SetUInt64(out scaledValue, 2 * mantissa);

                    // scale           = 2 * 2^(-exponent)
                    BigInteger.Pow2((uint)(-exponent + 1), out scale);

                    // scaledMarginLow = 2 * 2^(-1)
                    BigInteger.SetUInt32(out scaledMarginLow, 1);
                }

                // The high and low margins are equal
                pScaledMarginHigh = &scaledMarginLow;
            }

            // Compute an estimate for digitExponent that will be correct or undershoot by one.
            //
            // This optimization is based on the paper "Printing Floating-Point Numbers Quickly and Accurately" by Burger and Dybvig http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656&rep=rep1&type=pdf
            //
            // We perform an additional subtraction of 0.69 to increase the frequency of a failed estimate because that lets us take a faster branch in the code.
            // 0.69 is chosen because 0.69 + log10(2) is less than one by a reasonable epsilon that will account for any floating point error.
            //
            // We want to set digitExponent to floor(log10(v)) + 1
            //      v = mantissa * 2^exponent
            //      log2(v) = log2(mantissa) + exponent;
            //      log10(v) = log2(v) * log10(2)
            //      floor(log2(v)) = mantissaHighBitIdx + exponent;
            //      log10(v) - log10(2) < (mantissaHighBitIdx + exponent) * log10(2) <= log10(v)
            //      log10(v) < (mantissaHighBitIdx + exponent) * log10(2) + log10(2) <= log10(v) + log10(2)
            //      floor(log10(v)) < ceil((mantissaHighBitIdx + exponent) * log10(2)) <= floor(log10(v)) + 1
            const double Log10V2 = 0.30102999566398119521373889472449;
            int digitExponent = (int)(Math.Ceiling(((int)(mantissaHighBitIdx) + exponent) * Log10V2 - 0.69));

            // Divide value by 10^digitExponent.
            if (digitExponent > 0)
            {
                // The exponent is positive creating a division so we multiply up the scale.
                scale.MultiplyPow10((uint)(digitExponent));
            }
            else if (digitExponent < 0)
            {
                // The exponent is negative creating a multiplication so we multiply up the scaledValue, scaledMarginLow and scaledMarginHigh.

                BigInteger.Pow10((uint)(-digitExponent), out BigInteger pow10);

                scaledValue.Multiply(ref pow10);
                scaledMarginLow.Multiply(ref pow10);

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            bool isEven = (mantissa % 2) == 0;
            bool estimateTooLow = false;

            if (cutoffNumber == -1)
            {
                // When printing the shortest possible string, we want to
                // take IEEE unbiased rounding into account so we can return
                // shorter strings for various edge case values like 1.23E+22

                BigInteger.Add(ref scaledValue, ref *pScaledMarginHigh, out BigInteger scaledValueHigh);
                int cmpHigh = BigInteger.Compare(ref scaledValueHigh, ref scale);
                estimateTooLow = isEven ? (cmpHigh >= 0) : (cmpHigh > 0);
            }
            else
            {
                estimateTooLow = BigInteger.Compare(ref scaledValue, ref scale) >= 0;
            }

            // Was our estimate for digitExponent was too low?
            if (estimateTooLow)
            {
                // The exponent estimate was incorrect.
                // Increment the exponent and don't perform the premultiply needed for the first loop iteration.
                digitExponent++;
            }
            else
            {
                // The exponent estimate was correct.
                // Multiply larger by the output base to prepare for the first loop iteration.
                scaledValue.Multiply10();
                scaledMarginLow.Multiply10();

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            // Compute the cutoff exponent (the exponent of the final digit to print).
            // Default to the maximum size of the output buffer.
            int cutoffExponent = digitExponent - buffer.Length;

            if (cutoffNumber != -1)
            {
                int desiredCutoffExponent = 0;

                if (isSignificantDigits)
                {
                    // We asked for a specific number of significant digits.
                    Debug.Assert(cutoffNumber > 0);
                    desiredCutoffExponent = digitExponent - cutoffNumber;
                }
                else
                {
                    // We asked for a specific number of fractional digits.
                    Debug.Assert(cutoffNumber >= 0);
                    desiredCutoffExponent = -cutoffNumber;
                }

                if (desiredCutoffExponent > cutoffExponent)
                {
                    // Only select the new cutoffExponent if it won't overflow the destination buffer.
                    cutoffExponent = desiredCutoffExponent;
                }
            }

            // Output the exponent of the first digit we will print
            decimalExponent = --digitExponent;

            // In preparation for calling BigInteger.HeuristicDivie(), we need to scale up our values such that the highest block of the denominator is greater than or equal to 8.
            // We also need to guarantee that the numerator can never have a length greater than the denominator after each loop iteration.
            // This requires the highest block of the denominator to be less than or equal to 429496729 which is the highest number that can be multiplied by 10 without overflowing to a new block.

            Debug.Assert(scale.GetLength() > 0);
            uint hiBlock = scale.GetBlock((uint)(scale.GetLength() - 1));

            if ((hiBlock < 8) || (hiBlock > 429496729))
            {
                // Perform a bit shift on all values to get the highest block of the denominator into the range [8,429496729].
                // We are more likely to make accurate quotient estimations in BigInteger.HeuristicDivide() with higher denominator values so we shift the denominator to place the highest bit at index 27 of the highest block.
                // This is safe because (2^28 - 1) = 268435455 which is less than 429496729.
                // This means that all values with a highest bit at index 27 are within range.
                Debug.Assert(hiBlock != 0);
                uint hiBlockLog2 = (uint)BitOperations.Log2(hiBlock);
                Debug.Assert((hiBlockLog2 < 3) || (hiBlockLog2 > 27));
                uint shift = (32 + 27 - hiBlockLog2) % 32;

                scale.ShiftLeft(shift);
                scaledValue.ShiftLeft(shift);
                scaledMarginLow.ShiftLeft(shift);

                if (pScaledMarginHigh != &scaledMarginLow)
                {
                    BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                }
            }

            // These values are used to inspect why the print loop terminated so we can properly round the final digit.
            bool low;            // did the value get within marginLow distance from zero
            bool high;           // did the value get within marginHigh distance from one
            uint outputDigit;    // current digit being output

            if (cutoffNumber == -1)
            {
                Debug.Assert(isSignificantDigits);
                Debug.Assert(digitExponent >= cutoffExponent);

                // For the unique cutoff mode, we will try to print until we have reached a level of precision that uniquely distinguishes this value from its neighbors.
                // If we run out of space in the output buffer, we terminate early.

                while (true)
                {
                    // divide out the scale to extract the digit
                    outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                    Debug.Assert(outputDigit < 10);

                    // update the high end of the value
                    BigInteger.Add(ref scaledValue, ref *pScaledMarginHigh, out BigInteger scaledValueHigh);

                    // stop looping if we are far enough away from our neighboring values or if we have reached the cutoff digit
                    int cmpLow = BigInteger.Compare(ref scaledValue, ref scaledMarginLow);
                    int cmpHigh = BigInteger.Compare(ref scaledValueHigh, ref scale);

                    if (isEven)
                    {
                        low = (cmpLow <= 0);
                        high = (cmpHigh >= 0);
                    }
                    else
                    {
                        low = (cmpLow < 0);
                        high = (cmpHigh > 0);
                    }

                    if (low || high || (digitExponent == cutoffExponent))
                    {
                        break;
                    }

                    // store the output digit
                    buffer[curDigit] = (byte)('0' + outputDigit);
                    curDigit++;

                    // multiply larger by the output base
                    scaledValue.Multiply10();
                    scaledMarginLow.Multiply10();

                    if (pScaledMarginHigh != &scaledMarginLow)
                    {
                        BigInteger.Multiply(ref scaledMarginLow, 2, out *pScaledMarginHigh);
                    }

                    digitExponent--;
                }
            }
            else if (digitExponent >= cutoffExponent)
            {
                Debug.Assert((cutoffNumber > 0) || ((cutoffNumber == 0) && !isSignificantDigits));

                // For length based cutoff modes, we will try to print until we have exhausted all precision (i.e. all remaining digits are zeros) or until we reach the desired cutoff digit.
                low = false;
                high = false;

                while (true)
                {
                    // divide out the scale to extract the digit
                    outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                    Debug.Assert(outputDigit < 10);

                    if (scaledValue.IsZero() || (digitExponent <= cutoffExponent))
                    {
                        break;
                    }

                    // store the output digit
                    buffer[curDigit] = (byte)('0' + outputDigit);
                    curDigit++;

                    // multiply larger by the output base
                    scaledValue.Multiply10();
                    digitExponent--;
                }
            }
            else
            {
                // In the scenario where the first significant digit is after the cutoff, we want to treat that
                // first significant digit as the rounding digit. If the first significant would cause the next
                // digit to round, we will increase the decimalExponent by one and set the previous digit to one.
                // This  ensures we correctly handle the case where the first significant digit is exactly one after
                // the cutoff, it is a 4, and the subsequent digit would round that to 5 inducing a double rounding
                // bug when NumberToString does its own rounding checks. However, if the first significant digit
                // would not cause the next one to round, we preserve that digit as is.

                // divide out the scale to extract the digit
                outputDigit = BigInteger.HeuristicDivide(ref scaledValue, ref scale);
                Debug.Assert((0 < outputDigit) && (outputDigit < 10));

                if ((outputDigit > 5) || ((outputDigit == 5) && !scaledValue.IsZero()))
                {
                    decimalExponent++;
                    outputDigit = 1;
                }

                buffer[curDigit] = (byte)('0' + outputDigit);
                curDigit++;

                // return the number of digits output
                return (uint)curDigit;
            }

            // round off the final digit
            // default to rounding down if value got too close to 0
            bool roundDown = low;

            if (low == high)    // is it legal to round up and down
            {
                // round to the closest digit by comparing value with 0.5.
                //
                // To do this we need to convert the inequality to large integer values.
                //      compare(value, 0.5)
                //      compare(scale * value, scale * 0.5)
                //      compare(2 * scale * value, scale)
                scaledValue.ShiftLeft(1); // Multiply by 2
                int compare = BigInteger.Compare(ref scaledValue, ref scale);
                roundDown = compare < 0;

                // if we are directly in the middle, round towards the even digit (i.e. IEEE rouding rules)
                if (compare == 0)
                {
                    roundDown = (outputDigit & 1) == 0;
                }
            }

            // print the rounded digit
            if (roundDown)
            {
                buffer[curDigit] = (byte)('0' + outputDigit);
                curDigit++;
            }
            else if (outputDigit == 9)      // handle rounding up
            {
                // find the first non-nine prior digit
                while (true)
                {
                    // if we are at the first digit
                    if (curDigit == 0)
                    {
                        // output 1 at the next highest exponent

                        buffer[curDigit] = (byte)('1');
                        curDigit++;
                        decimalExponent++;

                        break;
                    }

                    curDigit--;

                    if (buffer[curDigit] != '9')
                    {
                        // increment the digit

                        buffer[curDigit]++;
                        curDigit++;

                        break;
                    }
                }
            }
            else
            {
                // values in the range [0,8] can perform a simple round up
                buffer[curDigit] = (byte)('0' + outputDigit + 1);
                curDigit++;
            }

            // return the number of digits output
            uint outputLen = (uint)curDigit;
            Debug.Assert(outputLen <= buffer.Length);
            return outputLen;
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Dragon4.cs.meta
================================================
fileFormatVersion: 2
guid: c85d12eb4f5572c45baa13de29cee602
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Formatting.cs.meta
================================================
fileFormatVersion: 2
guid: 5424f58089802e74383c0f5c73ef3e33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Grisu3.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace System
{
    internal static partial class Number
    {
        // This is a port of the `Grisu3` implementation here: https://github.com/google/double-conversion/blob/a711666ddd063eb1e4b181a6cb981d39a1fc8bac/double-conversion/fast-dtoa.cc
        // The backing algorithm and the proofs behind it are described in more detail here: http://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf
        // ========================================================================================================================================
        //
        // Overview:
        //
        // The general idea behind Grisu3 is to leverage additional bits and cached powers of ten to generate the correct digits.
        // The algorithm is imprecise for some numbers. Fortunately, the algorithm itself can determine this scenario and gives us
        // a result indicating success or failure. We must fallback to a different algorithm for the failing scenario.
        internal static class Grisu3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static unsafe bool IsNegative(double d)
            {
                return BitConverter.DoubleToInt64Bits(d) < 0;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static unsafe bool IsNegativeInfinity(float f)
            {
                return f == float.NegativeInfinity;
            }

            private const int CachedPowersDecimalExponentDistance = 8;
            private const int CachedPowersMinDecimalExponent = -348;
            private const int CachedPowersPowerMaxDecimalExponent = 340;
            private const int CachedPowersOffset = -CachedPowersMinDecimalExponent;

            // 1 / Log2(10)
            private const double D1Log210 = 0.301029995663981195;

            // The minimal and maximal target exponents define the range of w's binary exponent,
            // where w is the result of multiplying the input by a cached power of ten.
            //
            // A different range might be chosen on a different platform, to optimize digit generation,
            // but a smaller range requires more powers of ten to be cached.
            private const int MaximalTargetExponent = -32;
            private const int MinimalTargetExponent = -60;

            private static readonly short[] s_CachedPowersBinaryExponent = new short[]
            {
                -1220,
                -1193,
                -1166,
                -1140,
                -1113,
                -1087,
                -1060,
                -1034,
                -1007,
                -980,
                -954,
                -927,
                -901,
                -874,
                -847,
                -821,
                -794,
                -768,
                -741,
                -715,
                -688,
                -661,
                -635,
                -608,
                -582,
                -555,
                -529,
                -502,
                -475,
                -449,
                -422,
                -396,
                -369,
                -343,
                -316,
                -289,
                -263,
                -236,
                -210,
                -183,
                -157,
                -130,
                -103,
                -77,
                -50,
                -24,
                3,
                30,
                56,
                83,
                109,
                136,
                162,
                189,
                216,
                242,
                269,
                295,
                322,
                348,
                375,
                402,
                428,
                455,
                481,
                508,
                534,
                561,
                588,
                614,
                641,
                667,
                694,
                720,
                747,
                774,
                800,
                827,
                853,
                880,
                907,
                933,
                960,
                986,
                1013,
                1039,
                1066,
            };

            private static readonly short[] s_CachedPowersDecimalExponent = new short[]
            {
                CachedPowersMinDecimalExponent,
                -340,
                -332,
                -324,
                -316,
                -308,
                -300,
                -292,
                -284,
                -276,
                -268,
                -260,
                -252,
                -244,
                -236,
                -228,
                -220,
                -212,
                -204,
                -196,
                -188,
                -180,
                -172,
                -164,
                -156,
                -148,
                -140,
                -132,
                -124,
                -116,
                -108,
                -100,
                -92,
                -84,
                -76,
                -68,
                -60,
                -52,
                -44,
                -36,
                -28,
                -20,
                -12,
                -4,
                4,
                12,
                20,
                28,
                36,
                44,
                52,
                60,
                68,
                76,
                84,
                92,
                100,
                108,
                116,
                124,
                132,
                140,
                148,
                156,
                164,
                172,
                180,
                188,
                196,
                204,
                212,
                220,
                228,
                236,
                244,
                252,
                260,
                268,
                276,
                284,
                292,
                300,
                308,
                316,
                324,
                332,
                CachedPowersPowerMaxDecimalExponent,
            };

            private static readonly ulong[] s_CachedPowersSignificand = new ulong[]
            {
                0xFA8FD5A0081C0288,
                0xBAAEE17FA23EBF76,
                0x8B16FB203055AC76,
                0xCF42894A5DCE35EA,
                0x9A6BB0AA55653B2D,
                0xE61ACF033D1A45DF,
                0xAB70FE17C79AC6CA,
                0xFF77B1FCBEBCDC4F,
                0xBE5691EF416BD60C,
                0x8DD01FAD907FFC3C,
                0xD3515C2831559A83,
                0x9D71AC8FADA6C9B5,
                0xEA9C227723EE8BCB,
                0xAECC49914078536D,
                0x823C12795DB6CE57,
                0xC21094364DFB5637,
                0x9096EA6F3848984F,
                0xD77485CB25823AC7,
                0xA086CFCD97BF97F4,
                0xEF340A98172AACE5,
                0xB23867FB2A35B28E,
                0x84C8D4DFD2C63F3B,
                0xC5DD44271AD3CDBA,
                0x936B9FCEBB25C996,
                0xDBAC6C247D62A584,
                0xA3AB66580D5FDAF6,
                0xF3E2F893DEC3F126,
                0xB5B5ADA8AAFF80B8,
                0x87625F056C7C4A8B,
                0xC9BCFF6034C13053,
                0x964E858C91BA2655,
                0xDFF9772470297EBD,
                0xA6DFBD9FB8E5B88F,
                0xF8A95FCF88747D94,
                0xB94470938FA89BCF,
                0x8A08F0F8BF0F156B,
                0xCDB02555653131B6,
                0x993FE2C6D07B7FAC,
                0xE45C10C42A2B3B06,
                0xAA242499697392D3,
                0xFD87B5F28300CA0E,
                0xBCE5086492111AEB,
                0x8CBCCC096F5088CC,
                0xD1B71758E219652C,
                0x9C40000000000000,
                0xE8D4A51000000000,
                0xAD78EBC5AC620000,
                0x813F3978F8940984,
                0xC097CE7BC90715B3,
                0x8F7E32CE7BEA5C70,
                0xD5D238A4ABE98068,
                0x9F4F2726179A2245,
                0xED63A231D4C4FB27,
                0xB0DE65388CC8ADA8,
                0x83C7088E1AAB65DB,
                0xC45D1DF942711D9A,
                0x924D692CA61BE758,
                0xDA01EE641A708DEA,
                0xA26DA3999AEF774A,
                0xF209787BB47D6B85,
                0xB454E4A179DD1877,
                0x865B86925B9BC5C2,
                0xC83553C5C8965D3D,
                0x952AB45CFA97A0B3,
                0xDE469FBD99A05FE3,
                0xA59BC234DB398C25,
                0xF6C69A72A3989F5C,
                0xB7DCBF5354E9BECE,
                0x88FCF317F22241E2,
                0xCC20CE9BD35C78A5,
                0x98165AF37B2153DF,
                0xE2A0B5DC971F303A,
                0xA8D9D1535CE3B396,
                0xFB9B7CD9A4A7443C,
                0xBB764C4CA7A44410,
                0x8BAB8EEFB6409C1A,
                0xD01FEF10A657842C,
                0x9B10A4E5E9913129,
                0xE7109BFBA19C0C9D,
                0xAC2820D9623BF429,
                0x80444B5E7AA7CF85,
                0xBF21E44003ACDD2D,
                0x8E679C2F5E44FF8F,
                0xD433179D9C8CB841,
                0x9E19DB92B4E31BA9,
                0xEB96BF6EBADF77D9,
                0xAF87023B9BF0EE6B,
            };

            private static readonly uint[] s_SmallPowersOfTen = new uint[]
            {
                1,          // 10^0
                10,         // 10^1
                100,        // 10^2
                1000,       // 10^3
                10000,      // 10^4
                100000,     // 10^5
                1000000,    // 10^6
                10000000,   // 10^7
                100000000,  // 10^8
                1000000000, // 10^9
            };

            public static bool TryRunDouble(double value, int requestedDigits, ref NumberBuffer number)
            {
                double v = IsNegative(value) ? -value : value;

                Debug.Assert(v > 0);
                //Debug.Assert(double.IsFinite(v));

                int length;
                int decimalExponent;
                bool result;

                if (requestedDigits == -1)
                {
                    DiyFp w = DiyFp.CreateAndGetBoundaries(v, out DiyFp boundaryMinus, out DiyFp boundaryPlus).Normalize();
                    result = TryRunShortest(in boundaryMinus, in w, in boundaryPlus, number.Digits, out length, out decimalExponent);
                }
                else
                {
                    DiyFp w = new DiyFp(v).Normalize();
                    result = TryRunCounted(in w, requestedDigits, number.Digits, out length, out decimalExponent);
                }

                if (result)
                {
                    Debug.Assert((requestedDigits == -1) || (length == requestedDigits));

                    number.Scale = length + decimalExponent;
                    number.Digits[length] = (byte)('\0');
                    number.DigitsCount = length;
                }

                return result;
            }

            public static bool TryRunSingle(float value, int requestedDigits, ref NumberBuffer number)
            {
                float v = IsNegative(value) ? -value : value;

                Debug.Assert(v > 0);
                //Debug.Assert(float.IsFinite(v));

                int length;
                int decimalExponent;
                bool result;

                if (requestedDigits == -1)
                {
                    DiyFp w = DiyFp.CreateAndGetBoundaries(v, out DiyFp boundaryMinus, out DiyFp boundaryPlus).Normalize();
                    result = TryRunShortest(in boundaryMinus, in w, in boundaryPlus, number.Digits, out length, out decimalExponent);
                }
                else
                {
                    DiyFp w = new DiyFp(v).Normalize();
                    result = TryRunCounted(in w, requestedDigits, number.Digits, out length, out decimalExponent);
                }

                if (result)
                {
                    Debug.Assert((requestedDigits == -1) || (length == requestedDigits));

                    number.Scale = length + decimalExponent;
                    number.Digits[length] = (byte)('\0');
                    number.DigitsCount = length;
                }

                return result;
            }

            // The counted version of Grisu3 only generates requestedDigits number of digits.
            // This version does not generate the shortest representation, and with enough requested digits 0.1 will at some point print as 0.9999999...
            // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and therefore the rounding strategy for halfway cases is irrelevant.
            private static bool TryRunCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int decimalExponent)
            {
                Debug.Assert(requestedDigits > 0);

                int tenMkMinimalBinaryExponent = MinimalTargetExponent - (w.e + DiyFp.SignificandSize);
                int tenMkMaximalBinaryExponent = MaximalTargetExponent - (w.e + DiyFp.SignificandSize);

                DiyFp tenMk = GetCachedPowerForBinaryExponentRange(tenMkMinimalBinaryExponent, tenMkMaximalBinaryExponent, out int mk);

                Debug.Assert(MinimalTargetExponent <= (w.e + tenMk.e + DiyFp.SignificandSize));
                Debug.Assert(MaximalTargetExponent >= (w.e + tenMk.e + DiyFp.SignificandSize));

                // Note that tenMk is only an approximation of 10^-k.
                // A DiyFp only contains a 64-bit significand and tenMk is thus only precise up to 64-bits.

                // The DiyFp.Multiply procedure rounds its result and tenMk is approximated too.
                // The variable scaledW (as well as scaledBoundaryMinus/Plus) are now off by a small amount.
                //
                // In fact, scaledW - (w * 10^k) < 1ulp (unit in last place) of scaledW.
                // In other words, let f = scaledW.f and e = scaledW.e, then:
                //      (f - 1) * 2^e < (w * 10^k) < (f + 1) * 2^e

                DiyFp scaledW = w.Multiply(in tenMk);

                // We now have (double)(scaledW * 10^-mk).
                //
                // DigitGenCounted will generate the first requestedDigits of scaledW and return together with a kappa such that:
                //      scaledW ~= buffer * 10^kappa.
                //
                // It will not always be exactly the same since DigitGenCounted only produces a limited number of digits.

                bool result = TryDigitGenCounted(in scaledW, requestedDigits, buffer, out length, out int kappa);
                decimalExponent = -mk + kappa;
                return result;
            }

            // Provides a decimal representation of v.
            // Returns true if it succeeds; otherwise, the result cannot be trusted.
            //
            // There will be length digits inside the buffer (not null-terminated).
            // If the function returns true then:
            //      v == (double)(buffer * 10^decimalExponent)
            //
            // The digits in the buffer are the shortest represenation possible (no 0.09999999999999999 instead of 0.1).
            // The shorter representation will even be chosen if the longer one would be closer to v.
            //
            // The last digit will be closest to the actual v.
            // That is, even if several digits might correctly yield 'v' when read again, the closest will be computed.
            private static bool TryRunShortest(in DiyFp boundaryMinus, in DiyFp w, in DiyFp boundaryPlus, Span<byte> buffer, out int length, out int decimalExponent)
            {
                // boundaryMinus and boundaryPlus are the boundaries between v and its closest floating-point neighbors.
                // Any number strictly between boundaryMinus and boundaryPlus will round to v when converted to a double.
                // Grisu3 will never output representations that lie exactly on a boundary.

                Debug.Assert(boundaryPlus.e == w.e);

                int tenMkMinimalBinaryExponent = MinimalTargetExponent - (w.e + DiyFp.SignificandSize);
                int tenMkMaximalBinaryExponent = MaximalTargetExponent - (w.e + DiyFp.SignificandSize);

                DiyFp tenMk = GetCachedPowerForBinaryExponentRange(tenMkMinimalBinaryExponent, tenMkMaximalBinaryExponent, out int mk);

                Debug.Assert(MinimalTargetExponent <= (w.e + tenMk.e + DiyFp.SignificandSize));
                Debug.Assert(MaximalTargetExponent >= (w.e + tenMk.e + DiyFp.SignificandSize));

                // Note that tenMk is only an approximation of 10^-k.
                // A DiyFp only contains a 64-bit significan and tenMk is thus only precise up to 64-bits.

                // The DiyFp.Multiply procedure rounds its result and tenMk is approximated too.
                // The variable scaledW (as well as scaledBoundaryMinus/Plus) are now off by a small amount.
                //
                // In fact, scaledW - (w * 10^k) < 1ulp (unit in last place) of scaledW.
                // In other words, let f = scaledW.f and e = scaledW.e, then:
                //      (f - 1) * 2^e < (w * 10^k) < (f + 1) * 2^e

                DiyFp scaledW = w.Multiply(in tenMk);
                Debug.Assert(scaledW.e == (boundaryPlus.e + tenMk.e + DiyFp.SignificandSize));

                // In theory, it would be possible to avoid some recomputations by computing the difference between w
                // and boundaryMinus/Plus (a power of 2) and to compute scaledBoundaryMinus/Plus by subtracting/adding
                // from scaledW. However, the code becomes much less readable and the speed enhancements are not terrific.

                DiyFp scaledBoundaryMinus = boundaryMinus.Multiply(in tenMk);
                DiyFp scaledBoundaryPlus = boundaryPlus.Multiply(in tenMk);

                // DigitGen will generate the digits of scaledW. Therefore, we have:
                //      v == (double)(scaledW * 10^-mk)
                //
                // Set decimalExponent == -mk and pass it to DigitGen and if scaledW is not an integer than it will be updated.
                // For instance, if scaledW == 1.23 then the buffer will be filled with "123" and the decimalExponent will be decreased by 2.

                bool result = TryDigitGenShortest(in scaledBoundaryMinus, in scaledW, in scaledBoundaryPlus, buffer, out length, out int kappa);
                decimalExponent = -mk + kappa;
                return result;
            }

            // Returns the biggest power of ten that is less than or equal to the given number.
            // We furthermore receive the maximum number of bits 'number' has.
            //
            // Returns power == 10^(exponent) such that
            //      power <= number < power * 10
            // If numberBits == 0, then 0^(0-1) is returned.
            // The number of bits must be <= 32.
            //
            // Preconditions:
            //      number < (1 << (numberBits + 1))
            private static uint BiggestPowerTen(uint number, int numberBits, out int exponentPlusOne)
            {
                // Inspired by the method for finding an integer log base 10 from here:
                // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10

                Debug.Assert(number < (1U << (numberBits + 1)));

                // 1233/4096 is approximately 1/log2(10)
                int exponentGuess = ((numberBits + 1) * 1233) >> 12;
                Debug.Assert((uint)(exponentGuess) < s_SmallPowersOfTen.Length);

                uint power = s_SmallPowersOfTen[exponentGuess];

                // We don't have any guarantees that 2^numberBits <= number
                if (number < power)
                {
                    exponentGuess--;
                    power = s_SmallPowersOfTen[exponentGuess];
                }

                exponentPlusOne = exponentGuess + 1;
                return power;
            }

            // Generates (at most) requestedDigits of input number w.
            //
            // w is a floating-point number (DiyFp), consisting of a significand and an exponent.
            // Its exponent is bounded by MinimalTargetExponent and MaximalTargetExponent, hence:
            //      -60 <= w.e <= -32
            //
            // Returns false if it fails, in which case the generated digits in the buffer should not be used.
            //
            // Preconditions:
            //      w is correct up to 1 ulp (unit in last place). That is, its error must be strictly less than a unit of its last digit.
            //      MinimalTargetExponent <= w.e <= MaximalTargetExponent
            //
            // Postconditions:
            //      Returns false if the procedure fails; otherwise:
            //      * buffer is not null-terminated, but length contains the number of digits.
            //      * The representation in buffer is the most precise representation of requestedDigits digits.
            //      * buffer contains at most requestedDigits digits of w. If there are less than requestedDigits digits then some trailing '0's have been removed.
            //      * kappa is such that w = buffer * 10^kappa + eps with |eps| < 10^kappa / 2.
            //
            // This procedure takes into account the imprecision of its input numbers.
            // If the precision is not enough to guarantee all the postconditions, then false is returned.
            // This usually happens rarely, but the failure-rate increases with higher requestedDigits
            private static bool TryDigitGenCounted(in DiyFp w, int requestedDigits, Span<byte> buffer, out int length, out int kappa)
            {
                Debug.Assert(MinimalTargetExponent <= w.e);
                Debug.Assert(w.e <= MaximalTargetExponent);
                Debug.Assert(MinimalTargetExponent >= -60);
                Debug.Assert(MaximalTargetExponent <= -32);

                // w is assumed to have an error less than 1 unit.
                // Whenever w is scaled we also scale its error.
                ulong wError = 1;

                // We cut the input number into two parts: the integral digits and the fractional digits.
                // We don't emit any decimal separator, but adapt kapp instead.
                // For example: instead of writing "1.2", we put "12" into the buffer and increase kappa by 1.
                var one = new DiyFp(1UL << -w.e, w.e);

                // Division by one is a shift.
                uint integrals = (uint)(w.f >> -one.e);

                // Modulo by one is an and.
                ulong fractionals = w.f & (one.f - 1);

                // We deviate from the original algorithm here and do some early checks to determine if we can satisfy requestedDigits.
                // If we determine that we can't, we exit early and avoid most of the heavy lifting that the algorithm otherwise does.
                //
                // When fractionals is zero, we can easily determine if integrals can satisfy requested digits:
                //      If requestedDigits >= 11, integrals is not able to exhaust the count by itself since 10^(11 -1) > uint.MaxValue >= integrals.
                //      If integrals < 10^(requestedDigits - 1), integrals cannot exhaust the count.
                //      Otherwise, integrals might be able to exhaust the count and we need to execute the rest of the code.
                if ((fractionals == 0) && ((requestedDigits >= 11) || (integrals < s_SmallPowersOfTen[requestedDigits - 1])))
                {
                    Debug.Assert(buffer[0] == '\0');
                    length = 0;
                    kappa = 0;
                    return false;
                }

                uint divisor = BiggestPowerTen(integrals, DiyFp.SignificandSize - (-one.e), out kappa);
                length = 0;

                // Loop invariant:
                //      buffer = w / 10^kappa (integer division)
                // These invariants hold for the first iteration:
                //      kappa has been initialized with the divisor exponent + 1
                //      The divisor is the biggest power of ten that is smaller than integrals
                while (kappa > 0)
                {
                    uint digit = MathEx.DivRem(integrals, divisor, out integrals);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    requestedDigits--;
                    kappa--;

                    // Note that kappa now equals the exponent of the
                    // divisor and that the invariant thus holds again.
                    if (requestedDigits == 0)
                    {
                        break;
                    }

                    divisor /= 10;
                }

                if (requestedDigits == 0)
                {
                    ulong rest = ((ulong)(integrals) << -one.e) + fractionals;
                    return TryRoundWeedCounted(
                        buffer,
                        length,
                        rest,
                        tenKappa: ((ulong)(divisor)) << -one.e,
                        unit: wError,
                        ref kappa
                    );
                }

                // The integrals have been generated and we are at the point of the decimal separator.
                // In the following loop, we simply multiply the remaining digits by 10 and divide by one.
                // We just need to pay attention to multiply associated data (the unit), too.
                // Note that the multiplication by 10 does not overflow because:
                //      w.e >= -60 and thus one.e >= -60

                Debug.Assert(one.e >= MinimalTargetExponent);
                Debug.Assert(fractionals < one.f);
                Debug.Assert((ulong.MaxValue / 10) >= one.f);

                while ((requestedDigits > 0) && (fractionals > wError))
                {
                    fractionals *= 10;
                    wError *= 10;

                    // Integer division by one.
                    uint digit = (uint)(fractionals >> -one.e);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    requestedDigits--;
                    kappa--;

                    // Modulo by one.
                    fractionals &= (one.f - 1);
                }

                if (requestedDigits != 0)
                {
                    buffer[0] = (byte)('\0');
                    length = 0;
                    kappa = 0;
                    return false;
                }

                return TryRoundWeedCounted(
                    buffer,
                    length,
                    rest: fractionals,
                    tenKappa: one.f,
                    unit: wError,
                    ref kappa
                );
            }

            // Generates the digits of input number w.
            //
            // w is a floating-point number (DiyFp), consisting of a significand and an exponent.
            // Its exponent is bounded by kMinimalTargetExponent and kMaximalTargetExponent, hence:
            //      -60 <= w.e() <= -32.
            //
            // Returns false if it fails, in which case the generated digits in the buffer should not be used.
            //
            // Preconditions:
            //      low, w and high are correct up to 1 ulp (unit in the last place). That is, their error must be less than a unit of their last digits.
            //      low.e() == w.e() == high.e()
            //      low < w < high, and taking into account their error: low~ <= high~
            //      kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent
            //
            // Postconditions:
            //      Returns false if procedure fails; otherwise:
            //      * buffer is not null-terminated, but len contains the number of digits.
            //      * buffer contains the shortest possible decimal digit-sequence such that LOW < buffer * 10^kappa < HIGH, where LOW and HIGH are the correct values of low and high (without their error).
            //      * If more than one decimal representation gives the minimal number of decimal digits then the one closest to W (where W is the correct value of w) is chosen.
            //
            // This procedure takes into account the imprecision of its input numbers.
            // If the precision is not enough to guarantee all the postconditions then false is returned.
            // This usually happens rarely (~0.5%).
            //
            // Say, for the sake of example, that:
            //      w.e() == -48, and w.f() == 0x1234567890abcdef
            //
            // w's value can be computed by w.f() * 2^w.e()
            //
            // We can obtain w's integral digits by simply shifting w.f() by -w.e().
            //      -> w's integral part is 0x1234
            //      w's fractional part is therefore 0x567890abcdef.
            //
            // Printing w's integral part is easy (simply print 0x1234 in decimal).
            //
            // In order to print its fraction we repeatedly multiply the fraction by 10 and get each digit.
            // For example, the first digit after the point would be computed by
            //      (0x567890abcdef * 10) >> 48. -> 3
            //
            // The whole thing becomes slightly more complicated because we want to stop once we have enough digits.
            // That is, once the digits inside the buffer represent 'w' we can stop.
            //
            // Everything inside the interval low - high represents w.
            // However we have to pay attention to low, high and w's imprecision.
            private static bool TryDigitGenShortest(in DiyFp low, in DiyFp w, in DiyFp high, Span<byte> buffer, out int length, out int kappa)
            {
                Debug.Assert(low.e == w.e);
                Debug.Assert(w.e == high.e);

                Debug.Assert((low.f + 1) <= (high.f - 1));

                Debug.Assert(MinimalTargetExponent <= w.e);
                Debug.Assert(w.e <= MaximalTargetExponent);

                // low, w, and high are imprecise, but by less than one ulp (unit in the last place).
                //
                // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that the new numbers
                // are outside of the interval we want the final representation to lie in.
                //
                // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield numbers that
                // are certain to lie in the interval. We will use this fact later on.
                //
                // We will now start by generating the digits within the uncertain interval.
                // Later, we will weed out representations that lie outside the safe interval and thus might lie outside the correct interval.

                ulong unit = 1;

                var tooLow = new DiyFp(low.f - unit, low.e);
                var tooHigh = new DiyFp(high.f + unit, high.e);

                // tooLow and tooHigh are guaranteed to lie outside the interval we want the generated number in.

                DiyFp unsafeInterval = tooHigh.Subtract(in tooLow);

                // We now cut the input number into two parts: the integral digits and the fractional digits.
                // We will not write any decimal separator, but adapt kappa instead.
                //
                // Reminder: we are currently computing the digits (Stored inside the buffer) such that:
                //      tooLow < buffer * 10^kappa < tooHigh
                //
                // We use tooHigh for the digitGeneration and stop as soon as possible.
                // If we stop early, we effectively round down.

                var one = new DiyFp(1UL << -w.e, w.e);

                // Division by one is a shift.
                uint integrals = (uint)(tooHigh.f >> -one.e);

                // Modulo by one is an and.
                ulong fractionals = tooHigh.f & (one.f - 1);

                uint divisor = BiggestPowerTen(integrals, DiyFp.SignificandSize - (-one.e), out kappa);
                length = 0;

                // Loop invariant:
                //      buffer = tooHigh / 10^kappa (integer division)
                // These invariants hold for the first iteration:
                //      kappa has been initialized with the divisor exponent + 1
                //      The divisor is the biggest power of ten that is smaller than integrals
                while (kappa > 0)
                {
                    uint digit = MathEx.DivRem(integrals, divisor, out integrals);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    kappa--;

                    // Note that kappa now equals the exponent of the
                    // divisor and that the invariant thus holds again.

                    ulong rest = ((ulong)(integrals) << -one.e) + fractionals;

                    // Invariant: tooHigh = buffer * 10^kappa + DiyFp(rest, one.e)
                    // Reminder: unsafeInterval.e == one.e

                    if (rest < unsafeInterval.f)
                    {
                        // Rounding down (by not emitting the remaining digits)
                        // yields a number that lies within the unsafe interval

                        return TryRoundWeedShortest(
                            buffer,
                            length,
                            tooHigh.Subtract(w).f,
                            unsafeInterval.f,
                            rest,
                            tenKappa: ((ulong)(divisor)) << -one.e,
                            unit
                        );
                    }

                    divisor /= 10;
                }

                // The integrals have been generated and we are at the point of the decimal separator.
                // In the following loop, we simply multiply the remaining digits by 10 and divide by one.
                // We just need to pay attention to multiply associated data (the unit), too.
                // Note that the multiplication by 10 does not overflow because:
                //      w.e >= -60 and thus one.e >= -60

                Debug.Assert(one.e >= MinimalTargetExponent);
                Debug.Assert(fractionals < one.f);
                Debug.Assert((ulong.MaxValue / 10) >= one.f);

                while (true)
                {
                    fractionals *= 10;
                    unit *= 10;

                    unsafeInterval = new DiyFp(unsafeInterval.f * 10, unsafeInterval.e);

                    // Integer division by one.
                    uint digit = (uint)(fractionals >> -one.e);
                    Debug.Assert(digit <= 9);
                    buffer[length] = (byte)('0' + digit);

                    length++;
                    kappa--;

                    // Modulo by one.
                    fractionals &= (one.f - 1);

                    if (fractionals < unsafeInterval.f)
                    {
                        return TryRoundWeedShortest(
                            buffer,
                            length,
                            tooHigh.Subtract(w).f * unit,
                            unsafeInterval.f,
                            rest: fractionals,
                            tenKappa: one.f,
                            unit
                        );
                    }
                }
            }

            // Returns a cached power-of-ten with a binary exponent in the range [minExponent; maxExponent] (boundaries included).
            private static DiyFp GetCachedPowerForBinaryExponentRange(int minExponent, int maxExponent, out int decimalExponent)
            {
                Debug.Assert(s_CachedPowersSignificand.Length == s_CachedPowersBinaryExponent.Length);
                Debug.Assert(s_CachedPowersSignificand.Length == s_CachedPowersDecimalExponent.Length);

                double k = Math.Ceiling((minExponent + DiyFp.SignificandSize - 1) * D1Log210);
                int index = ((CachedPowersOffset + (int)(k) - 1) / CachedPowersDecimalExponentDistance) + 1;

                Debug.Assert((uint)(index) < s_CachedPowersSignificand.Length);

                Debug.Assert(minExponent <= s_CachedPowersBinaryExponent[index]);
                Debug.Assert(s_CachedPowersBinaryExponent[index] <= maxExponent);

                decimalExponent = s_CachedPowersDecimalExponent[index];
                return new DiyFp(s_CachedPowersSignificand[index], s_CachedPowersBinaryExponent[index]);
            }

            // Rounds the buffer upwards if the result is closer to v by possibly adding 1 to the buffer.
            // If the precision of the calculation is not sufficient to round correctly, return false.
            //
            // The rounding might shift the whole buffer, in which case, the kappy is adjusted.
            // For example "99", kappa = 3 might become "10", kappa = 4.
            //
            // If (2 * rest) > tenKappa then the buffer needs to be round up.
            // rest can have an error of +/- 1 unit.
            // This function accounts for the imprecision and returns false if the rounding direction cannot be unambiguously determined.
            //
            // Preconditions:
            //      rest < tenKappa
            private static bool TryRoundWeedCounted(Span<byte> buffer, int length, ulong rest, ulong tenKappa, ulong unit, ref int kappa)
            {
                Debug.Assert(rest < tenKappa);

                // The following tests are done in a specific order to avoid overflows.
                // They will work correctly with any ulong values of rest < tenKappa and unit.
                //
                // If the unit is too big, then we don't know which way to round.
                // For example, a unit of 50 means that the real number lies within rest +/- 50.
                // If 10^kappa == 40, then there is no way to tell which way to round.
                //
                // Even if unit is just half the size of 10^kappa we are already completely lost.
                // And after the previous test, we know that the expression will not over/underflow.
                if ((unit >= tenKappa) || ((tenKappa - unit) <= unit))
                {
                    return false;
                }

                // If 2 * (rest + unit) <= 10^kappa, we can safely round down.
                if (((tenKappa - rest) > rest) && ((tenKappa - (2 * rest)) >= (2 * unit)))
                {
                    return true;
                }

                // If 2 * (rest - unit) >= 10^kappa, we can safely round up.
                if ((rest > unit) && (tenKappa <= (rest - unit) || ((tenKappa - (rest - unit)) <= (rest - unit))))
                {
                    // Increment the last digit recursively until we find a non '9' digit.
                    buffer[length - 1]++;

                    for (int i = (length - 1); i > 0; i--)
                    {
                        if (buffer[i] != ('0' + 10))
                        {
                            break;
                        }

                        buffer[i] = (byte)('0');
                        buffer[i - 1]++;
                    }

                    // If the first digit is now '0'+10, we had a buffer with all '9's.
                    // With the exception of the first digit, all digits are now '0'.
                    // Simply switch the first digit to '1' and adjust the kappa.
                    // For example, "99" becomes "10" and the power (the kappa) is increased.
                    if (buffer[0] == ('0' + 10))
                    {
                        buffer[0] = (byte)('1');
                        kappa++;
                    }

                    return true;
                }

                return false;
            }

            // Adjusts the last digit of the generated number and screens out generated solutions that may be inaccurate.
            // A solution may be inaccurate if it is outside the safe interval or if we cannot provide that it is closer to the input than a neighboring representation of the same length.
            //
            // Input:
            //      buffer containing the digits of tooHigh / 10^kappa
            //      the buffer's length
            //      distanceTooHighW == (tooHigh - w).f * unit
            //      unsafeInterval == (tooHigh - tooLow).f * unit
            //      rest = (tooHigh - buffer * 10^kapp).f * unit
            //      tenKappa = 10^kappa * unit
            //      unit = the common multiplier
            //
            // Output:
            //      Returns true if the buffer is guaranteed to contain the closest representable number to the input.
            //
            // Modifies the generated digits in the buffer to approach (round towards) w.
            private static bool TryRoundWeedShortest(Span<byte> buffer, int length, ulong distanceTooHighW, ulong unsafeInterval, ulong rest, ulong tenKappa, ulong unit)
            {
                ulong smallDistance = distanceTooHighW - unit;
                ulong bigDistance = distanceTooHighW + unit;

                // Let wLow = tooHigh - bigDistance, and wHigh = tooHigh - smallDistance.
                //
                // Note: wLow < w < wHigh
                //
                // The real w * unit must lie somewhere inside the interval
                //      ]w_low; w_high[ (often written as "(w_low; w_high)")

                // Basically the buffer currently contains a number in the unsafe interval
                //      ]too_low; too_high[ with too_low < w < too_high
                //
                //  tooHigh - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                //                    ^v 1 unit            ^      ^                 ^      ^
                //  boundaryHigh ---------------------     .      .                 .      .
                //                    ^v 1 unit            .      .                 .      .
                //  - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .
                //                                         .      .         ^       .      .
                //                                         .  bigDistance   .       .      .
                //                                         .      .         .       .    rest
                //                              smallDistance     .         .       .      .
                //                                         v      .         .       .      .
                //  wHigh - - - - - - - - - - - - - - - - - -     .         .       .      .
                //                    ^v 1 unit                   .         .       .      .
                //  w ---------------------------------------     .         .       .      .
                //                    ^v 1 unit                   v         .       .      .
                //  wLow  - - - - - - - - - - - - - - - - - - - - -         .       .      .
                //                                                          .       .      v
                //  buffer -------------------------------------------------+-------+--------
                //                                                          .       .
                //                                                  safeInterval    .
                //                                                          v       .
                //  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .
                //                    ^v 1 unit                                     .
                //  boundaryLow -------------------------                     unsafeInterval
                //                    ^v 1 unit                                     v
                //  tooLow  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                //
                //
                // Note that the value of buffer could lie anywhere inside the range tooLow to tooHigh.
                //
                // boundaryLow, boundaryHigh and w are approximations of the real boundaries and v (the input number).
                // They are guaranteed to be precise up to one unit.
                // In fact the error is guaranteed to be strictly less than one unit.
                //
                // Anything that lies outside the unsafe interval is guaranteed not to round to v when read again.
                // Anything that lies inside the safe interval is guaranteed to round to v when read again.
                //
                // If the number inside the buffer lies inside the unsafe interval but not inside the safe interval
                // then we simply do not know and bail out (returning false).
                //
                // Similarly we have to take into account the imprecision of 'w' when finding the closest representation of 'w'.
                // If we have two potential representations, and one is closer to both wLow and wHigh, then we know it is closer to the actual value v.
                //
                // By generating the digits of tooHigh we got the largest (closest to tooHigh) buffer that is still in the unsafe interval.
                // In the case where wHigh < buffer < tooHigh we try to decrement the buffer.
                // This way the buffer approaches (rounds towards) w.
                //
                // There are 3 conditions that stop the decrementation process:
                //   1) the buffer is already below wHigh
                //   2) decrementing the buffer would make it leave the unsafe interval
                //   3) decrementing the buffer would yield a number below wHigh and farther away than the current number.
                //
                // In other words:
                //      (buffer{-1} < wHigh) && wHigh - buffer{-1} > buffer - wHigh
                //
                // Instead of using the buffer directly we use its distance to tooHigh.
                //
                // Conceptually rest ~= tooHigh - buffer
                //
                // We need to do the following tests in this order to avoid over- and underflows.

                Debug.Assert(rest <= unsafeInterval);

                while ((rest < smallDistance) && ((unsafeInterval - rest) >= tenKappa) && (((rest + tenKappa) < smallDistance) || ((smallDistance - rest) >= (rest + tenKappa - smallDistance))))
                {
                    buffer[length - 1]--;
                    rest += tenKappa;
                }

                // We have approached w+ as much as possible.
                // We now test if approaching w- would require changing the buffer.
                // If yes, then we have two possible representations close to w, but we cannot decide which one is closer.
                if ((rest < bigDistance) && ((unsafeInterval - rest) >= tenKappa) && (((rest + tenKappa) < bigDistance) || ((bigDistance - rest) > (rest + tenKappa - bigDistance))))
                {
                    return false;
                }

                // Weeding test.
                //
                // The safe interval is [tooLow + 2 ulp; tooHigh - 2 ulp]
                // Since tooLow = tooHigh - unsafeInterval this is equivalent to
                //      [tooHigh - unsafeInterval + 4 ulp; tooHigh - 2 ulp]
                //
                // Conceptually we have: rest ~= tooHigh - buffer
                return ((2 * unit) <= rest) && (rest <= (unsafeInterval - 4 * unit));
            }
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Grisu3.cs.meta
================================================
fileFormatVersion: 2
guid: 5447d418e8d20414f941dc0316a0af97
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.NumberBuffer.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace System
{
    internal static partial class Number
    {
        // We need 1 additional byte, per length, for the terminating null
        internal const int DecimalNumberBufferLength = 29 + 1 + 1;  // 29 for the longest input + 1 for rounding
        internal const int DoubleNumberBufferLength = 767 + 1 + 1;  // 767 for the longest input + 1 for rounding: 4.9406564584124654E-324
        internal const int Int32NumberBufferLength = 10 + 1;    // 10 for the longest input: 2,147,483,647
        internal const int Int64NumberBufferLength = 19 + 1;    // 19 for the longest input: 9,223,372,036,854,775,807
        internal const int SingleNumberBufferLength = 112 + 1 + 1;  // 112 for the longest input + 1 for rounding: 1.40129846E-45
        internal const int UInt32NumberBufferLength = 10 + 1;   // 10 for the longest input: 4,294,967,295
        internal const int UInt64NumberBufferLength = 20 + 1;   // 20 for the longest input: 18,446,744,073,709,551,615

        internal unsafe ref struct NumberBuffer
        {
            public int DigitsCount;
            public int Scale;
            public bool IsNegative;
            public bool HasNonZeroTail;
            public NumberBufferKind Kind;
            public Span<byte> Digits;

            public NumberBuffer(NumberBufferKind kind, byte* digits, int digitsLength)
            {
                Debug.Assert(digits != null);
                Debug.Assert(digitsLength > 0);

                DigitsCount = 0;
                Scale = 0;
                IsNegative = false;
                HasNonZeroTail = false;
                Kind = kind;
                Digits = new Span<byte>(digits, digitsLength);

#if DEBUG
                Digits.Fill(0xCC);
#endif

                Digits[0] = (byte)('\0');
                CheckConsistency();
            }

            [Conditional("DEBUG")]
            public void CheckConsistency()
            {
#if DEBUG
                Debug.Assert((Kind == NumberBufferKind.Integer) || (Kind == NumberBufferKind.Decimal) || (Kind == NumberBufferKind.FloatingPoint));
                Debug.Assert(Digits[0] != '0', "Leading zeros should never be stored in a Number");
 
                int numDigits;
                for (numDigits = 0; numDigits < Digits.Length; numDigits++)
                {
                    byte digit = Digits[numDigits];
 
                    if (digit == 0)
                    {
                        break;
                    }
 
                    Debug.Assert((digit >= '0') && (digit <= '9'), "Unexpected character found in Number");
                }
 
                Debug.Assert(numDigits == DigitsCount, "Null terminator found in unexpected location in Number");
                Debug.Assert(numDigits < Digits.Length, "Null terminator not found in Number");
#endif // DEBUG
            }

            public byte* GetDigitsPointer()
            {
                // This is safe to do since we are a ref struct
                return (byte*)(Unsafe.AsPointer(ref Digits[0]));
            }

            //
            // Code coverage note: This only exists so that Number displays nicely in the VS watch window. So yes, I know it works.
            //
            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();

                sb.Append('[');
                sb.Append('"');

                for (int i = 0; i < Digits.Length; i++)
                {
                    byte digit = Digits[i];

                    if (digit == 0)
                    {
                        break;
                    }

                    sb.Append((char)(digit));
                }

                sb.Append('"');
                sb.Append(", Length = ").Append(DigitsCount);
                sb.Append(", Scale = ").Append(Scale);
                sb.Append(", IsNegative = ").Append(IsNegative);
                sb.Append(", HasNonZeroTail = ").Append(HasNonZeroTail);
                sb.Append(", Kind = ").Append(Kind);
                sb.Append(']');

                return sb.ToString();
            }
        }

        internal enum NumberBufferKind : byte
        {
            Unknown = 0,
            Integer = 1,
            Decimal = 2,
            FloatingPoint = 3,
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.NumberBuffer.cs.meta
================================================
fileFormatVersion: 2
guid: 87bdf9f8d442e2842b3821eea6b35164
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.NumberToFloatingPointBits.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace System
{
    internal unsafe partial class Number
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static unsafe int SingleToInt32Bits(float value)
        {
            return *((int*)&value);
        }

        public readonly struct FloatingPointInfo
        {
            public static readonly FloatingPointInfo Double = new FloatingPointInfo(
                denormalMantissaBits: 52,
                exponentBits: 11,
                maxBinaryExponent: 1023,
                exponentBias: 1023,
                infinityBits: 0x7FF00000_00000000
            );

            public static readonly FloatingPointInfo Single = new FloatingPointInfo(
                denormalMantissaBits: 23,
                exponentBits: 8,
                maxBinaryExponent: 127,
                exponentBias: 127,
                infinityBits: 0x7F800000
            );

            public ulong ZeroBits { get; }
            public ulong InfinityBits { get; }

            public ulong NormalMantissaMask { get; }
            public ulong DenormalMantissaMask { get; }

            public int MinBinaryExponent { get; }
            public int MaxBinaryExponent { get; }

            public int ExponentBias { get; }
            public int OverflowDecimalExponent { get; }

            public ushort NormalMantissaBits { get; }
            public ushort DenormalMantissaBits { get; }

            public ushort ExponentBits { get; }

            public FloatingPointInfo(ushort denormalMantissaBits, ushort exponentBits, int maxBinaryExponent, int exponentBias, ulong infinityBits)
            {
                ExponentBits = exponentBits;

                DenormalMantissaBits = denormalMantissaBits;
                NormalMantissaBits = (ushort)(denormalMantissaBits + 1); // we get an extra (hidden) bit for normal mantissas

                OverflowDecimalExponent = (maxBinaryExponent + 2 * NormalMantissaBits) / 3;
                ExponentBias = exponentBias;

                MaxBinaryExponent = maxBinaryExponent;
                MinBinaryExponent = 1 - maxBinaryExponent;

                DenormalMantissaMask = (1UL << denormalMantissaBits) - 1;
                NormalMantissaMask = (1UL << NormalMantissaBits) - 1;

                InfinityBits = infinityBits;
                ZeroBits = 0;
            }
        }

        private static readonly float[] s_Pow10SingleTable = new float[]
        {
            1e0f,   // 10^0
            1e1f,   // 10^1
            1e2f,   // 10^2
            1e3f,   // 10^3
            1e4f,   // 10^4
            1e5f,   // 10^5
            1e6f,   // 10^6
            1e7f,   // 10^7
            1e8f,   // 10^8
            1e9f,   // 10^9
            1e10f,  // 10^10
        };

        private static readonly double[] s_Pow10DoubleTable = new double[]
        {
            1e0,    // 10^0
            1e1,    // 10^1
            1e2,    // 10^2
            1e3,    // 10^3
            1e4,    // 10^4
            1e5,    // 10^5
            1e6,    // 10^6
            1e7,    // 10^7
            1e8,    // 10^8
            1e9,    // 10^9
            1e10,   // 10^10
            1e11,   // 10^11
            1e12,   // 10^12
            1e13,   // 10^13
            1e14,   // 10^14
            1e15,   // 10^15
            1e16,   // 10^16
            1e17,   // 10^17
            1e18,   // 10^18
            1e19,   // 10^19
            1e20,   // 10^20
            1e21,   // 10^21
            1e22,   // 10^22
        };

        private static void AccumulateDecimalDigitsIntoBigInteger(ref NumberBuffer number, uint firstIndex, uint lastIndex, out BigInteger result)
        {
            BigInteger.SetZero(out result);

            byte* src = number.GetDigitsPointer() + firstIndex;
            uint remaining = lastIndex - firstIndex;

            while (remaining != 0)
            {
                uint count = Math.Min(remaining, 9);
                uint value = DigitsToUInt32(src, (int)(count));

                result.MultiplyPow10(count);
                result.Add(value);

                src += count;
                remaining -= count;
            }
        }

        private static ulong AssembleFloatingPointBits(in FloatingPointInfo info, ulong initialMantissa, int initialExponent, bool hasZeroTail)
        {
            // number of bits by which we must adjust the mantissa to shift it into the
            // correct position, and compute the resulting base two exponent for the
            // normalized mantissa:
            uint initialMantissaBits = BigInteger.CountSignificantBits(initialMantissa);
            int normalMantissaShift = info.NormalMantissaBits - (int)(initialMantissaBits);
            int normalExponent = initialExponent - normalMantissaShift;

            ulong mantissa = initialMantissa;
            int exponent = normalExponent;

            if (normalExponent > info.MaxBinaryExponent)
            {
                // The exponent is too large to be represented by the floating point
                // type; report the overflow condition:
                return info.InfinityBits;
            }
            else if (normalExponent < info.MinBinaryExponent)
            {
                // The exponent is too small to be represented by the floating point
                // type as a normal value, but it may be representable as a denormal
                // value.  Compute the number of bits by which we need to shift the
                // mantissa in order to form a denormal number.  (The subtraction of
                // an extra 1 is to account for the hidden bit of the mantissa that
                // is not available for use when representing a denormal.)
                int denormalMantissaShift = normalMantissaShift + normalExponent + info.ExponentBias - 1;

                // Denormal values have an exponent of zero, so the debiased exponent is
                // the negation of the exponent bias:
                exponent = -info.ExponentBias;

                if (denormalMantissaShift < 0)
                {
                    // Use two steps for right shifts:  for a shift of N bits, we first
                    // shift by N-1 bits, then shift the last bit and use its value to
                    // round the mantissa.
                    mantissa = RightShiftWithRounding(mantissa, -denormalMantissaShift, hasZeroTail);

                    // If the mantissa is now zero, we have underflowed:
                    if (mantissa == 0)
                    {
                        return info.ZeroBits;
                    }

                    // When we round the mantissa, the result may be so large that the
                    // number becomes a normal value.  For example, consider the single
                    // precision case where the mantissa is 0x01ffffff and a right shift
                    // of 2 is required to shift the value into position. We perform the
                    // shift in two steps:  we shift by one bit, then we shift again and
                    // round using the dropped bit.  The initial shift yields 0x00ffffff.
                    // The rounding shift then yields 0x007fffff and because the least
                    // significant bit was 1, we add 1 to this number to round it.  The
                    // final result is 0x00800000.
                    //
                    // 0x00800000 is 24 bits, which is more than the 23 bits available
                    // in the mantissa.  Thus, we have rounded our denormal number into
                    // a normal number.
                    //
                    // We detect this case here and re-adjust the mantissa and exponent
                    // appropriately, to form a normal number:
                    if (mantissa > info.DenormalMantissaMask)
                    {
                        // We add one to the denormal_mantissa_shift to account for the
                        // hidden mantissa bit (we subtracted one to account for this bit
                        // when we computed the denormal_mantissa_shift above).
                        exponent = initialExponent - (denormalMantissaShift + 1) - normalMantissaShift;
                    }
                }
                else
                {
                    mantissa <<= denormalMantissaShift;
                }
            }
            else
            {
                if (normalMantissaShift < 0)
                {
                    // Use two steps for right shifts:  for a shift of N bits, we first
                    // shift by N-1 bits, then shift the last bit and use its value to
                    // round the mantissa.
                    mantissa = RightShiftWithRounding(mantissa, -normalMantissaShift, hasZeroTail);

                    // When we round the mantissa, it may produce a result that is too
                    // large.  In this case, we divide the mantissa by two and increment
                    // the exponent (this does not change the value).
                    if (mantissa > info.NormalMantissaMask)
                    {
                        mantissa >>= 1;
                        exponent++;

                        // The increment of the exponent may have generated a value too
                        // large to be represented.  In this case, report the overflow:
                        if (exponent > info.MaxBinaryExponent)
                        {
                            return info.InfinityBits;
                        }
                    }
                }
                else if (normalMantissaShift > 0)
                {
                    mantissa <<= normalMantissaShift;
                }
            }

            // Unset the hidden bit in the mantissa and assemble the floating point value
            // from the computed components:
            mantissa &= info.DenormalMantissaMask;

            Debug.Assert((info.DenormalMantissaMask & (1UL << info.DenormalMantissaBits)) == 0);
            ulong shiftedExponent = ((ulong)(exponent + info.ExponentBias)) << info.DenormalMantissaBits;
            Debug.Assert((shiftedExponent & info.DenormalMantissaMask) == 0);
            Debug.Assert((mantissa & ~info.DenormalMantissaMask) == 0);
            Debug.Assert((shiftedExponent & ~(((1UL << info.ExponentBits) - 1) << info.DenormalMantissaBits)) == 0); // exponent fits in its place

            return shiftedExponent | mantissa;
        }

        private static ulong ConvertBigIntegerToFloatingPointBits(ref BigInteger value, in FloatingPointInfo info, uint integerBitsOfPrecision, bool hasNonZeroFractionalPart)
        {
            int baseExponent = info.DenormalMantissaBits;

            // When we have 64-bits or less of precision, we can just get the mantissa directly
            if (integerBitsOfPrecision <= 64)
            {
                return AssembleFloatingPointBits(in info, value.ToUInt64(), baseExponent, !hasNonZeroFractionalPart);
            }

            uint topBlockIndex = MathEx.DivRem(integerBitsOfPrecision, 32, out uint topBlockBits);
            uint middleBlockIndex = topBlockIndex - 1;
            uint bottomBlockIndex = middleBlockIndex - 1;

            ulong mantissa;
            int exponent = baseExponent + ((int)(bottomBlockIndex) * 32);
            bool hasZeroTail = !hasNonZeroFractionalPart;

            // When the top 64-bits perfectly span two blocks, we can get those blocks directly
            if (topBlockBits == 0)
            {
                mantissa = ((ulong)(value.GetBlock(middleBlockIndex)) << 32) + value.GetBlock(bottomBlockIndex);
            }
            else
            {
                // Otherwise, we need to read three blocks and combine them into a 64-bit mantissa

                int bottomBlockShift = (int)(topBlockBits);
                int topBlockShift = 64 - bottomBlockShift;
                int middleBlockShift = topBlockShift - 32;

                exponent += (int)(topBlockBits);

                uint bottomBlock = value.GetBlock(bottomBlockIndex);
                uint bottomBits = bottomBlock >> bottomBlockShift;

                ulong middleBits = (ulong)(value.GetBlock(middleBlockIndex)) << middleBlockShift;
                ulong topBits = (ulong)(value.GetBlock(topBlockIndex)) << topBlockShift;

                mantissa = topBits + middleBits + bottomBits;

                uint unusedBottomBlockBitsMask = (1u << (int)(topBlockBits)) - 1;
                hasZeroTail &= (bottomBlock & unusedBottomBlockBitsMask) == 0;
            }

            for (uint i = 0; i != bottomBlockIndex; i++)
            {
                hasZeroTail &= (value.GetBlock(i) == 0);
            }

            return AssembleFloatingPointBits(in info, mantissa, exponent, hasZeroTail);
        }

        // get 32-bit integer from at most 9 digits
        private static uint DigitsToUInt32(byte* p, int count)
        {
            Debug.Assert((1 <= count) && (count <= 9));

            byte* end = (p + count);
            uint res = (uint)(p[0] - '0');

            for (p++; p < end; p++)
            {
                res = (10 * res) + p[0] - '0';
            }

            return res;
        }

        // get 64-bit integer from at most 19 digits
        private static ulong DigitsToUInt64(byte* p, int count)
        {
            Debug.Assert((1 <= count) && (count <= 19));

            byte* end = (p + count);
            ulong res = (ulong)(p[0] - '0');

            for (p++; p < end; p++)
            {
                res = (10 * res) + p[0] - '0';
            }

            return res;
        }

        private static ulong NumberToFloatingPointBits(ref NumberBuffer number, in FloatingPointInfo info)
        {
            Debug.Assert(number.GetDigitsPointer()[0] != '0');

            Debug.Assert(number.Scale <= FloatingPointMaxExponent);
            Debug.Assert(number.Scale >= FloatingPointMinExponent);

            Debug.Assert(number.DigitsCount != 0);

            // The input is of the form 0.Mantissa x 10^Exponent, where 'Mantissa' are
            // the decimal digits of the mantissa and 'Exponent' is the decimal exponent.
            // We decompose the mantissa into two parts: an integer part and a fractional
            // part.  If the exponent is positive, then the integer part consists of the
            // first 'exponent' digits, or all present digits if there are fewer digits.
            // If the exponent is zero or negative, then the integer part is empty.  In
            // either case, the remaining digits form the fractional part of the mantissa.

            uint totalDigits = (uint)(number.DigitsCount);
            uint positiveExponent = (uint)(Math.Max(0, number.Scale));

            uint integerDigitsPresent = Math.Min(positiveExponent, totalDigits);
            uint fractionalDigitsPresent = totalDigits - integerDigitsPresent;

            uint fastExponent = (uint)(Math.Abs(number.Scale - integerDigitsPresent - fractionalDigitsPresent));

            // When the number of significant digits is less than or equal to 15 and the
            // scale is less than or equal to 22, we can take some shortcuts and just rely
            // on floating-point arithmetic to compute the correct result. This is
            // because each floating-point precision values allows us to exactly represent
            // different whole integers and certain powers of 10, depending on the underlying
            // formats exact range. Additionally, IEEE operations dictate that the result is
            // computed to the infinitely precise result and then rounded, which means that
            // we can rely on it to produce the correct result when both inputs are exact.

            byte* src = number.GetDigitsPointer();

            if ((info.DenormalMantissaBits == 23) && (totalDigits <= 7) && (fastExponent <= 10))
            {
                // It is only valid to do this optimization for single-precision floating-point
                // values since we can lose some of the mantissa bits and would return the
                // wrong value when upcasting to double.

                float result = DigitsToUInt32(src, (int)(totalDigits));
                float scale = s_Pow10SingleTable[fastExponent];

                if (fractionalDigitsPresent != 0)
                {
                    result /= scale;
                }
                else
                {
                    result *= scale;
                }

                return (uint)(SingleToInt32Bits(result));
            }

            if ((totalDigits <= 15) && (fastExponent <= 22))
            {
                double result = DigitsToUInt64(src, (int)(totalDigits));
                double scale = s_Pow10DoubleTable[fastExponent];

                if (fractionalDigitsPresent != 0)
                {
                    result /= scale;
                }
                else
                {
                    result *= scale;
                }

                if (info.DenormalMantissaBits == 52)
                {
                    return (ulong)(BitConverter.DoubleToInt64Bits(result));
                }
                else
                {
                    Debug.Assert(info.DenormalMantissaBits == 23);
                    return (uint)(SingleToInt32Bits((float)(result)));
                }
            }

            return NumberToFloatingPointBitsSlow(ref number, in info, positiveExponent, integerDigitsPresent, fractionalDigitsPresent);
        }

        private static ulong NumberToFloatingPointBitsSlow(ref NumberBuffer number, in FloatingPointInfo info, uint positiveExponent, uint integerDigitsPresent, uint fractionalDigitsPresent)
        {
            // To generate an N bit mantissa we require N + 1 bits of precision.  The
            // extra bit is used to correctly round the mantissa (if there are fewer bits
            // than this available, then that's totally okay; in that case we use what we
            // have and we don't need to round).
            uint requiredBitsOfPrecision = (uint)(info.NormalMantissaBits + 1);

            uint totalDigits = (uint)(number.DigitsCount);
            uint integerDigitsMissing = positiveExponent - integerDigitsPresent;

            const uint IntegerFirstIndex = 0;
            uint integerLastIndex = integerDigitsPresent;

            uint fractionalFirstIndex = integerLastIndex;
            uint fractionalLastIndex = totalDigits;

            // First, we accumulate the integer part of the mantissa into a big_integer:
            AccumulateDecimalDigitsIntoBigInteger(ref number, IntegerFirstIndex, integerLastIndex, out BigInteger integerValue);

            if (integerDigitsMissing > 0)
            {
                if (integerDigitsMissing > info.OverflowDecimalExponent)
                {
                    return info.InfinityBits;
                }

                integerValue.MultiplyPow10(integerDigitsMissing);
            }

            // At this point, the integer_value contains the value of the integer part
            // of the mantissa.  If either [1] this number has more than the required
            // number of bits of precision or [2] the mantissa has no fractional part,
            // then we can assemble the result immediately:
            uint integerBitsOfPrecision = BigInteger.CountSignificantBits(ref integerValue);

            if ((integerBitsOfPrecision >= requiredBitsOfPrecision) || (fractionalDigitsPresent == 0))
            {
                return ConvertBigIntegerToFloatingPointBits(
                    ref integerValue,
                    in info,
                    integerBitsOfPrecision,
                    fractionalDigitsPresent != 0
                );
            }

            // Otherwise, we did not get enough bits of precision from the integer part,
            // and the mantissa has a fractional part.  We parse the fractional part of
            // the mantissa to obtain more bits of precision.  To do this, we convert
            // the fractional part into an actual fraction N/M, where the numerator N is
            // computed from the digits of the fractional part, and the denominator M is
            // computed as the power of 10 such that N/M is equal to the value of the
            // fractional part of the mantissa.

            uint fractionalDenominatorExponent = fractionalDigitsPresent;

            if (number.Scale < 0)
            {
                fractionalDenominatorExponent += (uint)(-number.Scale);
            }

            if ((integerBitsOfPrecision == 0) && (fractionalDenominatorExponent - (int)(totalDigits)) > info.OverflowDecimalExponent)
            {
                // If there were any digits in the integer part, it is impossible to
                // underflow (because the exponent cannot possibly be small enough),
                // so if we underflow here it is a true underflow and we return zero.
                return info.ZeroBits;
            }

            AccumulateDecimalDigitsIntoBigInteger(ref number, fractionalFirstIndex, fractionalLastIndex, out BigInteger fractionalNumerator);

            if (fractionalNumerator.IsZero())
            {
                return ConvertBigIntegerToFloatingPointBits(
                    ref integerValue,
                    in info,
                    integerBitsOfPrecision,
                    fractionalDigitsPresent != 0
                );
            }

            BigInteger.Pow10(fractionalDenominatorExponent, out BigInteger fractionalDenominator);

            // Because we are using only the fractional part of the mantissa here, the
            // numerator is guaranteed to be smaller than the denominator.  We normalize
            // the fraction such that the most significant bit of the numerator is in
            // the same position as the most significant bit in the denominator.  This
            // ensures that when we later shift the numerator N bits to the left, we
            // will produce N bits of precision.
            uint fractionalNumeratorBits = BigInteger.CountSignificantBits(ref fractionalNumerator);
            uint fractionalDenominatorBits = BigInteger.CountSignificantBits(ref fractionalDenominator);

            uint fractionalShift = 0;

            if (fractionalDenominatorBits > fractionalNumeratorBits)
            {
                fractionalShift = fractionalDenominatorBits - fractionalNumeratorBits;
            }

            if (fractionalShift > 0)
            {
                fractionalNumerator.ShiftLeft(fractionalShift);
            }

            uint requiredFractionalBitsOfPrecision = requiredBitsOfPrecision - integerBitsOfPrecision;
            uint remainingBitsOfPrecisionRequired = requiredFractionalBitsOfPrecision;

            if (integerBitsOfPrecision > 0)
            {
                // If the fractional part of the mantissa provides no bits of precision
                // and cannot affect rounding, we can just take whatever bits we got from
                // the integer part of the mantissa.  This is the case for numbers like
                // 5.0000000000000000000001, where the significant digits of the fractional
                // part start so far to the right that they do not affect the floating
                // point representation.
                //
                // If the fractional shift is exactly equal to the number of bits of
                // precision that we require, then no fractional bits will be part of the
                // result, but the result may affect rounding.  This is e.g. the case for
                // large, odd integers with a fractional part greater than or equal to .5.
                // Thus, we need to do the division to correctly round the result.
                if (fractionalShift > remainingBitsOfPrecisionRequired)
                {
                    return ConvertBigIntegerToFloatingPointBits(
                        ref integerValue,
                        in info,
                        integerBitsOfPrecision,
                        fractionalDigitsPresent != 0
                    );
                }

                remainingBitsOfPrecisionRequired -= fractionalShift;
            }

            // If there was no integer part of the mantissa, we will need to compute the
            // exponent from the fractional part.  The fractional exponent is the power
            // of two by which we must multiply the fractional part to move it into the
            // range [1.0, 2.0).  This will either be the same as the shift we computed
            // earlier, or one greater than that shift:
            uint fractionalExponent = fractionalShift;

            if (BigInteger.Compare(ref fractionalNumerator, ref fractionalDenominator) < 0)
            {
                fractionalExponent++;
            }

            fractionalNumerator.ShiftLeft(remainingBitsOfPrecisionRequired);

            BigInteger.DivRem(ref fractionalNumerator, ref fractionalDenominator, out BigInteger bigFractionalMantissa, out BigInteger fractionalRemainder);
            ulong fractionalMantissa = bigFractionalMantissa.ToUInt64();
            bool hasZeroTail = !number.HasNonZeroTail && fractionalRemainder.IsZero();

            // We may have produced more bits of precision than were required.  Check,
            // and remove any "extra" bits:
            uint fractionalMantissaBits = BigInteger.CountSignificantBits(fractionalMantissa);

            if (fractionalMantissaBits > requiredFractionalBitsOfPrecision)
            {
                int shift = (int)(fractionalMantissaBits - requiredFractionalBitsOfPrecision);
                hasZeroTail = hasZeroTail && (fractionalMantissa & ((1UL << shift) - 1)) == 0;
                fractionalMantissa >>= shift;
            }

            // Compose the mantissa from the integer and fractional parts:
            ulong integerMantissa = integerValue.ToUInt64();
            ulong completeMantissa = (integerMantissa << (int)(requiredFractionalBitsOfPrecision)) + fractionalMantissa;

            // Compute the final exponent:
            // * If the mantissa had an integer part, then the exponent is one less than
            //   the number of bits we obtained from the integer part.  (It's one less
            //   because we are converting to the form 1.11111, with one 1 to the left
            //   of the decimal point.)
            // * If the mantissa had no integer part, then the exponent is the fractional
            //   exponent that we computed.
            // Then, in both cases, we subtract an additional one from the exponent, to
            // account for the fact that we've generated an extra bit of precision, for
            // use in rounding.
            int finalExponent = (integerBitsOfPrecision > 0) ? (int)(integerBitsOfPrecision) - 2 : -(int)(fractionalExponent) - 1;

            return AssembleFloatingPointBits(in info, completeMantissa, finalExponent, hasZeroTail);
        }

        private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail)
        {
            // If we'd need to shift further than it is possible to shift, the answer
            // is always zero:
            if (shift >= 64)
            {
                return 0;
            }

            ulong extraBitsMask = (1UL << (shift - 1)) - 1;
            ulong roundBitMask = (1UL << (shift - 1));
            ulong lsbBitMask = 1UL << shift;

            bool lsbBit = (value & lsbBitMask) != 0;
            bool roundBit = (value & roundBitMask) != 0;
            bool hasTailBits = !hasZeroTail || (value & extraBitsMask) != 0;

            return (value >> shift) + (ShouldRoundUp(lsbBit, roundBit, hasTailBits) ? 1UL : 0);
        }

        private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits)
        {
            // If there are insignificant set bits, we need to round to the
            // nearest; there are two cases:
            // we round up if either [1] the value is slightly greater than the midpoint
            // between two exactly representable values or [2] the value is exactly the
            // midpoint between two exactly representable values and the greater of the
            // two is even (this is "round-to-even").
            return roundBit && (hasTailBits || lsbBit);
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.NumberToFloatingPointBits.cs.meta
================================================
fileFormatVersion: 2
guid: 73257159620332b4aa8656f1ba5a86b3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/Number.Parsing.cs.meta
================================================
fileFormatVersion: 2
guid: b6559ed9c353778499e24e59333cc89f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/NumberFormatInfoEx.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace System
{
    internal static class NumberFormatInfoEx
    {
        internal static bool HasInvariantNumberSigns(this NumberFormatInfo info)
        {
            return info.PositiveSign == "+" && info.NegativeSign == "-";
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/NumberFormatInfoEx.cs.meta
================================================
fileFormatVersion: 2
guid: 0550e632456d8424e8b871651efa0bf2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/ValueStringBuilder.cs
================================================
﻿// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Text
{
    internal ref partial struct ValueStringBuilder
    {
        private char[]? _arrayToReturnToPool;
        private Span<char> _chars;
        private int _pos;

        public ValueStringBuilder(Span<char> initialBuffer)
        {
            _arrayToReturnToPool = null;
            _chars = initialBuffer;
            _pos = 0;
        }

        public ValueStringBuilder(int initialCapacity)
        {
            _arrayToReturnToPool = ArrayPool<char>.Shared.Rent(initialCapacity);
            _chars = _arrayToReturnToPool;
            _pos = 0;
        }

        public int Length
        {
            get => _pos;
            set
            {
                Debug.Assert(value >= 0);
                Debug.Assert(value <= _chars.Length);
                _pos = value;
            }
        }

        public int Capacity => _chars.Length;

        public void EnsureCapacity(int capacity)
        {
            if (capacity > _chars.Length)
            {
                Grow(capacity - _pos);
            }
        }

        /// <summary>
        /// Get a pinnable reference to the builder.
        /// Does not ensure there is a null char after <see cref="Length"/>
        /// This overload is pattern matched in the C# 7.3+ compiler so you can omit
        /// the explicit method call, and write eg "fixed (char* c = builder)"
        /// </summary>
        public ref char GetPinnableReference()
        {
            return ref MemoryMarshal.GetReference(_chars);
        }

        /// <summary>
        /// Get a pinnable reference to the builder.
        /// </summary>
        /// <param name="terminate">Ensures that the builder has a null char after <see cref="Length"/></param>
        public ref char GetPinnableReference(bool terminate)
        {
            if (terminate)
            {
                EnsureCapacity(Length + 1);
                _chars[Length] = '\0';
            }
            return ref MemoryMarshal.GetReference(_chars);
        }

        public ref char this[int index]
        {
            get
            {
                Debug.Assert(index < _pos);
                return ref _chars[index];
            }
        }

        public override string ToString()
        {
            string s = _chars.Slice(0, _pos).ToString();
            Dispose();
            return s;
        }

        /// <summary>Returns the underlying storage of the builder.</summary>
        public Span<char> RawChars => _chars;

        /// <summary>
        /// Returns a span around the contents of the builder.
        /// </summary>
        /// <param name="terminate">Ensures that the builder has a null char after <see cref="Length"/></param>
        public ReadOnlySpan<char> AsSpan(bool terminate)
        {
            if (terminate)
            {
                EnsureCapacity(Length + 1);
                _chars[Length] = '\0';
            }
            return _chars.Slice(0, _pos);
        }

        public ReadOnlySpan<char> AsSpan() => _chars.Slice(0, _pos);
        public ReadOnlySpan<char> AsSpan(int start) => _chars.Slice(start, _pos - start);
        public ReadOnlySpan<char> AsSpan(int start, int length) => _chars.Slice(start, length);

        public bool TryCopyTo(Span<char> destination, out int charsWritten)
        {
            if (_chars.Slice(0, _pos).TryCopyTo(destination))
            {
                charsWritten = _pos;
                Dispose();
                return true;
            }
            else
            {
                charsWritten = 0;
                Dispose();
                return false;
            }
        }

        public void Insert(int index, char value, int count)
        {
            if (_pos > _chars.Length - count)
            {
                Grow(count);
            }

            int remaining = _pos - index;
            _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count));
            _chars.Slice(index, count).Fill(value);
            _pos += count;
        }

        public void Insert(int index, string s)
        {
            if (s == null)
            {
                return;
            }

            int count = s.Length;

            if (_pos > (_chars.Length - count))
            {
                Grow(count);
            }

            int remaining = _pos - index;
            _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count));
            s.AsSpan().CopyTo(_chars.Slice(index));
            _pos += count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(char c)
        {
            int pos = _pos;
            if ((uint)pos < (uint)_chars.Length)
            {
                _chars[pos] = c;
                _pos = pos + 1;
            }
            else
            {
                GrowAndAppend(c);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(string s)
        {
            if (s == null)
            {
                return;
            }

            int pos = _pos;
            if (s.Length == 1 && (uint)pos < (uint)_chars.Length) // very common case, e.g. appending strings from NumberFormatInfo like separators, percent symbols, etc.
            {
                _chars[pos] = s[0];
                _pos = pos + 1;
            }
            else
            {
                AppendSlow(s);
            }
        }

        private void AppendSlow(string s)
        {
            int pos = _pos;
            if (pos > _chars.Length - s.Length)
            {
                Grow(s.Length);
            }

            s.AsSpan().CopyTo(_chars.Slice(pos));
            _pos += s.Length;
        }

        public void Append(char c, int count)
        {
            if (_pos > _chars.Length - count)
            {
                Grow(count);
            }

            Span<char> dst = _chars.Slice(_pos, count);
            for (int i = 0; i < dst.Length; i++)
            {
                dst[i] = c;
            }
            _pos += count;
        }

        public unsafe void Append(char* value, int length)
        {
            int pos = _pos;
            if (pos > _chars.Length - length)
            {
                Grow(length);
            }

            Span<char> dst = _chars.Slice(_pos, length);
            for (int i = 0; i < dst.Length; i++)
            {
                dst[i] = *value++;
            }
            _pos += length;
        }

        public void Append(ReadOnlySpan<char> value)
        {
            int pos = _pos;
            if (pos > _chars.Length - value.Length)
            {
                Grow(value.Length);
            }

            value.CopyTo(_chars.Slice(_pos));
            _pos += value.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Span<char> AppendSpan(int length)
        {
            int origPos = _pos;
            if (origPos > _chars.Length - length)
            {
                Grow(length);
            }

            _pos = origPos + length;
            return _chars.Slice(origPos, length);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void GrowAndAppend(char c)
        {
            Grow(1);
            Append(c);
        }

        /// <summary>
        /// Resize the internal buffer either by doubling current buffer size or
        /// by adding <paramref name="additionalCapacityBeyondPos"/> to
        /// <see cref="_pos"/> whichever is greater.
        /// </summary>
        /// <param name="additionalCapacityBeyondPos">
        /// Number of chars requested beyond current position.
        /// </param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Grow(int additionalCapacityBeyondPos)
        {
            Debug.Assert(additionalCapacityBeyondPos > 0);
            Debug.Assert(_pos > _chars.Length - additionalCapacityBeyondPos, "Grow called incorrectly, no resize is needed.");

            char[] poolArray = ArrayPool<char>.Shared.Rent(Math.Max(_pos + additionalCapacityBeyondPos, _chars.Length * 2));

            _chars.Slice(0, _pos).CopyTo(poolArray);

            char[]? toReturn = _arrayToReturnToPool;
            _chars = _arrayToReturnToPool = poolArray;
            if (toReturn != null)
            {
                ArrayPool<char>.Shared.Return(toReturn);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            char[]? toReturn = _arrayToReturnToPool;
            this = default; // for safety, to avoid using pooled array if this instance is erroneously appended to again
            if (toReturn != null)
            {
                ArrayPool<char>.Shared.Return(toReturn);
            }
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Number/ValueStringBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: 4c5602223bfb1324ba376e5508ae9134
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Unity/TextMeshProExtensions.cs
================================================
﻿#if ZSTRING_TEXTMESHPRO_SUPPORT
using System;
using TMPro;

namespace Cysharp.Text
{
    public static partial class TextMeshProExtensions
    {
        public static void SetText<T>(this TMP_Text text, T arg0)
        {
            using ( var sb = new Cysharp.Text.Utf16ValueStringBuilder( true ) )
            {
                sb.Append(arg0);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }
        
        public static void SetTextFormat<T0>(this TMP_Text text, string format, T0 arg0)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1>(this TMP_Text text, string format, T0 arg0, T1 arg1)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

        public static void SetTextFormat<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this TMP_Text text, string format, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            using (var sb = new Cysharp.Text.Utf16ValueStringBuilder(true))
            {
                
                sb.AppendFormat(format, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
                var array = sb.AsArraySegment();
                text.SetCharArray(array.Array, array.Offset, array.Count);
            }
        }

    }
}
#endif



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Unity/TextMeshProExtensions.cs.meta
================================================
fileFormatVersion: 2
guid: 3e8ff697dcb687d47a24aeebcfb46817
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Unity/TextMeshProExtensions.SetStringBuilder.cs
================================================
﻿#if ZSTRING_TEXTMESHPRO_SUPPORT
using System;
using TMPro;

namespace Cysharp.Text
{
    public static partial class TextMeshProExtensions
    {
        public static void SetText(this TMP_Text text, Utf16ValueStringBuilder stringBuilder)
        {
            var array = stringBuilder.AsArraySegment();
            text.SetCharArray(array.Array, array.Offset, array.Count);
        }
    }
}
#endif



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Unity/TextMeshProExtensions.SetStringBuilder.cs.meta
================================================
fileFormatVersion: 2
guid: 26ef652c2e8c2cc488e0b2e063a179ce
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16/Utf16ValueStringBuilder.AppendFormat.cs.meta
================================================
fileFormatVersion: 2
guid: 2c686f65ca8d42c4aa85d157c378f10e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16/Utf16ValueStringBuilder.CreateFormatter.cs
================================================
﻿using System;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        static object? CreateFormatter(Type type)
        {
            if (type == typeof(System.SByte))
            {
                return new TryFormat<System.SByte>((System.SByte x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int16))
            {
                return new TryFormat<System.Int16>((System.Int16 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int32))
            {
                return new TryFormat<System.Int32>((System.Int32 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Int64))
            {
                return new TryFormat<System.Int64>((System.Int64 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Byte))
            {
                return new TryFormat<System.Byte>((System.Byte x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt16))
            {
                return new TryFormat<System.UInt16>((System.UInt16 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt32))
            {
                return new TryFormat<System.UInt32>((System.UInt32 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UInt64))
            {
                return new TryFormat<System.UInt64>((System.UInt64 x, Span<char> dest, out int written, ReadOnlySpan<char> format) => format.Length == 0 ? FastNumberWriter.TryWriteUInt64(dest, out written, x) : x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Single))
            {
                return new TryFormat<System.Single>((System.Single x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Double))
            {
                return new TryFormat<System.Double>((System.Double x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.TimeSpan))
            {
                return new TryFormat<System.TimeSpan>((System.TimeSpan x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.DateTime))
            {
                return new TryFormat<System.DateTime>((System.DateTime x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.DateTimeOffset))
            {
                return new TryFormat<System.DateTimeOffset>((System.DateTimeOffset x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Decimal))
            {
                return new TryFormat<System.Decimal>((System.Decimal x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Guid))
            {
                return new TryFormat<System.Guid>((System.Guid x, Span<char> dest, out int written, ReadOnlySpan<char> format) => x.TryFormat(dest, out written, format));
            }
            if (type == typeof(System.Byte?))
            {
                return CreateNullableFormatter<System.Byte>();
            }
            if (type == typeof(System.DateTime?))
            {
                return CreateNullableFormatter<System.DateTime>();
            }
            if (type == typeof(System.DateTimeOffset?))
            {
                return CreateNullableFormatter<System.DateTimeOffset>();
            }
            if (type == typeof(System.Decimal?))
            {
                return CreateNullableFormatter<System.Decimal>();
            }
            if (type == typeof(System.Double?))
            {
                return CreateNullableFormatter<System.Double>();
            }
            if (type == typeof(System.Int16?))
            {
                return CreateNullableFormatter<System.Int16>();
            }
            if (type == typeof(System.Int32?))
            {
                return CreateNullableFormatter<System.Int32>();
            }
            if (type == typeof(System.Int64?))
            {
                return CreateNullableFormatter<System.Int64>();
            }
            if (type == typeof(System.SByte?))
            {
                return CreateNullableFormatter<System.SByte>();
            }
            if (type == typeof(System.Single?))
            {
                return CreateNullableFormatter<System.Single>();
            }
            if (type == typeof(System.TimeSpan?))
            {
                return CreateNullableFormatter<System.TimeSpan>();
            }
            if (type == typeof(System.UInt16?))
            {
                return CreateNullableFormatter<System.UInt16>();
            }
            if (type == typeof(System.UInt32?))
            {
                return CreateNullableFormatter<System.UInt32>();
            }
            if (type == typeof(System.UInt64?))
            {
                return CreateNullableFormatter<System.UInt64>();
            }
            if (type == typeof(System.Guid?))
            {
                return CreateNullableFormatter<System.Guid>();
            }
            if (type == typeof(System.Boolean?))
            {
                return CreateNullableFormatter<System.Boolean>();
            }
            if (type == typeof(System.IntPtr))
            {
                return new TryFormat<System.IntPtr>((System.IntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format) => System.IntPtr.Size == 4
                    ? x.ToInt32().TryFormat(dest, out written, format)
                    : x.ToInt64().TryFormat(dest, out written, format));
            }
            if (type == typeof(System.UIntPtr))
            {
                return new TryFormat<System.UIntPtr>((System.UIntPtr x, Span<char> dest, out int written, ReadOnlySpan<char> format) => System.UIntPtr.Size == 4
                    ? x.ToUInt32().TryFormat(dest, out written, format)
                    : x.ToUInt64().TryFormat(dest, out written, format));
            }
            return null;
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16/Utf16ValueStringBuilder.CreateFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: d81568aff3a79df41881112bb037c194
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16/Utf16ValueStringBuilder.SpanFormattableAppend.cs
================================================
﻿using System;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf16ValueStringBuilder
    {
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value, string format)
        {
            Append(value, format);
            AppendLine();
        }
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value, string format)
        {
            if(!value.TryFormat(buffer.AsSpan(index), out var written, format.AsSpan()))
            {
                Grow(written);
                if(!value.TryFormat(buffer.AsSpan(index), out written, format.AsSpan()))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value, string format)
        {
            Append(value, format);
            AppendLine();
        }
    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf16/Utf16ValueStringBuilder.SpanFormattableAppend.cs.meta
================================================
fileFormatVersion: 2
guid: 0143a9022d2d364409298fa82d0bbc01
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8/Utf8ValueStringBuilder.AppendFormat.cs.meta
================================================
fileFormatVersion: 2
guid: 5d7ee057fcee1904f9ac7f3bf532a09e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8/Utf8ValueStringBuilder.CreateFormatter.cs
================================================
﻿using System;
using System.Buffers;
using System.Buffers.Text;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
        static object? CreateFormatter(Type type)
        {
            if (type == typeof(System.Byte))
            {
                return new TryFormat<System.Byte>((System.Byte x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.DateTime))
            {
                return new TryFormat<System.DateTime>((System.DateTime x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.DateTimeOffset))
            {
                return new TryFormat<System.DateTimeOffset>((System.DateTimeOffset x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Decimal))
            {
                return new TryFormat<System.Decimal>((System.Decimal x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Double))
            {
                return new TryFormat<System.Double>((System.Double x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int16))
            {
                return new TryFormat<System.Int16>((System.Int16 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int32))
            {
                return new TryFormat<System.Int32>((System.Int32 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Int64))
            {
                return new TryFormat<System.Int64>((System.Int64 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.SByte))
            {
                return new TryFormat<System.SByte>((System.SByte x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Single))
            {
                return new TryFormat<System.Single>((System.Single x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.TimeSpan))
            {
                return new TryFormat<System.TimeSpan>((System.TimeSpan x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt16))
            {
                return new TryFormat<System.UInt16>((System.UInt16 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt32))
            {
                return new TryFormat<System.UInt32>((System.UInt32 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.UInt64))
            {
                return new TryFormat<System.UInt64>((System.UInt64 x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Guid))
            {
                return new TryFormat<System.Guid>((System.Guid x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Boolean))
            {
                return new TryFormat<System.Boolean>((System.Boolean x, Span<byte> dest, out int written, StandardFormat format) => Utf8Formatter.TryFormat(x, dest, out written, format));
            }
            if (type == typeof(System.Byte?))
            {
                return CreateNullableFormatter<System.Byte>();
            }
            if (type == typeof(System.DateTime?))
            {
                return CreateNullableFormatter<System.DateTime>();
            }
            if (type == typeof(System.DateTimeOffset?))
            {
                return CreateNullableFormatter<System.DateTimeOffset>();
            }
            if (type == typeof(System.Decimal?))
            {
                return CreateNullableFormatter<System.Decimal>();
            }
            if (type == typeof(System.Double?))
            {
                return CreateNullableFormatter<System.Double>();
            }
            if (type == typeof(System.Int16?))
            {
                return CreateNullableFormatter<System.Int16>();
            }
            if (type == typeof(System.Int32?))
            {
                return CreateNullableFormatter<System.Int32>();
            }
            if (type == typeof(System.Int64?))
            {
                return CreateNullableFormatter<System.Int64>();
            }
            if (type == typeof(System.SByte?))
            {
                return CreateNullableFormatter<System.SByte>();
            }
            if (type == typeof(System.Single?))
            {
                return CreateNullableFormatter<System.Single>();
            }
            if (type == typeof(System.TimeSpan?))
            {
                return CreateNullableFormatter<System.TimeSpan>();
            }
            if (type == typeof(System.UInt16?))
            {
                return CreateNullableFormatter<System.UInt16>();
            }
            if (type == typeof(System.UInt32?))
            {
                return CreateNullableFormatter<System.UInt32>();
            }
            if (type == typeof(System.UInt64?))
            {
                return CreateNullableFormatter<System.UInt64>();
            }
            if (type == typeof(System.Guid?))
            {
                return CreateNullableFormatter<System.Guid>();
            }
            if (type == typeof(System.Boolean?))
            {
                return CreateNullableFormatter<System.Boolean>();
            }
            if (type == typeof(System.IntPtr))
            {
                return new TryFormat<System.IntPtr>((System.IntPtr x, Span<byte> dest, out int written, StandardFormat format) => System.IntPtr.Size == 4
                    ? Utf8Formatter.TryFormat(x.ToInt32(),  dest, out written, format)
                    : Utf8Formatter.TryFormat(x.ToInt64(),  dest, out written, format));
            }
            if (type == typeof(System.UIntPtr))
            {
                return new TryFormat<System.UIntPtr>((System.UIntPtr x, Span<byte> dest, out int written, StandardFormat format) => System.UIntPtr.Size == 4
                    ? Utf8Formatter.TryFormat(x.ToUInt32(),  dest, out written, format)
                    : Utf8Formatter.TryFormat(x.ToUInt64(),  dest, out written, format));
            }

            return null;
        }
    }
}


================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8/Utf8ValueStringBuilder.CreateFormatter.cs.meta
================================================
fileFormatVersion: 2
guid: 35e4f4117a41a70438f0ff051e65e239
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8/Utf8ValueStringBuilder.SpanFormattableAppend.cs
================================================
﻿using System;
using System.Buffers;
using System.Buffers.Text;
using System.Runtime.CompilerServices;

namespace Cysharp.Text
{
    public partial struct Utf8ValueStringBuilder
    {
        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Byte value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Byte value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTime value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTime value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.DateTimeOffset value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.DateTimeOffset value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Decimal value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Decimal value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Double value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Double value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int16 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int16 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int32 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int32 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Int64 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Int64 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.SByte value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.SByte value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Single value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Single value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.TimeSpan value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.TimeSpan value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt16 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt16 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt32 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt32 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.UInt64 value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.UInt64 value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Guid value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Guid value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value to this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Boolean value)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value to this instance with numeric format strings.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Append(System.Boolean value, StandardFormat format)
        {
            if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out var written, format))
            {
                Grow(written);
                if(!Utf8Formatter.TryFormat(value, buffer.AsSpan(index), out written, format))
                {
                    ThrowArgumentException(nameof(value));
                }
            }
            index += written;
        }

        /// <summary>Appends the string representation of a specified value followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Boolean value)
        {
            Append(value);
            AppendLine();
        }

        /// <summary>Appends the string representation of a specified value with numeric format strings followed by the default line terminator to the end of this instance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendLine(System.Boolean value, StandardFormat format)
        {
            Append(value, format);
            AppendLine();
        }

    }
}



================================================
FILE: src/ZString.Unity/Assets/Scripts/ZString/Utf8/Utf8ValueStringBuilder.SpanFormattableAppend.cs.meta
================================================
fileFormatVersion: 2
guid: d3c9ebcd92d8b6842821732af2a75fba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 



================================================
FILE: src/ZString.Unity/ProjectSettings/AudioManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!11 &1
AudioManager:
  m_ObjectHideFlags: 0
  m_Volume: 1
  Rolloff Scale: 1
  Doppler Factor: 1
  Default Speaker Mode: 2
  m_SampleRate: 0
  m_DSPBufferSize: 1024
  m_VirtualVoiceCount: 512
  m_RealVoiceCount: 32
  m_SpatializerPlugin: 
  m_AmbisonicDecoderPlugin: 
  m_DisableAudio: 0
  m_VirtualizeEffects: 1



================================================
FILE: src/ZString.Unity/ProjectSettings/boot.config
================================================
[Empty file]


================================================
FILE: src/ZString.Unity/ProjectSettings/ClusterInputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!236 &1
ClusterInputManager:
  m_ObjectHideFlags: 0
  m_Inputs: []



================================================
FILE: src/ZString.Unity/ProjectSettings/DynamicsManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!55 &1
PhysicsManager:
  m_ObjectHideFlags: 0
  serializedVersion: 7
  m_Gravity: {x: 0, y: -9.81, z: 0}
  m_DefaultMaterial: {fileID: 0}
  m_BounceThreshold: 2
  m_SleepThreshold: 0.005
  m_DefaultContactOffset: 0.01
  m_DefaultSolverIterations: 6
  m_DefaultSolverVelocityIterations: 1
  m_QueriesHitBackfaces: 0
  m_QueriesHitTriggers: 1
  m_EnableAdaptiveForce: 0
  m_ClothInterCollisionDistance: 0
  m_ClothInterCollisionStiffness: 0
  m_ContactsGeneration: 1
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  m_AutoSimulation: 1
  m_AutoSyncTransforms: 0
  m_ReuseCollisionCallbacks: 1
  m_ClothInterCollisionSettingsToggle: 0
  m_ContactPairsMode: 0
  m_BroadphaseType: 0
  m_WorldBounds:
    m_Center: {x: 0, y: 0, z: 0}
    m_Extent: {x: 250, y: 250, z: 250}
  m_WorldSubdivisions: 8



================================================
FILE: src/ZString.Unity/ProjectSettings/EditorBuildSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1045 &1
EditorBuildSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Scenes:
  - enabled: 1
    path: Assets/Scenes/SampleScene.unity
    guid: 2cda990e2423bbf4892e6590ba056729
  m_configObjects: {}



================================================
FILE: src/ZString.Unity/ProjectSettings/EditorSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!159 &1
EditorSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 7
  m_ExternalVersionControlSupport: Visible Meta Files
  m_SerializationMode: 2
  m_LineEndingsForNewScripts: 2
  m_DefaultBehaviorMode: 1
  m_SpritePackerMode: 4
  m_SpritePackerPaddingPower: 1
  m_EtcTextureCompressorBehavior: 1
  m_EtcTextureFastCompressor: 1
  m_EtcTextureNormalCompressor: 2
  m_EtcTextureBestCompressor: 4
  m_ProjectGenerationIncludedExtensions: txt;xml;fnt;cd
  m_ProjectGenerationRootNamespace: 
  m_UserGeneratedProjectSuffix: 
  m_CollabEditorSettings:
    inProgressEnabled: 1



================================================
FILE: src/ZString.Unity/ProjectSettings/GraphicsSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!30 &1
GraphicsSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 12
  m_Deferred:
    m_Mode: 1
    m_Shader: {fileID: 69, guid: 0000000000000000f000000000000000, type: 0}
  m_DeferredReflections:
    m_Mode: 1
    m_Shader: {fileID: 74, guid: 0000000000000000f000000000000000, type: 0}
  m_ScreenSpaceShadows:
    m_Mode: 1
    m_Shader: {fileID: 64, guid: 0000000000000000f000000000000000, type: 0}
  m_LegacyDeferred:
    m_Mode: 1
    m_Shader: {fileID: 63, guid: 0000000000000000f000000000000000, type: 0}
  m_DepthNormals:
    m_Mode: 1
    m_Shader: {fileID: 62, guid: 0000000000000000f000000000000000, type: 0}
  m_MotionVectors:
    m_Mode: 1
    m_Shader: {fileID: 75, guid: 0000000000000000f000000000000000, type: 0}
  m_LightHalo:
    m_Mode: 1
    m_Shader: {fileID: 105, guid: 0000000000000000f000000000000000, type: 0}
  m_LensFlare:
    m_Mode: 1
    m_Shader: {fileID: 102, guid: 0000000000000000f000000000000000, type: 0}
  m_AlwaysIncludedShaders:
  - {fileID: 10753, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10770, guid: 0000000000000000f000000000000000, type: 0}
  m_PreloadedShaders: []
  m_SpritesDefaultMaterial: {fileID: 10754, guid: 0000000000000000f000000000000000,
    type: 0}
  m_CustomRenderPipeline: {fileID: 0}
  m_TransparencySortMode: 0
  m_TransparencySortAxis: {x: 0, y: 0, z: 1}
  m_DefaultRenderingPath: 1
  m_DefaultMobileRenderingPath: 1
  m_TierSettings: []
  m_LightmapStripping: 0
  m_FogStripping: 0
  m_InstancingStripping: 0
  m_LightmapKeepPlain: 1
  m_LightmapKeepDirCombined: 1
  m_LightmapKeepDynamicPlain: 1
  m_LightmapKeepDynamicDirCombined: 1
  m_LightmapKeepShadowMask: 1
  m_LightmapKeepSubtractive: 1
  m_FogKeepLinear: 1
  m_FogKeepExp: 1
  m_FogKeepExp2: 1
  m_AlbedoSwatchInfos: []
  m_LightsUseLinearIntensity: 0
  m_LightsUseColorTemperature: 0



================================================
FILE: src/ZString.Unity/ProjectSettings/InputManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!13 &1
InputManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Axes:
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: a
    altPositiveButton: d
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: s
    altPositiveButton: w
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: mouse 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: mouse 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: mouse 2
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: space
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse X
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse Y
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse ScrollWheel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 2
    joyNum: 0
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 0
    type: 2
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 1
    type: 2
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 0
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 1
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 2
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 3
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: enter
    altNegativeButton: 
    altPositiveButton: space
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Cancel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: escape
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0



================================================
FILE: src/ZString.Unity/ProjectSettings/MemorySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!387306366 &1
MemorySettings:
  m_ObjectHideFlags: 0
  m_EditorMemorySettings:
    m_MainAllocatorBlockSize: -1
    m_ThreadAllocatorBlockSize: -1
    m_MainGfxBlockSize: -1
    m_ThreadGfxBlockSize: -1
    m_CacheBlockSize: -1
    m_TypetreeBlockSize: -1
    m_ProfilerBlockSize: -1
    m_ProfilerEditorBlockSize: -1
    m_BucketAllocatorGranularity: -1
    m_BucketAllocatorBucketsCount: -1
    m_BucketAllocatorBlockSize: -1
    m_BucketAllocatorBlockCount: -1
    m_ProfilerBucketAllocatorGranularity: -1
    m_ProfilerBucketAllocatorBucketsCount: -1
    m_ProfilerBucketAllocatorBlockSize: -1
    m_ProfilerBucketAllocatorBlockCount: -1
    m_TempAllocatorSizeMain: -1
    m_JobTempAllocatorBlockSize: -1
    m_BackgroundJobTempAllocatorBlockSize: -1
    m_JobTempAllocatorReducedBlockSize: -1
    m_TempAllocatorSizeGIBakingWorker: -1
    m_TempAllocatorSizeNavMeshWorker: -1
    m_TempAllocatorSizeAudioWorker: -1
    m_TempAllocatorSizeCloudWorker: -1
    m_TempAllocatorSizeGfx: -1
    m_TempAllocatorSizeJobWorker: -1
    m_TempAllocatorSizeBackgroundWorker: -1
    m_TempAllocatorSizePreloadManager: -1
  m_PlatformMemorySettings: {}



================================================
FILE: src/ZString.Unity/ProjectSettings/NavMeshAreas.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!126 &1
NavMeshProjectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  areas:
  - name: Walkable
    cost: 1
  - name: Not Walkable
    cost: 1
  - name: Jump
    cost: 2
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  - name: 
    cost: 1
  m_LastAgentTypeID: -887442657
  m_Settings:
  - serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.75
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_SettingNames:
  - Humanoid



================================================
FILE: src/ZString.Unity/ProjectSettings/NetworkManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!149 &1
NetworkManager:
  m_ObjectHideFlags: 0
  m_DebugLevel: 0
  m_Sendrate: 15
  m_AssetToPrefab: {}



================================================
FILE: src/ZString.Unity/ProjectSettings/PackageManagerSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 61
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 13964, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_EnablePreReleasePackages: 0
  m_EnablePackageDependencies: 0
  m_AdvancedSettingsExpanded: 1
  m_ScopedRegistriesSettingsExpanded: 1
  m_SeeAllPackageVersions: 0
  oneTimeWarningShown: 0
  m_Registries:
  - m_Id: main
    m_Name: 
    m_Url: https://packages.unity.com
    m_Scopes: []
    m_IsDefault: 1
    m_Capabilities: 7
  m_UserSelectedRegistryName: 
  m_UserAddingNewScopedRegistry: 0
  m_RegistryInfoDraft:
    m_Modified: 0
    m_ErrorMessage: 
    m_UserModificationsInstanceId: -832
    m_OriginalInstanceId: -834
  m_LoadAssets: 0



================================================
FILE: src/ZString.Unity/ProjectSettings/Physics2DSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!19 &1
Physics2DSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 4
  m_Gravity: {x: 0, y: -9.81}
  m_DefaultMaterial: {fileID: 0}
  m_VelocityIterations: 8
  m_PositionIterations: 3
  m_VelocityThreshold: 1
  m_MaxLinearCorrection: 0.2
  m_MaxAngularCorrection: 8
  m_MaxTranslationSpeed: 100
  m_MaxRotationSpeed: 360
  m_BaumgarteScale: 0.2
  m_BaumgarteTimeOfImpactScale: 0.75
  m_TimeToSleep: 0.5
  m_LinearSleepTolerance: 0.01
  m_AngularSleepTolerance: 2
  m_DefaultContactOffset: 0.01
  m_JobOptions:
    serializedVersion: 2
    useMultithreading: 0
    useConsistencySorting: 0
    m_InterpolationPosesPerJob: 100
    m_NewContactsPerJob: 30
    m_CollideContactsPerJob: 100
    m_ClearFlagsPerJob: 200
    m_ClearBodyForcesPerJob: 200
    m_SyncDiscreteFixturesPerJob: 50
    m_SyncContinuousFixturesPerJob: 50
    m_FindNearestContactsPerJob: 100
    m_UpdateTriggerContactsPerJob: 100
    m_IslandSolverCostThreshold: 100
    m_IslandSolverBodyCostScale: 1
    m_IslandSolverContactCostScale: 10
    m_IslandSolverJointCostScale: 10
    m_IslandSolverBodiesPerJob: 50
    m_IslandSolverContactsPerJob: 50
  m_AutoSimulation: 1
  m_QueriesHitTriggers: 1
  m_QueriesStartInColliders: 1
  m_CallbacksOnDisable: 1
  m_ReuseCollisionCallbacks: 0
  m_AutoSyncTransforms: 0
  m_AlwaysShowColliders: 0
  m_ShowColliderSleep: 1
  m_ShowColliderContacts: 0
  m_ShowColliderAABB: 0
  m_ContactArrowScale: 0.2
  m_ColliderAwakeColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.7529412}
  m_ColliderAsleepColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.36078432}
  m_ColliderContactColor: {r: 1, g: 0, b: 1, a: 0.6862745}
  m_ColliderAABBColor: {r: 1, g: 1, b: 0, a: 0.2509804}
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff



================================================
FILE: src/ZString.Unity/ProjectSettings/PresetManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1386491679 &1
PresetManager:
  m_ObjectHideFlags: 0
  m_DefaultList: []



================================================
FILE: src/ZString.Unity/ProjectSettings/ProjectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 17
  productGUID: 8c4adbd344401cd4ab84729f6d4f5fb1
  AndroidProfiler: 0
  AndroidFilterTouchesWhenObscured: 0
  AndroidEnableSustainedPerformanceMode: 0
  defaultScreenOrientation: 4
  targetDevice: 2
  useOnDemandResources: 0
  accelerometerFrequency: 60
  companyName: DefaultCompany
  productName: UnityTestTest
  defaultCursor: {fileID: 0}
  cursorHotspot: {x: 0, y: 0}
  m_SplashScreenBackgroundColor: {r: 0.13725491, g: 0.12156863, b: 0.1254902, a: 1}
  m_ShowUnitySplashScreen: 1
  m_ShowUnitySplashLogo: 1
  m_SplashScreenOverlayOpacity: 1
  m_SplashScreenAnimation: 1
  m_SplashScreenLogoStyle: 1
  m_SplashScreenDrawMode: 0
  m_SplashScreenBackgroundAnimationZoom: 1
  m_SplashScreenLogoAnimationZoom: 1
  m_SplashScreenBackgroundLandscapeAspect: 1
  m_SplashScreenBackgroundPortraitAspect: 1
  m_SplashScreenBackgroundLandscapeUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenBackgroundPortraitUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenLogos: []
  m_VirtualRealitySplashScreen: {fileID: 0}
  m_HolographicTrackingLossScreen: {fileID: 0}
  defaultScreenWidth: 1024
  defaultScreenHeight: 768
  defaultScreenWidthWeb: 960
  defaultScreenHeightWeb: 600
  m_StereoRenderingPath: 0
  m_ActiveColorSpace: 0
  m_MTRendering: 1
  m_StackTraceTypes: 010000000100000001000000010000000100000001000000
  iosShowActivityIndicatorOnLoading: -1
  androidShowActivityIndicatorOnLoading: -1
  iosAppInBackgroundBehavior: 0
  displayResolutionDialog: 1
  iosAllowHTTPDownload: 1
  allowedAutorotateToPortrait: 1
  allowedAutorotateToPortraitUpsideDown: 1
  allowedAutorotateToLandscapeRight: 1
  allowedAutorotateToLandscapeLeft: 1
  useOSAutorotation: 1
  use32BitDisplayBuffer: 1
  preserveFramebufferAlpha: 0
  disableDepthAndStencilBuffers: 0
  androidStartInFullscreen: 1
  androidRenderOutsideSafeArea: 1
  androidUseSwappy: 0
  androidBlitType: 0
  defaultIsNativeResolution: 1
  macRetinaSupport: 1
  runInBackground: 1
  captureSingleScreen: 0
  muteOtherAudioSources: 0
  Prepare IOS For Recording: 0
  Force IOS Speakers When Recording: 0
  deferSystemGesturesMode: 0
  hideHomeButton: 0
  submitAnalytics: 1
  usePlayerLog: 1
  bakeCollisionMeshes: 0
  forceSingleInstance: 0
  resizableWindow: 0
  useMacAppStoreValidation: 0
  macAppStoreCategory: public.app-category.games
  gpuSkinning: 0
  graphicsJobs: 0
  xboxPIXTextureCapture: 0
  xboxEnableAvatar: 0
  xboxEnableKinect: 0
  xboxEnableKinectAutoTracking: 0
  xboxEnableFitness: 0
  visibleInBackground: 1
  allowFullscreenSwitch: 1
  graphicsJobMode: 0
  fullscreenMode: 1
  xboxSpeechDB: 0
  xboxEnableHeadOrientation: 0
  xboxEnableGuest: 0
  xboxEnablePIXSampling: 0
  metalFramebufferOnly: 0
  xboxOneResolution: 0
  xboxOneSResolution: 0
  xboxOneXResolution: 3
  xboxOneMonoLoggingLevel: 0
  xboxOneLoggingLevel: 1
  xboxOneDisableEsram: 0
  xboxOnePresentImmediateThreshold: 0
  switchQueueCommandMemory: 0
  switchQueueControlMemory: 16384
  switchQueueComputeMemory: 262144
  switchNVNShaderPoolsGranularity: 33554432
  switchNVNDefaultPoolsGranularity: 16777216
  switchNVNOtherPoolsGranularity: 16777216
  vulkanEnableSetSRGBWrite: 0
  m_SupportedAspectRatios:
    4:3: 1
    5:4: 1
    16:10: 1
    16:9: 1
    Others: 1
  bundleVersion: 0.1
  preloadedAssets: []
  metroInputSource: 0
  wsaTransparentSwapchain: 0
  m_HolographicPauseOnTrackingLoss: 1
  xboxOneDisableKinectGpuReservation: 1
  xboxOneEnable7thCore: 1
  vrSettings:
    cardboard:
      depthFormat: 0
      enableTransitionView: 0
    daydream:
      depthFormat: 0
      useSustainedPerformanceMode: 0
      enableVideoLayer: 0
      useProtectedVideoMemory: 0
      minimumSupportedHeadTracking: 0
      maximumSupportedHeadTracking: 1
    hololens:
      depthFormat: 1
      depthBufferSharingEnabled: 1
    lumin:
      depthFormat: 0
      frameTiming: 2
      enableGLCache: 0
      glCacheMaxBlobSize: 524288
      glCacheMaxFileSize: 8388608
    oculus:
      sharedDepthBuffer: 1
      dashSupport: 1
      lowOverheadMode: 0
    enable360StereoCapture: 0
  isWsaHolographicRemotingEnabled: 0
  protectGraphicsMemory: 0
  enableFrameTimingStats: 0
  useHDRDisplay: 0
  m_ColorGamuts: 00000000
  targetPixelDensity: 30
  resolutionScalingMode: 0
  androidSupportedAspectRatio: 1
  androidMaxAspectRatio: 2.1
  applicationIdentifier:
    Standalone: com.Company.ProductName
  buildNumber: {}
  AndroidBundleVersionCode: 1
  AndroidMinSdkVersion: 16
  AndroidTargetSdkVersion: 0
  AndroidPreferredInstallLocation: 1
  aotOptions: 
  stripEngineCode: 1
  iPhoneStrippingLevel: 0
  iPhoneScriptCallOptimization: 0
  ForceInternetPermission: 0
  ForceSDCardPermission: 0
  CreateWallpaper: 0
  APKExpansionFiles: 0
  keepLoadedShadersAlive: 0
  StripUnusedMeshComponents: 1
  VertexChannelCompressionMask: 4054
  iPhoneSdkVersion: 988
  iOSTargetOSVersionString: 9.0
  tvOSSdkVersion: 0
  tvOSRequireExtendedGameController: 0
  tvOSTargetOSVersionString: 9.0
  uIPrerenderedIcon: 0
  uIRequiresPersistentWiFi: 0
  uIRequiresFullScreen: 1
  uIStatusBarHidden: 1
  uIExitOnSuspend: 0
  uIStatusBarStyle: 0
  iPhoneSplashScreen: {fileID: 0}
  iPhoneHighResSplashScreen: {fileID: 0}
  iPhoneTallHighResSplashScreen: {fileID: 0}
  iPhone47inSplashScreen: {fileID: 0}
  iPhone55inPortraitSplashScreen: {fileID: 0}
  iPhone55inLandscapeSplashScreen: {fileID: 0}
  iPhone58inPortraitSplashScreen: {fileID: 0}
  iPhone58inLandscapeSplashScreen: {fileID: 0}
  iPadPortraitSplashScreen: {fileID: 0}
  iPadHighResPortraitSplashScreen: {fileID: 0}
  iPadLandscapeSplashScreen: {fileID: 0}
  iPadHighResLandscapeSplashScreen: {fileID: 0}
  iPhone65inPortraitSplashScreen: {fileID: 0}
  iPhone65inLandscapeSplashScreen: {fileID: 0}
  iPhone61inPortraitSplashScreen: {fileID: 0}
  iPhone61inLandscapeSplashScreen: {fileID: 0}
  appleTVSplashScreen: {fileID: 0}
  appleTVSplashScreen2x: {fileID: 0}
  tvOSSmallIconLayers: []
  tvOSSmallIconLayers2x: []
  tvOSLargeIconLayers: []
  tvOSLargeIconLayers2x: []
  tvOSTopShelfImageLayers: []
  tvOSTopShelfImageLayers2x: []
  tvOSTopShelfImageWideLayers: []
  tvOSTopShelfImageWideLayers2x: []
  iOSLaunchScreenType: 0
  iOSLaunchScreenPortrait: {fileID: 0}
  iOSLaunchScreenLandscape: {fileID: 0}
  iOSLaunchScreenBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreenFillPct: 100
  iOSLaunchScreenSize: 100
  iOSLaunchScreenCustomXibPath: 
  iOSLaunchScreeniPadType: 0
  iOSLaunchScreeniPadImage: {fileID: 0}
  iOSLaunchScreeniPadBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreeniPadFillPct: 100
  iOSLaunchScreeniPadSize: 100
  iOSLaunchScreeniPadCustomXibPath: 
  iOSUseLaunchScreenStoryboard: 0
  iOSLaunchScreenCustomStoryboardPath: 
  iOSDeviceRequirements: []
  iOSURLSchemes: []
  iOSBackgroundModes: 0
  iOSMetalForceHardShadows: 0
  metalEditorSupport: 1
  metalAPIValidation: 1
  iOSRenderExtraFrameOnPause: 0
  appleDeveloperTeamID: 
  iOSManualSigningProvisioningProfileID: 
  tvOSManualSigningProvisioningProfileID: 
  iOSManualSigningProvisioningProfileType: 0
  tvOSManualSigningProvisioningProfileType: 0
  appleEnableAutomaticSigning: 0
  iOSRequireARKit: 0
  iOSAutomaticallyDetectAndAddCapabilities: 1
  appleEnableProMotion: 0
  clonedFromGUID: 5f34be1353de5cf4398729fda238591b
  templatePackageId: com.unity.template.2d@3.1.0
  templateDefaultScene: Assets/Scenes/SampleScene.unity
  AndroidTargetArchitectures: 1
  AndroidSplashScreenScale: 0
  androidSplashScreen: {fileID: 0}
  AndroidKeystoreName: '{inproject}: '
  AndroidKeyaliasName: 
  AndroidBuildApkPerCpuArchitecture: 0
  AndroidTVCompatibility: 0
  AndroidIsGame: 1
  AndroidEnableTango: 0
  androidEnableBanner: 1
  androidUseLowAccuracyLocation: 0
  androidUseCustomKeystore: 0
  m_AndroidBanners:
  - width: 320
    height: 180
    banner: {fileID: 0}
  androidGamepadSupportLevel: 0
  AndroidValidateAppBundleSize: 1
  AndroidAppBundleSizeToValidate: 100
  resolutionDialogBanner: {fileID: 0}
  m_BuildTargetIcons: []
  m_BuildTargetPlatformIcons: []
  m_BuildTargetBatching: []
  m_BuildTargetGraphicsAPIs:
  - m_BuildTarget: AndroidPlayer
    m_APIs: 150000000b000000
    m_Automatic: 0
  m_BuildTargetVRSettings: []
  m_BuildTargetEnableVuforiaSettings: []
  openGLRequireES31: 0
  openGLRequireES31AEP: 0
  openGLRequireES32: 0
  m_TemplateCustomTags: {}
  mobileMTRendering:
    Android: 1
    iPhone: 1
    tvOS: 1
  m_BuildTargetGroupLightmapEncodingQuality: []
  m_BuildTargetGroupLightmapSettings: []
  playModeTestRunnerEnabled: 0
  runPlayModeTestAsEditModeTest: 0
  actionOnDotNetUnhandledException: 1
  enableInternalProfiler: 0
  logObjCUncaughtExceptions: 1
  enableCrashReportAPI: 0
  cameraUsageDescription: 
  locationUsageDescription: 
  microphoneUsageDescription: 
  switchNetLibKey: 
  switchSocketMemoryPoolSize: 6144
  switchSocketAllocatorPoolSize: 128
  switchSocketConcurrencyLimit: 14
  switchScreenResolutionBehavior: 2
  switchUseCPUProfiler: 0
  switchApplicationID: 0x01004b9000490000
  switchNSODependencies: 
  switchTitleNames_0: 
  switchTitleNames_1: 
  switchTitleNames_2: 
  switchTitleNames_3: 
  switchTitleNames_4: 
  switchTitleNames_5: 
  switchTitleNames_6: 
  switchTitleNames_7: 
  switchTitleNames_8: 
  switchTitleNames_9: 
  switchTitleNames_10: 
  switchTitleNames_11: 
  switchTitleNames_12: 
  switchTitleNames_13: 
  switchTitleNames_14: 
  switchPublisherNames_0: 
  switchPublisherNames_1: 
  switchPublisherNames_2: 
  switchPublisherNames_3: 
  switchPublisherNames_4: 
  switchPublisherNames_5: 
  switchPublisherNames_6: 
  switchPublisherNames_7: 
  switchPublisherNames_8: 
  switchPublisherNames_9: 
  switchPublisherNames_10: 
  switchPublisherNames_11: 
  switchPublisherNames_12: 
  switchPublisherNames_13: 
  switchPublisherNames_14: 
  switchIcons_0: {fileID: 0}
  switchIcons_1: {fileID: 0}
  switchIcons_2: {fileID: 0}
  switchIcons_3: {fileID: 0}
  switchIcons_4: {fileID: 0}
  switchIcons_5: {fileID: 0}
  switchIcons_6: {fileID: 0}
  switchIcons_7: {fileID: 0}
  switchIcons_8: {fileID: 0}
  switchIcons_9: {fileID: 0}
  switchIcons_10: {fileID: 0}
  switchIcons_11: {fileID: 0}
  switchIcons_12: {fileID: 0}
  switchIcons_13: {fileID: 0}
  switchIcons_14: {fileID: 0}
  switchSmallIcons_0: {fileID: 0}
  switchSmallIcons_1: {fileID: 0}
  switchSmallIcons_2: {fileID: 0}
  switchSmallIcons_3: {fileID: 0}
  switchSmallIcons_4: {fileID: 0}
  switchSmallIcons_5: {fileID: 0}
  switchSmallIcons_6: {fileID: 0}
  switchSmallIcons_7: {fileID: 0}
  switchSmallIcons_8: {fileID: 0}
  switchSmallIcons_9: {fileID: 0}
  switchSmallIcons_10: {fileID: 0}
  switchSmallIcons_11: {fileID: 0}
  switchSmallIcons_12: {fileID: 0}
  switchSmallIcons_13: {fileID: 0}
  switchSmallIcons_14: {fileID: 0}
  switchManualHTML: 
  switchAccessibleURLs: 
  switchLegalInformation: 
  switchMainThreadStackSize: 1048576
  switchPresenceGroupId: 
  switchLogoHandling: 0
  switchReleaseVersion: 0
  switchDisplayVersion: 1.0.0
  switchStartupUserAccount: 0
  switchTouchScreenUsage: 0
  switchSupportedLanguagesMask: 0
  switchLogoType: 0
  switchApplicationErrorCodeCategory: 
  switchUserAccountSaveDataSize: 0
  switchUserAccountSaveDataJournalSize: 0
  switchApplicationAttribute: 0
  switchCardSpecSize: -1
  switchCardSpecClock: -1
  switchRatingsMask: 0
  switchRatingsInt_0: 0
  switchRatingsInt_1: 0
  switchRatingsInt_2: 0
  switchRatingsInt_3: 0
  switchRatingsInt_4: 0
  switchRatingsInt_5: 0
  switchRatingsInt_6: 0
  switchRatingsInt_7: 0
  switchRatingsInt_8: 0
  switchRatingsInt_9: 0
  switchRatingsInt_10: 0
  switchRatingsInt_11: 0
  switchLocalCommunicationIds_0: 
  switchLocalCommunicationIds_1: 
  switchLocalCommunicationIds_2: 
  switchLocalCommunicationIds_3: 
  switchLocalCommunicationIds_4: 
  switchLocalCommunicationIds_5: 
  switchLocalCommunicationIds_6: 
  switchLocalCommunicationIds_7: 
  switchParentalControl: 0
  switchAllowsScreenshot: 1
  switchAllowsVideoCapturing: 1
  switchAllowsRuntimeAddOnContentInstall: 0
  switchDataLossConfirmation: 0
  switchUserAccountLockEnabled: 0
  switchSystemResourceMemory: 16777216
  switchSupportedNpadStyles: 3
  switchNativeFsCacheSize: 32
  switchIsHoldTypeHorizontal: 0
  switchSupportedNpadCount: 8
  switchSocketConfigEnabled: 0
  switchTcpInitialSendBufferSize: 32
  switchTcpInitialReceiveBufferSize: 64
  switchTcpAutoSendBufferSizeMax: 256
  switchTcpAutoReceiveBufferSizeMax: 256
  switchUdpSendBufferSize: 9
  switchUdpReceiveBufferSize: 42
  switchSocketBufferEfficiency: 4
  switchSocketInitializeEnabled: 1
  switchNetworkInterfaceManagerInitializeEnabled: 1
  switchPlayerConnectionEnabled: 1
  ps4NPAgeRating: 12
  ps4NPTitleSecret: 
  ps4NPTrophyPackPath: 
  ps4ParentalLevel: 11
  ps4ContentID: ED1633-NPXX51362_00-0000000000000000
  ps4Category: 0
  ps4MasterVersion: 01.00
  ps4AppVersion: 01.00
  ps4AppType: 0
  ps4ParamSfxPath: 
  ps4VideoOutPixelFormat: 0
  ps4VideoOutInitialWidth: 1920
  ps4VideoOutBaseModeInitialWidth: 1920
  ps4VideoOutReprojectionRate: 60
  ps4PronunciationXMLPath: 
  ps4PronunciationSIGPath: 
  ps4BackgroundImagePath: 
  ps4StartupImagePath: 
  ps4StartupImagesFolder: 
  ps4IconImagesFolder: 
  ps4SaveDataImagePath: 
  ps4SdkOverride: 
  ps4BGMPath: 
  ps4ShareFilePath: 
  ps4ShareOverlayImagePath: 
  ps4PrivacyGuardImagePath: 
  ps4NPtitleDatPath: 
  ps4RemotePlayKeyAssignment: -1
  ps4RemotePlayKeyMappingDir: 
  ps4PlayTogetherPlayerCount: 0
  ps4EnterButtonAssignment: 1
  ps4ApplicationParam1: 0
  ps4ApplicationParam2: 0
  ps4ApplicationParam3: 0
  ps4ApplicationParam4: 0
  ps4DownloadDataSize: 0
  ps4GarlicHeapSize: 2048
  ps4ProGarlicHeapSize: 2560
  playerPrefsMaxSize: 32768
  ps4Passcode: frAQBc8Wsa1xVPfvJcrgRYwTiizs2trQ
  ps4pnSessions: 1
  ps4pnPresence: 1
  ps4pnFriends: 1
  ps4pnGameCustomData: 1
  playerPrefsSupport: 0
  enableApplicationExit: 0
  resetTempFolder: 1
  restrictedAudioUsageRights: 0
  ps4UseResolutionFallback: 0
  ps4ReprojectionSupport: 0
  ps4UseAudio3dBackend: 0
  ps4SocialScreenEnabled: 0
  ps4ScriptOptimizationLevel: 0
  ps4Audio3dVirtualSpeakerCount: 14
  ps4attribCpuUsage: 0
  ps4PatchPkgPath: 
  ps4PatchLatestPkgPath: 
  ps4PatchChangeinfoPath: 
  ps4PatchDayOne: 0
  ps4attribUserManagement: 0
  ps4attribMoveSupport: 0
  ps4attrib3DSupport: 0
  ps4attribShareSupport: 0
  ps4attribExclusiveVR: 0
  ps4disableAutoHideSplash: 0
  ps4videoRecordingFeaturesUsed: 0
  ps4contentSearchFeaturesUsed: 0
  ps4attribEyeToEyeDistanceSettingVR: 0
  ps4IncludedModules: []
  monoEnv: 
  splashScreenBackgroundSourceLandscape: {fileID: 0}
  splashScreenBackgroundSourcePortrait: {fileID: 0}
  blurSplashScreenBackground: 1
  spritePackerPolicy: 
  webGLMemorySize: 16
  webGLExceptionSupport: 1
  webGLNameFilesAsHashes: 0
  webGLDataCaching: 1
  webGLDebugSymbols: 0
  webGLEmscriptenArgs: 
  webGLModulesDirectory: 
  webGLTemplate: APPLICATION:Default
  webGLAnalyzeBuildSize: 0
  webGLUseEmbeddedResources: 0
  webGLCompressionFormat: 1
  webGLLinkerTarget: 1
  webGLThreadsSupport: 0
  webGLWasmStreaming: 0
  scriptingDefineSymbols: {}
  platformArchitecture: {}
  scriptingBackend: {}
  il2cppCompilerConfiguration: {}
  managedStrippingLevel: {}
  incrementalIl2cppBuild: {}
  allowUnsafeCode: 0
  additionalIl2CppArgs: 
  scriptingRuntimeVersion: 1
  gcIncremental: 0
  gcWBarrierValidation: 0
  apiCompatibilityLevelPerPlatform: {}
  m_RenderingPath: 1
  m_MobileRenderingPath: 1
  metroPackageName: Template_2D
  metroPackageVersion: 
  metroCertificatePath: 
  metroCertificatePassword: 
  metroCertificateSubject: 
  metroCertificateIssuer: 
  metroCertificateNotAfter: 0000000000000000
  metroApplicationDescription: Template_2D
  wsaImages: {}
  metroTileShortName: 
  metroTileShowName: 0
  metroMediumTileShowName: 0
  metroLargeTileShowName: 0
  metroWideTileShowName: 0
  metroSupportStreamingInstall: 0
  metroLastRequiredScene: 0
  metroDefaultTileSize: 1
  metroTileForegroundText: 2
  metroTileBackgroundColor: {r: 0.13333334, g: 0.17254902, b: 0.21568628, a: 0}
  metroSplashScreenBackgroundColor: {r: 0.12941177, g: 0.17254902, b: 0.21568628,
    a: 1}
  metroSplashScreenUseBackgroundColor: 0
  platformCapabilities: {}
  metroTargetDeviceFamilies: {}
  metroFTAName: 
  metroFTAFileTypes: []
  metroProtocolName: 
  XboxOneProductId: 
  XboxOneUpdateKey: 
  XboxOneSandboxId: 
  XboxOneContentId: 
  XboxOneTitleId: 
  XboxOneSCId: 
  XboxOneGameOsOverridePath: 
  XboxOnePackagingOverridePath: 
  XboxOneAppManifestOverridePath: 
  XboxOneVersion: 1.0.0.0
  XboxOnePackageEncryption: 0
  XboxOnePackageUpdateGranularity: 2
  XboxOneDescription: 
  XboxOneLanguage:
  - enus
  XboxOneCapability: []
  XboxOneGameRating: {}
  XboxOneIsContentPackage: 0
  XboxOneEnableGPUVariability: 1
  XboxOneSockets: {}
  XboxOneSplashScreen: {fileID: 0}
  XboxOneAllowedProductIds: []
  XboxOnePersistentLocalStorageSize: 0
  XboxOneXTitleMemory: 8
  XboxOneOverrideIdentityName: 
  vrEditorSettings:
    daydream:
      daydreamIconForeground: {fileID: 0}
      daydreamIconBackground: {fileID: 0}
  cloudServicesEnabled:
    UNet: 1
  luminIcon:
    m_Name: 
    m_ModelFolderPath: 
    m_PortalFolderPath: 
  luminCert:
    m_CertPath: 
    m_SignPackage: 1
  luminIsChannelApp: 0
  luminVersion:
    m_VersionCode: 1
    m_VersionName: 
  facebookSdkVersion: 7.9.4
  facebookAppId: 
  facebookCookies: 1
  facebookLogging: 1
  facebookStatus: 1
  facebookXfbml: 0
  facebookFrictionlessRequests: 1
  apiCompatibilityLevel: 6
  cloudProjectId: 
  framebufferDepthMemorylessMode: 0
  projectName: 
  organizationId: 
  cloudEnabled: 0
  enableNativePlatformBackendsForNewInputSystem: 0
  disableOldInputManagerSupport: 0
  legacyClampBlendShapeWeights: 1



================================================
FILE: src/ZString.Unity/ProjectSettings/ProjectVersion.txt
================================================
m_EditorVersion: 2021.3.41f1
m_EditorVersionWithRevision: 2021.3.41f1 (6c5a9e20c022)



================================================
FILE: src/ZString.Unity/ProjectSettings/QualitySettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!47 &1
QualitySettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_CurrentQuality: 3
  m_QualitySettings:
  - serializedVersion: 2
    name: Very Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 15
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    blendWeights: 1
    textureQuality: 1
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.3
    maximumLODLevel: 0
    particleRaycastBudget: 4
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    blendWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 0
    lodBias: 0.4
    maximumLODLevel: 0
    particleRaycastBudget: 16
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Medium
    pixelLightCount: 1
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    blendWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 0.7
    maximumLODLevel: 0
    particleRaycastBudget: 64
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: High
    pixelLightCount: 2
    shadows: 0
    shadowResolution: 1
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 40
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    blendWeights: 2
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 1
    maximumLODLevel: 0
    particleRaycastBudget: 256
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Very High
    pixelLightCount: 3
    shadows: 0
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 70
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    blendWeights: 4
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 1.5
    maximumLODLevel: 0
    particleRaycastBudget: 1024
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  - serializedVersion: 2
    name: Ultra
    pixelLightCount: 4
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 4
    shadowDistance: 150
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    blendWeights: 4
    textureQuality: 0
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    vSyncCount: 1
    lodBias: 2
    maximumLODLevel: 0
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    resolutionScalingFixedDPIFactor: 1
    excludedTargetPlatforms: []
  m_PerPlatformDefaultQuality:
    Android: 2
    Nintendo 3DS: 5
    Nintendo Switch: 5
    PS4: 5
    PSM: 5
    PSP2: 2
    Standalone: 5
    Tizen: 2
    WebGL: 3
    WiiU: 5
    Windows Store Apps: 5
    XboxOne: 5
    iPhone: 2
    tvOS: 2



================================================
FILE: src/ZString.Unity/ProjectSettings/TagManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!78 &1
TagManager:
  serializedVersion: 2
  tags: []
  layers:
  - Default
  - TransparentFX
  - Ignore Raycast
  - 
  - Water
  - UI
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  m_SortingLayers:
  - name: Default
    uniqueID: 0
    locked: 0



================================================
FILE: src/ZString.Unity/ProjectSettings/TimeManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!5 &1
TimeManager:
  m_ObjectHideFlags: 0
  Fixed Timestep: 0.02
  Maximum Allowed Timestep: 0.1
  m_TimeScale: 1
  Maximum Particle Timestep: 0.03



================================================
FILE: src/ZString.Unity/ProjectSettings/UnityConnectSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!310 &1
UnityConnectSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 1
  m_Enabled: 0
  m_TestMode: 0
  m_EventOldUrl: https://api.uca.cloud.unity3d.com/v1/events
  m_EventUrl: https://cdp.cloud.unity3d.com/v1/events
  m_ConfigUrl: https://config.uca.cloud.unity3d.com
  m_TestInitMode: 0
  CrashReportingSettings:
    m_EventUrl: https://perf-events.cloud.unity3d.com
    m_Enabled: 0
    m_LogBufferSize: 10
    m_CaptureEditorExceptions: 1
  UnityPurchasingSettings:
    m_Enabled: 0
    m_TestMode: 0
  UnityAnalyticsSettings:
    m_Enabled: 0
    m_TestMode: 0
    m_InitializeOnStartup: 1
  UnityAdsSettings:
    m_Enabled: 0
    m_InitializeOnStartup: 1
    m_TestMode: 0
    m_IosGameId: 
    m_AndroidGameId: 
    m_GameIds: {}
    m_GameId: 
  PerformanceReportingSettings:
    m_Enabled: 0



================================================
FILE: src/ZString.Unity/ProjectSettings/VersionControlSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!890905787 &1
VersionControlSettings:
  m_ObjectHideFlags: 0
  m_Mode: Visible Meta Files
  m_CollabEditorSettings:
    inProgressEnabled: 1



================================================
FILE: src/ZString.Unity/ProjectSettings/VFXManager.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!937362698 &1
VFXManager:
  m_ObjectHideFlags: 0
  m_IndirectShader: {fileID: 0}
  m_RenderPipeSettingsPath: 



================================================
FILE: src/ZString.Unity/ProjectSettings/XRSettings.asset
================================================
{
    "m_SettingKeys": [
        "VR Device Disabled",
        "VR Device User Alert"
    ],
    "m_SettingValues": [
        "False",
        "False"
    ]
}


================================================
FILE: src/ZString.Unity/UserSettings/EditorUserSettings.asset
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!162 &1
EditorUserSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 4
  m_ConfigSettings:
    vcSharedLogLevel:
      value: 0d5e400f0650
      flags: 0
  m_VCAutomaticAdd: 1
  m_VCDebugCom: 0
  m_VCDebugCmd: 0
  m_VCDebugOut: 0
  m_SemanticMergeMode: 2
  m_VCShowFailedCheckout: 1
  m_VCAllowAsyncUpdate: 0
  m_AssetPipelineMode2: 1
  m_CacheServerMode: 0
  m_CacheServers: []



================================================
FILE: src/ZString.Unity/UserSettings/Search.settings
================================================
{}


================================================
FILE: src/ZString.Unity/UserSettings/Layouts/default-2021.dwlt
================================================
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12004, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_PixelRect:
    serializedVersion: 2
    x: 8
    y: 51
    width: 2544
    height: 1333
  m_ShowMode: 4
  m_Title: Scene
  m_RootView: {fileID: 6}
  m_MinSize: {x: 875, y: 300}
  m_MaxSize: {x: 10000, y: 10000}
  m_Maximized: 0
--- !u!114 &2
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12010, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children:
  - {fileID: 9}
  - {fileID: 3}
  m_Position:
    serializedVersion: 2
    x: 0
    y: 30
    width: 2544
    height: 1283
  m_MinSize: {x: 300, y: 200}
  m_MaxSize: {x: 24288, y: 16192}
  vertical: 0
  controlID: 96
--- !u!114 &3
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12006, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 2028
    y: 0
    width: 516
    height: 1283
  m_MinSize: {x: 276, y: 71}
  m_MaxSize: {x: 4001, y: 4021}
  m_ActualView: {fileID: 14}
  m_Panes:
  - {fileID: 14}
  m_Selected: 0
  m_LastSelected: 0
--- !u!114 &4
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12006, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 0
    y: 0
    width: 502
    height: 776
  m_MinSize: {x: 201, y: 221}
  m_MaxSize: {x: 4001, y: 4021}
  m_ActualView: {fileID: 15}
  m_Panes:
  - {fileID: 15}
  m_Selected: 0
  m_LastSelected: 0
--- !u!114 &5
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12006, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 0
    y: 776
    width: 2028
    height: 507
  m_MinSize: {x: 231, y: 271}
  m_MaxSize: {x: 10001, y: 10021}
  m_ActualView: {fileID: 13}
  m_Panes:
  - {fileID: 13}
  - {fileID: 18}
  m_Selected: 0
  m_LastSelected: 0
--- !u!114 &6
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12008, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children:
  - {fileID: 7}
  - {fileID: 2}
  - {fileID: 8}
  m_Position:
    serializedVersion: 2
    x: 0
    y: 0
    width: 2544
    height: 1333
  m_MinSize: {x: 875, y: 300}
  m_MaxSize: {x: 10000, y: 10000}
  m_UseTopView: 1
  m_TopViewHeight: 30
  m_UseBottomView: 1
  m_BottomViewHeight: 20
--- !u!114 &7
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12011, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 0
    y: 0
    width: 2544
    height: 30
  m_MinSize: {x: 0, y: 0}
  m_MaxSize: {x: 0, y: 0}
  m_LastLoadedLayoutName: 
--- !u!114 &8
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12042, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 0
    y: 1313
    width: 2544
    height: 20
  m_MinSize: {x: 0, y: 0}
  m_MaxSize: {x: 0, y: 0}
--- !u!114 &9
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12010, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children:
  - {fileID: 10}
  - {fileID: 5}
  m_Position:
    serializedVersion: 2
    x: 0
    y: 0
    width: 2028
    height: 1283
  m_MinSize: {x: 200, y: 200}
  m_MaxSize: {x: 16192, y: 16192}
  vertical: 1
  controlID: 101
--- !u!114 &10
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12010, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children:
  - {fileID: 4}
  - {fileID: 11}
  m_Position:
    serializedVersion: 2
    x: 0
    y: 0
    width: 2028
    height: 776
  m_MinSize: {x: 200, y: 100}
  m_MaxSize: {x: 16192, y: 8096}
  vertical: 0
  controlID: 102
--- !u!114 &11
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12006, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Children: []
  m_Position:
    serializedVersion: 2
    x: 502
    y: 0
    width: 1526
    height: 776
  m_MinSize: {x: 202, y: 221}
  m_MaxSize: {x: 4002, y: 4021}
  m_ActualView: {fileID: 16}
  m_Panes:
  - {fileID: 16}
  - {fileID: 17}
  - {fileID: 12}
  m_Selected: 0
  m_LastSelected: 1
--- !u!114 &12
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12111, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 400, y: 100}
  m_MaxSize: {x: 2048, y: 2048}
  m_TitleContent:
    m_Text: Asset Store
    m_Image: {fileID: -8693916549880196297, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 468
    y: 181
    width: 973
    height: 501
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1
--- !u!114 &13
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12014, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 230, y: 250}
  m_MaxSize: {x: 10000, y: 10000}
  m_TitleContent:
    m_Text: Project
    m_Image: {fileID: -5467254957812901981, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 8
    y: 857
    width: 2027
    height: 486
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1
  m_SearchFilter:
    m_NameFilter: 
    m_ClassNames: []
    m_AssetLabels: []
    m_AssetBundleNames: []
    m_ReferencingInstanceIDs: 
    m_SceneHandles: 
    m_ShowAllHits: 0
    m_SkipHidden: 0
    m_SearchArea: 1
    m_Folders:
    - Assets
    m_Globs: []
    m_OriginalText: 
    m_FilterByTypeIntersection: 0
  m_ViewMode: 1
  m_StartGridSize: 64
  m_LastFolders:
  - Assets
  m_LastFoldersGridSize: -1
  m_LastProjectPath: C:\github\cysharp\ZString\src\ZString.Unity
  m_LockTracker:
    m_IsLocked: 0
  m_FolderTreeState:
    scrollPos: {x: 0, y: 0}
    m_SelectedIDs: 02770000
    m_LastClickedID: 30466
    m_ExpandedIDs: 000000000277000000ca9a3bffffff7f
    m_RenameOverlay:
      m_UserAcceptedRename: 0
      m_Name: 
      m_OriginalName: 
      m_EditFieldRect:
        serializedVersion: 2
        x: 0
        y: 0
        width: 0
        height: 0
      m_UserData: 0
      m_IsWaitingForDelay: 0
      m_IsRenaming: 0
      m_OriginalEventType: 11
      m_IsRenamingFilename: 1
      m_ClientGUIView: {fileID: 0}
    m_SearchString: 
    m_CreateAssetUtility:
      m_EndAction: {fileID: 0}
      m_InstanceID: 0
      m_Path: 
      m_Icon: {fileID: 0}
      m_ResourceFile: 
  m_AssetTreeState:
    scrollPos: {x: 0, y: 0}
    m_SelectedIDs: 
    m_LastClickedID: 0
    m_ExpandedIDs: 
    m_RenameOverlay:
      m_UserAcceptedRename: 0
      m_Name: 
      m_OriginalName: 
      m_EditFieldRect:
        serializedVersion: 2
        x: 0
        y: 0
        width: 0
        height: 0
      m_UserData: 0
      m_IsWaitingForDelay: 0
      m_IsRenaming: 0
      m_OriginalEventType: 11
      m_IsRenamingFilename: 1
      m_ClientGUIView: {fileID: 0}
    m_SearchString: 
    m_CreateAssetUtility:
      m_EndAction: {fileID: 0}
      m_InstanceID: 0
      m_Path: 
      m_Icon: {fileID: 0}
      m_ResourceFile: 
  m_ListAreaState:
    m_SelectedInstanceIDs: 
    m_LastClickedInstanceID: 0
    m_HadKeyboardFocusLastEvent: 0
    m_ExpandedInstanceIDs: c6230000
    m_RenameOverlay:
      m_UserAcceptedRename: 0
      m_Name: 
      m_OriginalName: 
      m_EditFieldRect:
        serializedVersion: 2
        x: 0
        y: 0
        width: 0
        height: 0
      m_UserData: 0
      m_IsWaitingForDelay: 0
      m_IsRenaming: 0
      m_OriginalEventType: 11
      m_IsRenamingFilename: 1
      m_ClientGUIView: {fileID: 0}
    m_CreateAssetUtility:
      m_EndAction: {fileID: 0}
      m_InstanceID: 0
      m_Path: 
      m_Icon: {fileID: 0}
      m_ResourceFile: 
    m_NewAssetIndexInList: -1
    m_ScrollPosition: {x: 0, y: 0}
    m_GridSize: 64
  m_SkipHiddenPackages: 0
  m_DirectoriesAreaWidth: 115
--- !u!114 &14
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12019, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 275, y: 50}
  m_MaxSize: {x: 4000, y: 4000}
  m_TitleContent:
    m_Text: Inspector
    m_Image: {fileID: -2667387946076563598, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 2036
    y: 81
    width: 515
    height: 1262
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1
  m_ObjectsLockedBeforeSerialization: []
  m_InstanceIDsLockedBeforeSerialization: 
  m_PreviewResizer:
    m_CachedPref: 160
    m_ControlHash: -371814159
    m_PrefName: Preview_InspectorPreview
  m_LastInspectedObjectInstanceID: -1
  m_LastVerticalScrollValue: 0
  m_GlobalObjectId: 
  m_InspectorMode: 0
  m_LockTracker:
    m_IsLocked: 0
  m_PreviewWindow: {fileID: 0}
--- !u!114 &15
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12061, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 200, y: 200}
  m_MaxSize: {x: 4000, y: 4000}
  m_TitleContent:
    m_Text: Hierarchy
    m_Image: {fileID: 7966133145522015247, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 8
    y: 81
    width: 501
    height: 755
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1
  m_SceneHierarchy:
    m_TreeViewState:
      scrollPos: {x: 0, y: 0}
      m_SelectedIDs: 
      m_LastClickedID: 0
      m_ExpandedIDs: b6daffff
      m_RenameOverlay:
        m_UserAcceptedRename: 0
        m_Name: 
        m_OriginalName: 
        m_EditFieldRect:
          serializedVersion: 2
          x: 0
          y: 0
          width: 0
          height: 0
        m_UserData: 0
        m_IsWaitingForDelay: 0
        m_IsRenaming: 0
        m_OriginalEventType: 11
        m_IsRenamingFilename: 0
        m_ClientGUIView: {fileID: 0}
      m_SearchString: 
    m_ExpandedScenes: []
    m_CurrenRootInstanceID: 0
    m_LockTracker:
      m_IsLocked: 0
    m_CurrentSortingName: TransformSorting
  m_WindowGUID: 3e376fd34ca9c2b4a8f43e6ea0bf2eeb
--- !u!114 &16
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12013, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 200, y: 200}
  m_MaxSize: {x: 4000, y: 4000}
  m_TitleContent:
    m_Text: Scene
    m_Image: {fileID: 2593428753322112591, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 510
    y: 81
    width: 1524
    height: 755
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData:
    - dockPosition: 0
      containerId: overlay-toolbar__top
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: -101, y: -26}
      snapCorner: 3
      id: Tool Settings
      index: 0
      layout: 1
    - dockPosition: 0
      containerId: overlay-toolbar__top
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: -141, y: 149}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 1
      id: unity-grid-and-snap-toolbar
      index: 1
      layout: 1
    - dockPosition: 1
      containerId: overlay-toolbar__top
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: unity-scene-view-toolbar
      index: 0
      layout: 1
    - dockPosition: 1
      containerId: overlay-toolbar__top
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 1
      id: unity-search-toolbar
      index: 1
      layout: 1
    - dockPosition: 0
      containerId: overlay-container--left
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: unity-transform-toolbar
      index: 0
      layout: 2
    - dockPosition: 0
      containerId: overlay-container--left
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: 0, y: 197}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: unity-component-tools
      index: 1
      layout: 2
    - dockPosition: 0
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 1
      snapOffset: {x: 67.5, y: 86}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Orientation
      index: 0
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Light Settings
      index: 0
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Camera
      index: 1
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Cloth Constraints
      index: 2
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Cloth Collisions
      index: 3
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Navmesh Display
      index: 4
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Agent Display
      index: 5
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Obstacle Display
      index: 6
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Occlusion Culling
      index: 7
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Physics Debugger
      index: 8
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Scene Visibility
      index: 9
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Particles
      index: 10
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Tilemap
      index: 11
      layout: 4
    - dockPosition: 1
      containerId: overlay-container--right
      floating: 0
      collapsed: 0
      displayed: 0
      snapOffset: {x: 0, y: 0}
      snapOffsetDelta: {x: 0, y: 0}
      snapCorner: 0
      id: Scene View/Tilemap Palette Helper
      index: 12
      layout: 4
    m_OverlaysVisible: 1
  m_WindowGUID: e8448edfc3320ad419db11b8a5873be2
  m_Gizmos: 1
  m_OverrideSceneCullingMask: 6917529027641081856
  m_SceneIsLit: 1
  m_SceneLighting: 1
  m_2DMode: 1
  m_isRotationLocked: 0
  m_PlayAudio: 0
  m_AudioPlay: 0
  m_Position:
    m_Target: {x: 0, y: 0, z: 0}
    speed: 2
    m_Value: {x: 0, y: 0, z: 0}
  m_RenderMode: 0
  m_CameraMode:
    drawMode: 0
    name: Shaded
    section: Shading Mode
  m_ValidateTrueMetals: 0
  m_DoValidateTrueMetals: 0
  m_ExposureSliderValue: 0
  m_SceneViewState:
    m_AlwaysRefresh: 0
    showFog: 1
    showSkybox: 1
    showFlares: 1
    showImageEffects: 1
    showParticleSystems: 1
    showVisualEffectGraphs: 1
    m_FxEnabled: 1
  m_Grid:
    xGrid:
      m_Fade:
        m_Target: 0
        speed: 2
        m_Value: 0
      m_Color: {r: 0.5, g: 0.5, b: 0.5, a: 0.4}
      m_Pivot: {x: 0, y: 0, z: 0}
      m_Size: {x: 0, y: 0}
    yGrid:
      m_Fade:
        m_Target: 0
        speed: 2
        m_Value: 0
      m_Color: {r: 0.5, g: 0.5, b: 0.5, a: 0.4}
      m_Pivot: {x: 0, y: 0, z: 0}
      m_Size: {x: 0, y: 0}
    zGrid:
      m_Fade:
        m_Target: 1
        speed: 2
        m_Value: 1
      m_Color: {r: 0.5, g: 0.5, b: 0.5, a: 0.4}
      m_Pivot: {x: 0, y: 0, z: 0}
      m_Size: {x: 1, y: 1}
    m_ShowGrid: 1
    m_GridAxis: 1
    m_gridOpacity: 0.5
  m_Rotation:
    m_Target: {x: 0, y: 0, z: 0, w: 1}
    speed: 2
    m_Value: {x: 0, y: 0, z: 0, w: 1}
  m_Size:
    m_Target: 10
    speed: 2
    m_Value: 10
  m_Ortho:
    m_Target: 1
    speed: 2
    m_Value: 1
  m_CameraSettings:
    m_Speed: 1
    m_SpeedNormalized: 0.5
    m_SpeedMin: 0.01
    m_SpeedMax: 2
    m_EasingEnabled: 1
    m_EasingDuration: 0.4
    m_AccelerationEnabled: 1
    m_FieldOfViewHorizontalOrVertical: 60
    m_NearClip: 0.03
    m_FarClip: 10000
    m_DynamicClip: 1
    m_OcclusionCulling: 0
  m_LastSceneViewRotation: {x: -0.08717229, y: 0.89959055, z: -0.21045254, w: -0.3726226}
  m_LastSceneViewOrtho: 0
  m_ReplacementShader: {fileID: 0}
  m_ReplacementString: 
  m_SceneVisActive: 1
  m_LastLockedObject: {fileID: 0}
  m_ViewIsLockedToObject: 0
--- !u!114 &17
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12015, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 200, y: 200}
  m_MaxSize: {x: 4000, y: 4000}
  m_TitleContent:
    m_Text: Game
    m_Image: {fileID: -6423792434712278376, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 507
    y: 94
    width: 1532
    height: 790
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1
  m_SerializedViewNames: []
  m_SerializedViewValues: []
  m_PlayModeViewName: GameView
  m_ShowGizmos: 0
  m_TargetDisplay: 0
  m_ClearColor: {r: 0, g: 0, b: 0, a: 0}
  m_TargetSize: {x: 1532, y: 769}
  m_TextureFilterMode: 0
  m_TextureHideFlags: 61
  m_RenderIMGUI: 0
  m_EnterPlayModeBehavior: 0
  m_UseMipMap: 0
  m_VSyncEnabled: 0
  m_Gizmos: 0
  m_Stats: 0
  m_SelectedSizes: 00000000000000000000000000000000000000000000000000000000000000000000000000000000
  m_ZoomArea:
    m_HRangeLocked: 0
    m_VRangeLocked: 0
    hZoomLockedByDefault: 0
    vZoomLockedByDefault: 0
    m_HBaseRangeMin: -766
    m_HBaseRangeMax: 766
    m_VBaseRangeMin: -384.5
    m_VBaseRangeMax: 384.5
    m_HAllowExceedBaseRangeMin: 1
    m_HAllowExceedBaseRangeMax: 1
    m_VAllowExceedBaseRangeMin: 1
    m_VAllowExceedBaseRangeMax: 1
    m_ScaleWithWindow: 0
    m_HSlider: 0
    m_VSlider: 0
    m_IgnoreScrollWheelUntilClicked: 0
    m_EnableMouseInput: 1
    m_EnableSliderZoomHorizontal: 0
    m_EnableSliderZoomVertical: 0
    m_UniformScale: 1
    m_UpDirection: 1
    m_DrawArea:
      serializedVersion: 2
      x: 0
      y: 21
      width: 1532
      height: 769
    m_Scale: {x: 1, y: 1}
    m_Translation: {x: 766, y: 384.5}
    m_MarginLeft: 0
    m_MarginRight: 0
    m_MarginTop: 0
    m_MarginBottom: 0
    m_LastShownAreaInsideMargins:
      serializedVersion: 2
      x: -766
      y: -384.5
      width: 1532
      height: 769
    m_MinimalGUI: 1
  m_defaultScale: 1
  m_LastWindowPixelSize: {x: 1532, y: 790}
  m_ClearInEditMode: 1
  m_NoCameraWarning: 1
  m_LowResolutionForAspectRatios: 01000000000100000100
  m_XRRenderMode: 0
  m_RenderTexture: {fileID: 0}
--- !u!114 &18
MonoBehaviour:
  m_ObjectHideFlags: 52
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 1
  m_Script: {fileID: 12003, guid: 0000000000000000e000000000000000, type: 0}
  m_Name: 
  m_EditorClassIdentifier: 
  m_MinSize: {x: 100, y: 100}
  m_MaxSize: {x: 4000, y: 4000}
  m_TitleContent:
    m_Text: Console
    m_Image: {fileID: -4327648978806127646, guid: 0000000000000000d000000000000000,
      type: 0}
    m_Tooltip: 
  m_Pos:
    serializedVersion: 2
    x: 8
    y: 718
    width: 1366
    height: 308
  m_ViewDataDictionary: {fileID: 0}
  m_OverlayCanvas:
    m_LastAppliedPresetName: Default
    m_SaveData: []
    m_OverlaysVisible: 1



================================================
FILE: tests/ZString.NetCore2Tests/ZString.NetCore2Tests.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.1</TargetFramework>
    <RootNamespace>ZStringTests</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentAssertions" Version="5.10.2" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="16.5.0" />
    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="4.7.0" />
    <PackageReference Include="xunit" Version="2.4.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.1">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="1.2.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <Compile Include="..\ZString.Tests\**\*.cs" Exclude="**\obj\**;**\bin\**" />
  </ItemGroup>

  <ItemGroup>
   <ProjectReference Include="..\..\src\ZString\ZString.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: tests/ZString.Tests/AppendJoinTest.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class AppendJoinTest
    {
#if NETCOREAPP || NETSTANDARD2_1
        [Fact]
        public void JoinOverloads()
        {
            var zsb = ZString.CreateStringBuilder();
            var bcl = new StringBuilder();
            zsb.Append("Foo:");
            bcl.Append("Foo:");

            zsb.AppendJoin("_,_", 0);  // params
            bcl.AppendJoin("_,_", 0);  // params
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", 0, 1);  // params
            bcl.AppendJoin("_,_", 0, 1);  // params
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", new string[0]);
            bcl.AppendJoin("_,_", new string[0]);
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", new[] { 1, 2, 3 });
            bcl.AppendJoin("_,_", new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", new string[] { }.AsEnumerable());
            bcl.AppendJoin("_,_", new string[] { }.AsEnumerable());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", new[] { 1, 2, 3 }.AsEnumerable());
            bcl.AppendJoin("_,_", new[] { 1, 2, 3 }.AsEnumerable());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', new string[0]);
            bcl.AppendJoin(',', new string[0]);
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', new[] { 1, 2, 3 });
            bcl.AppendJoin(',', new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', new string[0].AsEnumerable());
            bcl.AppendJoin(',', new string[0].AsEnumerable());
            zsb.ToString().Should().Be(bcl.ToString());
        }

        [Fact]
        public void JoinOverloads2()
        {
            var zsb = ZString.CreateStringBuilder();
            var bcl = new StringBuilder();
            zsb.Append("Foo:");
            bcl.Append("Foo:");

            zsb.AppendJoin("_,_", new string[] { }.ToList());
            bcl.AppendJoin("_,_", new string[] { }.ToList());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", new[] { 1, 2, 3 }.ToList());
            bcl.AppendJoin("_,_", new[] { 1, 2, 3 }.ToList());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IList<int>)new int[] { });
            bcl.AppendJoin("_,_", (IList<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IList<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin("_,_", (IList<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IReadOnlyList<int>)new int[] { });
            bcl.AppendJoin("_,_", (IReadOnlyList<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IReadOnlyList<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin("_,_", (IReadOnlyList<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (ICollection<int>)new int[] { });
            bcl.AppendJoin("_,_", (ICollection<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (ICollection<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin("_,_", (ICollection<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IReadOnlyCollection<int>)new int[] { });
            bcl.AppendJoin("_,_", (IReadOnlyCollection<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin("_,_", (IReadOnlyCollection<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin("_,_", (IReadOnlyCollection<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());
        }

        [Fact]
        public void JoinOverloads3()
        {
            var zsb = ZString.CreateStringBuilder();
            var bcl = new StringBuilder();
            zsb.Append("Foo:");
            bcl.Append("Foo:");

            zsb.AppendJoin(',', new string[] { }.ToList());
            bcl.AppendJoin(',', new string[] { }.ToList());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', new[] { 1, 2, 3 }.ToList());
            bcl.AppendJoin(',', new[] { 1, 2, 3 }.ToList());
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IList<int>)new int[] { });
            bcl.AppendJoin(',', (IList<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IList<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin(',', (IList<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IReadOnlyList<int>)new int[] { });
            bcl.AppendJoin(',', (IReadOnlyList<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IReadOnlyList<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin(',', (IReadOnlyList<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (ICollection<int>)new int[] { });
            bcl.AppendJoin(',', (ICollection<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (ICollection<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin(',', (ICollection<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IReadOnlyCollection<int>)new int[] { });
            bcl.AppendJoin(',', (IReadOnlyCollection<int>)new int[] { });
            zsb.ToString().Should().Be(bcl.ToString());

            zsb.AppendJoin(',', (IReadOnlyCollection<int>)new[] { 1, 2, 3 });
            bcl.AppendJoin(',', (IReadOnlyCollection<int>)new[] { 1, 2, 3 });
            zsb.ToString().Should().Be(bcl.ToString());
        }

        [Fact]
        public void JoinStrings()
        {
            var values = new string[] { "abc", null, "def" };
            {
                const char sep = ',';
                var zsb = ZString.CreateStringBuilder();
                var bcl = new StringBuilder();

                zsb.AppendJoin(sep, "Foo:");
                bcl.AppendJoin(sep, "Foo:");

                zsb.AppendJoin(sep, new ReadOnlySpan<string>(values));
                bcl.AppendJoin(sep, values);

                zsb.AppendJoin(sep, values);
                bcl.AppendJoin(sep, values);

                zsb.AppendJoin(sep, values.ToList());
                bcl.AppendJoin(sep, values.ToList());

                zsb.AppendJoin(sep, values.AsEnumerable());
                bcl.AppendJoin(sep, values.AsEnumerable());

                zsb.AppendLine();
                bcl.AppendLine();
                zsb.ToString().Should().Be(bcl.ToString());
            }

            {
                const string sep = "_,_";
                var zsb = ZString.CreateStringBuilder();
                var bcl = new StringBuilder();

                zsb.AppendJoin(sep, "Foo:");
                bcl.AppendJoin(sep, "Foo:");

                zsb.AppendJoin(sep, new ReadOnlySpan<string>(values));
                bcl.AppendJoin(sep, values);

                zsb.AppendJoin(sep, values);
                bcl.AppendJoin(sep, values);

                zsb.AppendJoin(sep, values.ToList());
                bcl.AppendJoin(sep, values.ToList());

                zsb.AppendJoin(sep, values.AsEnumerable());
                bcl.AppendJoin(sep, values.AsEnumerable());

                zsb.AppendLine();
                bcl.AppendLine();
                zsb.ToString().Should().Be(bcl.ToString());
            }
        }
    }
#endif
}



================================================
FILE: tests/ZString.Tests/CompositeFormatTest.cs
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0x95 in position 1639: invalid start byte


================================================
FILE: tests/ZString.Tests/EnumTest.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System;
using System.Collections.Generic;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public enum DuplicateEnum
    {
        A = 1,
        B = 2,
        BB = 2,
        C = 3
    }

    public enum StandardEnum
    {
        Abc = 1,
        Def = 2,
        Ghi = 3,
    }

    [Flags]
    public enum FlagsEnum
    {
        None = 0,
        Abc = 1,
        Bcd = 2,
        Efg = 4,
    }

    public class EnumTest
    {
        [Fact]
        public void Duplicate()
        {
            ZString.Format("{0}", DuplicateEnum.A).Should().Be("A");
            ZString.Format("{0}", DuplicateEnum.B).Should().Be("B");
            ZString.Format("{0}", DuplicateEnum.BB).Should().Be("B");
            ZString.Format("{0}", DuplicateEnum.C).Should().Be("C");
            Utf8(DuplicateEnum.A);
            Utf8(DuplicateEnum.B);
            Utf8(DuplicateEnum.BB);
            Utf8(DuplicateEnum.C);
        }

        [Fact]
        public void Standard()
        {
            ZString.Format("{0}", StandardEnum.Abc).Should().Be("Abc");
            ZString.Format("{0}", StandardEnum.Def).Should().Be("Def");
            ZString.Format("{0}", StandardEnum.Ghi).Should().Be("Ghi");
            Utf8(StandardEnum.Abc);
            Utf8(StandardEnum.Def);
            Utf8(StandardEnum.Ghi);
        }

        [Fact]
        public void Flags()
        {
            ZString.Format("{0}", FlagsEnum.Abc | FlagsEnum.Bcd).Should().Be("Abc, Bcd");
            ZString.Format("{0}", FlagsEnum.None).Should().Be("None");
            ZString.Format("{0}", FlagsEnum.Efg).Should().Be("Efg");
            Utf8(FlagsEnum.Abc | FlagsEnum.Bcd);
            Utf8(FlagsEnum.None);
            Utf8(FlagsEnum.Efg);
        }

        static void Utf8<T>(T e) where T : Enum
        {
            var s = ZString.CreateUtf8StringBuilder();
            s.AppendFormat("{0}", e);
            s.AsSpan().SequenceEqual(Encoding.UTF8.GetBytes(e.ToString())).Should().BeTrue();
        }
    }
}



================================================
FILE: tests/ZString.Tests/FormatTest.cs
================================================
using Cysharp.Text;
using FluentAssertions;
using System;
using System.Buffers;
using System.Numerics;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class FormatTest
    {
        internal static void Test<T0, T1>(string format, T0 t0, T1 t1)
        {
            Test(true, format, t0, t1);
        }

        internal static void Test<T0, T1>(bool testUtf8, string format, T0 t0, T1 t1)
        {
            {
                var actual = ZString.Format(format, t0, t1);
                var expected = string.Format(format, t0, t1);
                actual.Should().Be(expected);
            }
            if (testUtf8)
            {
                var sb = ZString.CreateUtf8StringBuilder();
                sb.AppendFormat(format, t0, t1);
                var actual = sb.ToString();
                var expected = string.Format(format, t0, t1);
                actual.Should().Be(expected);
            }

            // Prepare
            {
                var actual = ZString.PrepareUtf16<T0, T1>(format).Format(t0, t1);
                var expected = string.Format(format, t0, t1);
                actual.Should().Be(expected);
            }
            if (testUtf8)
            {
                var sb = ZString.PrepareUtf8<T0, T1>(format);
                var actual = sb.Format(t0, t1);
                var expected = string.Format(format, t0, t1);
                actual.Should().Be(expected);
            }

            // Direct
            if (testUtf8)
            {
                var writer = new ArrayBufferWriter<byte>();
                ZString.Utf8Format(writer, format, t0, t1);
                var actual = Encoding.UTF8.GetString(writer.WrittenSpan);
                var expected = string.Format(format, t0, t1);
                actual.Should().Be(expected);
            }
        }

        void Test<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            {
                var actual = ZString.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                var expected = string.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                actual.Should().Be(expected);
            }
            {
                var sb = ZString.CreateUtf8StringBuilder();
                sb.AppendFormat(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                var actual = sb.ToString();
                var expected = string.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                actual.Should().Be(expected);
            }

            // Prepare
            {
                var actual = ZString.PrepareUtf16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format).Format(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                var expected = string.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                actual.Should().Be(expected);
            }
            {
                var sb = ZString.PrepareUtf8<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(format);
                var actual = sb.Format(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                var expected = string.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                actual.Should().Be(expected);
            }

            // Direct
            {
                var writer = new ArrayBufferWriter<byte>();
                ZString.Utf8Format(writer, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                var actual = Encoding.UTF8.GetString(writer.WrittenSpan);
                var expected = string.Format(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
                actual.Should().Be(expected);
            }
        }

        [Fact]
        public void EmptyFormat()
        {
            Test("", 100, 200);
        }

        [Fact]
        public void NoFormat()
        {
            Test("abcdefg", 100, 200);
        }

        [Fact]
        public void SingleFormat()
        {
            Test("{0}", 100, 200);
        }

        [Fact]
        public void DoubleFormat()
        {
            Test("{0}{1}", 100, 200);
        }

        [Fact]
        public void DoubleFormat2()
        {
            Test("abc{0}def{1}", 100, 200);
        }

        [Fact]
        public void DoubleFormat3()
        {
            Test("abc{0}def{1}ghi", 100, 200);
        }

        [Fact]
        public void EmptyFormatString()
        {
            // UtfFormatter Deny space only
            Test(false, "{0:}{1: }", 100, 200);
        }

        [Fact]
        public void MaximumFormat()
        {
            Test("abc{0}de{1}f{2}g{3}h{4}i{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}z",
                100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600);
        }


        [Fact]
        public void Nullable()
        {
            Test("abc{0}def{1}ghi", (int?)100, (int?)1);
            Test("abc{0:X}def{1:X}ghi", (int?)100, (int?)1);
            Test("abc{0}def{1}ghi", (Guid?)Guid.NewGuid(), (Guid?)null);
            Test("abc{0:e}def{1:e}ghi", (double?)Math.PI, (double?)null);
        }

        [Fact]
        public void Comment()
        {
            Test("abc{{0}}def{1}ghi", 100, 200);
            Test("}}{{{0}{{}}{1}{{", 123, 456);
        }

        [Fact]
        public void FormatArgs()
        {
            ZString.Format("{0:00000000}-{1:00000000}", 100, 200).Should().Be("00000100-00000200");
        }

        [Fact]
        public void FormatIntPtr()
        {
            // IntPtr/UIntPtr ignores format
            // after .NET 5, not ignore format https://learn.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/5.0/intptr-uintptr-implement-iformattable
            Test("abc{0:X}def{1:X}", new IntPtr(int.MinValue), new IntPtr(int.MaxValue));
            Test("abc{0:X}def{1:X}", new UIntPtr(uint.MinValue), new UIntPtr(uint.MaxValue));
            if (IntPtr.Size == 8)
            {
                Test("abc{0:X}def{1:X}", new IntPtr(long.MinValue), new IntPtr(long.MaxValue));
                Test("abc{0:X}def{1:X}", new UIntPtr(ulong.MinValue), new UIntPtr(ulong.MaxValue));
            }
        }

        [Fact]
        public void FormattableObject()
        {
            Test("abc{0:}def{1:F3}", (object)default(Vector2), (object)new Vector2(MathF.PI));
            Test("abc{0:E0}def{1:N}", (object)new Vector3(float.MinValue, float.NaN, float.MaxValue),
                (object)new Vector3(MathF.PI));
        }

        [Fact]
        public void Escape()
        {
            TimeSpan span = new TimeSpan(12, 34, 56);
            var reference = string.Format(@"{0:h\,h\:mm\:ss}", span);

            var actual = ZString.Format(@"{0:h\,h\:mm\:ss}", span);
            actual.Should().Be(reference);
        }

        [Fact]
        public void Unicode()
        {
            Test("\u30cf\u30fc\u30c8: {0}, \u5bb6\u65cf: {1}(\u7d75\u6587\u5b57)", "\u2764", "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC67");
        }
    }
}


================================================
FILE: tests/ZString.Tests/InsertTest.cs
================================================
using Cysharp.Text;
using FluentAssertions;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class InsertTest
    {
        [Fact]
        public void InsertStringTest()
        { 
            string initialValue = "--[]--";

            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                string xyz = "xyz";

                zsb.Append(initialValue);
                var bcl = new StringBuilder(initialValue);

                zsb.Insert(3, xyz, 2);
                bcl.Insert(3, xyz, 2);
                zsb.ToString().Should().Be(bcl.ToString());

                zsb.Insert(3, xyz);
                bcl.Insert(3, xyz);
                zsb.ToString().Should().Be(bcl.ToString());

                zsb.Insert(0, "<<");
                bcl.Insert(0, "<<");
                zsb.ToString().Should().Be(bcl.ToString());

                var endIndex = zsb.Length - 1;
                zsb.Insert(endIndex, ">>");
                bcl.Insert(endIndex, ">>");
                zsb.ToString().Should().Be(bcl.ToString());
            }
        }

        [Fact]
        public void InsertLargeStringTest()
        {
            string initialValue = "--[]--";

            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                string text = new string('X', 32768);

                zsb.Append(initialValue);
                var bcl = new StringBuilder(initialValue);

                zsb.Insert(3, text);
                bcl.Insert(3, text);
                zsb.ToString().Should().Be(bcl.ToString());
            }
        }

        [Fact]
        public void NotInserted()
        {
            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                var text = "The quick brown dog jumps over the lazy cat.";
                zsb.Append(text);
                zsb.Insert( 10, "");
                zsb.ToString().Should().Be(text);
            }
        }
    }
}



================================================
FILE: tests/ZString.Tests/JoinTest.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class JoinTest
    {
        [Fact]
        public void JoinOverloads()
        {
            ZString.Join("_,_", new string[0]).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", new[] { 1 }).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", new[] { 1, 2 }).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", new[] { 1, 2, 3 }).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join("_,_", new string[] { }.AsEnumerable()).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", new[] { 1 }.AsEnumerable()).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", new[] { 1, 2 }.AsEnumerable()).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", new[] { 1, 2, 3 }.AsEnumerable()).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join(',', new string[0]).Should().Be(string.Join(",", new string[0]));
            ZString.Join(',', new[] { 1 }).Should().Be(string.Join(",", new[] { 1 }));
            ZString.Join(',', new[] { 1, 2 }).Should().Be(string.Join(",", new[] { 1, 2 }));
            ZString.Join(',', new[] { 1, 2, 3 }).Should().Be(string.Join(",", new[] { 1, 2, 3 }));

            ZString.Join(',', new string[0].AsEnumerable()).Should().Be(string.Join(",", new string[0]));
            ZString.Join(',', new[] { 1 }.AsEnumerable()).Should().Be(string.Join(",", new[] { 1 }));
            ZString.Join(',', new[] { 1, 2 }.AsEnumerable()).Should().Be(string.Join(",", new[] { 1, 2 }));
            ZString.Join(',', new[] { 1, 2, 3 }.AsEnumerable()).Should().Be(string.Join(",", new[] { 1, 2, 3 }));
        }

        [Fact]
        public void JoinOverloads2()
        {
            ZString.Join("_,_", new string[] { }.ToList()).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", new[] { 1 }.ToList()).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", new[] { 1, 2 }.ToList()).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", new[] { 1, 2, 3 }.ToList()).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join("_,_", (IList<int>)new int[] { }).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", (IList<int>)new[] { 1 }).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", (IList<int>)new[] { 1, 2 }).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", (IList<int>)new[] { 1, 2, 3 }).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join("_,_", (IReadOnlyList<int>)new int[] { }).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", (IReadOnlyList<int>)new[] { 1 }).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", (IReadOnlyList<int>)new[] { 1, 2 }).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", (IReadOnlyList<int>)new[] { 1, 2, 3 }).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join("_,_", (ICollection<int>)new int[] { }).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", (ICollection<int>)new[] { 1 }).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", (ICollection<int>)new[] { 1, 2 }).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", (ICollection<int>)new[] { 1, 2, 3 }).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));

            ZString.Join("_,_", (IReadOnlyCollection<int>)new int[] { }).Should().Be(string.Join("_,_", new string[0]));
            ZString.Join("_,_", (IReadOnlyCollection<int>)new[] { 1 }).Should().Be(string.Join("_,_", new[] { 1 }));
            ZString.Join("_,_", (IReadOnlyCollection<int>)new[] { 1, 2 }).Should().Be(string.Join("_,_", new[] { 1, 2 }));
            ZString.Join("_,_", (IReadOnlyCollection<int>)new[] { 1, 2, 3 }).Should().Be(string.Join("_,_", new[] { 1, 2, 3 }));
        }

        [Fact]
        public void JoinOverloads3()
        {
            ZString.Join(',', new string[] { }.ToList()).Should().Be(string.Join(',', new string[0]));
            ZString.Join(',', new[] { 1 }.ToList()).Should().Be(string.Join(',', new[] { 1 }));
            ZString.Join(',', new[] { 1, 2 }.ToList()).Should().Be(string.Join(',', new[] { 1, 2 }));
            ZString.Join(',', new[] { 1, 2, 3 }.ToList()).Should().Be(string.Join(',', new[] { 1, 2, 3 }));

            ZString.Join(',', (IList<int>)new int[] { }).Should().Be(string.Join(',', new string[0]));
            ZString.Join(',', (IList<int>)new[] { 1 }).Should().Be(string.Join(',', new[] { 1 }));
            ZString.Join(',', (IList<int>)new[] { 1, 2 }).Should().Be(string.Join(',', new[] { 1, 2 }));
            ZString.Join(',', (IList<int>)new[] { 1, 2, 3 }).Should().Be(string.Join(',', new[] { 1, 2, 3 }));

            ZString.Join(',', (IReadOnlyList<int>)new int[] { }).Should().Be(string.Join(',', new string[0]));
            ZString.Join(',', (IReadOnlyList<int>)new[] { 1 }).Should().Be(string.Join(',', new[] { 1 }));
            ZString.Join(',', (IReadOnlyList<int>)new[] { 1, 2 }).Should().Be(string.Join(',', new[] { 1, 2 }));
            ZString.Join(',', (IReadOnlyList<int>)new[] { 1, 2, 3 }).Should().Be(string.Join(',', new[] { 1, 2, 3 }));

            ZString.Join(',', (ICollection<int>)new int[] { }).Should().Be(string.Join(',', new string[0]));
            ZString.Join(',', (ICollection<int>)new[] { 1 }).Should().Be(string.Join(',', new[] { 1 }));
            ZString.Join(',', (ICollection<int>)new[] { 1, 2 }).Should().Be(string.Join(',', new[] { 1, 2 }));
            ZString.Join(',', (ICollection<int>)new[] { 1, 2, 3 }).Should().Be(string.Join(',', new[] { 1, 2, 3 }));

            ZString.Join(',', (IReadOnlyCollection<int>)new int[] { }).Should().Be(string.Join(',', new string[0]));
            ZString.Join(',', (IReadOnlyCollection<int>)new[] { 1 }).Should().Be(string.Join(',', new[] { 1 }));
            ZString.Join(',', (IReadOnlyCollection<int>)new[] { 1, 2 }).Should().Be(string.Join(',', new[] { 1, 2 }));
            ZString.Join(',', (IReadOnlyCollection<int>)new[] { 1, 2, 3 }).Should().Be(string.Join(',', new[] { 1, 2, 3 }));
        }

        [Fact]
        public void CooncatNullTest()
        {
            var str = ZString.Concat(default(string), "foo", "bar");
            str.Should().Be(string.Concat(default(string), "foo", "bar"));
        }

        [Fact]
        public void ConcatHugeString()
        {
            var a = new string('a', 10000);
            var b = new string('b', 1000000);

            var actrual = ZString.Join(',', new string[] { a, b });
            var expected = string.Join(',', new string[] { a, b });
            actrual.Should().Be(expected);
        }

        [Fact]
        public void JoinStrings()
        {
            var values = new[] { "abc", null, "def" };
            {
                const char sep = ',';
                var expected = string.Join(sep, values);
                ZString.Join(sep, new ReadOnlySpan<string>(values)).Should().Be(expected);
                ZString.Join(sep, values).Should().Be(expected);
                ZString.Join(sep, values.ToList()).Should().Be(expected);
                ZString.Join(sep, values.AsEnumerable()).Should().Be(expected);
            }

            {
                const string sep = "_,_";
                var expected = string.Join(sep, values);
                ZString.Join(sep, new ReadOnlySpan<string>(values)).Should().Be(expected);
                ZString.Join(sep, values).Should().Be(expected);
                ZString.Join(sep, values.ToList()).Should().Be(expected);
                ZString.Join(sep, values.AsEnumerable()).Should().Be(expected);
            }
        }

        [Fact]
        public void ConcatStrings()
        {
            var values = new[] { "abc", null, "def" };

            var expected = string.Concat(values);
            ZString.Concat(new ReadOnlySpan<string>(values)).Should().Be(expected);
            ZString.Concat(values).Should().Be(expected);
            ZString.Concat(values.ToList()).Should().Be(expected);
            ZString.Concat(values.AsEnumerable()).Should().Be(expected);
        }
    }
}



================================================
FILE: tests/ZString.Tests/NestedStringBuilder.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using FluentAssertions.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class NestedStringBuilder
    {
        [Fact]
        public void NotNestedUtf16()
        {
            using (_ = ZString.CreateStringBuilder(true))
            {
            }
            using (_ = ZString.CreateStringBuilder(false))
            {
                using (_ = ZString.CreateStringBuilder(true))
                {
                    using (_ = ZString.CreateStringBuilder(false))
                    {
                    }
                }
            }
        }

        [Fact]
        public void NestedUtf16()
        {
            using (_ = ZString.CreateStringBuilder(true))
            {
                using (_ = ZString.CreateStringBuilder(false))
                {
                    Assert.Throws<NestedStringBuilderCreationException>(() =>
                    {
                        using (_ = ZString.CreateStringBuilder(true))
                        {
                        }
                    }
                    );
                }
            }
        }

        [Fact]
        public void NotDisposedUtf16()
        {
            {
                _ = ZString.CreateStringBuilder(true);
            }
            {
                Assert.Throws<NestedStringBuilderCreationException>(() =>
                {
                    using (_ = ZString.CreateStringBuilder(true))
                    {
                    }
                }
                );
            }
            Utf16ValueStringBuilder.scratchBufferUsed.IsSameOrEqualTo(true);
            Utf16ValueStringBuilder.scratchBufferUsed = false;
        }

        [Fact]
        public void NotNestedUtf8()
        {
            using (_ = ZString.CreateUtf8StringBuilder(true))
            {
            }
            using (_ = ZString.CreateUtf8StringBuilder(false))
            {
                using (_ = ZString.CreateUtf8StringBuilder(true))
                {
                    using (_ = ZString.CreateUtf8StringBuilder(false))
                    {
                    }
                }
            }
        }

        [Fact]
        public void NestedUtf8()
        {
            using (_ = ZString.CreateUtf8StringBuilder(true))
            {
                using (_ = ZString.CreateUtf8StringBuilder(false))
                {
                    Assert.Throws<NestedStringBuilderCreationException>(() =>
                    {
                        using (_ = ZString.CreateUtf8StringBuilder(true))
                        {
                        }
                    }
                    );
                }
            }
        }

        [Fact]
        public void NotDisposedUtf8()
        {
            {
                _ = ZString.CreateUtf8StringBuilder(true);
            }
            {
                Assert.Throws<NestedStringBuilderCreationException>(() =>
                {
                    using (_ = ZString.CreateUtf8StringBuilder(true))
                    {
                    }
                }
                );
            }
            Utf8ValueStringBuilder.scratchBufferUsed.IsSameOrEqualTo(true);
            Utf8ValueStringBuilder.scratchBufferUsed = false;
        }

    }
}



================================================
FILE: tests/ZString.Tests/Primitives.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public enum MoreMyEnum
    {
        Fruit, Apple, Orange
    }

    public class Primitives
    {
        [Theory]
        [InlineData(int.MinValue, int.MinValue)]
        [InlineData(0, -1)]
        [InlineData(-1, 1)]
        [InlineData(-12, 12)]
        [InlineData(-123, 123)]
        [InlineData(-1234, 1234)]
        [InlineData(-12345, 12345)]
        [InlineData(-123456, 123456)]
        [InlineData(-1234567, 1234567)]
        [InlineData(-12345678, 12345678)]
        [InlineData(-123456789, 123456789)]
        [InlineData(-1234567890, 1234567890)]
        public void Integer(int x, int y)
        {
            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y);
                sb2.Append(x); sb2.Append(y);
                sb3.Append(x); sb3.Append(y);
                sb4.Append(x); sb4.Append(y);
                sb5.Append(x); sb5.Append(y);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Theory]
        [InlineData(ulong.MinValue, ulong.MinValue)]
        [InlineData(0UL, 1UL)]
        [InlineData(1UL, 1UL)]
        [InlineData(12UL, 12UL)]
        [InlineData(123UL, 123UL)]
        [InlineData(1234UL, 1234UL)]
        [InlineData(12345UL, 12345UL)]
        [InlineData(123456UL, 123456UL)]
        [InlineData(1234567UL, 1234567UL)]
        [InlineData(12345678UL, 12345678UL)]
        [InlineData(123456789UL, 123456789UL)]
        [InlineData(1234567890UL, 1234567890UL)]
        [InlineData(12345678901UL, 12345678901UL)]
        [InlineData(123456789012UL, 123456789012UL)]
        public void UInt64(ulong x, ulong y)
        {
            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y);
                sb2.Append(x); sb2.Append(y);
                sb3.Append(x); sb3.Append(y);
                sb4.Append(x); sb4.Append(y);
                sb5.Append(x); sb5.Append(y);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Theory]
        //[InlineData(double.MinValue, double.MinValue)]
        //[InlineData(double.Epsilon, double.NaN)]
        [InlineData(0.1, -0.1)]
        [InlineData(0.0, 0.0)]
        [InlineData(0.12, 0.12)]
        [InlineData(0.123, 0.123)]
        [InlineData(0.1234, 0.1234)]
        [InlineData(0.12345, 0.12345)]
        [InlineData(1.12345, 1.12345)]
        [InlineData(12.12345, 12.12345)]
        [InlineData(123.12345, 123.12345)]
        [InlineData(1234.12345, 1234.12345)]
        [InlineData(12345.12345, 12345.12345)]
        [InlineData(1234512345d, 1234512345d)]
        public void Double(double x, double y)
        {
            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y);
                sb2.Append(x); sb2.Append(y);
                sb3.Append(x); sb3.Append(y);
                sb4.Append(x); sb4.Append(y);
                sb5.Append(x); sb5.Append(y);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Theory]
        //[InlineData(double.MinValue, double.MinValue)]
        //[InlineData(double.Epsilon, double.NaN)]
        [InlineData(0.1f, -0.1f)]
        [InlineData(0.0f, 0.0f)]
        [InlineData(0.12f, 0.12f)]
        [InlineData(0.123f, 0.123f)]
        [InlineData(0.1234f, 0.1234f)]
        [InlineData(0.12345f, 0.12345f)]
        [InlineData(1.12345f, 1.12345f)]
        [InlineData(12.12345f, 12.12345f)]
        [InlineData(123.123f, 123.123f)]
        public void Single(float x, float y)
        {
            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y);
                sb2.Append(x); sb2.Append(y);
                sb3.Append(x); sb3.Append(y);
                sb4.Append(x); sb4.Append(y);
                sb5.Append(x); sb5.Append(y);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Fact]
        public void Others()
        {
            using (var sb1 = ZString.CreateStringBuilder())
            //using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            //using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var x = DateTime.Now;
                var y = DateTimeOffset.Now;
                var z = TimeSpan.FromMilliseconds(12345.6789);
                var g = Guid.NewGuid();

                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y); sb1.Append(z); sb1.Append(g);
                //sb2.Append(x, StandardFormat.Parse("O")); sb2.Append(y, StandardFormat.Parse("O")); sb2.Append(z); sb2.Append(g);
                sb3.Append(x); sb3.Append(y); sb3.Append(z); sb3.Append(g);
                //sb4.Concat(x, y, z, g);
                sb5.Append(x); sb5.Append(y); sb5.Append(z); sb5.Append(g);

                //sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                //sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Fact]
        public void EnumTest()
        {
            var x = MoreMyEnum.Apple;
            var y = MoreMyEnum.Orange;

            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x); sb1.Append(y);
                sb2.Append(x); sb2.Append(y);
                sb3.Append(x); sb3.Append(y);
                sb4.Append(x); sb4.Append(y);
                sb5.Append(x); sb5.Append(y);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }

        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        public void BoolTest(bool x)
        {
            using (var sb1 = ZString.CreateStringBuilder())
            using (var sb2 = ZString.CreateUtf8StringBuilder())
            using (var sb3 = ZString.CreateStringBuilder())
            using (var sb4 = ZString.CreateUtf8StringBuilder())
            {
                var sb5 = new StringBuilder();
                sb1.Append(x);
                sb2.Append(x);
                sb3.Append(x);
                sb4.Append(x);
                sb5.Append(x);

                sb1.ToString().Should().Be(sb2.ToString());
                sb1.ToString().Should().Be(sb3.ToString());
                sb1.ToString().Should().Be(sb4.ToString());
                sb1.ToString().Should().Be(sb5.ToString());
            }
        }
    }
}



================================================
FILE: tests/ZString.Tests/RemoveTest.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class RemoveTest
    { 
        [Fact]
        public void RemovePart()
        {
            string str = "The quick brown fox jumps over the lazy dog.";
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(str);
                var bcl = new StringBuilder(str);

                // Remove "brown "
                zsb.Remove(10, 6);
                bcl.Remove(10, 6);

                zsb.ToString().Should().Be(bcl.ToString());
            }
        }

        [Fact]
        public void RemoveAll()
        {
            string str = "The quick brown fox jumps over the lazy dog.";
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(str);
                var bcl = new StringBuilder(str);

                zsb.Remove(0, str.Length);
                bcl.Remove(0, str.Length);

                zsb.ToString().Should().Be(bcl.ToString());
            }
        }

        [Fact]
        public void RemoveTail()
        {
            string str = "foo,bar,baz";
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(str);
                var bcl = new StringBuilder(str);

                zsb.Remove(7, 4);
                bcl.Remove(7, 4);

                zsb.ToString().Should().Be(bcl.ToString());
            }
        }
    }
}



================================================
FILE: tests/ZString.Tests/ReplaceTest.cs
================================================
using Cysharp.Text;
using FluentAssertions;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class ReplaceTest
    {
        
        [Fact]
        public void ReplaceAtCharTest()
        {
            var s = new string(' ', 10);
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(s);
                zsb.ReplaceAt('-',2);
                zsb.ToString().Should().Be(new StringBuilder(s) { [2] = '-'}.ToString());
            }
        }
        
        [Fact]
        public void ReplaceCharTest()
        {
            var s = new string(' ', 10);
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(s);
                zsb.Replace(' ', '-', 2, 5);
                zsb.ToString().Should().Be(new StringBuilder(s).Replace(' ', '-', 2, 5).ToString());
            }

            s = "0";
            using (var zsb = ZString.CreateStringBuilder())
            {
                zsb.Append(s);
                zsb.Replace('0', '1');
                zsb.ToString().Should().Be(new StringBuilder(s).Replace('0', '1').ToString());
            }
        }

        [Fact]
        public void ReplaceStringTest()
        {
            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                var text = "bra bra BRA bra bra";
                zsb.Append(text);
                var bcl = new StringBuilder(text);
                
                zsb.Replace("bra", null, 1, text.Length - 2);
                bcl.Replace("bra", null, 1, text.Length - 2);

                //  "bra BRA bra"
                zsb.ToString().Should().Be(bcl.ToString());
            }

            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                var text = "num num num";
                zsb.Append(text);
                var bcl = new StringBuilder(text);

                // over DefaultBufferSize
                zsb.Replace("num", new string('1', 32768), 1, text.Length - 2);
                bcl.Replace("num", new string('1', 32768), 1, text.Length - 2);

                zsb.ToString().Should().Be(bcl.ToString());
            }

            using (var zsb = ZString.CreateStringBuilder())
            {
                var text = "The quick brown dog jumps over the lazy cat.";
                zsb.Append(text);
                var bcl = new StringBuilder(text);

                // All "cat" -> "dog"
                zsb.Replace("cat", "dog");
                bcl.Replace("cat", "dog");
                zsb.ToString().Should().Be(bcl.ToString());

                // Some "dog" -> "fox"
                zsb.Replace("dog", "fox", 15, 20);
                bcl.Replace("dog", "fox", 15, 20);
                zsb.ToString().Should().Be(bcl.ToString());
            }
        }
        
        [Fact]
        public void NotMatchTest()
        {
            using (var zsb = ZString.CreateStringBuilder(notNested: true))
            {
                var text = "The quick brown dog jumps over the lazy cat.";
                zsb.Append(text);
                zsb.Replace("pig", "dog");
                zsb.ToString().Should().Be(text);
            }
        }
    }
}



================================================
FILE: tests/ZString.Tests/StringBuilderTest.cs
================================================
using Cysharp.Text;
using FluentAssertions;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class StringBuilderTest
    {
        [Fact]
        public void Utf16DisposeTest()
        {
            var sb = ZString.CreateStringBuilder();
            sb.Dispose();
            sb.Dispose(); // call more than once
        }

        [Fact]
        public void Utf8DisposeTest()
        {
            var sb = ZString.CreateUtf8StringBuilder();
            sb.Dispose();
            sb.Dispose(); // call more than once
        }
    }
}



================================================
FILE: tests/ZString.Tests/Utf8StringBuilderTest.cs
================================================
﻿using Cysharp.Text;
using FluentAssertions;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Text;
using Xunit;

namespace ZStringTests
{
    public class Utf8StringBuilderTest
    {

        [Fact]
        public void AppendCharRepeat()
        {
            using (var zsb = ZString.CreateUtf8StringBuilder(notNested: true))
            {
                var text = "foo";
                zsb.Append(text);
                var bcl = new StringBuilder(text);

                // ASCII
                zsb.Append('\x7F', 10);
                bcl.Append('\x7F', 10);
                zsb.ToString().Should().Be(bcl.ToString());

                // Non-ASCII
                zsb.Append('\x80', 10);
                bcl.Append('\x80', 10);
                zsb.ToString().Should().Be(bcl.ToString());

                zsb.Append('\u9bd6', 10);
                bcl.Append('\u9bd6', 10);
                zsb.ToString().Should().Be(bcl.ToString());
            }

        }
    }
}



================================================
FILE: tests/ZString.Tests/ZString.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <RootNamespace>ZStringTests</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentAssertions" Version="5.10.2" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="16.5.0" />
    <PackageReference Include="xunit" Version="2.4.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.1">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="1.2.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\ZString\ZString.csproj">
      <SetTargetFramework>TargetFramework=netstandard2.1</SetTargetFramework>
    </ProjectReference>
  </ItemGroup>

</Project>



================================================
FILE: tests/ZString.Tests/ZStringWriterTest.cs
================================================
using System;
using Cysharp.Text;
using Xunit;

namespace ZStringTests
{
    public class ZStringWriterTest
    {
        [Fact]
        public void DoubleDisposeTest()
        {
            var sb = new ZStringWriter();
            sb.Dispose();
            sb.Dispose(); // call more than once
        }

        [Fact]
        public void BasicWrites()
        {
            using (var writer = new ZStringWriter())
            {
                writer.Write("text1".AsSpan());
                writer.Write("text2");
                writer.Write('c');
                writer.Write(true);
                writer.Write(123);
                writer.Write(456f);
                writer.Write(789d);
                writer.Write("end".AsMemory());
                writer.WriteLine();

                var expected = "text1text2cTrue123456789end" + Environment.NewLine;
                Assert.Equal(expected, writer.ToString());
            }
        }
    }
}


================================================
FILE: .github/dependabot.yaml
================================================
# ref: https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly" # Check for updates to GitHub Actions every week
    cooldown:
      default-days: 14 # Wait 14 days before creating another PR for the same dependency. This will prevent vulnerability on the package impact.
    ignore:
      # I just want update action when major/minor version is updated. patch updates are too noisy.
      - dependency-name: "*"
        update-types:
          - version-update:semver-patch



================================================
FILE: .github/workflows/build-debug.yaml
================================================
name: Build-Debug

on:
  push:
    branches:
      - "master"
  pull_request:
    branches:
      - "master"

jobs:
  build-dotnet:
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - uses: Cysharp/Actions/.github/actions/checkout@main
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      - run: dotnet build -c Release
      - run: dotnet test -c Release --no-build
      - run: dotnet pack -c Release --no-build -p:IncludeSymbols=true -p:SymbolPackageFormat=snupkg -o $GITHUB_WORKSPACE/artifacts

  build-unity:
    if: ${{ (github.event_name == 'push' && github.repository_owner == 'Cysharp') || startsWith(github.event.pull_request.head.label, 'Cysharp:') }}
    strategy:
      matrix:
        unity: ["2021.3.41f1"]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - uses: Cysharp/Actions/.github/actions/checkout@main
      # Execute scripts: Export Package
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
      - name: Build Unity (.unitypacakge)
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
        with:
          projectPath: src/ZString.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: PackageExporter.Export

      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/ZString.Unity

      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: ZString.Unity.${{ matrix.unity }}.unitypackage.zip
          path: ./src/ZString.Unity/*.unitypackage
          retention-days: 1



================================================
FILE: .github/workflows/build-release.yaml
================================================
name: Build-Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "tag: git tag you want create. (sample 1.0.0)"
        required: true
      dry-run:
        description: "dry-run: true will never create relase/nuget."
        required: true
        default: false
        type: boolean

jobs:
  update-packagejson:
    permissions:
      actions: read
      contents: write
    uses: Cysharp/Actions/.github/workflows/update-packagejson.yaml@main
    with:
      file-path: ./src/ZString.Unity/Assets/Scripts/ZString/package.json
      tag: ${{ inputs.tag }}
      dry-run: ${{ inputs.dry-run }}

  build-dotnet:
    needs: [update-packagejson]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    steps:
      - run: echo ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}
      - uses: Cysharp/Actions/.github/actions/setup-dotnet@main
      # pack nuget
      - run: dotnet build -c Release -p:Version=${{ inputs.tag }}
      - run: dotnet test tests/ZString.Tests -c Release --no-build
      - run: dotnet pack -c Release --no-build -p:Version=${{ inputs.tag }} -o ./publish
      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: nuget
          path: ./publish/
          retention-days: 1

  build-unity:
    needs: [update-packagejson]
    strategy:
      matrix:
        unity: ["2021.3.41f1"]
    permissions:
      contents: read
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    steps:
      - name: Load secrets
        id: op-load-secret
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_PUBLIC }}
          UNITY_EMAIL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/username"
          UNITY_PASSWORD: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/credential"
          UNITY_SERIAL: "op://${{ vars.OP_VAULT_ACTIONS_PUBLIC }}/UNITY_LICENSE/serial"

      - uses: Cysharp/Actions/.github/actions/checkout@main
        with:
          ref: ${{ needs.update-packagejson.outputs.sha }}
      # Execute scripts: Export Package
      # /opt/Unity/Editor/Unity -quit -batchmode -nographics -silent-crashes -logFile -projectPath . -executeMethod PackageExporter.Export
      - name: Build Unity (.unitypacakge)
        uses: Cysharp/Actions/.github/actions/unity-builder@main
        env:
          UNITY_EMAIL: ${{ steps.op-load-secret.outputs.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ steps.op-load-secret.outputs.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ steps.op-load-secret.outputs.UNITY_SERIAL }}
          UNITY_PACKAGE_VERSION: ${{ inputs.tag }}
        with:
          projectPath: src/ZString.Unity
          unityVersion: ${{ matrix.unity }}
          targetPlatform: StandaloneLinux64
          buildMethod: PackageExporter.Export

      - uses: Cysharp/Actions/.github/actions/check-metas@main # check meta files
        with:
          directory: src/ZString.Unity

      # Store artifacts.
      - uses: Cysharp/Actions/.github/actions/upload-artifact@main
        with:
          name: ZString.Unity.${{ inputs.tag }}.unitypackage
          path: ./src/ZString.Unity/ZString.Unity.${{ inputs.tag }}.unitypackage
          retention-days: 1

  create-release:
    needs: [update-packagejson, build-dotnet, build-unity]
    permissions:
      contents: write
      id-token: write # required for NuGet Trusted Publish
    uses: Cysharp/Actions/.github/workflows/create-release.yaml@main
    with:
      commit-id: ${{ needs.update-packagejson.outputs.sha }}
      tag: ${{ inputs.tag }}
      dry-run: ${{ inputs.dry-run }}
      nuget-push: true
      release-upload: true
      release-asset-path: ./ZString.Unity.${{ inputs.tag }}.unitypackage/ZString.Unity.${{ inputs.tag }}.unitypackage
    secrets: inherit

  cleanup:
    if: ${{ needs.update-packagejson.outputs.is-branch-created == 'true' }}
    needs: [update-packagejson, build-dotnet, build-unity]
    permissions:
      contents: write
    uses: Cysharp/Actions/.github/workflows/clean-packagejson-branch.yaml@main
    with:
      branch: ${{ needs.update-packagejson.outputs.branch-name }}



================================================
FILE: .github/workflows/prevent-github-change.yaml
================================================
name: Prevent github change
on:
  pull_request:
    paths:
      - ".github/**/*.yaml"
      - ".github/**/*.yml"

jobs:
  detect:
    permissions:
      contents: read
    uses: Cysharp/Actions/.github/workflows/prevent-github-change.yaml@main



================================================
FILE: .github/workflows/stale.yaml
================================================
name: "Close stale issues"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *"

jobs:
  stale:
    permissions:
      contents: read
      pull-requests: write
      issues: write
    uses: Cysharp/Actions/.github/workflows/stale-issue.yaml@main



================================================
FILE: .github/workflows/toc.yaml
================================================
name: TOC Generator

on:
  push:
    paths:
      - 'README.md'

jobs:
  toc:
    permissions:
      contents: write
    uses: Cysharp/Actions/.github/workflows/toc-generator.yaml@main
    with:
      TOC_TITLE: "## Table of Contents"
    secrets: inherit


